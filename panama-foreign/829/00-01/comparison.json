{"files":[{"patch":"@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -22,1 +22,1 @@\n-message=Merge\n+message=Merge .*\n@@ -30,3 +30,0 @@\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n","filename":".jcheck\/conf","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -13,0 +13,14 @@\n+\n+---\n+Foreign Function & Memory API\n+\n+This repository contains changes which aim at improving the interoperability between the Java programming language and native libraries, which is one of the main goals of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/). This is done by introducing a new Java API, the Foreign Function & Memory API, which can be used to:\n+\n+* interact with different kinds of memory resources, including so-called off-heap or native memory, as shown [here](doc\/panama_memaccess.md);\n+* find native functions in a .dll\/.so\/.dylib and invoke them using method handles, as shown [here](doc\/panama_ffi.md).\n+\n+This API has been delivered, as incubating\/preview APIs, in official JDK releases, see [JEP 412](https:\/\/openjdk.java.net\/jeps\/412), [JEP 419](https:\/\/openjdk.java.net\/jeps\/419) and [JEP 424](https:\/\/openjdk.java.net\/jeps\/424) for more details.\n+\n+The Foreign Function & Memory API is best used in combination with a tool called `jextract`, which can be used to generate Java bindings to access functions and\/or structs in a native library described by a given header file. The tool is available in a standalone [repository](https:\/\/github.com\/openjdk\/jextract) which contains several [examples](https:\/\/github.com\/openjdk\/jextract\/tree\/master\/samples) which should help you getting started.\n+\n+Early acccess (EA) binary snapshots of this repository can be found at: http:\/\/jdk.java.net\/panama\/\n","filename":"README.md","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,693 @@\n+<!doctype html>\n+<html>\n+<head>\n+<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>\n+\n+<link href='https:\/\/fonts.loli.net\/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text\/css' \/><style type='text\/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:\"Lucida Console\",Consolas,\"Courier\",monospace; --title-bar-height:20px; }\n+.mac-os-11 { --title-bar-height:28px; }\n+html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }\n+body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }\n+iframe { margin: auto; }\n+a.url { word-break: break-all; }\n+a:active, a:hover { outline: 0px; }\n+.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }\n+#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }\n+#write.first-line-indent p { text-indent: 2em; }\n+#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }\n+#write.first-line-indent li { margin-left: 2em; }\n+.for-image #write { padding-left: 8px; padding-right: 8px; }\n+body.typora-export { padding-left: 30px; padding-right: 30px; }\n+.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }\n+.typora-export .task-list-item input { pointer-events: none; }\n+@media screen and (max-width: 500px) {\n+  body.typora-export { padding-left: 0px; padding-right: 0px; }\n+  #write { padding-left: 20px; padding-right: 20px; }\n+}\n+#write li > figure:last-child { margin-bottom: 0.5rem; }\n+#write ol, #write ul { position: relative; }\n+img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }\n+button, input, select, textarea { color: inherit; font: inherit; }\n+input[type=\"checkbox\"], input[type=\"radio\"] { line-height: normal; padding: 0px; }\n+*, ::after, ::before { box-sizing: border-box; }\n+#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }\n+#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }\n+p { line-height: inherit; }\n+h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }\n+p { orphans: 4; }\n+h1 { font-size: 2rem; }\n+h2 { font-size: 1.8rem; }\n+h3 { font-size: 1.6rem; }\n+h4 { font-size: 1.4rem; }\n+h5 { font-size: 1.2rem; }\n+h6 { font-size: 1rem; }\n+.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }\n+.hidden { display: none; }\n+.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }\n+a { cursor: pointer; }\n+sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }\n+sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }\n+#write input[type=\"checkbox\"] { cursor: pointer; width: inherit; height: inherit; }\n+figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }\n+figure > table { margin: 0px; }\n+thead, tr { break-inside: avoid; break-after: auto; }\n+thead { display: table-header-group; }\n+table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }\n+table.md-table td { min-width: 32px; }\n+.CodeMirror-gutters { border-right: 0px; background-color: inherit; }\n+.CodeMirror-linenumber { user-select: none; }\n+.CodeMirror { text-align: left; }\n+.CodeMirror-placeholder { opacity: 0.3; }\n+.CodeMirror pre { padding: 0px 4px; }\n+.CodeMirror-lines { padding: 0px; }\n+div.hr:focus { cursor: none; }\n+#write pre { white-space: pre-wrap; }\n+#write.fences-no-line-wrapping pre { white-space: pre; }\n+#write pre.ty-contain-cm { white-space: normal; }\n+.CodeMirror-gutters { margin-right: 4px; }\n+.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }\n+.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }\n+#write .md-fences.mock-cm { white-space: pre-wrap; }\n+.md-fences.md-fences-with-lineno { padding-left: 0px; }\n+#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }\n+.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }\n+.CodeMirror-line, twitterwidget { break-inside: avoid; }\n+svg { break-inside: avoid; }\n+.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }\n+.footnotes + .footnotes { margin-top: 0px; }\n+.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }\n+li div { padding-top: 0px; }\n+blockquote { margin: 1rem 0px; }\n+li .mathjax-block, li p { margin: 0.5rem 0px; }\n+li blockquote { margin: 1rem 0px; }\n+li { margin: 0px; position: relative; }\n+blockquote > :last-child { margin-bottom: 0px; }\n+blockquote > :first-child, li > :first-child { margin-top: 0px; }\n+.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }\n+#write .footnote-line { white-space: pre-wrap; }\n+@media print {\n+  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }\n+  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; padding-bottom: 0px !important; }\n+  .typora-export * { -webkit-print-color-adjust: exact; }\n+  .typora-export #write { break-after: avoid; }\n+  .typora-export #write::after { height: 0px; }\n+  .is-mac table { break-inside: avoid; }\n+  .typora-export-show-outline .typora-export-sidebar { display: none; }\n+}\n+.footnote-line { margin-top: 0.714em; font-size: 0.7em; }\n+a img, img a { cursor: pointer; }\n+pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }\n+p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }\n+#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }\n+p > .md-image:only-child { display: inline-block; width: 100%; }\n+#write .MathJax_Display { margin: 0.8em 0px 0px; }\n+.md-math-block { width: 100%; }\n+.md-math-block:not(:empty)::after { display: none; }\n+.MathJax_ref { fill: currentcolor; }\n+[contenteditable=\"true\"]:active, [contenteditable=\"true\"]:focus, [contenteditable=\"false\"]:active, [contenteditable=\"false\"]:focus { outline: 0px; box-shadow: none; }\n+.md-task-list-item { position: relative; list-style-type: none; }\n+.task-list-item.md-task-list-item { padding-left: 0px; }\n+.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }\n+.math { font-size: 1rem; }\n+.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }\n+.md-toc-content { position: relative; margin-left: 0px; }\n+.md-toc-content::after, .md-toc::after { display: none; }\n+.md-toc-item { display: block; color: rgb(65, 131, 196); }\n+.md-toc-item a { text-decoration: none; }\n+.md-toc-inner:hover { text-decoration: underline; }\n+.md-toc-inner { display: inline-block; cursor: pointer; }\n+.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }\n+.md-toc-h2 .md-toc-inner { margin-left: 2em; }\n+.md-toc-h3 .md-toc-inner { margin-left: 4em; }\n+.md-toc-h4 .md-toc-inner { margin-left: 6em; }\n+.md-toc-h5 .md-toc-inner { margin-left: 8em; }\n+.md-toc-h6 .md-toc-inner { margin-left: 10em; }\n+@media screen and (max-width: 48em) {\n+  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }\n+  .md-toc-h4 .md-toc-inner { margin-left: 5em; }\n+  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }\n+  .md-toc-h6 .md-toc-inner { margin-left: 8em; }\n+}\n+a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }\n+.footnote-line a:not(.reversefootnote) { color: inherit; }\n+.reversefootnote { font-family: ui-monospace, sans-serif; }\n+.md-attr { display: none; }\n+.md-fn-count::after { content: \".\"; }\n+code, pre, samp, tt { font-family: var(--monospace); }\n+kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }\n+.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }\n+code { text-align: left; vertical-align: initial; }\n+a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }\n+.os-windows.monocolor-emoji .md-emoji { font-family: \"Segoe UI Symbol\", sans-serif; }\n+.md-diagram-panel > svg { max-width: 100%; }\n+[lang=\"flow\"] svg, [lang=\"mermaid\"] svg { max-width: 100%; height: auto; }\n+[lang=\"mermaid\"] .node text { font-size: 1rem; }\n+table tr th { border-bottom: 0px; }\n+video { max-width: 100%; display: block; margin: 0px auto; }\n+iframe { max-width: 100%; width: 100%; border: none; }\n+.highlight td, .highlight tr { border: 0px; }\n+mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }\n+.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }\n+.md-expand mark .md-meta { opacity: 0.3 !important; }\n+mark .md-meta { color: rgb(0, 0, 0); }\n+@media print {\n+  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }\n+}\n+.md-diagram-panel .messageText { stroke: none !important; }\n+.md-diagram-panel .start-state { fill: var(--node-fill); }\n+.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }\n+.md-fences.md-fences-math { font-size: 1em; }\n+.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }\n+.md-fences-advanced:not(.md-focus) { background: inherit; }\n+.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }\n+.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }\n+.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }\n+.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }\n+@media screen and (max-width: 1024px) {\n+  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }\n+}\n+@media screen and (max-width: 800px) {\n+  .typora-export-sidebar { display: none; }\n+}\n+.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }\n+.outline-content ul { margin-top: 0px; margin-bottom: 0px; }\n+.outline-content strong { font-weight: 400; }\n+.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }\n+.outline-expander::before { content: \"\"; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }\n+.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }\n+.outline-expander:hover::before { content: \"\"; }\n+.outline-h1 > .outline-item { padding-left: 0px; }\n+.outline-h2 > .outline-item { padding-left: 1em; }\n+.outline-h3 > .outline-item { padding-left: 2em; }\n+.outline-h4 > .outline-item { padding-left: 3em; }\n+.outline-h5 > .outline-item { padding-left: 4em; }\n+.outline-h6 > .outline-item { padding-left: 5em; }\n+.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }\n+.outline-label:hover { text-decoration: underline; }\n+.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }\n+.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }\n+.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }\n+.outline-item-open > .outline-item > .outline-expander::before { content: \"\"; }\n+.outline-children { display: none; }\n+.info-panel-tab-wrapper { display: none; }\n+.outline-item-open > .outline-children { display: block; }\n+.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }\n+.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }\n+.typora-export .outline-expander::before { content: \"+\"; font-family: inherit; top: -1px; }\n+.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: \"−\"; }\n+.typora-export-collapse-outline .outline-children { display: none; }\n+.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }\n+.typora-export-no-collapse-outline .outline-expander::before { content: \"\" !important; }\n+.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }\n+.md-inline-math-container mjx-container { zoom: 0.95; }\n+mjx-container { break-inside: avoid; }\n+\n+\n+.CodeMirror { height: auto; }\n+.CodeMirror.cm-s-inner { background: inherit; }\n+.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }\n+.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }\n+.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }\n+.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }\n+.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }\n+.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }\n+.cm-s-inner .cm-number { color: rgb(17, 102, 68); }\n+.cm-s-inner .cm-def { color: rgb(0, 0, 255); }\n+.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }\n+.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }\n+.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }\n+.cm-s-inner .cm-string { color: rgb(170, 17, 17); }\n+.cm-s-inner .cm-property { color: rgb(0, 0, 0); }\n+.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }\n+.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }\n+.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }\n+.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }\n+.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }\n+.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }\n+.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }\n+.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }\n+.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }\n+.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }\n+.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }\n+.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }\n+.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }\n+.cm-negative { color: rgb(221, 68, 68); }\n+.cm-positive { color: rgb(34, 153, 34); }\n+.cm-header, .cm-strong { font-weight: 700; }\n+.cm-del { text-decoration: line-through; }\n+.cm-em { font-style: italic; }\n+.cm-link { text-decoration: underline; }\n+.cm-error { color: red; }\n+.cm-invalidchar { color: red; }\n+.cm-constant { color: rgb(38, 139, 210); }\n+.cm-defined { color: rgb(181, 137, 0); }\n+div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }\n+div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }\n+.cm-s-inner .CodeMirror-activeline-background { background: inherit; }\n+.CodeMirror { position: relative; overflow: hidden; }\n+.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }\n+.CodeMirror-sizer { position: relative; }\n+.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }\n+.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }\n+.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }\n+.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }\n+.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }\n+.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }\n+.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }\n+.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }\n+.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }\n+.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }\n+.CodeMirror-lines { cursor: text; }\n+.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }\n+.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }\n+.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }\n+.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }\n+.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }\n+.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }\n+.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }\n+.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }\n+.CodeMirror-measure pre { position: static; }\n+.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }\n+.CodeMirror div.CodeMirror-cursor { visibility: hidden; }\n+.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }\n+.cm-searching { background: rgba(255, 255, 0, 0.4); }\n+span.cm-underlined { text-decoration: underline; }\n+span.cm-strikethrough { text-decoration: line-through; }\n+.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }\n+.cm-tw-deleted { text-decoration: line-through; }\n+.cm-tw-header5 { font-weight: 700; }\n+.cm-tw-listitem:first-child { padding-left: 10px; }\n+.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }\n+.cm-tw-underline { text-decoration: underline; }\n+@media print {\n+  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }\n+}\n+\n+\n+:root {\n+    --side-bar-bg-color: #fafafa;\n+    --control-text-color: #777;\n+}\n+\n+@include-when-export url(https:\/\/fonts.loli.net\/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);\n+\n+\/* open-sans-regular - latin-ext_latin *\/\n+  \/* open-sans-italic - latin-ext_latin *\/\n+    \/* open-sans-700 - latin-ext_latin *\/\n+    \/* open-sans-700italic - latin-ext_latin *\/\n+  html {\n+    font-size: 16px;\n+    -webkit-font-smoothing: antialiased;\n+}\n+\n+body {\n+    font-family: \"Open Sans\",\"Clear Sans\", \"Helvetica Neue\", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;\n+    color: rgb(51, 51, 51);\n+    line-height: 1.6;\n+}\n+\n+#write {\n+    max-width: 860px;\n+  \tmargin: 0 auto;\n+  \tpadding: 30px;\n+    padding-bottom: 100px;\n+}\n+\n+@media only screen and (min-width: 1400px) {\n+\t#write {\n+\t\tmax-width: 1024px;\n+\t}\n+}\n+\n+@media only screen and (min-width: 1800px) {\n+\t#write {\n+\t\tmax-width: 1200px;\n+\t}\n+}\n+\n+#write > ul:first-child,\n+#write > ol:first-child{\n+    margin-top: 30px;\n+}\n+\n+a {\n+    color: #4183C4;\n+}\n+h1,\n+h2,\n+h3,\n+h4,\n+h5,\n+h6 {\n+    position: relative;\n+    margin-top: 1rem;\n+    margin-bottom: 1rem;\n+    font-weight: bold;\n+    line-height: 1.4;\n+    cursor: text;\n+}\n+h1:hover a.anchor,\n+h2:hover a.anchor,\n+h3:hover a.anchor,\n+h4:hover a.anchor,\n+h5:hover a.anchor,\n+h6:hover a.anchor {\n+    text-decoration: none;\n+}\n+h1 tt,\n+h1 code {\n+    font-size: inherit;\n+}\n+h2 tt,\n+h2 code {\n+    font-size: inherit;\n+}\n+h3 tt,\n+h3 code {\n+    font-size: inherit;\n+}\n+h4 tt,\n+h4 code {\n+    font-size: inherit;\n+}\n+h5 tt,\n+h5 code {\n+    font-size: inherit;\n+}\n+h6 tt,\n+h6 code {\n+    font-size: inherit;\n+}\n+h1 {\n+    font-size: 2.25em;\n+    line-height: 1.2;\n+    border-bottom: 1px solid #eee;\n+}\n+h2 {\n+    font-size: 1.75em;\n+    line-height: 1.225;\n+    border-bottom: 1px solid #eee;\n+}\n+\n+\/*@media print {\n+    .typora-export h1,\n+    .typora-export h2 {\n+        border-bottom: none;\n+        padding-bottom: initial;\n+    }\n+\n+    .typora-export h1::after,\n+    .typora-export h2::after {\n+        content: \"\";\n+        display: block;\n+        height: 100px;\n+        margin-top: -96px;\n+        border-top: 1px solid #eee;\n+    }\n+}*\/\n+\n+h3 {\n+    font-size: 1.5em;\n+    line-height: 1.43;\n+}\n+h4 {\n+    font-size: 1.25em;\n+}\n+h5 {\n+    font-size: 1em;\n+}\n+h6 {\n+   font-size: 1em;\n+    color: #777;\n+}\n+p,\n+blockquote,\n+ul,\n+ol,\n+dl,\n+table{\n+    margin: 0.8em 0;\n+}\n+li>ol,\n+li>ul {\n+    margin: 0 0;\n+}\n+hr {\n+    height: 2px;\n+    padding: 0;\n+    margin: 16px 0;\n+    background-color: #e7e7e7;\n+    border: 0 none;\n+    overflow: hidden;\n+    box-sizing: content-box;\n+}\n+\n+li p.first {\n+    display: inline-block;\n+}\n+ul,\n+ol {\n+    padding-left: 30px;\n+}\n+ul:first-child,\n+ol:first-child {\n+    margin-top: 0;\n+}\n+ul:last-child,\n+ol:last-child {\n+    margin-bottom: 0;\n+}\n+blockquote {\n+    border-left: 4px solid #dfe2e5;\n+    padding: 0 15px;\n+    color: #777777;\n+}\n+blockquote blockquote {\n+    padding-right: 0;\n+}\n+table {\n+    padding: 0;\n+    word-break: initial;\n+}\n+table tr {\n+    border: 1px solid #dfe2e5;\n+    margin: 0;\n+    padding: 0;\n+}\n+table tr:nth-child(2n),\n+thead {\n+    background-color: #f8f8f8;\n+}\n+table th {\n+    font-weight: bold;\n+    border: 1px solid #dfe2e5;\n+    border-bottom: 0;\n+    margin: 0;\n+    padding: 6px 13px;\n+}\n+table td {\n+    border: 1px solid #dfe2e5;\n+    margin: 0;\n+    padding: 6px 13px;\n+}\n+table th:first-child,\n+table td:first-child {\n+    margin-top: 0;\n+}\n+table th:last-child,\n+table td:last-child {\n+    margin-bottom: 0;\n+}\n+\n+.CodeMirror-lines {\n+    padding-left: 4px;\n+}\n+\n+.code-tooltip {\n+    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);\n+    border-top: 1px solid #eef2f2;\n+}\n+\n+.md-fences,\n+code,\n+tt {\n+    border: 1px solid #e7eaed;\n+    background-color: #f8f8f8;\n+    border-radius: 3px;\n+    padding: 0;\n+    padding: 2px 4px 0px 4px;\n+    font-size: 0.9em;\n+}\n+\n+code {\n+    background-color: #f3f4f4;\n+    padding: 0 2px 0 2px;\n+}\n+\n+.md-fences {\n+    margin-bottom: 15px;\n+    margin-top: 15px;\n+    padding-top: 8px;\n+    padding-bottom: 6px;\n+}\n+\n+\n+.md-task-list-item > input {\n+  margin-left: -1.3em;\n+}\n+\n+@media print {\n+    html {\n+        font-size: 13px;\n+    }\n+    pre {\n+        page-break-inside: avoid;\n+        word-wrap: break-word;\n+    }\n+}\n+\n+.md-fences {\n+\tbackground-color: #f8f8f8;\n+}\n+#write pre.md-meta-block {\n+\tpadding: 1rem;\n+    font-size: 85%;\n+    line-height: 1.45;\n+    background-color: #f7f7f7;\n+    border: 0;\n+    border-radius: 3px;\n+    color: #777777;\n+    margin-top: 0 !important;\n+}\n+\n+.mathjax-block>.code-tooltip {\n+\tbottom: .375rem;\n+}\n+\n+.md-mathjax-midline {\n+    background: #fafafa;\n+}\n+\n+#write>h3.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .375rem;\n+}\n+#write>h4.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .285714286rem;\n+}\n+#write>h5.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .285714286rem;\n+}\n+#write>h6.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .285714286rem;\n+}\n+.md-image>.md-meta {\n+    \/*border: 1px solid #ddd;*\/\n+    border-radius: 3px;\n+    padding: 2px 0px 0px 4px;\n+    font-size: 0.9em;\n+    color: inherit;\n+}\n+\n+.md-tag {\n+    color: #a7a7a7;\n+    opacity: 1;\n+}\n+\n+.md-toc { \n+    margin-top:20px;\n+    padding-bottom:20px;\n+}\n+\n+.sidebar-tabs {\n+    border-bottom: none;\n+}\n+\n+#typora-quick-open {\n+    border: 1px solid #ddd;\n+    background-color: #f8f8f8;\n+}\n+\n+#typora-quick-open-item {\n+    background-color: #FAFAFA;\n+    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;\n+    border-style: solid;\n+    border-width: 1px;\n+}\n+\n+\/** focus mode *\/\n+.on-focus-mode blockquote {\n+    border-left-color: rgba(85, 85, 85, 0.12);\n+}\n+\n+header, .context-menu, .megamenu-content, footer{\n+    font-family: \"Segoe UI\", \"Arial\", sans-serif;\n+}\n+\n+.file-node-content:hover .file-node-icon,\n+.file-node-content:hover .file-node-open-state{\n+    visibility: visible;\n+}\n+\n+.mac-seamless-mode #typora-sidebar {\n+    background-color: #fafafa;\n+    background-color: var(--side-bar-bg-color);\n+}\n+\n+.md-lang {\n+    color: #b4654d;\n+}\n+\n+\/*.html-for-mac {\n+    --item-hover-bg-color: #E6F0FE;\n+}*\/\n+\n+#md-notification .btn {\n+    border: 0;\n+}\n+\n+.dropdown-menu .divider {\n+    border-color: #e5e5e5;\n+    opacity: 0.4;\n+}\n+\n+.ty-preferences .window-content {\n+    background-color: #fafafa;\n+}\n+\n+.ty-preferences .nav-group-item.active {\n+    color: white;\n+    background: #999;\n+}\n+\n+.menu-item-container a.menu-style-btn {\n+    background-color: #f5f8fa;\n+    background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); \n+}\n+\n+\n+\n+<\/style><title>panama_ffi<\/title>\n+<\/head>\n+<body class='typora-export'><div class='typora-export-content'>\n+<div id='write'  class=''><h2 id='state-of-foreign-function-support'><span>State of foreign function support<\/span><\/h2><p><strong><span>January 2023<\/span><\/strong><\/p><p><strong><span>Maurizio Cimadamore<\/span><\/strong><\/p><p><span>The Foreign Function &amp; Memory API (FFM API in short) provides access to foreign functions through the <\/span><code>Linker<\/code><span> interface, which has been available as an <\/span><a href='https:\/\/openjdk.java.net\/jeps\/11'><span>incubating<\/span><\/a><span> API since Java <\/span><a href='https:\/\/openjdk.java.net\/jeps\/389'><span>16<\/span><\/a><span>. A linker allows clients to construct <\/span><em><span>downcall<\/span><\/em><span> method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, FFM API&#39;s foreign function support is completely expressed in terms of Java code and no intermediate native code is required.<\/span><\/p><h3 id='zero-length-memory-segments'><span>Zero-length memory segments<\/span><\/h3><p><span>Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the <\/span><a href='panama_memaccess.md'><span>foreign memory access support<\/span><\/a><span>. The Foreign Memory Access API allows client to create and manipulate <\/span><em><span>memory segments<\/span><\/em><span>. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always <\/span><em><span>safe<\/span><\/em><span>, and can never result in a VM crash, or, worse, in silent memory corruption.<\/span><\/p><p><span>Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known <\/span><em><span>in full<\/span><\/em><span> when the segment is created. But when we interact with native libraries we often receive <\/span><em><span>raw<\/span><\/em><span> pointers; such pointers have no spatial bounds (does a <\/span><code>char*<\/code><span> in C refer to one <\/span><code>char<\/code><span>, or a <\/span><code>char<\/code><span> array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in the FFM API are modelled using <\/span><em><span>zero-length memory segments<\/span><\/em><span>.<\/span><\/p><p><span>If clients want to dereference a zero-length memory segment, they can do so <\/span><em><span>unsafely<\/span><\/em><span> in two ways. First, the client can create a new memory segment from the zero-length memory segment <\/span><em><span>unsafely<\/span><\/em><span>, using the <\/span><code>MemorySegment::ofAddress<\/code><span> factory. This method is <\/span><em><span>restricted<\/span><\/em><span> and will generate runtime warnings if called without specifying the <\/span><code>--enable-native-access<\/code><span> command-line flag. By calling <\/span><code>MemorySegment::ofAddress<\/code><span> a client inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 758.438px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">raw<\/span> <span class=\"cm-operator\">=<\/span> ... <span class=\"cm-comment\">\/\/obtain address from native code<\/span><\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">segment<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MemorySegment<\/span>.<span class=\"cm-variable\">ofAddress<\/span>(<span class=\"cm-variable\">raw<\/span>.<span class=\"cm-variable\">address<\/span>(), <span class=\"cm-number\">100<\/span>, <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">x<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">segment<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>Alternatively, clients can obtain an <\/span><em><span>unbounded<\/span><\/em><span> address value layout. This is done using the <\/span><code>ValueLayout.OfAddress::asUnbounded<\/code><span> method (which is also a restricted method). When an access operation uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments with <\/span><em><span>maximal<\/span><\/em><span> size (i.e. <\/span><code>Long.MAX_VALUE<\/code><span>). As such, these segments can be accessed directly, as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 1138.39px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">foreign<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">someSegment<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">ValueLayout<\/span>.<span class=\"cm-variable\">ADDRESS<\/span>.<span class=\"cm-variable\">asUnbounded<\/span>(), <span class=\"cm-number\">0<\/span>); <span class=\"cm-comment\">\/\/ wrap address into segment (size = Long.MAX_VALUE)<\/span><\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">x<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">ValueLayout<\/span>.<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>); <span class=\"cm-comment\">\/\/ok<\/span><\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 46px;\"><\/div><\/div><\/div><\/pre><p><span>Which approach is taken largely depends on the information that a client has available when obtaining a memory segment wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.<\/span><\/p><h3 id='segment-allocators'><span>Segment allocators<\/span><\/h3><p><span>Idiomatic C code implicitly relies on stack allocation to allow for concise variable declarations; consider this example:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 267.219px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 266.219px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">arr<\/span>[] <span class=\"cm-operator\">=<\/span> { <span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span> };<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>A variable initializer such as the one above can be implemented as follows, using the Foreign Memory Access API:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 957.078px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span> <span class=\"cm-def\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">arr<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MemorySegment<\/span>.<span class=\"cm-variable\">allocateNative<\/span>(<span class=\"cm-variable\">MemoryLayout<\/span>.<span class=\"cm-variable\">sequenceLayout<\/span>(<span class=\"cm-number\">5<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>), <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">for<\/span> (<span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-number\">0<\/span> ; <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">&lt;<\/span> <span class=\"cm-number\">5<\/span> ; <span class=\"cm-variable\">i<\/span><span class=\"cm-operator\">++<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">arr<\/span>.<span class=\"cm-variable\">setAtIndex<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">i<\/span>, <span class=\"cm-variable\">i<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 138px;\"><\/div><\/div><\/div><\/pre><p><span>There are a number of issues with the above code snippet:<\/span><\/p><ul><li><span>compared to the C code, it is more verbose — the native array has to be initialized <\/span><em><span>element by element<\/span><\/em><\/li><li><span>allocation is very slow compared to C; allocating the <\/span><code>arr<\/code><span> variable now takes a full <\/span><code>malloc<\/code><span>, while in C the variable was simply stack-allocated<\/span><\/li><li><span>when having multiple declarations like the one above, it might become increasingly harder to manage the lifecycle of the various segments<\/span><\/li><\/ul><p><span>To address these problems, the FFM API provides a <\/span><code>SegmentAllocator<\/code><span> abstraction, a functional interface which provides methods to allocate commonly used values. Since <\/span><code>Arena<\/code><span> implements the <\/span><code>SegmentAllocator<\/code><span> interface, the above code can be rewritten conveniently as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 55.6172px; left: 241.188px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 603.016px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">arr<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>);<\/span><\/pre><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">} <span class=\"cm-comment\">\/\/ 'arr' is released here<\/span><\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 69px;\"><\/div><\/div><\/div><\/pre><p><span>In the above code, the arena acts as a <\/span><em><span>native<\/span><\/em><span> allocator (that is, an allocator built on top of <\/span><code>MemorySegment::allocateNative<\/code><span>). The arena is then used to create a native array, initialized to the values <\/span><code>0, 1, 2, 3, 4<\/code><span>.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied <\/span><em><span>in bulk<\/span><\/em><span> into the memory region associated with the newly allocated memory segment. The returned segment is associated with the scope of the arena which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.<\/span><\/p><p><span>Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the <\/span><code>SegmentAllocator<\/code><span> interface. For example, the following code creates a <\/span><em><span>slicing<\/span><\/em><span> allocator and uses it to allocate a segment whose content is initialized from a Java <\/span><code>int<\/code><span> array:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 170.852px; left: 379.359px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 784.406px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">SegmentAllocator<\/span> <span class=\"cm-variable\">allocator<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">SegmentAllocator<\/span>.<span class=\"cm-variable\">slicingAllocator<\/span>(<span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocate<\/span>(<span class=\"cm-number\">1024<\/span>));<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">for<\/span> (<span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-number\">0<\/span> ; <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">&lt;<\/span> <span class=\"cm-number\">10<\/span> ; <span class=\"cm-variable\">i<\/span><span class=\"cm-operator\">++<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">s<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">allocator<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>,  <span class=\"cm-keyword\">new<\/span> <span class=\"cm-variable-3\">int<\/span>[] { <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>, <span class=\"cm-number\">5<\/span> });<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        ...<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    ...<\/span><\/pre><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"> } <span class=\"cm-comment\">\/\/ all memory allocated is released here<\/span><\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 184px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 184px;\"><\/div><\/div><\/div><\/pre><p><span>This code creates a native segment whose size is 1024 bytes. The segment is then used to create a slicing allocator, which responds to  allocation requests by returning slices of that pre-allocated segment.  If the current segment does not have sufficient space to accommodate an  allocation request, an exception is thrown. All of the memory associated with the segments created by the allocator (i.e., in the body of the  for loop) is deallocated atomically when the arena is closed. This  technique combines the advantages of deterministic deallocation,  provided by the <\/span><code>Arena<\/code><span> abstraction, with a more flexible and scalable allocation scheme. It can be very useful when writing code  which manages a large number of off-heap segments.<\/span><\/p><p><span>All the methods in the FFM API which <\/span><em><span>produce<\/span><\/em><span> memory segments (see <\/span><code>VaList::nextVarg<\/code><span> and downcall method handles), allow for an allocator parameter to be provided — this is key in ensuring that an application using the FFM API achieves optimal allocation performances, especially in non-trivial use cases.<\/span><\/p><h3 id='symbol-lookups'><span>Symbol lookups<\/span><\/h3><p><span>The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the <\/span><code>System::loadLibrary<\/code><span> and <\/span><code>System::load<\/code><span> methods. Unfortunately, these methods do not provide a way for clients to obtain the <\/span><em><span>address<\/span><\/em><span> associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely <\/span><code>SymbolLookup<\/code><span> (similar in spirit to a method handle lookup), which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 3 different ways:<\/span><\/p><ul><li><code>SymbolLookup::libraryLookup(String, SegmentScope)<\/code><span> — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is not longer alive, the library referred to by the lookup will also be closed;<\/span><\/li><li><code>SymbolLookup::loaderLookup<\/code><span> — creates a symbol lookup which can be used to search symbols in all the libraries loaded by the caller&#39;s classloader (e.g. using <\/span><code>System::loadLibrary<\/code><span> or <\/span><code>System::load<\/code><span>)<\/span><\/li><li><code>Linker::defaultLookup<\/code><span> — returns the default symbol lookup associated with a <\/span><code>Linker<\/code><span> instance. For instance, the default lookup of the native linker (see <\/span><code>Linker::nativeLinker<\/code><span>) can be used to look up platform-specific symbols in the standard C library (such as <\/span><code>strlen<\/code><span>, or <\/span><code>getpid<\/code><span>).<\/span><\/li><\/ul><p><span>Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the <\/span><code>find(String)<\/code><span> method, which returns an <\/span><code>Optional&lt;MemorySegment&gt;<\/code><span>.  The memory segments returned by the <\/span><code>lookup<\/code><span> are zero-length segments, whose base address is the address of the function or variable in the library.<\/span><\/p><p><span>For instance, the following code can be used to look up the <\/span><code>clang_getClangVersion<\/code><span> function provided by the <\/span><code>clang<\/code><span> library; it does so by creating a <\/span><em><span>library lookup<\/span><\/em><span> whose lifecycle is associated to that of a confined arena.<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 741.141px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">SymbolLookup<\/span> <span class=\"cm-variable\">libclang<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">SymbolLookup<\/span>.<span class=\"cm-variable\">libraryLookup<\/span>(<span class=\"cm-string\">\"libclang.so\"<\/span>, <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">clangVersion<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">libclang<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"clang_getClangVersion\"<\/span>).<span class=\"cm-variable\">get<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 92px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 92px;\"><\/div><\/div><\/div><\/pre><h3 id='linker'><span>Linker<\/span><\/h3><p><span>At the core of the FFM API&#39;s foreign function support we find the <\/span><code>Linker<\/code><span> abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling foreign function calls as plain <\/span><code>MethodHandle<\/code><span> calls (see <\/span><code>Linker::downcallHandle<\/code><span>); second, for upcalls, it allows to convert an existing <\/span><code>MethodHandle<\/code><span> (which might point to some Java method) into a <\/span><code>MemorySegment<\/code><span> which could then be passed to foreign functions as a function pointer (see <\/span><code>Linker::upcallStub<\/code><span>):<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 862.062px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><span><span>​<\/span>x<\/span><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">interface<\/span> <span class=\"cm-def\">Linker<\/span> {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">downcallHandle<\/span>(<span class=\"cm-variable\">Addressable<\/span> <span class=\"cm-variable\">symbol<\/span>, <span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">function<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">upcallStub<\/span>(<span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">target<\/span>, <span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">function<\/span>, <span class=\"cm-variable\">SegmentScope<\/span> <span class=\"cm-variable\">scope<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    ... <span class=\"cm-comment\">\/\/ some overloads omitted here<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">nativeLinker<\/span>() { ... }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 161px;\"><\/div><\/div><\/div><\/pre><p><span>Both functions take a <\/span><code>FunctionDescriptor<\/code><span> instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are <\/span><em><span>value layouts<\/span><\/em><span> (for scalars and pointers) and <\/span><em><span>group layouts<\/span><\/em><span> (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java <\/span><code>MethodType<\/code><span>  — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.<\/span><\/p><p><span>The <\/span><code>Linker::nativeLinker<\/code><span> factory is used to obtain a <\/span><code>Linker<\/code><span> implementation for the ABI associated with the OS and processor where the Java runtime is currently executing. As such, the native linker can be used to call C functions. The following table shows the mapping between C types, layouts and Java carriers under the Linux\/macOS native linker implementation; note that the mappings can be platform dependent: on Windows\/x64, the C type <\/span><code>long<\/code><span> is 32-bit, so the <\/span><code>JAVA_INT<\/code><span> layout (and the Java carrier <\/span><code>int.class<\/code><span>) would have to be used instead:<\/span><\/p><figure><table><thead><tr><th><span>C type<\/span><\/th><th><span>Layout<\/span><\/th><th><span>Java carrier<\/span><\/th><\/tr><\/thead><tbody><tr><td><code>bool<\/code><\/td><td><code>JAVA_BOOLEAN<\/code><\/td><td><code>byte<\/code><\/td><\/tr><tr><td><code>char<\/code><\/td><td><code>JAVA_BYTE<\/code><\/td><td><code>byte<\/code><\/td><\/tr><tr><td><code>short<\/code><\/td><td><code>JAVA_SHORT<\/code><\/td><td><code>short<\/code><span>, <\/span><code>char<\/code><\/td><\/tr><tr><td><code>int<\/code><\/td><td><code>JAVA_INT<\/code><\/td><td><code>int<\/code><\/td><\/tr><tr><td><code>long<\/code><\/td><td><code>JAVA_LONG<\/code><\/td><td><code>long<\/code><\/td><\/tr><tr><td><code>long long<\/code><\/td><td><code>JAVA_LONG<\/code><\/td><td><code>long<\/code><\/td><\/tr><tr><td><code>float<\/code><\/td><td><code>JAVA_FLOAT<\/code><\/td><td><code>float<\/code><\/td><\/tr><tr><td><code>double<\/code><\/td><td><code>JAVA_DOUBLE<\/code><\/td><td><code>double<\/code><\/td><\/tr><tr><td><code>char*<\/code><br><code>int**<\/code><br><span> ...<\/span><\/td><td><code>ADDRESS<\/code><\/td><td><code>MemorySegment<\/code><\/td><\/tr><tr><td><code>struct Point { int x; int y; };<\/code><br><code>union Choice { float a; int b; };<\/code><br><span>...<\/span><\/td><td><code>MemoryLayout.structLayout(...)<\/code><br><code>MemoryLayout.unionLayout(...)<\/code><br><\/td><td><code>MemorySegment<\/code><\/td><\/tr><\/tbody><\/table><\/figure><p><span>Both C structs\/unions and pointers are modelled using the <\/span><code>MemorySegment<\/code><span> carrier type. However, C structs\/unions are modelled in function descriptors with memory layouts of type <\/span><code>GroupLayout<\/code><span>, whereas pointers are modelled using the <\/span><code>ADDRESS<\/code><span> value layout constant (whose size is platform-specific). Moreover, the behavior of a downcall method handle returning a struct\/union type is radically different from that of a downcall method handle returning a C pointer:<\/span><\/p><ul><li><span>downcall method handles returning C pointers will wrap the pointer address into a fresh zero-length memory segment (unless an unbounded address layout is specified);<\/span><\/li><li><span>downcall method handles returning a C struct\/union type will return a <\/span><em><span>new<\/span><\/em><span> segment, of given size (the size of the struct\/union). The segment is allocated using a user-provided <\/span><code>SegmentAllocator<\/code><span>, which is provided using an additional prefix parameter inserted in the downcall method handle signature.<\/span><\/li><\/ul><p><span>A tool, such as <\/span><code>jextract<\/code><span>, will generate all the required C layouts (for scalars and structs\/unions) <\/span><em><span>automatically<\/span><\/em><span>, so that clients do not have to worry about platform-dependent details such as sizes, alignment constraints and padding.<\/span><\/p><h3 id='downcalls'><span>Downcalls<\/span><\/h3><p><span>We will now look at how foreign functions can be called from Java using the native linker. Assume we wanted to call the following function from the standard C library:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 257.516px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">size_t<\/span> <span class=\"cm-def\">strlen<\/span>(<span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">char<\/span> <span class=\"cm-variable-3\">*<\/span><span class=\"cm-variable\">s<\/span>);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>In order to do that, we have to:<\/span><\/p><ul><li><span>lookup the <\/span><code>strlen<\/code><span> symbol<\/span><\/li><li><span>describe the signature of the C function using a function descriptor<\/span><\/li><li><span>create a <\/span><em><span>downcall<\/span><\/em><span> native method handle with the above information, using the native linker<\/span><\/li><\/ul><p><span>Here&#39;s an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the <\/span><a href='#appendix-full-source-code'><span>appendix<\/span><\/a><span>):<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 456.156px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">linker<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>Note that, since the function <\/span><code>strlen<\/code><span> is part of the standard C library, which is loaded with the VM, we can just use the default lookup of the native linker to look it up. The rest is pretty straightforward — the only tricky detail is how to model <\/span><code>size_t<\/code><span>: typically this type has the size of a pointer, so we can use <\/span><code>JAVA_LONG<\/code><span> both Linux and Windows. On the Java side, we model the <\/span><code>size_t<\/code><span> using a <\/span><code>long<\/code><span> and the pointer is modelled using an <\/span><code>Addressable<\/code><span> parameter.<\/span><\/p><p><span>Once we have obtained the downcall method handle, we can just use it as any other method handle<\/span><a href=\"#2\"><sup><span>1<\/span><\/sup><\/a><span>:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 602.984px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">strlen<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>)); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 69px;\"><\/div><\/div><\/div><\/pre><p><span>Here we are using a confined arena to convert a Java string into an off-heap memory segment which contains a <\/span><code>NULL<\/code><span> terminated C string. We then pass that segment to the method handle and retrieve our result in a Java <\/span><code>long<\/code><span>. Note how all this is possible <\/span><em><span>without<\/span><\/em><span> any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an arena to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.<\/span><\/p><p><span>The <\/span><code>Linker<\/code><span> interface also supports linking of native functions without an address known at link time; when that happens, an address (of type <\/span><code>MemorySegment<\/code><span>) must be provided when the method handle returned by the linker is invoked — this is very useful to support <\/span><em><span>virtual calls<\/span><\/em><span>. For instance, the above code can be rewritten as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 715.219px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen_virtual<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>( <span class=\"cm-comment\">\/\/ address parameter missing!<\/span><\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span> <span class=\"cm-def\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">strlen_virtual<\/span>.<span class=\"cm-variable\">invoke<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>() <span class=\"cm-comment\">\/\/ address provided here!<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    ); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 230px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 230px;\"><\/div><\/div><\/div><\/pre><p><span>It is important to note that, albeit the interop code is written in Java, the above code can <\/span><em><span>not<\/span><\/em><span> be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Java runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Java runtime has to <\/span><em><span>trust<\/span><\/em><span> the function descriptor passed in<\/span><a href=\"#2\"><sup><span>2<\/span><\/sup><\/a><span>; for this reason, the <\/span><code>Linker::nativeLinker<\/code><span> factory is also a restricted method.<\/span><\/p><p><span>When working with shared arenas, it is always possible for the arena associated with a memory segment passed <\/span><em><span>by reference<\/span><\/em><span> to a native function to be closed (by another thread) <\/span><em><span>while<\/span><\/em><span> the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the <\/span><code>Linker<\/code><span> API provides some basic temporal safety guarantees: any <\/span><code>MemorySegment<\/code><span> instance passed by reference to a downcall method handle will be <\/span><em><span>kept alive<\/span><\/em><span> for the entire duration of the call. In other words, it&#39;s as if the call to the downcall method handle occurred inside an invisible call to <\/span><code>SegmentScope::whileAlive<\/code><span>.<\/span><\/p><p><span>Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is <\/span><em><span>very<\/span><\/em><span>. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a <\/span><em><span>hot<\/span><\/em><span> loop), the JIT compiler might decide to generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.<\/span><\/p><h3 id='upcalls'><span>Upcalls<\/span><\/h3><p><span>Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let&#39;s consider the following function from the C standard library:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 473.469px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">void<\/span> <span class=\"cm-def\">qsort<\/span>(<span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable-3\">*<\/span><span class=\"cm-variable\">base<\/span>, <span class=\"cm-variable-3\">size_t<\/span> <span class=\"cm-variable\">nmemb<\/span>, <span class=\"cm-variable-3\">size_t<\/span> <span class=\"cm-variable\">size<\/span>,<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">           <span class=\"cm-variable-3\">int<\/span> (<span class=\"cm-operator\">*<\/span><span class=\"cm-variable\">compar<\/span>)(<span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable-3\">*<\/span>, <span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable-3\">*<\/span>));<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 46px;\"><\/div><\/div><\/div><\/pre><p><span>The <\/span><code>qsort<\/code><span> function can be used to sort the contents of an array, using a custom comparator function — <\/span><code>compar<\/code><span> — which is passed as a function pointer. To be able to call the <\/span><code>qsort<\/code><span> function from Java we have first to create a downcall method handle for it:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 637.516px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">linker<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">qsort<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">lookup<\/span>(<span class=\"cm-string\">\"qsort\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">ofVoid<\/span>(<span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>As before, we use <\/span><code>JAVA_LONG<\/code><span> and <\/span><code>long.class<\/code><span> to map the C <\/span><code>size_t<\/code><span> type, and <\/span><code>ADDRESS<\/code><span> for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).<\/span><\/p><p><span>This time, in order to invoke the <\/span><code>qsort<\/code><span> downcall handle, we need a <\/span><em><span>function pointer<\/span><\/em><span> to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let&#39;s write a function that can compare two int elements (passed as pointers):<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 620.25px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">class<\/span> <span class=\"cm-def\">Qsort<\/span> {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">qsortCompare<\/span>(<span class=\"cm-variable\">MemoryAddress<\/span> <span class=\"cm-variable\">addr1<\/span>, <span class=\"cm-variable\">MemoryAddress<\/span> <span class=\"cm-variable\">addr2<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-keyword\">return<\/span> <span class=\"cm-variable\">addr1<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>) <span class=\"cm-operator\">-<\/span> <span class=\"cm-variable\">addr2<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span>}<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>Here we can see that the function is performing some <\/span><em><span>unsafe<\/span><\/em><span> dereference of the pointer contents.<\/span><\/p><p><span>Now let&#39;s create a method handle pointing to the comparator function above:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 741.078px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">comparDesc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>);<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">comparHandle<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MethodHandles<\/span>.<span class=\"cm-variable\">lookup<\/span>()<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                         .<span class=\"cm-variable\">findStatic<\/span>(<span class=\"cm-variable\">Qsort<\/span>.<span class=\"cm-keyword\">class<\/span>, <span class=\"cm-string\">\"qsortCompare\"<\/span>,<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                                     <span class=\"cm-variable\">CLinker<\/span>.<span class=\"cm-variable\">upcallType<\/span>(<span class=\"cm-variable\">comparDesc<\/span>));<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 92px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 92px;\"><\/div><\/div><\/div><\/pre><p><span>To do that, we first create a function descriptor for the function pointer type, and then we use the <\/span><code>CLinker::upcallType<\/code><span> to turn that function descriptor into a suitable <\/span><code>MethodType<\/code><span> instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the <\/span><code>qsort<\/code><span> downcall handle:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 732.5px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">comparFunc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">upcallStub<\/span>(<span class=\"cm-variable\">comparHandle<\/span>, <span class=\"cm-variable\">comparDesc<\/span>, <span class=\"cm-variable\">session<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">array<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">session<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">9<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>, <span class=\"cm-number\">6<\/span>, <span class=\"cm-number\">5<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">8<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">7<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">qsort<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">array<\/span>, <span class=\"cm-number\">10L<\/span>, <span class=\"cm-number\">4L<\/span>, <span class=\"cm-variable\">comparFunc<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">int<\/span>[] <span class=\"cm-variable\">sorted<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">array<\/span>.<span class=\"cm-variable\">toArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>); <span class=\"cm-comment\">\/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 138px;\"><\/div><\/div><\/div><\/pre><p><span>The above code creates an upcall stub — <\/span><code>comparFunc<\/code><span> — a function pointer that can be used to invoke our Java comparator function, of type <\/span><code>MemorySegment<\/code><span>. The upcall stub is associated with the provided segment scope instance; this means that the stub will be uninstalled when the arena is closed.<\/span><\/p><p><span>The snippet then creates an off-heap array from a Java array, which is then passed to the <\/span><code>qsort<\/code><span> handle, along with the comparator function we obtained from the foreign linker.  As a side effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.<\/span><\/p><h3 id='varargs'><span>Varargs<\/span><\/h3><p><span>Some C functions are <\/span><em><span>variadic<\/span><\/em><span> and can take an arbitrary number of arguments. Perhaps the most common example of this is the <\/span><code>printf<\/code><span> function, defined in the C standard library:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 317.969px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">int<\/span> <span class=\"cm-def\">printf<\/span>(<span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">char<\/span> <span class=\"cm-variable-3\">*<\/span><span class=\"cm-variable\">format<\/span>, ...);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>This function takes a format string, which features zero or more <\/span><em><span>holes<\/span><\/em><span>, and then can take a number of additional arguments that is identical to the number of holes in the format string.<\/span><\/p><p><span>The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let&#39;s say we wanted to model the following C call:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"C\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 352.516px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">printf<\/span>(<span class=\"cm-string\">\"%d plus %d equals %d\"<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">4<\/span>);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>To do this using the foreign function support provided by the FFM API we would have to build a <\/span><em><span>specialized<\/span><\/em><span> downcall handle for that call shape, using a linker option to specify the position of the first variadic layout, as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 680.703px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">linker<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">printf<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">lookup<\/span>(<span class=\"cm-string\">\"printf\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">Option<\/span>.<span class=\"cm-variable\">firstVariadicArg<\/span>(<span class=\"cm-number\">1<\/span>) <span class=\"cm-comment\">\/\/ first int is variadic<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 138px;\"><\/div><\/div><\/div><\/pre><p><span>Then we can call the specialized downcall handle as usual:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 922.547px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">printf<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"%d plus %d equals %d\"<\/span>), <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">4<\/span>); <span class=\"cm-comment\">\/\/prints \"2 plus 2 equals 4\"<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 69px;\"><\/div><\/div><\/div><\/pre><p><span>While this works, and provides optimal performance, it has some limitations<\/span><a href=\"#3\"><sup><span>3<\/span><\/sup><\/a><span>:<\/span><\/p><ul><li><span>If the variadic function needs to be called with many shapes, we have to create many downcall handles<\/span><\/li><li><span>while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.<\/span><\/li><\/ul><h3 id='appendix-full-source-code'><span>Appendix: full source code<\/span><\/h3><p><span>The full source code containing most of the code shown throughout this document can be seen below:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\" style=\"break-inside: unset;\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 1026.14px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">Arena<\/span>;<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">Linker<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">FunctionDescriptor<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">SymbolLookup<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">MemorySegment<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">VaList<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">invoke<\/span>.<span class=\"cm-variable\">MethodHandle<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">invoke<\/span>.<span class=\"cm-variable\">MethodHandles<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">util<\/span>.<span class=\"cm-variable\">Arrays<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">ValueLayout<\/span>.<span class=\"cm-operator\">*<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">class<\/span> <span class=\"cm-def\">Examples<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">LINKER<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">SymbolLookup<\/span> <span class=\"cm-variable\">STDLIB<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">main<\/span>(<span class=\"cm-variable-3\">String<\/span>[] <span class=\"cm-variable\">args<\/span>) <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">strlen<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">strlen_virtual<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">qsort<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">printf<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">strlen<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">hello<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> (<span class=\"cm-variable-3\">long<\/span>) <span class=\"cm-variable\">strlen<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">hello<\/span>); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">System<\/span>.<span class=\"cm-variable\">out<\/span>.<span class=\"cm-variable\">println<\/span>(<span class=\"cm-variable\">len<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">strlen_virtual<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen_virtual<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">hello<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> (<span class=\"cm-variable-3\">long<\/span>) <span class=\"cm-variable\">strlen_virtual<\/span>.<span class=\"cm-variable\">invoke<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">hello<\/span>); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">System<\/span>.<span class=\"cm-variable\">out<\/span>.<span class=\"cm-variable\">println<\/span>(<span class=\"cm-variable\">len<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-keyword\">class<\/span> <span class=\"cm-def\">Qsort<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">qsortCompare<\/span>(<span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">addr1<\/span>, <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">addr2<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-keyword\">return<\/span> <span class=\"cm-variable\">addr1<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>) <span class=\"cm-operator\">-<\/span> <span class=\"cm-variable\">addr2<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">qsort<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">qsort<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"qsort\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">ofVoid<\/span>(<span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">comparDesc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>.<span class=\"cm-variable\">asUnbounded<\/span>(), <span class=\"cm-variable\">ADDRESS<\/span>.<span class=\"cm-variable\">asUnbounded<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">comparHandle<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MethodHandles<\/span>.<span class=\"cm-variable\">lookup<\/span>()<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                         .<span class=\"cm-variable\">findStatic<\/span>(<span class=\"cm-variable\">Qsort<\/span>.<span class=\"cm-keyword\">class<\/span>, <span class=\"cm-string\">\"qsortCompare\"<\/span>,<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                                     <span class=\"cm-variable\">comparDesc<\/span>.<span class=\"cm-variable\">toMethodType<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">comparFunc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">upcallStub<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">comparHandle<\/span>, <span class=\"cm-variable\">comparDesc<\/span>, <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">array<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">9<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>, <span class=\"cm-number\">6<\/span>, <span class=\"cm-number\">5<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">8<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">7<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">qsort<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">array<\/span>, <span class=\"cm-number\">10L<\/span>, <span class=\"cm-number\">4L<\/span>, <span class=\"cm-variable\">comparFunc<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable-3\">int<\/span>[] <span class=\"cm-variable\">sorted<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">array<\/span>.<span class=\"cm-variable\">toArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>); <span class=\"cm-comment\">\/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">System<\/span>.<span class=\"cm-variable\">out<\/span>.<span class=\"cm-variable\">println<\/span>(<span class=\"cm-variable\">Arrays<\/span>.<span class=\"cm-variable\">toString<\/span>(<span class=\"cm-variable\">sorted<\/span>));<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">printf<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">printf<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"printf\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">Option<\/span>.<span class=\"cm-variable\">firstVariadicArg<\/span>(<span class=\"cm-number\">1<\/span>) <span class=\"cm-comment\">\/\/ first int is variadic<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">s<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"%d plus %d equals %d\\n\"<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">printf<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">s<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">4<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 2097px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 2097px;\"><\/div><\/div><\/div><\/pre><p>&nbsp;<\/p><ul><li><a id=\"1\"\/><span>(<\/span><sup><span>1<\/span><\/sup><span>):<\/span><small><span> For simplicity, the examples shown in this document use <\/span><code>MethodHandle::invoke<\/code><span> rather than <\/span><code>MethodHandle::invokeExact<\/code><span>; by doing so we avoid having to cast by-reference arguments back to <\/span><code>Addressable<\/code><span>. With <\/span><code>invokeExact<\/code><span> the method handle invocation should be rewritten as <\/span><code>strlen.invokeExact((Addressable)session.allocateUtf8String(&quot;Hello&quot;));<\/code><\/small><\/li><li><a id=\"2\"\/><span>(<\/span><sup><span>2<\/span><\/sup><span>):<\/span><small><span> In reality this is not entirely new; even in JNI, when you call a <\/span><code>native<\/code><span> method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/span><\/small><\/li><li><a id=\"3\"\/><span>(<\/span><sup><span>3<\/span><\/sup><span>):<\/span><small><span> Previous iterations of the FFM API provided a <\/span><code>VaList<\/code><span> class that could be used to model a C <\/span><code>va_list<\/code><span>. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the <\/span><code>jextract<\/code><span> tool might provide higher-level bindings for variadic calls. <\/span><\/small><\/li><\/ul><\/div><\/div>\n+<\/body>\n+<\/html>\n\\ No newline at end of file\n","filename":"doc\/panama_ffi.html","additions":693,"deletions":0,"binary":false,"changes":693,"status":"added"},{"patch":"@@ -0,0 +1,363 @@\n+## State of foreign function support\n+\n+**March 2023**\n+\n+**Maurizio Cimadamore**\n+\n+The Foreign Function & Memory API (FFM API in short) provides access to foreign functions through the `Linker` interface, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). A linker allows clients to construct *downcall* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, FFM API's foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+\n+### Zero-length memory segments\n+\n+Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the [foreign memory access support](panama_memaccess.md). The Foreign Memory Access API allows client to create and manipulate *memory segments*. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always *safe*, and can never result in a VM crash, or, worse, in silent memory corruption.\n+\n+Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we often receive *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in the FFM API are modelled using *zero-length memory segments*.\n+\n+To work with native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>. First, clients can unsafely resize a zero-length memory segment by obtaining a memory segment with the same base address as the zero-length memory segment, but with the desired size, so that the resulting segment can then be accessed directly, as follows:\n+\n+```java\n+MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ size = 0\n+                                   .reinterpret(4)               \/\/ size = 4\n+int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n+```\n+\n+In some cases, a client might additionally want to assign new temporal bounds to a zero-length memory segment. This can be done using another variant of the `MemorySegment::reinterpret` method, which returns a new native segment with the desired size and temporal bounds:\n+\n+```java\n+MemorySegment foreign = null;\n+try (Arena arena = Arena.ofConfined()) {\n+      foreign = someSegment.get(ValueLayout.ADDRESS, 0)           \/\/ size = 0, scope = always alive\n+                           .reinterpret(4, arena, null);          \/\/ size = 4, scope = arena.scope()\n+      int x = foreign.get(ValueLayout.JAVA_INT, 0);               \/\/ ok\n+}\n+int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ throws IllegalStateException\n+```\n+\n+Note how the new segment behaves as if it was allocated in the provided arena: when the arena is closed, the new segment is no longer accessible.\n+\n+Alternatively, if the size of the foreign segment is known statically, clients can associate a *target layout* with the address layout used to obtain the segment. When an access operation, or a function descriptor that is passed to a downcall method handle (see below), uses an address value layout with target layout `T`, the runtime will wrap any corresponding raw addresses as segments with size set to `T.byteSize()`:\n+```java\n+MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ size = 4\n+int x = foreign.get(ValueLayout.JAVA_INT, 0);                                               \/\/ ok\n+```\n+\n+Which approach is taken largely depends on the information that a client has available when obtaining a memory segment wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). If the size is known statically, using an address layout with the correct target layout might be preferable. In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n+\n+> Note: Memory segments created using `MemorySegment::reinterpret`, or `OfAddress::withTargetLayout` are completely *unsafe*. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size and temporal bounds of the memory region pointed by the address indeed conforms to the parameters provided by the client. For these reasons, these methods are *restricted method* in the FFM API. The first time a restricted method is invoked, a runtime warning is generated. Developers can get rid of warnings by specifying the set of modules that are allowed to call restricted methods. This is done by specifying the option `--enable-native-access=M`, where `M` is a module name. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. If the `--enable-native-access` option is specified, any attempt to call restricted operations from a module not listed in the option will fail with a runtime exception.\n+\n+### Symbol lookups\n+\n+The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the `System::loadLibrary` and `System::load` methods. Unfortunately, these methods do not provide a way for clients to obtain the *address* associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely `SymbolLookup` (similar in spirit to a method handle lookup), which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 3 different ways:\n+\n+* `SymbolLookup::libraryLookup(String, SegmentScope)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is no longer alive, the library referred to by the lookup will also be closed;\n+* `SymbolLookup::loaderLookup` — creates a symbol lookup which can be used to search symbols in all the libraries loaded by the caller's classloader (e.g. using `System::loadLibrary` or `System::load`)\n+* `Linker::defaultLookup` — returns the default symbol lookup associated with a `Linker` instance. For instance, the default lookup of the native linker (see `Linker::nativeLinker`) can be used to look up platform-specific symbols in the standard C library (such as `strlen`, or `getpid`).\n+\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `find(String)` method, which returns an `Optional<MemorySegment>`.  The memory segments returned by the `lookup` are zero-length segments, whose base address is the address of the function or variable in the library.\n+\n+For instance, the following code can be used to look up the `clang_getClangVersion` function provided by the `clang` library; it does so by creating a *library lookup* whose lifecycle is associated to that of a confined arena.\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    SymbolLookup libclang = SymbolLookup.libraryLookup(\"libclang.so\", arena);\n+    MemorySegment clangVersion = libclang.find(\"clang_getClangVersion\").get();\n+}\n+```\n+\n+### Linker\n+\n+At the core of the FFM API's foreign function support we find the `Linker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling foreign function calls as plain `MethodHandle` calls (see `Linker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to foreign functions as a function pointer (see `Linker::upcallStub`):\n+\n+```java\n+interface Linker {\n+    MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope);\n+    ... \/\/ some overloads omitted here\n+\n+    static Linker nativeLinker() { ... }\n+}\n+```\n+\n+Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType` — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n+\n+The `Linker::nativeLinker` factory is used to obtain a `Linker` implementation for the ABI associated with the OS and processor where the Java runtime is currently executing. As such, the native linker can be used to call C functions. The following table shows the mapping between C types, layouts and Java carriers under the Linux\/macOS native linker implementation; note that the mappings can be platform dependent: on Windows\/x64, the C type `long` is 32-bit, so the `JAVA_INT` layout (and the Java carrier `int.class`) would have to be used instead:\n+\n+| C type                                                       | Layout                                                       | Java carrier    |\n+| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |\n+| `bool`                                                       | `JAVA_BOOLEAN`                                               | `byte`          |\n+| `char`                                                       | `JAVA_BYTE`                                                  | `byte`          |\n+| `short`                                                      | `JAVA_SHORT`                                                 | `short`, `char` |\n+| `int`                                                        | `JAVA_INT`                                                   | `int`           |\n+| `long`                                                       | `JAVA_LONG`                                                  | `long`          |\n+| `long long`                                                  | `JAVA_LONG`                                                  | `long`          |\n+| `float`                                                      | `JAVA_FLOAT`                                                 | `float`         |\n+| `double`                                                     | `JAVA_DOUBLE`                                                | `double`        |\n+| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`                                                    | `MemorySegment` |\n+| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `MemoryLayout.structLayout(...)`<br \/>`MemoryLayout.unionLayout(...)`<br \/> | `MemorySegment` |\n+\n+Both C structs\/unions and pointers are modelled using the `MemorySegment` carrier type. However, C structs\/unions are modelled in function descriptors with memory layouts of type `GroupLayout`, whereas pointers are modelled using the `ADDRESS` value layout constant (whose size is platform-specific). Moreover, the behavior of a downcall method handle returning a struct\/union type is radically different from that of a downcall method handle returning a C pointer:\n+\n+* downcall method handles returning C pointers will wrap the pointer address into a fresh zero-length memory segment (unless an unbounded address layout is specified);\n+* downcall method handles returning a C struct\/union type will return a *new* segment, of given size (the size of the struct\/union). The segment is allocated using a user-provided `SegmentAllocator`, which is provided using an additional prefix parameter inserted in the downcall method handle signature.\n+\n+A tool, such as `jextract`, will generate all the required C layouts (for scalars and structs\/unions) *automatically*, so that clients do not have to worry about platform-dependent details such as sizes, alignment constraints and padding.\n+\n+### Downcalls\n+\n+We will now look at how foreign functions can be called from Java using the native linker. Assume we wanted to call the following function from the standard C library:\n+\n+```c\n+size_t strlen(const char *s);\n+```\n+\n+In order to do that, we have to:\n+\n+* lookup the `strlen` symbol\n+* describe the signature of the C function using a function descriptor\n+\n+* create a *downcall* native method handle with the above information, using the native linker\n+\n+Here's an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the [appendix](#appendix-full-source-code)):\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle strlen = linker.downcallHandle(\n+        linker.defaultLookup().find(\"strlen\").get(),\n+        FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+);\n+```\n+\n+Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the default lookup of the native linker to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `JAVA_LONG` both Linux and Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modelled using an `MemorySegment` parameter.\n+\n+Once we have obtained the downcall method handle, we can just use it as any other method handle:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    long len = strlen.invokeExact(arena.allocateUtf8String(\"Hello\")); \/\/ 5\n+}\n+```\n+\n+Here we are using a confined arena to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this is possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an arena to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n+\n+The `Linker` interface also supports linking of native functions without an address known at link time; when that happens, an address (of type `MemorySegment`) must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n+\n+```java\n+MethodHandle strlen_virtual = linker.downcallHandle( \/\/ address parameter missing!\n+\t\tFunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+);\n+\n+try (Arena arena = Arena.ofConfined()) {\n+    long len = strlen_virtual.invokeExact(\n+        linker.defaultLookup().find(\"strlen\").get() \/\/ address provided here!\n+        arena.allocateUtf8String(\"Hello\")\n+    ); \/\/ 5\n+}\n+```\n+\n+It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Java runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Java runtime has to *trust* the function descriptor passed in<a href=\"#1\"><sup>1<\/sup><\/a>; for this reason, the `Linker::nativeLinker` factory is also a restricted method.\n+\n+When working with shared arenas, it is always possible for the arena associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `MemorySegment` instance passed by reference to a downcall method handle will be *kept alive* for the entire duration of the call.\n+\n+Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a *hot* loop), the JIT compiler might decide to generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.\n+\n+### Upcalls\n+\n+Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let's consider the following function from the C standard library:\n+\n+```c\n+void qsort(void *base, size_t nmemb, size_t size,\n+           int (*compar)(const void *, const void *));\n+```\n+\n+The `qsort` function can be used to sort the contents of an array, using a custom comparator function — `compar` — which is passed as a function pointer. To be able to call the `qsort` function from Java we have first to create a downcall method handle for it:\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle qsort = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"qsort\").get(),\n+        FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+);\n+```\n+\n+As before, we use `JAVA_LONG` and `long.class` to map the C `size_t` type, and `ADDRESS` for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n+\n+This time, in order to invoke the `qsort` downcall handle, we need a *function pointer* to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let's write a function that can compare two int elements (passed as pointers):\n+\n+```java\n+class Qsort {\n+    static int qsortCompare(MemorySegment elem1, MemorySegmet elem2) {\n+        return elem1.get(JAVA_INT, 0) - elem2.get(JAVA_INT, 0);\n+    }\n+}\n+```\n+\n+Here we can see that the function is performing some *unsafe* dereference of the pointer contents.\n+\n+Now let's create a method handle pointing to the comparator function above:\n+\n+```java\n+FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+                                                      ADDRESS.withTargetLayout(JAVA_INT),\n+                                                      ADDRESS.withTargetLayout(JAVA_INT));\n+MethodHandle comparHandle = MethodHandles.lookup()\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     comparDesc.toMethodType());\n+```\n+\n+To do that, we first create a function descriptor for the function pointer type. This descriptor uses address layouts that have a `JAVA_INT` target layout, to allow access operations inside the upcall method handle. We use the `FunctionDescriptor::toMethodType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, arena);\n+    MemorySegment array = session.allocateArray(0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+    qsort.invokeExact(array, 10L, 4L, comparFunc);\n+    int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+}\n+```\n+\n+The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function, of type `MemorySegment`. The upcall stub is associated with the provided segment scope instance; this means that the stub will be uninstalled when the arena is closed.\n+\n+The snippet then creates an off-heap array from a Java array, which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n+\n+### Variadic calls\n+\n+Some C functions are *variadic* and can take an arbitrary number of arguments. Perhaps the most common example of this is the `printf` function, defined in the C standard library:\n+\n+```c\n+int printf(const char *format, ...);\n+```\n+\n+This function takes a format string, which features zero or more *holes*, and then can take a number of additional arguments that is identical to the number of holes in the format string.\n+\n+The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let's say we wanted to model the following C call:\n+\n+```c\n+printf(\"%d plus %d equals %d\", 2, 2, 4);\n+```\n+\n+To do this using the foreign function support provided by the FFM API we would have to build a *specialized* downcall handle for that call shape, using a linker option to specify the position of the first variadic layout, as follows:\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle printf = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"printf\").get(),\n+        FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT)\n+        Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n+);\n+```\n+\n+Then we can call the specialized downcall handle as usual:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+}\n+```\n+\n+While this works, and provides optimal performance, it has some limitations<a href=\"#2\"><sup>2<\/sup><\/a>:\n+\n+* If the variadic function needs to be called with many shapes, we have to create many downcall handles\n+* while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.\n+\n+### Appendix: full source code\n+\n+The full source code containing most of the code shown throughout this document can be seen below:\n+\n+```java\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public class Examples {\n+\n+    static Linker LINKER = Linker.nativeLinker();\n+    static SymbolLookup STDLIB = LINKER.defaultLookup();\n+\n+    public static void main(String[] args) throws Throwable {\n+        strlen();\n+        strlen_virtual();\n+        qsort();\n+        printf();\n+    }\n+\n+    public static void strlen() throws Throwable {\n+        MethodHandle strlen = LINKER.downcallHandle(\n+                STDLIB.find(\"strlen\").get(),\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+        );\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment hello = arena.allocateUtf8String(\"Hello\");\n+            long len = (long) strlen.invokeExact(hello); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    public static void strlen_virtual() throws Throwable {\n+        MethodHandle strlen_virtual = LINKER.downcallHandle(\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+        );\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment hello = arena.allocateUtf8String(\"Hello\");\n+            long len = (long) strlen_virtual.invokeExact(\n+                STDLIB.find(\"strlen\").get(),\n+                hello); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    static class Qsort {\n+        static int qsortCompare(MemorySegment addr1, MemorySegment addr2) {\n+            return addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);\n+        }\n+    }\n+\n+    public static void qsort() throws Throwable {\n+        MethodHandle qsort = LINKER.downcallHandle(\n+                STDLIB.find(\"qsort\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+        );\n+        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+                                                              ADDRESS.withTargetLayout(JAVA_INT),\n+                                                              ADDRESS.withTargetLayout(JAVA_INT));\n+        MethodHandle comparHandle = MethodHandles.lookup()\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     comparDesc.toMethodType());\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment comparFunc = LINKER.upcallStub(\n+                comparHandle, comparDesc, arena);\n+\n+            MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+            qsort.invokeExact(array, 10L, 4L, comparFunc);\n+            int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+            System.out.println(Arrays.toString(sorted));\n+        }\n+    }\n+\n+    public static void printf() throws Throwable {\n+        MethodHandle printf = LINKER.downcallHandle(\n+                STDLIB.find(\"printf\").get(),\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT),\n+                Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n+        );\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+            int res = (int)printf.invokeExact(s, 2, 2, 4);\n+        }\n+    }\n+}\n+```\n+\n+\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> Previous iterations of the FFM API provided a `VaList` class that could be used to model a C `va_list`. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the `jextract` tool might provide higher-level bindings for variadic calls. <\/small>\n","filename":"doc\/panama_ffi.md","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+## State of foreign memory support\n+\n+**March 2023**\n+\n+**Maurizio Cimadamore**\n+\n+A crucial part of any native interop story lies in the ability of accessing off-heap memory efficiently and safely. Java achieves this goal through the Foreign Function & Memory API (FFM API in short), parts of which have been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [14](https:\/\/openjdk.java.net\/jeps\/370). The FFM API introduces abstractions to allocate and access flat memory regions (whether on- or off-heap), to manage the lifecycle of memory resources and to model native memory addresses.\n+\n+### Memory segments and arenas\n+\n+Memory segments are abstractions which can be used to model contiguous memory regions, located either on-heap (i.e. *heap segments*) or off- the Java heap (i.e. *native segments*). Memory segments provide *strong* spatial, temporal and thread-confinement guarantees which make memory dereference operation *safe* (more on that later), although in most simple cases some properties of memory segments can safely be ignored.\n+\n+For instance, the following snippet allocates 100 bytes off-heap:\n+\n+```java\n+MemorySegment segment = Arena.global().allocate(100);\n+```\n+\n+The above code allocates a 100-bytes long memory segment, using an *arena*. The FFM API provides several kinds of arena, which can be used to control the lifecycle of the allocated native segments in different ways. In this example, the segment is allocated with the *global* arena. Memory segments allocated with this arena are always *alive* and their backing regions of memory are never deallocated. In other words, we say that the above segment has an *unbounded* lifetime.\n+\n+> Note: the lifetime of a memory segment is modelled by a *scope* (see `MemorySegment.Scope`). A memory segment can be accessed as long as its associated scope is *alive* (see `Scope::isAlive`). In most cases, the scope of a memory segment is the scope of the arena which allocated that segment. Accessing the scope of a segment can be useful to perform lifetime queries (e.g. asking whether a segment has the same lifetime as that of another segment), creating custom arenas and unsafely assigning new temporal bounds to an existing native memory segments (these topics are explored in more details below).\n+\n+Most programs, though, require off-heap memory to be deallocated while the program is running, and thus need memory segments with *bounded* lifetimes. The simplest way to obtain a segment with bounded lifetime is to use an *automatic arena*:\n+\n+```java\n+MemorySegment segment = Arena.ofAuto().allocate(100);\n+```\n+\n+Segments allocated with an automatic arena are alive as long as they are determined to be reachable by the garbage collector. In other words, the above snippet creates a native segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory.\n+\n+There are cases, however, where automatic deallocation is not enough: consider the case where a large memory segment is mapped from a file (this is possible using `FileChannel::map`); in this case, an application would probably prefer to release (e.g. `unmap`) the memory associated with this segment in a *deterministic* fashion, to ensure that memory doesn't remain available for longer than it needs to.\n+\n+A *confined* arena allocates segment featuring a bounded *and* deterministic lifetime. A memory segment allocated with a confined arena is alive from the time when the arena is opened, until the time when the arena is closed (at which point the segments become inaccessible). Multiple segments allocated with the same arena enjoy the *same* bounded lifetime and can safely contain mutual references. For example, this code opens an arena and uses it to allocate several native segments:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment segment1 = arena.allocate(100);\n+    MemorySegment segment2 = arena.allocate(100);\n+    ...\n+    MemorySegment segmentN = arena.allocate(100);\n+} \/\/ all segments are deallocated here\n+```\n+\n+When the arena is closed (above, this is done with the *try-with-resources* construct) the arena is no longer alive, all the segments associated with it are invalidated atomically, and the regions of memory backing the segments are deallocated.\n+\n+A confined arena's deterministic lifetime comes at a price: only one thread can access the memory segments allocated in a confined arena. If multiple threads need access to a segment, then a *shared* arena can be used (`Arena::ofShared`). The memory segments allocated in a shared arena can be accessed by multiple threads, and any thread (regardless of whether it was involved in access) can close the shared arena to deallocate the segments. The closure will atomically invalidate the segments, though deallocation of the regions of memory backing the segments might not occur immediately: an expensive synchronization operation<a href=\"#1\"><sup>1<\/sup><\/a> is needed to detect and cancel pending concurrent access operations on the segments.\n+\n+In summary, an arena controls *which* threads can access a memory segment and *when*, in order to provide both strong temporal safety and a predictable performance model. The FFM API offers a choice of arenas so that a client can trade off breadth-of-access against timeliness of deallocation.\n+\n+### Slicing segments\n+\n+Memory segments support *slicing* — that is, given a segment, it is possible to create a new segment whose spatial bounds are stricter than that of the original segment:\n+\n+```java\n+MemorySegment segment = Arena.ofAuto().allocate(10);\n+MemorySegment slice = segment.asSlice(4, 4);\n+```\n+\n+The above code creates a slice that starts at offset 4 and has a length of 4 bytes. Slices have the *same* temporal bounds (i.e. segment scope) as the parent segment. In the above example, the memory associated with the parent segment will not be released as long as there is at least one *reachable* slice derived from that segment.\n+\n+To process the contents of a memory segment in bulk, a memory segment can be turned into a stream of slices, using the `MemorySegment::stream` method:\n+\n+```java\n+SequenceLayout seq = MemoryLayout.sequenceLayout(1_000_000, JAVA_INT);\n+SequenceLayout bulk_element = MemoryLayout.sequenceLayout(100, JAVA_INT);\n+\n+try (Arena arena = Arena.ofShared()) {\n+    MemorySegment segment = arena.allocate(seq);\n+    int sum = segment.elements(bulk_element).parallel()\n+                       .mapToInt(slice -> {\n+                           int res = 0;\n+                           for (int i = 0; i < 100 ; i++) {\n+                               res += slice.getAtIndex(JAVA_INT, i);\n+                           }\n+                           return res;\n+                       }).sum();\n+}\n+```\n+\n+The `MemorySegment::elements` method takes an element layout and returns a new stream. The stream is built on top of a spliterator instance (see `MemorySegment::spliterator`) which splits the segment into chunks whose size match that of the provided layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes *exactly* one element would be inefficient, so instead we use a *bulk* element layout. The bulk element layout is a sequence layout containing a group of 100 elements — which should make it more amenable to parallel processing. Since we are using `Stream::parallel` to work on disjoint slices in parallel, here we use a *shared* arena, to ensure that the resulting segment can be accessed by multiple threads.\n+\n+### Accessing segments\n+\n+Memory segments can be dereferenced easily, by using *value layouts* (layouts are covered in greater details in the next section). A value layout captures information such as:\n+\n+- The number of bytes to be dereferenced;\n+- The alignment constraints of the address at which dereference occurs;\n+- The endianness with which bytes are stored in said memory region;\n+- The Java type to be used in the dereference operation (e.g. `int` vs `float`).\n+\n+For instance, the layout constant `ValueLayout.JAVA_INT` is four bytes wide, has no alignment constraints, uses the native platform endianness (e.g. little-endian on Linux\/x64) and is associated with the Java type `int`. The following example reads pairs of 32-bit values (as Java ints) and uses them to construct an array of points:\n+\n+```java\n+record Point(int x, int y);\n+MemorySegment segment = Arena.ofAuto().allocate(10 * 4 * 2);\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = segment.getAtIndex(JAVA_INT, i * 2);\n+    int y = segment.getAtIndex(JAVA_INT, (i * 2) + 1);\n+    values[i] = new Point(x, y);\n+}\n+```\n+\n+The above snippet allocates a flat array of 80 bytes using an automatic arena. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (under the hood, the segment offset being accessed is obtained by multiplying the logical index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n+\n+### Structured access\n+\n+Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, clients can use a `MemoryLayout` to describe the contents of a memory segment *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#2\"><sup>2<\/sup><\/a>:\n+\n+```java\n+MemoryLayout points = MemoryLayout.sequenceLayout(10,\n+    MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"x\"),\n+        JAVA_INT.withName(\"y\")\n+    )\n+);            \n+```\n+\n+That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. Once defined, a memory layout can be queried — for instance we can compute the offset of the `y` coordinate in the 4th element of the `points` array:\n+\n+```java\n+long y3 = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\")); \/\/ 28\n+```\n+\n+To specify which nested layout element should be used for the offset calculation we use a *layout path*, a selection expression that navigates the layout, from the *root* layout, down to the leaf layout we wish to select; in this case we need to select the 4th layout element in the sequence, and then select the layout named `y` inside the selected group layout.\n+\n+One of the things that can be derived from a layout is a *memory access var handle*. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. With memory access var handles we can rewrite our example above as follows:\n+\n+```java\n+MemorySegment segment = Arena.ofAuto().allocate(points);\n+VarHandle xHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"x\"));\n+VarHandle yHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"y\"));\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = (int)xHandle.get(segment, (long)i);\n+    int y = (int)yHandle.get(segment, (long)i);\n+}\n+```\n+\n+In the above, `xHandle` and `yHandle` are two var handle instances whose type is `int` and which takes two access coordinates:\n+\n+1. a `MemorySegment` instance; the segment whose memory should be dereferenced\n+2. a *logical* index, which is used to select the element of the sequence we want to access (as the layout path used to construct these var handles contains one free dimension)\n+\n+Note that memory access var handles (as any other var handle) are *strongly* typed; and to get maximum efficiency, it is generally necessary to introduce casts to make sure that the access coordinates match the expected types — in this case we have to cast `i` into a `long`; similarly, since the signature polymorphic method `VarHandle::get` notionally returns `Object` a cast is necessary to force the right return type the var handle operation <a href=\"#3\"><sup>3<\/sup><\/a>.\n+\n+In other words, manual offset computation is no longer needed — offsets and strides can in fact be derived from the layout object; note how `yHandle` is able to compute the required offset of the `y` coordinate in the flat array without the need of any error-prone arithmetic computation.\n+\n+### Combining memory access handles\n+\n+We have seen in the previous sections how memory access var handles dramatically simplify user code when structured access is involved. While deriving memory access var handles from layout is the most convenient option, the FFM API also allows to create such memory access var handles in a standalone fashion, as demonstrated in the following code:\n+\n+```java\n+VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(JAVA_INT); \/\/ (MS, J) -> I\n+```\n+\n+The above code creates a memory access var handle which reads\/writes `int` values at a certain byte offset in a segment. To create this var handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user might want to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values. Of course, all this information can be succinctly derived from the provided value layout (`JAVA_INT` in the above example).\n+\n+The attentive reader might have noted how rich the var handles obtained from memory layouts are, compared to the simple memory access var handle we have constructed here. How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle *combinators*. Developers familiar with the method handles know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` class. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n+\n+The FFM API adds a rich set of var handle combinators in the `MethodHandles` class; with these tools, developers can express var handle transformations such as:\n+\n+* mapping a var handle carrier type into a different one, using an embedding\/projection method handle pairs\n+* filter one or more var handle access coordinates using unary filters\n+* permute var handle access coordinates\n+* bind concrete access coordinates to an existing var handle\n+\n+Without diving too deep, let's consider how we might want to take a basic memory access handle and turn it into a var handle which dereference a segment at a specific offset (again using the `points` layout defined previously):\n+\n+```java\n+VarHandle intHandle = MemoryHandles.memorySegmentViewVarHandle(JAVA_INT); \/\/ (MS, J) -> I\n+long offsetOfY = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\"));\n+VarHandle valueHandle = MethodHandles.insertCoordinates(intHandle, 1, offsetOfValue); \/\/ (MS) -> I\n+```\n+\n+We have been able to derive, from a basic memory access var handle, a new var handle that dereferences a segment at a given fixed offset. It is easy to see how other, richer, var handles obtained using a memory layout can also be constructed manually using the var handle combinators provided by the FFM API.\n+\n+### Segment allocators and custom arenas\n+\n+Memory allocation is often a bottleneck when clients use off-heap memory. The FFM API therefore includes a `SegmentAllocator` interface to define operations to allocate and initialize memory segments. As a convenience, the `Arena` interface extends the `SegmentAllocator` interface so that arenas can be used to allocate native segments. In other words, `Arena` is a \"one-stop shop\" for flexible allocation and timely deallocation of off-heap memory:\n+\n+```java\n+FileChannel channel = ...\n+try (Arena offHeap = Arena.ofConfined()) {\n+    MemorySegment nativeArray   = offHeap.allocateArray(ValueLayout.JAVA_INT, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+    MemorySegment nativeString  = offHeap.allocateUtf8String(\"Hello!\");\n+\n+    MemorySegment mappedSegment = channel.map(MapMode.READ_WRITE, 0, 1000, arena);\n+   ...\n+} \/\/ memory released here\n+```\n+\n+Segment allocators can also be obtained via factories in the `SegmentAllocator` interface. For example, one factory creates a *slicing allocator* that responds to allocation requests by returning memory segments which are part of a previously allocated segment; thus, many requests can be satisfied without physically allocating more memory. The following code obtains a slicing allocator over an existing segment, then uses it to allocate a segment initialized from a Java array:\n+\n+```java\n+MemorySegment segment = ...\n+SegmentAllocator allocator = SegmentAllocator.slicingAllocator(segment);\n+for (int i = 0 ; i < 10 ; i++) {\n+    MemorySegment s = allocator.allocateArray(JAVA_INT, new int[] { 1, 2, 3, 4, 5 });\n+    ...\n+}\n+```\n+\n+A segment allocator can be used as a building block to create an arena that supports a custom allocation strategy. For example, if many segments share the same bounded lifetime, then an arena could use a slicing allocator to allocate the segments efficiently. This lets clients enjoy both scalable allocation (thanks to slicing) and deterministic deallocation (thanks to the arena).\n+\n+As an example, the following code defines a *slicing arena* that behaves like a confined arena (i.e., single-threaded access), but internally uses a slicing allocator to respond to allocation requests.  When the slicing arena is closed, the underlying confined arena is also closed; this will invalidate all segments allocated with the slicing arena:\n+\n+```java\n+class SlicingArena {\n+     final Arena arena = Arena.ofConfined();\n+     final SegmentAllocator slicingAllocator;\n+\n+     SlicingArena(long size) {\n+         slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+     }\n+\n+public void allocate(long byteSize, long byteAlignment) {\n+         return slicingAllocator.allocate(byteSize, byteAlignment);\n+     }\n+\n+     public MemorySegment.Scope scope() {\n+         return arena.scope();\n+     }\n+\n+     public void close() {\n+         return arena.close();\n+     }\n+}\n+```\n+\n+The earlier code which used a slicing allocator directly can now be written more succinctly, as follows:\n+\n+```java\n+try (Arena slicingArena = new SlicingArena(1000)) {\n+     for (int i = 0 ; i < 10 ; i++) {\n+         MemorySegment s = arena.allocateArray(JAVA_INT, new int[] { 1, 2, 3, 4, 5 });\n+         ...\n+     }\n+} \/\/ all memory allocated is released here\n+```\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> Shared arenas rely on VM thread-local handshakes (JEP [312](https:\/\/openjdk.java.net\/jeps\/312)) to implement lock-free, safe, shared memory access; that is, when it comes to memory access, there should be no difference in performance between a shared segment and a confined segment. On the other hand, `Arena::close` might be slower on shared arenas than on confined ones.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> In general, deriving a complete layout from a C `struct` declaration is no trivial matter, and it's one of those areas where tooling can help greatly.<\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> Clients can enforce stricter type checking when interacting with `VarHandle` instances, by obtaining an *exact* var handle, using the `VarHandle::withInvokeExactBehavior` method.<\/small>\n+\n","filename":"doc\/panama_memaccess.md","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.Buffer;\n+import java.util.function.BiFunction;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.foreign.MemoryInspectionUtil.*;\n+\n+\/**\n+ * Class that supports inspection of MemorySegments through MemoryLayouts.\n+ * <p>\n+ * Memory abstractions such as ByteBuffers and byte arrays can be inspected via wrapping methods\n+ * such as {@link MemorySegment#ofArray(byte[])} and {@link MemorySegment#ofBuffer(Buffer)}.\n+ *\n+ * @since 20\n+ *\/\n+public final class MemoryInspection {\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspection() {\n+    }\n+\n+    \/**\n+     * Returns a human-readable view of the provided {@linkplain MemorySegment memory} viewed\n+     * through the provided {@linkplain MemoryLayout layout} using the provided {@code renderer}.\n+     * <p>\n+     * The exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a MemorySegment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     * var layout = MemoryLayout.structLayout(\n+     *         ValueLayout.JAVA_INT.withName(\"x\"),\n+     *         ValueLayout.JAVA_INT.withName(\"y\")\n+     * ).withName(\"Point\");\n+     *\n+     * MemoryInspection.inspect(segment, layout, ValueLayoutRenderer.standard())\n+     *     .forEach(System.out::println);\n+     *\n+     *}\n+     * might be rendered to something like this:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     * <p>\n+     * This method is intended to view memory segments through small and medium-sized memory layouts.\n+     *\n+     * @param segment  to be viewed\n+     * @param layout   to use as a layout when viewing the memory segment\n+     * @param renderer to apply when rendering value layouts\n+     * @return a view of the memory abstraction viewed through the memory layout\n+     *\/\n+    public static Stream<String> inspect(MemorySegment segment,\n+                                         MemoryLayout layout,\n+                                         BiFunction<ValueLayout, Object, String> renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+        return MemoryInspectionUtil.inspect(segment, layout, renderer);\n+    }\n+\n+    \/**\n+     * {@return a standard value layout renderer that will render numeric values into decimal form and where\n+     * other value types are rendered to a reasonable \"natural\" form}\n+     * <p>\n+     * More specifically, values types are rendered as follows:\n+     * <ul>\n+     *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+     *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+     *     <li>Character values are rendered as {@code char}.<\/li>\n+     *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n+     *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n+     * <\/ul>\n+     *\/\n+    public static BiFunction<ValueLayout, Object, String> standardRenderer() {\n+        return STANDARD_VALUE_LAYOUT_RENDERER;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspection.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Internal class to support inspection MemorySegments into various formats.\n+ *\/\n+final class MemoryInspectionUtil {\n+\n+    static final BiFunction<ValueLayout, Object, String> STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspectionUtil() {\n+    }\n+\n+    static Stream<String> inspect(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  BiFunction<ValueLayout, Object, String> renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+\n+        final var builder = Stream.<String>builder();\n+        toString0(segment, layout, renderer, builder::add, new ViewState(), \"\");\n+        return builder.build();\n+    }\n+\n+    private static void toString0(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  BiFunction<ValueLayout, Object, String> renderer,\n+                                  Consumer<String> action,\n+                                  ViewState state,\n+                                  String suffix) {\n+\n+        \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n+\n+        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n+            action.accept(renderValueLayout(state, ofBoolean, renderer.apply(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfByte ofByte) {\n+            action.accept(renderValueLayout(state, ofByte, renderer.apply(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfShort ofShort) {\n+            action.accept(renderValueLayout(state, ofShort, renderer.apply(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfInt ofInt) {\n+            action.accept(renderValueLayout(state, ofInt, renderer.apply(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfLong ofLong) {\n+            action.accept(renderValueLayout(state, ofLong, renderer.apply(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfFloat ofFloat) {\n+            action.accept(renderValueLayout(state, ofFloat, renderer.apply(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfDouble ofDouble) {\n+            action.accept(renderValueLayout(state, ofDouble, renderer.apply(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            return;\n+        }\n+        if (layout instanceof ValueLayout.OfChar ofChar) {\n+            action.accept(renderValueLayout(state, ofChar, renderer.apply(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n+            return;\n+        }\n+        if (layout instanceof AddressLayout ofAddress) {\n+            action.accept(renderValueLayout(state, ofAddress, renderer.apply(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n+            return;\n+        }\n+        if (layout instanceof PaddingLayout paddingLayout) {\n+            action.accept(state.indentSpaces() + paddingLayout.bitSize() + \" padding bits\");\n+            state.indexAndAdd(paddingLayout);\n+            return;\n+        }\n+        if (layout instanceof GroupLayout groupLayout) {\n+\n+            \/* Strictly, we should provide all permutations of unions.\n+             * So, if we have a union U =  (A|B),(C|D) then we should present:\n+             * (A,C), (A,D), (B,C) and (B,D)\n+             *\/\n+\n+            final var separator = groupLayout instanceof StructLayout\n+                    ? \",\"  \/\/ Struct separator\n+                    : \"|\"; \/\/ Union separator\n+\n+            action.accept(indentedLabel(state, groupLayout) + \" {\");\n+            state.incrementIndent();\n+            final var members = groupLayout.memberLayouts();\n+            final long initialIndex = state.index();\n+            long maxIndex = initialIndex;\n+            for (int i = 0; i < members.size(); i++) {\n+                if (groupLayout instanceof UnionLayout) {\n+                    \/\/ If it is a union, we need to reset the index for each member\n+                    state.index(initialIndex);\n+                    \/\/ We record the max index used for any union member so we can leave off from there\n+                    maxIndex = Math.max(maxIndex, state.index());\n+                }\n+                toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n+                if (groupLayout instanceof UnionLayout) {\n+                    \/\/ This is the best we can do.\n+                    state.index(maxIndex);\n+                }\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"}\" + suffix);\n+            return;\n+        }\n+        if (layout instanceof SequenceLayout sequenceLayout) {\n+            action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n+            state.incrementIndent();\n+            final long elementCount = sequenceLayout.elementCount();\n+            for (long i = 0; i < elementCount; i++) {\n+                toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+            }\n+            state.decrementIndent();\n+            action.accept(state.indentSpaces() + \"]\" + suffix);\n+            return;\n+        }\n+        action.accept(state.indentSpaces() + \"Unknown layout: \" + layout + \" at index \" + state.index());\n+        state.indexAndAdd(layout);\n+    }\n+\n+    static String renderValueLayout(ViewState state,\n+                                    ValueLayout layout,\n+                                    String value,\n+                                    String suffix) {\n+        return indentedLabel(state, layout) + \"=\" + value + suffix;\n+    }\n+\n+    static String indentedLabel(ViewState state,\n+                                MemoryLayout layout) {\n+        return state.indentSpaces() + layout.name()\n+                .orElseGet(layout::toString);\n+    }\n+\n+    static final class ViewState {\n+\n+        private static final int SPACES_PER_INDENT = 4;\n+\n+        \/\/ Holding a non-static indents allows simple thread-safe use\n+        private final StringBuilder indents = new StringBuilder();\n+\n+        private int indent;\n+        private long index;\n+\n+        void incrementIndent() {\n+            indent++;\n+        }\n+\n+        void decrementIndent() {\n+            indent--;\n+        }\n+\n+        String indentSpaces() {\n+            final int spaces = indent * SPACES_PER_INDENT;\n+            while (indents.length() < spaces) {\n+                \/\/ Expand as needed\n+                indents.append(\" \");\n+            }\n+            return indents.substring(0, spaces);\n+        }\n+\n+        long index() {\n+            return index;\n+        }\n+\n+        void index(long index) {\n+            this.index = index;\n+        }\n+\n+        long indexAndAdd(long delta) {\n+            final long val = index;\n+            index += delta;\n+            return val;\n+        }\n+\n+        long indexAndAdd(MemoryLayout layout) {\n+            return indexAndAdd(layout.byteSize());\n+        }\n+    }\n+\n+    private static final class StandardValueLayoutRenderer implements BiFunction<ValueLayout, Object, String> {\n+\n+        @Override\n+        public String apply(ValueLayout layout, Object o) {\n+            requireNonNull(layout);\n+            requireNonNull(o);\n+\n+            \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n+\n+            if (layout instanceof ValueLayout.OfBoolean ofBoolean && o instanceof Boolean b) {\n+                return Boolean.toString(b);\n+            }\n+            if (layout instanceof ValueLayout.OfByte ofByte && o instanceof Byte b) {\n+                return Byte.toString(b);\n+            }\n+            if (layout instanceof ValueLayout.OfShort ofShort && o instanceof Short s) {\n+                return Short.toString(s);\n+            }\n+            if (layout instanceof ValueLayout.OfInt ofInt && o instanceof Integer i) {\n+                return Integer.toString(i);\n+            }\n+            if (layout instanceof ValueLayout.OfLong ofLong && o instanceof Long l) {\n+                return Long.toString(l);\n+            }\n+            if (layout instanceof ValueLayout.OfFloat ofFloat && o instanceof Float f) {\n+                return Float.toString(f);\n+            }\n+            if (layout instanceof ValueLayout.OfDouble ofDouble && o instanceof Double d) {\n+                return Double.toString(d);\n+            }\n+            if (layout instanceof ValueLayout.OfChar ofChar && o instanceof Character c) {\n+                return Character.toString(c);\n+            }\n+            if (layout instanceof AddressLayout ofAddress && o instanceof MemorySegment m) {\n+                return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", m.address());\n+            }\n+            throw new UnsupportedOperationException(\"layout \" + layout + \" for \" + o.getClass().getName() + \" not supported\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return singletonToString(StandardValueLayoutRenderer.class);\n+        }\n+    }\n+\n+    private static String singletonToString(Class<?> implementingClass) {\n+        return \"The \" + implementingClass.getName() + \" singleton\";\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryInspection\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.VarHandle;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.MemoryInspection;\n+import org.testng.annotations.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+import static java.util.Objects.requireNonNull;\n+\n+@Test\n+public class TestMemoryInspection {\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n+\n+    @Test\n+    public void valueLayouts() {\n+\n+        record TestInput(ValueLayout layout, String stringValue) {\n+        }\n+\n+        List.of(\n+                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n+                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n+                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n+                new TestInput(JAVA_BOOLEAN, \"false\"),\n+                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n+        ).forEach(ti -> {\n+            var expect = ti.layout() + \"=\" + ti.stringValue();\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> jdk.internal.foreign.MemoryInspection.inspect(s, ti.layout(), jdk.internal.foreign.MemoryInspection.standardRenderer()))\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        });\n+    }\n+\n+    @Test\n+    public void point() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, Point.LAYOUT, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void pointCustomRenderer() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=0x0001,\n+                    y=0x0002\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemoryInspection.inspect(segment, Point.LAYOUT, new BiFunction<ValueLayout, Object, String>() {\n+\n+                        @Override\n+                        public String apply(ValueLayout layout, Object o) {\n+                            return String.format(\"0x%04x\", (int)o);\n+                        }\n+                    })\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void standardCustomRenderer() {\n+\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                \/\/ These are in bit alignment order (descending) for all platforms\n+                \/\/ in order for each element to be aligned to its type's bit alignment.\n+                Stream.of(\n+                                JAVA_LONG,\n+                                JAVA_DOUBLE,\n+                                ADDRESS,\n+                                JAVA_INT,\n+                                JAVA_FLOAT,\n+                                JAVA_SHORT,\n+                                JAVA_CHAR,\n+                                JAVA_BOOLEAN,\n+                                JAVA_BYTE\n+                        )\n+                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n+                        .toArray(MemoryLayout[]::new)\n+        ).withName(\"struct\");\n+\n+        System.out.println(\"layout = \" + layout);\n+        var expect = platformLineSeparated(\"\"\"\n+                struct {\n+                    long=0,\n+                    double=0.0,\n+                    MemorySegment=$1,\n+                    int=0,\n+                    float=0.0,\n+                    short=0,\n+                    char=\\u0000,\n+                    boolean=false,\n+                    byte=0\n+                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n+\n+\n+        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n+                jdk.internal.foreign.MemoryInspection.inspect(segment, layout, jdk.internal.foreign.MemoryInspection.standardRenderer()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void sequence() {\n+        final int arraySize = 4;\n+        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n+                MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"x\"),\n+                        ValueLayout.JAVA_INT.withName(\"y\")\n+                ).withName(\"Point\")\n+        ).withName(\"PointArrayOfElements\");\n+\n+        var xh = sequenceLayout.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"x\"));\n+        var yh = sequenceLayout.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"y\"));\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                PointArrayOfElements [\n+                    Point {\n+                        x=1,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=1,\n+                        y=1\n+                    },\n+                    Point {\n+                        x=1,\n+                        y=2\n+                    },\n+                    Point {\n+                        x=1,\n+                        y=3\n+                    }\n+                ]\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment -> {\n+            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                xh.set(segment, i, 1);\n+                yh.set(segment, i, (int) i);\n+            }\n+\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, sequenceLayout, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                .collect(joining(System.lineSeparator()));}\n+        );\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void union() {\n+        var u0 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                MemoryLayout.paddingLayout(Integer.SIZE)\n+        ).withName(\"Point\");\n+\n+        var u1 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                ValueLayout.JAVA_INT.withName(\"z\")\n+        ).withName(\"3D-Point\");\n+\n+        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Union {\n+                    Point {\n+                        x=1,\n+                        y=2,\n+                        32 padding bits\n+                    }|\n+                    3D-Point {\n+                        x=1,\n+                        y=2,\n+                        z=3\n+                    }\n+                }\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment -> {\n+            u0.varHandle(PathElement.groupElement(\"x\")).set(segment, 1);\n+            u1.varHandle(PathElement.groupElement(\"y\")).set(segment, 2);\n+            u1.varHandle(PathElement.groupElement(\"z\")).set(segment, 3);\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, union, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    static final class Point {\n+\n+        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\")\n+        ).withName(\"Point\");\n+\n+        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+\n+        private final MemorySegment memorySegment;\n+\n+        Point(MemorySegment memorySegment) {\n+            this.memorySegment = requireNonNull(memorySegment);\n+        }\n+\n+        int x() {\n+            return (int) xVH.get(memorySegment);\n+        }\n+\n+        int y() {\n+            return (int) yVH.get(memorySegment);\n+        }\n+\n+        void x(int x) {\n+            xVH.set(memorySegment, x);\n+        }\n+\n+        void y(int y) {\n+            yVH.set(memorySegment, y);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n+        }\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -49,15 +49,26 @@\n-    @Test(dataProvider = \"slices\")\n-    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.byteSize(), s2.byteSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s2, i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s1, i, i);\n-        }\n-        \/\/perform copy\n-        MemorySegment.copy(s1.segment, 0, s2.segment, 0, size);\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.check(s2, i, i);\n+    static final int TEST_BYTE_SIZE = 16;\n+\n+    @Test(dataProvider = \"segmentKinds\")\n+    public void testByteCopy(SegmentKind kind1, SegmentKind kind2) {\n+        MemorySegment s1 = kind1.makeSegment(TEST_BYTE_SIZE);\n+        MemorySegment s2 = kind2.makeSegment(TEST_BYTE_SIZE);\n+\n+        \/\/ for all offsets\n+        for (int s1Offset = 0; s1Offset < s1.byteSize(); s1Offset++) {\n+            for (int s2Offset = 0; s2Offset < s2.byteSize(); s2Offset++) {\n+                long slice1ByteSize = s1.byteSize() - s1Offset;\n+                long slice2ByteSize = s2.byteSize() - s2Offset;\n+\n+                long copySize = Math.min(slice1ByteSize, slice2ByteSize);\n+\n+                \/\/prepare source slice\n+                for (int i = 0 ; i < copySize; i++) {\n+                    Type.BYTE.set(s1, s1Offset, i, i);\n+                }\n+                \/\/perform copy\n+                MemorySegment.copy(s1, Type.BYTE.layout, s1Offset, s2, Type.BYTE.layout, s2Offset, copySize);\n+                \/\/check that copy actually worked\n+                for (int i = 0; i < copySize; i++) {\n+                    Type.BYTE.check(s2, s2Offset, i, i);\n+                }\n+            }\n@@ -67,16 +78,27 @@\n-    @Test(dataProvider = \"slices\")\n-    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n-        if (s1.type.carrier != s2.type.carrier) return;\n-        int size = Math.min(s1.elementSize(), s2.elementSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            s2.set(i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            s1.set(i, i);\n-        }\n-        \/\/perform copy\n-        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n-        \/\/check that copy actually worked\n-        for (int i = 0; i < size; i++) {\n-            s2.check(i, i);\n+    @Test(dataProvider = \"segmentKindsAndTypes\")\n+    public void testElementCopy(SegmentKind kind1, SegmentKind kind2, Type type1, Type type2) {\n+        MemorySegment s1 = kind1.makeSegment(TEST_BYTE_SIZE);\n+        MemorySegment s2 = kind2.makeSegment(TEST_BYTE_SIZE);\n+\n+        \/\/ for all offsets\n+        for (int s1Offset = 0; s1Offset < s1.byteSize(); s1Offset++) {\n+            for (int s2Offset = 0; s2Offset < s2.byteSize(); s2Offset++) {\n+                long slice1ByteSize = s1.byteSize() - s1Offset;\n+                long slice2ByteSize = s2.byteSize() - s2Offset;\n+\n+                long slice1ElementSize = slice1ByteSize \/ type1.size();\n+                long slice2ElementSize = slice2ByteSize \/ type2.size();\n+\n+                long copySize = Math.min(slice1ElementSize, slice2ElementSize);\n+\n+                \/\/prepare source slice\n+                for (int i = 0 ; i < copySize; i++) {\n+                    type1.set(s1, s1Offset, i, i);\n+                }\n+                \/\/perform copy\n+                MemorySegment.copy(s1, type1.layout, s1Offset, s2, type2.layout, s2Offset, copySize);\n+                \/\/check that copy actually worked\n+                for (int i = 0; i < copySize; i++) {\n+                    type2.check(s2, s2Offset, i, i);\n+                }\n+            }\n@@ -102,6 +124,6 @@\n-        SHORT_LE(short.class, ValueLayout.JAVA_SHORT.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (short)i),\n-        CHAR_LE(char.class, ValueLayout.JAVA_CHAR.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (char)i),\n-        INT_LE(int.class, ValueLayout.JAVA_INT.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> i),\n-        FLOAT_LE(float.class, ValueLayout.JAVA_FLOAT.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (float)i),\n-        LONG_LE(long.class, ValueLayout.JAVA_LONG.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (long)i),\n-        DOUBLE_LE(double.class, ValueLayout.JAVA_DOUBLE.withBitAlignment(8).withOrder(ByteOrder.LITTLE_ENDIAN), i -> (double)i),\n+        SHORT_LE(short.class, ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (short)i),\n+        CHAR_LE(char.class, ValueLayout.JAVA_CHAR_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (char)i),\n+        INT_LE(int.class, ValueLayout.JAVA_INT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> i),\n+        FLOAT_LE(float.class, ValueLayout.JAVA_FLOAT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (float)i),\n+        LONG_LE(long.class, ValueLayout.JAVA_LONG_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (long)i),\n+        DOUBLE_LE(double.class, ValueLayout.JAVA_DOUBLE_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (double)i),\n@@ -109,6 +131,6 @@\n-        SHORT_BE(short.class, ValueLayout.JAVA_SHORT.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (short)i),\n-        CHAR_BE(char.class, ValueLayout.JAVA_CHAR.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (char)i),\n-        INT_BE(int.class, ValueLayout.JAVA_INT.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> i),\n-        FLOAT_BE(float.class, ValueLayout.JAVA_FLOAT.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (float)i),\n-        LONG_BE(long.class, ValueLayout.JAVA_LONG.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (long)i),\n-        DOUBLE_BE(double.class, ValueLayout.JAVA_DOUBLE.withBitAlignment(8).withOrder(ByteOrder.BIG_ENDIAN), i -> (double)i);\n+        SHORT_BE(short.class, ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (short)i),\n+        CHAR_BE(char.class, ValueLayout.JAVA_CHAR_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (char)i),\n+        INT_BE(int.class, ValueLayout.JAVA_INT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> i),\n+        FLOAT_BE(float.class, ValueLayout.JAVA_FLOAT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (float)i),\n+        LONG_BE(long.class, ValueLayout.JAVA_LONG_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (long)i),\n+        DOUBLE_BE(double.class, ValueLayout.JAVA_DOUBLE_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN), i -> (double)i);\n@@ -127,2 +149,2 @@\n-        int size() {\n-            return (int)layout.byteSize();\n+        long size() {\n+            return layout.byteSize();\n@@ -135,2 +157,2 @@\n-        void set(SegmentSlice slice, int index, int val) {\n-            handle().set(slice.segment, index * size(), valueConverter.apply(val));\n+        void set(MemorySegment segment, long offset, int index, int val) {\n+            handle().set(segment, offset + (index * size()), valueConverter.apply(val));\n@@ -139,2 +161,2 @@\n-        void check(SegmentSlice slice, int index, int val) {\n-            assertEquals(handle().get(slice.segment, index * size()), valueConverter.apply(val));\n+        void check(MemorySegment segment, long offset, int index, int val) {\n+            assertEquals(handle().get(segment, offset + (index * size())), valueConverter.apply(val));\n@@ -144,11 +166,3 @@\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n+    enum SegmentKind {\n+        NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n+        ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n@@ -156,18 +170,1 @@\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final Type type;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.type = type;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n+        final IntFunction<MemorySegment> segmentFactory;\n@@ -175,2 +172,2 @@\n-        void set(int index, int val) {\n-            type.set(this, index, val);\n+        SegmentKind(IntFunction<MemorySegment> segmentFactory) {\n+            this.segmentFactory = segmentFactory;\n@@ -179,10 +176,2 @@\n-        void check(int index, int val) {\n-            type.check(this, index, val);\n-        }\n-\n-        int byteSize() {\n-            return last - first + 1;\n-        }\n-\n-        int elementSize() {\n-            return byteSize() \/ type.size();\n+        MemorySegment makeSegment(int size) {\n+            return segmentFactory.apply(size);\n@@ -190,0 +179,1 @@\n+    }\n@@ -191,3 +181,7 @@\n-        @Override\n-        public String toString() {\n-            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+    @DataProvider\n+    static Object[][] segmentKinds() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (SegmentKind kind1 : SegmentKind.values()) {\n+            for (SegmentKind kind2 : SegmentKind.values()) {\n+                cases.add(new Object[] {kind1, kind2});\n+            }\n@@ -195,0 +189,1 @@\n+        return cases.toArray(Object[][]::new);\n@@ -197,12 +192,9 @@\n-    @DataProvider(name = \"slices\")\n-    static Object[][] elementSlices() {\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (Type type : Type.values()) {\n-                for (int index = 0; index < 16; index += type.size()) {\n-                    MemorySegment first = segment.asSlice(0, index);\n-                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n-                    MemorySegment second = segment.asSlice(index);\n-                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+    @DataProvider\n+    static Object[][] segmentKindsAndTypes() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (Object[] segmentKinds : segmentKinds()) {\n+            for (Type type1 : Type.values()) {\n+                for (Type type2 : Type.values()) {\n+                    if (type1.layout.carrier() == type2.layout.carrier()) {\n+                        cases.add(new Object[]{segmentKinds[0], segmentKinds[1], type1, type2});\n+                    }\n@@ -212,7 +204,1 @@\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n+        return cases.toArray(Object[][]::new);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":98,"deletions":112,"binary":false,"changes":210,"status":"modified"}]}