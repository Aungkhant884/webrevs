{"files":[{"patch":"@@ -71,1 +71,1 @@\n- * and alignment constraint. Alternatively, native segments can be obtained by\n+ * and aligned to the given alignment constraint. Alternatively, native segments can be obtained by\n@@ -224,1 +224,1 @@\n- * <li>A native segment at address 1000 can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint,\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint,\n@@ -227,1 +227,1 @@\n- * <li>A native segment at address 1000 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n@@ -230,1 +230,1 @@\n- * <li>A native segment at address 1000 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint,\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint,\n@@ -233,1 +233,1 @@\n- * <li>A native segment at address 1004 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * <li>A native segment with address 1004 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n@@ -236,1 +236,1 @@\n- * <li>A native segment at address 1006 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n+ * <li>A native segment with address 1006 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n@@ -239,1 +239,1 @@\n- * <li>A native segment at address 1007 can be accessed at offsets 0, 1, 2, 3, etc under a 1-byte alignment constraint.\n+ * <li>A native segment with address 1007 can be accessed at offsets 0, 1, 2, 3, etc under a 1-byte alignment constraint.\n@@ -244,2 +244,0 @@\n- * <!-- Under a 1-byte alignment constraint, any offset address in a native segment can be accessed. -->\n- * <!-- In effect, every target address is at least 1-byte aligned. -->\n@@ -250,1 +248,1 @@\n- * or {@link #allocateNative(MemoryLayout)}. These factories ensure that the off-heap region of memory associated with\n+ * or {@link #allocateNative(MemoryLayout)}. These factories ensure that the off-heap region of memory backing\n@@ -257,1 +255,1 @@\n- * determine a target address in physical memory. Since the alignment constraint <em>always<\/em> refer to alignment of\n+ * determine a target address in physical memory. Since the alignment constraint <em>always<\/em> refers to alignment of\n@@ -364,1 +362,1 @@\n- * into the size of the region of memory associated with a pointer returned from a foreign function, it also has no insight\n+ * into the size of the region of memory backing a pointer returned from a foreign function, also has no insight\n@@ -379,1 +377,1 @@\n- * Alternatively, clients can obtain, <em>unsafely<\/em>, an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbound}\n+ * Alternatively, clients can obtain, <em>unsafely<\/em>, an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n@@ -381,1 +379,1 @@\n- * uses one or more unbound address value layouts, the API will wrap any corresponding raw addresses with native segments\n+ * uses one or more unbounded address value layouts, the API will wrap any corresponding raw addresses with native segments\n@@ -923,1 +921,1 @@\n-     * Creates a memory segment that models the memory associated with the given {@link Buffer} instance.\n+     * Creates a memory segment that is backed by the same region of memory that backs the given {@link Buffer} instance.\n@@ -928,1 +926,1 @@\n-     * the return segment is a native segment; otherwise the returned memory segment is a heap segment.\n+     * the returned segment is a native segment; otherwise the returned memory segment is a heap segment.\n@@ -935,1 +933,1 @@\n-     *     <li>if the buffer is an heap buffer, then {@code S} is the {@linkplain MemorySession#global() global session}; or\n+     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain MemorySession#global() global session}; or\n@@ -938,1 +936,1 @@\n-     *     Therefore, the off-heap memory associated with the buffer instance will remain available as long as the\n+     *     Therefore, the off-heap region of memory backing the buffer instance will remain available as long as the\n@@ -942,2 +940,2 @@\n-     * @param buffer the buffer instance to be wrapped by a new memory segment.\n-     * @return a memory segment, wrapping the given buffer instance.\n+     * @param buffer the buffer instance to be turned into a new memory segment.\n+     * @return a memory segment, derived from the given buffer instance.\n@@ -950,1 +948,1 @@\n-     * Creates a heap segment that models the region of memory associated with the given heap-allocated byte array.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given byte array.\n@@ -962,1 +960,1 @@\n-     * Creates a heap segment that models the region of memory associated with the given char array.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given char array.\n@@ -974,1 +972,1 @@\n-     * Creates a heap segment that models the region of memory associated with the given short array.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given short array.\n@@ -986,1 +984,1 @@\n-     * Creates a heap segment that models the region of memory associated with the given int array.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given int array.\n@@ -991,1 +989,1 @@\n-     * @return a heap memory segment backed by a int array.\n+     * @return a heap memory segment backed by an int array.\n@@ -998,1 +996,1 @@\n-     * Creates a heap segment that models the region of memory associated with the given float array.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given float array.\n@@ -1010,1 +1008,1 @@\n-     * Creates a heap segment that models the region of memory associated with the given long array.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given long array.\n@@ -1022,1 +1020,1 @@\n-     * Creates a heap segment that models the region of memory associated with the given double array.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given double array.\n@@ -1138,1 +1136,1 @@\n-     * The region of off-heap region of memory associated with the returned native segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -1161,1 +1159,1 @@\n-     * {@link MemorySession#allocate(MemoryLayout)} method.\n+     * {@link MemorySession#allocate(long)} method.\n@@ -1169,1 +1167,1 @@\n-     * The off-heap region of memory associated with the returned native segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -1173,1 +1171,1 @@\n-     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteSize the size (in bytes) of the off-heap memory region of memory backing the native memory segment.\n@@ -1195,1 +1193,1 @@\n-     * {@link MemorySession#allocate(MemoryLayout)} method.\n+     * {@link MemorySession#allocate(long,long)} method.\n@@ -1203,1 +1201,1 @@\n-     * The off-heap region of memory associated with the returned native segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -1205,2 +1203,2 @@\n-     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteSize the size (in bytes) of the off-heap region of memory backing the native memory segment.\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n@@ -2063,1 +2061,1 @@\n-     *     This means that the two segments either refer at the same location in some off-heap region, or they refer\n+     *     This means that the two segments either refer to the same location in some off-heap region, or they refer\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":35,"deletions":37,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * the off-heap memory associated with said segments.\n+ * the off-heap memory backing said segments.\n@@ -225,1 +225,1 @@\n-     * The off-heap region of memory associated with the returned native memory segment is initialized to zero.\n+     * The off-heap region of memory backing the returned native memory segment is initialized to zero.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n- *     <li>It can be used to access the region of memory associated with a global variable (this might require\n+ *     <li>It can be used to access the region of memory backing a global variable (this might require\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * The off-heap memory associated with the native segment will be released when the segment becomes\n+ * The off-heap memory backing the native segment will be released when the segment becomes\n@@ -72,2 +72,2 @@\n- * Clients that operate under these assumptions might want to programmatically release the memory associated\n- * with a memory segment. This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n+ * Clients that operate under these assumptions might want to programmatically release the memory backing a memory segment.\n+ * This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n@@ -100,1 +100,1 @@\n- * operation either succeeds - and accesses a valid location of the region of memory associated with the memory segment - or fails.\n+ * operation either succeeds - and accesses a valid location of the region of memory backing the memory segment - or fails.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}