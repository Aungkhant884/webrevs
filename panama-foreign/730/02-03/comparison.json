{"files":[{"patch":"@@ -366,3 +366,3 @@\n- * To access native zero-length memory segments, clients have two options. First, they can\n- * {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) obtain}\n- * a <em>new<\/em> native segment <em>unsafely<\/em>, with new spatial and temporal bounds, as follows:\n+ * To access native zero-length memory segments, clients have two options, both of which are <em>unsafe<\/em>. Clients\n+ * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) obtain}\n+ * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n@@ -377,1 +377,1 @@\n- * Alternatively, clients can obtain, <em>unsafely<\/em>, an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n+ * Alternatively, clients can obtain an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n@@ -379,2 +379,2 @@\n- * uses one or more unbounded address value layouts, the API will wrap any corresponding raw addresses with native segments\n- * with maximal size (e.g. {@linkplain java.lang.Long#MAX_VALUE}). As such, these segments might be accessed directly, as follows:\n+ * uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments\n+ * with <em>maximal<\/em> size (i.e. {@linkplain java.lang.Long#MAX_VALUE}). As such, these segments can be accessed directly, as follows:\n@@ -395,1 +395,1 @@\n- * be associated with a given native pointer. In these cases using an unbounded address layout might be preferrable.\n+ * be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}