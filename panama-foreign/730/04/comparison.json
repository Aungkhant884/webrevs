{"files":[{"patch":"@@ -124,1 +124,1 @@\n- * {@linkplain ValueLayout.OfAddress address layout} returns a native memory segment associated with\n+ * {@linkplain ValueLayout.OfAddress address layout} returns a native segment associated with\n@@ -138,1 +138,1 @@\n- * is a native memory segment associated with the {@linkplain MemorySession#global() global session}.\n+ * is a native segment associated with the {@linkplain MemorySession#global() global session}.\n@@ -163,1 +163,1 @@\n-     *     to the size and alignment constraints of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n+     *     to the size and alignment constraint of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n@@ -203,1 +203,1 @@\n-     * Creates a method handle which can be used to call a target foreign function with the given signature and address.\n+     * Creates a method handle which can be used to call a foreign function with the given signature and address.\n@@ -206,2 +206,2 @@\n-     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker runtime\n-     * to allocate structs returned by-value.\n+     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker to allocate\n+     * structs returned by-value.\n@@ -228,1 +228,1 @@\n-     * Creates a method handle which can be used to call a target foreign function with the given signature.\n+     * Creates a method handle which can be used to call a foreign function with the given signature.\n@@ -235,1 +235,1 @@\n-     * which will be used by the linker runtime to allocate structs returned by-value.\n+     * which will be used by the linker to allocate structs returned by-value.\n@@ -254,1 +254,1 @@\n-     * The returned memory segment's base address points to the newly allocated upcall stub, and is associated with\n+     * The returned memory segment's address points to the newly allocated upcall stub, and is associated with\n@@ -266,1 +266,1 @@\n-     * @return a zero-length segment whose base address is the address of the upcall stub.\n+     * @return a zero-length segment whose address is the address of the upcall stub.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-     * Returns a memory layout of the same type with the same size and alignment constraints as this layout,\n+     * Returns a memory layout of the same type with the same size and alignment constraint as this layout,\n@@ -244,1 +244,1 @@\n-     * but with the specified alignment constraints (in bits).\n+     * but with the specified alignment constraint (in bits).\n@@ -247,1 +247,1 @@\n-     * @return a memory layout with the given alignment constraints.\n+     * @return a memory layout with the given alignment constraint.\n@@ -356,1 +356,1 @@\n-     * Creates an access var handle that can be used to dereference memory at the layout selected by the given layout path,\n+     * Creates an access var handle that can be used to access a memory segment at the layout selected by the given layout path,\n@@ -359,1 +359,1 @@\n-     * The final memory location accessed by the returned var handle can be computed as follows:\n+     * The final address accessed by the returned var handle can be computed as follows:\n@@ -362,1 +362,1 @@\n-     * address = base + offset\n+     * address = base(segment) + offset\n@@ -365,2 +365,4 @@\n-     * where {@code base} denotes the base address associated with the {@link MemorySegment} access coordinate\n-     * (see {@link MemorySegment#address()} and {@code offset} can be expressed in the following form:\n+     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed\n+     * memory segment. For native segments, this function just returns the native segment's\n+     * {@linkplain MemorySegment#address() address}. For heap segments, this function is more complex, as the address\n+     * of heap segments is virtualized. The {@code offset} coordinate can be expressed in the following form:\n@@ -385,2 +387,2 @@\n-     * @return a var handle which can be used to dereference memory at the (possibly nested) layout selected by the layout path in {@code elements}.\n-     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraints.\n+     * @return a var handle which can be used to access a memory segment at the (possibly nested) layout selected by the layout path in {@code elements}.\n+     * @throws UnsupportedOperationException if the layout path has one or more elements with incompatible alignment constraint.\n@@ -583,1 +585,1 @@\n-     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n+     * the same kind, have the same size, name and alignment constraint. Furthermore, depending on the layout kind, additional\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.channels.FileChannel.*;\n@@ -58,6 +59,3 @@\n- * A memory segment models a contiguous region of memory. A memory segment is associated with both spatial\n- * and temporal bounds (e.g. a {@link MemorySession}). Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n- * which falls <em>outside<\/em> the boundaries of the memory segment being accessed. Temporal bounds ensure that memory access\n- * operations on a segment cannot occur after the memory session associated with a memory segment has been closed (see {@link MemorySession#close()}).\n- *\n- * There are many kinds of memory segments:\n+ * A memory segment provides access to a contiguous region of memory.\n+ * <p>\n+ * There are two kinds of memory segments:\n@@ -65,9 +63,2 @@\n- *     <li>{@linkplain MemorySegment#allocateNative(long, long) native memory segments}, backed by off-heap memory;<\/li>\n- *     <li>{@linkplain FileChannel#map(FileChannel.MapMode, long, long, MemorySession) mapped memory segments}, obtained by mapping\n- * a file into main memory ({@code mmap}); the contents of a mapped memory segments can be {@linkplain #force() persisted} and\n- * {@linkplain #load() loaded} to and from the underlying memory-mapped file;<\/li>\n- *     <li>{@linkplain MemorySegment#ofArray(int[]) array segments}, wrapping an existing, heap-allocated Java array; and<\/li>\n- *     <li>{@linkplain MemorySegment#ofBuffer(Buffer) buffer segments}, wrapping an existing {@link Buffer} instance;\n- * buffer memory segments might be backed by either off-heap memory or on-heap memory, depending on the characteristics of the\n- * wrapped buffer instance. For instance, a buffer memory segment obtained from a byte buffer created with the\n- * {@link ByteBuffer#allocateDirect(int)} method will be backed by off-heap memory.<\/li>\n+ *     <li>A <em>heap segment<\/em> is backed by, and provides access to, a region of memory inside the Java heap (an \"on-heap\" region).<\/li>\n+ *     <li>A <em>native segment<\/em> is backed by, and provides access to, a region of memory outside the Java heap (an \"off-heap\" region).<\/li>\n@@ -75,0 +66,13 @@\n+ * Heap segments can be obtained by calling one of the {@link MemorySegment#ofArray(int[])} factory methods.\n+ * These methods return a memory segment backed by the on-heap region that holds the specified Java array.\n+ * <p>\n+ * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long)}\n+ * factory methods, which return a memory segment backed by a newly allocated off-heap region with the given size\n+ * and aligned to the given alignment constraint. Alternatively, native segments can be obtained by\n+ * {@link FileChannel#map(MapMode, long, long, MemorySession) mapping} a file into a new off-heap region\n+ * (in some systems, this operation is sometimes referred to as {@code mmap}).\n+ * Segments obtained in this way are called <em>mapped<\/em> segments, and their contents can be {@linkplain #force() persisted} and\n+ * {@linkplain #load() loaded} to and from the underlying memory-mapped file.\n+ * <p>\n+ * Both kinds of segments are read and written using the same methods, known as <a href=\"#segment-deref\">access operations<\/a>.\n+ * An access operation on a memory segment always and only provides access to the region for which the segment was obtained.\n@@ -76,1 +80,1 @@\n- * <h2 id=\"lifecyle-confinement\">Lifecycle and confinement<\/h2>\n+ * <h2 id=\"segment-characteristics\">Characteristics of memory segments<\/h2>\n@@ -78,13 +82,11 @@\n- * Memory segments are associated with a {@linkplain MemorySegment#session() memory session}. As for all resources associated\n- * with a memory session, a segment cannot be accessed after its underlying session has been closed. For instance,\n- * the following code will result in an exception:\n- * {@snippet lang=java :\n- * MemorySegment segment = null;\n- * try (MemorySession session = MemorySession.openConfined()) {\n- *     segment = MemorySegment.allocateNative(8, session);\n- * }\n- * segment.get(ValueLayout.JAVA_LONG, 0); \/\/ already closed!\n- * }\n- * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning memory\n- * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads;\n- * if it is associated with a confined session, it can only be accessed by the thread which owns the memory session.\n+ * Every memory segment has an {@linkplain #address() address}, expressed as a {@code long} value.\n+ * The nature of a segment's address depends on the kind of the segment:\n+ * <ul>\n+ * <li>The address of a heap segment is not a physical address, but rather an offset within the region of memory\n+ * which backs the segment. The region is inside the Java heap, so garbage collection might cause the region to be\n+ * relocated in physical memory over time, but this is not exposed to clients of the {@code MemorySegment} API who\n+ * see a stable <em>virtualized<\/em> address for a heap segment backed by the region.\n+ * A heap segment obtained from one of the {@link #ofArray(int[])} factory methods has an address of zero.<\/li>\n+ * <li>The address of a native segment (including mapped segments) denotes the physical address of the region of\n+ * memory which backs the segment.<\/li>\n+ * <\/ul>\n@@ -92,5 +94,20 @@\n- * Heap segments are always associated with the {@linkplain MemorySession#global() global} memory session.\n- * This session cannot be closed, and segments associated with it can be considered as <em>always alive<\/em>.\n- * Buffer segments are typically associated with the global memory session, with one exception: buffer segments created\n- * from byte buffer instances obtained calling the {@link #asByteBuffer()} method on a memory segment {@code S}\n- * are associated with the same memory session as {@code S}.\n+ * Every memory segment has a {@linkplain #byteSize() size}. The size of a heap segment is derived from the Java array\n+ * from which it is obtained. This size is predictable across Java runtimes.\n+ * The size of a native segment is either passed explicitly\n+ * (as in {@link MemorySegment#allocateNative(long)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link MemorySegment#allocateNative(MemoryLayout)}). The size of a memory segment is typically\n+ * a positive number but may be <a href=\"#wrapping-addresses\">zero<\/a>, but never negative.\n+ * <p>\n+ * The address and size of a memory segment jointly ensure that access operations on the segment cannot fall\n+ * <em>outside<\/em> the boundaries of the region of memory which backs the segment.\n+ * That is, a memory segment has <em>spatial bounds<\/em>.\n+ * <p>\n+ * Every memory segment is associated with a {@linkplain MemorySession memory session}. This ensures that access operations\n+ * on a memory segment cannot occur when the region of memory which backs the memory segment is no longer available\n+ * (e.g. after the memory session associated with the accessed memory segment has been {@linkplain MemorySession#close() closed}).\n+ * That is, a memory segment has <em>temporal bounds<\/em>.\n+ * <p>\n+ * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated memory\n+ * session; that is, if the segment is associated with a {@linkplain MemorySession#openShared() shared session},\n+ * it can be accessed by multiple threads; if it is associated with a {@linkplain MemorySession#openConfined() confined session},\n+ * it can only be accessed by the thread which owns the memory session.\n@@ -98,1 +115,1 @@\n- * <h2 id=\"segment-deref\">Dereferencing memory segments<\/h2>\n+ * <h2 id=\"segment-deref\">Accessing memory segments<\/h2>\n@@ -100,3 +117,3 @@\n- * A memory segment can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n- * Each dereference method takes a {@linkplain ValueLayout value layout}, which specifies the size,\n- * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * A memory segment can be read or written using various access operations provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each access operation takes a {@linkplain ValueLayout value layout}, which specifies the size and shape of the value,\n+ * and an offset, expressed in bytes.\n@@ -109,1 +126,1 @@\n- * If the value to be read is stored in memory using {@linkplain ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * If the value to be read is stored in memory using {@linkplain ByteOrder#BIG_ENDIAN big-endian} encoding, the access operation\n@@ -116,1 +133,1 @@\n- * For more complex dereference operations (e.g. structured memory access), clients can obtain a\n+ * For more complex access operations (e.g. structured memory access), clients can obtain a\n@@ -145,3 +162,5 @@\n- * Memory segments support <em>slicing<\/em>. A memory segment can be used to {@linkplain MemorySegment#asSlice(long, long) obtain}\n- * other segments backed by the same underlying memory region, but with <em>stricter<\/em> spatial bounds than the ones\n- * of the original segment:\n+ * Memory segments support {@linkplain MemorySegment#asSlice(long, long) slicing}. Slicing a memory segment\n+ * returns a new memory segment that is backed by the same region of memory as the original. The address of the sliced\n+ * segment is derived from the address of the original segment, by adding an offset (expressed in bytes). The size of\n+ * the sliced segment is either derived implicitly (by subtracting the specified offset from the size of the original segment),\n+ * or provided explicitly. In other words, a sliced segment has <em>stricter<\/em> spatial bounds than those of the original segment:\n@@ -157,1 +176,2 @@\n- * of {@code segment}, and is 10 bytes long. As a result, attempting to read an int value at offset 20 of the\n+ * of {@code segment}, and is 10 bytes long. That is, the address of the {@code slice} is {@code segment.address() + 50},\n+ * and its size is 10. As a result, attempting to read an int value at offset 20 of the\n@@ -179,4 +199,16 @@\n- * When dereferencing a memory segment using a layout, the runtime must check that the segment address being dereferenced\n- * matches the layout's {@linkplain MemoryLayout#byteAlignment() alignment constraints}. If the segment being\n- * dereferenced is a native segment, then it has a concrete {@linkplain #address() base address}, which can\n- * be used to perform the alignment check. The pseudo-function below demonstrates this:\n+ * Access operations on a memory segment are constrained not only by the spatial and temporal bounds of the segment,\n+ * but also by the <em>alignment constraint<\/em> of the value layout specified to the operation. An access operation can\n+ * access only those offsets in the segment that denote addresses in physical memory which are <em>aligned<\/em> according\n+ * to the layout. An address in physical memory is <em>aligned<\/em> according to a layout if the address is an integer\n+ * multiple of the layout's alignment constraint. For example, the address 1000 is aligned according to an 8-byte alignment\n+ * constraint (because 1000 is an integer multiple of 8), and to a 4-byte alignment constraint, and to a 2-byte alignment\n+ * constraint; in contrast, the address 1004 is aligned according to a 4-byte alignment constraint, and to a 2-byte alignment\n+ * constraint, but not to an 8-byte alignment constraint.\n+ * Access operations are required to respect alignment because it can impact the performance of access operations, and\n+ * can also determine which access operations are available at a given physical address. For instance,\n+ * {@linkplain java.lang.invoke.VarHandle#compareAndSet(Object...) atomic access operations} operations using\n+ * {@link java.lang.invoke.VarHandle} are only permitted at aligned addresses. In addition, alignment\n+ * applies to an access operation whether the segment being accessed is a native segment or a heap segment.\n+ * <p>\n+ * If the segment being accessed is a native segment, then its {@linkplain #address() address} in physical memory can be\n+ * combined with the offset to obtain the <em>target address<\/em> in physical memory. The pseudo-function below demonstrates this:\n@@ -184,1 +216,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -186,1 +218,1 @@\n- *   return ((segment.address().address() + offset) % layout.byteAlignment()) == 0;\n+ *   return ((segment.address() + offset) % layout.byteAlignment()) == 0;\n@@ -190,4 +222,65 @@\n- * If, however, the segment being dereferenced is a heap segment, the above function will not work: a heap\n- * segment's {@linkplain #address() base address} is <em>virtualized<\/em> and, as such, cannot be used to construct an\n- * alignment check. Instead, heap segments are assumed to produce addresses which are never more aligned than the element\n- * size of the Java array from which they have originated from, as shown in the following table:\n+ * For example:\n+ * <ul>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint,\n+ * because the target addresses (1000, 1008, 1016, 1024) are 8-byte aligned.\n+ * Access at offsets 1-7 or 9-15 or 17-23 is disallowed because the target addresses would not be 8-byte aligned.<\/li>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * because the target addresses (1000, 1004, 1008, 1012) are 4-byte aligned.\n+ * Access at offsets 1-3 or 5-7 or 9-11 is disallowed because the target addresses would not be 4-byte aligned.<\/li>\n+ * <li>A native segment with address 1000 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint,\n+ * because the target addresses (1000, 1002, 1004, 1006) are 2-byte aligned.\n+ * Access at offsets 1 or 3 or 5 is disallowed because the target addresses would not be 2-byte aligned.<\/li>\n+ * <li>A native segment with address 1004 can be accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint,\n+ * and at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n+ * Under an 8-byte alignment constraint, it can be accessed at offsets 4, 12, 20, 28, etc.<\/li>\n+ * <li>A native segment with address 1006 can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint.\n+ * Under a 4-byte alignment constraint, it can be accessed at offsets 2, 6, 10, 14, etc.\n+ * Under an 8-byte alignment constraint, it can be accessed at offsets 2, 10, 18, 26, etc.\n+ * <li>A native segment with address 1007 can be accessed at offsets 0, 1, 2, 3, etc under a 1-byte alignment constraint.\n+ * Under a 2-byte alignment constraint, it can be accessed at offsets 1, 3, 5, 7, etc.\n+ * Under a 4-byte alignment constraint, it can be accessed at offsets 1, 5, 9, 13, etc.\n+ * Under an 8-byte alignment constraint, it can be accessed at offsets 1, 9, 17, 25, etc.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * The alignment constraint used to access a segment is typically dictated by the shape of the data structure stored\n+ * in the segment. For example, if the programmer wishes to store a sequence of 8-byte values in a native segment, then\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long)}\n+ * or {@link #allocateNative(MemoryLayout)}. These factories ensure that the off-heap region of memory backing\n+ * the returned segment has a starting address that is 8-byte aligned. Subsequently, the programmer can access the\n+ * segment at the offsets of interest -- 0, 8, 16, 24, etc -- in the knowledge that every such access is aligned.\n+ * <p>\n+ * If the segment being accessed is a heap segment, then determining whether access is aligned is more complex.\n+ * The address of the segment in physical memory is not known, and is not even fixed (it may change when the segment\n+ * is relocated during garbage collection). This means that the address cannot be combined with the specified offset to\n+ * determine a target address in physical memory. Since the alignment constraint <em>always<\/em> refers to alignment of\n+ * addresses in physical memory, it is not possible in principle to determine if any offset in a heap segment is aligned.\n+ * For example, suppose the programmer chooses a 8-byte alignment constraint and tries\n+ * to access offset 16 in a heap segment. If the heap segment's address 0 corresponds to physical address 1000,\n+ * then the target address (1016) would be aligned, but if address 0 corresponds to physical address 1004,\n+ * then the target address (1020) would not be aligned. It is undesirable to allow access to target addresses that are\n+ * aligned according to the programmer's chosen alignment constraint, but might not be predictably aligned in physical memory\n+ * (e.g. because of platform considerations and\/or garbage collection behavior).\n+ * <p>\n+ * In practice, the Java runtime lays out arrays in memory so that each n-byte element occurs at an n-byte\n+ * aligned physical address. The runtime preserves this invariant even if the array is relocated during garbage\n+ * collection. Access operations rely on this invariant to determine if the specified offset in a heap segment refers\n+ * to an aligned address in physical memory. For example:\n+ * <ul>\n+ * <li>The starting physical address of a {@code long[]} array will be 8-byte aligned (e.g. 1000), so that successive long elements\n+ * occur at 8-byte aligned addresses (e.g., 1000, 1008, 1016, 1024, etc.) A heap segment backed by a {@code long[]} array\n+ * can be accessed at offsets 0, 8, 16, 24, etc under an 8-byte alignment constraint. In addition, the segment can be\n+ * accessed at offsets 0, 4, 8, 12, etc under a 4-byte alignment constraint, because the target addresses\n+ * (1000, 1004, 1008, 1012) are 4-byte aligned. And, the segment can be accessed at offsets 0, 2, 4, 6, etc under a\n+ * 2-byte alignment constraint, because the target addresses (e.g. 1000, 1002, 1004, 1006) are 2-byte aligned.<\/li>\n+ * <li>The starting physical address of a {@code short[]} array will be 2-byte aligned (e.g. 1006) so that successive\n+ * short elements occur at 2-byte aligned addresses (e.g. 1006, 1008, 1010, 1012, etc). A heap segment backed by a\n+ * {@code short[]} array can be accessed at offsets 0, 2, 4, 6, etc under a 2-byte alignment constraint. The segment cannot\n+ * be accessed at <em>any<\/em> offset under a 4-byte alignment constraint, because there is no guarantee that the target\n+ * address would be 4-byte aligned, e.g., offset 0 would correspond to physical address 1006 while offset 1 would correspond\n+ * to physical address 1007. Similarly, the segment cannot be accessed at any offset under an 8-byte alignment constraint,\n+ * because because there is no guarantee that the target address would be 8-byte aligned, e.g., offset 2 would correspond\n+ * to physical address 1008 but offset 4 would correspond to physical address 1010.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * In other words, heap segments feature a <em>maximum<\/em> alignment which is derived from the size of the elements of\n+ * the Java array backing the segment, as shown in the following table:\n@@ -196,1 +289,1 @@\n- * <caption style=\"display:none\">Array type of an array backing a segment and its address alignment<\/caption>\n+ * <caption style=\"display:none\">Maximum alignment of heap segments<\/caption>\n@@ -199,2 +292,2 @@\n- *     <th scope=\"col\">Array type<\/th>\n- *     <th scope=\"col\">Alignment<\/th>\n+ *     <th scope=\"col\">Array type (of backing region)<\/th>\n+ *     <th scope=\"col\">Maximum supported alignment (in bytes)<\/th>\n@@ -223,3 +316,60 @@\n- * Note that the above definition is conservative: it might be possible, for instance, that a heap segment\n- * constructed from a {@code byte[]} might have a subset of addresses {@code S} which happen to be 8-byte aligned. But determining\n- * which segment addresses belong to {@code S} requires reasoning about details which are ultimately implementation-dependent.\n+ * Heap segment can only be accessed using a layout whose alignment is smaller or equal to the\n+ * maximum alignment associated with the heap segment. Attempting to access a heap segment using a layout\n+ * whose alignment is greater than the maximum alignment associated with the heap segment will fail,\n+ * as demonstrated in the following example:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+ * byteSegment.get(ValueLayout.JAVA_INT, 0); \/\/ fails: layout alignment is 4, segment max alignment is 1\n+ * }\n+ *\n+ * In such circumstances, clients have two options. They can use a heap segment backed by a different array\n+ * type (e.g. {@code long[]}), capable of supporting greater maximum alignment:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment longSegment = MemorySegment.ofArray(new long[10]);\n+ * longSegment.get(ValueLayout.JAVA_INT, 0); \/\/ ok: layout alignment is 4, segment max alignment is 8\n+ * }\n+ *\n+ * Alternatively, they can invoke the access operation with a layout whose alignment is smaller:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment byteSegment = MemorySegment.ofArray(new byte[10]);\n+ * byteSegment.get(ValueLayout.JAVA_INT.withBitAlignment(8), 0); \/\/ ok: layout alignment is 1, segment max alignment is 1\n+ * }\n+ *\n+ * <h2 id=\"wrapping-addresses\">Zero-length memory segments<\/h2>\n+ *\n+ * When interacting with <a href=\"package-summary.html#ffa\">foreign functions<\/a>, it is common for those functions\n+ * to allocate a region of memory and return a pointer to that region. Modeling the region of memory with a memory segment\n+ * is challenging because the Java runtime has no insight into the size of the region. Only the address of the start of\n+ * the region, stored in the pointer, is available. For example, a C function with return type {@code char*} might return\n+ * a pointer to a region containing a single {@code char} value, or to a region containing an array of {@code char} values,\n+ * where the size of the array might be provided in a separate parameter. The size of the array is not readily apparent\n+ * to the code calling the foreign function and hoping to use its result.\n+ * <p>\n+ * The {@link Linker} represents a pointer returned from a foreign function with a <em>zero-length memory segment<\/em>.\n+ * The address of the segment is the address stored in the pointer. The size of the segment is zero. Similarly, when a\n+ * client reads an <em>address<\/em> from a memory segment, a zero-length memory segment is returned.\n+ * <p>\n+ * Since a zero-length segment features trivial spatial bounds, any attempt to access these segments will fail with\n+ * {@link IndexOutOfBoundsException}. This is a crucial safety feature: as these segments are associated with a region\n+ * of memory whose size is not known, any access operations involving these segments cannot be validated.\n+ * In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent.\n+ * <p>\n+ * Zero-length memory segments obtained when interacting with foreign functions are associated with the\n+ * {@link MemorySession#global() global} memory session. This is because the Java runtime, in addition to having no insight\n+ * into the size of the region of memory backing a pointer returned from a foreign function, also has no insight\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it. The global memory\n+ * session ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * <p>\n+ * To access native zero-length memory segments, clients have two options, both of which are <em>unsafe<\/em>. Clients\n+ * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) obtain}\n+ * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySession session = ... \/\/ initialize a memory session\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n+ * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, session); \/\/ create new segment (size = 4)\n+ * int x = segment.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n@@ -227,7 +377,13 @@\n- * <h2 id=\"restricted-segments\">Restricted memory segments<\/h2>\n- * Sometimes it is necessary to turn a raw address (e.g. obtained from native code) into a memory segment with\n- * full spatial, temporal and confinement bounds. To do this, clients can {@linkplain #ofAddress(long, long, MemorySession)}\n- * a native segment <em>unsafely<\/em>, by providing a new size, as well as a new {@linkplain MemorySession memory session}.\n- * This is a <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> operation and should be used with\n- * caution: for instance, an incorrect segment size could result in a VM crash when attempting to dereference\n- * the memory segment.\n+ * Alternatively, clients can obtain an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n+ * address value layout. When an access operation, or a function descriptor that is passed to a downcall method handle,\n+ * uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments\n+ * with <em>maximal<\/em> size (i.e. {@linkplain java.lang.Long#MAX_VALUE}). As such, these segments can be accessed directly, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ wrap address into segment (size = Long.MAX_VALUE)\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Both {@link #ofAddress(long, long, MemorySession)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n+ * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n+ * for instance, sizing a segment incorrectly could result in a VM crash when attempting to access the memory segment.\n@@ -235,4 +391,5 @@\n- * For example, clients requiring sophisticated, low-level control over mapped memory segments, might consider writing\n- * custom mapped memory segment factories; using {@link Linker}, e.g. on Linux, it is possible to call {@code mmap}\n- * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n- * {@link #ofAddress(long, long, MemorySession)}.\n+ * Which approach is taken largely depends on the information that a client has available when obtaining a memory segment\n+ * wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the\n+ * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API).\n+ * In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should\n+ * be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n@@ -249,7 +406,1 @@\n-     * Returns the base address of the memory region associated with this segment. If this memory segment is\n-     * a {@linkplain #isNative() native} memory segment, then the returned address is the off-heap address\n-     * at which the native memory region associated with this segment starts. If this memory segment is an array\n-     * memory segment, the returned address is the byte offset into the {@linkplain #array()} object associated\n-     * with this segment. In other words, the base address of an array segment is always <em>virtualized<\/em>.\n-     *\n-     * @return the base address of the memory region associated with this segment.\n+     * {@return the address of this memory segment}\n@@ -282,1 +433,1 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -298,1 +449,1 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -314,1 +465,1 @@\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n+     * Returns a slice of this memory segment, at the given offset. The returned segment's address is the address\n@@ -319,1 +470,1 @@\n-     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n@@ -327,1 +478,1 @@\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n+     * Returns a slice of this memory segment, at the given offset. The returned segment's address is the address\n@@ -337,1 +488,1 @@\n-     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n@@ -360,4 +511,3 @@\n-     * Returns {@code true} if this segment is a native segment. A native memory segment is\n-     * created using the {@link #allocateNative(long)} (and related) factory, or a buffer segment\n-     * derived from a {@linkplain ByteBuffer#allocateDirect(int) direct byte buffer} using the {@link #ofBuffer(Buffer)} factory,\n-     * or if this is a {@linkplain #isMapped() mapped} segment.\n+     * Returns {@code true} if this segment is a native segment. A native segment is\n+     * created e.g. using the {@link #allocateNative(long)} (and related) factory, or by\n+     * {@linkplain #ofBuffer(Buffer) wrapping} a {@linkplain ByteBuffer#allocateDirect(int) direct buffer}.\n@@ -369,3 +519,3 @@\n-     * Returns {@code true} if this segment is a mapped segment. A mapped memory segment is\n-     * created using the {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or a buffer segment\n-     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofBuffer(Buffer)} factory.\n+     * Returns {@code true} if this segment is a mapped segment. A mapped memory segment is created e.g. using the\n+     * {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or by\n+     * {@linkplain #ofBuffer(Buffer) wrapping} a {@linkplain java.nio.MappedByteBuffer mapped byte buffer}.\n@@ -382,1 +532,1 @@\n-     * same memory region. As such, it is not possible for a\n+     * same region of memory. As such, it is not possible for a\n@@ -395,1 +545,1 @@\n-     * <p>The offset is relative to the base address of this segment and can be\n+     * <p>The offset is relative to the address of this segment and can be\n@@ -474,1 +624,1 @@\n-     * {@linkplain #address() base address} of each segment and will be in the\n+     * {@linkplain #address() address} of each segment and will be in the\n@@ -595,1 +745,1 @@\n-     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native memory segment, the resulting buffer is\n+     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native segment, the resulting buffer is\n@@ -626,1 +776,2 @@\n-     * @param elementLayout the source element elementLayout.\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n@@ -639,1 +790,1 @@\n-     * @param elementLayout the source element elementLayout. If the byte order associated with the elementLayout is\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n@@ -653,1 +804,1 @@\n-     * @param elementLayout the source element elementLayout. If the byte order associated with the elementLayout is\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n@@ -667,1 +818,1 @@\n-     * @param elementLayout the source element elementLayout. If the byte order associated with the elementLayout is\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n@@ -681,1 +832,1 @@\n-     * @param elementLayout the source element elementLayout. If the byte order associated with the elementLayout is\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n@@ -695,1 +846,1 @@\n-     * @param elementLayout the source element elementLayout. If the byte order associated with the elementLayout is\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n@@ -709,1 +860,1 @@\n-     * @param elementLayout the source element elementLayout. If the byte order associated with the elementLayout is\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n@@ -728,2 +879,1 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -756,2 +906,1 @@\n-     *\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -772,1 +921,1 @@\n-     * Creates a buffer memory segment that models the memory associated with the given {@link Buffer} instance.\n+     * Creates a memory segment that is backed by the same region of memory that backs the given {@link Buffer} instance.\n@@ -775,4 +924,3 @@\n-     * If the buffer is {@linkplain ByteBuffer#isReadOnly() read-only}, the resulting segment will also be\n-     * {@linkplain ByteBuffer#isReadOnly() read-only}. The memory session associated with this segment can either be the\n-     * {@linkplain MemorySession#global() global} memory session, in case the buffer has been created independently,\n-     * or some other memory session, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * If the buffer is {@linkplain Buffer#isReadOnly() read-only}, the resulting segment will also be\n+     * {@linkplain ByteBuffer#isReadOnly() read-only}. Moreover, if the buffer is a {@linkplain Buffer#isDirect() direct buffer},\n+     * the returned segment is a native segment; otherwise the returned memory segment is a heap segment.\n@@ -780,1 +928,11 @@\n-     * The resulting memory segment keeps a reference to the backing buffer, keeping it <em>reachable<\/em>.\n+     * The memory session {@code S} associated with the returned segment is\n+     * computed as follows:\n+     * <ul>\n+     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose session\n+     *     is {@code S'}, then {@code S = S'}; or<\/li>\n+     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain MemorySession#global() global session}; or\n+     *     <li>if the buffer is a direct buffer, then {@code S} is an\n+     *     {@linkplain MemorySession#openImplicit() implicit session} that keeps the buffer reachable.\n+     *     Therefore, the off-heap region of memory backing the buffer instance will remain available as long as the\n+     *     returned segment is reachable.<\/li>\n+     * <\/ul>\n@@ -782,2 +940,2 @@\n-     * @param buffer the buffer instance backing the buffer memory segment.\n-     * @return a buffer memory segment.\n+     * @param buffer the buffer instance to be turned into a new memory segment.\n+     * @return a memory segment, derived from the given buffer instance.\n@@ -790,2 +948,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated byte array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given byte array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -793,2 +952,2 @@\n-     * @param byteArray the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param byteArray the primitive array backing the heap memory segment.\n+     * @return a heap memory segment backed by a byte array.\n@@ -801,2 +960,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated char array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given char array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -804,2 +964,2 @@\n-     * @param charArray the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param charArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a char array.\n@@ -812,2 +972,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated short array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given short array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -815,2 +976,2 @@\n-     * @param shortArray the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param shortArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a short array.\n@@ -823,2 +984,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated int array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given int array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -826,2 +988,2 @@\n-     * @param intArray the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param intArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by an int array.\n@@ -834,2 +996,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated float array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given float array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -837,2 +1000,2 @@\n-     * @param floatArray the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param floatArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a float array.\n@@ -845,2 +1008,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated long array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given long array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -848,2 +1012,2 @@\n-     * @param longArray the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param longArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a long array.\n@@ -856,2 +1020,3 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated double array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Creates a heap segment backed by the on-heap region of memory that holds the given double array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session, and\n+     * its {@link #address()} is set to zero.\n@@ -859,2 +1024,2 @@\n-     * @param doubleArray the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param doubleArray the primitive array backing the heap segment.\n+     * @return a heap memory segment backed by a double array.\n@@ -867,1 +1032,1 @@\n-     * A zero-length native memory segment modelling the {@code NULL} address.\n+     * A zero-length native segment modelling the {@code NULL} address.\n@@ -872,1 +1037,1 @@\n-     * Creates a zero-length native memory segment from the given {@linkplain #address() address value}.\n+     * Creates a zero-length native segment from the given {@linkplain #address() address value}.\n@@ -880,1 +1045,1 @@\n-     * @return a zero-length native memory segment with the given address.\n+     * @return a zero-length native segment with the given address.\n@@ -887,1 +1052,1 @@\n-     * Creates a native memory segment with the given size and {@linkplain #address() address value}.\n+     * Creates a native segment with the given size and {@linkplain #address() address value}.\n@@ -900,1 +1065,1 @@\n-     * @return a zero-length native memory segment with the given address and size.\n+     * @return a zero-length native segment with the given address and size.\n@@ -913,1 +1078,1 @@\n-     * Creates a native memory segment with the given size, base address, and memory session.\n+     * Creates a native segment with the given size, address, and memory session.\n@@ -915,1 +1080,1 @@\n-     * where an address to some underlying memory region is typically obtained from foreign code\n+     * where an address to some underlying region of memory is typically obtained from foreign code\n@@ -922,1 +1087,1 @@\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * if appropriate, writing; an attempt to access an invalid address from Java code will either return an arbitrary value,\n@@ -930,1 +1095,2 @@\n-     * @param address the returned segment's base address.\n+     *\n+     * @param address the returned segment's address.\n@@ -933,1 +1099,1 @@\n-     * @return a native memory segment with the given base address, size and memory session.\n+     * @return a native segment with the given address, size and memory session.\n@@ -951,1 +1117,5 @@\n-     * Creates a native memory segment with the given layout.\n+     * Creates a native segment with the given layout.\n+     * <p>\n+     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n+     * of the returned segment will be aligned according to the alignment constraint of the provided layout.\n@@ -954,1 +1124,1 @@\n-     * memory session. As such, the native memory region associated with the returned segment is\n+     * memory session. As such, the off-heap region which backs the returned segment is\n@@ -966,1 +1136,1 @@\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -968,2 +1138,2 @@\n-     * @param layout the layout of the off-heap memory block backing the native memory segment.\n-     * @return a new native memory segment.\n+     * @param layout the layout of the off-heap memory region backing the native segment.\n+     * @return a new native segment.\n@@ -978,1 +1148,5 @@\n-     * Creates a native memory segment with the given size (in bytes).\n+     * Creates a native segment with the given size (in bytes).\n+     * <p>\n+     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n+     * of the returned segment is guaranteed to be at least 1-byte aligned.\n@@ -981,1 +1155,1 @@\n-     * memory session. As such, the native memory region associated with the returned segment is\n+     * memory session. As such, the off-heap region which backs the returned segment is\n@@ -985,1 +1159,1 @@\n-     * {@link MemorySession#allocate(long)}} method.\n+     * {@link MemorySession#allocate(long)} method.\n@@ -993,1 +1167,1 @@\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -997,1 +1171,1 @@\n-     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteSize the size (in bytes) of the off-heap memory region of memory backing the native memory segment.\n@@ -1008,1 +1182,5 @@\n-     * Creates a native memory segment with the given size (in bytes) and alignment (in bytes).\n+     * Creates a native segment with the given size (in bytes) and alignment (in bytes).\n+     * <p>\n+     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n+     * of the returned segment will be aligned according to the provided alignment constraint.\n@@ -1011,1 +1189,1 @@\n-     * memory session. As such, the native memory region associated with the returned segment is\n+     * memory session. As such, the off-heap region which backs the returned segment is\n@@ -1015,1 +1193,1 @@\n-     * {@link MemorySession#allocate(long, long)} method.\n+     * {@link MemorySession#allocate(long,long)} method.\n@@ -1023,1 +1201,1 @@\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * The region of off-heap region backing the returned native segment is initialized to zero.\n@@ -1025,2 +1203,2 @@\n-     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteSize the size (in bytes) of the off-heap region of memory backing the native memory segment.\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n@@ -1106,1 +1284,1 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the source\n@@ -1128,4 +1306,25 @@\n-\n-        AbstractMemorySegmentImpl.copy(srcSegment, srcElementLayout, srcOffset,\n-                dstSegment, dstElementLayout, dstOffset,\n-                elementCount);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n+        }\n+        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n+        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n@@ -1137,3 +1336,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1145,3 +1343,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1158,3 +1356,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1166,3 +1363,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1180,3 +1377,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1188,3 +1384,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1201,3 +1397,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1209,3 +1404,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1223,3 +1418,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1231,3 +1425,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1244,3 +1438,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1252,3 +1445,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1266,3 +1459,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1274,3 +1466,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1287,3 +1479,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1295,3 +1486,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1309,3 +1500,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1317,3 +1507,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1330,3 +1520,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1338,3 +1527,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1352,3 +1541,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1360,3 +1548,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1373,3 +1561,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1381,3 +1568,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1395,3 +1582,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1403,3 +1589,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1416,3 +1602,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1424,3 +1609,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1438,3 +1623,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1446,3 +1630,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1459,3 +1643,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1467,3 +1650,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1484,3 +1667,2 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1492,3 +1674,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1505,3 +1687,2 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param offset offset in bytes (relative to this segment address) at which this access operation will occur.\n@@ -1513,3 +1694,3 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1527,3 +1708,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1535,2 +1716,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1538,1 +1719,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1551,3 +1732,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1559,2 +1740,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1562,1 +1743,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1576,3 +1757,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1584,2 +1765,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1587,1 +1768,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1600,3 +1781,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1608,2 +1789,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1611,1 +1792,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1625,3 +1806,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1633,2 +1814,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1636,1 +1817,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1649,3 +1830,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1657,2 +1838,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1660,1 +1841,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1674,3 +1855,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1682,2 +1863,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1685,1 +1866,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1698,3 +1879,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1706,2 +1887,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1709,1 +1890,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1723,3 +1904,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1731,2 +1912,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1734,1 +1915,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1747,3 +1928,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1755,2 +1936,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1758,1 +1939,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1772,3 +1953,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1780,2 +1961,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1783,1 +1964,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1796,3 +1977,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1804,2 +1985,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1807,1 +1988,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1825,3 +2006,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1833,2 +2014,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1836,1 +2017,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1849,3 +2030,3 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n@@ -1857,2 +2038,2 @@\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n@@ -1860,1 +2041,1 @@\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n@@ -1873,2 +2054,2 @@\n-     * object is also a memory segment, and if that segment refers to the same memory location as this segment. More specifically,\n-     * for two segments {@code s1} and {@code s2} to be considered equals, all the following must be true:\n+     * object is also a memory segment, and if the two segments refer to the same location, in some region of memory.\n+     * More specifically, for two segments {@code s1} and {@code s2} to be considered equals, all the following must be true:\n@@ -1879,2 +2060,2 @@\n-     *     <li>{@code s1.address() == s2.address()}, that is, the base address of the two segments should be the same.\n-     *     This means that the two segments either refer at the same off-heap memory location, or they refer\n+     *     <li>{@code s1.address() == s2.address()}, that is, the address of the two segments should be the same.\n+     *     This means that the two segments either refer to the same location in some off-heap region, or they refer\n@@ -1886,1 +2067,1 @@\n-     * to perform address checks, such as checking if a native memory segment has the {@code NULL} address.\n+     * to perform address checks, such as checking if a native segment has the {@code NULL} address.\n@@ -1920,1 +2101,1 @@\n-     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source element layout,\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the source element layout,\n@@ -1954,1 +2135,1 @@\n-     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the destination element layout,\n+     * segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the destination element layout,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":553,"deletions":372,"binary":false,"changes":925,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * the off-heap memory associated with said segments.\n+ * the off-heap memory backing said segments.\n@@ -218,1 +218,4 @@\n-      * this memory session.\n+     * this memory session. The {@link MemorySegment#address()} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n+     * of the returned segment will be aligned according the provided alignment constraint.\n+     * <p>\n@@ -222,1 +225,1 @@\n-     * The off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * The off-heap region of memory backing the returned native memory segment is initialized to zero.\n@@ -225,1 +228,1 @@\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- *     <li>{@link #implicitAllocator()} obtains an allocator which allocates native memory segment in independent,\n+ *     <li>{@link #implicitAllocator()} obtains an allocator which allocates native segment in independent,\n@@ -83,1 +83,1 @@\n-     * @return a new native memory segment containing the converted C string.\n+     * @return a new native segment containing the converted C string.\n@@ -338,1 +338,1 @@\n-     * Allocates a memory segment with the given size and alignment constraints.\n+     * Allocates a memory segment with the given size and alignment constraint.\n@@ -386,1 +386,1 @@\n-     * Creates an arena-based allocator used to allocate native memory segments. The returned allocator features\n+     * Creates an arena-based allocator used to allocate native segments. The returned allocator features\n@@ -391,1 +391,1 @@\n-     * native memory segment {@code S} of size {@code B}. The allocator then responds to allocation requests in one of the following ways:\n+     * native segment {@code S} of size {@code B}. The allocator then responds to allocation requests in one of the following ways:\n@@ -457,2 +457,1 @@\n-     * SegmentAllocator implicitAllocator = (size, align) ->\n-     *     MemorySession.openImplicit().allocate(size, align);\n+     * SegmentAllocator implicitAllocator = MemorySegment::allocateNative;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-     * Returns a sequence layout with the same element layout, alignment constraints and name as this sequence layout,\n+     * Returns a sequence layout with the same element layout, alignment constraint and name as this sequence layout,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- *     <li>It can be passed to a {@link Linker} to create a downcall method handle, which can then be used to call the foreign function at the segment's base address.<\/li>\n+ *     <li>It can be passed to a {@link Linker} to create a downcall method handle, which can then be used to call the foreign function at the segment's address.<\/li>\n@@ -56,1 +56,1 @@\n- *     <li>It can be used to dereference memory associated with a global variable (this might require\n+ *     <li>It can be used to access the region of memory backing a global variable (this might require\n@@ -126,1 +126,1 @@\n-     * @return a zero-length memory segment whose base address indicates the address of the symbol, if found.\n+     * @return a zero-length memory segment whose address indicates the address of the symbol, if found.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-     * Reads the next address value, wraps it into a native memory segment, and advances this variable argument list's position.\n+     * Reads the next address value, wraps it into a native segment, and advances this variable argument list's position.\n@@ -153,1 +153,1 @@\n-     * @return a native memory segment whose {@linkplain MemorySegment#address() address} is the value read from\n+     * @return a native segment whose {@linkplain MemorySegment#address() address} is the value read from\n@@ -238,1 +238,1 @@\n-     * @return a new variable argument list backed by a native memory region starting at the given address value.\n+     * @return a new variable argument list backed by an off-heap region of memory starting at the given address value.\n@@ -328,1 +328,1 @@\n-         * Writes the {@linkplain MemorySegment#address() address} of the provided native memory segment\n+         * Writes the {@linkplain MemorySegment#address() address} of the provided native segment\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * {@linkplain MemorySegment#get(OfInt, long) accessing} a memory region using the value layout.\n+ * {@linkplain MemorySegment#get(OfInt, long) accessing} a region of memory using the value layout.\n@@ -60,1 +60,1 @@\n-     * Returns a value layout with the same carrier, alignment constraints and name as this value layout,\n+     * Returns a value layout with the same carrier, alignment constraint and name as this value layout,\n@@ -69,2 +69,2 @@\n-     * Creates a <em>strided<\/em> access var handle that can be used to dereference a multi-dimensional array. The\n-     * layout of this array is a sequence layout with {@code shape.length} nested sequence layouts. The element\n+     * Creates a <em>strided<\/em> access var handle that can be used to access a memory segment as multi-dimensional\n+     * array. The layout of this array is a sequence layout with {@code shape.length} nested sequence layouts. The element\n@@ -93,1 +93,1 @@\n-     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset dereferenced by the var handle can be\n+     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset accessed by the var handle can be\n@@ -117,1 +117,2 @@\n-     * @return a var handle which can be used to dereference a multi-dimensional array, featuring {@code shape.length + 1}\n+     * @return a var handle which can be used to access a memory segment as a multi-dimensional array,\n+     * featuring {@code shape.length + 1}\n@@ -327,2 +328,2 @@\n-         * Returns an <em>unbounded<\/em> address layout with the same carrier, alignment constraints, name and order as this address layout,\n-         * but with the specified pointee layout. An unbounded address layouts allow raw addresses to be dereferenced\n+         * Returns an <em>unbounded<\/em> address layout with the same carrier, alignment constraint, name and order as this address layout,\n+         * but with the specified pointee layout. An unbounded address layouts allow raw addresses to be accessed\n@@ -330,1 +331,1 @@\n-         * these segments be used in subsequent dereference operations.\n+         * these segments can be used in subsequent access operations.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * models a contiguous memory region, residing either inside or outside the Java heap. The contents of a memory\n+ * models a contiguous region of memory, residing either inside or outside the Java heap. The contents of a memory\n@@ -37,1 +37,1 @@\n- * an alternate, more abstract way, to <a href=MemorySegment.html#segment-deref>dereference memory segments<\/a>\n+ * an alternate, more abstract way, to <a href=MemorySegment.html#segment-deref>access memory segments<\/a>\n@@ -41,2 +41,2 @@\n- * For example, to allocate an off-heap memory region big enough to hold 10 values of the primitive type {@code int}, and fill it with values\n- * ranging from {@code 0} to {@code 9}, we can use the following code:\n+ * For example, to allocate an off-heap region of memory big enough to hold 10 values of the primitive type {@code int},\n+ * and fill it with values ranging from {@code 0} to {@code 9}, we can use the following code:\n@@ -53,1 +53,1 @@\n- * The off-heap memory associated with the native memory segment will be released when the segment becomes\n+ * The off-heap memory backing the native segment will be released when the segment becomes\n@@ -59,3 +59,3 @@\n- * {@linkplain java.lang.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) dereference method}\n- * accepts a {@linkplain java.lang.foreign.ValueLayout value layout}, which specifies the size, alignment constraints,\n- * byte order as well as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * {@linkplain java.lang.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) access method}\n+ * accepts a {@linkplain java.lang.foreign.ValueLayout value layout}, which specifies the size, alignment constraint,\n+ * byte order as well as the Java type ({@code int}, in this case) associated with the access operation. More specifically,\n@@ -72,2 +72,2 @@\n- * Clients that operate under these assumptions might want to programmatically release the memory associated\n- * with a memory segment. This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n+ * Clients that operate under these assumptions might want to programmatically release the memory backing a memory segment.\n+ * This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n@@ -93,1 +93,1 @@\n- * <em>outside<\/em> the boundaries of the memory segment used by the dereference operation. We call this guarantee <em>spatial safety<\/em>;\n+ * <em>outside<\/em> the boundaries of the memory segment used by the access operation. We call this guarantee <em>spatial safety<\/em>;\n@@ -100,1 +100,1 @@\n- * operation either succeeds - and accesses a valid memory location - or fails.\n+ * operation either succeeds - and accesses a valid location of the region of memory backing the memory segment - or fails.\n@@ -142,42 +142,0 @@\n- * <h3 id=\"foreign-segments\">Foreign memory segments<\/h3>\n- *\n- * When a memory segment is created from Java code, the segment properties (spatial bounds, temporal bounds and confinement)\n- * are fully known at segment creation. But when interacting with foreign functions, clients will often receive memory segments\n- * that wrap <em>raw<\/em> foreign addresses. We call these segments <em>foreign<\/em> memory segments.\n- * <p>\n- * Foreign memory segments are typically modelled using zero-length memory segments backed by the\n- * {@linkplain java.lang.foreign.MemorySession#global() global} memory session. As such, attempts to dereference\n- * foreign memory segments will fail with {@link java.lang.IndexOutOfBoundsException}. This is a crucial safety feature:\n- * raw foreign addresses are not associated with spatial bounds. For example, the C type {@code char*} can refer to a single {@code char} value,\n- * or an array of {@code char} values, of given size. Nor do said addresses have any notion of temporal bounds or thread-confinement.\n- * <p>\n- * To dereference foreign memory segments, clients have two options. First, they can\n- * {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) create}\n- * a new native memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial and temporal bounds\n- * which might, for instance, be available in the documentation of the foreign function which produced the memory segment.\n- * Here is how a foreign segment can be dereferenced:\n- *\n- * {@snippet lang = java:\n- * MemorySession session = ... \/\/ initialize a memory session\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ obtain foreign segment (size = 0)\n- * MemorySegment segment = MemorySegment.ofAddress(raw.address(), 4, session); \/\/ new segment (size = 4)\n- * int x = segment.get(ValueLayout.JAVA_INT, 0); \/\/ok\n- *}\n- *\n- * Alternatively, clients can obtain, <em>unsafely<\/em>, an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n- * address value layout. Unbounded address value layouts allow the API to view foreign segments as segments with maximal size\n- * (e.g. {@linkplain java.lang.Long#MAX_VALUE}), meaning that clients can always perform dereference operations on a foreign\n- * segment obtained using an unbounded address layout:\n- *\n- * {@snippet lang = java:\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ obtain foreign segment (size = Long.MAX_VALUE)\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n- *}\n- *\n- * Note that there is no <em>correct<\/em> choice here. Which approach is taken largely depends on the information\n- * that a client has available when obtaining a foreign memory segment. For instance, if such segment points to\n- * a C struct, the client might prefer to resize the foreign segment, to match the size of the struct (so that\n- * out-of-bounds access will be detected by the API). In other instances, however, there will be no, or little\n- * information as to what spatial and\/or temporal bounds should be associated with a given foreign segment. In these\n- * cases the second approach is preferrable.\n- *\n@@ -199,1 +157,1 @@\n- * The above method dereferences two foreign memory segments containing an integer value, and performs a simple comparison\n+ * The above method accesses two foreign memory segments containing an integer value, and performs a simple comparison\n@@ -245,1 +203,1 @@\n- * memory when attempting to dereference said segment. For these reasons, it is crucial for code that calls a restricted method\n+ * memory when attempting to access said segment. For these reasons, it is crucial for code that calls a restricted method\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":14,"deletions":56,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -974,2 +974,3 @@\n-     * Maps a region of this channel's file into a new mapped memory segment,\n-     * with the given offset, size and memory session.\n+     * Maps a region of this channel's file into a new mapped memory segment, with the given offset,\n+     * size and memory session. The {@linkplain MemorySegment#address() address} of the returned memory segment\n+     * is the starting address of the mapped off-heap region backing the segment.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}