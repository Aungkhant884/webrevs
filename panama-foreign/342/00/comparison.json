{"files":[{"patch":"@@ -1621,1 +1621,1 @@\n-      assert(!is_mcall || (call_returns[block->_pre_order] == current_offset), \"ret_addr_offset() did not match size of emitted code\");\n+      assert(!is_mcall || (call_returns[block->_pre_order] == (uint) current_offset), \"ret_addr_offset() did not match size of emitted code\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-                stackOffset += layout.byteSize();\n+                stackOffset += STACK_SLOT_SIZE;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,27 @@\n+    public static void assertStructEquals(MemorySegment actual, MemorySegment expected, MemoryLayout layout) {\n+        assertEquals(actual.byteSize(), expected.byteSize());\n+        GroupLayout g = (GroupLayout) layout;\n+        for (MemoryLayout field : g.memberLayouts()) {\n+            if (field instanceof ValueLayout) {\n+                VarHandle vh = g.varHandle(vhCarrier(field), MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n+                assertEquals(vh.get(actual), vh.get(expected));\n+            }\n+        }\n+    }\n+\n+    private static Class<?> vhCarrier(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout) {\n+            if (isIntegral(layout)) {\n+                if (layout.bitSize() == 64) {\n+                    return long.class;\n+                }\n+                return int.class;\n+            } else if (layout.bitSize() == 32) {\n+                return float.class;\n+            }\n+            return double.class;\n+        } else {\n+            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import jdk.incubator.foreign.GroupLayout;\n@@ -67,1 +66,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -198,27 +196,0 @@\n-    private static void assertStructEquals(MemorySegment actual, MemorySegment expected, MemoryLayout layout) {\n-        assertEquals(actual.byteSize(), expected.byteSize());\n-        GroupLayout g = (GroupLayout) layout;\n-        for (MemoryLayout field : g.memberLayouts()) {\n-            if (field instanceof ValueLayout) {\n-                VarHandle vh = g.varHandle(vhCarrier(field), MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n-                assertEquals(vh.get(actual), vh.get(expected));\n-            }\n-        }\n-    }\n-\n-    private static Class<?> vhCarrier(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                if (layout.bitSize() == 64) {\n-                    return long.class;\n-                }\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            }\n-            return double.class;\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestUpcallHighArity extends CallGeneratorHelper {\n+    static final MethodHandle MH_do_upcall;\n+    static final MethodHandle MH_passAndSave;\n+    static final CLinker LINKER = CLinker.getInstance();\n+\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.ofStruct(\n+        C_POINTER.withName(\"p0\"),\n+        C_DOUBLE.withName(\"p1\"),\n+        C_INT.withName(\"p2\")\n+    );\n+\n+    static {\n+        try {\n+            LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallHighArity\");\n+            MH_do_upcall = LINKER.downcallHandle(\n+                lookup.lookup(\"do_upcall\"),\n+                MethodType.methodType(void.class, MemoryAddress.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER,\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER)\n+            );\n+            MH_passAndSave = MethodHandles.lookup().findStatic(TestUpcallHighArity.class, \"passAndSave\",\n+                    MethodType.methodType(void.class, Object[].class, AtomicReference.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    static void passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+        ref.set(o);\n+    }\n+\n+    @Test(dataProvider = \"args\")\n+    public void testUpcall(MethodHandle downcall, MethodType upcallType,\n+                           FunctionDescriptor upcallDescriptor) throws Throwable {\n+        AtomicReference<Object[]> capturedArgs = new AtomicReference<>();\n+        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs)\n+                                         .asCollector(Object[].class, upcallType.parameterCount())\n+                                         .asType(upcallType);\n+        try (MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor)) {\n+            List<MemorySegment> segments = new ArrayList<>();\n+            Object[] args = new Object[upcallType.parameterCount() + 1];\n+            args[0] = upcallStub.address();\n+            List<MemoryLayout> argLayouts = upcallDescriptor.argumentLayouts();\n+            for (int i = 1; i < args.length; i++) {\n+                args[i] = makeArg(argLayouts.get(i - 1), null, false, segments);\n+            }\n+\n+            downcall.invokeWithArguments(args);\n+\n+            Object[] capturedArgsArr = capturedArgs.get();\n+            for (int i = 0; i < capturedArgsArr.length; i++) {\n+                if (upcallType.parameterType(i) == MemorySegment.class) {\n+                    assertStructEquals((MemorySegment) capturedArgsArr[i], (MemorySegment) args[i + 1], argLayouts.get(i));\n+                } else {\n+                    assertEquals(capturedArgsArr[i], args[i + 1]);\n+                }\n+            }\n+            segments.forEach(MemorySegment::close);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] args() {\n+        return new Object[][]{\n+            { MH_do_upcall,\n+                MethodType.methodType(void.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+                    MemorySegment.class, int.class, double.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER,\n+                    S_PDI_LAYOUT, C_INT, C_DOUBLE, C_POINTER)\n+            }\n+        };\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -330,0 +330,43 @@\n+\n+    @Test\n+    public void testStackStruct() {\n+        MemoryLayout struct = MemoryLayout.ofStruct(C_POINTER, C_DOUBLE, C_INT);\n+\n+        MethodType mt = MethodType.methodType(void.class,\n+            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n+            MemorySegment.class, int.class, double.class, MemoryAddress.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+            struct, C_INT, C_DOUBLE, C_POINTER,\n+            struct, C_INT, C_DOUBLE, C_POINTER,\n+            struct, C_INT, C_DOUBLE, C_POINTER,\n+            struct, C_INT, C_DOUBLE, C_POINTER);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { copy(struct), baseAddress(), convertAddress(), move(rcx, long.class) },\n+            { move(rdx, int.class) },\n+            { move(xmm2, double.class) },\n+            { convertAddress(), move(r9, long.class) },\n+            { copy(struct), baseAddress(), convertAddress(), move(stackStorage(0), long.class) },\n+            { move(stackStorage(1), int.class) },\n+            { move(stackStorage(2), double.class) },\n+            { convertAddress(), move(stackStorage(3), long.class) },\n+            { copy(struct), baseAddress(), convertAddress(), move(stackStorage(4), long.class) },\n+            { move(stackStorage(5), int.class) },\n+            { move(stackStorage(6), double.class) },\n+            { convertAddress(), move(stackStorage(7), long.class) },\n+            { copy(struct), baseAddress(), convertAddress(), move(stackStorage(8), long.class) },\n+            { move(stackStorage(9), int.class) },\n+            { move(stackStorage(10), double.class) },\n+            { convertAddress(), move(stackStorage(11), long.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct S_PDI { void* p0; double p1; int p2; };\n+\n+\n+EXPORT void do_upcall(void (*cb)(struct S_PDI, int, double, void*, struct S_PDI, int, double, void*,\n+                                 struct S_PDI, int, double, void*, struct S_PDI, int, double, void*),\n+        struct S_PDI a0, int a1, double a2, void* a3, struct S_PDI a4, int a5, double a6, void* a7,\n+        struct S_PDI a8, int a9, double a10, void* a11, struct S_PDI a12, int a13, double a14, void* a15) {\n+    cb(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestUpcallHighArity.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}