{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.MemoryScope.SharedScope;\n@@ -44,3 +45,1 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, MemoryScope.DUMMY_CLEANUP_ACTION, null)\n-            .share()\n-            .withAccessModes(READ | WRITE);\n+    public static final MemorySegment EVERYTHING = new GlobalMemorySegment();\n@@ -118,0 +117,48 @@\n+\n+    \/**\n+     * Segment representing whole native memory.\n+     * It doesn't perform range checks, and attached scope doesn't do temporal checks,\n+     * as the consequence it can be faster than ordinal memory segment.\n+     *\/\n+    private static final class GlobalMemorySegment extends NativeMemorySegmentImpl {\n+        private static final Scope SCOPE = new Scope();\n+\n+        GlobalMemorySegment() {\n+            super(0, Long.MAX_VALUE, READ | WRITE, SCOPE);\n+        }\n+\n+        @Override\n+        public void checkAccess(long offset, long length, boolean readOnly) {\n+            \/\/ No need to check access, as everything is always RW and allows access to whole world\n+        }\n+\n+        @Override\n+        NativeMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {\n+            return new NativeMemorySegmentImpl(min + offset, size, mask, scope);\n+        }\n+\n+        \/**\n+         * Special scope - can't be closed & it's always ALIVE\n+         *\/\n+        private static final class Scope extends SharedScope {\n+            Scope() {\n+                super(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            }\n+\n+            @Override\n+            void justClose() {\n+                \/\/ In normal circumstances this method should not be called, as segment\n+                \/\/ should prevent it.\n+                throw new IllegalStateException(\"Should never be called\");\n+            }\n+\n+            @Override\n+            public boolean isAlive() {\n+                return true;\n+            }\n+\n+            @Override\n+            public void checkValidState() {\n+            }\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":50,"deletions":3,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n@@ -63,0 +63,2 @@\n+    static final MemorySegment globalRestrictedSegment = MemorySegment.ofNativeRestricted();\n+\n@@ -65,0 +67,1 @@\n+    long segment_addr_idx; \/\/ The segment address divided by carrier size, as it's sequence layout\n@@ -75,1 +78,3 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+\n+        \/\/ Allocate bigger size for aligning\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE + CARRIER_SIZE);\n@@ -79,0 +84,3 @@\n+        \/\/ Get index of segment's address aligned up\n+        segment_addr_idx = (segment.address().toRawLongValue() + CARRIER_SIZE - 1) \/ CARRIER_SIZE;\n+\n@@ -104,0 +112,8 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int global_segment_get() {\n+        \/\/ The segment used inside this benchmarks should have range & temporal checks\n+        \/\/ removed. Results should be better than for other kinds of segments\n+        return (int) VH_int.get(globalRestrictedSegment, segment_addr_idx);\n+    }\n+\n@@ -119,0 +135,10 @@\n+    @Benchmark\n+    public int global_segment_loop() {\n+        \/\/ In fact, we operate inside `segment`\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += (int) VH_int.get(globalRestrictedSegment, segment_addr_idx + i);\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * Simulates & benchmarks random access from users (i.e. to off-heap array).\n+ * Baselined to plain Java arrays.\n+ *\/\n+@Fork(\n+    value = 3,\n+    jvmArgsAppend = { \"--add-modules\", \"jdk.incubator.foreign\", \"-Dforeign.restricted=permit\"}\n+)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class NativeMemoryAccess {\n+    static final MemorySegment ms = MemorySegment.ofNativeRestricted();\n+    static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+\n+    MemorySegment allocatedSegment;\n+    int[] intData = new int[12];\n+    volatile int intDataOffset = 0;\n+\n+    volatile MemoryAddress address;\n+    volatile long addressRaw;\n+\n+    @Setup\n+    public void setup() {\n+        var ms = MemorySegment.allocateNative(256);\n+        address = ms.address();\n+        addressRaw = address.toRawLongValue();\n+        allocatedSegment = ms;\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        allocatedSegment.close();\n+        allocatedSegment = null;\n+    }\n+\n+    @Benchmark\n+    public void target(Blackhole bh) {\n+        int[] local = intData;\n+        int localOffset = intDataOffset;\n+        bh.consume(local[localOffset]);\n+        bh.consume(local[localOffset + 1]);\n+    }\n+\n+    @Benchmark\n+    public void foreignAddress(Blackhole bh) {\n+        var a = address;\n+        bh.consume((int) intHandle.get(ms, a.addOffset(0).toRawLongValue()));\n+        bh.consume((int) intHandle.get(ms, a.addOffset(4).toRawLongValue()));\n+    }\n+\n+    @Benchmark\n+    public void foreignAddressRaw(Blackhole bh) {\n+        var a = addressRaw;\n+        bh.consume((int) intHandle.get(ms, a));\n+        bh.consume((int) intHandle.get(ms, a + 4));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/NativeMemoryAccess.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"}]}