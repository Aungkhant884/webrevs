[{"commit":{"message":"Small naming & comments improvements."},"files":[],"sha":"c7d4fdf15a3da9ff0a044bf398d83bc8ae69c4c0"},{"commit":{"message":"Revert \"Next iteration of tuning\"\n\nThis change was introduced as it was found that JVM makes\nnull check and inlines empty method. However right now\nthis phenomen can't be see, so reverting this as\nit can generate number of NPE.\n\nThis reverts commit 9e29818b8a2f4ba3a3bec8a1edace072c993ccd4."},"files":[],"sha":"6ac9dc302b8623f65577f32c7a68ac98765905c8"},{"commit":{"message":"Next iteration of tuning\n\nAfter checking source code it looks like that better is to set scope to `null`.\n\nThe results outpaced the Java array access.\n\n```\nBenchmark                           Mode  Cnt         Score          Error  Units\nAccessBenchmark.foreignAddress     thrpt    4  86860188.499 ± 13454393.406  ops\/s\nAccessBenchmark.foreignAddressRaw  thrpt    4  96150181.668 ±  7025145.700  ops\/s\nAccessBenchmark.target             thrpt    4  93673099.539 ± 23272596.145  ops\/s```\n\nversus tests on original repo\n```\nBenchmark                           Mode  Cnt         Score         Error  Units\nAccessBenchmark.foreignAddress     thrpt    4  81907199.092 ± 2663269.652  ops\/s\nAccessBenchmark.foreignAddressRaw  thrpt    4  83629168.611 ± 1025857.535  ops\/s\nAccessBenchmark.target             thrpt    4  94023553.582 ± 6128411.421  ops\/s\n```\n\n# Benchmark code\n```\nState(Scope.Thread)\npublic class AccessBenchmark {\n    static final MemorySegment ms = MemorySegment.ofNativeRestricted();\n    static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n\n    int[] intData = new int[12];\n    volatile int intDataOffset = 0;\n\n    volatile MemoryAddress address;\n    volatile long addressRaw;\n\n    @Setup\n    public void setup() {\n        var ms = MemorySegment.allocateNative(256);\n        address = ms.address();\n        addressRaw = address.toRawLongValue();\n    }\n\n    @Benchmark\n    public void target(Blackhole bh) {\n        int[] local = intData;\n        int localOffset = intDataOffset;\n        bh.consume(local[localOffset]);\n        bh.consume(local[localOffset + 1]);\n    }\n\n    @Benchmark\n    public void foreignAddress(Blackhole bh) {\n        var a = address;\n        bh.consume((int) intHandle.get(ms, a.addOffset(0).toRawLongValue()));\n        bh.consume((int) intHandle.get(ms, a.addOffset(4).toRawLongValue()));\n    }\n\n    @Benchmark\n    public void foreignAddressRaw(Blackhole bh) {\n        var a = addressRaw;\n        bh.consume((int) intHandle.get(ms, a));\n        bh.consume((int) intHandle.get(ms, a + 4));\n    }\n}\n\n```"},"files":[],"sha":"9e29818b8a2f4ba3a3bec8a1edace072c993ccd4"},{"commit":{"message":"[WIP] Performance improvement to unchecked segment  ofNativeRestricted\n\nAccessing native memory using ofNativeRestricted could generate range and temporal checkes. As this scope can't be closed and represents whole memory, above checks are not needed, and are |leftoevers| from  NativeMemorySegmentImpl.\n\nThus to overcome this, I adding special segment & scope to allow hotspot better optimize code would be a good solution.\n\nThe JMH benchmarks baselined to peformance of plain array access, shown improvement from 89% of array access to 94% of it (% = foreignAddress \/ target)\n\nImproved version\n```\nBenchmark                        Mode  Cnt         Score          Error  Units\nAccessBenchmark.foreignAddress  thrpt    4  87981021.113 ±  4496953.479  ops\/s\nAccessBenchmark.target          thrpt    4  92840761.490 ± 15994108.441  ops\/s\n```\n\nOriginal version\n```\nBenchmark                        Mode  Cnt         Score         Error  Units\nAccessBenchmark.foreignAddress  thrpt    4  82076915.820 ± 3076568.791  ops\/s\nAccessBenchmark.target          thrpt    4  91962637.002 ± 5104697.571  ops\/s\n```"},"files":[],"sha":"2d2dff23b007f066e8a9f2f0dc42f414396341d3"}]