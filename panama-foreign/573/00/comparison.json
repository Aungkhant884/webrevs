{"files":[{"patch":"@@ -763,0 +763,8 @@\n+\n+  \/\/ This check is repetition of some checks from inline_unsafe_access(), used to determine if barriers are needed\n+  \/\/ Not full scope of checks is performed, we check only if access can be mixed\n+  const Type *const base_type = gvn().type(base);\n+\n+  \/\/ Is off heap access (true implies can_access_non_heap = true)\n+  const bool off_heap_access = TypePtr::NULL_PTR == base_type;\n+\n@@ -764,1 +772,4 @@\n-  bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(gvn().type(base));\n+  const bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(base_type);\n+\n+  \/\/ Not determined access base can and can not be null.\n+  const bool mixed_access = !(off_heap_access == can_access_non_heap);\n@@ -826,1 +837,1 @@\n-  if (can_access_non_heap) {\n+  if (mixed_access) {\n@@ -873,1 +884,1 @@\n-  if (can_access_non_heap) {\n+  if (mixed_access) {\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -409,4 +409,9 @@\n-            return VectorSupport.load(vmClass, e, length,\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    bb, offset, s,\n-                    defaultImpl);\n+            Object base = BufferAccess.bufferBase(bb);\n+            if (base == null) {\n+              return VectorSupport.load(vmClass, e, length,\n+                      null, BufferAccess.bufferAddress(bb, offset),\n+                      bb, offset, s,\n+                      defaultImpl);\n+            } else {\n+              throw new IllegalStateException(\"Only off-heap segments are supported\");\n+            }\n@@ -451,5 +456,11 @@\n-            VectorSupport.store(vmClass, e, length,\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n-                    v,\n-                    bb, offset,\n-                    defaultImpl);\n+            final Object base = BufferAccess.bufferBase(bb);\n+\n+            if (base == null) {\n+              VectorSupport.store(vmClass, e, length,\n+                                  null, BufferAccess.bufferAddress(bb, offset),\n+                                  v,\n+                                  bb, offset,\n+                                  defaultImpl);\n+            } else {\n+              throw new IllegalStateException(\"Only off-heap segments are supported\");\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3548,0 +3548,1 @@\n+        Objects.requireNonNull(a);\n@@ -3566,8 +3567,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        }\n@@ -3600,0 +3605,1 @@\n+        Objects.requireNonNull(a);\n@@ -3615,9 +3621,13 @@\n-        ByteSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          ByteSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3159,0 +3159,1 @@\n+        Objects.requireNonNull(a);\n@@ -3177,8 +3178,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        }\n@@ -3211,0 +3216,1 @@\n+        Objects.requireNonNull(a);\n@@ -3226,9 +3232,13 @@\n-        DoubleSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          DoubleSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3146,0 +3146,1 @@\n+        Objects.requireNonNull(a);\n@@ -3164,8 +3165,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        }\n@@ -3198,0 +3203,1 @@\n+        Objects.requireNonNull(a);\n@@ -3213,9 +3219,13 @@\n-        FloatSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          FloatSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3255,0 +3255,1 @@\n+        Objects.requireNonNull(a);\n@@ -3273,8 +3274,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        }\n@@ -3307,0 +3312,1 @@\n+        Objects.requireNonNull(a);\n@@ -3322,9 +3328,13 @@\n-        IntSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          IntSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3158,0 +3158,1 @@\n+        Objects.requireNonNull(a);\n@@ -3176,8 +3177,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        }\n@@ -3210,0 +3215,1 @@\n+        Objects.requireNonNull(a);\n@@ -3225,9 +3231,13 @@\n-        LongSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          LongSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3535,0 +3535,1 @@\n+        Objects.requireNonNull(a);\n@@ -3553,8 +3554,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        }\n@@ -3587,0 +3592,1 @@\n+        Objects.requireNonNull(a);\n@@ -3602,9 +3608,13 @@\n-        ShortSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          ShortSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -4503,0 +4503,1 @@\n+        Objects.requireNonNull(a);\n@@ -4521,8 +4522,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                  });\n+        }\n@@ -4555,0 +4560,1 @@\n+        Objects.requireNonNull(a);\n@@ -4570,9 +4576,13 @@\n-        $Type$Species vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          $Type$Species vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\",\n+    \"-Djdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK=1\"})\n+public class ByteBufferVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  ByteBuffer directIn, directOut;\n+  ByteBuffer heapIn, heapOut;\n+\n+  @Setup\n+  public void setup() {\n+    directIn = ByteBuffer.allocateDirect(size);\n+    directOut = ByteBuffer.allocateDirect(size);\n+\n+    heapIn = ByteBuffer.wrap(new byte[size]);\n+    heapOut = ByteBuffer.wrap(new byte[size]);\n+  }\n+\n+  @Benchmark\n+  public void directBuffers() {\n+    copyMemory(directIn, directOut);\n+  }\n+\n+  @Benchmark\n+  public void heapBuffers() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers() {\n+    copyMemory(directIn, directOut);\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n+    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}