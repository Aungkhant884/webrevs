{"files":[{"patch":"@@ -3,1 +3,1 @@\n-**May 2021**\n+**September 2021**\n@@ -7,1 +7,1 @@\n-In this document we explore the main concepts behind Panama's foreign function support; as we shall see, the central abstraction in the foreign function support is the so called *foreign linker*, an abstraction that allows clients to construct *native* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+Panama support foreign functions through the Foreign Memory Access API, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). The central abstraction in the Foreign Linker API is the *foreign linker*, which allows clients to construct *native* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n@@ -15,3 +15,1 @@\n-A memory address is just what the name implies: it encapsulates a memory address (either on- or off-heap). Since, in order to dereference memory using a memory access var handle, we need a segment, it follows that it is *not* possible to directly dereference a memory address — to do that we need a segment first. So clients can proceed in three different ways here.\n-\n-First, if the memory address is known to belong to a segment the client *already* owns, a *rebase* operation can be performed; in other words, the client can ask the address what is its offset relative to a given segment, and then proceed to dereference the original segment accordingly:\n+If clients want to dereference `MemoryAddress`, they can do so *unsafely* in two ways. First, they can use one of the *unsafe* dereference methods provided by `MemoryAddress` (these methods closely mirror those offered by `MemorySegment`); these methods are *restricted* and can only be called if the caller module has been listed in the `--enable-native-access` command-line flag:\n@@ -20,1 +18,0 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, ResourceScope.newImplicitScope());\n@@ -23,9 +20,1 @@\n-int x = MemoryAccess.getIntAtOffset(segment, addr.segmentOffset(segment));    \n-```\n-\n-Secondly, if the client does *not* have a segment which contains a given memory address, it can create one *unsafely*, using the `MemoryAddress::asSegment`; this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n-\n-```java\n-MemoryAddress addr = ... \/\/obtain address from native code\n-MemorySegment segment = addr.asSegment(100);\n-int x = MemoryAccess.getInt(segment);\n+int x = addr.get(JAVA_INT, 0);\n@@ -34,1 +23,1 @@\n-Alternatively, the client can fall back to use the so called *everything* segment - that is, a primordial segment which covers the entire native heap and whose scope is always alive (the so called *global scope*). Since this segment is available as a constant, dereference can happen without the need of creating any additional segment instances:\n+Alternatively, the client can create a memory segment from an address *unsafely*, using the `MemorySegment::ofAddressNative` factory (which is also a *restricted* method); this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n@@ -38,1 +27,4 @@\n-int x = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+\tMemorySegment segment = MemorySegment.ofAddressNative(100, scope);\n+\tint x = MemoryAccess.getInt(segment);\n+}\n@@ -41,3 +33,1 @@\n-Of course, since accessing the entire native heap is inherently *unsafe*, accessing the *everything* segment is considered a *restricted* operation which is only allowed if the module performing the operation is listed in the  `--enable-native-access` command-line flag.\n-\n-`MemoryAddress`, like `MemorySegment` , implements the `Addressable` interface, which is a functional interface whose method projects an entity down to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddres` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n+Both `MemoryAddress` and `MemorySegment`, implements the `Addressable` interface, which is an interface modelling entities that can be passed *by reference* — that is, which can be projected to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddres` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n@@ -58,2 +48,2 @@\n-    for (int i = 0 ; i <= 5 ; i++) {\n-        MemoryAccess.setIntAtIndex(arr, i);\n+    for (int i = 0 ; i < 5 ; i++) {\n+        arr.setAtIndex(JAVA_INT, i, i);\n@@ -66,1 +56,1 @@\n-* compared to the C code, it is more verbose - the native array has to be initialized *element by element*\n+* compared to the C code, it is more verbose — the native array has to be initialized *element by element*\n@@ -70,1 +60,1 @@\n-To address these problems, Panama provides a `SegmentAllocator` abstraction, a functional interface which provides many useful operation to allocate commonly used values. For instance, the above code can be rewritten as follows:\n+To address these problems, Panama provides a `SegmentAllocator` abstraction, a functional interface which provides methods to allocate commonly used values. Conveniently, all resource scopes implement the `SegmentAllocator` interface, which means that the above code can be rewritten as follows:\n@@ -74,1 +64,1 @@\n-    MemorySegment arr = SegmentAllocator.ofScope(scope).allocateArray(JAVA_INT, new int[] { 0, 1, 2, 3, 4 });\n+    MemorySegment arr = scope.allocateArray(JAVA_INT, new int[] { 0, 1, 2, 3, 4 });\n@@ -78,1 +68,1 @@\n-The above code obtains a  *scoped allocator* (an allocator built on top of `MemorySegment::allocateNative`), and then uses this allocator to create a native array which is initialized to the values `{ 0, 1, 2, 3, 4 }`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. The scoped allocator makes sure that all segments allocated with it are no longer usable after the scope associated with the allocator has been closed. This makes it easier to manage multiple resources which share the same lifecycle.\n+In the above code, the resource scope is used as an allocator (built on top of `MemorySegment::allocateNative`) to create a native array which is initialized to the values `{ 0, 1, 2, 3, 4 }`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. Since the returned segment is associated with the scope which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.\n@@ -94,1 +84,1 @@\n-For these reasons, all the methods in the Foreign Linker API which *produce* memory segments (see `CLinker::toCString`), allow an optional allocator to be provided by user code — this is key in ensuring that an application using the Foreign Linker API achieves optimal allocation performances, especially in non-trivial use cases.\n+For these reasons, all the methods in the Foreign Linker API which *produce* memory segments (see `VaList::nextVarg`), allow an optional allocator to be provided by user code — this is key in ensuring that an application using the Foreign Linker API achieves optimal allocation performances, especially in non-trivial use cases.\n@@ -98,1 +88,1 @@\n-The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the `System::loadLibrary` and `System::load` methods, which internally map into calls to `dlopen`. Unfortunately, these methods do not provide a way for clients to obtain the address associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely `SymbolLookup` (similar in spirit to a method handle lookup),  which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 2 different ways <a href=\"#1\"><sup>1<\/sup><\/a>:\n+The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the `System::loadLibrary` and `System::load` methods, which internally map into calls to `dlopen`. Unfortunately, these methods do not provide a way for clients to obtain the address associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely `SymbolLookup` (similar in spirit to a method handle lookup), which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 2 different ways <a href=\"#1\"><sup>1<\/sup><\/a>:\n@@ -101,1 +91,1 @@\n-* `CLinker::getSystemLookup`  — returns a platform-specific symbol lookup which can be used e.g. to search symbols in the standard C library\n+* By obtaining a `CLinker` instance. In fact, `CLinker` implements the `SymbolLookup` interface, and can be used to look up platform-specific symbols in the standard C library.\n@@ -103,1 +93,1 @@\n-Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an  `Optional<MemoryAddress>`.\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an `Optional<MemoryAddress>`.\n@@ -105,1 +95,1 @@\n-For instance, the following code can be used to lookup the `clang_getClangVersion` function provided by the `clang` library:\n+For instance, the following code can be used to look up the `clang_getClangVersion` function provided by the `clang` library:\n@@ -114,1 +104,1 @@\n-At the core of Panama foreign function support we find the `CLinker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows to model native function calls as plain `MethodHandle` calls (see `ForeignLinker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to native functions as a function pointer (see `ForeignLinker::upcallStub`):\n+At the core of Panama foreign function support we find the `CLinker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling native function calls as plain `MethodHandle` calls (see `ForeignLinker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to native functions as a function pointer (see `ForeignLinker::upcallStub`):\n@@ -119,1 +109,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);    \n+    UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);    \n@@ -122,1 +112,1 @@\n-    static CLinker getInstance() { ... }\n+    static CLinker systemCLinker() { ... }\n@@ -126,5 +116,1 @@\n-In the following sections we will dive deeper into how downcall handles and upcall stubs are created; here we want to focus on the similarities between these two routines. First, both take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the signature of a foreign function in full. Speaking of C, the `CLinker` class defines many layout constants (one for each main C primitive type) — these layouts can be combined using a `FunctionDescriptor` to describe the signature of a C function. For instance, assuming we have a C function taking a `char*` and returning a `long` we can model such a function with the following descriptor:\n-\n-```java\n-FunctionDescriptor func = FunctionDescriptor.of(CLinker.C_LONG, CLinker.C_POINTER);\n-```\n+In the following sections we will dive deeper into how downcall handles and upcall stubs are created; here we want to focus on the similarities between these two routines. First, both take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType`, embodying the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n@@ -132,1 +118,1 @@\n-The layouts used above will be mapped to the right layout according to the platform we are executing on. This also means that these layouts will be platform dependent and that e.g. `C_LONG` will be a 32 bit value layout on Windows, while being a 64-bit value on Linux.\n+The following table shows the mapping between C types, layouts and Java carriers under the Linux\/macOS foreign linker implementation; note that the mappings can be platform dependent: on Windows\/x64, the C type `long` is 32-bit, so the `JAVA_INT` layout (and the Java carrier `int.class`) would have to be used instead:\n@@ -134,1 +120,12 @@\n-Layouts defined in the `CLinker` class are not only handy, as they already model the C types we want to work on; they also contain hidden pieces of information which the foreign linker support uses in order to compute the calling sequence associated with a given function descriptor. For instance, the two C types `int` and `float` might share a similar memory layout (they both are expressed as 32 bit values), but are typically passed using different machine registers. The layout attributes attached to the C-specific layouts in the `CLinker` class ensures that arguments and return values are interpreted in the correct way.\n+| C type                                                       | Layout         | Java carrier                       |\n+| ------------------------------------------------------------ | -------------- | ---------------------------------- |\n+| `bool`                                                       | `JAVA_BOOLEAN` | `byte`                             |\n+| `char`                                                       | `JAVA_BYTE`    | `byte`                             |\n+| `short`                                                      | `JAVA_SHORT`   | `short`, `char`                    |\n+| `int`                                                        | `JAVA_INT`     | `int`                              |\n+| `long`                                                       | `JAVA_LONG`    | `long`                             |\n+| `long long`                                                  | `JAVA_LONG`    | `long`                             |\n+| `float`                                                      | `JAVA_FLOAT`   | `float`                            |\n+| `double`                                                     | `JAVA_DOUBLE`  | `double`                           |\n+| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`      | `Addressable`<br \/>`MemoryAddress` |\n+| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `GroupLayout`  | `MemorySegment`                    |\n@@ -136,1 +133,1 @@\n-Another similarity between `downcallHandle` and `upcallStub` is that they both accept (either directly, or indirectly) a `MethodType` instance. The method type describes the Java signatures that clients will be using when interacting with said downcall handles, or upcall stubs. The C linker implementation adds constraints on which layouts can be used with which Java carrier — for instance by enforcing that the size of the Java carrier is equal to that of the corresponding layout, or by making sure that certain layouts are associated with specific carriers. The following table shows the Java carrier vs. layout mappings enforced by the Linux\/macOS foreign linker implementation:\n+Note that all C pointer types are modelled using the `ADDRESS` layout constant; the Java carrier type associated with this layout is either `Addressable` or `MemoryAddress` depending on whether the layout appears in a parameter position (resp. return position) in the function descriptor associated with a downcall method handle (resp. upcall stub). This maximizes applicability of e.g. downcall method handles, ensuring that any implementation of `Addressable` (e.g. memory segments, memory address, upcall stubs, va lists) can be passed where a pointer is expected.\n@@ -138,15 +135,1 @@\n-| C layout      | Java carrier     |\n-| ------------- | ---------------- |\n-| `C_BOOL`      | `byte`           |\n-| `C_CHAR`      | `byte`           |\n-| `C_SHORT`     | `short`, `char`  |\n-| `C_INT`       | `int`            |\n-| `C_LONG`      | `long`           |\n-| `C_LONGLONG`  | `long`           |\n-| `C_FLOAT`     | `float`          |\n-| `C_DOUBLE`    | `double`         |\n-| `C_POINTER`   | `MemoryAddress`  |\n-| `GroupLayout` | `MemorySegment`  |\n-| `C_VALIST`    | `CLinker.VaList` |\n-\n-Aside from the mapping between primitive layout and primitive Java carriers (which might vary across platforms), it is important to note how all pointer layouts must correspond to a `MemoryAddress` carrier, whereas structs (whose layout is defined by a `GroupLayout`) must be associated with a `MemorySegment` carrier; there is also a layout\/carrier pair for native `va_list` (which are covered later in this document).\n+A tool, such as `jextract`, will generate all the required C layouts (for scalars and structs\/unions) *automatically*, so that clients do not have to worry about platform-dependent details such as sizes, alignment constraints and padding.\n@@ -165,1 +148,1 @@\n-* describe the signature of the C function using the layouts in the `CLinker` class\n+* describe the signature of the C function using a function descriptor\n@@ -167,1 +150,0 @@\n-* select a Java signature we want to *overlay* on the native function — this will be the signature that clients of the native method handles will interact with\n@@ -173,4 +155,4 @@\n-MethodHandle strlen = CLinker.getInstance().downcallHandle(\n-\t\tCLinker.systemLookup().lookup(\"strlen\").get(),\n-        MethodType.methodType(long.class, MemoryAddress.class),\n-        FunctionDescriptor.of(C_LONG, C_POINTER)\n+CLinker linker = CLinker.systemCLinker();\n+MethodHandle strlen = linker.downcallHandle(\n+\t\tlinker.lookup(\"strlen\").get(),\n+        FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n@@ -180,1 +162,1 @@\n-Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the system lookup to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `C_LONG` on Linux, but we'd have to use `C_LONGLONG` on Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modeled using a `MemoryAddress` parameter.\n+Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the system lookup to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `JAVA_LONG` both Linux and Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modelled using an `Addressable` parameter.\n@@ -182,1 +164,1 @@\n-One we have obtained the downcall native method handle, we can just use it as any other method handle:\n+One we have obtained the downcall native method handle, we can just use it as any other method handle<a href=\"#3\"><sup>3<\/sup><\/a>:\n@@ -186,1 +168,1 @@\n-    long len = strlen.invokeExact(CLinker.toCString(\"Hello\", scope).address()); \/\/ 5\n+    long len = strlen.invoke(scope.allocateUtf8String(\"Hello\")); \/\/ 5\n@@ -192,1 +174,1 @@\n-The `CLinker` interfaces also supports linking of native function without an address known at link time; when that happens, an address must be provided when the method handle returned by the linker is invoked - this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n+The `CLinker` interfaces also supports linking of native function without an address known at link time; when that happens, an address must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n@@ -195,3 +177,2 @@\n-MethodHandle strlen_virtual = CLinker.getInstance().downcallHandle( \/\/ address parameter missing!\n-\t\tMethodType.methodType(long.class, MemoryAddress.class),\n-        FunctionDescriptor.of(C_LONG, C_POINTER)\n+MethodHandle strlen_virtual = linker.downcallHandle( \/\/ address parameter missing!\n+\t\tFunctionDescriptor.of(JAVA_LONG, ADDRESS)\n@@ -201,3 +182,3 @@\n-    long len = strlen_virtual.invokeExact(\n-        (Addressable)CLinker.systemLookup().lookup(\"strlen\").get() \/\/ address provided here!\n-        CLinker.toCString(\"Hello\", scope).address()\n+    long len = strlen_virtual.invoke(\n+        linker.lookup(\"strlen\").get() \/\/ address provided here!\n+        scope.allocateUtf8String(\"Hello\")\n@@ -212,1 +193,1 @@\n-Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside an *hot* loop), the JIT compiler might decide to just generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI <a href=\"#3\"><sup>3<\/sup><\/a>.\n+Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a *hot* loop), the JIT compiler might decide to just generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.\n@@ -226,1 +207,2 @@\n-MethodHandle qsort = CLinker.getInstance().downcallHandle(\n+CLinker linker = CLinker.systemCLinker();\n+MethodHandle qsort = linker.downcallHandle(\n@@ -228,2 +210,1 @@\n-        MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n-        FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER)\n+        FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n@@ -233,1 +214,1 @@\n-As before, we use `C_LONG` and `long.class` to map the C `size_t` type, and we use `MemoryAddess.class` both for the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n+As before, we use `JAVA_LONG` and `long.class` to map the C `size_t` type, and `ADDRESS` for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n@@ -240,2 +221,1 @@\n-\t\treturn MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) - \n-\t    \t   MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n+\t\treturn addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);\n@@ -246,1 +226,1 @@\n-Here we can see that the function is performing some *unsafe* dereference of the pointer contents, by using the *everything* segment.\n+Here we can see that the function is performing some *unsafe* dereference of the pointer contents.\n@@ -256,1 +236,1 @@\n-Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall segment, and pass it to the `qsort` downcall handle:\n+Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n@@ -260,1 +240,1 @@\n-    MemorySegment comparFunc = CLinker.getInstance().upcallStub(\n+    UpcallStub comparFunc = linker.upcallStub(\n@@ -262,1 +242,1 @@\n-    \tFunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+    \tFunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS),\n@@ -264,3 +244,3 @@\n-    MemorySegment array = SegmentAllocator.ofScope(scope).allocateArray(new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 }));\n-    qsort.invokeExact(array.address(), 10L, 4L, comparFunc);\n-    int[] sorted = array.toIntArray(); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+    MemorySegment array = scope.allocateArray(new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 }));\n+    qsort.invoke(array, 10L, 4L, comparFunc);\n+    int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n@@ -270,1 +250,1 @@\n-The above code creates  a memory segment — `comparFunc` — containing a stub that can be used to invoke our Java comparator function. The memory segment is associated with the provided resource scope instance; this means that the stub will be uninstalled when the resource scope is closed. It is also possible (not shown here) to create upcall stubs associated with an *implicit scope*, in which case the stub will be uninstalled when the upcall segment becomes *unreachable*.\n+The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function. The upcall stub is associated with the provided resource scope instance; this means that the stub will be uninstalled when the resource scope is closed.\n@@ -272,1 +252,1 @@\n-The snippet then creates an off-heap array from a Java array (using a `SegmentAllocator`), which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side-effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n+The snippet then creates an off-heap array from a Java array (using a `SegmentAllocator`), which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n@@ -290,1 +270,1 @@\n-To do this using the foreign function support provided by Panama we would have to build a *specialized* downcall handle for that call shape <a href=\"#4\"><sup>4<\/sup><\/a>:\n+To do this using the foreign function support provided by Panama we would have to build a *specialized* downcall handle for that call shape, using the `FunctionDescriptor::asVariadic` to inject additional variadic layouts, as follows:\n@@ -293,4 +273,4 @@\n-MethodHandle printf = CLinker.getInstance().downcallHandle(\n-\t\tCLinker.systemLookup().lookup(\"printf\").get(),\n-        MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, int.class),\n-        FunctionDescriptor.of(C_INT, C_POINTER, C_INT, C_INT, C_INT)\n+CLinker linker = CLinker.systemCLinker();\n+MethodHandle printf = linker.downcallHandle(\n+\t\tlinker.lookup(\"printf\").get(),\n+        FunctionDescriptor.of(JAVA_INT, ADDRESS).asVariadic(JAVA_INT, JAVA_INT, JAVA_INT)\n@@ -306,1 +286,1 @@\n-While this works, it is easy to see how such an approach is not very desirable:\n+While this works, and provides optimal performance, there are some drawbacks:\n@@ -308,1 +288,1 @@\n-* If the variadic function needs to be called with many different shapes, we have to create many different downcall handles\n+* If the variadic function needs to be called with many shapes, we have to create many downcall handles\n@@ -311,1 +291,1 @@\n-To mitigate these issues, the standard C foreign linker comes equipped with support for C variable argument lists — or `va_list`.  When a variadic function is called, C code has to unpack the variadic arguments by creating a `va_list` structure, and then accessing the variadic arguments through the `va_list` one by one (using the `va_arg` macro). To facilitate interop between standard variadic functions and `va_list` many C library functions in fact define *two* flavors of the same function, one using standard variadic signature, one using an extra `va_list` parameter. For instance, in the case of `printf` we can find that a `va_list`-accepting function performing the same task is also defined:\n+To add flexibility, the standard C foreign linker comes equipped with support for C variable argument lists — or `va_list`.  When a variadic function is called, C code has to unpack the variadic arguments by creating a `va_list` structure, and then accessing the variadic arguments through the `va_list` one by one (using the `va_arg` macro). To facilitate interop between standard variadic functions and `va_list` many C library functions in fact define *two* flavors of the same function, one using standard variadic signature, one using an extra `va_list` parameter. For instance, in the case of `printf` we can find that a `va_list`-accepting function performing the same task is also defined:\n@@ -322,4 +302,4 @@\n-MethodHandle vprintf = CLinker.getInstance().downcallHandle(\n-\t\tCLinker.systemLookup().lookup(\"vprintf\").get(),\n-\t\tMethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n-        FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+CLinker linker = CLinker.systemCLinker();\n+MethodHandle vprintf = linker.downcallHandle(\n+\t\tlinker.lookup(\"vprintf\").get(),\n+\t\tFunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS));\n@@ -328,3 +308,1 @@\n-Here, the notable thing is that `CLinker` comes equipped with the special `C_VA_LIST` layout (the layout of a `va_list` parameter) as well as a `VaList` carrier, which can be used to construct and represent variable argument lists from Java code.\n-\n-To call the `vprintf` handle we need to create an instance of `VaList` which contains the arguments we want to pass to the `vprintf` function — we can do so, as follows:\n+Here, the layout of a `va_list` parameter is simply `ADDRESS` (as va lists are passed by reference). To call the `vprintf` handle we need to create an instance of `VaList` which contains the arguments we want to pass to the `vprintf` function — we can do so, as follows:\n@@ -335,1 +313,1 @@\n-            CLinker.toCString(\"%d plus %d equals %d\", scope).address(),\n+            scope.allocateUtf8String(\"%d plus %d equals %d\", scope),\n@@ -337,3 +315,3 @@\n-                            builder.vargFromInt(C_INT, 2)\n-                                   .vargFromInt(C_INT, 2)\n-                                   .vargFromInt(C_INT, 4), scope)\n+                            builder.addVarg(C_INT, 2)\n+                                   .addVarg(C_INT, 2)\n+                                   .addVarg(C_INT, 4), scope)\n@@ -343,1 +321,1 @@\n-While the callee has to do more work to call the `vprintf` handle, note that that now we're back in a place where the downcall handle  `vprintf` can be shared across multiple callees. Note that both the format string and the `VaList` are associated with the given resource scope — this means that both will remain valid throughout the native function call. As for other APIs, it is also possible (not shown here) to create a `VaList` associated with an *implicit scope* - meaning that the resources allocated by the `VaList` will remain available as long as the `VaList` remains *reachable*.\n+While the callee has to do more work to call the `vprintf` handle, note that that now we're back in a place where the downcall handle  `vprintf` can be shared across multiple callees. Note that both the format string and the `VaList` are associated with the given resource scope — this means that both will remain valid throughout the native function call.\n@@ -345,1 +323,1 @@\n-Another advantage of using `VaList` is that this approach also scales to upcall stubs — it is therefore possible for clients to create upcalls stubs which take a `VaList` and then, from the Java upcall, read the arguments packed inside the `VaList` one by one using the methods provided by the `VaList` API (e.g. `VaList::vargAsInt(MemoryLayout)`), which mimic the behavior of the C `va_arg` macro.\n+Using `VaList` also scales to upcall stubs — it is therefore possible for clients to create upcalls stubs which take a `VaList` and then, from the Java upcall, read the arguments packed inside the `VaList` one by one using the methods provided by the `VaList` API (e.g. `VaList::nextVarg(ValueLayout.OfInt)`), which mimics the behavior of the C `va_arg` macro.\n@@ -356,1 +334,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -361,0 +338,1 @@\n+import jdk.incubator.foreign.VaList;\n@@ -367,1 +345,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.*;\n@@ -371,0 +349,2 @@\n+    static CLinker LINKER = CLinker.systemCLinker();\n+\n@@ -380,4 +360,3 @@\n-        MethodHandle strlen = CLinker.getInstance().downcallHandle(\n-                CLinker.systemLookup().lookup(\"strlen\").get(),\n-                MethodType.methodType(long.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_LONG, C_POINTER)\n+        MethodHandle strlen = LINKER.downcallHandle(\n+                LINKER.lookup(\"strlen\").get(),\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n@@ -387,2 +366,2 @@\n-            MemorySegment hello = CLinker.toCString(\"Hello\", scope);\n-            long len = (long) strlen.invokeExact(hello.address()); \/\/ 5\n+            MemorySegment hello = scope.allocateUtf8String(\"Hello\");\n+            long len = (long) strlen.invoke(hello); \/\/ 5\n@@ -394,3 +373,2 @@\n-        MethodHandle strlen_virtual = CLinker.getInstance().downcallHandle(\n-                MethodType.methodType(long.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_LONG, C_POINTER)\n+        MethodHandle strlen_virtual = LINKER.downcallHandle(\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n@@ -400,4 +378,4 @@\n-            MemorySegment hello = CLinker.toCString(\"Hello\", scope);\n-            long len = (long) strlen_virtual.invokeExact(\n-                (Addressable)CLinker.systemLookup().lookup(\"strlen\").get(),\n-                hello.address()); \/\/ 5\n+            MemorySegment hello = scope.allocateUtf8String(\"Hello\");\n+            long len = (long) strlen_virtual.invoke(\n+                LINKER.lookup(\"strlen\").get(),\n+                hello); \/\/ 5\n@@ -410,3 +388,1 @@\n-            int v1 = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue());\n-            int v2 = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n-            return v1 - v2;\n+            return addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);\n@@ -417,4 +393,3 @@\n-        MethodHandle qsort = CLinker.getInstance().downcallHandle(\n-                CLinker.systemLookup().lookup(\"qsort\").get(),\n-                MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER)\n+        MethodHandle qsort = LINKER.downcallHandle(\n+                LINKER.lookup(\"qsort\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n@@ -428,1 +403,1 @@\n-            MemoryAddress comparFunc = CLinker.getInstance().upcallStub(\n+            CLinker.UpcallStub comparFunc = LINKER.upcallStub(\n@@ -430,1 +405,1 @@\n-                FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER), scope);\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS), scope);\n@@ -432,4 +407,3 @@\n-            MemorySegment array = SegmentAllocator.ofScope(scope)\n-                                                  .allocateArray(C_INT, new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });\n-            qsort.invokeExact(array.address(), 10L, 4L, comparFunc);\n-            int[] sorted = array.toIntArray(); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+            MemorySegment array = scope.allocateArray(JAVA_INT, new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });\n+            qsort.invoke(array, 10L, 4L, comparFunc);\n+            int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n@@ -441,4 +415,3 @@\n-        MethodHandle printf = CLinker.getInstance().downcallHandle(\n-                CLinker.systemLookup().lookup(\"printf\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, int.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER, C_INT, C_INT, C_INT)\n+        MethodHandle printf = LINKER.downcallHandle(\n+                LINKER.lookup(\"printf\").get(),\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS).asVariadic(JAVA_INT, JAVA_INT, JAVA_INT)\n@@ -447,2 +420,2 @@\n-            MemorySegment s = CLinker.toCString(\"%d plus %d equals %d\\n\", scope);\n-            printf.invoke(s.address(), 2, 2, 4);\n+            MemorySegment s = scope.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+            printf.invoke(s, 2, 2, 4);\n@@ -454,4 +427,3 @@\n-        MethodHandle vprintf = CLinker.getInstance().downcallHandle(\n-                CLinker.systemLookup().lookup(\"vprintf\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, CLinker.VaList.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+        MethodHandle vprintf = LINKER.downcallHandle(\n+                LINKER.lookup(\"vprintf\").get(),\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS));\n@@ -460,6 +432,6 @@\n-            MemorySegment s = CLinker.toCString(\"%d plus %d equals %d\\n\", scope);\n-            CLinker.VaList vlist = CLinker.VaList.make(builder ->\n-                     builder.vargFromInt(C_INT, 2)\n-                            .vargFromInt(C_INT, 2)\n-                            .vargFromInt(C_INT, 4), scope);\n-            vprintf.invoke(s.address(), vlist);\n+            MemorySegment s = scope.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+            VaList vlist = VaList.make(builder ->\n+                     builder.addVarg(JAVA_INT, 2)\n+                            .addVarg(JAVA_INT, 2)\n+                            .addVarg(JAVA_INT, 4), scope);\n+            vprintf.invoke(s, vlist);\n@@ -473,1 +445,1 @@\n-* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In the future, we might add more ways to obtain a symbol lookup - for instance:   ```  SymbolLookup.ofLibrary(String libName, ResourceScope scope)   ``` . This would  allow developers to load a  library and associate its lifecycle with a `ResourceScope` (rather than  a classloader). That is, when the scope is closed, the library will be  unloaded. However, adding these new mode will require some additional  foundational work on the `CLinker` support - as we need to make sure  that the memory address used by a downcall method handle cannot be  unloaded while the downcall method handle is being invoked.<\/small>\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In the future, we might add more ways to obtain a symbol lookup — for instance: `SymbolLookup.ofLibrary(String libName, ResourceScope scope)`. This would allow developers to load a library and associate its lifecycle with a `ResourceScope` (rather than a classloader). That is, when the scope is closed, the library will be unloaded. However, adding these new mode will require some additional foundational work on the `CLinker` support — as we need to make sure that the memory address used by a downcall method handle cannot be unloaded while the downcall method handle is being invoked.<\/small>\n@@ -475,2 +447,1 @@\n-* <a id=\"3\"\/>(<sup>3<\/sup>):<small> As an advanced option, Panama allows the user to opt-in to remove Java to native thread transitions; while, in the general case it is unsafe doing so (removing thread transitions could have a negative impact on GC for long running native functions, and could crash the VM if the downcall needs to pop back out in Java, e.g. via an upcall), greater efficiency can be achieved; performance sensitive users should consider this option at least for the functions that are called more frequently, assuming that these functions are *leaf* functions (e.g. do not go back to Java via an upcall) and are relatively short-lived.<\/small>\n-* <a id=\"4\"\/>(<sup>4<\/sup>):<small> On Windows, layouts for variadic arguments have to be adjusted using the `CLinker.Win64.asVarArg(ValueLayout)`; this is necessary because the Windows ABI passes variadic arguments using different rules than the ones used for ordinary arguments.<\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> For simplicity, the examples shown in this document use `MethodHandle::invoke` rather than `MethodHandle::invokeExact`; by doing so we avoid having to cast by-reference arguments back to `Addressable`. With `invokeExact` the method handle invocation should be rewritten as `strlen.invokeExact((Addressable)scope.allocateUtf8String(\"Hello\"));`<\/small>\n","filename":"doc\/panama_ffi.md","additions":128,"deletions":157,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-**May 2021**\n+**September 2021**\n@@ -7,1 +7,1 @@\n-A crucial part of any native interop story lies in the ability of accessing off-heap memory in an efficient fashion. Panama achieves this goal through the so called Foreign Memory Access API. This API has been made available as an incubating API in Java [14](https:\/\/openjdk.java.net\/jeps\/370) , [15](https:\/\/openjdk.java.net\/jeps\/383) and [16](https:\/\/openjdk.java.net\/jeps\/393) and is, to date, the most mature part of the Panama interop story.\n+A crucial part of any native interop story lies in the ability of accessing off-heap memory efficiently and safely. Panama achieves this goal through the Foreign Memory Access API, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [14](https:\/\/openjdk.java.net\/jeps\/370). The Foreign Memory Access API introduces abstractions to allocate and access flat memory regions (whether on- or off-heap), to manage the lifecycle of memory resources and to model native memory addresses.\n@@ -11,1 +11,1 @@\n-Memory segments are abstractions which can be used to model contiguous memory regions, located either on- or off- the Java heap. Segments can be allocated from native memory (e.g. like a `malloc`), or can be wrapped around existing memory sources (e.g. a Java array or a `ByteBuffer`). Memory segments provide *strong* spatial, temporal and thread-confinement guarantees which make memory dereference operation *safe* (more on that later), although in most simple cases some of the properties of memory segments can safely be ignored.\n+Memory segments are abstractions which can be used to model contiguous memory regions, located either on- or off- the Java heap. Segments can be allocated from native memory (e.g. like a `malloc`), or can be wrapped around existing memory sources (e.g. a Java array or a `ByteBuffer`). Memory segments provide *strong* spatial, temporal and thread-confinement guarantees which make memory dereference operation *safe* (more on that later), although in most simple cases some properties of memory segments can safely be ignored.\n@@ -16,1 +16,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, ResourceScope.newImplicitScope());\n+MemorySegment segment = MemorySegment.allocateNative(100, ResourceScope.newConfinedScope());\n@@ -19,1 +19,1 @@\n-The above code allocates a 100-bytes long memory segment. The lifecycle of a memory segment is controlled by an abstraction called `ResourceScope`. In this example, the segment memory will not be *freed* as long as the segment instance is deemed *reachable*, as specified by the `newImplicitScope()` parameter. In other words, the above factory creates a segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory. Of course, the memory access API also supports deterministic memory release; we will cover that in a later section of this document.\n+The above code allocates a 100-bytes long memory segment. The lifecycle of a memory segment is controlled by an abstraction called `ResourceScope`, which can be used to deallocate the memory associated with the memory segment (we will cover that in a later section of this document). Resource scopes feature (by default) an *implicit deallocation* mechanism, which allow memory segments such as the one above to be used pretty much in the same way as a `ByteBuffer` allocated with the `allocateDirect` factory. That is, the memory associated with the segment is deallocated when the resource scope, and hence, the segment, becomes unreacheable.\n@@ -24,1 +24,1 @@\n-MemorySegment segment = MemorySement.allocateNative(10, ResourceScope.newImplicitScope());\n+MemorySegment segment = MemorySement.allocateNative(10, ResourceScope.newConfinedScope());\n@@ -30,1 +30,8 @@\n-The Foreign Memory Access API provides ready-made static accessors in the `MemoryAccess` class, which allows to dereference a segment in various ways. The following example reads pair of 32-bit values (as Java ints) and uses them to construct an array of points:\n+Memory segments can be dereferenced easily, by using *value layouts* (layouts are covered in greater details in the next section). A value layout captures information such as:\n+\n+- The number of bytes to be dereferenced;\n+- The alignment constraints of the address at which dereference occurs;\n+- The endianness with which bytes are stored in said memory region;\n+- The Java type to be used in the dereference operation (e.g. `int` vs `float`).\n+\n+For instance, the layout constant `ValueLayout.JAVA_INT` is four bytes wide, has no alignment constraints, uses the native platform endianness (e.g. little-endian on Linux\/x64) and is associated with the Java type `int`. The following example reads pairs of 32-bit values (as Java ints) and uses them to construct an array of points:\n@@ -34,1 +41,1 @@\n-MemorySegment segment = MemorySement.allocateNative(10 * 4 * 2, ResourceScope.newImplicitScope());\n+MemorySegment segment = MemorySement.allocateNative(10 * 4 * 2, ResourceScope.newConfinedScope());\n@@ -37,2 +44,2 @@\n-    int x = MemoryAccess.getIntAtIndex(segment, i * 2);\n-    int y = MemoryAccess.getIntAtIndex(segment, (i * 2) + 1);\n+    int x = segment.getAtIndex(JAVA_INT, i * 2);\n+    int y = segment.getAtIndex(JAVA_INT, (i * 2) + 1);\n@@ -43,1 +50,1 @@\n-The above snippet allocates a flat array of 80 bytes using `MemorySegment::allocateNative`. Then, inside the loop, elements in the array are accessed using the `MemoryAccess.getIntAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (in other words, the segment offset being accessed is obtained by multiplying the index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n+The above snippet allocates a flat array of 80 bytes using `MemorySegment::allocateNative`. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (in other words, the segment offset being accessed is obtained by multiplying the index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n@@ -45,1 +52,1 @@\n-Memory segments are pretty flexible when it comes to interacting with existing memory sources and APIs. For instance it is possible to create a `ByteBuffer` *view* out of an existing memory segment, as follows:\n+Memory segments are pretty flexible when it comes to interacting with existing memory sources and APIs. For instance, it is possible to create a `ByteBuffer` *view* out of an existing memory segment, as follows:\n@@ -72,1 +79,1 @@\n-That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. The advantage of defining a memory layout upfront, using an API, is that we can then query the layout  — for instance we can compute the offset of the `y` coordinate in the 4th element of the points array:\n+That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. The advantage of defining a memory layout upfront, using an API, is that we can then query the layout — for instance we can compute the offset of the `y` coordinate in the 4th element of the points array:\n@@ -78,1 +85,1 @@\n-To specify which nested layout element should be used for the offset calculation we use a so called *layout path* - that is, a selection expression that navigates the layout, from the *root* layout, down to the leaf layout we wish to select; in this case we need to select the 4th layout element in the sequence, and then select the layout named `y` inside the selected group layout.\n+To specify which nested layout element should be used for the offset calculation we use a *layout path*, a selection expression that navigates the layout, from the *root* layout, down to the leaf layout we wish to select; in this case we need to select the 4th layout element in the sequence, and then select the layout named `y` inside the selected group layout.\n@@ -80,1 +87,1 @@\n-One of the things that can be derived from a layout is a so called *memory access var handle*. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. With memory access var handles we can rewrite our example above as follows:\n+One of the things that can be derived from a layout is a *memory access var handle*. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. With memory access var handles we can rewrite our example above as follows:\n@@ -83,1 +90,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(points, ResourceScope.newImplicitScope());\n+MemorySegment segment = MemorySegment.allocateNative(points, ResourceScope.newConfinedScope());\n@@ -93,1 +100,1 @@\n-In the above,  `xHandle` and `yHandle` are two var handle instances whose type is `int`  and which takes two access coordinates:\n+In the above, `xHandle` and `yHandle` are two var handle instances whose type is `int` and which takes two access coordinates:\n@@ -106,1 +113,1 @@\n-Memory segments support deterministic deallocation, through an abstraction called `ResourceScope`. A resource scope models the lifecycle associated with one or more resources (in this document, by resources we mean mostly memory segments); a resource scope has a state: it starts off in the *alive* state, which means that all the resources it manages can be safely accessed - and, at the user request, it can be *closed*. After a resource scope is closed, access to resources managed by that scope is no longer allowed. Resource scope support the `AutoCloseable` interface, which means that user can use resource scopes with the *try-with-resources* construct, as demonstrated in the following code:\n+Memory segments support deterministic deallocation, through an abstraction called `ResourceScope`. A resource scope models the lifecycle associated with one or more resources (in this document, by resources we mean mostly memory segments); a resource scope has a state: it starts off in the *alive* state, which means that all the resources it manages can be safely accessed — and, at the user request, it can be *closed*. After a resource scope is closed, access to resources managed by that scope is no longer allowed. Resource scope support the `AutoCloseable` interface, which means that user can use resource scopes with the *try-with-resources* construct, as demonstrated in the following code:\n@@ -116,3 +123,1 @@\n-As this example alludes to, resource scopes can come in many flavors: they can be *confined* (where access is restricted to the thread which created the scope), *shared* <a href=\"#3\"><sup>3<\/sup><\/a> (where access can occur in any thread) and can be optionally associated with a `Cleaner` object, which would take care of performing implicit deallocation, in case the resource scope becomes *unreachable* and the `close` method has not been called by the user.\n-\n-Some resource scopes do *not* support deterministic deallocation. Such scopes are called *implicit* scopes. Calling `close` on an implicit scope will fail; instead, resources associated with implicit scopes are *always* managed by a `Cleaner`. A new implicit scope can be obtained using the `ResourceScope::newImplicitScope` factory (which has been used in many examples throughout this document).\n+As this example alludes to, resource scopes can come in two flavors: they can be *confined* (where access is restricted to the thread which created the scope) or *shared* <a href=\"#3\"><sup>3<\/sup><\/a> (where access can occur in any thread). By default, all resources scopes are associated with an internal `Cleaner` object, which would take care of performing implicit deallocation (in case `close` is never called). Optionally, clients can provide a custom `Cleaner` object, or decide not to use a `Cleaner` all together. While this latter option provides slightly better scope creation performance, it must be used with caution: any scope that becomes unreachable before its `close` method has been called will end up leaking memory resources.\n@@ -131,1 +136,1 @@\n-Here we create another confined scope, and then, inside the *try-with-resources* we use the scope to create many segments; all such segments share the *same* resource scope - meaning that when such scope is closed, the memory associated with all these segments will be reclaimed at once.\n+Here we create another confined scope, and then, inside the *try-with-resources* we use the scope to create many segments; all such segments share the *same* resource scope — meaning that when such scope is closed, the memory associated with all these segments will be reclaimed at once.\n@@ -137,2 +142,2 @@\n-    MemoryAccess.setIntAtIndex(segment, 0, x);\n-    MemoryAccess.setIntAtIndex(segment, 1, y);\n+    segment.setAtIndex(JAVA_INT, 0, x);\n+    segment.setAtIndex(JAVA_INT, 1, y);\n@@ -142,1 +147,1 @@\n-If the segment is associated with a confined scope, no problem arises: the thread that created the segment is the same thread that performs the dereference - as such, when `writePoint` is called, the segment's scope is either alive (and will remain so for the duration of the call), or already closed (in which case some exception will be thrown, and no value will be written).\n+If the segment is associated with a confined scope, no problem arises: the thread that created the segment is the same thread that performs the dereference operation — as such, when `writePoint` is called, the segment's scope is either alive (and will remain so for the duration of the call), or already closed (in which case some exception will be thrown, and no value will be written).\n@@ -144,1 +149,1 @@\n-But, if the segment is associated with a shared scope, there is a new problem we are faced with: the segment might be closed (concurrently) in between the two accesses! This means that, the method ends up writing only one value instead of two; in other words, the behavior of the method is no longer atomic. Note that this cannot happen in the case where the scope is shared but associated with an *implicit scope* - as implicit scopes do not support explicit deallocation.\n+But, if the segment is associated with a shared scope, there is a new problem we are faced with: the segment might be closed (concurrently) in between the two accesses! This means that, the method ends up writing only one value instead of two; in other words, the behavior of the method is no longer atomic.\n@@ -146,1 +151,1 @@\n-To avoid this problem, clients can acquire a so called resource scope *handle*. A resource scope handle effectively prevents a scope from being closed, until said handle is released by the application. Let's illustrate how that works in practice:\n+To avoid this problem, clients can temporarily prevent a scope from being closed, by creating a temporal dependency between that scope and another scope under their control. Let's illustrate how that works in practice:\n@@ -150,2 +155,2 @@\n-    var handle = segment.scope().acquire();\n-    try {\n+    try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+\t\tscope.keepAlive(segment.scope());\n@@ -154,2 +159,0 @@\n-    } finally {\n-        segment.scope().release(handle);   \n@@ -160,1 +163,1 @@\n-A resource scope handle acts as a more restricted version <a href=\"#4\"><sup>4<\/sup><\/a> of an *atomic reference count*; each time a scope is acquired, its *acquired count* goes up; conversely the count goes down each time an handle associated with that scope is released. A scope can only be closed if its acquired count is exactly zero - meaning that no other client is attempting to access that (shared) segment. In our example above, the semantics of resource scope handles guarantees that the method will be able to either acquire the handle successfully, and write both values, or fail to acquire the handle, and write no value.\n+Here, the client creates a *fresh* confined scope, and then sets up a dependency between this new scope and the segment's scope, using `ResourceScope::keepAlive`. This means that the segment cannot be released until the local scope is closed. The attentive user might have noticed that this idiom acts as a more restricted version <a href=\"#4\"><sup>4<\/sup><\/a> of an *atomic reference count*; each time a target scope is kept alive by a new local scope, its *acquired count* goes up; conversely the count goes down each time a local scope associated with the target scope is released. A target scope can only be closed if its acquired count is exactly zero. In our example above, the semantics of resource scope handles guarantees that the method will be able to either set up the temporal dependency successfully, and write both values, or fail, and write no value.\n@@ -176,1 +179,1 @@\n-                               res += MemoryAccess.getIntAtIndex(slice, i);\n+                               res += slice.getAtIndex(JAVA_INT, i);\n@@ -192,1 +195,1 @@\n-VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())    \n+VarHandle intHandle = MemoryHandles.varHandle(JAVA_INT); \/\/ (MS, J) -> I\n@@ -195,1 +198,1 @@\n-The above code creates a memory access var handle which reads\/writes `int` values at a certain byte offset in a segment. To create this var handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as to whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user can supply an extra alignment parameter (not shown here) — this can be useful to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values. Of course, when deriving memory access var handles from layouts, all the above information can more simply inferred from the selected layout.\n+The above code creates a memory access var handle which reads\/writes `int` values at a certain byte offset in a segment. To create this var handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user might want to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values. Of course, all this information can be succinctly derived from the provided value layout (`JAVA_INT` in the above example).\n@@ -209,1 +212,1 @@\n-VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()); \/\/ (MS, J) -> I\n+VarHandle intHandle = MemoryHandles.varHandle(JAVA_INT); \/\/ (MS, J) -> I\n@@ -218,1 +221,1 @@\n-The memory access API provides basic safety guarantees for all memory segments created using the API. More specifically, dereferencing memory should either succeed, or result in a runtime exception - but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment. This is possible, since all segments have immutable *spatial bounds*, and, as we have seen, are associated with a resource scope which make sure that the segment cannot be dereferenced after the scope has been closed, or, in case of a confined scope, that the segment is dereferenced from the very same thread which created the scope.\n+The memory access API provides basic safety guarantees for all memory segments created using the API. More specifically, dereferencing memory should either succeed, or result in a runtime exception — but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment. This is possible, since all segments have immutable *spatial bounds*, and, as we have seen, are associated with a resource scope which make sure that the segment cannot be dereferenced after the scope has been closed, or, in case of a confined scope, that the segment is dereferenced from the very same thread which created the scope.\n@@ -224,1 +227,1 @@\n-Memory segments provide a similar capability - that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial bounds and resource scope; a cleanup action to be executed when the segment is closed might also be specified.\n+Memory segments provide a similar capability — that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial bounds and resource scope; a cleanup action to be executed when the segment is closed might also be specified.\n@@ -231,1 +234,1 @@\n-    var unsafeSegment = addr.asSegment(10, scope);\n+    var unsafeSegment = MemorySegment.ofAddressNative(addr, 10, scope);\n@@ -240,1 +243,1 @@\n-For these reasons, creating unsafe segments is a *restricted* operation in the Foreign Memory Access API. Restricted operations can only be performed from selected modules. To grant a given module `M`  the permission to execute restricted methods, the option `--enable-native-access=M` must be specified on the command line. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. Any attempt to call restricted operations from a module not listed in the above flag will fail with a runtime exception.\n+For these reasons, creating unsafe segments is a *restricted* operation in the Foreign Memory Access API. Restricted operations can only be performed from selected modules. To grant a given module `M` the permission to execute restricted methods, the option `--enable-native-access=M` must be specified on the command line. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. Any attempt to call restricted operations from a module not listed in the above flag will fail with a runtime exception.\n@@ -245,1 +248,1 @@\n-* <a id=\"4\"\/>(<sup>4<\/sup>):<small> The main difference between reference counting and the mechanism proposed here is that reference counting is *symmetric* - meaning that any client is able to both increment and decrement the reference count at will. The resource scope handle mechanism is *asymmetric*, since only the client acquiring a handle has the capability to release that handle. This avoids situation where a client might be tempted to e.g. decrement the reference count multiple times in order to perform some task which would otherwise be forbidden. <\/small>\n+* <a id=\"4\"\/>(<sup>4<\/sup>):<small> The main difference between reference counting and the mechanism proposed here is that reference counting is *symmetric* — meaning that any client is able to both increment and decrement the reference count at will. The resource scope handle mechanism is *asymmetric*, since only the client acquiring a handle has the capability to release that handle. This avoids situation where a client might be tempted to e.g. decrement the reference count multiple times in order to perform some task which would otherwise be forbidden. <\/small>\n","filename":"doc\/panama_memaccess.md","additions":44,"deletions":41,"binary":false,"changes":85,"status":"modified"}]}