{"files":[{"patch":"@@ -211,17 +211,1 @@\n-  if (!_needs_return_buffer) {\n-    \/\/ Unpack native results.\n-    switch (_ret_bt) {\n-      case T_BOOLEAN: __ c2bool(r0);                     break;\n-      case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;\n-      case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;\n-      case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;\n-      case T_INT    : __ sbfx(r0, r0, 0, 32);            break;\n-      case T_DOUBLE :\n-      case T_FLOAT  :\n-        \/\/ Result is in v0 we'll save as needed\n-        break;\n-      case T_VOID: break;\n-      case T_LONG: break;\n-      default       : ShouldNotReachHere();\n-    }\n-  } else {\n+  if (_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -212,18 +212,1 @@\n-  if (!_needs_return_buffer) {\n-    \/\/ FIXME: this assumes we return in rax\/xmm0, which might not be the case\n-    \/\/ Unpack native results.\n-    switch (_ret_bt) {\n-      case T_BOOLEAN: __ c2bool(rax);            break;\n-      case T_CHAR   : __ movzwl(rax, rax);       break;\n-      case T_BYTE   : __ sign_extend_byte (rax); break;\n-      case T_SHORT  : __ sign_extend_short(rax); break;\n-      case T_INT    : \/* nothing to do *\/        break;\n-      case T_DOUBLE :\n-      case T_FLOAT  :\n-        \/\/ Result is in xmm0 we'll save as needed\n-        break;\n-      case T_VOID: break;\n-      case T_LONG: break;\n-      default       : ShouldNotReachHere();\n-    }\n-  } else {\n+  if (_needs_return_buffer) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-        if (!allTypesPrimitive(type))\n-            throw new IllegalArgumentException(\"Type must only contain primitives: \" + type);\n+        if (hasIllegalType(type))\n+            throw new IllegalArgumentException(\"Illegal type(s) found: \" + type);\n@@ -63,3 +63,3 @@\n-    private static boolean allTypesPrimitive(MethodType type) {\n-        if (!type.returnType().isPrimitive())\n-            return false;\n+    private static boolean hasIllegalType(MethodType type) {\n+        if (isIllegalType(type.returnType()))\n+            return true;\n@@ -68,2 +68,2 @@\n-            if (!pType.isPrimitive())\n-                return false;\n+            if (isIllegalType(pType))\n+                return true;\n@@ -72,1 +72,9 @@\n-        return true;\n+        return false;\n+    }\n+\n+    private static boolean isIllegalType(Class<?> pType) {\n+        return !(pType == long.class\n+              || pType == int.class\n+              || pType == float.class\n+              || pType == double.class\n+              || pType == void.class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -284,1 +287,2 @@\n-        DUP\n+        DUP,\n+        CAST\n@@ -354,0 +358,4 @@\n+    static Binding cast(Class<?> fromType, Class<?> toType) {\n+        return new Cast(fromType, toType);\n+    }\n+\n@@ -365,0 +373,4 @@\n+        private static boolean isSubIntType(Class<?> type) {\n+            return type == boolean.class || type == byte.class || type == short.class || type == char.class;\n+        }\n+\n@@ -366,0 +378,4 @@\n+            if (isSubIntType(type)) {\n+                bindings.add(Binding.cast(type, int.class));\n+                type = int.class;\n+            }\n@@ -371,1 +387,8 @@\n-            bindings.add(Binding.vmLoad(storage, type));\n+            Class<?> loadType = type;\n+            if (isSubIntType(type)) {\n+                loadType = int.class;\n+            }\n+            bindings.add(Binding.vmLoad(storage, loadType));\n+            if (isSubIntType(type)) {\n+                bindings.add(Binding.cast(int.class, type));\n+            }\n@@ -675,0 +698,35 @@\n+\n+    \/**\n+     * CAST([fromType], [toType])\n+     *   Pop a [fromType] from the stack, convert it to [toType], and push the resulting\n+     *   value onto the stack.\n+     *\n+     *\/\n+    record Cast(Class<?> fromType, Class<?> toType) implements Binding {\n+\n+        @Override\n+        public Tag tag() {\n+            return Tag.CAST;\n+        }\n+\n+        @Override\n+        public void verify(Deque<Class<?>> stack) {\n+            Class<?> actualType = stack.pop();\n+            SharedUtils.checkType(actualType, fromType);\n+            stack.push(toType);\n+        }\n+\n+        @Override\n+        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+            Object arg = stack.pop();\n+            MethodHandle converter = MethodHandles.explicitCastArguments(MethodHandles.identity(toType),\n+                    MethodType.methodType(toType, fromType));\n+            try {\n+                Object result = converter.invoke(arg);\n+                stack.push(result);\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":60,"deletions":2,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-import static java.lang.foreign.ValueLayout.*;\n@@ -477,0 +476,1 @@\n+                case CAST -> emitCast((Binding.Cast) binding);\n@@ -620,1 +620,0 @@\n-\n@@ -671,0 +670,1 @@\n+\n@@ -677,0 +677,47 @@\n+    private void emitCast(Binding.Cast cast) {\n+        Class<?> fromType = cast.fromType();\n+        Class<?> toType = cast.toType();\n+\n+        if (fromType == int.class) {\n+            popType(int.class);\n+\n+            if (toType == boolean.class) {\n+                \/\/ implement least significant byte non-zero test\n+                Label falseLabel = new Label();\n+                Label endLabel = new Label();\n+\n+                \/\/ select first byte\n+                emitConst(0xFF);\n+                mv.visitInsn(IAND);\n+\n+                \/\/ check non-zero\n+                mv.visitJumpInsn(IFEQ, falseLabel);\n+                emitConst(1);\n+                mv.visitJumpInsn(GOTO, endLabel);\n+                mv.visitLabel(falseLabel);\n+                emitConst(0);\n+                mv.visitLabel(endLabel);\n+            } else if (toType == byte.class) {\n+                mv.visitInsn(I2B);\n+            } else if (toType == short.class) {\n+                mv.visitInsn(I2S);\n+            } else {\n+                assert toType == char.class;\n+                mv.visitInsn(I2C);\n+            }\n+\n+            pushType(toType);\n+        } else {\n+            popType(fromType);\n+\n+            assert fromType == boolean.class\n+                    || fromType == byte.class\n+                    || fromType == short.class\n+                    || fromType == char.class;\n+            \/\/ no-op in bytecode\n+\n+            assert toType == int.class;\n+            pushType(int.class);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -196,1 +196,2 @@\n-        DUP\n+        DUP,\n+        CAST\n@@ -223,1 +224,2 @@\n-        DUP\n+        DUP,\n+        CAST\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:CompileCommand=dontinline,TestNormalize::doCall*\n+ *   TestNormalize\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static org.testng.Assert.assertEquals;\n+\n+\/\/ test normalization of smaller than int primitive types\n+public class TestNormalize extends NativeTestHelper {\n+\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final MethodHandle SAVE_BOOLEAN_AS_INT;\n+    private static final MethodHandle SAVE_BYTE_AS_INT;\n+    private static final MethodHandle SAVE_SHORT_AS_INT;\n+    private static final MethodHandle SAVE_CHAR_AS_INT;\n+\n+    private static final MethodHandle BOOLEAN_TO_INT;\n+    private static final MethodHandle BYTE_TO_INT;\n+    private static final MethodHandle SHORT_TO_INT;\n+    private static final MethodHandle CHAR_TO_INT;\n+\n+    private static final MethodHandle NATIVE_BOOLEAN_TO_INT;\n+\n+    private static final int BOOLEAN_HOB_MASK = ~0b1;\n+    private static final int BYTE_HOB_MASK    = ~0xFF;\n+    private static final int SHORT_HOB_MASK   = ~0xFFFF;\n+    private static final int CHAR_HOB_MASK    = ~0xFFFF;\n+\n+    private static final MethodHandle SAVE_BOOLEAN;\n+\n+    static {\n+        System.loadLibrary(\"Normalize\");\n+\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            SAVE_BOOLEAN_AS_INT = lookup.findStatic(TestNormalize.class, \"saveBooleanAsInt\", MethodType.methodType(void.class, boolean.class, int[].class));\n+            SAVE_BYTE_AS_INT = lookup.findStatic(TestNormalize.class, \"saveByteAsInt\", MethodType.methodType(void.class, byte.class, int[].class));\n+            SAVE_SHORT_AS_INT = lookup.findStatic(TestNormalize.class, \"saveShortAsInt\", MethodType.methodType(void.class, short.class, int[].class));\n+            SAVE_CHAR_AS_INT = lookup.findStatic(TestNormalize.class, \"saveCharAsInt\", MethodType.methodType(void.class, char.class, int[].class));\n+\n+            BOOLEAN_TO_INT = lookup.findStatic(TestNormalize.class, \"booleanToInt\", MethodType.methodType(int.class, boolean.class));\n+            BYTE_TO_INT = lookup.findStatic(TestNormalize.class, \"byteToInt\", MethodType.methodType(int.class, byte.class));\n+            SHORT_TO_INT = lookup.findStatic(TestNormalize.class, \"shortToInt\", MethodType.methodType(int.class, short.class));\n+            CHAR_TO_INT = lookup.findStatic(TestNormalize.class, \"charToInt\", MethodType.methodType(int.class, char.class));\n+\n+            NATIVE_BOOLEAN_TO_INT = LINKER.downcallHandle(findNativeOrThrow(\"int_identity\"), FunctionDescriptor.of(JAVA_INT, JAVA_BOOLEAN));\n+\n+            SAVE_BOOLEAN = lookup.findStatic(TestNormalize.class, \"saveBoolean\", MethodType.methodType(void.class, boolean.class, boolean[].class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    \/\/ The idea of this test is that we pass a 'dirty' int value down to native code, and then receive it back\n+    \/\/ as the argument to an upcall, as well as the result of the downcall, but with a sub-int type (boolean, byte, short, char).\n+    \/\/ When we do either of those, argument normalization should take place, so that the resulting value is sane (1).\n+    \/\/ After that we convert the value back to int again, the JVM can\/will skip value normalization here.\n+    \/\/ We then check the high order bits of the resulting int. If argument normalization took place at (1), they should all be 0.\n+    @Test(dataProvider = \"cases\")\n+    public void testNormalize(ValueLayout layout, int testValue, int hobMask, MethodHandle toInt, MethodHandle saver) throws Throwable {\n+        \/\/ use actual type as parameter type to test upcall arg normalization\n+        FunctionDescriptor upcallDesc = FunctionDescriptor.ofVoid(layout);\n+        \/\/ use actual type as return type to test downcall return normalization\n+        FunctionDescriptor downcallDesc = FunctionDescriptor.of(layout, ADDRESS, JAVA_INT);\n+\n+        MemorySegment target = findNativeOrThrow(\"test\");\n+        MethodHandle downcallHandle = LINKER.downcallHandle(target, downcallDesc);\n+        downcallHandle = MethodHandles.filterReturnValue(downcallHandle, toInt);\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            int[] box = new int[1];\n+            saver = MethodHandles.insertArguments(saver, 1, box);\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, session);\n+            int dirtyValue = testValue | hobMask; \/\/ set all bits that should not be set\n+\n+            \/\/ test after JIT as well\n+            for (int i = 0; i < 20_000; i++) {\n+                doCall(downcallHandle, upcallStub, box, dirtyValue, hobMask);\n+            }\n+        }\n+    }\n+\n+    private static void doCall(MethodHandle downcallHandle, MemorySegment upcallStub,\n+                               int[] box, int dirtyValue, int hobMask) throws Throwable {\n+        int result = (int) downcallHandle.invokeExact(upcallStub, dirtyValue);\n+        assertEquals(box[0] & hobMask, 0); \/\/ check normalized upcall arg\n+        assertEquals(result & hobMask, 0); \/\/ check normalized downcall return value\n+    }\n+\n+    public static void saveBooleanAsInt(boolean b, int[] box) {\n+        box[0] = booleanToInt(b);\n+    }\n+    public static void saveByteAsInt(byte b, int[] box) {\n+        box[0] = byteToInt(b);\n+    }\n+    public static void saveShortAsInt(short s, int[] box) {\n+        box[0] = shortToInt(s);\n+    }\n+    public static void saveCharAsInt(char c, int[] box) {\n+        box[0] = charToInt(c);\n+    }\n+\n+    public static int booleanToInt(boolean b) {\n+        try {\n+            return (int) NATIVE_BOOLEAN_TO_INT.invokeExact(b); \/\/ FIXME do in pure Java?\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    public static int byteToInt(byte b) {\n+        return b;\n+    }\n+    public static int charToInt(char c) {\n+        return c;\n+    }\n+    public static int shortToInt(short s) {\n+        return s;\n+    }\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        return new Object[][] {\n+            { JAVA_BOOLEAN, booleanToInt(true),     BOOLEAN_HOB_MASK, BOOLEAN_TO_INT, SAVE_BOOLEAN_AS_INT },\n+            { JAVA_BYTE,    byteToInt((byte) 42),   BYTE_HOB_MASK,    BYTE_TO_INT,    SAVE_BYTE_AS_INT    },\n+            { JAVA_SHORT,   shortToInt((short) 42), SHORT_HOB_MASK,   SHORT_TO_INT,   SAVE_SHORT_AS_INT   },\n+            { JAVA_CHAR,    charToInt('a'),         CHAR_HOB_MASK,    CHAR_TO_INT,    SAVE_CHAR_AS_INT    }\n+        };\n+    }\n+\n+    \/\/ test which int values are considered true and false\n+    \/\/ we currently convert any int with a non-zero first byte to true, otherwise false.\n+    @Test(dataProvider = \"bools\")\n+    public void testBool(int testValue, boolean expected) throws Throwable {\n+        MemorySegment addr = findNativeOrThrow(\"test\");\n+        MethodHandle target = LINKER.downcallHandle(addr, FunctionDescriptor.of(JAVA_BOOLEAN, ADDRESS, JAVA_INT));\n+\n+        boolean[] box = new boolean[1];\n+        MethodHandle upcallTarget = MethodHandles.insertArguments(SAVE_BOOLEAN, 1, box);\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), session);\n+            boolean result = (boolean) target.invokeExact(callback, testValue);\n+            assertEquals(box[0], expected);\n+            assertEquals(result, expected);\n+        }\n+    }\n+\n+    private static void saveBoolean(boolean b, boolean[] box) {\n+        box[0] = b;\n+    }\n+\n+    @DataProvider\n+    public static Object[][] bools() {\n+        return new Object[][]{\n+            { 0b01,          true  }, \/\/ zero least significant bit, but non-zero first byte\n+            { 0b1_0000_0000, false }  \/\/ zero first byte\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/\/ we use 'int' here to make sure the native code doesn't touch any of the bits\n+\/\/ the important part is that our Java code performs argument normalization\n+EXPORT int test(void (*cb)(int), int x) {\n+    cb(x); \/\/ check upcall arg normalization\n+    return x; \/\/ check return value normalization\n+}\n+\n+EXPORT int int_identity(int x) {\n+    return x;\n+}\n","filename":"test\/jdk\/java\/foreign\/normalize\/libNormalize.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"}]}