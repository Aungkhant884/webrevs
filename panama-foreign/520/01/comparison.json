{"files":[{"patch":"@@ -100,11 +100,0 @@\n-\n-        @Override\n-        void cleanup() {\n-            if (fst != ResourceCleanup.CLOSED_LIST) {\n-                ResourceCleanup prev = fst;\n-                fst = ResourceCleanup.CLOSED_LIST;\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+        ResourceScope.Handle handle = acquire();\n@@ -87,1 +88,1 @@\n-            checkValidStateSlow();\n+            \/\/ avoid close vs. add races\n@@ -89,2 +90,2 @@\n-        } catch (ScopedMemoryAccess.Scope.ScopedAccessError err) {\n-            throw new IllegalStateException(\"Already closed\");\n+        } finally {\n+            release(handle);\n@@ -297,1 +298,16 @@\n-        abstract void cleanup();\n+        final void cleanup() {\n+            \/\/ We don't need to worry about add vs. close races here; adding a new cleanup action is done\n+            \/\/ under acquire, which prevents scope from being closed. Additionally, close vs. close races are impossible\n+            \/\/ (because MemoryScope::justClose ensures that only one thread can win the race to close the scope).\n+            \/\/ In other words, this is effectively single-threaded code.\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup current = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                while (current != null) {\n+                    current.cleanup();\n+                    current = current.next;\n+                }\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n@@ -303,8 +319,0 @@\n-        static void cleanup(ResourceCleanup first) {\n-            ResourceCleanup current = first;\n-            while (current != null) {\n-                current.cleanup();\n-                current = current.next;\n-            }\n-        }\n-\n@@ -332,1 +340,0 @@\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -119,1 +118,1 @@\n-     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n+     * A shared resource list; this implementation has to handle add vs. add races.\n@@ -135,0 +134,3 @@\n+            \/\/ We don't need to worry about add vs. close races here; adding a new cleanup action is done\n+            \/\/ under acquire, which prevents scope from being closed. The only possible race here is\n+            \/\/ add vs. add.\n@@ -138,5 +140,1 @@\n-                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n-                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n-                    \/\/ too late\n-                    throw new IllegalStateException(\"Already closed\");\n-                } else if (newSegment == prev) {\n+                if ((ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup) == prev) {\n@@ -148,21 +146,0 @@\n-\n-        void cleanup() {\n-            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n-            \/\/ (because MemoryScope::justClose ensured that this thread won the race to close the scope).\n-            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n-            \/\/ while we're closing it.\n-            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n-                \/\/ok now we're really closing down\n-                ResourceCleanup prev = null;\n-                while (true) {\n-                    prev = (ResourceCleanup) FST.getAcquire(this);\n-                    \/\/ no need to check for DUMMY, since only one thread can get here!\n-                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n-                        break;\n-                    }\n-                }\n-                cleanup(prev);\n-            } else {\n-                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n-            }\n-        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -130,1 +130,8 @@\n-            scope.close();\n+            while (true) {\n+                try {\n+                    scope.close();\n+                    break;\n+                } catch (IllegalStateException ise) {\n+                    \/\/ scope is acquired (by add) - wait some more\n+                }\n+            }\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}