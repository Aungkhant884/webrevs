{"files":[{"patch":"@@ -154,2 +154,2 @@\n- * VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n- *                                                PathElement.groupElement(\"value\"));\n+ * VarHandle valueHandle = taggedValues.varHandle(0L, PathElement.sequenceElement(),\n+ *                                                    PathElement.groupElement(\"value\"));\n@@ -167,2 +167,2 @@\n- * MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),\n- *                                                           PathElement.groupElement(\"kind\"));\n+ * MethodHandle offsetHandle = taggedValues.byteOffsetHandle(0L, PathElement.sequenceElement(),\n+ *                                                               PathElement.groupElement(\"kind\"));\n@@ -200,1 +200,1 @@\n- * VarHandle rectPointYs = RECTANGLE.varHandle(\n+ * VarHandle rectPointYs = RECTANGLE.varHandle(0L,\n@@ -352,0 +352,14 @@\n+    \/**\n+     *{@return a method handle that can be used to invoke {@link #scale(long, long)} on this layout}\n+     * This method is equivalent to {@link #scaleHandle()},\n+     * with the exception that the base offset coordinate of the returned method handle is bound to the provided value,\n+     * as follows:\n+     * {@snippet lang = \"java\":\n+     * MethodHandles.insertCoordinates(scaleHandle(), 0, baseOffset);\n+     * }\n+     * @param baseOffset the offset to be bound to the returned method handle.\n+     *\/\n+    default MethodHandle scaleHandle(long baseOffset) {\n+        return MethodHandles.insertArguments(scaleHandle(), 0, baseOffset);\n+    }\n+\n@@ -385,0 +399,20 @@\n+    \/**\n+     * Creates a method handle that computes the offset, in bytes, of the layout selected\n+     * by the given layout path, where the initial layout in the path is this layout.\n+     * <p>\n+     * This method is equivalent to {@link #byteOffsetHandle(PathElement...)}, with the exception that the base offset\n+     * parameter of the returned method handle is bound to the provided value, as follows:\n+     * {@snippet lang = \"java\":\n+     * MethodHandles.insertArguments(byteOffsetHandle(elements), 0, baseOffset);\n+     * }\n+     *\n+     * @param baseOffset the offset to be bound to the returned method handle.\n+     * @param elements the layout path elements.\n+     * @return a method handle that computes the offset, in bytes, of the layout selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>.\n+     *\/\n+    default MethodHandle byteOffsetHandle(long baseOffset, PathElement... elements) {\n+        return MethodHandles.insertArguments(byteOffsetHandle(elements), 0, baseOffset);\n+    }\n+\n@@ -543,0 +577,61 @@\n+    \/**\n+     * Creates a var handle that accesses elements in a memory segment at the offsets selected by the given layout path,\n+     * where the initial layout in the path is this layout.\n+     * <p>\n+     * This method is equivalent to {@link #varHandle(PathElement...)},\n+     * with the exception that an extra logical index coordinate is added to the returned var handle. The index is\n+     * used to scale the accessed offset by this layout size, as follows:\n+     * {@snippet lang = \"java\":\n+     * MethodHandles.collectCoordinates(varHandle(elements), 1, scaleHandle());\n+     * }\n+     *\n+     * @param elements the layout path elements.\n+     * @return a var handle that accesses elements in a memory segment at the offsets selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout selected by the provided path is not a {@linkplain ValueLayout value layout}.\n+     *\/\n+    default VarHandle arrayElementVarHandle(PathElement... elements) {\n+        return MethodHandles.collectCoordinates(varHandle(elements), 1, scaleHandle());\n+    }\n+\n+    \/**\n+     * Creates a var handle that accesses elements in a memory segment at the offsets selected by the given layout path,\n+     * where the initial layout in the path is this layout.\n+     * <p>\n+     * This method is equivalent to {@link #arrayElementVarHandle(PathElement...)},\n+     * with the exception that the base offset coordinate of the returned var handle is bound to the provided value,\n+     * as follows:\n+     * {@snippet lang = \"java\":\n+     * MethodHandles.insertCoordinates(arrayElementVarHandle(elements), 1, baseOffset);\n+     * }\n+     *\n+     * @param baseOffset the offset to be bound to the returned var handle.\n+     * @param elements the layout path elements.\n+     * @return a var handle that accesses a memory segment at the offset selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout selected by the provided path is not a {@linkplain ValueLayout value layout}.\n+     *\/\n+    default VarHandle arrayElementVarHandle(long baseOffset, PathElement... elements) {\n+        return MethodHandles.insertCoordinates(arrayElementVarHandle(elements), 1, baseOffset);\n+    }\n+\n+    \/**\n+     * Creates a method handle which, given a memory segment, returns a {@linkplain MemorySegment#asSlice(long,long) slice}\n+     * corresponding to the layout selected by the given layout path, where the initial layout in the path is this layout.\n+     * <p>\n+     * This method is equivalent to {@link #sliceHandle(PathElement...)}, with the exception that the base offset\n+     * parameter of the returned method handle is bound to the provided value, as follows:\n+     * {@snippet lang = \"java\":\n+     * MethodHandles.insertArguments(sliceHandle(elements), 1, baseOffset);\n+     * }\n+     *\n+     * @param baseOffset the offset to be bound to the returned method handle.\n+     * @param elements the layout path elements.\n+     * @return a method handle which is used to slice a memory segment at the offset selected by the given layout path.\n+     * @throws IllegalArgumentException if the layout path is not <a href=\"#well-formedness\">well-formed<\/a> for this layout.\n+     * @throws IllegalArgumentException if the layout path contains one or more <a href=#deref-path-elements>dereference path elements<\/a>.\n+     *\/\n+    default MethodHandle sliceHandle(long baseOffset, PathElement... elements) {\n+        return MethodHandles.insertArguments(sliceHandle(elements), 1, baseOffset);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":100,"deletions":5,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-        MethodHandle slicer = containerLayout.sliceHandle(fieldPath);\n+        MethodHandle slicer = containerLayout.sliceHandle(0L, fieldPath);\n@@ -279,1 +279,1 @@\n-                return (MemorySegment) slicer.invokeExact(container, 0L);\n+                return (MemorySegment) slicer.invokeExact(container);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,2 +85,1 @@\n-    static final VarHandle intHandleIndexed = MethodHandles.collectCoordinates(ValueLayout.JAVA_INT.varHandle(),\n-            1, MethodHandles.insertArguments(ValueLayout.JAVA_INT.scaleHandle(), 0, 0L));\n+    static final VarHandle intHandleIndexed = ValueLayout.JAVA_INT.arrayElementVarHandle(0L);\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -294,5 +294,0 @@\n-    private static VarHandle arrayVarHandle(ValueLayout layout) {\n-        return MethodHandles.collectCoordinates(layout.varHandle(),\n-                1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n-    }\n-\n@@ -300,2 +295,2 @@\n-        VarHandle indexedHandleNO = arrayVarHandle(helper.elementLayout.withOrder(NATIVE_ORDER));\n-        VarHandle indexedHandleNNO = arrayVarHandle(helper.elementLayout.withOrder(NON_NATIVE_ORDER));\n+        VarHandle indexedHandleNO = helper.elementLayout.withOrder(NATIVE_ORDER).arrayElementVarHandle(0L);\n+        VarHandle indexedHandleNNO = helper.elementLayout.withOrder(NON_NATIVE_ORDER).arrayElementVarHandle(0L);\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-            MethodHandle sliceX = struct.sliceHandle(groupElement(\"x\"));\n+            MethodHandle sliceX = struct.sliceHandle(0L, groupElement(\"x\"));\n@@ -161,1 +161,1 @@\n-                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg, 0L);\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg);\n@@ -309,1 +309,1 @@\n-        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(0L, pathElements);\n@@ -311,1 +311,1 @@\n-        long actualByteOffset = (long) byteOffsetHandle.invokeExact(0L, indexes);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-    static final VarHandle VH_INT_UNALIGNED = arrayVarHandle(JAVA_INT_UNALIGNED);\n-    static final VarHandle VH_INT = arrayVarHandle(JAVA_INT);\n+    static final VarHandle VH_INT_UNALIGNED = JAVA_INT_UNALIGNED.arrayElementVarHandle(0L);\n+    static final VarHandle VH_INT = JAVA_INT.arrayElementVarHandle(0L);\n@@ -43,7 +43,2 @@\n-    static final VarHandle VH_LONG_UNALIGNED = arrayVarHandle(JAVA_LONG_UNALIGNED);\n-    static final VarHandle VH_LONG = arrayVarHandle(JAVA_LONG);\n-\n-    private static VarHandle arrayVarHandle(ValueLayout layout) {\n-        return MethodHandles.collectCoordinates(layout.varHandle(),\n-            1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n-    }\n+    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle(0L);\n+    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle(0L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"}]}