{"files":[{"patch":"@@ -270,3 +270,1 @@\n-    default MemorySegment allocate(long byteSize, long byteAlignment) {\n-        return ((MemorySessionImpl)scope()).allocate(byteSize, byteAlignment);\n-    }\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.nio.ByteOrder;\n@@ -33,1 +32,1 @@\n-import java.util.function.Function;\n+\n@@ -35,0 +34,1 @@\n+import jdk.internal.foreign.ArenaImpl;\n@@ -129,1 +129,1 @@\n-        MemorySegment segment = allocate(bytes.length + termCharSize);\n+        MemorySegment segment = allocateNoInit(bytes.length + termCharSize);\n@@ -131,0 +131,3 @@\n+        for (int i = 0 ; i < termCharSize ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, bytes.length + i, (byte)0);\n+        }\n@@ -143,1 +146,1 @@\n-        MemorySegment addr = allocate(layout);\n+        MemorySegment addr = allocateNoInit(layout);\n@@ -157,1 +160,1 @@\n-        MemorySegment addr = allocate(layout);\n+        MemorySegment addr = allocateNoInit(layout);\n@@ -171,1 +174,1 @@\n-        MemorySegment addr = allocate(layout);\n+        MemorySegment addr = allocateNoInit(layout);\n@@ -185,1 +188,1 @@\n-        MemorySegment addr = allocate(layout);\n+        MemorySegment addr = allocateNoInit(layout);\n@@ -199,1 +202,1 @@\n-        MemorySegment addr = allocate(layout);\n+        MemorySegment addr = allocateNoInit(layout);\n@@ -213,1 +216,1 @@\n-        MemorySegment addr = allocate(layout);\n+        MemorySegment addr = allocateNoInit(layout);\n@@ -227,1 +230,1 @@\n-        MemorySegment addr = allocate(layout);\n+        MemorySegment addr = allocateNoInit(layout);\n@@ -243,1 +246,1 @@\n-        MemorySegment segment = allocate(layout);\n+        MemorySegment segment = allocateNoInit(layout);\n@@ -256,1 +259,1 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n@@ -267,1 +270,1 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n@@ -278,1 +281,1 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n@@ -289,1 +292,1 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n@@ -300,1 +303,1 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n@@ -311,1 +314,1 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n@@ -322,1 +325,1 @@\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+        return copyArrayWithSwapIfNeeded(elements, elementLayout);\n@@ -325,2 +328,1 @@\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n+    private MemorySegment copyArrayWithSwapIfNeeded(Object array, ValueLayout elementLayout) {\n@@ -328,1 +330,2 @@\n-        MemorySegment addr = allocate(Objects.requireNonNull(elementLayout), size);\n+        Objects.requireNonNull(elementLayout);\n+        MemorySegment segment = allocateNoInit(elementLayout, size);\n@@ -330,2 +333,1 @@\n-            MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n-                    addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n+            MemorySegment.copy(array, 0, segment, elementLayout, 0, size);\n@@ -333,1 +335,1 @@\n-        return addr;\n+        return segment;\n@@ -426,0 +428,21 @@\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout) :\n+                allocate(layout);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(long size) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(size) :\n+                allocate(size);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout, long size) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout, size) :\n+                allocate(layout, size);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":47,"deletions":24,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.util.Objects;\n+\n+public class ArenaImpl implements Arena {\n+\n+    private final MemorySessionImpl session;\n+    private final boolean shouldReserveMemory;\n+    ArenaImpl(MemorySessionImpl session) {\n+        this.session = session;\n+        shouldReserveMemory = session instanceof ImplicitSession;\n+    }\n+\n+    @Override\n+    public Scope scope() {\n+        return session;\n+    }\n+\n+    @Override\n+    public void close() {\n+        session.close();\n+    }\n+\n+    public MemorySegment allocateNoInit(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session, false, shouldReserveMemory);\n+    }\n+\n+    public MemorySegment allocateNoInit(long byteSize) {\n+        return allocateNoInit(byteSize, 1);\n+    }\n+\n+    public MemorySegment allocateNoInit(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return allocateNoInit(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+    public MemorySegment allocateNoInit(MemoryLayout layout, long size) {\n+        Objects.requireNonNull(layout);\n+        if (size < 0) {\n+            throw new IllegalArgumentException(\"Negative array size\");\n+        }\n+        return allocateNoInit(layout.byteSize() * size, layout.byteAlignment());\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session, true, shouldReserveMemory);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -80,11 +80,1 @@\n-        return new Arena() {\n-            @Override\n-            public Scope scope() {\n-                return MemorySessionImpl.this;\n-            }\n-\n-            @Override\n-            public void close() {\n-                MemorySessionImpl.this.close();\n-            }\n-        };\n+        return new ArenaImpl(this);\n@@ -156,5 +146,0 @@\n-    public MemorySegment allocate(long byteSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, this);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -49,1 +48,0 @@\n-    private static final boolean SKIP_ZERO_MEMORY = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.skipZeroMemory\");\n@@ -118,1 +116,2 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl) {\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldInit, boolean shouldReserve) {\n@@ -127,1 +126,3 @@\n-        NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+        if (shouldReserve) {\n+            NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n+        }\n@@ -129,2 +130,2 @@\n-        long buf = UNSAFE.allocateMemory(alignedSize);\n-        if (!SKIP_ZERO_MEMORY) {\n+        long buf = allocateMemoryWrapper(alignedSize);\n+        if (shouldInit) {\n@@ -140,1 +141,3 @@\n-                NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                if (shouldReserve) {\n+                    NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                }\n@@ -150,0 +153,8 @@\n+    private static long allocateMemoryWrapper(long size) {\n+        try {\n+            return UNSAFE.allocateMemory(size);\n+        } catch (IllegalArgumentException ex) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        public MemorySegment allocate(long byteSize) {\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-            arena.allocate(Long.MAX_VALUE, 2);\n+             arena.allocate(Long.MAX_VALUE, 2);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    SlicingPool pool = new SlicingPool();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[size];\n+        Random random = new Random();\n+        random.nextBytes(arr);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public long alloc_malloc_arena() {\n+        MallocArena arena = new MallocArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    @Benchmark\n+    public long alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    @Benchmark\n+    public long alloc_pool_arena() {\n+        Arena arena = pool.acquire();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    static class SlicingPool {\n+        final MemorySegment pool = Arena.ofAuto().allocate(1024);\n+        boolean isAcquired = false;\n+\n+        public Arena acquire() {\n+            if (isAcquired) {\n+                throw new IllegalStateException(\"An allocator is already in use\");\n+            }\n+            isAcquired = true;\n+            return new SlicingPoolAllocator();\n+        }\n+\n+        class SlicingPoolAllocator implements Arena {\n+\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicing = SegmentAllocator.slicingAllocator(pool);\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicing.allocate(byteSize, byteAlignment)\n+                        .reinterpret(arena, null);\n+            }\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                isAcquired = false;\n+                arena.close();\n+            }\n+        }\n+    }\n+\n+    public static class MallocArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return CLayouts.allocateMemory(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize))\n+                    .reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"}]}