{"files":[{"patch":"@@ -57,0 +57,1 @@\n+BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncInvokers := $(LIBCXX)\n@@ -69,0 +70,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncInvokers := \/EHsc\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,0 +200,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -211,0 +211,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n@@ -358,1 +358,2 @@\n-  return reinterpret_cast<JavaFrameAnchor*>(reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(jfa_sp_offset()));\n+  return reinterpret_cast<OptimizedEntryBlob::FrameData*>(\n+    reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -319,41 +319,0 @@\n-void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n-  __ block_comment(\"{ save_java_frame_anchor \");\n-  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} save_java_frame_anchor \");\n-}\n-\n-void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n-  __ block_comment(\"{ restore_java_frame_anchor \");\n-  \/\/ thread->_last_Java_sp = NULL\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n-\n-  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n-  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-\n-  \/\/_thread->frame_anchor()->copy(&_anchor);\n-\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n-\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n-\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} restore_java_frame_anchor \");\n-}\n-\n@@ -445,0 +404,54 @@\n+static int compute_res_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  return result_size;\n+}\n+\n+static void save_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ save java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, offset), reg->as_Register());\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, offset), reg->as_XMMRegister());\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} save java result \");\n+}\n+\n+static void restore_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ restore java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, offset));\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} restore java result \");\n+}\n+\n@@ -577,6 +590,0 @@\n-struct AuxiliarySaves {\n-  JavaFrameAnchor jfa;\n-  uintptr_t thread;\n-  bool should_detach;\n-};\n-\n@@ -607,0 +614,1 @@\n+  int res_save_area_size = compute_res_save_area_size(conv);\n@@ -612,1 +620,2 @@\n-  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int res_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int arg_save_area_offset   = res_save_area_offset   + res_save_area_size;\n@@ -614,6 +623,2 @@\n-  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n-  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n-\n-  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n-  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n-  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = frame_data_offset      + sizeof(OptimizedEntryBlob::FrameData);\n@@ -630,2 +635,2 @@\n-  \/\/      | AuxiliarySaves      |\n-  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n@@ -639,0 +644,3 @@\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_are_offset\n+  \/\/      |                     |\n@@ -649,1 +657,0 @@\n-  Label call_return;\n@@ -665,1 +672,1 @@\n-  __ block_comment(\"{ get_thread\");\n+  __ block_comment(\"{ on_entry\");\n@@ -667,1 +674,1 @@\n-  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n@@ -669,1 +676,1 @@\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_entry)));\n@@ -672,40 +679,1 @@\n-  __ movptr(Address(rsp, thread_offset), r15_thread);\n-  __ block_comment(\"} get_thread\");\n-\n-  \/\/ TODO:\n-  \/\/ We expect not to be coming from JNI code, but we might be.\n-  \/\/ We should figure out what our stance is on supporting that and then maybe add\n-  \/\/ some more handling here for:\n-  \/\/   - handle blocks\n-  \/\/   - check for active exceptions (and emit an error)\n-\n-  __ block_comment(\"{ safepoint poll\");\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  if (os::is_MP()) {\n-    __ membar(Assembler::Membar_mask_bits(\n-                Assembler::LoadLoad  | Assembler::StoreLoad |\n-                Assembler::LoadStore | Assembler::StoreStore));\n-   }\n-\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n-  Label L_after_safepoint_poll;\n-  Label L_safepoint_poll_slow_path;\n-\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n-\n-  __ bind(L_after_safepoint_poll);\n-  __ block_comment(\"} safepoint poll\");\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n-\n-  __ block_comment(\"{ reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n-  __ block_comment(\"} reguard stack check\");\n+  __ block_comment(\"} on_entry\");\n@@ -727,0 +695,10 @@\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+  save_java_result(_masm, conv, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_exit)));\n@@ -728,0 +706,1 @@\n+  __ block_comment(\"} on_exit\");\n@@ -729,2 +708,1 @@\n-  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n-  __ reset_last_Java_frame(r15_thread, true);\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n@@ -732,1 +710,1 @@\n-  __ call(Address(rbx, Method::from_compiled_offset()));\n+  restore_java_result(_masm, conv, res_save_area_offset);\n@@ -734,0 +712,1 @@\n+  \/\/ return value shuffle\n@@ -760,21 +739,0 @@\n-  __ bind(call_return);\n-\n-  \/\/ also sets last Java frame\n-  __ movptr(r15_thread, Address(rsp, thread_offset));\n-  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n-  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n-\n-  __ block_comment(\"{ maybe_detach_thread\");\n-  Label L_after_detach;\n-  __ cmpb(Address(rsp, should_detach_offset), 0);\n-  __ jcc(Assembler::equal, L_after_detach);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n-  __ reinit_heapbase();\n-  __ bind(L_after_detach);\n-  __ block_comment(\"} maybe_detach_thread\");\n-\n-  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n@@ -786,23 +744,0 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_reguard);\n-  __ block_comment(\"} L_reguard\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -838,1 +773,1 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":83,"deletions":148,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+#include \"runtime\/javaFrameAnchor.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n@@ -716,1 +718,1 @@\n-                     jobject receiver, ByteSize jfa_sp_offset) :\n+                                       jobject receiver, ByteSize frame_data_offset) :\n@@ -720,1 +722,1 @@\n-  _jfa_sp_offset(jfa_sp_offset) {\n+  _frame_data_offset(frame_data_offset) {\n@@ -725,1 +727,1 @@\n-                             jobject receiver, ByteSize jfa_sp_offset) {\n+                                               jobject receiver, ByteSize frame_data_offset) {\n@@ -732,1 +734,1 @@\n-    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, frame_data_offset);\n@@ -739,0 +741,8 @@\n+\n+void OptimizedEntryBlob::oops_do(OopClosure* f, const frame& frame) {\n+  frame_data_for_frame(frame)->old_handles->oops_do(f);\n+}\n+\n+JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+  return &frame_data_for_frame(frame)->jfa;\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaFrameAnchor.hpp\"\n@@ -37,0 +38,1 @@\n+class JNIHandleBlock;\n@@ -80,1 +82,1 @@\n-class JavaFrameAnchor; \/\/ for EntryBlob::jfa_for_frame\n+class JavaFrameAnchor; \/\/ for OptimizedEntryBlob::jfa_for_frame\n@@ -729,1 +731,2 @@\n-\/\/ For optimized upcall stubs\n+class ProgrammableUpcallHandler;\n+\n@@ -731,0 +734,1 @@\n+  friend class ProgrammableUpcallHandler;\n@@ -734,1 +738,1 @@\n-  ByteSize _jfa_sp_offset;\n+  ByteSize _frame_data_offset;\n@@ -737,1 +741,9 @@\n-            jobject receiver, ByteSize jfa_sp_offset);\n+                     jobject receiver, ByteSize frame_data_offset);\n+\n+  struct FrameData {\n+    JavaFrameAnchor jfa;\n+    JavaThread* thread;\n+    JNIHandleBlock* old_handles;\n+    JNIHandleBlock* new_handles;\n+    bool should_detach;\n+  };\n@@ -739,0 +751,2 @@\n+  \/\/ defined in frame_ARCH.cpp\n+  FrameData* frame_data_for_frame(const frame& frame) const;\n@@ -742,2 +756,2 @@\n-                           intptr_t exception_handler_offset, jobject receiver,\n-                           ByteSize jfa_sp_offset);\n+                                    intptr_t exception_handler_offset, jobject receiver,\n+                                    ByteSize frame_data_offset);\n@@ -747,1 +761,0 @@\n-  ByteSize jfa_sp_offset() const { return _jfa_sp_offset; }\n@@ -749,1 +762,0 @@\n-  \/\/ defined in frame_ARCH.cpp\n@@ -752,0 +764,2 @@\n+  void oops_do(OopClosure* f, const frame& frame);\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    assert(!JavaThread::cast(thread)->has_last_Java_frame(), \"newly-attached thread not expected to have last Java frame\");\n@@ -74,0 +75,87 @@\n+\/\/ modelled after JavaCallWrapper::JavaCallWrapper\n+Thread* ProgrammableUpcallHandler::on_entry(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = JavaThread::cast(maybe_attach_and_get_thread(&context->should_detach));\n+  context->thread = thread;\n+\n+  assert(thread->can_call_java(), \"must be able to call Java\");\n+\n+  \/\/ Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java,\n+  \/\/ since it can potentially block.\n+  context->new_handles = JNIHandleBlock::allocate_block(thread);\n+\n+  \/\/ After this, we are official in Java Code. This needs to be done before we change any of the thread local\n+  \/\/ info, since we cannot find oops before the new information is set up completely.\n+  ThreadStateTransition::transition_from_native(thread, _thread_in_Java);\n+\n+  \/\/ Make sure that we handle asynchronous stops and suspends _before_ we clear all thread state\n+  \/\/ in OptimizedEntryBlob::FrameData. This way, we can decide if we need to do any pd actions\n+  \/\/ to prepare for stop\/suspend (flush register windows on sparcs, cache sp, or other state).\n+  bool clear_pending_exception = true;\n+  if (thread->has_special_runtime_exit_condition()) {\n+    thread->handle_special_runtime_exit_condition();\n+    if (thread->has_pending_exception()) {\n+      clear_pending_exception = false;\n+    }\n+  }\n+\n+  context->old_handles = thread->active_handles();\n+\n+  \/\/ For the profiler, the last_Java_frame information in thread must always be in\n+  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n+  \/\/ the valid transition is to clear _last_Java_sp and then reset the rest of\n+  \/\/ the (platform specific) state.\n+\n+  context->jfa.copy(thread->frame_anchor());\n+  thread->frame_anchor()->clear();\n+\n+  debug_only(thread->inc_java_call_counter());\n+  thread->set_active_handles(context->new_handles);     \/\/ install new handle block and reset Java frame linkage\n+\n+  assert (thread->thread_state() != _thread_in_native, \"cannot set native pc to NULL\");\n+\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  if(clear_pending_exception) {\n+    thread->clear_pending_exception();\n+  }\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n+\n+  return thread;\n+}\n+\n+\/\/ modelled after JavaCallWrapper::~JavaCallWrapper\n+void ProgrammableUpcallHandler::on_exit(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = context->thread;\n+  assert(thread == JavaThread::current(), \"must still be the same thread\");\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n+\n+  \/\/ restore previous handle block\n+  thread->set_active_handles(context->old_handles);\n+\n+  thread->frame_anchor()->zap();\n+\n+  debug_only(thread->dec_java_call_counter());\n+\n+  \/\/ Old thread-local info. has been restored. We are not back in native code.\n+  ThreadStateTransition::transition_from_java(thread, _thread_in_native);\n+\n+  \/\/ State has been restored now make the anchor frame visible for the profiler.\n+  \/\/ Do this after the transition because this allows us to put an assert\n+  \/\/ the Java->native transition which checks to see that stack is not walkable\n+  \/\/ on sparc\/ia64 which will catch violations of the reseting of last_Java_frame\n+  \/\/ invariants (i.e. _flags always cleared on return to Java)\n+\n+  thread->frame_anchor()->copy(&context->jfa);\n+\n+  \/\/ Release handles after we are marked as being in native code again, since this\n+  \/\/ operation might block\n+  JNIHandleBlock::release_block(context->new_handles, thread);\n+\n+  assert(!thread->has_pending_exception(), \"Upcall can not throw an exception\");\n+\n+  if (context->should_detach) {\n+    detach_thread(thread);\n+  }\n+}\n+\n@@ -110,0 +198,1 @@\n+  ResourceMark rm;\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/codeBlob.hpp\"\n@@ -52,0 +53,3 @@\n+\n+  static Thread* on_entry(OptimizedEntryBlob::FrameData* context);\n+  static void on_exit(OptimizedEntryBlob::FrameData* context);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1071,3 +1071,1 @@\n-   \/\/ Nothing to do\n-   \/\/ receiver is a global ref\n-   \/\/ handle block is for JNI\n+    _cb->as_optimized_entry_blob()->oops_do(f, *this);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class ProgrammableUpcallHandler;\n@@ -55,0 +56,1 @@\n+friend class ProgrammableUpcallHandler;\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -931,0 +931,1 @@\n+    HandleMark hm(self);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1919,0 +1919,9 @@\n+#ifdef ASSERT\n+void JavaThread::verify_frame_info() {\n+  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n+         (has_last_Java_frame() && java_call_counter() > 0),\n+         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n+         has_last_Java_frame(), java_call_counter());\n+}\n+#endif\n+\n@@ -1926,2 +1935,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0), \"wrong java_sp info!\");\n+  DEBUG_ONLY(verify_frame_info();)\n@@ -1975,4 +1983,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  verify_frame_info();\n@@ -1983,4 +1988,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  DEBUG_ONLY(verify_frame_info();)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1130,0 +1130,2 @@\n+  DEBUG_ONLY(void verify_frame_info();)\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -327,0 +327,3 @@\n+        } catch(IOException e) {\n+            if (e.getMessage().equals(\"Function not implemented\"))\n+                throw new SkipException(e.getMessage(), e);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test\n+ * @test id=scope\n@@ -33,0 +33,25 @@\n+ *   -DUPCALL_TEST_TYPE=SCOPE\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=no_scope\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -DUPCALL_TEST_TYPE=NO_SCOPE\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=async\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -44,1 +69,1 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.SkipException;\n@@ -52,0 +77,1 @@\n+import java.util.HashMap;\n@@ -53,0 +79,1 @@\n+import java.util.Map;\n@@ -64,0 +91,8 @@\n+    private enum TestType {\n+        SCOPE,\n+        NO_SCOPE,\n+        ASYNC\n+    }\n+\n+    private static final TestType UPCALL_TEST_TYPE = TestType.valueOf(System.getProperty(\"UPCALL_TEST_TYPE\"));\n+\n@@ -66,0 +101,1 @@\n+        System.loadLibrary(\"AsyncInvokers\");\n@@ -91,0 +127,5 @@\n+    private static void checkSelected(TestType type) {\n+        if (UPCALL_TEST_TYPE != type)\n+            throw new SkipException(\"Skipping tests that were not selected\");\n+    }\n+\n@@ -93,0 +134,2 @@\n+        checkSelected(TestType.SCOPE);\n+\n@@ -111,0 +154,2 @@\n+        checkSelected(TestType.NO_SCOPE);\n+\n@@ -128,0 +173,57 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.ASYNC);\n+\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        MethodType mtype = methodType(ret, paramTypes, fields);\n+        try (NativeScope scope = new NativeScope()) {\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            MemoryAddress callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(scope, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n+\n+    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n+        if (ret == Ret.VOID) {\n+            String name = \"call_async_V\";\n+            return INVOKERS.computeIfAbsent(name, symbol ->\n+                abi.downcallHandle(\n+                    LOOKUP.lookup(symbol).orElseThrow(),\n+                    MethodType.methodType(void.class, MemoryAddress.class),\n+                    FunctionDescriptor.ofVoid(C_POINTER)));\n+        }\n+\n+        String name = \"call_async_\" + returnType.name().charAt(0)\n+                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n+\n+        return INVOKERS.computeIfAbsent(name, symbol -> {\n+            MemoryAddress invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            MemoryLayout returnLayout = returnType.layout(fields);\n+            MethodType type = MethodType.methodType(paramCarrier(returnLayout), MemoryAddress.class);\n+            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n+\n+            return abi.downcallHandle(invokerSymbol, type, desc);\n+        });\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":104,"deletions":2,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                    assertEquals(capturedArgsArr[i], args[i + 1]);\n+                    assertEquals(capturedArgsArr[i], args[i + 1], \"For index \" + i);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <thread>\n+\n+#include \"libTestUpcall.h\"\n+#ifdef __clang__\n+#pragma clang optimize off\n+#elif defined __GNUC__\n+#pragma GCC optimize (\"O0\")\n+#elif defined _MSC_BUILD\n+#pragma optimize( \"\", off )\n+#endif\n+\n+template<typename CB>\n+void launch_v(CB cb) {\n+    std::thread thrd(cb);\n+    thrd.join();\n+}\n+\n+template<typename O, typename CB>\n+void start(O& out, CB cb) {\n+    out = cb();\n+}\n+\n+template<typename O, typename CB>\n+O launch(CB cb) {\n+    O result;\n+    std::thread thrd(&start<O, CB>, std::ref(result), cb);\n+    thrd.join();\n+    return result;\n+}\n+\n+extern \"C\" {\n+EXPORT void call_async_V(void (*cb)(void)) { launch_v(cb); }\n+\n+EXPORT int call_async_I(int (*cb)(void)) { return launch<int>(cb); }\n+EXPORT float call_async_F(float (*cb)(void)) { return launch<float>(cb); }\n+EXPORT double call_async_D(double (*cb)(void)) { return launch<double>(cb); }\n+EXPORT void* call_async_P(void* (*cb)(void)) { return launch<void*>(cb); }\n+\n+EXPORT struct S_I call_async_S_I(struct S_I (*cb)(void)) { return launch<struct S_I>(cb); }\n+EXPORT struct S_F call_async_S_F(struct S_F (*cb)(void)) { return launch<struct S_F>(cb); }\n+EXPORT struct S_D call_async_S_D(struct S_D (*cb)(void)) { return launch<struct S_D>(cb); }\n+EXPORT struct S_P call_async_S_P(struct S_P (*cb)(void)) { return launch<struct S_P>(cb); }\n+EXPORT struct S_II call_async_S_II(struct S_II (*cb)(void)) { return launch<struct S_II>(cb); }\n+EXPORT struct S_IF call_async_S_IF(struct S_IF (*cb)(void)) { return launch<struct S_IF>(cb); }\n+EXPORT struct S_ID call_async_S_ID(struct S_ID (*cb)(void)) { return launch<struct S_ID>(cb); }\n+EXPORT struct S_IP call_async_S_IP(struct S_IP (*cb)(void)) { return launch<struct S_IP>(cb); }\n+EXPORT struct S_FI call_async_S_FI(struct S_FI (*cb)(void)) { return launch<struct S_FI>(cb); }\n+EXPORT struct S_FF call_async_S_FF(struct S_FF (*cb)(void)) { return launch<struct S_FF>(cb); }\n+EXPORT struct S_FD call_async_S_FD(struct S_FD (*cb)(void)) { return launch<struct S_FD>(cb); }\n+EXPORT struct S_FP call_async_S_FP(struct S_FP (*cb)(void)) { return launch<struct S_FP>(cb); }\n+EXPORT struct S_DI call_async_S_DI(struct S_DI (*cb)(void)) { return launch<struct S_DI>(cb); }\n+EXPORT struct S_DF call_async_S_DF(struct S_DF (*cb)(void)) { return launch<struct S_DF>(cb); }\n+EXPORT struct S_DD call_async_S_DD(struct S_DD (*cb)(void)) { return launch<struct S_DD>(cb); }\n+EXPORT struct S_DP call_async_S_DP(struct S_DP (*cb)(void)) { return launch<struct S_DP>(cb); }\n+EXPORT struct S_PI call_async_S_PI(struct S_PI (*cb)(void)) { return launch<struct S_PI>(cb); }\n+EXPORT struct S_PF call_async_S_PF(struct S_PF (*cb)(void)) { return launch<struct S_PF>(cb); }\n+EXPORT struct S_PD call_async_S_PD(struct S_PD (*cb)(void)) { return launch<struct S_PD>(cb); }\n+EXPORT struct S_PP call_async_S_PP(struct S_PP (*cb)(void)) { return launch<struct S_PP>(cb); }\n+EXPORT struct S_III call_async_S_III(struct S_III (*cb)(void)) { return launch<struct S_III>(cb); }\n+EXPORT struct S_IIF call_async_S_IIF(struct S_IIF (*cb)(void)) { return launch<struct S_IIF>(cb); }\n+EXPORT struct S_IID call_async_S_IID(struct S_IID (*cb)(void)) { return launch<struct S_IID>(cb); }\n+EXPORT struct S_IIP call_async_S_IIP(struct S_IIP (*cb)(void)) { return launch<struct S_IIP>(cb); }\n+EXPORT struct S_IFI call_async_S_IFI(struct S_IFI (*cb)(void)) { return launch<struct S_IFI>(cb); }\n+EXPORT struct S_IFF call_async_S_IFF(struct S_IFF (*cb)(void)) { return launch<struct S_IFF>(cb); }\n+EXPORT struct S_IFD call_async_S_IFD(struct S_IFD (*cb)(void)) { return launch<struct S_IFD>(cb); }\n+EXPORT struct S_IFP call_async_S_IFP(struct S_IFP (*cb)(void)) { return launch<struct S_IFP>(cb); }\n+EXPORT struct S_IDI call_async_S_IDI(struct S_IDI (*cb)(void)) { return launch<struct S_IDI>(cb); }\n+EXPORT struct S_IDF call_async_S_IDF(struct S_IDF (*cb)(void)) { return launch<struct S_IDF>(cb); }\n+EXPORT struct S_IDD call_async_S_IDD(struct S_IDD (*cb)(void)) { return launch<struct S_IDD>(cb); }\n+EXPORT struct S_IDP call_async_S_IDP(struct S_IDP (*cb)(void)) { return launch<struct S_IDP>(cb); }\n+EXPORT struct S_IPI call_async_S_IPI(struct S_IPI (*cb)(void)) { return launch<struct S_IPI>(cb); }\n+EXPORT struct S_IPF call_async_S_IPF(struct S_IPF (*cb)(void)) { return launch<struct S_IPF>(cb); }\n+EXPORT struct S_IPD call_async_S_IPD(struct S_IPD (*cb)(void)) { return launch<struct S_IPD>(cb); }\n+EXPORT struct S_IPP call_async_S_IPP(struct S_IPP (*cb)(void)) { return launch<struct S_IPP>(cb); }\n+EXPORT struct S_FII call_async_S_FII(struct S_FII (*cb)(void)) { return launch<struct S_FII>(cb); }\n+EXPORT struct S_FIF call_async_S_FIF(struct S_FIF (*cb)(void)) { return launch<struct S_FIF>(cb); }\n+EXPORT struct S_FID call_async_S_FID(struct S_FID (*cb)(void)) { return launch<struct S_FID>(cb); }\n+EXPORT struct S_FIP call_async_S_FIP(struct S_FIP (*cb)(void)) { return launch<struct S_FIP>(cb); }\n+EXPORT struct S_FFI call_async_S_FFI(struct S_FFI (*cb)(void)) { return launch<struct S_FFI>(cb); }\n+EXPORT struct S_FFF call_async_S_FFF(struct S_FFF (*cb)(void)) { return launch<struct S_FFF>(cb); }\n+EXPORT struct S_FFD call_async_S_FFD(struct S_FFD (*cb)(void)) { return launch<struct S_FFD>(cb); }\n+EXPORT struct S_FFP call_async_S_FFP(struct S_FFP (*cb)(void)) { return launch<struct S_FFP>(cb); }\n+EXPORT struct S_FDI call_async_S_FDI(struct S_FDI (*cb)(void)) { return launch<struct S_FDI>(cb); }\n+EXPORT struct S_FDF call_async_S_FDF(struct S_FDF (*cb)(void)) { return launch<struct S_FDF>(cb); }\n+EXPORT struct S_FDD call_async_S_FDD(struct S_FDD (*cb)(void)) { return launch<struct S_FDD>(cb); }\n+EXPORT struct S_FDP call_async_S_FDP(struct S_FDP (*cb)(void)) { return launch<struct S_FDP>(cb); }\n+EXPORT struct S_FPI call_async_S_FPI(struct S_FPI (*cb)(void)) { return launch<struct S_FPI>(cb); }\n+EXPORT struct S_FPF call_async_S_FPF(struct S_FPF (*cb)(void)) { return launch<struct S_FPF>(cb); }\n+EXPORT struct S_FPD call_async_S_FPD(struct S_FPD (*cb)(void)) { return launch<struct S_FPD>(cb); }\n+EXPORT struct S_FPP call_async_S_FPP(struct S_FPP (*cb)(void)) { return launch<struct S_FPP>(cb); }\n+EXPORT struct S_DII call_async_S_DII(struct S_DII (*cb)(void)) { return launch<struct S_DII>(cb); }\n+EXPORT struct S_DIF call_async_S_DIF(struct S_DIF (*cb)(void)) { return launch<struct S_DIF>(cb); }\n+EXPORT struct S_DID call_async_S_DID(struct S_DID (*cb)(void)) { return launch<struct S_DID>(cb); }\n+EXPORT struct S_DIP call_async_S_DIP(struct S_DIP (*cb)(void)) { return launch<struct S_DIP>(cb); }\n+EXPORT struct S_DFI call_async_S_DFI(struct S_DFI (*cb)(void)) { return launch<struct S_DFI>(cb); }\n+EXPORT struct S_DFF call_async_S_DFF(struct S_DFF (*cb)(void)) { return launch<struct S_DFF>(cb); }\n+EXPORT struct S_DFD call_async_S_DFD(struct S_DFD (*cb)(void)) { return launch<struct S_DFD>(cb); }\n+EXPORT struct S_DFP call_async_S_DFP(struct S_DFP (*cb)(void)) { return launch<struct S_DFP>(cb); }\n+EXPORT struct S_DDI call_async_S_DDI(struct S_DDI (*cb)(void)) { return launch<struct S_DDI>(cb); }\n+EXPORT struct S_DDF call_async_S_DDF(struct S_DDF (*cb)(void)) { return launch<struct S_DDF>(cb); }\n+EXPORT struct S_DDD call_async_S_DDD(struct S_DDD (*cb)(void)) { return launch<struct S_DDD>(cb); }\n+EXPORT struct S_DDP call_async_S_DDP(struct S_DDP (*cb)(void)) { return launch<struct S_DDP>(cb); }\n+EXPORT struct S_DPI call_async_S_DPI(struct S_DPI (*cb)(void)) { return launch<struct S_DPI>(cb); }\n+EXPORT struct S_DPF call_async_S_DPF(struct S_DPF (*cb)(void)) { return launch<struct S_DPF>(cb); }\n+EXPORT struct S_DPD call_async_S_DPD(struct S_DPD (*cb)(void)) { return launch<struct S_DPD>(cb); }\n+EXPORT struct S_DPP call_async_S_DPP(struct S_DPP (*cb)(void)) { return launch<struct S_DPP>(cb); }\n+EXPORT struct S_PII call_async_S_PII(struct S_PII (*cb)(void)) { return launch<struct S_PII>(cb); }\n+EXPORT struct S_PIF call_async_S_PIF(struct S_PIF (*cb)(void)) { return launch<struct S_PIF>(cb); }\n+EXPORT struct S_PID call_async_S_PID(struct S_PID (*cb)(void)) { return launch<struct S_PID>(cb); }\n+EXPORT struct S_PIP call_async_S_PIP(struct S_PIP (*cb)(void)) { return launch<struct S_PIP>(cb); }\n+EXPORT struct S_PFI call_async_S_PFI(struct S_PFI (*cb)(void)) { return launch<struct S_PFI>(cb); }\n+EXPORT struct S_PFF call_async_S_PFF(struct S_PFF (*cb)(void)) { return launch<struct S_PFF>(cb); }\n+EXPORT struct S_PFD call_async_S_PFD(struct S_PFD (*cb)(void)) { return launch<struct S_PFD>(cb); }\n+EXPORT struct S_PFP call_async_S_PFP(struct S_PFP (*cb)(void)) { return launch<struct S_PFP>(cb); }\n+EXPORT struct S_PDI call_async_S_PDI(struct S_PDI (*cb)(void)) { return launch<struct S_PDI>(cb); }\n+EXPORT struct S_PDF call_async_S_PDF(struct S_PDF (*cb)(void)) { return launch<struct S_PDF>(cb); }\n+EXPORT struct S_PDD call_async_S_PDD(struct S_PDD (*cb)(void)) { return launch<struct S_PDD>(cb); }\n+EXPORT struct S_PDP call_async_S_PDP(struct S_PDP (*cb)(void)) { return launch<struct S_PDP>(cb); }\n+EXPORT struct S_PPI call_async_S_PPI(struct S_PPI (*cb)(void)) { return launch<struct S_PPI>(cb); }\n+EXPORT struct S_PPF call_async_S_PPF(struct S_PPF (*cb)(void)) { return launch<struct S_PPF>(cb); }\n+EXPORT struct S_PPD call_async_S_PPD(struct S_PPD (*cb)(void)) { return launch<struct S_PPD>(cb); }\n+EXPORT struct S_PPP call_async_S_PPP(struct S_PPP (*cb)(void)) { return launch<struct S_PPP>(cb); }\n+}\n","filename":"test\/jdk\/java\/foreign\/libAsyncInvokers.cpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default_gc\n@@ -50,0 +50,57 @@\n+\/*\n+ * @test id=zgc\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Z\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestAsyncStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestAsyncStackWalk\n+ *\/\n+\/*\n+ * @test id=shenandoah\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestAsyncStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestAsyncStackWalk\n+ *\/\n+\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default_gc\n@@ -50,0 +50,57 @@\n+\/*\n+ * @test id=zgc\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Z\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestStackWalk\n+ *\/\n+\/*\n+ * @test id=shenandoah\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestStackWalk\n+ *\/\n+\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"}]}