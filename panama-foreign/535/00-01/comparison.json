{"files":[{"patch":"@@ -146,1 +146,1 @@\n-To avoid this problem, clients can acquire a so called resource scope *handle*. A resource scope handle effectively prevents a scope to be closed, until said handle is released by the application. Let's illustrate how that works in practice:\n+To avoid this problem, clients can acquire a so called resource scope *handle*. A resource scope handle effectively prevents a scope from being closed, until said handle is released by the application. Let's illustrate how that works in practice:\n@@ -183,1 +183,1 @@\n-The `MemorySegment::elements` method takes an element layout and returns a new stream. The stream is built on top of a spliterator instance (see `MemorySegment::spliterator`) which splits the segment into chunks which corresponds to the elements in the provided layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes *exactly* one element would be inefficient, so instead we use a *bulk* element layout. The bulk element layout is a sequence layout contains a group of 100 elements — which should make it more amenable to parallel processing.\n+The `MemorySegment::elements` method takes an element layout and returns a new stream. The stream is built on top of a spliterator instance (see `MemorySegment::spliterator`) which splits the segment into chunks which corresponds to the elements in the provided layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes *exactly* one element would be inefficient, so instead we use a *bulk* element layout. The bulk element layout is a sequence layout containing a group of 100 elements — which should make it more amenable to parallel processing.\n","filename":"doc\/panama_memaccess.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}