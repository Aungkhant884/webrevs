{"files":[{"patch":"@@ -447,2 +447,4 @@\n-     *\n-     * The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * <p>\n+     * Accessing a memory segment using the var handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n@@ -451,4 +453,3 @@\n-     * can be more strict (but not less) than the alignment constraint of the selected value layout.\n-     * <p>\n-     * Moreover, if the access operation (computed as above) falls outside the spatial bounds of the\n-     * accessed memory segment, an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A > S},\n+     * can be more strict (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n@@ -456,4 +457,6 @@\n-     * is the size of the accessed memory segment.\n-     * <p>\n-     * Finally, if the {@linkplain MemorySegment#scope() scope} associated with the accessed segment is not\n-     * {@linkplain MemorySegment.Scope#isAlive() alive}, the access operation will result in an {@link IllegalStateException}.\n+     * is the size of the accessed memory segment.<\/li>\n+     *     <li>The accessed memory segment must be {@link MemorySegment#isAccessibleBy(Thread) accessible} from the\n+     * thread performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed segment must be\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}, or an {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -535,3 +538,11 @@\n-     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n-     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n-     * strict (but not less) than the alignment constraint of the selected value layout.\n+     * Computing a slice of a memory segment using the method handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected layout.<\/li>\n+     *     <li>The start offset of the slicing operation (computed as above) must fall fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the start offset of the slicing operation (computed as above), {@code A} is the size of the\n+     * selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     * <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"}]}