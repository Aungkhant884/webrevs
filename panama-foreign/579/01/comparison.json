{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import static java.lang.constant.ConstantDescs.CD_Class;\n@@ -213,0 +214,3 @@\n+    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n+            MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_Class, CD_BYTEORDER));\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -683,0 +684,45 @@\n+    \/**\n+     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n+     * by the carrier provided:\n+     * <ul>\n+     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n+     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n+     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n+     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n+     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n+     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n+     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n+     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemoryAddress.class}<\/li>\n+     * <\/ul>\n+     * @param carrier the value layout carrier.\n+     * @param order the value layout's byte order.\n+     * @return a new value layout.\n+     * @throws IllegalArgumentException if the carrier type is not supported.\n+     *\/\n+    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(order);\n+        if (carrier == boolean.class) {\n+            return new ValueLayout.OfBoolean(order);\n+        } else if (carrier == char.class) {\n+            return new ValueLayout.OfChar(order);\n+        } else if (carrier == byte.class) {\n+            return new ValueLayout.OfByte(order);\n+        } else if (carrier == short.class) {\n+            return new ValueLayout.OfShort(order);\n+        } else if (carrier == int.class) {\n+            return new ValueLayout.OfInt(order);\n+        } else if (carrier == float.class) {\n+            return new ValueLayout.OfFloat(order);\n+        } else if (carrier == long.class) {\n+            return new ValueLayout.OfLong(order);\n+        } else if (carrier == double.class) {\n+            return new ValueLayout.OfDouble(order);\n+        } else if (carrier == MemoryAddress.class) {\n+            return new ValueLayout.OfAddress(order);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -151,14 +152,2 @@\n-        ClassDesc THIS_DESC = getClass().describeConstable().get();\n-        DynamicConstantDesc<ValueLayout> desc = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, specializedConstantName(), THIS_DESC, CD_VALUE_LAYOUT);\n-        if (order != ByteOrder.nativeOrder()) {\n-            MethodHandleDesc MH_WITH_ORDER = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, THIS_DESC, \"withOrder\",\n-                    MethodTypeDesc.of(THIS_DESC, CD_BYTEORDER));\n-\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withOrder\", desc.constantType(), MH_WITH_ORDER,\n-                    desc, order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN);\n-        }\n-        return Optional.of(decorateLayoutConstant(desc));\n-    }\n-\n-    String specializedConstantName() {\n-        throw new IllegalStateException();\n+        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"value\",\n+                CD_VALUE_LAYOUT, MH_VALUE, carrier().describeConstable().get(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));\n@@ -256,5 +245,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_BOOLEAN\";\n-        }\n@@ -295,5 +279,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_BYTE\";\n-        }\n@@ -334,5 +313,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_CHAR\";\n-        }\n@@ -373,5 +347,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_SHORT\";\n-        }\n@@ -412,5 +381,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_INT\";\n-        }\n@@ -451,5 +415,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_FLOAT\";\n-        }\n@@ -490,5 +449,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_LONG\";\n-        }\n@@ -529,5 +483,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"JAVA_DOUBLE\";\n-        }\n@@ -540,2 +489,2 @@\n-        OfAddress(ByteOrder order, long size) {\n-            super(MemoryAddress.class, order, size);\n+        OfAddress(ByteOrder order) {\n+            super(MemoryAddress.class, order, Unsafe.ADDRESS_SIZE * 8);\n@@ -568,5 +517,0 @@\n-\n-        @Override\n-        String specializedConstantName() {\n-            return \"ADDRESS\";\n-        }\n@@ -578,0 +522,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(MemoryAddress.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -579,1 +527,1 @@\n-    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder(), Unsafe.ADDRESS_SIZE * 8).withBitAlignment(8);\n+    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder()).withBitAlignment(8);\n@@ -584,0 +532,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -590,0 +542,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -596,0 +552,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -602,0 +562,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -608,0 +572,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -614,0 +582,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -621,0 +593,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n@@ -627,0 +603,4 @@\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":42,"deletions":62,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -632,23 +632,2 @@\n-            ValueLayout layout;\n-            if (type() == boolean.class) {\n-                layout = ValueLayout.JAVA_BOOLEAN;\n-            } else if (type() == char.class) {\n-                layout = ValueLayout.JAVA_CHAR;\n-            } else if (type() == byte.class) {\n-                layout = ValueLayout.JAVA_BYTE;\n-            } else if (type() == short.class) {\n-                layout = ValueLayout.JAVA_SHORT;\n-            } else if (type() == int.class) {\n-                layout = ValueLayout.JAVA_INT;\n-            } else if (type() == float.class) {\n-                layout = ValueLayout.JAVA_FLOAT;\n-            } else if (type() == long.class) {\n-                layout = ValueLayout.JAVA_LONG;\n-            } else if (type() == double.class) {\n-                layout = ValueLayout.JAVA_DOUBLE;\n-            } else if (type() == MemoryAddress.class) {\n-                layout = ValueLayout.ADDRESS;\n-            } else {\n-                throw new IllegalStateException(\"Unsupported carrier: \" + type().getName());\n-            }\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout.withOrder(ByteOrder.nativeOrder()).withBitAlignment(8)), 1, offset);\n+            ValueLayout layout = MemoryLayout.valueLayout(type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, offset);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"}]}