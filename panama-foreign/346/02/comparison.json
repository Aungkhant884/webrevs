{"files":[{"patch":"@@ -28,1 +28,4 @@\n- * <p> Classes to support low-level, safe and efficient memory access.\n+ * <p> Classes to support low-level and efficient foreign memory\/function access, directly from Java.\n+ *\n+ * <h2>Foreign memory access<\/h2>\n+ *\n@@ -30,1 +33,1 @@\n- * The key abstractions introduced by this package are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.\n+ * The key abstractions introduced to support foreign memory access are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.\n@@ -64,1 +67,1 @@\n- * <h2><a id=\"deallocation\"><\/a>Deterministic deallocation<\/h2>\n+ * <h3><a id=\"deallocation\"><\/a>Deterministic deallocation<\/h3>\n@@ -78,1 +81,1 @@\n- * <h2><a id=\"safety\"><\/a>Safety<\/h2>\n+ * <h3><a id=\"safety\"><\/a>Safety<\/h3>\n@@ -95,0 +98,137 @@\n+ *\n+ * <h2>Foreign function access<\/h2>\n+ * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.LibraryLookup} and {@link jdk.incubator.foreign.CLinker}.\n+ * The former is used to load foreign libraries, as well as to lookup symbols inside said libraries; the latter\n+ * provides linking capabilities which allow to model foreign functions as {@link jdk.incubator.foreign.MemoryHandles} instance,\n+ * so that clients can perform foreign function calls directly in Java, without the need for intermediate layers of native\n+ * code (as it's the case with the <a href=\"{@docRoot}\/..\/specs\/jni\/index.html\">Java Native Interface (JNI)<\/a>).\n+ * <p>\n+ * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux x64 platform,\n+ * we can use the following code:\n+ *\n+ * <pre>{@code\n+MethodHandle strlen = CLinker.getInstance().downcallHandle(\n+        LibraryLookup.ofDefault().lookup(\"strlen\"),\n+        MethodType.methodType(long.class, MemoryAddress.class),\n+        FunctionDescriptor.of(CLinker.C_LONG, CLinker.C_POINTER)\n+);\n+\n+try (var cString = CLinker.toCString(\"Hello\")) {\n+    long len = strlen.invokeExact(cString.address()) \/\/ 5\n+}\n+ * }<\/pre>\n+ *\n+ * Here, we lookup the {@code strlen} symbol in the <em>default<\/em> library lookup (see {@link jdk.incubator.foreign.LibraryLookup#ofDefault()}.\n+ * Then, we obtain a linker instance (see {@link jdk.incubator.foreign.CLinker#getInstance()}) and we use it to\n+ * obtain a method handle which targets the {@code strlen} library symbol. To complete the linking successfully,\n+ * we must provide (i) a {@link java.lang.invoke.MethodType} instance, describing the type of the resulting method handle\n+ * and (ii) a {@link jdk.incubator.foreign.FunctionDescriptor} instance, describing the signature of the {@code strlen}\n+ * function. From this information, the linker will uniquely determine the sequence of steps which will turn\n+ * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n+ * into a foreign function call, according to the rules specified by the platform C ABI. The {@link jdk.incubator.foreign.CLinker}\n+ * class also provides many useful methods for interacting with native code, such as converting Java strings into\n+ * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String)} and\n+ * {@link jdk.incubator.foreign.CLinker#toJavaString(jdk.incubator.foreign.MemorySegment)}, respectively), as\n+ * demonstrated in the above example.\n+ *\n+ * <h3>Foreign addresses<\/h3>\n+ *\n+ * When a memory segment is created from Java code, the segment properties (spatial bounds, temporal bounds and confinement)\n+ * are fully known at segment creation. But when interacting with native libraries, clients will often receive <em>raw<\/em> pointers;\n+ * such pointers have no spatial bounds (example: does the C type {@code char*} refer to a single {@code char} value,\n+ * or an array of {@code char} values, of given size?), no notion of temporal bounds, nor thread-confinement.\n+ * <p>\n+ * When clients receive a {@link jdk.incubator.foreign.MemoryAddress} instance from a foreign function call, it might be\n+ * necessary to obtain a {@link jdk.incubator.foreign.MemorySegment} instance to dereference the memory pointed to by that address.\n+ * To do that, clients can proceed in three different ways, described below.\n+ * <p>\n+ * First, if the memory address is known to belong to a segment the client already owns, a <em>rebase<\/em> operation can be performed;\n+ * in other words, the client can ask the address what its offset relative to a given segment is, and, then, proceed to dereference\n+ * the original segment accordingly, as follows:\n+ *\n+ * <pre>{@code\n+MemorySegment segment = MemorySegment.allocateNative(100);\n+...\n+MemoryAddress addr = ... \/\/obtain address from native code\n+int x = MemoryAccess.getIntAtOffset(segment, addr.segmentOffset(segment));\n+ * }<\/pre>\n+ *\n+ * Secondly, if the client does <em>not<\/em> have a segment which contains a given memory address, it can create one <em>unsafely<\/em>,\n+ * using the {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)} factory. This allows the client to\n+ * inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n+ * which produced the native address. Here is how an unsafe segment can be created from a native address:\n+ *\n+ * <pre>{@code\n+MemoryAddress addr = ... \/\/obtain address from native code\n+MemorySegment segment = addr.asSegmentRestricted(4); \/\/ segment is 4 bytes long\n+int x = MemoryAccess.getInt(segment);\n+ * }<\/pre>\n+ *\n+ * Alternatively, the client can fall back to use the so called <em>everything<\/em> segment - that is, a primordial segment\n+ * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#ofNativeRestricted()}\n+ * method, so that dereference can happen without the need of creating any additional segment instances:\n+ *\n+ * <pre>{@code\n+MemoryAddress addr = ... \/\/obtain address from native code\n+int x = MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr.toRawLongValue());\n+ * }<\/pre>\n+ *\n+ * <h3>Upcalls<\/h3>\n+ * The {@link jdk.incubator.foreign.CLinker} class also allows to turn an existing method handle (which might point\n+ * to a Java method) into a native memory segment (see {@link jdk.incubator.foreign.MemorySegment}), so that Java code\n+ * can effectively be passed to other foreign functions. For instance, we can write a method that compares two\n+ * integer values, as follows:\n+ *\n+ * <pre>{@code\n+class IntComparator {\n+    static int intCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+        return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr1.toRawLongValue()) -\n+               MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr2.toRawLongValue());\n+    }\n+}\n+ * }<\/pre>\n+ *\n+ * The above method dereferences two memory addresses containing an integer value, and performs a simple comparison\n+ * by returning the difference between such values. We can then obtain a method handle which targets the above static\n+ * method, as follows:\n+ *\n+ * <pre>{@code\n+MethodHandle intCompareHandle = MethodHandles.lookup().findStatic(IntComparator.class,\n+                                                   \"intCompare\",\n+                                                   MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+ * }<\/pre>\n+ *\n+ * Now that we have a method handle instance, we can link it into a fresh native memory segment, using the {@link jdk.incubator.foreign.CLinker} class, as follows:\n+ *\n+ * <pre>{@code\n+MemorySegment comparFunc = CLinker.getInstance().upcallStub(\n+     intCompareHandle,\n+     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER)\n+);\n+ * }<\/pre>\n+ *\n+ * As before, we need to provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance describing the signature\n+ * of the function pointer we want to create; as before, this, coupled with the method handle type, uniquely determines the\n+ * sequence of steps which will allow foreign code to call the {@code intCompareHandle} according to the rules specified\n+ * by the platform C ABI.\n+ *\n+ * <h2>Restricted methods<\/h2>\n+ * Some methods in this package are considered <em>restricted<\/em>. Restricted methods are typically used to bind native\n+ * foreign data and\/or functions to first-class Java API elements which can then be used directly by client. For instance\n+ * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)} can be used to create\n+ * a fresh segment with given spatial bounds out of a native address.\n+ * <p>\n+ * Binding foreign data and\/or functions is generally unsafe and, if done incorrectly, can result in VM crashes, or memory corruption when the bound Java API element is accessed.\n+ * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)}, if the provided\n+ * spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n+ * memory when attempting to dereference said segment. For these reasons, it is crucial for code that calls a restricted method\n+ * to never pass arguments that might cause incorrect binding of foreign data and\/or functions to a Java API.\n+ * <p>\n+ * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the JDK property\n+ * {@code foreign.restricted} must be set to a value other than {@code deny}. The possible values for this property are:\n+ * <ul>\n+ * <li>{@code deny}: issues a runtime exception on each restricted call. This is the default value;<\/li>\n+ * <li>{@code permit}: allows restricted calls;<\/li>\n+ * <li>{@code warn}: like permit, but also prints a one-line warning on each restricted call;<\/li>\n+ * <li>{@code debug}: like permit, but also dumps the stack corresponding to any given restricted call.<\/li>\n+ * <\/ul>\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":144,"deletions":4,"binary":false,"changes":148,"status":"modified"}]}