{"files":[{"patch":"@@ -42,4 +42,3 @@\n- * This interface is a used as a super class for all ForeinLinker implementations that\n- * implement the system's C ABI and calling convention. As such, instances of this interface\n- * can be used to link foreign functions in native libraries that follow the JVM's target\n- * platform C application binary interface (ABI).\n+ * A foreign linker specializing for C Application Binary Interface (ABI) calling conventions.\n+ * Instances of this interface can be used to link foreign functions in native libraries that\n+ * follow the JVM's target platform C ABI.\n@@ -48,3 +47,5 @@\n- * a function descriptor. The method type, consisting of a set of 'carrier' types constitutes\n- * the Java side of a call to a foreign function, while the function descriptor constitutes\n- * the native side of the call. Memory layout attributes are used in the function descriptor\n+ * a function descriptor. The method type, consisting of a set of <em>carrier<\/em> types constitute the\n+ * set of carrier types, which, together, specify the Java signature which clients must adhere to when\n+ * calling the underlying foreign function. The function descriptor contains a set of memory layouts which,\n+ * together, specify the foreign function signature and classification information (via custom layout attributes),\n+ * so that linking can take place. Memory layout attributes are used in the function descriptor\n@@ -52,2 +53,5 @@\n- * Clients of this API should use the prepared memory layout constants found in this interface\n- * to create their function descriptor, based on the built-in types provided by the C language.<\/p>\n+ * Clients of this API should build function descriptors using the predefined memory layout constants\n+ * (based on a subset of the built-in types provided by the C language), found in this interface;\n+ * a failure to do so might result in linkage errors, given that linking requires additional classification\n+ * information to determine, for instance, how arguments should be loaded into registers during a\n+ * foreign function call.<\/p>\n@@ -68,1 +72,1 @@\n- *   <li>If the carrier type is {@code MemoryAddress} or {@code VaList}, then the corresponding memory layout must be a\n+ *   <li>If the carrier type is {@code MemoryAddress}, then the corresponding memory layout must be a\n@@ -70,2 +74,1 @@\n- *   For this purpose, {@link CLinker#C_POINTER} can  be used as a memory layout for {@code MemoryAddress} carriers,\n- *   and {@link CLinker#C_VA_LIST} can be used for {@code VaList} carriers.<\/li>\n+ *   For this purpose, {@link CLinker#C_POINTER} can  be used<\/li>\n@@ -75,0 +78,3 @@\n+ *\n+ *   <li>If the carrier type is {@code VaList}, then the corresponding memory layout must be\n+ *   {@link CLinker#C_VA_LIST}<\/li>\n@@ -80,2 +86,2 @@\n- * handle that accepts a variable number of arguments. However, for down calls only, it is possible to link a native\n- * variadic function by using a 'specialized' method type and function descriptor: for each argument that is to be\n+ * handle that accepts a variable number of arguments. However, for downcalls only, it is possible to link a native\n+ * variadic function by using a <em>specialized<\/em> method type and function descriptor: for each argument that is to be\n@@ -83,3 +89,4 @@\n- * function descriptor when linking the function. Furthermore, the memory layouts of variadic arguments must\n- * have a special vararg attribute. Such memory layouts can be created from an existing layout by calling\n- * {@link #asVarArg(MemoryLayout)}<\/p>\n+ * function descriptor when linking the function. Furthermore, as memory layouts corresponding to variadic arguments in\n+ * a function descriptor must contain additional classification information, it is required that\n+ * {@link #asVarArg(MemoryLayout)} is used to create the memory layouts for each parameter corresponding to a variadic\n+ * argument in a specialized function descriptor<\/p>\n@@ -90,1 +97,1 @@\n-     * Obtain a linker that uses the de facto C ABI of the current system to do it's linking.\n+     * Obtain a linker that uses the de facto C ABI of the current system to do its linking.\n@@ -99,2 +106,2 @@\n-    static CLinker getSystemLinker() {\n-        Utils.checkRestrictedAccess(\"SystemCLinker.getSystemLinker\");\n+    static CLinker getInstance() {\n+        Utils.checkRestrictedAccess(\"CLinker.getInstance\");\n@@ -140,5 +147,1 @@\n-     * The {@code _Bool} native type.\n-     *\/\n-    ValueLayout C_BOOL = pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);\n-    \/**\n-     * The {@code char} native type.\n+     * The layout for the {@code char} C type\n@@ -148,1 +151,1 @@\n-     * The {@code short} native type.\n+     * The layout for the {@code short} C type\n@@ -152,1 +155,1 @@\n-     * The {@code int} native type.\n+     * The layout for the {@code int} C type\n@@ -156,1 +159,1 @@\n-     * The {@code long} native type.\n+     * The layout for the {@code long} C type\n@@ -164,1 +167,1 @@\n-     * The {@code float} native type.\n+     * The layout for the {@code float} C type\n@@ -168,1 +171,1 @@\n-     * The {@code double} native type.\n+     * The layout for the {@code double} C type\n@@ -180,1 +183,1 @@\n-     * The {@code va_list} native type.\n+     * The layout for the {@code va_list} C type\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":34,"deletions":31,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -83,6 +83,0 @@\n-        \/**\n-         * The {@code _Bool} native type.\n-         *\/\n-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n@@ -188,6 +182,0 @@\n-        \/**\n-         * The {@code _Bool} native type.\n-         *\/\n-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n@@ -291,6 +279,0 @@\n-        \/**\n-         * The {@code _Bool} native type.\n-         *\/\n-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -30,0 +31,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -38,2 +40,2 @@\n-        System.out.println(CLinker.C_BOOL); \/\/ trigger clinit\n-        assertNotNull(CLinker.C_BOOL); \/\/ should not be null\n+        System.out.println(PlatformLayouts.Win64.C_CHAR); \/\/ trigger clinit\n+        assertNotNull(CLinker.C_CHAR); \/\/ should not be null\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit1.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -30,0 +31,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -38,4 +40,4 @@\n-        System.out.println(CLinker.C_BOOL); \/\/ trigger clinit\n-        assertNotNull(CLinker.C_BOOL);\n-        assertNotNull(CLinker.C_BOOL);\n-        assertNotNull(CLinker.C_BOOL);\n+        System.out.println(CLinker.C_CHAR); \/\/ trigger clinit\n+        assertNotNull(PlatformLayouts.Win64.C_CHAR);\n+        assertNotNull(PlatformLayouts.SysV.C_CHAR);\n+        assertNotNull(PlatformLayouts.AArch64.C_CHAR);\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit2.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}