{"files":[{"patch":"@@ -31,1 +31,1 @@\n- * {@link MemoryAddress}, {@link LibraryLookup.Symbol} and {@link CSupport.VaList}.\n+ * {@link MemoryAddress}, {@link LibraryLookup.Symbol} and {@link CLinker.VaList}.\n@@ -36,1 +36,1 @@\n- * and {@link CSupport.VaList}.\n+ * and {@link CLinker.VaList}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,703 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.PlatformLayouts;\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.nio.charset.Charset;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import static jdk.internal.foreign.PlatformLayouts.*;\n+\n+\/**\n+ * A foreign linker specializing for C Application Binary Interface (ABI) calling conventions.\n+ * Instances of this interface can be used to link foreign functions in native libraries that\n+ * follow the JVM's target platform C ABI.\n+ *\n+ * <p>There are two components that go into linking a foreign function: a method type, and\n+ * a function descriptor. The method type, consists of a set of <em>carrier<\/em> types, which, together,\n+ * specify the Java signature which clients must adhere to when calling the underlying foreign function.\n+ * The function descriptor contains a set of memory layouts which, together, specify the foreign function\n+ * signature and classification information (via custom layout attributes), so that linking can take place.\n+ * Memory layout attributes are used in the function descriptor to attach ABI classification meta-data to\n+ * memory layouts, which are required for linking. Clients of this API should build function descriptors\n+ * using the predefined memory layout constants (based on a subset of the built-in types provided by the C language),\n+ * found in this interface; a failure to do so might result in linkage errors, given that linking requires additional\n+ * classification information to determine, for instance, how arguments should be loaded into registers during a\n+ * foreign function call.<\/p>\n+ *\n+ * <p>Implementations of this interface support the following primitive carrier types:\n+ * {@code byte}, {@code short}, {@code char}, {@code int}, {@code long}, {@code float},\n+ * and {@code double}, as well as {@link MemoryAddress} for passing pointers, and\n+ * {@link MemorySegment} for passing structs and unions. Finally, the {@link VaList}\n+ * carrier type can be used to match the native {@code va_list} type.<\/p>\n+ *\n+ * <p>The function descriptor used in linking contains a memory layout to match each carrier type.\n+ * There are some restrictions on the carrier type and memory layout combinations that are allowed:<\/p>\n+ * <ul>\n+ *   <li>If a primitve type is used as a carrier type, the corresponding\n+ *   memory layout must be a {@code ValueLayout}, and the bit size of the layout must match that of the carrier type\n+ *   (see {@link Integer#SIZE} and similar fields in other primitive wrapper classes).<\/li>\n+ *\n+ *   <li>If the carrier type is {@code MemoryAddress}, then the corresponding memory layout must be a\n+ *   {@code ValueLayout}, and its bit size must match the platform's address size (see {@link MemoryLayouts#ADDRESS}).\n+ *   For this purpose, {@link CLinker#C_POINTER} can  be used<\/li>\n+ *\n+ *   <li>If the carrier type is {@code MemorySegment}, then the corresponding memory layout must be a\n+ *   {@code GroupLayout}<\/li>\n+ *\n+ *   <li>If the carrier type is {@code VaList}, then the corresponding memory layout must be\n+ *   {@link CLinker#C_VA_LIST}<\/li>\n+ * <\/ul>\n+ *\n+ * <p>Variadic functions, declared in C either with a trailing ellipses ({@code ...}) at the end of the formal parameter\n+ * list or with an empty formal parameter list, are not supported directly. It is not possible to create a method handle\n+ * that takes a variable number of arguments, and neither is it possible to create an upcall stub wrapping a method\n+ * handle that accepts a variable number of arguments. However, for downcalls only, it is possible to link a native\n+ * variadic function by using a <em>specialized<\/em> method type and function descriptor: for each argument that is to be\n+ * passed as a variadic argument, an explicit carrier type and memory layout must be present in the method type and\n+ * function descriptor when linking the function. Furthermore, as memory layouts corresponding to variadic arguments in\n+ * a function descriptor must contain additional classification information, it is required that\n+ * {@link #asVarArg(MemoryLayout)} is used to create the memory layouts for each parameter corresponding to a variadic\n+ * argument in a specialized function descriptor<\/p>\n+ *\n+ * @apiNote In the future, if the Java language permits, {@link MemoryLayout}\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by\n+ * explicitly permitted types.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public interface CLinker {\n+\n+    \/**\n+     * Returns the C linker for the current platform.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @return a linker for this system.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     *\/\n+    static CLinker getInstance() {\n+        Utils.checkRestrictedAccess(\"CLinker.getInstance\");\n+        return SharedUtils.getSystemLinker();\n+    }\n+\n+    \/**\n+     * Obtain a foreign method handle, with given type, which can be used to call a\n+     * target foreign function at a given address and featuring a given function descriptor.\n+     *\n+     * @param symbol   downcall symbol.\n+     * @param type     the method type.\n+     * @param function the function descriptor.\n+     * @return the downcall method handle.\n+     * @throws IllegalArgumentException in the case of a carrier type and memory layout mismatch.\n+     *\/\n+    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n+\n+    \/**\n+     * Allocates a native segment whose base address (see {@link MemorySegment#address}) can be\n+     * passed to other foreign functions (as a function pointer); calling such a function pointer\n+     * from native code will result in the execution of the provided method handle.\n+     *\n+     * <p>The returned segment is <em>not<\/em> thread-confined, and it only features\n+     * the {@link MemorySegment#CLOSE} access mode. When the returned segment is closed,\n+     * the corresponding native stub will be deallocated.<\/p>\n+     *\n+     * @param target   the target method handle.\n+     * @param function the function descriptor.\n+     * @return the native stub segment.\n+     * @throws IllegalArgumentException in the case of a carrier type and memory layout mismatch.\n+     *\/\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);\n+\n+    \/**\n+     * The layout for the {@code char} C type\n+     *\/\n+    ValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n+    \/**\n+     * The layout for the {@code short} C type\n+     *\/\n+    ValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n+    \/**\n+     * The layout for the {@code int} C type\n+     *\/\n+    ValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n+    \/**\n+     * The layout for the {@code long} C type\n+     *\/\n+    ValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n+    \/**\n+     * The {@code long long} native type.\n+     *\/\n+    ValueLayout C_LONGLONG = pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);\n+    \/**\n+     * The layout for the {@code float} C type\n+     *\/\n+    ValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n+    \/**\n+     * The layout for the {@code double} C type\n+     *\/\n+    ValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n+    \/**\n+     * The {@code long double} native type.\n+     *\/\n+    ValueLayout C_LONGDOUBLE = pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);\n+    \/**\n+     * The {@code T*} native type.\n+     *\/\n+    ValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n+    \/**\n+     * The layout for the {@code va_list} C type\n+     *\/\n+    MemoryLayout C_VA_LIST = pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);\n+\n+    \/**\n+     * Returns a memory layout that is suitable to use the layout for variadic arguments.\n+     *\n+     * @param ml the layout the adapt\n+     * @return a potentially newly created layout with the right attributes\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends MemoryLayout> T asVarArg(T ml) {\n+        return (T) PlatformLayouts.asVarArg(ml);\n+    }\n+\n+        \/**\n+     * Convert a Java string into a null-terminated C string, using the\n+     * platform's default charset, storing the result into a new native memory segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native memory segment containing the converted C string.\n+     * @throws NullPointerException if either {@code str == null}.\n+     *\/\n+    static MemorySegment toCString(String str) {\n+        Objects.requireNonNull(str);\n+        return toCString(str.getBytes());\n+    }\n+\n+    \/**\n+     * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},\n+     * storing the result into a new native memory segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.\n+     * @return a new native memory segment containing the converted C string.\n+     * @throws NullPointerException if either {@code str == null} or {@code charset == null}.\n+     *\/\n+    static MemorySegment toCString(String str, Charset charset) {\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(charset);\n+        return toCString(str.getBytes(charset));\n+    }\n+\n+    \/**\n+     * Convert a Java string into a null-terminated C string, using the platform's default charset,\n+     * storing the result into a native memory segment allocated using the provided scope.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @param scope the scope to be used for the native segment allocation.\n+     * @return a new native memory segment containing the converted C string.\n+     * @throws NullPointerException if either {@code str == null} or {@code scope == null}.\n+     *\/\n+    static MemorySegment toCString(String str, NativeScope scope) {\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(scope);\n+        return toCString(str.getBytes(), scope);\n+    }\n+\n+    \/**\n+     * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},\n+     * storing the result into a new native memory segment native memory segment allocated using the provided scope.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.\n+     * @param scope the scope to be used for the native segment allocation.\n+     * @return a new native memory segment containing the converted C string.\n+     * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.\n+     *\/\n+    static MemorySegment toCString(String str, Charset charset, NativeScope scope) {\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(scope);\n+        return toCString(str.getBytes(charset), scope);\n+    }\n+\n+    \/**\n+     * Convert a null-terminated C string stored at given address into a Java string, using the platform's default charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param addr the address at which the string is stored.\n+     * @return a Java string with the contents of the null-terminated C string at given address.\n+     * @throws NullPointerException if {@code addr == null}\n+     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n+     *\/\n+    static String toJavaStringRestricted(MemoryAddress addr) {\n+        Utils.checkRestrictedAccess(\"CLinker.toJavaStringRestricted\");\n+        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), Charset.defaultCharset());\n+    }\n+\n+    \/**\n+     * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param addr the address at which the string is stored.\n+     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.\n+     * @return a Java string with the contents of the null-terminated C string at given address.\n+     * @throws NullPointerException if {@code addr == null}\n+     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n+     *\/\n+    static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {\n+        Utils.checkRestrictedAccess(\"CLinker.toJavaStringRestricted\");\n+        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), charset);\n+    }\n+\n+    \/**\n+     * Convert a null-terminated C string stored at given address into a Java string, using the platform's default charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param addr the address at which the string is stored.\n+     * @return a Java string with the contents of the null-terminated C string at given address.\n+     * @throws NullPointerException if {@code addr == null}\n+     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of the segment\n+     * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive<\/em>.\n+     *\/\n+    static String toJavaString(MemorySegment addr) {\n+        return SharedUtils.toJavaStringInternal(addr, 0L, Charset.defaultCharset());\n+    }\n+\n+    \/**\n+     * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param addr the address at which the string is stored.\n+     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.\n+     * @return a Java string with the contents of the null-terminated C string at given address.\n+     * @throws NullPointerException if {@code addr == null}\n+     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of the segment\n+     * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive<\/em>.\n+     *\/\n+    static String toJavaString(MemorySegment addr, Charset charset) {\n+        return SharedUtils.toJavaStringInternal(addr, 0L, charset);\n+    }\n+\n+    private static void copy(MemorySegment addr, byte[] bytes) {\n+        var heapSegment = MemorySegment.ofArray(bytes);\n+        addr.copyFrom(heapSegment);\n+        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n+    }\n+\n+    private static MemorySegment toCString(byte[] bytes) {\n+        MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);\n+        copy(segment, bytes);\n+        return segment;\n+    }\n+\n+    private static MemorySegment toCString(byte[] bytes, NativeScope scope) {\n+        MemorySegment addr = scope.allocate(bytes.length + 1, 1L);\n+        copy(addr, bytes);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate memory of given size using malloc.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param size memory size to be allocated\n+     * @return addr memory address of the allocated memory\n+     *\/\n+    static MemoryAddress allocateMemoryRestricted(long size) {\n+        Utils.checkRestrictedAccess(\"CLinker.allocateMemoryRestricted\");\n+        return SharedUtils.allocateMemoryInternal(size);\n+    }\n+\n+    \/**\n+     * Free the memory pointed by the given memory address.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param addr memory address of the native memory to be freed\n+     *\/\n+    static void freeMemoryRestricted(MemoryAddress addr) {\n+        Utils.checkRestrictedAccess(\"CLinker.freeMemoryRestricted\");\n+        SharedUtils.freeMemoryInternal(addr);\n+    }\n+\n+    \/**\n+     * An interface that models a C {@code va_list}.\n+     * <p>\n+     * A va list is a stateful cursor used to iterate over a set of variadic arguments.\n+     * <p>\n+     * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n+     * arguments to variadic calls are erased by way of 'default argument promotions',\n+     * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n+     * and which erases all {@code float} arguments to {@code double}.\n+     * <p>\n+     * As such, this interface only supports reading {@code int}, {@code double},\n+     * and any other type that fits into a {@code long}.\n+     *\n+     * @apiNote In the future, if the Java language permits, {@link VaList}\n+     * may become a {@code sealed} interface, which would prohibit subclassing except by\n+     * explicitly permitted types.\n+     *\n+     *\/\n+    interface VaList extends Addressable, AutoCloseable {\n+\n+        \/**\n+         * Reads the next value as an {@code int} and advances this va list's position.\n+         *\n+         * @param layout the layout of the value\n+         * @return the value read as an {@code int}\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n+         *\/\n+        int vargAsInt(MemoryLayout layout);\n+\n+        \/**\n+         * Reads the next value as a {@code long} and advances this va list's position.\n+         *\n+         * @param layout the layout of the value\n+         * @return the value read as an {@code long}\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n+         *\/\n+        long vargAsLong(MemoryLayout layout);\n+\n+        \/**\n+         * Reads the next value as a {@code double} and advances this va list's position.\n+         *\n+         * @param layout the layout of the value\n+         * @return the value read as an {@code double}\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n+         *\/\n+        double vargAsDouble(MemoryLayout layout);\n+\n+        \/**\n+         * Reads the next value as a {@code MemoryAddress} and advances this va list's position.\n+         *\n+         * @param layout the layout of the value\n+         * @return the value read as an {@code MemoryAddress}\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n+         *\/\n+        MemoryAddress vargAsAddress(MemoryLayout layout);\n+\n+        \/**\n+         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n+         * <p>\n+         * The memory segment returned by this method will be allocated using\n+         * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.\n+         *\n+         * @param layout the layout of the value\n+         * @return the value read as an {@code MemorySegment}\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n+         *\/\n+        MemorySegment vargAsSegment(MemoryLayout layout);\n+\n+        \/**\n+         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n+         * <p>\n+         * The memory segment returned by this method will be allocated using the given {@code NativeScope}.\n+         *\n+         * @param layout the layout of the value\n+         * @param scope the scope to allocate the segment in\n+         * @return the value read as an {@code MemorySegment}\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n+         *\/\n+        MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);\n+\n+        \/**\n+         * Skips a number of elements with the given memory layouts, and advances this va list's position.\n+         *\n+         * @param layouts the layout of the value\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         *\/\n+        void skip(MemoryLayout... layouts);\n+\n+        \/**\n+         * A predicate used to check if the memory associated with the C {@code va_list} modelled\n+         * by this instance is still valid to use.\n+         *\n+         * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid\n+         * @see #close()\n+         *\/\n+        boolean isAlive();\n+\n+        \/**\n+         * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached\n+         * to this va list that holds its elements (see {@link VaList#make(Consumer)}).\n+         * <p>\n+         * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values\n+         * from this va list will result in an exception.\n+         *\n+         * @see #isAlive()\n+         *\/\n+        void close();\n+\n+        \/**\n+         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n+         * starting from the current position, without affecting the state of the original va list, essentially\n+         * allowing the elements to be traversed multiple times.\n+         * <p>\n+         * If this method needs to allocate native memory for the copy, it will use\n+         * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the\n+         * returned va list instance to release the allocated memory.\n+         * <p>\n+         * This method only copies the va list cursor itself and not the memory that may be attached to the\n+         * va list which holds its elements. That means that if this va list was created with the\n+         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n+         * elements, making the copy unusable.\n+         *\n+         * @return a copy of this C {@code va_list}.\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         *\/\n+        VaList copy();\n+\n+        \/**\n+         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n+         * starting from the current position, without affecting the state of the original va list, essentially\n+         * allowing the elements to be traversed multiple times.\n+         * <p>\n+         * If this method needs to allocate native memory for the copy, it will use\n+         * the given {@code NativeScope} to do so.\n+         * <p>\n+         * This method only copies the va list cursor itself and not the memory that may be attached to the\n+         * va list which holds its elements. That means that if this va list was created with the\n+         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n+         * elements, making the copy unusable.\n+         *\n+         * @param scope the scope to allocate the copy in\n+         * @return a copy of this C {@code va_list}.\n+         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n+         * (see {@link #close()}).\n+         *\/\n+        VaList copy(NativeScope scope);\n+\n+        \/**\n+         * Returns the memory address of the C {@code va_list} associated with this instance.\n+         *\n+         * @return the memory address of the C {@code va_list} associated with this instance.\n+         *\/\n+        @Override\n+        MemoryAddress address();\n+\n+        \/**\n+         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n+         * <p>\n+         * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+         * restricted methods, and use safe and supported functionalities, where possible.\n+         *\n+         * @param address a memory address pointing to an existing C {@code va_list}.\n+         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n+         *\/\n+        static VaList ofAddressRestricted(MemoryAddress address) {\n+            Utils.checkRestrictedAccess(\"VaList.ofAddressRestricted\");\n+            return SharedUtils.newVaListOfAddress(address);\n+        }\n+\n+        \/**\n+         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n+         * <p>\n+         * If this method needs to allocate native memory for the va list, it will use\n+         * {@link MemorySegment#allocateNative(long, long)} to do so.\n+         * <p>\n+         * This method will allocate native memory to hold the elements in the va list. This memory\n+         * will be 'attached' to the returned va list instance, and will be released when {@link VaList#close()}\n+         * is called.\n+         * <p>\n+         * Note that when there are no elements added to the created va list,\n+         * this method will return the same as {@linkplain #empty()}.\n+         *\n+         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n+         *                of the underlying C {@code va_list}.\n+         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n+         *\/\n+        static VaList make(Consumer<Builder> actions) {\n+            return SharedUtils.newVaList(actions, MemorySegment::allocateNative);\n+        }\n+\n+        \/**\n+         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n+         * <p>\n+         * If this method needs to allocate native memory for the va list, it will use\n+         * the given {@code NativeScope} to do so.\n+         * <p>\n+         * This method will allocate native memory to hold the elements in the va list. This memory\n+         * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.\n+         * <p>\n+         * Note that when there are no elements added to the created va list,\n+         * this method will return the same as {@linkplain #empty()}.\n+         *\n+         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n+         *                of the underlying C {@code va_list}.\n+         * @param scope the scope to be used for the valist allocation.\n+         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n+         *\/\n+        static VaList make(Consumer<Builder> actions, NativeScope scope) {\n+            return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+        }\n+\n+        \/**\n+         * Returns an empty C {@code va_list} constant.\n+         * <p>\n+         * The returned {@code VaList} can not be closed.\n+         *\n+         * @return a {@code VaList} modelling an empty C {@code va_list}.\n+         *\/\n+        static VaList empty() {\n+            return SharedUtils.emptyVaList();\n+        }\n+\n+        \/**\n+         * A builder interface used to construct a C {@code va_list}.\n+         *\n+         * @apiNote In the future, if the Java language permits, {@link MemoryLayout}\n+         * may become a {@code sealed} interface, which would prohibit subclassing except by\n+         * explicitly permitted types.\n+         *\n+         *\/\n+        interface Builder {\n+\n+            \/**\n+             * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.\n+             *\n+             * @param layout the native layout of the value.\n+             * @param value the value, represented as an {@code int}.\n+             * @return this builder.\n+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n+             *\/\n+            Builder vargFromInt(ValueLayout layout, int value);\n+\n+            \/**\n+             * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.\n+             *\n+             * @param layout the native layout of the value.\n+             * @param value the value, represented as a {@code long}.\n+             * @return this builder.\n+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n+             *\/\n+            Builder vargFromLong(ValueLayout layout, long value);\n+\n+            \/**\n+             * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.\n+             *\n+             * @param layout the native layout of the value.\n+             * @param value the value, represented as a {@code double}.\n+             * @return this builder.\n+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n+             *\/\n+            Builder vargFromDouble(ValueLayout layout, double value);\n+\n+            \/**\n+             * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.\n+             *\n+             * @param layout the native layout of the value.\n+             * @param value the value, represented as a {@code Addressable}.\n+             * @return this builder.\n+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n+             *\/\n+            Builder vargFromAddress(ValueLayout layout, Addressable value);\n+\n+            \/**\n+             * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.\n+             *\n+             * @param layout the native layout of the value.\n+             * @param value the value, represented as a {@code MemorySegment}.\n+             * @return this builder.\n+             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n+             *\/\n+            Builder vargFromSegment(GroupLayout layout, MemorySegment value);\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":703,"deletions":0,"binary":false,"changes":703,"status":"added"},{"patch":"@@ -1,925 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.nio.ByteOrder;\n-import java.nio.charset.Charset;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-\/**\n- * A set of utilities for working with libraries using the C language\/ABI\n- *\/\n-public class CSupport {\n-\n-    \/**\n-     * No need to construct\n-     *\/\n-    private CSupport() {}\n-\n-    \/**\n-     * Obtain a linker that uses the de facto C ABI of the current system to do it's linking.\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @return a linker for this system.\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n-     *\/\n-    public static ForeignLinker getSystemLinker() {\n-        Utils.checkRestrictedAccess(\"CSupport.getSystemLinker\");\n-        return SharedUtils.getSystemLinker();\n-    }\n-\n-    \/**\n-     * An interface that models a C {@code va_list}.\n-     * <p>\n-     * A va list is a stateful cursor used to iterate over a set of variadic arguments.\n-     * <p>\n-     * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n-     * arguments to variadic calls are erased by way of 'default argument promotions',\n-     * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n-     * and which erases all {@code float} arguments to {@code double}.\n-     * <p>\n-     * As such, this interface only supports reading {@code int}, {@code double},\n-     * and any other type that fits into a {@code long}.\n-     *\/\n-    public interface VaList extends Addressable, AutoCloseable {\n-\n-        \/**\n-         * Reads the next value as an {@code int} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code int}\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-         *\/\n-        int vargAsInt(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code long} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code long}\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-         *\/\n-        long vargAsLong(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code double} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code double}\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-         *\/\n-        double vargAsDouble(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemoryAddress} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code MemoryAddress}\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-         *\/\n-        MemoryAddress vargAsAddress(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be allocated using\n-         * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be allocated using the given {@code NativeScope}.\n-         *\n-         * @param layout the layout of the value\n-         * @param scope the scope to allocate the segment in\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);\n-\n-        \/**\n-         * Skips a number of elements with the given memory layouts, and advances this va list's position.\n-         *\n-         * @param layouts the layout of the value\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         *\/\n-        void skip(MemoryLayout... layouts);\n-\n-        \/**\n-         * A predicate used to check if the memory associated with the C {@code va_list} modelled\n-         * by this instance is still valid to use.\n-         *\n-         * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid\n-         * @see #close()\n-         *\/\n-        boolean isAlive();\n-\n-        \/**\n-         * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached\n-         * to this va list that holds its elements (see {@link VaList#make(Consumer)}).\n-         * <p>\n-         * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values\n-         * from this va list will result in an exception.\n-         *\n-         * @see #isAlive()\n-         *\/\n-        void close();\n-\n-        \/**\n-         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-         * starting from the current position, without affecting the state of the original va list, essentially\n-         * allowing the elements to be traversed multiple times.\n-         * <p>\n-         * If this method needs to allocate native memory for the copy, it will use\n-         * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the\n-         * returned va list instance to release the allocated memory.\n-         * <p>\n-         * This method only copies the va list cursor itself and not the memory that may be attached to the\n-         * va list which holds its elements. That means that if this va list was created with the\n-         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n-         * elements, making the copy unusable.\n-         *\n-         * @return a copy of this C {@code va_list}.\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         *\/\n-        VaList copy();\n-\n-        \/**\n-         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-         * starting from the current position, without affecting the state of the original va list, essentially\n-         * allowing the elements to be traversed multiple times.\n-         * <p>\n-         * If this method needs to allocate native memory for the copy, it will use\n-         * the given {@code NativeScope} to do so.\n-         * <p>\n-         * This method only copies the va list cursor itself and not the memory that may be attached to the\n-         * va list which holds its elements. That means that if this va list was created with the\n-         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n-         * elements, making the copy unusable.\n-         *\n-         * @param scope the scope to allocate the copy in\n-         * @return a copy of this C {@code va_list}.\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         *\/\n-        VaList copy(NativeScope scope);\n-\n-        \/**\n-         * Returns the memory address of the C {@code va_list} associated with this instance.\n-         *\n-         * @return the memory address of the C {@code va_list} associated with this instance.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-\n-        \/**\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n-         * <p>\n-         * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param address a memory address pointing to an existing C {@code va_list}.\n-         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-         *\/\n-        static VaList ofAddressRestricted(MemoryAddress address) {\n-            Utils.checkRestrictedAccess(\"VaList.ofAddressRestricted\");\n-            return SharedUtils.newVaListOfAddress(address);\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n-         * <p>\n-         * If this method needs to allocate native memory for the va list, it will use\n-         * {@link MemorySegment#allocateNative(long, long)} to do so.\n-         * <p>\n-         * This method will allocate native memory to hold the elements in the va list. This memory\n-         * will be 'attached' to the returned va list instance, and will be released when {@link VaList#close()}\n-         * is called.\n-         * <p>\n-         * Note that when there are no elements added to the created va list,\n-         * this method will return the same as {@linkplain #empty()}.\n-         *\n-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-         *                of the underlying C {@code va_list}.\n-         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n-         *\/\n-        static VaList make(Consumer<VaList.Builder> actions) {\n-            return SharedUtils.newVaList(actions, MemorySegment::allocateNative);\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n-         * <p>\n-         * If this method needs to allocate native memory for the va list, it will use\n-         * the given {@code NativeScope} to do so.\n-         * <p>\n-         * This method will allocate native memory to hold the elements in the va list. This memory\n-         * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.\n-         * <p>\n-         * Note that when there are no elements added to the created va list,\n-         * this method will return the same as {@linkplain #empty()}.\n-         *\n-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-         *                of the underlying C {@code va_list}.\n-         * @param scope the scope to be used for the valist allocation.\n-         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n-         *\/\n-        static VaList make(Consumer<VaList.Builder> actions, NativeScope scope) {\n-            return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n-        }\n-\n-        \/**\n-         * Returns an empty C {@code va_list} constant.\n-         * <p>\n-         * The returned {@code VaList} can not be closed.\n-         *\n-         * @return a {@code VaList} modelling an empty C {@code va_list}.\n-         *\/\n-        static VaList empty() {\n-            return SharedUtils.emptyVaList();\n-        }\n-\n-        \/**\n-         * A builder interface used to construct a C {@code va_list}.\n-         *\/\n-        interface Builder {\n-\n-            \/**\n-             * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as an {@code int}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-             *\/\n-            Builder vargFromInt(ValueLayout layout, int value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code long}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-             *\/\n-            Builder vargFromLong(ValueLayout layout, long value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code double}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-             *\/\n-            Builder vargFromDouble(ValueLayout layout, double value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code Addressable}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-             *\/\n-            Builder vargFromAddress(ValueLayout layout, Addressable value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code MemorySegment}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-             *\/\n-            Builder vargFromSegment(GroupLayout layout, MemorySegment value);\n-        }\n-    }\n-\n-    \/**\n-     * The {@code _Bool} native type.\n-     *\/\n-    public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);\n-    \/**\n-     * The {@code char} native type.\n-     *\/\n-    public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n-    \/**\n-     * The {@code short} native type.\n-     *\/\n-    public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n-    \/**\n-     * The {@code int} native type.\n-     *\/\n-    public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n-    \/**\n-     * The {@code long} native type.\n-     *\/\n-    public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n-    \/**\n-     * The {@code long long} native type.\n-     *\/\n-    public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);\n-    \/**\n-     * The {@code float} native type.\n-     *\/\n-    public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n-    \/**\n-     * The {@code double} native type.\n-     *\/\n-    public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n-    \/**\n-     * The {@code long double} native type.\n-     *\/\n-    public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);\n-    \/**\n-     * The {@code T*} native type.\n-     *\/\n-    public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n-\n-    \/**\n-     * The {@code va_list} native type.\n-     *\/\n-    public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);\n-\n-    \/**\n-     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.\n-     *\/\n-    public static final class SysV {\n-        private SysV() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The name of the SysV linker\n-         * @see ForeignLinker#name\n-         *\/\n-        public static final String NAME = \"SysV\";\n-\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n-         * attribute value must be an enum constant from {@link ArgumentClass}.\n-         *\/\n-        public final static String CLASS_ATTRIBUTE_NAME = \"abi\/sysv\/class\";\n-\n-        \/**\n-         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n-         *\/\n-        public enum ArgumentClass {\n-            \/** Classification constant for integral values *\/\n-            INTEGER,\n-            \/** Classification constant for floating point values *\/\n-            SSE,\n-            \/** Classification constant for x87 floating point values *\/\n-            X87,\n-            \/** Classification constant for {@code complex long double} values *\/\n-            COMPLEX_87,\n-            \/** Classification constant for machine pointer values *\/\n-            POINTER;\n-        }\n-\n-        \/**\n-         * The {@code _Bool} native type.\n-         *\/\n-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);\n-\n-        \/**\n-         * The {@code long double} native type.\n-         *\/\n-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);\n-\n-        \/**\n-         * The {@code complex long double} native type.\n-         *\/\n-        public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n-\n-        \/**\n-         * The {@code va_list} native type, as it is passed to a function.\n-         *\/\n-        public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;\n-    }\n-\n-    \/**\n-     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.\n-     *\/\n-    public static final class Win64 {\n-\n-        private Win64() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The name of the Windows linker\n-         * @see ForeignLinker#name\n-         *\/\n-        public final static String NAME = \"Windows\";\n-\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The\n-         * attribute value must be a boolean.\n-         *\/\n-        public final static String VARARGS_ATTRIBUTE_NAME = \"abi\/windows\/varargs\";\n-\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n-         * attribute value must be an enum constant from {@link ArgumentClass}.\n-         *\/\n-        public final static String CLASS_ATTRIBUTE_NAME = \"abi\/windows\/class\";\n-\n-        \/**\n-         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n-         *\/\n-        public enum ArgumentClass {\n-            \/** Classification constant for integral values *\/\n-            INTEGER,\n-            \/** Classification constant for floating point values *\/\n-            FLOAT,\n-            \/** Classification constant for machine pointer values *\/\n-            POINTER;\n-        }\n-\n-        \/**\n-         * The {@code _Bool} native type.\n-         *\/\n-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n-\n-        \/**\n-         * The {@code long double} native type.\n-         *\/\n-        public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n-\n-        \/**\n-         * The {@code va_list} native type, as it is passed to a function.\n-         *\/\n-        public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;\n-\n-        \/**\n-         * Return a new memory layout which describes a variadic parameter to be passed to a function.\n-         * @param layout the original parameter layout.\n-         * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},\n-         * which is set to {@code true}.\n-         *\/\n-        public static ValueLayout asVarArg(ValueLayout layout) {\n-            return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);\n-        }\n-    }\n-\n-    \/**\n-     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.\n-     *\/\n-    public static final class AArch64 {\n-\n-        private AArch64() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The name of the AArch64 linker\n-         * @see ForeignLinker#name\n-         *\/\n-        public final static String NAME = \"AArch64\";\n-\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n-         * attribute value must be an enum constant from {@link ArgumentClass}.\n-         *\/\n-        public static final String CLASS_ATTRIBUTE_NAME = \"abi\/aarch64\/class\";\n-\n-        \/**\n-         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n-         *\/\n-        public enum ArgumentClass {\n-            \/** Classification constant for machine integral values *\/\n-            INTEGER,\n-            \/** Classification constant for machine floating point values *\/\n-            VECTOR,\n-            \/** Classification constant for machine pointer values *\/\n-            POINTER;\n-        }\n-\n-        \/**\n-         * The {@code _Bool} native type.\n-         *\/\n-        public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n-\n-        \/**\n-         * The {@code long double} native type.\n-         *\/\n-        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n-                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n-\n-        \/**\n-         * The {@code va_list} native type, as it is passed to a function.\n-         *\/\n-        public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;\n-    }\n-\n-    \/**\n-     * Convert a Java string into a null-terminated C string, using the\n-     * platform's default charset, storing the result into a new native memory segment.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @return a new native memory segment containing the converted C string.\n-     * @throws NullPointerException if either {@code str == null}.\n-     *\/\n-    public static MemorySegment toCString(String str) {\n-        Objects.requireNonNull(str);\n-        return toCString(str.getBytes());\n-    }\n-\n-    \/**\n-     * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},\n-     * storing the result into a new native memory segment.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.\n-     * @return a new native memory segment containing the converted C string.\n-     * @throws NullPointerException if either {@code str == null} or {@code charset == null}.\n-     *\/\n-    public static MemorySegment toCString(String str, Charset charset) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(charset);\n-        return toCString(str.getBytes(charset));\n-    }\n-\n-    \/**\n-     * Convert a Java string into a null-terminated C string, using the platform's default charset,\n-     * storing the result into a native memory segment allocated using the provided scope.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param scope the scope to be used for the native segment allocation.\n-     * @return a new native memory segment containing the converted C string.\n-     * @throws NullPointerException if either {@code str == null} or {@code scope == null}.\n-     *\/\n-    public static MemorySegment toCString(String str, NativeScope scope) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(scope);\n-        return toCString(str.getBytes(), scope);\n-    }\n-\n-    \/**\n-     * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},\n-     * storing the result into a new native memory segment native memory segment allocated using the provided scope.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.\n-     * @param scope the scope to be used for the native segment allocation.\n-     * @return a new native memory segment containing the converted C string.\n-     * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.\n-     *\/\n-    public static MemorySegment toCString(String str, Charset charset, NativeScope scope) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(charset);\n-        Objects.requireNonNull(scope);\n-        return toCString(str.getBytes(charset), scope);\n-    }\n-\n-    \/**\n-     * Convert a null-terminated C string stored at given address into a Java string, using the platform's default charset.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws NullPointerException if {@code addr == null}\n-     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n-     *\/\n-    public static String toJavaStringRestricted(MemoryAddress addr) {\n-        Utils.checkRestrictedAccess(\"CSupport.toJavaStringRestricted\");\n-        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), Charset.defaultCharset());\n-    }\n-\n-    \/**\n-     * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param addr the address at which the string is stored.\n-     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws NullPointerException if {@code addr == null}\n-     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n-     *\/\n-    public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {\n-        Utils.checkRestrictedAccess(\"CSupport.toJavaStringRestricted\");\n-        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue(), charset);\n-    }\n-\n-    \/**\n-     * Convert a null-terminated C string stored at given address into a Java string, using the platform's default charset.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws NullPointerException if {@code addr == null}\n-     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n-     * @throws IllegalStateException if the size of the native string is greater than the size of the segment\n-     * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive<\/em>.\n-     *\/\n-    public static String toJavaString(MemorySegment addr) {\n-        return SharedUtils.toJavaStringInternal(addr, 0L, Charset.defaultCharset());\n-    }\n-\n-    \/**\n-     * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * @param addr the address at which the string is stored.\n-     * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws NullPointerException if {@code addr == null}\n-     * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.\n-     * @throws IllegalStateException if the size of the native string is greater than the size of the segment\n-     * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive<\/em>.\n-     *\/\n-    public static String toJavaString(MemorySegment addr, Charset charset) {\n-        return SharedUtils.toJavaStringInternal(addr, 0L, charset);\n-    }\n-\n-    private static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n-    }\n-\n-    private static MemorySegment toCString(byte[] bytes) {\n-        MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);\n-        copy(segment, bytes);\n-        return segment;\n-    }\n-\n-    private static MemorySegment toCString(byte[] bytes, NativeScope scope) {\n-        MemorySegment addr = scope.allocate(bytes.length + 1, 1L);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate memory of given size using malloc.\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param size memory size to be allocated\n-     * @return addr memory address of the allocated memory\n-     *\/\n-    public static MemoryAddress allocateMemoryRestricted(long size) {\n-        Utils.checkRestrictedAccess(\"CSupport.allocateMemoryRestricted\");\n-        return SharedUtils.allocateMemoryInternal(size);\n-    }\n-\n-    \/**\n-     * Free the memory pointed by the given memory address.\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr memory address of the native memory to be freed\n-     *\/\n-    public static void freeMemoryRestricted(MemoryAddress addr) {\n-        Utils.checkRestrictedAccess(\"CSupport.freeMemoryRestricted\");\n-        SharedUtils.freeMemoryInternal(addr);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CSupport.java","additions":0,"deletions":925,"binary":false,"changes":925,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.incubator.foreign;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-\n-\/**\n- * This class can be used to link native functions as a {@link MethodHandle}, or to link Java\n- * methods as a native function pointer (modelled as a {@link MemorySegment}).\n- *\n- * Instances of this interface can be obtained for instance by calling {@link CSupport#getSystemLinker()}\n- *\/\n-public interface ForeignLinker {\n-    \/**\n-     * Obtain a method handle which can be used to call a given native function.\n-     *\n-     * @param symbol downcall symbol.\n-     * @param type the method type.\n-     * @param function the function descriptor.\n-     * @return the downcall method handle.\n-     *\/\n-    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n-\n-    \/**\n-     * Allocates a native stub segment which contains executable code to upcall into a given method handle.\n-     * As such, the base address of the returned stub segment can be passed to other foreign functions\n-     * (as a function pointer). The returned segment is <em>not<\/em> thread-confined, and it only features\n-     * the {@link MemorySegment#CLOSE} access mode. When the returned segment is closed,\n-     * the corresponding native stub will be deallocated.\n-     *\n-     * @param target the target method handle.\n-     * @param function the function descriptor.\n-     * @return the native stub segment.\n-     *\/\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);\n-\n-    \/**\n-     * Returns the name of this linker.\n-     *\n-     * @return the name\n-     *\/\n-    String name();\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ForeignLinker.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -41,1 +41,1 @@\n- * {@link ForeignLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}) also maintain a strong reference\n+ * {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}) also maintain a strong reference\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+public enum CABI {\n+    SysV,\n+    Win64,\n+    AArch64;\n+\n+    public static CABI current() {\n+        String arch = System.getProperty(\"os.arch\");\n+        String os = System.getProperty(\"os.name\");\n+        if (arch.equals(\"amd64\") || arch.equals(\"x86_64\")) {\n+            if (os.startsWith(\"Windows\")) {\n+                return Win64;\n+            } else {\n+                return SysV;\n+            }\n+        } else if (arch.equals(\"aarch64\")) {\n+            return AArch64;\n+        }\n+        throw new UnsupportedOperationException(\"Unsupported os or arch: \" + os + \", \" + arch);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.nio.ByteOrder;\n+\n+public class PlatformLayouts {\n+    public static <Z extends MemoryLayout> Z pick(Z sysv, Z win64, Z aarch64) {\n+        return switch (CABI.current()) {\n+            case SysV -> sysv;\n+            case Win64 -> win64;\n+            case AArch64 -> aarch64;\n+        };\n+    }\n+\n+    public static MemoryLayout asVarArg(MemoryLayout ml) {\n+        if (CABI.current() == CABI.Win64) {\n+            return Win64.asVarArg(ml);\n+        }\n+        return ml;\n+    }\n+\n+    \/**\n+     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.\n+     *\/\n+    public static final class SysV {\n+        private SysV() {\n+            \/\/just the one\n+        }\n+\n+        \/**\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n+         * attribute value must be an enum constant from {@link ArgumentClass}.\n+         *\/\n+        public final static String CLASS_ATTRIBUTE_NAME = \"abi\/sysv\/class\";\n+\n+        \/**\n+         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n+         *\/\n+        public enum ArgumentClass {\n+            \/** Classification constant for integral values *\/\n+            INTEGER,\n+            \/** Classification constant for floating point values *\/\n+            SSE,\n+            \/** Classification constant for x87 floating point values *\/\n+            X87,\n+            \/** Classification constant for {@code complex long double} values *\/\n+            COMPLEX_87,\n+            \/** Classification constant for machine pointer values *\/\n+            POINTER;\n+        }\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);\n+\n+        \/**\n+         * The {@code long double} native type.\n+         *\/\n+        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);\n+\n+        \/**\n+         * The {@code complex long double} native type.\n+         *\/\n+        public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n+\n+        \/**\n+         * The {@code va_list} native type, as it is passed to a function.\n+         *\/\n+        public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;\n+    }\n+\n+    \/**\n+     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.\n+     *\/\n+    public static final class Win64 {\n+\n+        private Win64() {\n+            \/\/just the one\n+        }\n+\n+        \/**\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The\n+         * attribute value must be a boolean.\n+         *\/\n+        public final static String VARARGS_ATTRIBUTE_NAME = \"abi\/windows\/varargs\";\n+\n+        \/**\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n+         * attribute value must be an enum constant from {@link ArgumentClass}.\n+         *\/\n+        public final static String CLASS_ATTRIBUTE_NAME = \"abi\/windows\/class\";\n+\n+        \/**\n+         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n+         *\/\n+        public enum ArgumentClass {\n+            \/** Classification constant for integral values *\/\n+            INTEGER,\n+            \/** Classification constant for floating point values *\/\n+            FLOAT,\n+            \/** Classification constant for machine pointer values *\/\n+            POINTER;\n+        }\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n+\n+        \/**\n+         * The {@code long double} native type.\n+         *\/\n+        public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n+\n+        \/**\n+         * The {@code va_list} native type, as it is passed to a function.\n+         *\/\n+        public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;\n+\n+        \/**\n+         * Return a new memory layout which describes a variadic parameter to be passed to a function.\n+         * @param layout the original parameter layout.\n+         * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},\n+         * which is set to {@code true}.\n+         *\/\n+        public static MemoryLayout asVarArg(MemoryLayout layout) {\n+            return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);\n+        }\n+    }\n+\n+    \/**\n+     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.\n+     *\/\n+    public static final class AArch64 {\n+\n+        private AArch64() {\n+            \/\/just the one\n+        }\n+\n+        \/**\n+         * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The\n+         * attribute value must be an enum constant from {@link ArgumentClass}.\n+         *\/\n+        public static final String CLASS_ATTRIBUTE_NAME = \"abi\/aarch64\/class\";\n+\n+        \/**\n+         * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.\n+         *\/\n+        public enum ArgumentClass {\n+            \/** Classification constant for machine integral values *\/\n+            INTEGER,\n+            \/** Classification constant for machine floating point values *\/\n+            VECTOR,\n+            \/** Classification constant for machine pointer values *\/\n+            POINTER;\n+        }\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n+\n+        \/**\n+         * The {@code long double} native type.\n+         *\/\n+        public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n+                .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);\n+\n+        \/**\n+         * The {@code va_list} native type, as it is passed to a function.\n+         *\/\n+        public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.CSupport;\n@@ -34,1 +33,0 @@\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -37,1 +35,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n@@ -120,10 +117,0 @@\n-    public static <Z extends MemoryLayout> Z pick(Z sysv, Z win64, Z aarch64) {\n-        ForeignLinker abi = SharedUtils.getSystemLinker();\n-        return switch (abi.name()) {\n-            case CSupport.SysV.NAME -> sysv;\n-            case CSupport.Win64.NAME -> win64;\n-            case CSupport.AArch64.NAME -> aarch64;\n-            default -> throw new ExceptionInInitializerError(\"Unexpected ABI: \" + abi.name());\n-        };\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -39,0 +37,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -40,0 +39,1 @@\n+import jdk.internal.foreign.CABI;\n@@ -60,1 +60,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.incubator.foreign.CLinker.*;\n@@ -238,13 +238,6 @@\n-    public static ForeignLinker getSystemLinker() {\n-        String arch = System.getProperty(\"os.arch\");\n-        String os = System.getProperty(\"os.name\");\n-        if (arch.equals(\"amd64\") || arch.equals(\"x86_64\")) {\n-            if (os.startsWith(\"Windows\")) {\n-                return Windowsx64Linker.getInstance();\n-            } else {\n-                return SysVx64Linker.getInstance();\n-            }\n-        } else if (arch.equals(\"aarch64\")) {\n-            return AArch64Linker.getInstance();\n-        }\n-        throw new UnsupportedOperationException(\"Unsupported os or arch: \" + os + \", \" + arch);\n+    public static CLinker getSystemLinker() {\n+        return switch (CABI.current()) {\n+            case Win64 -> Windowsx64Linker.getInstance();\n+            case SysV -> SysVx64Linker.getInstance();\n+            case AArch64 -> AArch64Linker.getInstance();\n+        };\n@@ -310,6 +303,4 @@\n-        String name = CSupport.getSystemLinker().name();\n-        return switch(name) {\n-            case Win64.NAME -> Windowsx64Linker.newVaList(actions, allocator);\n-            case SysV.NAME -> SysVx64Linker.newVaList(actions, allocator);\n-            case AArch64.NAME -> AArch64Linker.newVaList(actions, allocator);\n-            default -> throw new IllegalStateException(\"Unknown linker name: \" + name);\n+        return switch (CABI.current()) {\n+            case Win64 -> Windowsx64Linker.newVaList(actions, allocator);\n+            case SysV -> SysVx64Linker.newVaList(actions, allocator);\n+            case AArch64 -> AArch64Linker.newVaList(actions, allocator);\n@@ -326,6 +317,4 @@\n-        String name = CSupport.getSystemLinker().name();\n-        return switch(name) {\n-            case Win64.NAME -> Windowsx64Linker.newVaListOfAddress(ma);\n-            case SysV.NAME -> SysVx64Linker.newVaListOfAddress(ma);\n-            case AArch64.NAME -> AArch64Linker.newVaListOfAddress(ma);\n-            default -> throw new IllegalStateException(\"Unknown linker name: \" + name);\n+        return switch (CABI.current()) {\n+            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma);\n+            case SysV -> SysVx64Linker.newVaListOfAddress(ma);\n+            case AArch64 -> AArch64Linker.newVaListOfAddress(ma);\n@@ -336,6 +325,4 @@\n-        String name = CSupport.getSystemLinker().name();\n-        return switch(name) {\n-            case Win64.NAME -> Windowsx64Linker.emptyVaList();\n-            case SysV.NAME -> SysVx64Linker.emptyVaList();\n-            case AArch64.NAME -> AArch64Linker.emptyVaList();\n-            default -> throw new IllegalStateException(\"Unknown linker name: \" + name);\n+        return switch (CABI.current()) {\n+            case Win64 -> Windowsx64Linker.emptyVaList();\n+            case SysV -> SysVx64Linker.emptyVaList();\n+            case AArch64 -> AArch64Linker.emptyVaList();\n@@ -420,1 +407,1 @@\n-    public static class EmptyVaList implements CSupport.VaList {\n+    public static class EmptyVaList implements VaList {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":22,"deletions":35,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -43,1 +42,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -49,1 +48,1 @@\n-public class AArch64Linker implements ForeignLinker {\n+public class AArch64Linker implements CLinker {\n@@ -60,1 +59,1 @@\n-            MH_unboxVaList = lookup.findVirtual(CSupport.VaList.class, \"address\",\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n@@ -90,5 +89,0 @@\n-    @Override\n-    public String name() {\n-        return AArch64.NAME;\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-import static jdk.incubator.foreign.CSupport.AArch64;\n-import static jdk.incubator.foreign.CSupport.VaList;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64;\n+import static jdk.incubator.foreign.CLinker.VaList;\n@@ -100,1 +100,1 @@\n-    private static final CSupport.VaList EMPTY\n+    private static final VaList EMPTY\n@@ -141,1 +141,1 @@\n-    public static CSupport.VaList empty() {\n+    public static VaList empty() {\n@@ -425,1 +425,1 @@\n-    static class Builder implements CSupport.VaList.Builder {\n+    static class Builder implements VaList.Builder {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-import jdk.incubator.foreign.SequenceLayout;\n-import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -50,1 +49,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -34,6 +34,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -51,1 +52,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-import static jdk.incubator.foreign.CSupport.SysV;\n-import static jdk.incubator.foreign.CSupport.VaList;\n+import static jdk.internal.foreign.PlatformLayouts.SysV;\n+import static jdk.incubator.foreign.CLinker.VaList;\n@@ -115,1 +115,1 @@\n-    private static final CSupport.VaList EMPTY = new SharedUtils.EmptyVaList(emptyListAddress());\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(emptyListAddress());\n@@ -144,1 +144,1 @@\n-    public static CSupport.VaList empty() {\n+    public static VaList empty() {\n@@ -359,1 +359,1 @@\n-    static class Builder implements CSupport.VaList.Builder {\n+    static class Builder implements VaList.Builder {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -34,0 +32,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -43,1 +42,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -48,1 +47,1 @@\n-public class SysVx64Linker implements ForeignLinker {\n+public class SysVx64Linker implements CLinker {\n@@ -65,1 +64,1 @@\n-            MH_unboxVaList = lookup.findVirtual(CSupport.VaList.class, \"address\",\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n@@ -101,5 +100,0 @@\n-    @Override\n-    public String name() {\n-        return SysV.NAME;\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -48,1 +49,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.CSupport;\n@@ -32,0 +31,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -33,1 +33,2 @@\n-import static jdk.incubator.foreign.CSupport.Win64.VARARGS_ATTRIBUTE_NAME;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n+import static jdk.internal.foreign.PlatformLayouts.Win64.VARARGS_ATTRIBUTE_NAME;\n@@ -45,1 +46,1 @@\n-        CSupport.Win64.ArgumentClass clazz = Windowsx64Linker.argumentClassFor(type);\n+        Win64.ArgumentClass clazz = Windowsx64Linker.argumentClassFor(type);\n@@ -60,1 +61,1 @@\n-        if (clazz == CSupport.Win64.ArgumentClass.INTEGER) {\n+        if (clazz == Win64.ArgumentClass.INTEGER) {\n@@ -62,1 +63,1 @@\n-        } else if(clazz == CSupport.Win64.ArgumentClass.POINTER) {\n+        } else if(clazz == Win64.ArgumentClass.POINTER) {\n@@ -64,1 +65,1 @@\n-        } else if (clazz == CSupport.Win64.ArgumentClass.FLOAT) {\n+        } else if (clazz == Win64.ArgumentClass.FLOAT) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CSupport.VaList;\n+import jdk.incubator.foreign.CLinker.VaList;\n@@ -37,1 +37,1 @@\n-import static jdk.incubator.foreign.CSupport.Win64.C_POINTER;\n+import static jdk.internal.foreign.PlatformLayouts.Win64.C_POINTER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -34,0 +32,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -42,1 +41,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -47,1 +46,1 @@\n-public class Windowsx64Linker implements ForeignLinker {\n+public class Windowsx64Linker implements CLinker {\n@@ -66,1 +65,1 @@\n-            MH_unboxVaList = lookup.findVirtual(CSupport.VaList.class, \"address\",\n+            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n@@ -102,5 +101,0 @@\n-    @Override\n-    public String name() {\n-        return Win64.NAME;\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.incubator.foreign.CLinker.*;\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -28,1 +26,4 @@\n-import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.foreign.CABI;\n+import jdk.internal.foreign.PlatformLayouts;\n+\n+import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -32,1 +33,1 @@\n-    public static final ForeignLinker ABI = CSupport.getSystemLinker();\n+    public static final CABI ABI = CABI.current();\n@@ -35,5 +36,4 @@\n-        return switch (ABI.name()) {\n-            case CSupport.SysV.NAME -> layout.attribute(CSupport.SysV.CLASS_ATTRIBUTE_NAME).get() == CSupport.SysV.ArgumentClass.INTEGER;\n-            case CSupport.Win64.NAME -> layout.attribute(CSupport.Win64.CLASS_ATTRIBUTE_NAME).get() == CSupport.Win64.ArgumentClass.INTEGER;\n-            case CSupport.AArch64.NAME -> layout.attribute(CSupport.AArch64.CLASS_ATTRIBUTE_NAME).get() == CSupport.AArch64.ArgumentClass.INTEGER;\n-            default -> throw new AssertionError(\"unexpected ABI: \" + ABI.name());\n+        return switch (ABI) {\n+            case SysV -> layout.attribute(SysV.CLASS_ATTRIBUTE_NAME).get() == SysV.ArgumentClass.INTEGER;\n+            case Win64 -> layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get() == Win64.ArgumentClass.INTEGER;\n+            case AArch64 -> layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get() == AArch64.ArgumentClass.INTEGER;\n@@ -44,5 +44,4 @@\n-        return switch (ABI.name()) {\n-            case CSupport.SysV.NAME -> layout.attribute(CSupport.SysV.CLASS_ATTRIBUTE_NAME).get() == CSupport.SysV.ArgumentClass.POINTER;\n-            case CSupport.Win64.NAME -> layout.attribute(CSupport.Win64.CLASS_ATTRIBUTE_NAME).get() == CSupport.Win64.ArgumentClass.POINTER;\n-            case CSupport.AArch64.NAME -> layout.attribute(CSupport.AArch64.CLASS_ATTRIBUTE_NAME).get() == CSupport.AArch64.ArgumentClass.POINTER;\n-            default -> throw new AssertionError(\"unexpected ABI: \" + ABI.name());\n+        return switch (ABI) {\n+            case SysV -> layout.attribute(SysV.CLASS_ATTRIBUTE_NAME).get() == SysV.ArgumentClass.POINTER;\n+            case Win64 -> layout.attribute(Win64.CLASS_ATTRIBUTE_NAME).get() == Win64.ArgumentClass.POINTER;\n+            case AArch64 -> layout.attribute(AArch64.CLASS_ATTRIBUTE_NAME).get() == AArch64.ArgumentClass.POINTER;\n@@ -51,4 +50,0 @@\n-\n-    public static ValueLayout asVarArg(ValueLayout layout) {\n-        return ABI.name().equals(CSupport.Win64.NAME) ? CSupport.Win64.asVarArg(layout) : layout;\n-    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -53,1 +54,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.incubator.foreign.CLinker.*;\n@@ -59,1 +60,1 @@\n-    final static ForeignLinker abi = CSupport.getSystemLinker();\n+    final static CLinker abi = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -29,1 +30,2 @@\n-import jdk.incubator.foreign.CSupport;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -38,2 +40,2 @@\n-        System.out.println(CSupport.C_BOOL); \/\/ trigger clinit\n-        assertNotNull(CSupport.C_BOOL); \/\/ should not be null\n+        System.out.println(PlatformLayouts.Win64.C_CHAR); \/\/ trigger clinit\n+        assertNotNull(CLinker.C_CHAR); \/\/ should not be null\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit1.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -29,1 +30,2 @@\n-import jdk.incubator.foreign.CSupport;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -38,4 +40,4 @@\n-        System.out.println(CSupport.C_BOOL); \/\/ trigger clinit\n-        assertNotNull(CSupport.C_BOOL);\n-        assertNotNull(CSupport.C_BOOL);\n-        assertNotNull(CSupport.C_BOOL);\n+        System.out.println(CLinker.C_CHAR); \/\/ trigger clinit\n+        assertNotNull(PlatformLayouts.Win64.C_CHAR);\n+        assertNotNull(PlatformLayouts.SysV.C_CHAR);\n+        assertNotNull(PlatformLayouts.AArch64.C_CHAR);\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit2.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -51,1 +52,1 @@\n-import jdk.incubator.foreign.CSupport;\n+import jdk.incubator.foreign.CLinker;\n@@ -54,1 +55,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -56,1 +56,0 @@\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -70,1 +69,1 @@\n-    static ForeignLinker abi = CSupport.getSystemLinker();\n+    static CLinker abi = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary CSupport should have a way to free memory allocated outside Java\n+ * @summary SystemCLinker should have a way to free memory allocated outside Java\n@@ -36,1 +36,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.incubator.foreign.CLinker.*;\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n+import jdk.incubator.foreign.CLinker;\n@@ -43,1 +42,1 @@\n-import static jdk.incubator.foreign.CSupport.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n@@ -50,1 +49,1 @@\n-    private static final ForeignLinker ABI = CSupport.getSystemLinker();\n+    private static final CLinker ABI = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -35,2 +36,1 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n+import jdk.incubator.foreign.CLinker;\n@@ -39,1 +39,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -49,1 +48,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.incubator.foreign.CLinker.*;\n@@ -54,1 +53,1 @@\n-    static final ForeignLinker abi = CSupport.getSystemLinker();\n+    static final CLinker abi = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.foreign.CSupport;\n+import jdk.incubator.foreign.CLinker;\n@@ -145,1 +145,1 @@\n-        return CSupport.allocateMemoryRestricted(size);\n+        return CLinker.allocateMemoryRestricted(size);\n@@ -149,1 +149,1 @@\n-        CSupport.freeMemoryRestricted(addr);\n+        CLinker.freeMemoryRestricted(addr);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -51,1 +52,1 @@\n-import jdk.incubator.foreign.CSupport;\n+import jdk.incubator.foreign.CLinker;\n@@ -58,1 +59,0 @@\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -75,1 +75,1 @@\n-import static jdk.incubator.foreign.CSupport.C_POINTER;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -82,1 +82,1 @@\n-    static ForeignLinker abi = CSupport.getSystemLinker();\n+    static CLinker abi = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n+import jdk.incubator.foreign.CLinker;\n@@ -47,1 +46,1 @@\n-    static final ForeignLinker abi = CSupport.getSystemLinker();\n+    static final CLinker abi = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStubs.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n@@ -30,2 +31,1 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n+import jdk.incubator.foreign.CLinker;\n@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.CSupport.*;\n+import static jdk.incubator.foreign.CLinker.*;\n@@ -62,1 +62,1 @@\n-    static final ForeignLinker abi = CSupport.getSystemLinker();\n+    static final CLinker abi = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign.abi\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n@@ -45,1 +46,1 @@\n-import static jdk.incubator.foreign.CSupport.AArch64.*;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign.abi\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n@@ -46,1 +47,1 @@\n-import static jdk.incubator.foreign.CSupport.SysV.*;\n+import static jdk.internal.foreign.PlatformLayouts.SysV.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign.abi\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n@@ -45,1 +46,1 @@\n-import static jdk.incubator.foreign.CSupport.Win64.*;\n+import static jdk.internal.foreign.PlatformLayouts.Win64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n+import jdk.incubator.foreign.CLinker;\n@@ -63,1 +62,1 @@\n-import static jdk.incubator.foreign.CSupport.C_POINTER;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -68,1 +67,1 @@\n-    static final ForeignLinker linker = CSupport.getSystemLinker();\n+    static final CLinker linker = CLinker.getInstance();\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign.abi\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n@@ -35,4 +36,1 @@\n-import jdk.incubator.foreign.CSupport.AArch64;\n-import jdk.incubator.foreign.CSupport.SysV;\n-import jdk.incubator.foreign.CSupport.VaList;\n-import jdk.incubator.foreign.CSupport.Win64;\n+import jdk.incubator.foreign.CLinker.VaList;\n@@ -57,6 +55,6 @@\n-import static jdk.incubator.foreign.CSupport.C_DOUBLE;\n-import static jdk.incubator.foreign.CSupport.C_FLOAT;\n-import static jdk.incubator.foreign.CSupport.C_INT;\n-import static jdk.incubator.foreign.CSupport.C_LONGLONG;\n-import static jdk.incubator.foreign.CSupport.C_POINTER;\n-import static jdk.incubator.foreign.CSupport.C_VA_LIST;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_FLOAT;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONGLONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n@@ -65,0 +63,1 @@\n+import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -71,1 +70,1 @@\n-    private static final ForeignLinker abi = CSupport.getSystemLinker();\n+    private static final CLinker abi = CLinker.getInstance();\n@@ -76,1 +75,1 @@\n-            FunctionDescriptor.of(C_INT, C_INT, CSupport.C_VA_LIST));\n+            FunctionDescriptor.of(C_INT, C_INT, C_VA_LIST));\n@@ -79,1 +78,1 @@\n-            FunctionDescriptor.of(C_DOUBLE, C_INT, CSupport.C_VA_LIST));\n+            FunctionDescriptor.of(C_DOUBLE, C_INT, C_VA_LIST));\n@@ -121,1 +120,1 @@\n-            = CSupport.VaList::make;\n+            = VaList::make;\n@@ -130,1 +129,1 @@\n-            = CSupport.VaList::make;\n+            = VaList::make;\n@@ -801,1 +800,1 @@\n-        void accept(CSupport.VaList list);\n+        void accept(VaList list);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.CSupport;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -32,0 +30,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -45,4 +44,4 @@\n-import static jdk.incubator.foreign.CSupport.C_DOUBLE;\n-import static jdk.incubator.foreign.CSupport.C_INT;\n-import static jdk.incubator.foreign.CSupport.C_LONGLONG;\n-import static jdk.incubator.foreign.CSupport.C_POINTER;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONGLONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -58,1 +57,1 @@\n-    static final ForeignLinker abi = CSupport.getSystemLinker();\n+    static final CLinker abi = CLinker.getInstance();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverhead.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -30,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -44,2 +43,2 @@\n-import static jdk.incubator.foreign.CSupport.C_INT;\n-import static jdk.incubator.foreign.CSupport.C_POINTER;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -55,1 +54,1 @@\n-    static final ForeignLinker abi = CSupport.getSystemLinker();\n+    static final CLinker abi = CLinker.getInstance();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import jdk.incubator.foreign.CSupport;\n-import jdk.incubator.foreign.ForeignLinker;\n@@ -29,0 +27,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -42,4 +41,4 @@\n-import static jdk.incubator.foreign.CSupport.C_DOUBLE;\n-import static jdk.incubator.foreign.CSupport.C_INT;\n-import static jdk.incubator.foreign.CSupport.C_LONGLONG;\n-import static jdk.incubator.foreign.CSupport.Win64.asVarArg;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONGLONG;\n+import static jdk.incubator.foreign.CLinker.asVarArg;\n@@ -55,1 +54,1 @@\n-    static final ForeignLinker linker = CSupport.getSystemLinker();\n+    static final CLinker linker = CLinker.getInstance();\n@@ -67,2 +66,2 @@\n-                    MethodType.methodType(void.class, int.class, CSupport.VaList.class),\n-                    FunctionDescriptor.ofVoid(C_INT, CSupport.C_VA_LIST));\n+                    MethodType.methodType(void.class, int.class, VaList.class),\n+                    FunctionDescriptor.ofVoid(C_INT, C_VA_LIST));\n@@ -82,1 +81,1 @@\n-        try (CSupport.VaList vaList = CSupport.VaList.make(b ->\n+        try (VaList vaList = VaList.make(b ->\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.CSupport;\n@@ -31,1 +30,1 @@\n-import jdk.incubator.foreign.ForeignLinker;\n+import jdk.incubator.foreign.CLinker;\n@@ -37,1 +36,0 @@\n-import static jdk.incubator.foreign.CSupport.*;\n@@ -39,0 +37,1 @@\n+import static jdk.incubator.foreign.CLinker.*;\n@@ -54,1 +53,1 @@\n-            ForeignLinker abi = CSupport.getSystemLinker();\n+            CLinker abi = CLinker.getInstance();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}