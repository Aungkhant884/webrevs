{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.io.IOException;\n@@ -37,1 +36,0 @@\n-import java.nio.file.Path;\n@@ -43,1 +41,0 @@\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -92,2 +89,2 @@\n- * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, MemorySession)}. Such native memory segments are\n- * called <em>mapped memory segments<\/em>; mapped memory segments are associated with an underlying file descriptor.\n+ * {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)}. Such native memory segments are called\n+ * <em>mapped memory segments<\/em>; mapped memory segments are associated with an underlying file descriptor.\n@@ -387,1 +384,1 @@\n-     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode, MemorySession)} factory, or a buffer segment\n+     * created using the {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)} factory, or a buffer segment\n@@ -956,47 +953,0 @@\n-    \/**\n-     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path,\n-     * size, offset and memory session.\n-     * <p>\n-     * If the specified mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, the resulting segment\n-     * will be read-only (see {@link #isReadOnly()}).\n-     * <p>\n-     * The content of a mapped memory segment can change at any time, for example\n-     * if the content of the corresponding region of the mapped file is changed by\n-     * this (or another) program.  Whether such changes occur, and when they\n-     * occur, is operating-system dependent and therefore unspecified.\n-     * <p>\n-     * All or part of a mapped memory segment may become\n-     * inaccessible at any time, for example if the backing mapped file is truncated.  An\n-     * attempt to access an inaccessible region of a mapped memory segment will not\n-     * change the segment's content and will cause an unspecified exception to be\n-     * thrown either at the time of the access or at some later time.  It is\n-     * therefore strongly recommended that appropriate precautions be taken to\n-     * avoid the manipulation of a mapped file by this (or another) program, except to read or write\n-     * the file's content.\n-     *\n-     * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block\n-     * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.\n-     *\n-     * @param path the path to the file to memory map.\n-     * @param bytesOffset the offset (expressed in bytes) within the file at which the mapped segment is to start.\n-     * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.\n-     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the mapping mode\n-     *                might affect the behavior of the returned memory mapped segment (see {@link #force()}).\n-     * @param session the segment memory session.\n-     * @return a new mapped memory segment.\n-     * @throws IllegalArgumentException if {@code bytesOffset < 0}, {@code bytesSize < 0}, or if {@code path} is not associated\n-     * with the default file system.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n-     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n-     * @throws UnsupportedOperationException if an unsupported map mode is specified.\n-     * @throws IOException if the specified path does not point to an existing file, or if some other I\/O error occurs.\n-     * @throws  SecurityException If a security manager is installed, and it denies an unspecified permission required by the implementation.\n-     * In the case of the default provider, the {@link SecurityManager#checkRead(String)} method is invoked to check\n-     * read access if the file is opened for reading. The {@link SecurityManager#checkWrite(String)} method is invoked to check\n-     * write access if the file is opened for writing.\n-     *\/\n-    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, MemorySession session) throws IOException {\n-        Objects.requireNonNull(session);\n-        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode, session);\n-    }\n-\n@@ -1015,1 +965,1 @@\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n@@ -1058,1 +1008,1 @@\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":5,"deletions":55,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- *     <li>closing the memory session associated with a {@linkplain MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, MemorySession) mapped memory segment}\n+ *     <li>closing the memory session associated with a {@linkplain FileChannel#map(FileChannel.MapMode, long, long, MemorySession) mapped memory segment}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n@@ -41,0 +43,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -946,1 +949,1 @@\n-     *         an implementation specific map mode requiring read access\n+     *         an implementation specific map mode requiring read access,\n@@ -950,1 +953,1 @@\n-     *         If the {@code mode} is {@link MapMode#READ_WRITE READ_WRITE}.\n+     *         If the {@code mode} is {@link MapMode#READ_WRITE READ_WRITE},\n@@ -952,1 +955,1 @@\n-     *         map mode requiring write access but this channel was not\n+     *         map mode requiring write access, but this channel was not\n@@ -970,0 +973,83 @@\n+    \/**\n+     * Maps a region of this channel's file into a new mapped memory segment,\n+     * with a given offset, size and memory session.\n+     *\n+     * <p> If the specified mapping mode is\n+     * {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, the resulting\n+     * segment will be read-only (see {@link MemorySegment#isReadOnly()}).\n+     *\n+     * <p> The content of a mapped memory segment can change at any time, for\n+     * example if the content of the corresponding region of the mapped file is\n+     * changed by this (or another) program.  Whether such changes occur, and\n+     * when they occur, is operating-system dependent and therefore unspecified.\n+     *\n+     * <p> All or part of a mapped memory segment may become inaccessible at any\n+     * time, for example if the backing mapped file is truncated. An attempt to\n+     * access an inaccessible region of a mapped memory segment will not change\n+     * the segment's content and will cause an unspecified exception to be\n+     * thrown either at the time of the access or at some later time. It is\n+     * therefore strongly recommended that appropriate precautions be taken to\n+     * avoid the manipulation of a mapped file by this (or another) program,\n+     * except to read or write the file's content.\n+     *\n+     * @implNote When obtaining a mapped segment from a newly created file\n+     *           channel, the initialization state of the contents of the block\n+     *           of mapped memory associated with the returned mapped memory\n+     *           segment is unspecified and should not be relied upon.\n+     *\n+     * @param mode\n+     *        The file mapping mode, see\n+     *        {@link FileChannel#map(FileChannel.MapMode, long, long)};\n+     *        the mapping mode might affect the behavior of the returned memory\n+     *        mapped segment (see {@link MemorySegment#force()}).\n+     *\n+     * @param offset\n+     *        The offset (expressed in bytes) within the file at which the\n+     *        mapped segment is to start.\n+     *\n+     * @param size\n+     *        The size (in bytes) of the mapped memory backing the memory\n+     *        segment.\n+\n+     * @param session\n+     *        The segment memory session.\n+     *\n+     * @return A new mapped memory segment.\n+     *\n+     * @throws IllegalArgumentException\n+     *         If {@code offset < 0}, {@code size < 0} or\n+     *         {@code offset + size < 0}.\n+     *\n+     * @throws IllegalStateException\n+     *         If the {@code session} is not\n+     *         {@linkplain MemorySession#isAlive() alive}, or if access occurs\n+     *         from a thread other than the thread\n+     *         {@linkplain MemorySession#ownerThread() owning} the\n+     *         {@code session}.\n+     *\n+     * @throws NonReadableChannelException\n+     *         If the {@code mode} is {@link MapMode#READ_ONLY READ_ONLY} or\n+     *         an implementation specific map mode requiring read access,\n+     *         but this channel was not opened for reading.\n+     *\n+     * @throws NonWritableChannelException\n+     *         If the {@code mode} is {@link MapMode#READ_WRITE READ_WRITE},\n+     *         {@link MapMode#PRIVATE PRIVATE} or an implementation specific\n+     *         map mode requiring write access, but this channel was not\n+     *         opened for both reading and writing.\n+     *\n+     * @throws IOException\n+     *         If some other I\/O error occurs.\n+     *\n+     * @throws UnsupportedOperationException\n+     *         If an unsupported map mode is specified.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    public MemorySegment map(MapMode mode, long offset, long size,\n+                                      MemorySession session)\n+            throws IOException, UnsupportedOperationException\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":89,"deletions":3,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -32,7 +31,0 @@\n-import java.nio.channels.FileChannel;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.OpenOption;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.Objects;\n@@ -40,1 +32,0 @@\n-import jdk.internal.misc.ExtendedMapMode;\n@@ -42,1 +33,0 @@\n-import sun.nio.ch.FileChannelImpl;\n@@ -56,1 +46,1 @@\n-    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemorySession session) {\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemorySession session) {\n@@ -74,1 +64,0 @@\n-\n@@ -107,50 +96,1 @@\n-    \/\/ factories\n-\n-    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, MemorySession session) throws IOException {\n-        Objects.requireNonNull(path);\n-        Objects.requireNonNull(mapMode);\n-        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n-        sessionImpl.checkValidStateSlow();\n-        if (bytesSize < 0) throw new IllegalArgumentException(\"Requested bytes size must be >= 0.\");\n-        if (bytesOffset < 0) throw new IllegalArgumentException(\"Requested bytes offset must be >= 0.\");\n-        FileSystem fs = path.getFileSystem();\n-        if (fs != FileSystems.getDefault() ||\n-                fs.getClass().getModule() != Object.class.getModule()) {\n-            throw new IllegalArgumentException(\"Unsupported file system\");\n-        }\n-        try (FileChannel channelImpl = FileChannel.open(path, openOptions(mapMode))) {\n-            UnmapperProxy unmapperProxy = ((FileChannelImpl)channelImpl).mapInternal(mapMode, bytesOffset, bytesSize);\n-            int modes = DEFAULT_MODES;\n-            if (mapMode == FileChannel.MapMode.READ_ONLY) {\n-                modes |= READ_ONLY;\n-            }\n-            if (unmapperProxy != null) {\n-                AbstractMemorySegmentImpl segment = new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,\n-                        modes, session);\n-                sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-                    @Override\n-                    public void cleanup() {\n-                        unmapperProxy.unmap();\n-                    }\n-                });\n-                return segment;\n-            } else {\n-                return new EmptyMappedMemorySegmentImpl(modes, session);\n-            }\n-        }\n-    }\n-\n-    private static OpenOption[] openOptions(FileChannel.MapMode mapMode) {\n-        if (mapMode == FileChannel.MapMode.READ_ONLY ||\n-            mapMode == ExtendedMapMode.READ_ONLY_SYNC) {\n-            return new OpenOption[] { StandardOpenOption.READ };\n-        } else if (mapMode == FileChannel.MapMode.READ_WRITE ||\n-                   mapMode == FileChannel.MapMode.PRIVATE ||\n-                   mapMode == ExtendedMapMode.READ_WRITE_SYNC) {\n-            return new OpenOption[] { StandardOpenOption.READ, StandardOpenOption.WRITE };\n-        } else {\n-            throw new UnsupportedOperationException(\"Unsupported map mode: \" + mapMode);\n-        }\n-    }\n-\n-    static class EmptyMappedMemorySegmentImpl extends MappedMemorySegmentImpl {\n+    public static class EmptyMappedMemorySegmentImpl extends MappedMemorySegmentImpl {\n@@ -181,1 +121,1 @@\n-    };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":3,"deletions":63,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n@@ -49,0 +51,3 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MappedMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -1053,2 +1058,16 @@\n-    public Unmapper mapInternal(MapMode mode, long position, long size) throws IOException {\n-        boolean isSync = isSync(Objects.requireNonNull(mode, \"Mode is null\"));\n+    private static final int MAP_MEM_SEG_DEFAULT_MODES = 0;\n+    private static final int MAP_MEM_SEG_READ_ONLY = 1;\n+\n+    @Override\n+    public MemorySegment map(MapMode mode, long offset, long size,\n+                             MemorySession session)\n+            throws IOException, UnsupportedOperationException\n+    {\n+        Objects.requireNonNull(mode,\"Mode is null\");\n+        Objects.requireNonNull(session, \"Session is null\");\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        sessionImpl.checkValidStateSlow();\n+        if (offset < 0) throw new IllegalArgumentException(\"Requested bytes offset must be >= 0.\");\n+        if (size < 0) throw new IllegalArgumentException(\"Requested bytes size must be >= 0.\");\n+\n+        boolean isSync = isSync(mode);\n@@ -1056,1 +1075,18 @@\n-        return mapInternal(mode, position, size, prot, isSync);\n+        Unmapper unmapper = mapInternal(mode, offset, size, prot, isSync);\n+        int modes = MAP_MEM_SEG_DEFAULT_MODES;\n+        if (mode == MapMode.READ_ONLY) {\n+            modes |= MAP_MEM_SEG_READ_ONLY;\n+        }\n+        if (unmapper != null) {\n+            AbstractMemorySegmentImpl segment = new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n+                    modes, session);\n+            sessionImpl.addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+                @Override\n+                public void cleanup() {\n+                    unmapper.unmap();\n+                }\n+            });\n+            return segment;\n+        } else {\n+            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(modes, session);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -230,2 +230,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE, session);\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, session);\n@@ -235,2 +236,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY, session);\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(tempPath, StandardOpenOption.READ)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, session);\n@@ -247,1 +249,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n@@ -249,1 +252,1 @@\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), session);\n@@ -254,1 +257,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {\n@@ -256,1 +260,1 @@\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), session);\n@@ -267,4 +271,7 @@\n-        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, MemorySession.openConfined());\n-        assertTrue(segment.isMapped());\n-        segment.session().close();\n-        mappedBufferOp.apply(segment);\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, session);\n+            assertTrue(segment.isMapped());\n+            segment.session().close();\n+            mappedBufferOp.apply(segment);\n+        }\n@@ -283,1 +290,2 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (MemorySession session = MemorySession.openConfined();\n+                 FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n@@ -285,1 +293,1 @@\n-                MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, session);\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), session);\n@@ -293,1 +301,2 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (MemorySession session = MemorySession.openConfined();\n+                 FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {\n@@ -295,1 +304,1 @@\n-                MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, session);\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), session);\n@@ -313,2 +322,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, LARGE_SIZE, FileChannel.MapMode.READ_WRITE, session);\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, session);\n@@ -490,1 +500,3 @@\n-        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, MemorySession.openImplicit());\n+        try (FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, MemorySession.openImplicit());\n+        }\n@@ -498,1 +510,3 @@\n-        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, MemorySession.openImplicit());\n+        try (FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, MemorySession.openImplicit());\n+        }\n@@ -509,2 +523,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, SIZE, FileChannel.MapMode.READ_WRITE, session);\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, session);\n@@ -518,2 +533,3 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n-                MemorySegment segment = MemorySegment.mapFile(f.toPath(), offset, SIZE - offset, FileChannel.MapMode.READ_ONLY, session);\n+            try (MemorySession session = MemorySession.openConfined();\n+                 FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, session);\n@@ -531,2 +547,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE, session);\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, session);\n@@ -542,2 +559,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_ONLY, session);\n+        try (MemorySession session = MemorySession.openConfined();\n+             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, session);\n@@ -554,1 +572,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n@@ -557,1 +575,3 @@\n-        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, MemorySession.openImplicit());\n+        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, MemorySession.openImplicit());\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":50,"deletions":30,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -116,2 +117,2 @@\n-            try {\n-                MemorySegment.mapFile(tempPath, 0, 10, FileChannel.MapMode.READ_WRITE, session);\n+            try (FileChannel fileChannel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 10L, session);\n@@ -121,1 +122,1 @@\n-        }, \"MemorySegment::mapFromFile\");\n+        }, \"FileChannel::map\");\n@@ -224,2 +225,2 @@\n-                try {\n-                    return MemorySegment.mapFile(Path.of(\"foo.txt\"), 0, 10, FileChannel.MapMode.READ_WRITE, session);\n+                try (FileChannel fileChannel = FileChannel.open(Path.of(\"foo.txt\"), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                    return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 10L, session);\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-                    try {\n-                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, MemorySession.openConfined());\n+                    try (FileChannel fileChannel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, MemorySession.openConfined());\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @enablePreview\n+ * @bug 8281412\n+ * @summary Test FileChannel::map to MemorySegment with custom file channel\n+ * @run testng\/othervm MapToMemorySegmentTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.FileLock;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class MapToMemorySegmentTest {\n+\n+    static Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"foo\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testCustomFileChannel() throws IOException {\n+        var session = MemorySession.openConfined();\n+        var fc = FileChannel.open(tempPath, StandardOpenOption.WRITE, StandardOpenOption.READ);\n+        var fileChannel = new CustomFileChannel(fc);\n+        try (session; fileChannel){\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, session);\n+        }\n+    }\n+\n+    @Test\n+    public void testCustomFileChannelOverride() throws IOException {\n+        var session = MemorySession.openConfined();\n+        var fc = FileChannel.open(tempPath, StandardOpenOption.WRITE, StandardOpenOption.READ);\n+        var fileChannel = new CustomFileChannelOverride(fc);\n+        try (session; fileChannel){\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, session);\n+        }\n+    }\n+\n+    static class CustomFileChannel extends FileChannel {\n+        FileChannel fc;\n+\n+        public CustomFileChannel(FileChannel fc) {\n+            this.fc = fc;\n+        }\n+\n+        public int read(ByteBuffer dst) throws IOException {\n+            return fc.read(dst);\n+        }\n+\n+        public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+            return fc.read(dsts, offset, length);\n+        }\n+\n+        public int write(ByteBuffer src) throws IOException {\n+            return fc.write(src);\n+        }\n+\n+        public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+            return fc.write(srcs, offset, length);\n+        }\n+\n+        public long position() throws IOException {\n+            return fc.position();\n+        }\n+\n+        public FileChannel position(long newPosition) throws IOException {\n+            return fc.position(newPosition);\n+        }\n+\n+        public long size() throws IOException {\n+            return fc.size();\n+        }\n+\n+        public FileChannel truncate(long size) throws IOException {\n+            return fc.truncate(size);\n+        }\n+\n+        public void force(boolean metaData) throws IOException {\n+            this.fc.force(metaData);\n+        }\n+\n+        public long transferTo(long position, long count, WritableByteChannel target) throws IOException {\n+            return fc.transferTo(position, count, target);\n+        }\n+\n+        public long transferFrom(ReadableByteChannel src, long position, long count) throws IOException {\n+            return fc.transferFrom(src, position, count);\n+        }\n+\n+        public int read(ByteBuffer dst, long position) throws IOException {\n+            return fc.read(dst, position);\n+        }\n+\n+        public int write(ByteBuffer src, long position) throws IOException {\n+            return fc.write(src, position);\n+        }\n+\n+        public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException {\n+            return fc.map(mode, position, size);\n+        }\n+\n+        public FileLock lock(long position, long size, boolean shared) throws IOException {\n+            return fc.lock(position, size, shared);\n+        }\n+\n+        public FileLock tryLock(long position, long size, boolean shared) throws IOException {\n+            return fc.tryLock(position , size, shared);\n+        }\n+\n+        protected void implCloseChannel() throws IOException {\n+            fc.close();\n+        }\n+    }\n+\n+    static class CustomFileChannelOverride extends CustomFileChannel {\n+\n+        public CustomFileChannelOverride(FileChannel fc) { super(fc); }\n+\n+        @Override\n+        public MemorySegment map(MapMode mode, long offset, long size, MemorySession session)\n+                throws IOException, UnsupportedOperationException\n+        {\n+            return fc.map(mode, offset, size, session);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapToMemorySegmentTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -84,0 +84,1 @@\n+    FileChannel fileChannel;\n@@ -98,1 +99,2 @@\n-        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE, MemorySession.openConfined());\n+        fileChannel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE);\n+        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, MemorySession.openConfined());\n@@ -103,1 +105,2 @@\n-    public void tearDown() {\n+    public void tearDown() throws IOException {\n+        fileChannel.close();\n@@ -191,1 +194,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}