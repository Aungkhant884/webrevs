{"files":[{"patch":"@@ -140,3 +140,7 @@\n-    \/\/Todo: fixme\n-    ValueLayout bitfield(ValueLayout v, List<MemoryLayout> sublayouts) {\n-        return Utils.addContents(v, MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));\n+    ValueLayout bitfield(ValueLayout container, List<MemoryLayout> sublayouts) {\n+        return Utils.addContents(container, MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));\n+    }\n+\n+    ValueLayout bitfield(long containerSize, List<MemoryLayout> sublayouts) {\n+        return bitfield((ValueLayout)LayoutUtils.valueLayoutForSize(containerSize)\n+                        .layout().orElseThrow(() -> new IllegalStateException(\"Unsupported size: \" + containerSize)), sublayouts);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/RecordLayoutComputer.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -139,5 +139,0 @@\n-    private String structName() {\n-        String name = type.spelling();\n-        return name.isEmpty()? \"struct <anonymous>\" : name;\n-    }\n-\n@@ -145,1 +140,0 @@\n-        long storageSize = storageSize(layouts);\n@@ -150,7 +144,0 @@\n-            MemoryLayout padding = null;\n-            if (l.isPadding() && (offset + l.bitSize() > storageSize)) {\n-                \/\/ split padding\n-                long delta = storageSize - offset;\n-                padding = MemoryLayout.ofPaddingBits(l.bitSize() - delta);\n-                l = MemoryLayout.ofPaddingBits(delta);\n-            }\n@@ -158,0 +145,3 @@\n+            if (offset > MAX_STORAGE_SIZE) {\n+                throw new IllegalStateException(\"Crossing storage unit boundaries\");\n+            }\n@@ -159,1 +149,2 @@\n-            if (!pendingFields.isEmpty() && offset == storageSize) {\n+            long storageSize = storageSize(offset);\n+            if (!pendingFields.isEmpty() && storageSize != -1) {\n@@ -161,4 +152,1 @@\n-                newFields.add(bitfield(\n-                        (ValueLayout)LayoutUtils.valueLayoutForSize(storageSize)\n-                                .layout().orElseThrow(() -> new IllegalStateException(\"Unsupported size: \" + storageSize)),\n-                        pendingFields));\n+                newFields.add(bitfield(storageSize, pendingFields));\n@@ -167,6 +155,0 @@\n-            } else if (offset > storageSize) {\n-                throw new IllegalStateException(\"Crossing storage unit boundaries: \" + structName());\n-            }\n-            if (padding != null) {\n-                newFields.add(padding);\n-                offset += padding.bitSize();\n@@ -176,1 +158,4 @@\n-            throw new IllegalStateException(\"Partially used storage unit: \" + structName());\n+            long storageSize = nextStorageSize(offset);\n+            \/\/emit new\n+            newFields.add(bitfield(storageSize, pendingFields));\n+            pendingFields.clear();\n@@ -181,5 +166,8 @@\n-    private long storageSize(List<MemoryLayout> layouts) {\n-        long size = layouts.stream().mapToLong(MemoryLayout::bitSize).sum();\n-        int[] sizes = { 64, 32, 16, 8 };\n-        for (int s : sizes) {\n-            if (size % s == 0) {\n+    static int[] STORAGE_SIZES = { 64, 32, 16, 8 };\n+    static int[] ALIGN_SIZES = { 8, 16, 32, 64 };\n+    static int MAX_STORAGE_SIZE = 64;\n+\n+    private long storageSize(long size) {\n+        \/\/ offset should be < MAX_STORAGE_SIZE\n+        for (int s : STORAGE_SIZES) {\n+            if (size == s) {\n@@ -189,1 +177,17 @@\n-        throw new IllegalStateException(\"Cannot infer storage size:\" + structName());\n+        return -1;\n+    }\n+\n+    private long nextStorageSize(long size) {\n+        \/\/ offset should be < MAX_STORAGE_SIZE\n+        for (int s : ALIGN_SIZES) {\n+            long alignedSize = alignUp(size, s);\n+            long storageSize = storageSize(alignedSize);\n+            if (storageSize != -1) {\n+                return storageSize;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private static long alignUp(long n, long alignment) {\n+        return (n + alignment - 1) & -alignment;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructLayoutComputer.java","additions":35,"deletions":31,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260929\n+ * @summary jextract crashes with Crossing storage unit boundaries\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8261578\n+ *\/\n+public class Test8261578 extends JextractToolRunner {\n+    @Test\n+    public void test1() {\n+        Path outputPath = getOutputFilePath(\"output_1\");\n+        Path headerFile = getInputFilePath(\"test8261578_1.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> ndpi_class = loader.loadClass(\"test8261578_1_h$ndpi_flow_tcp_struct\");\n+            assertNotNull(ndpi_class);\n+\n+            checkMethod(ndpi_class, \"gnutella_msg_id$slice\", MemorySegment.class, MemorySegment.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test2() {\n+        Path outputPath = getOutputFilePath(\"output_2\");\n+        Path headerFile = getInputFilePath(\"test8261578_2.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> foo_class = loader.loadClass(\"test8261578_2_h$foo\");\n+            assertNotNull(foo_class);\n+\n+            checkMethod(foo_class, \"clear_color$slice\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$get\", int.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(foo_class, \"clear_s$get\", byte.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_s$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test3() {\n+        Path outputPath = getOutputFilePath(\"output_3\");\n+        Path headerFile = getInputFilePath(\"test8261578_3.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> plugin_class = loader.loadClass(\"test8261578_3_h$PluginCodec_H323AudioG7231AnnexC\");\n+            assertNotNull(plugin_class);\n+\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$get\", byte.class, MemorySegment.class);\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/Test8261578.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct ndpi_flow_tcp_struct {\n+  char gnutella_msg_id[3];\n+  int irc_3a_counter:3;\n+  int irc_stage2:5;\n+  int irc_direction:2;\n+  int irc_0x1000_full:1;\n+  int soulseek_stage:2;\n+  int filetopia_stage:2;\n+  int tds_stage:3;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_1.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct foo {\n+   int clear_color[2];\n+   int clear_z;\n+   char clear_s;\n+   int pad:24;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_2.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct PluginCodec_H323AudioG7231AnnexC {\n+  unsigned char maxAl_sduAudioFrames;\n+  int silenceSuppression:1;\n+  int highRateMode0:6; \/\/ INTEGER (27..78), -- units octets\n+  int highRateMode1:6; \/\/ INTEGER (27..78), -- units octets\n+  int lowRateMode0:6; \/\/ INTEGER (23..66), -- units octets\n+  int lowRateMode1:6; \/\/ INTEGER (23..66), -- units octets\n+  int sidMode0:4; \/\/ INTEGER (6..17), -- units octets\n+  int sidMode1:4; \/\/ INTEGER (6..17), -- units octets\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_3.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"}]}