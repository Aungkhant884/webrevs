{"files":[{"patch":"@@ -26,0 +26,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +32,11 @@\n+=======\n+GENSRC_SCOPED_MEMORY_ACCESS :=\n+\n+\n+SCOPED_MEMORY_ACCESS_GENSRC_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/misc\n+SCOPED_MEMORY_ACCESS_SRC_DIR := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\n+\n+SCOPED_MEMORY_ACCESS_TEMPLATE := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template\n+SCOPED_MEMORY_ACCESS_BIN_TEMPLATE := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template\n+DEST := $(SCOPED_MEMORY_ACCESS_GENSRC_DIR)\/ScopedMemoryAccess.java\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -143,0 +155,1 @@\n+<<<<<<< HEAD\n@@ -152,0 +165,11 @@\n+=======\n+$(DEST): $(BUILD_TOOLS_JDK) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE)\n+\t$(MKDIR) -p $(SCOPED_MEMORY_ACCESS_GENSRC_DIR)\n+\t$(CP) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(DEST)\n+\t$(foreach t, $(SCOPE_MEMORY_ACCESS_TYPES), \\\n+\t\t$(TOOL_SPP) -nel -K$(BIN_$t_type) -Dtype=$(BIN_$t_type) -DType=$(BIN_$t_Type) $(BIN_$t_ARGS) \\\n+\t\t-i$(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE) -o$(DEST) ;)\n+\t$(PRINTF) \"}\\n\" >> $(DEST)\n+\t\n+TARGETS += $(DEST)\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"make\/modules\/java.base\/gensrc\/GensrcScopedMemoryAccess.gmk","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -306,0 +306,1 @@\n+<<<<<<< HEAD\n@@ -307,0 +308,3 @@\n+=======\n+  template(jdk_internal_misc_Scoped_signature,    \"Ljdk\/internal\/misc\/ScopedMemoryAccess$Scoped;\") \\\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+<<<<<<< HEAD\n@@ -24,0 +25,2 @@\n+=======\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -104,0 +107,1 @@\n+<<<<<<< HEAD\n@@ -111,0 +115,11 @@\n+=======\n+      \/\/FIXME: this doesn't work if reachability fences are violated by C2\n+      \/\/ last_frame.oops_do(&cl, NULL, &register_map);\n+\n+      \/\/ if (cl.found()) {\n+      \/\/   \/\/ Found the deopt oop in a compiled method; deoptimize.\n+      \/\/   Deoptimization::deoptimize(jt, last_frame);\n+      \/\/ }\n+\n+      \/\/ so... we unconditionally deoptimize, for now\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -116,0 +131,1 @@\n+<<<<<<< HEAD\n@@ -117,0 +133,4 @@\n+=======\n+    vframeStream stream(jt);\n+    for (; !stream.at_end(); stream.next()) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -150,0 +170,1 @@\n+<<<<<<< HEAD\n@@ -163,0 +184,15 @@\n+=======\n+JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception)) {\n+  CloseScopedMemoryClosure cl(deopt, exception);\n+  Handshake::execute(&cl);\n+  return !cl._found;\n+} JVM_END\n+\n+\/\/\/ JVM_RegisterUnsafeMethods\n+\n+#define LANG \"Ljdk\/internal\/misc\/\"\n+\n+#define MEMACCESS \"ScopedMemoryAccess\"\n+#define SCOPE LANG MEMACCESS \"$Scope;\"\n+#define SCOPED_ERR LANG MEMACCESS \"$Scope$ScopedAccessError;\"\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -174,0 +210,1 @@\n+<<<<<<< HEAD\n@@ -175,0 +212,3 @@\n+=======\n+#undef LANG\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -181,0 +221,1 @@\n+<<<<<<< HEAD\n@@ -182,0 +223,3 @@\n+=======\n+JVM_ENTRY(void, JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jclass scopedMemoryAccessClass)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -186,0 +230,1 @@\n+<<<<<<< HEAD\n@@ -187,0 +232,3 @@\n+=======\n+} JVM_END\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+<<<<<<< HEAD\n@@ -48,0 +49,5 @@\n+=======\n+    MemoryAccessVarHandleBase(VarForm form, boolean skipOffetCheck, boolean be, long length, long alignmentMask) {\n+        super(form);\n+        this.skipAlignmentMaskCheck = skipOffetCheck;\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+<<<<<<< HEAD\n@@ -346,0 +347,17 @@\n+=======\n+\n+        if (carrier == byte.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleByteHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == char.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleCharHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == short.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleShortHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == int.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleIntHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == float.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleFloatHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == long.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleLongHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+        } else if (carrier == double.class) {\n+            return maybeAdapt(new MemoryAccessVarHandleDoubleHelper(skipAlignmentMaskCheck, be, size, alignmentMask));\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +71,9 @@\n+=======\n+    MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask) {\n+        super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask);\n+    }\n+\n+    @Override\n+    final MethodType accessModeTypeUncached(AccessMode accessMode) {\n+        return accessMode.at.accessModeType(MemorySegmentProxy.class, $type$.class, long.class);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -493,0 +493,1 @@\n+<<<<<<< HEAD\n@@ -496,0 +497,7 @@\n+=======\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, src,\n+                                      srcOffset,\n+                                      null,\n+                                      ix(index),\n+                                      (long)length << $LG_BYTES_PER_VALUE$);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -515,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -517,0 +526,3 @@\n+=======\n+            SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null, ix(pos), null, ix(0), (long)rem << $LG_BYTES_PER_VALUE$);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+<<<<<<< HEAD\n@@ -92,0 +93,3 @@\n+=======\n+    static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1048,0 +1048,1 @@\n+<<<<<<< HEAD\n@@ -1051,0 +1052,7 @@\n+=======\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), src.scope(), srcBase,\n+                                      srcAddr,\n+                                      base,\n+                                      addr,\n+                                      len);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1058,0 +1066,1 @@\n+<<<<<<< HEAD\n@@ -1061,0 +1070,8 @@\n+=======\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), src.scope(), srcBase,\n+                                          srcAddr,\n+                                          base,\n+                                          addr,\n+                                          len,\n+                                          (long)1 << $LG_BYTES_PER_VALUE$);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+<<<<<<< HEAD\n@@ -53,0 +54,3 @@\n+=======\n+ * This class provides tools to manages races when multiple threads are accessing and\/or releasing the same memory\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -102,0 +106,1 @@\n+<<<<<<< HEAD\n@@ -104,0 +109,2 @@\n+=======\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+<<<<<<< HEAD\n@@ -48,0 +49,3 @@\n+=======\n+ * The behavior of the methods in this class is highly platform-dependent; as a result, calling these methods might\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -77,0 +81,1 @@\n+<<<<<<< HEAD\n@@ -78,0 +83,3 @@\n+=======\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -96,0 +104,1 @@\n+<<<<<<< HEAD\n@@ -97,0 +106,3 @@\n+=======\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -115,0 +127,1 @@\n+<<<<<<< HEAD\n@@ -116,0 +129,3 @@\n+=======\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -123,0 +139,1 @@\n+<<<<<<< HEAD\n@@ -124,0 +141,3 @@\n+=======\n+     * storage device described by the segment's file descriptor (see {@link MemorySegment#fileDescriptor()}).\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -147,0 +167,1 @@\n+<<<<<<< HEAD\n@@ -148,0 +169,3 @@\n+=======\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+<<<<<<< HEAD\n@@ -52,0 +53,14 @@\n+=======\n+ * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long)}) take a segment and an offset (expressed in bytes).\n+ * The final address at which the dereference will occur will be computed by offsetting the base address by\n+ * the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n+ * <p>\n+ * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment)}) so that\n+ * clients can omit the offset coordinate.\n+ * <p>\n+ * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n+ * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long)}),\n+ * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n+ * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n+ * be dereferenced.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -59,0 +74,1 @@\n+<<<<<<< HEAD\n@@ -72,0 +88,16 @@\n+=======\n+    private static final VarHandle byte_LE_handle = indexedHandle(MemoryLayouts.BITS_8_LE, byte.class);\n+    private static final VarHandle char_LE_handle = indexedHandle(MemoryLayouts.BITS_16_LE, char.class);\n+    private static final VarHandle short_LE_handle = indexedHandle(MemoryLayouts.BITS_16_LE, short.class);\n+    private static final VarHandle int_LE_handle = indexedHandle(MemoryLayouts.BITS_32_LE, int.class);\n+    private static final VarHandle float_LE_handle = indexedHandle(MemoryLayouts.BITS_32_LE, float.class);\n+    private static final VarHandle long_LE_handle = indexedHandle(MemoryLayouts.BITS_64_LE, long.class);\n+    private static final VarHandle double_LE_handle = indexedHandle(MemoryLayouts.BITS_64_LE, double.class);\n+    private static final VarHandle byte_BE_handle = indexedHandle(MemoryLayouts.BITS_8_BE, byte.class);\n+    private static final VarHandle char_BE_handle = indexedHandle(MemoryLayouts.BITS_16_BE, char.class);\n+    private static final VarHandle short_BE_handle = indexedHandle(MemoryLayouts.BITS_16_BE, short.class);\n+    private static final VarHandle int_BE_handle = indexedHandle(MemoryLayouts.BITS_32_BE, int.class);\n+    private static final VarHandle float_BE_handle = indexedHandle(MemoryLayouts.BITS_32_BE, float.class);\n+    private static final VarHandle long_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, long.class);\n+    private static final VarHandle double_BE_handle = indexedHandle(MemoryLayouts.BITS_64_BE, double.class);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -80,0 +112,1 @@\n+<<<<<<< HEAD\n@@ -84,1 +117,2 @@\n-        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());\n+=======\n+        address_handle = MemoryHandles.asAddressVarHandle(indexedHandle(MemoryLayouts.ADDRESS, carrier));\n@@ -88,1 +122,7 @@\n-     * Reads a byte from given segment and offset.\n+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);\n+    byte value = (byte)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n@@ -91,1 +131,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -94,2 +134,2 @@\n-    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n-        return (byte)byte_handle.get(segment, offset);\n+    public static byte getByteAtOffset_LE(MemorySegment segment, long offset) {\n+        return (byte)byte_LE_handle.get(segment, offset);\n@@ -99,2 +139,7 @@\n-     * Writes a byte at given segment and offset.\n-     *\n+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.withStride(BITS_8_LE.withBitAlignment(8).varHandle(byte.class), 1L);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n@@ -102,1 +147,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -105,2 +150,2 @@\n-    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n-        byte_handle.set(segment, offset, value);\n+    public static void setByteAtOffset_LE(MemorySegment segment, long offset, byte value) {\n+        byte_LE_handle.set(segment, offset, value);\n@@ -110,1 +155,1 @@\n-     * Reads a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -114,1 +159,2 @@\n-    getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);\n+    char value = (char)handle.get(segment, offset);\n@@ -117,1 +163,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -120,2 +166,2 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset) {\n-        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static char getCharAtOffset_LE(MemorySegment segment, long offset) {\n+        return (char)char_LE_handle.get(segment, offset);\n@@ -125,1 +171,1 @@\n-     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -129,1 +175,2 @@\n-    setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(char.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -132,1 +179,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -135,2 +182,2 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n-        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setCharAtOffset_LE(MemorySegment segment, long offset, char value) {\n+        char_LE_handle.set(segment, offset, value);\n@@ -140,1 +187,1 @@\n-     * Reads a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -144,1 +191,2 @@\n-    getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);\n+    short value = (short)handle.get(segment, offset);\n@@ -147,1 +195,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -150,2 +198,2 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset) {\n-        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static short getShortAtOffset_LE(MemorySegment segment, long offset) {\n+        return (short)short_LE_handle.get(segment, offset);\n@@ -155,1 +203,1 @@\n-     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -159,1 +207,2 @@\n-    setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_LE.withBitAlignment(8).varHandle(short.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -162,1 +211,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -165,2 +214,2 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n-        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setShortAtOffset_LE(MemorySegment segment, long offset, short value) {\n+        short_LE_handle.set(segment, offset, value);\n@@ -170,1 +219,1 @@\n-     * Reads an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -174,1 +223,2 @@\n-    getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);\n+    int value = (int)handle.get(segment, offset);\n@@ -177,1 +227,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -180,2 +230,2 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset) {\n-        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static int getIntAtOffset_LE(MemorySegment segment, long offset) {\n+        return (int)int_LE_handle.get(segment, offset);\n@@ -185,1 +235,1 @@\n-     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -189,1 +239,2 @@\n-    setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(int.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -192,1 +243,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -195,2 +246,2 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n-        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setIntAtOffset_LE(MemorySegment segment, long offset, int value) {\n+        int_LE_handle.set(segment, offset, value);\n@@ -200,1 +251,1 @@\n-     * Reads a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -204,1 +255,2 @@\n-    getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);\n+    float value = (float)handle.get(segment, offset);\n@@ -207,1 +259,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -210,2 +262,2 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n-        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static float getFloatAtOffset_LE(MemorySegment segment, long offset) {\n+        return (float)float_LE_handle.get(segment, offset);\n@@ -215,1 +267,1 @@\n-     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -219,1 +271,2 @@\n-    setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_LE.withBitAlignment(8).varHandle(float.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -222,1 +275,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -225,2 +278,2 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n-        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setFloatAtOffset_LE(MemorySegment segment, long offset, float value) {\n+        float_LE_handle.set(segment, offset, value);\n@@ -230,1 +283,1 @@\n-     * Reads a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -234,1 +287,2 @@\n-    getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);\n+    long value = (long)handle.get(segment, offset);\n@@ -237,1 +291,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -240,2 +294,2 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset) {\n-        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static long getLongAtOffset_LE(MemorySegment segment, long offset) {\n+        return (long)long_LE_handle.get(segment, offset);\n@@ -245,1 +299,1 @@\n-     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -249,1 +303,2 @@\n-    setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(long.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -252,1 +307,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -255,2 +310,2 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n-        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setLongAtOffset_LE(MemorySegment segment, long offset, long value) {\n+        long_LE_handle.set(segment, offset, value);\n@@ -260,1 +315,1 @@\n-     * Reads a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -264,1 +319,2 @@\n-    getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);\n+    double value = (double)handle.get(segment, offset);\n@@ -267,1 +323,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -270,2 +326,2 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n-        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static double getDoubleAtOffset_LE(MemorySegment segment, long offset) {\n+        return (double)double_LE_handle.get(segment, offset);\n@@ -275,1 +331,1 @@\n-     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n@@ -279,1 +335,2 @@\n-    setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_LE.withBitAlignment(8).varHandle(double.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -282,1 +339,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -285,2 +342,2 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n-        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setDoubleAtOffset_LE(MemorySegment segment, long offset, double value) {\n+        double_LE_handle.set(segment, offset, value);\n@@ -290,1 +347,1 @@\n-     * Reads a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -292,1 +349,1 @@\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n+     * This is equivalent to the following code:\n@@ -294,2 +351,2 @@\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);\n+    VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);\n+    byte value = (byte)handle.get(segment, offset);\n@@ -297,0 +354,1 @@\n+     *\n@@ -298,2 +356,2 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a memory address read from {@code segment}.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a byte value read from {@code segment}.\n@@ -301,2 +359,2 @@\n-    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n-        return (MemoryAddress)address_handle.get(segment, offset);\n+    public static byte getByteAtOffset_BE(MemorySegment segment, long offset) {\n+        return (byte)byte_BE_handle.get(segment, offset);\n@@ -306,1 +364,1 @@\n-     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -308,1 +366,1 @@\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n+     * This is equivalent to the following code:\n@@ -310,2 +368,2 @@\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    handle.set(segment, offset, value.address());\n+    VarHandle handle = MemoryHandles.withStride(BITS_8_BE.withBitAlignment(8).varHandle(byte.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -314,2 +372,2 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the byte value to be written.\n@@ -317,2 +375,2 @@\n-    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n-        address_handle.set(segment, offset, value.address());\n+    public static void setByteAtOffset_BE(MemorySegment segment, long offset, byte value) {\n+        byte_BE_handle.set(segment, offset, value);\n@@ -322,1 +380,1 @@\n-     * Reads a char from given segment and offset with given byte order.\n+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -326,1 +384,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);\n@@ -330,2 +388,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -334,2 +391,2 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        return (char)((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);\n+    public static char getCharAtOffset_BE(MemorySegment segment, long offset) {\n+        return (char)char_BE_handle.get(segment, offset);\n@@ -339,1 +396,1 @@\n-     * Writes a char at given segment and offset with given byte order.\n+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -343,1 +400,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(char.class), 1L);\n@@ -347,2 +404,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -351,2 +407,2 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n-        ((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);\n+    public static void setCharAtOffset_BE(MemorySegment segment, long offset, char value) {\n+        char_BE_handle.set(segment, offset, value);\n@@ -356,1 +412,1 @@\n-     * Reads a short from given segment and offset with given byte order.\n+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -360,1 +416,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);\n@@ -364,2 +420,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -368,2 +423,2 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        return (short)((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);\n+    public static short getShortAtOffset_BE(MemorySegment segment, long offset) {\n+        return (short)short_BE_handle.get(segment, offset);\n@@ -373,1 +428,1 @@\n-     * Writes a short at given segment and offset with given byte order.\n+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -377,1 +432,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_16_BE.withBitAlignment(8).varHandle(short.class), 1L);\n@@ -381,2 +436,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -385,2 +439,2 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n-        ((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);\n+    public static void setShortAtOffset_BE(MemorySegment segment, long offset, short value) {\n+        short_BE_handle.set(segment, offset, value);\n@@ -390,1 +444,1 @@\n-     * Reads an int from given segment and offset with given byte order.\n+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -394,1 +448,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);\n@@ -398,2 +452,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -402,2 +455,2 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        return (int)((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);\n+    public static int getIntAtOffset_BE(MemorySegment segment, long offset) {\n+        return (int)int_BE_handle.get(segment, offset);\n@@ -407,1 +460,1 @@\n-     * Writes an int at given segment and offset with given byte order.\n+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -411,1 +464,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(int.class), 1L);\n@@ -415,2 +468,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -419,2 +471,2 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n-        ((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);\n+    public static void setIntAtOffset_BE(MemorySegment segment, long offset, int value) {\n+        int_BE_handle.set(segment, offset, value);\n@@ -424,1 +476,1 @@\n-     * Reads a float from given segment and offset with given byte order.\n+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -428,1 +480,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);\n@@ -432,2 +484,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -436,2 +487,2 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        return (float)((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);\n+    public static float getFloatAtOffset_BE(MemorySegment segment, long offset) {\n+        return (float)float_BE_handle.get(segment, offset);\n@@ -441,1 +492,1 @@\n-     * Writes a float at given segment and offset with given byte order.\n+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -445,1 +496,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_32_BE.withBitAlignment(8).varHandle(float.class), 1L);\n@@ -449,2 +500,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -453,2 +503,2 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n-        ((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);\n+    public static void setFloatAtOffset_BE(MemorySegment segment, long offset, float value) {\n+        float_BE_handle.set(segment, offset, value);\n@@ -458,1 +508,1 @@\n-     * Reads a long from given segment and offset with given byte order.\n+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -462,1 +512,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);\n@@ -466,2 +516,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -470,2 +519,2 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        return (long)((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);\n+    public static long getLongAtOffset_BE(MemorySegment segment, long offset) {\n+        return (long)long_BE_handle.get(segment, offset);\n@@ -475,1 +524,1 @@\n-     * Writes a long at given segment and offset with given byte order.\n+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -479,1 +528,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(long.class), 1L);\n@@ -483,2 +532,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -487,2 +535,2 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n-        ((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);\n+    public static void setLongAtOffset_BE(MemorySegment segment, long offset, long value) {\n+        long_BE_handle.set(segment, offset, value);\n@@ -492,1 +540,1 @@\n-     * Reads a double from given segment and offset with given byte order.\n+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -496,1 +544,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);\n@@ -500,2 +548,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -504,2 +551,2 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        return (double)((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);\n+    public static double getDoubleAtOffset_BE(MemorySegment segment, long offset) {\n+        return (double)double_BE_handle.get(segment, offset);\n@@ -509,1 +556,1 @@\n-     * Writes a double at given segment and offset with given byte order.\n+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -513,1 +560,1 @@\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n+    VarHandle handle = MemoryHandles.withStride(BITS_64_BE.withBitAlignment(8).varHandle(double.class), 1L);\n@@ -517,2 +564,1 @@\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -521,2 +567,2 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n-        ((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);\n+    public static void setDoubleAtOffset_BE(MemorySegment segment, long offset, double value) {\n+        double_BE_handle.set(segment, offset, value);\n@@ -526,1 +572,1 @@\n-     * Reads a byte from given segment.\n+     * Read a byte from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -530,1 +576,2 @@\n-    byte value = getByteAtOffset(segment, 0L);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);\n+    byte value = (byte)handle.get(segment, offset);\n@@ -534,0 +581,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -536,2 +584,2 @@\n-    public static byte getByte(MemorySegment segment) {\n-        return getByteAtOffset(segment, 0L);\n+    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n+        return (byte)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).get(segment, offset);\n@@ -541,1 +589,1 @@\n-     * Writes a byte at given segment.\n+     * Writes a byte at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -545,1 +593,2 @@\n-    setByteAtOffset(segment, 0L, value);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_BYTE.withBitAlignment(8).varHandle(byte.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -548,0 +597,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -550,2 +600,2 @@\n-    public static void setByte(MemorySegment segment, byte value) {\n-        setByteAtOffset(segment, 0L, value);\n+    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? byte_BE_handle : byte_LE_handle).set(segment, offset, value);\n@@ -555,1 +605,1 @@\n-     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -559,1 +609,2 @@\n-    char value = getCharAtOffset(segment, 0L);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);\n+    char value = (char)handle.get(segment, offset);\n@@ -562,0 +613,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -564,2 +616,2 @@\n-    public static char getChar(MemorySegment segment) {\n-        return getCharAtOffset(segment, 0L);\n+    public static char getCharAtOffset(MemorySegment segment, long offset) {\n+        return (char)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);\n@@ -569,1 +621,1 @@\n-     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -573,1 +625,2 @@\n-    setCharAtOffset(segment, 0L, value);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_CHAR.withBitAlignment(8).varHandle(char.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -576,0 +629,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -578,2 +632,2 @@\n-    public static void setChar(MemorySegment segment, char value) {\n-        setCharAtOffset(segment, 0L, value);\n+    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);\n@@ -583,1 +637,1 @@\n-     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -587,1 +641,2 @@\n-    short value = getShortAtOffset(segment, 0L);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);\n+    short value = (short)handle.get(segment, offset);\n@@ -590,0 +645,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -592,2 +648,2 @@\n-    public static short getShort(MemorySegment segment) {\n-        return getShortAtOffset(segment, 0L);\n+    public static short getShortAtOffset(MemorySegment segment, long offset) {\n+        return (short)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);\n@@ -597,1 +653,1 @@\n-     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -601,1 +657,2 @@\n-    setShortAtOffset(segment, 0L, value);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_SHORT.withBitAlignment(8).varHandle(short.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -604,0 +661,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -606,2 +664,2 @@\n-    public static void setShort(MemorySegment segment, short value) {\n-        setShortAtOffset(segment, 0L, value);\n+    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);\n@@ -611,1 +669,1 @@\n-     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -615,1 +673,2 @@\n-    int value = getIntAtOffset(segment, 0L);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);\n+    int value = (int)handle.get(segment, offset);\n@@ -618,0 +677,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -620,2 +680,2 @@\n-    public static int getInt(MemorySegment segment) {\n-        return getIntAtOffset(segment, 0L);\n+    public static int getIntAtOffset(MemorySegment segment, long offset) {\n+        return (int)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);\n@@ -625,1 +685,1 @@\n-     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -629,1 +689,2 @@\n-    setIntAtOffset(segment, 0L, value);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_INT.withBitAlignment(8).varHandle(int.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -632,0 +693,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -634,2 +696,2 @@\n-    public static void setInt(MemorySegment segment, int value) {\n-        setIntAtOffset(segment, 0L, value);\n+    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);\n@@ -639,1 +701,1 @@\n-     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -643,1 +705,2 @@\n-    float value = getFloatAtOffset(segment, 0L);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);\n+    float value = (float)handle.get(segment, offset);\n@@ -646,0 +709,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -648,2 +712,2 @@\n-    public static float getFloat(MemorySegment segment) {\n-        return getFloatAtOffset(segment, 0L);\n+    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n+        return (float)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);\n@@ -653,1 +717,1 @@\n-     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -657,1 +721,2 @@\n-    setFloatAtOffset(segment, 0L, value);\n+    VarHandle handle = MemoryHandles.withStride(JAVA_FLOAT.withBitAlignment(8).varHandle(float.class), 1L);\n+    handle.set(segment, offset, value);\n@@ -660,0 +725,1 @@\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n@@ -662,2 +728,2 @@\n-    public static void setFloat(MemorySegment segment, float value) {\n-        setFloatAtOffset(segment, 0L, value);\n+    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);\n@@ -667,1 +733,1103 @@\n-     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Read a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);\n+    long value = (long)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLongAtOffset(MemorySegment segment, long offset) {\n+        return (long)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Read a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);\n+    double value = (double)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n+        return (double)((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.withStride(JAVA_DOUBLE.withBitAlignment(8).varHandle(double.class), 1L);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n+        ((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Read a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L));\n+    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a memory address read from {@code segment}.\n+     *\/\n+    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n+        return (MemoryAddress)address_handle.get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.withStride(JAVA_LONG.withBitAlignment(8).varHandle(long.class), 1L));\n+    handle.set(segment, offset, value.address());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     *\/\n+    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n+        address_handle.set(segment, offset, value.address());\n+    }\n+\n+    private static VarHandle indexedHandle(ValueLayout elementLayout, Class<?> carrier) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n+     * Reads a byte from given segment and offset.\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a byte value read from {@code segment}.\n+     *\/\n+    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n+        return (byte)byte_handle.get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment and offset.\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n+        byte_handle.set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getCharAtOffset(MemorySegment segment, long offset) {\n+        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n+        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShortAtOffset(MemorySegment segment, long offset) {\n+        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n+        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getIntAtOffset(MemorySegment segment, long offset) {\n+        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n+        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n+        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n+        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLongAtOffset(MemorySegment segment, long offset) {\n+        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n+        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n+        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n+        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    }\n+\n+    \/**\n+     * Reads a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n+    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a memory address read from {@code segment}.\n+     *\/\n+    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n+        return (MemoryAddress)address_handle.get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n+    handle.set(segment, offset, value.address());\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     *\/\n+    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n+        address_handle.set(segment, offset, value.address());\n+    }\n+\n+    \/**\n+     * Reads a char from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n+    char value = (char)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (char)((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a short from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n+    short value = (short)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (short)((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an int from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n+    int value = (int)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (int)((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a float from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n+    float value = (float)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (float)((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a long from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n+    long value = (long)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (long)((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a double from given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n+    double value = (double)handle.get(segment, offset);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+        return (double)((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and offset with given byte order.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n+    handle.set(segment, offset, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param order the specified byte order.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n+        ((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a byte from given segment.\n+=======\n+     * Read a byte from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    byte value = getByteAtOffset_LE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @return a byte value read from {@code segment}.\n+     *\/\n+    public static byte getByte_LE(MemorySegment segment) {\n+        return getByteAtOffset_LE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setByteAtOffset_LE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByte_LE(MemorySegment segment, byte value) {\n+        setByteAtOffset_LE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a char from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset_LE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getChar_LE(MemorySegment segment) {\n+        return getCharAtOffset_LE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset_LE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setChar_LE(MemorySegment segment, char value) {\n+        setCharAtOffset_LE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a short from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset_LE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShort_LE(MemorySegment segment) {\n+        return getShortAtOffset_LE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset_LE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShort_LE(MemorySegment segment, short value) {\n+        setShortAtOffset_LE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read an int from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset_LE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getInt_LE(MemorySegment segment) {\n+        return getIntAtOffset_LE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset_LE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setInt_LE(MemorySegment segment, int value) {\n+        setIntAtOffset_LE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a float from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset_LE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloat_LE(MemorySegment segment) {\n+        return getFloatAtOffset_LE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset_LE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloat_LE(MemorySegment segment, float value) {\n+        setFloatAtOffset_LE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a long from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    long value = getLongAtOffset_LE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLong_LE(MemorySegment segment) {\n+        return getLongAtOffset_LE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset_LE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLong_LE(MemorySegment segment, long value) {\n+        setLongAtOffset_LE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a double from given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    double value = getDoubleAtOffset_LE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDouble_LE(MemorySegment segment) {\n+        return getDoubleAtOffset_LE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset_LE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDouble_LE(MemorySegment segment, double value) {\n+        setDoubleAtOffset_LE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a byte from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    byte value = getByteAtOffset_BE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @return a byte value read from {@code segment}.\n+     *\/\n+    public static byte getByte_BE(MemorySegment segment) {\n+        return getByteAtOffset_BE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setByteAtOffset_BE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByte_BE(MemorySegment segment, byte value) {\n+        setByteAtOffset_BE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a char from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset_BE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getChar_BE(MemorySegment segment) {\n+        return getCharAtOffset_BE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset_BE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setChar_BE(MemorySegment segment, char value) {\n+        setCharAtOffset_BE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a short from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset_BE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShort_BE(MemorySegment segment) {\n+        return getShortAtOffset_BE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset_BE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShort_BE(MemorySegment segment, short value) {\n+        setShortAtOffset_BE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read an int from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset_BE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getInt_BE(MemorySegment segment) {\n+        return getIntAtOffset_BE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset_BE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setInt_BE(MemorySegment segment, int value) {\n+        setIntAtOffset_BE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a float from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset_BE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloat_BE(MemorySegment segment) {\n+        return getFloatAtOffset_BE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset_BE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloat_BE(MemorySegment segment, float value) {\n+        setFloatAtOffset_BE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a long from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    long value = getLongAtOffset_BE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a long value read from {@code segment}.\n+     *\/\n+    public static long getLong_BE(MemorySegment segment) {\n+        return getLongAtOffset_BE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a long at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset_BE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLong_BE(MemorySegment segment, long value) {\n+        setLongAtOffset_BE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a double from given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    double value = getDoubleAtOffset_BE(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a double value read from {@code segment}.\n+     *\/\n+    public static double getDouble_BE(MemorySegment segment) {\n+        return getDoubleAtOffset_BE(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a double at given segment, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset_BE(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDouble_BE(MemorySegment segment, double value) {\n+        setDoubleAtOffset_BE(segment, 0L, value);\n+    }\n+\n+    \/**\n+     * Read a byte from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    byte value = getByteAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @return a byte value read from {@code segment}.\n+     *\/\n+    public static byte getByte(MemorySegment segment) {\n+        return getByteAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n+     * Writes a byte at given segment.\n+=======\n+     * Writes a byte at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setByteAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByte(MemorySegment segment, byte value) {\n+        setByteAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n+     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+=======\n+     * Read a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a char value read from {@code segment}.\n+     *\/\n+    public static char getChar(MemorySegment segment) {\n+        return getCharAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setChar(MemorySegment segment, char value) {\n+        setCharAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n+     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+=======\n+     * Read a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a short value read from {@code segment}.\n+     *\/\n+    public static short getShort(MemorySegment segment) {\n+        return getShortAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShort(MemorySegment segment, short value) {\n+        setShortAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n+     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+=======\n+     * Read an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return an int value read from {@code segment}.\n+     *\/\n+    public static int getInt(MemorySegment segment) {\n+        return getIntAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setInt(MemorySegment segment, int value) {\n+        setIntAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n+     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+=======\n+     * Read a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @return a float value read from {@code segment}.\n+     *\/\n+    public static float getFloat(MemorySegment segment) {\n+        return getFloatAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloat(MemorySegment segment, float value) {\n+        setFloatAtOffset(segment, 0L, value);\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n+     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+=======\n+     * Read a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -695,0 +1863,1 @@\n+<<<<<<< HEAD\n@@ -696,0 +1865,3 @@\n+=======\n+     * Read a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -723,0 +1895,1 @@\n+<<<<<<< HEAD\n@@ -724,0 +1897,3 @@\n+=======\n+     * Read a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -751,0 +1927,1 @@\n+<<<<<<< HEAD\n@@ -936,0 +2113,249 @@\n+=======\n+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    byte value = getByteAtOffset_LE(segment, index);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static byte getByteAtIndex_LE(MemorySegment segment, long index) {\n+        return getByteAtOffset_LE(segment, index);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setByteAtOffset_LE(segment, index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByteAtIndex_LE(MemorySegment segment, long index, byte value) {\n+        setByteAtOffset_LE(segment, index, value);\n+    }\n+\n+    \/**\n+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset_LE(segment, 2 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static char getCharAtIndex_LE(MemorySegment segment, long index) {\n+        return getCharAtOffset_LE(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset_LE(segment, 2 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtIndex_LE(MemorySegment segment, long index, char value) {\n+        setCharAtOffset_LE(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset_LE(segment, 2 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static short getShortAtIndex_LE(MemorySegment segment, long index) {\n+        return getShortAtOffset_LE(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset_LE(segment, 2 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtIndex_LE(MemorySegment segment, long index, short value) {\n+        setShortAtOffset_LE(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset_LE(segment, 4 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static int getIntAtIndex_LE(MemorySegment segment, long index) {\n+        return getIntAtOffset_LE(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset_LE(segment, 4 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtIndex_LE(MemorySegment segment, long index, int value) {\n+        setIntAtOffset_LE(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset_LE(segment, 4 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static float getFloatAtIndex_LE(MemorySegment segment, long index) {\n+        return getFloatAtOffset_LE(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset_LE(segment, 4 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtIndex_LE(MemorySegment segment, long index, float value) {\n+        setFloatAtOffset_LE(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getLongAtOffset_LE(segment, 8 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static long getLongAtIndex_LE(MemorySegment segment, long index) {\n+        return getLongAtOffset_LE(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset_LE(segment, 8 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtIndex_LE(MemorySegment segment, long index, long value) {\n+        setLongAtOffset_LE(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getDoubleAtOffset_LE(segment, 8 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static double getDoubleAtIndex_LE(MemorySegment segment, long index) {\n+        return getDoubleAtOffset_LE(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset_LE(segment, 8 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtIndex_LE(MemorySegment segment, long index, double value) {\n+        setDoubleAtOffset_LE(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    byte value = getByteAtOffset_BE(segment, index);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static byte getByteAtIndex_BE(MemorySegment segment, long index) {\n+        return getByteAtOffset_BE(segment, index);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setByteAtOffset_BE(segment, index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByteAtIndex_BE(MemorySegment segment, long index, byte value) {\n+        setByteAtOffset_BE(segment, index, value);\n+    }\n+\n+    \/**\n+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset_BE(segment, 2 * index);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -941,0 +2367,1 @@\n+<<<<<<< HEAD\n@@ -951,0 +2378,12 @@\n+=======\n+    public static char getCharAtIndex_BE(MemorySegment segment, long index) {\n+        return getCharAtOffset_BE(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset_BE(segment, 2 * index, value);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -956,0 +2395,1 @@\n+<<<<<<< HEAD\n@@ -966,0 +2406,12 @@\n+=======\n+    public static void setCharAtIndex_BE(MemorySegment segment, long index, char value) {\n+        setCharAtOffset_BE(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset_BE(segment, 2 * index);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -971,0 +2423,1 @@\n+<<<<<<< HEAD\n@@ -981,0 +2434,12 @@\n+=======\n+    public static short getShortAtIndex_BE(MemorySegment segment, long index) {\n+        return getShortAtOffset_BE(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset_BE(segment, 2 * index, value);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -986,0 +2451,1 @@\n+<<<<<<< HEAD\n@@ -996,0 +2462,12 @@\n+=======\n+    public static void setShortAtIndex_BE(MemorySegment segment, long index, short value) {\n+        setShortAtOffset_BE(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset_BE(segment, 4 * index);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1001,0 +2479,1 @@\n+<<<<<<< HEAD\n@@ -1011,0 +2490,12 @@\n+=======\n+    public static int getIntAtIndex_BE(MemorySegment segment, long index) {\n+        return getIntAtOffset_BE(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset_BE(segment, 4 * index, value);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1016,0 +2507,1 @@\n+<<<<<<< HEAD\n@@ -1021,1 +2513,12 @@\n-     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset(segment, 4 * index);\n+=======\n+    public static void setIntAtIndex_BE(MemorySegment segment, long index, int value) {\n+        setIntAtOffset_BE(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n@@ -1025,1 +2528,2 @@\n-    float value = getFloatAtOffset(segment, 4 * index);\n+    float value = getFloatAtOffset_BE(segment, 4 * index);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1031,0 +2535,1 @@\n+<<<<<<< HEAD\n@@ -1041,0 +2546,12 @@\n+=======\n+    public static float getFloatAtIndex_BE(MemorySegment segment, long index) {\n+        return getFloatAtOffset_BE(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset_BE(segment, 4 * index, value);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1046,0 +2563,1 @@\n+<<<<<<< HEAD\n@@ -1056,0 +2574,12 @@\n+=======\n+    public static void setFloatAtIndex_BE(MemorySegment segment, long index, float value) {\n+        setFloatAtOffset_BE(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getLongAtOffset_BE(segment, 8 * index);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1061,0 +2591,1 @@\n+<<<<<<< HEAD\n@@ -1071,0 +2602,12 @@\n+=======\n+    public static long getLongAtIndex_BE(MemorySegment segment, long index) {\n+        return getLongAtOffset_BE(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset_BE(segment, 8 * index, value);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1076,0 +2619,1 @@\n+<<<<<<< HEAD\n@@ -1086,0 +2630,12 @@\n+=======\n+    public static void setLongAtIndex_BE(MemorySegment segment, long index, long value) {\n+        setLongAtOffset_BE(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getDoubleAtOffset_BE(segment, 8 * index);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -1091,0 +2647,1 @@\n+<<<<<<< HEAD\n@@ -1330,0 +2887,260 @@\n+=======\n+    public static double getDoubleAtIndex_BE(MemorySegment segment, long index) {\n+        return getDoubleAtOffset_BE(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#BIG_ENDIAN}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset_BE(segment, 8 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtIndex_BE(MemorySegment segment, long index, double value) {\n+        setDoubleAtOffset_BE(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Read a byte from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    byte value = getByteAtOffset(segment, index);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n+     * @return a byte value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static byte getByteAtIndex(MemorySegment segment, long index) {\n+        return getByteAtOffset(segment, index);\n+    }\n+\n+    \/**\n+     * Writes a byte at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setByteAtOffset(segment, index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index)}.\n+     * @param value the byte value to be written.\n+     *\/\n+    public static void setByteAtIndex(MemorySegment segment, long index, byte value) {\n+        setByteAtOffset(segment, index, value);\n+    }\n+\n+    \/**\n+     * Read a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    char value = getCharAtOffset(segment, 2 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static char getCharAtIndex(MemorySegment segment, long index) {\n+        return getCharAtOffset(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setCharAtOffset(segment, 2 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param value the char value to be written.\n+     *\/\n+    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n+        setCharAtOffset(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Read a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    short value = getShortAtOffset(segment, 2 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static short getShortAtIndex(MemorySegment segment, long index) {\n+        return getShortAtOffset(segment, scale(segment, index, 2));\n+    }\n+\n+    \/**\n+     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setShortAtOffset(segment, 2 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n+     * @param value the short value to be written.\n+     *\/\n+    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n+        setShortAtOffset(segment, scale(segment, index, 2), value);\n+    }\n+\n+    \/**\n+     * Read an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    int value = getIntAtOffset(segment, 4 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static int getIntAtIndex(MemorySegment segment, long index) {\n+        return getIntAtOffset(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setIntAtOffset(segment, 4 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param value the int value to be written.\n+     *\/\n+    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n+        setIntAtOffset(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Read a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    float value = getFloatAtOffset(segment, 4 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static float getFloatAtIndex(MemorySegment segment, long index) {\n+        return getFloatAtOffset(segment, scale(segment, index, 4));\n+    }\n+\n+    \/**\n+     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setFloatAtOffset(segment, 4 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n+     * @param value the float value to be written.\n+     *\/\n+    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n+        setFloatAtOffset(segment, scale(segment, index, 4), value);\n+    }\n+\n+    \/**\n+     * Read a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getLongAtOffset(segment, 8 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static long getLongAtIndex(MemorySegment segment, long index) {\n+        return getLongAtOffset(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setLongAtOffset(segment, 8 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the long value to be written.\n+     *\/\n+    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n+        setLongAtOffset(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Read a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getDoubleAtOffset(segment, 8 * index);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n+        return getDoubleAtOffset(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setDoubleAtOffset(segment, 8 * index, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the double value to be written.\n+     *\/\n+    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n+        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n+    }\n+\n+    \/**\n+     * Read a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    return getAddressAtOffset(segment, index * 8);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n+     *\/\n+    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n+        return getAddressAtOffset(segment, scale(segment, index, 8));\n+    }\n+\n+    \/**\n+     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setAddressAtOffset(segment, index * 8, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     *\/\n+    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n+        setAddressAtOffset(segment, scale(segment, index, 8), value);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":2018,"deletions":201,"binary":false,"changes":2219,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+<<<<<<< HEAD\n@@ -157,0 +158,9 @@\n+=======\n+     *\/\n+    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}), and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final ValueLayout ADDRESS = MemoryLayout.ofValueBits(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+<<<<<<< HEAD\n@@ -81,0 +82,5 @@\n+=======\n+ * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n+ * mapped memory segments are associated with a {@link FileDescriptor} instance which can be obtained calling the\n+ * {@link #fileDescriptor()} method. For more operations on mapped memory segments, please refer to the\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -189,0 +195,1 @@\n+<<<<<<< HEAD\n@@ -212,0 +219,25 @@\n+=======\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(Thread)}); in fact, many threads\n+ * can attempt to gain ownership of the same segment, concurrently, and only one of them is guaranteed to succeed.\n+ * <p>\n+ * When using shared segments, clients should make sure that no other thread is accessing the segment while\n+ * the segment is being closed. If one or more threads attempts to access a segment concurrently while the\n+ * segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should\n+ * refrain from attempting to close a segment repeatedly (e.g. keep calling {@link #close()} until no exception is thrown);\n+ * such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads\n+ * accessing\/closing the segment.\n+ *\n+ * <h2>Implicit deallocation<\/h2>\n+ *\n+ * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n+ * that segment will be released when the segment becomes <em>unreachable<\/em>, which can be useful to prevent native memory\n+ * leaks. This can be achieved using the {@link #registerCleaner(Cleaner)} method, as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment gcSegment = segment.registerCleaner(cleaner);\n+ * }<\/pre><\/blockquote>\n+ *\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -379,0 +411,1 @@\n+<<<<<<< HEAD\n@@ -385,0 +418,8 @@\n+=======\n+     * Obtain the file descriptor with this memory segment, assuming this segment is a mapped memory segment,\n+     * created using the {@link #mapFromPath(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * @return the file descriptor associated with this memory segment (if any).\n+     *\/\n+    Optional<FileDescriptor> fileDescriptor();\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -394,0 +435,1 @@\n+<<<<<<< HEAD\n@@ -398,0 +440,4 @@\n+=======\n+     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, this segment will be marked\n+     * as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -420,0 +466,1 @@\n+<<<<<<< HEAD\n@@ -423,0 +470,4 @@\n+=======\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -444,0 +495,1 @@\n+<<<<<<< HEAD\n@@ -447,0 +499,4 @@\n+=======\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -455,0 +511,4 @@\n+<<<<<<< HEAD\n+=======\n+     * @throws NullPointerException if {@code thread == null}\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -465,0 +525,1 @@\n+<<<<<<< HEAD\n@@ -468,0 +529,4 @@\n+=======\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -478,0 +543,4 @@\n+<<<<<<< HEAD\n+=======\n+     * @throws NullPointerException if {@code thread == null}\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -861,0 +930,1 @@\n+<<<<<<< HEAD\n@@ -862,0 +932,3 @@\n+=======\n+    static MemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+<<<<<<< HEAD\n@@ -37,0 +38,3 @@\n+=======\n+ * using the combinator methods defined in the {@link jdk.incubator.foreign.MemoryHandles} class. Finally, the {@link jdk.incubator.foreign.MemoryLayout} class\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -46,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -48,0 +53,4 @@\n+=======\n+    for (long i = 0 ; i < 10 ; i++) {\n+       intHandle.set(base.asSlice(i * 4), (int)i);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.internal.misc.Unsafe;\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -58,0 +62,4 @@\n+<<<<<<< HEAD\n+=======\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -152,0 +160,1 @@\n+<<<<<<< HEAD\n@@ -153,0 +162,3 @@\n+=======\n+            if ((byte) BYTE_HANDLE.get(this, 0) != (byte) BYTE_HANDLE.get(that, 0)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -167,0 +179,1 @@\n+<<<<<<< HEAD\n@@ -168,0 +181,3 @@\n+=======\n+            if ((byte) BYTE_HANDLE.get(this, i) != (byte) BYTE_HANDLE.get(that, i)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -316,0 +332,1 @@\n+<<<<<<< HEAD\n@@ -318,0 +335,4 @@\n+=======\n+    public Optional<FileDescriptor> fileDescriptor() {\n+        return Optional.empty();\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+<<<<<<< HEAD\n@@ -85,0 +86,4 @@\n+=======\n+    public Optional<FileDescriptor> fileDescriptor() {\n+        return Optional.of(unmapper.fileDescriptor());\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -51,0 +52,3 @@\n+=======\n+ * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -116,0 +120,1 @@\n+<<<<<<< HEAD\n@@ -117,0 +122,3 @@\n+=======\n+    MemoryScope confineTo(Thread newOwner) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -136,0 +144,1 @@\n+<<<<<<< HEAD\n@@ -137,0 +146,3 @@\n+=======\n+    MemoryScope share() {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -149,0 +161,1 @@\n+<<<<<<< HEAD\n@@ -150,0 +163,3 @@\n+=======\n+    MemoryScope cleanable(Cleaner cleaner) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -167,0 +183,1 @@\n+<<<<<<< HEAD\n@@ -168,0 +185,3 @@\n+=======\n+    abstract Thread ownerThread();\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -224,0 +244,1 @@\n+<<<<<<< HEAD\n@@ -226,0 +247,15 @@\n+=======\n+        MemoryScope confineTo(Thread newOwner) {\n+            if (newOwner == owner) {\n+                throw new IllegalArgumentException(\"Segment already owned by thread: \" + newOwner);\n+            }\n+            return super.confineTo(newOwner);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n+        }\n+    }\n+\n+<<<<<<< HEAD\n+=======\n+        @Override\n+        Thread ownerThread() {\n+            return owner;\n@@ -229,0 +265,1 @@\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -264,0 +301,1 @@\n+<<<<<<< HEAD\n@@ -265,0 +303,3 @@\n+=======\n+        Thread ownerThread() {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+<<<<<<< HEAD\n@@ -54,0 +55,3 @@\n+=======\n+            ADDRESS_FILTER = MethodHandles.lookup().findStatic(Utils.class, \"filterSegment\",\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -38,0 +39,3 @@\n+=======\n+import jdk.incubator.foreign.*;\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -39,1 +43,0 @@\n-import jdk.incubator.foreign.SequenceLayout;\n@@ -231,0 +234,1 @@\n+<<<<<<< HEAD\n@@ -232,0 +236,3 @@\n+=======\n+        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -236,0 +243,1 @@\n+<<<<<<< HEAD\n@@ -237,0 +245,3 @@\n+=======\n+        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -249,0 +260,1 @@\n+<<<<<<< HEAD\n@@ -250,0 +262,3 @@\n+=======\n+        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -255,0 +270,1 @@\n+<<<<<<< HEAD\n@@ -256,0 +272,3 @@\n+=======\n+        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -266,0 +285,1 @@\n+<<<<<<< HEAD\n@@ -268,0 +288,4 @@\n+=======\n+        MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n+        assertTrue(segment.fileDescriptor().isPresent());\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -283,0 +307,1 @@\n+<<<<<<< HEAD\n@@ -284,0 +309,3 @@\n+=======\n+            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -292,0 +320,1 @@\n+<<<<<<< HEAD\n@@ -293,0 +322,3 @@\n+=======\n+            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -561,0 +593,1 @@\n+<<<<<<< HEAD\n@@ -604,0 +637,2 @@\n+=======\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -662,0 +697,1 @@\n+<<<<<<< HEAD\n@@ -690,0 +726,30 @@\n+=======\n+                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtIndex_BE(addr, pos, (byte)(long)pos));\n+        Consumer<MemorySegment> charInitializer =\n+                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex_BE(addr, pos, (char)(long)pos));\n+        Consumer<MemorySegment> shortInitializer =\n+                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex_BE(addr, pos, (short)(long)pos));\n+        Consumer<MemorySegment> intInitializer =\n+                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex_BE(addr, pos, (int)(long)pos));\n+        Consumer<MemorySegment> floatInitializer =\n+                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex_BE(addr, pos, (float)(long)pos));\n+        Consumer<MemorySegment> longInitializer =\n+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex_BE(addr, pos, (long)pos));\n+        Consumer<MemorySegment> doubleInitializer =\n+                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex_BE(addr, pos, (double)(long)pos));\n+\n+        Consumer<MemorySegment> byteChecker =\n+                (base) -> checkBytes(base, bytes, Function.identity(), MemoryAccess::getByteAtIndex_BE, ByteBuffer::get);\n+        Consumer<MemorySegment> charChecker =\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, MemoryAccess::getCharAtIndex_BE, CharBuffer::get);\n+        Consumer<MemorySegment> shortChecker =\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, MemoryAccess::getShortAtIndex_BE, ShortBuffer::get);\n+        Consumer<MemorySegment> intChecker =\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, MemoryAccess::getIntAtIndex_BE, IntBuffer::get);\n+        Consumer<MemorySegment> floatChecker =\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, MemoryAccess::getFloatAtIndex_BE, FloatBuffer::get);\n+        Consumer<MemorySegment> longChecker =\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, MemoryAccess::getLongAtIndex_BE, LongBuffer::get);\n+        Consumer<MemorySegment> doubleChecker =\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, MemoryAccess::getDoubleAtIndex_BE, DoubleBuffer::get);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -7,0 +7,1 @@\n+<<<<<<< HEAD\n@@ -8,0 +9,5 @@\n+=======\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -39,0 +45,1 @@\n+<<<<<<< HEAD\n@@ -41,0 +48,2 @@\n+=======\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -175,0 +184,1 @@\n+<<<<<<< HEAD\n@@ -184,0 +194,17 @@\n+=======\n+        RegisterKind[] kinds = RegisterKind.values();\n+\n+        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n+        Object[][] data = new Object[cleaners.length * kinds.length * segmentFunctions.length][3];\n+\n+        for (int kind = 0 ; kind < kinds.length ; kind++) {\n+            for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n+                for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n+                    data[kind + kinds.length * cleaner + (cleaners.length * kinds.length * segmentFunction)] =\n+                            new Object[] { kinds[kind], cleaners[cleaner], segmentFunctions[segmentFunction] };\n+                }\n+            }\n+        }\n+\n+        return data;\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+<<<<<<< HEAD\n@@ -46,0 +47,3 @@\n+=======\n+import java.util.function.Function;\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -59,0 +63,1 @@\n+<<<<<<< HEAD\n@@ -74,0 +79,12 @@\n+=======\n+    @Test(dataProvider = \"accessors\")\n+    public void testHandshake(Function<MemorySegment, Runnable> accessorFactory) throws InterruptedException {\n+        for (int it = 0 ; it < ITERATIONS ; it++) {\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            System.err.println(\"ITERATION \" + it);\n+            ExecutorService accessExecutor = Executors.newCachedThreadPool();\n+            for (int i = 0; i < Runtime.getRuntime().availableProcessors() ; i++) {\n+                accessExecutor.execute(accessorFactory.apply(segment));\n+            }\n+            Thread.sleep(ThreadLocalRandom.current().nextInt(MAX_DELAY_MILLIS));\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -83,0 +100,1 @@\n+<<<<<<< HEAD\n@@ -87,0 +105,4 @@\n+=======\n+\n+        AbstractSegmentAccessor(MemorySegment segment) {\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -96,0 +118,1 @@\n+<<<<<<< HEAD\n@@ -106,0 +129,6 @@\n+=======\n+                    backoff();\n+                    continue outer;\n+                }\n+            }\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -122,0 +151,1 @@\n+<<<<<<< HEAD\n@@ -124,0 +154,4 @@\n+=======\n+        AbstractBufferAccessor(MemorySegment segment) {\n+            super(segment);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -130,0 +164,1 @@\n+<<<<<<< HEAD\n@@ -132,0 +167,4 @@\n+=======\n+        SegmentAccessor(MemorySegment segment) {\n+            super(segment);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -138,0 +177,1 @@\n+<<<<<<< HEAD\n@@ -139,0 +179,3 @@\n+=======\n+                sum += MemoryAccess.getByteAtIndex(segment, i);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -148,0 +191,1 @@\n+<<<<<<< HEAD\n@@ -150,0 +194,4 @@\n+=======\n+        SegmentCopyAccessor(MemorySegment segment) {\n+            super(segment);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -163,0 +211,1 @@\n+<<<<<<< HEAD\n@@ -165,0 +214,4 @@\n+=======\n+        SegmentFillAccessor(MemorySegment segment) {\n+            super(segment);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -177,0 +230,1 @@\n+<<<<<<< HEAD\n@@ -182,0 +236,7 @@\n+=======\n+        SegmentMismatchAccessor(MemorySegment segment) {\n+            super(segment);\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            copy.copyFrom(segment);\n+            MemoryAccess.setByteAtIndex(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -192,0 +253,1 @@\n+<<<<<<< HEAD\n@@ -194,0 +256,4 @@\n+=======\n+        BufferAccessor(MemorySegment segment) {\n+            super(segment);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -209,0 +275,1 @@\n+<<<<<<< HEAD\n@@ -211,0 +278,4 @@\n+=======\n+        public BufferHandleAccessor(MemorySegment segment) {\n+            super(segment);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -232,0 +303,4 @@\n+<<<<<<< HEAD\n+=======\n+            long prev = System.currentTimeMillis();\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -240,0 +315,1 @@\n+<<<<<<< HEAD\n@@ -241,0 +317,3 @@\n+=======\n+            long delay = System.currentTimeMillis() - prev;\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -245,0 +324,1 @@\n+<<<<<<< HEAD\n@@ -258,0 +338,11 @@\n+=======\n+    @DataProvider\n+    static Object[][] accessors() {\n+        return new Object[][] {\n+                { (Function<MemorySegment, Runnable>)SegmentAccessor::new },\n+                { (Function<MemorySegment, Runnable>)SegmentCopyAccessor::new },\n+                { (Function<MemorySegment, Runnable>)SegmentMismatchAccessor::new },\n+                { (Function<MemorySegment, Runnable>)SegmentFillAccessor::new },\n+                { (Function<MemorySegment, Runnable>)BufferAccessor::new },\n+                { (Function<MemorySegment, Runnable>)BufferHandleAccessor::new }\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+<<<<<<< HEAD\n@@ -110,0 +111,2 @@\n+=======\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+<<<<<<< HEAD\n@@ -159,0 +160,2 @@\n+=======\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.incubator.foreign.MemoryAddress;\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n@@ -98,0 +102,1 @@\n+<<<<<<< HEAD\n@@ -99,0 +104,3 @@\n+=======\n+        segment = MemorySegment.mapFromPath(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);\n+>>>>>>> 4ff386970b18d3cb9745444a257c4c374b65fdec\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}