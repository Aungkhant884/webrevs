{"files":[{"patch":"@@ -297,1 +297,1 @@\n-            MemorySegment hello = arena.allocateUtf8String(\"Hello\");\n+            MemorySegment hello = arena.allocateString(\"Hello\");\n@@ -309,1 +309,1 @@\n-            MemorySegment hello = arena.allocateUtf8String(\"Hello\");\n+            MemorySegment hello = arena.allocateString(\"Hello\");\n@@ -311,2 +311,2 @@\n-                STDLIB.find(\"strlen\").get(),\n-                hello); \/\/ 5\n+                    STDLIB.find(\"strlen\").get(),\n+                    hello); \/\/ 5\n@@ -329,2 +329,2 @@\n-                                                              ADDRESS.withTargetLayout(JAVA_INT),\n-                                                              ADDRESS.withTargetLayout(JAVA_INT));\n+                ADDRESS.withTargetLayout(JAVA_INT),\n+                ADDRESS.withTargetLayout(JAVA_INT));\n@@ -332,2 +332,2 @@\n-                                         .findStatic(Qsort.class, \"qsortCompare\",\n-                                                     comparDesc.toMethodType());\n+                .findStatic(Qsort.class, \"qsortCompare\",\n+                        comparDesc.toMethodType());\n@@ -337,1 +337,1 @@\n-                comparHandle, comparDesc, arena);\n+                    comparHandle, comparDesc, arena);\n@@ -353,2 +353,2 @@\n-            MemorySegment s = arena.allocateUtf8String(\"%d plus %d equals %d\\n\");\n-            int res = (int)printf.invokeExact(s, 2, 2, 4);\n+            MemorySegment s = arena.allocateString(\"%d plus %d equals %d\\n\");\n+            int res = (int) printf.invokeExact(s, 2, 2, 4);\n","filename":"doc\/panama_ffi.md","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n- *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment str = arena.allocateString(\"Hello\");\n@@ -98,1 +98,1 @@\n- * }\n+ *}\n@@ -438,2 +438,1 @@\n- *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n- * }\n+ *     int res = (int)printf.invokeExact(arena.allocateString(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -441,0 +440,1 @@\n+ *}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.lang.foreign.Linker.Option;\n-import java.lang.invoke.MethodHandle;\n@@ -39,0 +37,1 @@\n+import java.nio.charset.Charset;\n@@ -50,0 +49,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -51,1 +51,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n@@ -1062,1 +1061,2 @@\n-     * Reads a UTF-8 encoded, null-terminated string from this segment at the given offset.\n+     * Reads a null-terminated string from this segment at the given offset, using the\n+     * {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1064,4 +1064,5 @@\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * getString(offset, StandardCharsets.UTF_8);\n+     *}\n+     *\n@@ -1071,3 +1072,4 @@\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code S + offset > byteSize()}, where {@code S} is the size of the UTF-8\n-     * string (including the terminator character).\n+     * @throws IllegalArgumentException if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset} > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1079,2 +1081,3 @@\n-    default String getUtf8String(long offset) {\n-        return SharedUtils.toJavaStringInternal(this, offset);\n+    @ForceInline\n+    default String getString(long offset) {\n+        return getString(offset, StandardCharsets.UTF_8);\n@@ -1084,1 +1087,1 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * Reads a null-terminated string from this segment at the given offset, using the provided charset.\n@@ -1090,0 +1093,29 @@\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the string bytes.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException      if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset} > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    @ForceInline\n+    default String getString(long offset, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset);\n+    }\n+\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1091,4 +1123,4 @@\n-     * If the given string contains any {@code '\\0'} characters, they will be\n-     * copied as well. This means that, depending on the method used to read\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n-     * will appear truncated when read again.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * setString(offset, str, StandardCharsets.UTF_8);\n+     *}\n@@ -1098,1 +1130,3 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code str.getBytes().length() + offset >= byteSize()}.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset} > byteSize() - (B + 1}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1104,2 +1138,4 @@\n-    default void setUtf8String(long offset, String str) {\n-        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    @ForceInline\n+    default void setString(long offset, String str) {\n+        Objects.requireNonNull(str);\n+        setString(offset, str, StandardCharsets.UTF_8);\n@@ -1108,0 +1144,38 @@\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     *                the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param str     the Java string to be written into this segment.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset} > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    @ForceInline\n+    default void setString(long offset, String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        StringSupport.write(this, offset, charset, str);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":95,"deletions":21,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.charset.Charset;\n@@ -36,1 +37,1 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.StringSupport;\n@@ -38,0 +39,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -65,1 +67,1 @@\n-     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n+     * Converts a Java string into a null-terminated C string using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset,\n@@ -68,0 +70,18 @@\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * allocateString(str, StandardCharsets.UTF_8);\n+     *}\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native segment containing the converted C string.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateString(String str) {\n+        Objects.requireNonNull(str);\n+        return allocateString(str, StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * and storing the result into a memory segment.\n+     * <p>\n@@ -75,1 +95,1 @@\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n@@ -78,3 +98,2 @@\n-     * @implSpec the default implementation for this method copies the contents of the provided Java string\n-     * into a new memory segment obtained by calling {@code this.allocate(str.length() + 1)}.\n-     * @param str the Java string to be converted into a C string.\n+     * @param str     the Java string to be converted into a C string.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n@@ -82,0 +101,9 @@\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     * @implSpec the default implementation for this method copies the contents of the provided Java string\n+     * into a new memory segment obtained by calling {@code this.allocate(B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n@@ -83,1 +111,3 @@\n-    default MemorySegment allocateUtf8String(String str) {\n+    @ForceInline\n+    default MemorySegment allocateString(String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n@@ -85,1 +115,5 @@\n-        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n+        byte[] bytes = str.getBytes(charset);\n+        MemorySegment segment = allocate(bytes.length + termCharSize);\n+        MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        return segment;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":42,"deletions":8,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n- *     MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment cString = arena.allocateString(\"Hello\");\n@@ -113,1 +113,1 @@\n- * {@linkplain java.lang.foreign.SegmentAllocator#allocateUtf8String(java.lang.String) converting} Java strings into\n+ * {@linkplain java.lang.foreign.SegmentAllocator#allocateString(java.lang.String) converting} Java strings into\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-                MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment str = arena.allocateString(\"Hello\");\n@@ -290,1 +290,1 @@\n-                int res = (int) printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+                int res = (int) printf.invokeExact(arena.allocateString(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -572,1 +572,1 @@\n-                MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment cString = arena.allocateString(\"Hello\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n+\/**\n+ * Miscellaneous functions to read and write strings, in various charsets.\n+ *\/\n+public class StringSupport {\n+    public static String read(MemorySegment segment, long offset, Charset charset) {\n+        return switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> readFast_byte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readFast_short(segment, offset, charset);\n+            default -> throw new UnsupportedOperationException(\"Unsupported charset: \" + charset);\n+        };\n+    }\n+\n+    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+        switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> writeFast_byte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeFast_short(segment, offset, charset, string);\n+            default -> throw new UnsupportedOperationException(\"Unsupported charset: \" + charset);\n+        }\n+    }\n+    private static String readFast_byte(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, ValueLayout.JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeFast_byte(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, offset, bytes.length);\n+        segment.set(ValueLayout.JAVA_BYTE, offset + bytes.length, (byte)0);\n+    }\n+\n+    private static String readFast_short(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_short(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, ValueLayout.JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeFast_short(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_SHORT, offset + bytes.length, (short)0);\n+    }\n+\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    public enum CharsetKind {\n+        SINGLE_BYTE(1),\n+        DOUBLE_BYTE(2);\n+\n+        final int terminatorCharSize;\n+\n+        CharsetKind(int terminatorCharSize) {\n+            this.terminatorCharSize = terminatorCharSize;\n+        }\n+\n+        public int terminatorCharSize() {\n+            return terminatorCharSize;\n+        }\n+\n+        public static CharsetKind of(Charset charset) {\n+            if (charset == StandardCharsets.UTF_8 || charset == StandardCharsets.ISO_8859_1 || charset == StandardCharsets.US_ASCII) {\n+                return CharsetKind.SINGLE_BYTE;\n+            } else if (charset == StandardCharsets.UTF_16LE || charset == StandardCharsets.UTF_16BE || charset == StandardCharsets.UTF_16) {\n+                return CharsetKind.DOUBLE_BYTE;\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported charset: \" + charset);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -49,1 +48,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -151,12 +149,0 @@\n-    public static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n-    }\n-\n-    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -250,18 +250,0 @@\n-    public static String toJavaStringInternal(MemorySegment segment, long start) {\n-        int len = strlen(segment, start);\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n-        return new String(bytes, StandardCharsets.UTF_8);\n-    }\n-\n-    private static int strlen(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -190,3 +190,3 @@\n-                buf.setUtf8String(0, s1);\n-                MemorySegment other = arena.allocateUtf8String(s2);\n-                return ((MemorySegment)strcat.invokeExact(buf, other)).getUtf8String(0);\n+                buf.setString(0, s1);\n+                MemorySegment other = arena.allocateString(s2);\n+                return ((MemorySegment)strcat.invokeExact(buf, other)).getString(0);\n@@ -198,2 +198,2 @@\n-                MemorySegment ns1 = arena.allocateUtf8String(s1);\n-                MemorySegment ns2 = arena.allocateUtf8String(s2);\n+                MemorySegment ns1 = arena.allocateString(s1);\n+                MemorySegment ns2 = arena.allocateString(s2);\n@@ -206,1 +206,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateString(msg);\n@@ -213,1 +213,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateString(msg);\n@@ -303,1 +303,1 @@\n-                MemorySegment formatStr = arena.allocateUtf8String(format);\n+                MemorySegment formatStr = arena.allocateString(format);\n@@ -384,1 +384,1 @@\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateString(\"str\"), \"str\");\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        assertEquals(str, addr.getUtf8String(0));\n+        assertEquals(str, addr.getString(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -202,1 +201,1 @@\n-        allocator.allocateUtf8String(\"Hello\");\n+        allocator.allocateString(\"Hello\");\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.lang.reflect.Field;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -41,3 +44,5 @@\n-    public void testStrings(String testString, int expectedByteLength) {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment text = arena.allocateUtf8String(testString);\n+    public void testStrings(String testString) throws ReflectiveOperationException {\n+        for (Charset charset : Charset.availableCharsets().values()) {\n+            if (isStandard(charset)) {\n+                try (Arena arena = Arena.ofConfined()) {\n+                    MemorySegment text = arena.allocateString(testString, charset);\n@@ -45,1 +50,4 @@\n-            assertEquals(text.byteSize(), expectedByteLength);\n+                    int terminatorSize = \"\\0\".getBytes(charset).length;\n+                    if (charset == StandardCharsets.UTF_16) {\n+                        terminatorSize -= 2; \/\/ drop BOM\n+                    }\n@@ -47,2 +55,14 @@\n-            String roundTrip = text.getUtf8String(0);\n-            assertEquals(roundTrip, testString);\n+                    int expectedByteLength =\n+                            testString.getBytes(charset).length +\n+                            terminatorSize;\n+\n+                    assertEquals(text.byteSize(), expectedByteLength);\n+\n+                    String roundTrip = text.getString(0, charset);\n+                    if (charset.newEncoder().canEncode(testString)) {\n+                        assertEquals(roundTrip, testString);\n+                    }\n+                }\n+            } else {\n+                assertThrows(UnsupportedOperationException.class, () -> Arena.global().allocateString(testString, charset));\n+            }\n@@ -55,7 +75,7 @@\n-            { \"testing\",               8 },\n-            { \"\",                      1 },\n-            { \"X\",                     2 },\n-            { \"12345\",                 6 },\n-            { \"yen \\u00A5\",            7 }, \/\/ in UTF-8 2 bytes: 0xC2 0xA5\n-            { \"snowman \\u26C4\",       12 }, \/\/ in UTF-8 three bytes: 0xE2 0x9B 0x84\n-            { \"rainbow \\uD83C\\uDF08\", 13 }  \/\/ in UTF-8 four bytes: 0xF0 0x9F 0x8C 0x88\n+            { \"testing\" },\n+            { \"\" },\n+            { \"X\" },\n+            { \"12345\" },\n+            { \"yen \\u00A5\" },\n+            { \"snowman \\u26C4\" },\n+            { \"rainbow \\uD83C\\uDF08\" }\n@@ -64,0 +84,9 @@\n+\n+    boolean isStandard(Charset charset) throws ReflectiveOperationException {\n+        for (Field standardCharset : StandardCharsets.class.getDeclaredFields()) {\n+            if (standardCharset.get(null) == charset) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            MemorySegment segment = arena.allocateUtf8String(str);\n+            MemorySegment segment = arena.allocateString(str);\n@@ -104,1 +104,1 @@\n-        return (int)STRLEN.invokeExact(arenaAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(arenaAllocator.allocateString(str));\n@@ -110,1 +110,1 @@\n-        int l = (int) STRLEN.invokeExact(arena.allocateUtf8String(str));\n+        int l = (int) STRLEN.invokeExact(arena.allocateString(str));\n@@ -117,1 +117,1 @@\n-        return (int)STRLEN.invokeExact(segmentAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(segmentAllocator.allocateString(str));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}