{"files":[{"patch":"@@ -63,3 +63,4 @@\n-     * this memory session. The {@link MemorySegment#address()} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n-     * of the returned segment will be aligned according the provided alignment constraint.\n+     * the memory session associated with this arena. The {@link MemorySegment#address()} of the returned memory segment\n+     * is the starting address of the newly allocated off-heap memory region backing the segment.\n+     * Moreover, the {@linkplain MemorySegment#address() address} of the returned segment will be aligned according\n+     * the provided alignment constraint.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * if a memory session is created and closed by one thread, and the segments it creates are only ever accessed by that very same\n+ * if a memory session is created and closed by one thread, and the segments associated with it are only ever accessed by that very same\n@@ -52,1 +52,1 @@\n- * Conversely, if a session creates segments that can be accessed by multiple threads, or if the session can be\n+ * Conversely, if a session is associated with segments that can be accessed by multiple threads, or if the session can be\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-     * @param segment the segment from which the returned allocator should slice from.\n+     * @param segment the segment which the returned allocator should slice from.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-    public Thread ownerThread() {\n+    public final Thread ownerThread() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.foreign.MemorySessionImpl.ResourceList.ResourceCleanup;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-            segment = MemorySegment.allocateNative(POINT, arena.session());\n+            segment = arena.allocate(POINT);\n@@ -80,1 +80,1 @@\n-                return new Allocation(arena, MemorySegment.allocateNative(layout, arena.session()));\n+                return new Allocation(arena, arena.allocate(layout));\n@@ -165,1 +165,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(POINT, arena.session());\n+            MemorySegment segment = arena.allocate(POINT);\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -248,0 +248,57 @@\n+    @Test\n+    public void testConfinedSessionWithImplicitDependency() {\n+        Arena root = Arena.openConfined();\n+        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            keepAlive(MemorySession.implicit(), root.session());\n+        }\n+        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n+        \/\/ might be called from another thread (the Cleaner thread), so that the confined session lock count is updated racily.\n+        \/\/ If that happens, the loop below never terminates.\n+        while (true) {\n+            try {\n+                root.close();\n+                break; \/\/ success!\n+            } catch (IllegalStateException ex) {\n+                kickGC();\n+                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n+                    try (Arena arena = Arena.openConfined()) {\n+                        keepAlive(arena.session(), root.session());\n+                        \/\/ dummy\n+                    }\n+                }\n+                \/\/ try again\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedSessionWithSharedDependency() {\n+        Arena root = Arena.openConfined();\n+        List<Thread> threads = new ArrayList<>();\n+        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            Arena arena = Arena.openShared(); \/\/ create session inside same thread!\n+            keepAlive(arena.session(), root.session());\n+            Thread t = new Thread(arena::close); \/\/ close from another thread!\n+            threads.add(t);\n+            t.start();\n+        }\n+        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n+            try (Arena arena = Arena.openConfined()) {\n+                keepAlive(arena.session(), root.session());\n+                \/\/ dummy\n+            }\n+        }\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                \/\/ ok\n+            }\n+        });\n+        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined session happen in different\n+        \/\/ threads, so that the confined session lock count is updated racily. If that happens, the following close will blow up.\n+        root.close();\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    Arena arena;\n+    Arena confinedArena, sharedArena;\n@@ -71,3 +71,4 @@\n-        arena = Arena.openConfined();\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, arena.session());;\n-        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, arena.session());; \/\/ <- This segment is not shared!\n+        confinedArena = Arena.openConfined();\n+        sharedArena = Arena.openShared();\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.session());\n+        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.session());\n@@ -97,1 +98,2 @@\n-        arena.close();\n+        confinedArena.close();\n+        sharedArena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}