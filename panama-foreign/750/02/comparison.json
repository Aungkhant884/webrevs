{"files":[{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.ArenaImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * An arena allocates and manages the lifecycle of native segments.\n+ * <p>\n+ * An arena is a {@linkplain AutoCloseable closeable} segment allocator that is associated with a {@link #session() memory session}.\n+ * This session is created with the arena, and is closed when the arena is {@linkplain #close() closed}.\n+ * Furthermore, all the native segments {@linkplain #allocate(long, long) allocated} by the arena are associated\n+ * with that session.\n+ * <p>\n+ * The <a href=\"MemorySession.html#thread-confinement\">confinement properties<\/a> of the session associated with an\n+ * arena are determined by the factory used to create the arena. For instance, an arena created with {@link #openConfined()}\n+ * is associated with a <em>confined<\/em> memory session. Conversely, an arena created with {@link #openShared()} is\n+ * associated with a <em>shared<\/em> memory session.\n+ * <p>\n+ * An arena is extremely useful when interacting with foreign code, as shown below:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     MemorySegment nativeArray = arena.allocateArray(ValueLayout.JAVA_INT, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+ *     MemorySegment nativeString = arena.allocateUtf8String(\"Hello!\");\n+ *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.session());\n+ *     ...\n+ * } \/\/ memory released here\n+ *}\n+ *\n+ * @since 20\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface Arena extends SegmentAllocator, AutoCloseable permits ArenaImpl { \/\/@@@: This can also be non-sealed!\n+\n+    \/**\n+     * Creates a native memory segment with the given size (in bytes), alignment constraint (in bytes) associated with\n+     * this memory session. The {@link MemorySegment#address()} of the returned memory segment is the starting address of\n+     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n+     * of the returned segment will be aligned according the provided alignment constraint.\n+     * <p>\n+     * Clients are responsible for ensuring that this arena is closed when the segments returned by this method are no\n+     * longer in use. Failure to do so will result in off-heap memory leaks.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemorySegment.allocateNative(bytesSize, byteAlignment, session());\n+     * }\n+     * <p>\n+     * The region of off-heap memory backing the returned native memory segment is initialized to zero.\n+     *\n+     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n+     * is not a power of 2.\n+     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} the session associated with this arena.\n+     * @see MemorySegment#allocateNative(long, long, MemorySession)\n+     *\/\n+    @Override\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n+\n+    \/**\n+     * {@return the session associated with this arena}\n+     *\/\n+    MemorySession session();\n+\n+    \/**\n+     * Closes this arena. This closes the {@linkplain #session() session} associated with this arena and invalidates\n+     * all the memory segments associated with it. Any off-heap region of memory backing the segments associated with\n+     * that memory session are also released.\n+     * @throws IllegalStateException if the session associated with this arena is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} the session associated with this arena.\n+     *\/\n+    @Override\n+    void close();\n+\n+    \/**\n+     * Creates a new arena, associated with a new confined session.\n+     * @return a new arena, associated with a new confined session.\n+     *\/\n+    static Arena openConfined() {\n+        return new ArenaImpl(MemorySessionImpl.createConfined(Thread.currentThread()));\n+    }\n+\n+    \/**\n+     * Creates a new arena, associated with a new shared session.\n+     * @return a new arena, associated with a new shared session.\n+     *\/\n+    static Arena openShared() {\n+        return new ArenaImpl(MemorySessionImpl.createShared());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -109,2 +109,2 @@\n- * downcall method handles and, when no longer required, they can be {@linkplain MemorySession#close() released},\n- * via their associated {@linkplain MemorySession memory session}.\n+ * downcall method handles and, when no longer required, they can be closed, via their associated\n+ * {@linkplain MemorySession memory session}.\n@@ -124,1 +124,1 @@\n- *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#ownerThread() owning} the memory session of {@code R},\n+ *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#isOwnedBy(Thread) owning} the memory session of {@code R},\n@@ -277,1 +277,1 @@\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n@@ -353,2 +353,2 @@\n-         * try (MemorySession session = MemorySession.openConfined()) {\n-         *     MemorySegment capturedState = session.allocate(ccs.layout());\n+         * try (Arena arena = Arena.openConfined()) {\n+         *     MemorySegment capturedState = arena.allocate(ccs.layout());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.Array;\n@@ -52,1 +51,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -57,2 +55,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n@@ -70,1 +66,1 @@\n- * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long)}\n+ * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, MemorySession)}\n@@ -98,2 +94,2 @@\n- * (as in {@link MemorySegment#allocateNative(long)}) or derived from a {@link MemoryLayout}\n- * (as in {@link MemorySegment#allocateNative(MemoryLayout)}). The size of a memory segment is typically\n+ * (as in {@link MemorySegment#allocateNative(long, MemorySession)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link MemorySegment#allocateNative(MemoryLayout, MemorySession)}). The size of a memory segment is typically\n@@ -108,1 +104,1 @@\n- * (e.g. after the memory session associated with the accessed memory segment has been {@linkplain MemorySession#close() closed}).\n+ * (e.g. after the memory session associated with the accessed memory segment is no longer {@link MemorySession#isAlive() alive}.\n@@ -112,3 +108,2 @@\n- * session; that is, if the segment is associated with a {@linkplain MemorySession#openShared() shared session},\n- * it can be accessed by multiple threads; if it is associated with a {@linkplain MemorySession#openConfined() confined session},\n- * it can only be accessed by the thread which owns the memory session.\n+ * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads; if it is\n+ * associated with a confined session, it can only be accessed by the thread which owns the memory session.\n@@ -188,2 +183,2 @@\n- * {@snippet lang=java :\n- * try (MemorySession session = MemorySession.openShared()) {\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openShared()) {\n@@ -191,1 +186,1 @@\n- *     MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, session);\n+ *     MemorySegment segment = arena.allocate(SEQUENCE_LAYOUT);\n@@ -196,1 +191,1 @@\n- * }\n+ *}\n@@ -248,2 +243,2 @@\n- * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long)}\n- * or {@link #allocateNative(MemoryLayout)}. These factories ensure that the off-heap region of memory backing\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, MemorySession)}\n+ * or {@link #allocateNative(MemoryLayout, MemorySession)}. These factories ensure that the off-heap region of memory backing\n@@ -513,1 +508,1 @@\n-     * created e.g. using the {@link #allocateNative(long)} (and related) factory, or by\n+     * created e.g. using the {@link #allocateNative(long, MemorySession)} (and related) factory, or by\n@@ -755,1 +750,1 @@\n-     * after the memory session associated with this segment has been closed (see {@link MemorySession#close()}), will\n+     * after the memory session associated with this segment is no longer {@linkplain MemorySession#isAlive() alive}, will\n@@ -757,1 +752,1 @@\n-     * the thread {@linkplain MemorySession#ownerThread() owning} this segment's memory session will throw\n+     * the thread {@linkplain MemorySession#isOwnedBy(Thread) owning} this segment's memory session will throw\n@@ -936,1 +931,1 @@\n-     *     {@linkplain MemorySession#openImplicit() implicit session} that keeps the buffer reachable.\n+     *     {@linkplain MemorySession#implicit() implicit session} that keeps the buffer reachable.\n@@ -1091,0 +1086,37 @@\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, byteSize, session, null);\n+     *}\n+     *\n+     * @param address the returned segment's address.\n+     * @param byteSize the desired size.\n+     * @param session the native segment memory session.\n+     * @return a native segment with the given address, size and memory session.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    @ForceInline\n+    static MemorySegment ofAddress(long address, long byteSize, MemorySession session) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n+        Objects.requireNonNull(session);\n+        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, null);\n+    }\n+\n+    \/**\n+     * Creates a native segment with the given size, address, and memory session.\n+     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n+     * where an address to some underlying region of memory is typically obtained from foreign code\n+     * (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided memory session.\n+     * <p>\n+     * The provided cleanup action (if any) will be invoked <em>after<\/em> the provided session is closed.\n+     * <p>\n@@ -1104,0 +1136,1 @@\n+     * @param cleanupAction the custom cleanup action to be associated to the returned segment (can be null).\n@@ -1108,1 +1141,1 @@\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n@@ -1114,1 +1147,1 @@\n-    static MemorySegment ofAddress(long address, long byteSize, MemorySession session) {\n+    static MemorySegment ofAddress(long address, long byteSize, MemorySession session, Runnable cleanupAction) {\n@@ -1118,1 +1151,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session, cleanupAction);\n@@ -1122,1 +1155,6 @@\n-     * Creates a native segment with the given layout.\n+     * Creates a native segment with the given layout and memory session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n+     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n@@ -1128,7 +1166,0 @@\n-     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n-     * memory session. As such, the off-heap region which backs the returned segment is\n-     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n-     * <p>\n-     * Native segments featuring deterministic deallocation can be obtained using the\n-     * {@link MemorySession#allocate(MemoryLayout)} method.\n-     * <p>\n@@ -1137,2 +1168,1 @@\n-     * MemorySession.openImplicit()\n-     *         .allocate(layout.bytesSize(), layout.bytesAlignment());\n+     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), session);\n@@ -1144,0 +1174,1 @@\n+     * @param session the session to which the returned segment is associated.\n@@ -1145,1 +1176,3 @@\n-     * @see MemorySession#allocate(MemoryLayout)\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n@@ -1147,1 +1180,2 @@\n-    static MemorySegment allocateNative(MemoryLayout layout) {\n+    static MemorySegment allocateNative(MemoryLayout layout, MemorySession session) {\n+        Objects.requireNonNull(session);\n@@ -1149,1 +1183,1 @@\n-        return allocateNative(layout.byteSize(), layout.byteAlignment());\n+        return allocateNative(layout.byteSize(), layout.byteAlignment(), session);\n@@ -1153,1 +1187,6 @@\n-     * Creates a native segment with the given size (in bytes).\n+     * Creates a native segment with the given size (in bytes) and memory session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n+     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n@@ -1159,7 +1198,0 @@\n-     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n-     * memory session. As such, the off-heap region which backs the returned segment is\n-     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n-     * <p>\n-     * Native segments featuring deterministic deallocation can be obtained using the\n-     * {@link MemorySession#allocate(long)} method.\n-     * <p>\n@@ -1168,2 +1200,1 @@\n-     * MemorySession.openImplicit()\n-     *     .allocate(byteSize, 1)\n+     * allocateNative(bytesSize, 1, session);\n@@ -1173,2 +1204,0 @@\n-     * <p>\n-     * This method corresponds to the {@link ByteBuffer#allocateDirect(int)} method and has similar behavior.\n@@ -1177,0 +1206,1 @@\n+     * @param session the session to which the returned segment is associated.\n@@ -1179,2 +1209,3 @@\n-     * @see ByteBuffer#allocateDirect(int)\n-     * @see MemorySession#allocate(long)\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n@@ -1182,2 +1213,2 @@\n-    static MemorySegment allocateNative(long byteSize) {\n-        return allocateNative(byteSize, 1L);\n+    static MemorySegment allocateNative(long byteSize, MemorySession session) {\n+        return allocateNative(byteSize, 1, session);\n@@ -1187,1 +1218,6 @@\n-     * Creates a native segment with the given size (in bytes) and alignment (in bytes).\n+     * Creates a native segment with the given size (in bytes), alignment (in bytes) and session.\n+     * <p>\n+     * Clients are responsible for ensuring that the memory session associated with the returned segment is\n+     * closed when segments are no longer in use. Failure to do so will result in off-heap memory leaks. As an\n+     * alternative, an {@linkplain MemorySession#implicit() implicitly closed} session can be used, allowing\n+     * the returned segment to be automatically released some unspecified time after the session is no longer referenced.\n@@ -1193,13 +1229,0 @@\n-     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n-     * memory session. As such, the off-heap region which backs the returned segment is\n-     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n-     * <p>\n-     * Native segments featuring deterministic deallocation can be obtained using the\n-     * {@link MemorySession#allocate(long,long)} method.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemorySession.openImplicit()\n-     *     .allocate(byteSize, byteAlignment)\n-     * }\n-     * <p>\n@@ -1210,0 +1233,1 @@\n+     * @param session the scope to which the returned segment is associated.\n@@ -1212,2 +1236,4 @@\n-     * is not a power of 2.\n-     * @see MemorySession#allocate(long, long)\n+     *                                  is not a power of 2.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n@@ -1215,1 +1241,2 @@\n-    static MemorySegment allocateNative(long byteSize, long byteAlignment) {\n+    static MemorySegment allocateNative(long byteSize, long byteAlignment, MemorySession session) {\n+        Objects.requireNonNull(session);\n@@ -1217,2 +1244,1 @@\n-        return MemorySession.openImplicit()\n-                .allocate(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":98,"deletions":72,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.ref.Cleaner;\n-import java.util.Objects;\n-\n@@ -32,2 +29,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.Utils;\n@@ -35,0 +30,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -37,7 +33,1 @@\n- * A memory session manages the lifecycle of one or more resources. Resources (e.g. {@link MemorySegment}) associated\n- * with a memory session can only be accessed while the memory session is {@linkplain #isAlive() alive},\n- * and by the {@linkplain #ownerThread() thread} associated with the memory session (if any).\n- * <p>\n- * Memory sessions can be closed. When a memory session is closed, it is no longer {@linkplain #isAlive() alive},\n- * and subsequent operations on resources associated with that session (e.g. attempting to access a {@link MemorySegment} instance)\n- * will fail with {@link IllegalStateException}.\n+ * A memory session manages the lifecycle of memory segments.\n@@ -45,6 +35,2 @@\n- * A memory session is associated with one or more {@linkplain #addCloseAction(Runnable) close actions}. Close actions\n- * can be used to specify the cleanup code that must run when a given resource (or set of resources) is no longer in use.\n- * When a memory session is closed, the {@linkplain #addCloseAction(Runnable) close actions}\n- * associated with that session are executed (in unspecified order). For instance, closing the memory session associated with\n- * one or more {@linkplain MemorySession#allocate(long, long) native memory segments} results in releasing\n- * the off-heap memory backing said segments.\n+ * Segments associated with a memory session can only be accessed while the session is {@linkplain #isAlive() alive},\n+ * and by the {@linkplain #isOwnedBy(Thread) thread} associated with the session (if any).\n@@ -52,3 +38,4 @@\n- * The {@linkplain #global() global session} is a memory session that cannot be closed.\n- * As a result, resources associated with the global session are never released. Examples of resources associated with\n- * the global memory session are {@linkplain MemorySegment#ofArray(int[]) heap segments}.\n+ * Memory sessions can be closed, either explicitly (i.e. using an {@linkplain Arena arena}) or implicitly, by the garbage\n+ * collector. When a memory session is closed, it is no longer {@linkplain #isAlive() alive}, and subsequent operations\n+ * on the segments associated with that session (e.g. {@link MemorySegment#get(ValueLayout.OfInt, long)})\n+ * will fail with {@link IllegalStateException}.\n@@ -56,1 +43,1 @@\n- * <h2 id = \"thread-confinement\">Thread confinement<\/h2>\n+ * <h2 id = \"thread-confinement\">Safety and thread-confinement<\/h2>\n@@ -58,1 +45,15 @@\n- * Memory sessions can be divided into two categories: <em>thread-confined<\/em> memory sessions, and <em>shared<\/em>\n+ * Memory sessions provide strong temporal safety guarantees: a memory segment associated with a session cannot be accessed\n+ * <em>after<\/em> the session has been closed. The costs associated with maintaining this safety invariant can vary greatly,\n+ * depending on how many threads have access to the memory segment associated to a memory session. For instance,\n+ * if a memory session is created and closed by one thread, and the segments it creates are only ever accessed by that very same\n+ * thread, it is easy to show that there cannot be situations where a memory segment is accessed <em>while<\/em> its\n+ * associated session is being closed.\n+ * <p>\n+ * Conversely, if a session creates segments that can be accessed by multiple threads, or if the session can be\n+ * closed by a thread other than the accessing thread, the situation is much more complex. For instance, it would\n+ * be possible for a segment to be accessed while its associated session is being closed, concurrently,\n+ * by another thread. Even in this case, memory sessions provide strong temporal safety guarantees, but doing\n+ * so can incur in a higher performance impact: when closing a memory session the Java runtime has to determine\n+ * that no segment associated with that session is being accessed.\n+ * <p>\n+ * For this reason, memory sessions can be divided into two categories: <em>thread-confined<\/em> memory sessions, and <em>shared<\/em>\n@@ -62,1 +63,1 @@\n- * they are assigned an {@linkplain #ownerThread() owner thread}, typically the thread which initiated the creation operation.\n+ * they are assigned an {@linkplain #isOwnedBy(Thread) owner thread}, typically the thread which initiated the creation operation.\n@@ -71,1 +72,1 @@\n- * <h2 id=\"closeable\">Closeable memory sessions<\/h2>\n+ * <h2 id=\"implicit\">Implicitly closed sessions<\/h2>\n@@ -73,5 +74,5 @@\n- * When a session is associated with off-heap resources, it is often desirable for said resources to be released in a timely fashion,\n- * rather than waiting for the session to be deemed <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>\n- * by the garbage collector. In this scenario, a client might consider using a {@linkplain #isCloseable() <em>closeable<\/em>} memory session.\n- * Closeable memory sessions are memory sessions that can be {@linkplain MemorySession#close() closed} deterministically, as demonstrated\n- * in the following example:\n+ * Memory sessions that can be closed explicitly, while powerful, must be used with caution. These sessions must be closed\n+ * when no longer in use (via their associated arenas), by calling the {@link Arena#close} method. A failure to do so\n+ * might result in memory leaks. To mitigate this problem, clients can use {@linkplain #implicit() sessions} that\n+ * are closed implicitly, by the garbage collector. These sessions are closed at some unspecified time <em>after<\/em>\n+ * they become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n@@ -79,21 +80,5 @@\n- * {@snippet lang=java :\n- * try (MemorySession session = MemorySession.openConfined()) {\n- *    MemorySegment segment1 = session.allocate(100);\n- *    MemorySegment segment1 = session.allocate(200);\n- *    ...\n- * } \/\/ all memory released here\n- * }\n- *\n- * The above code creates a confined, closeable session. Then it allocates two segments associated with that session.\n- * When the session is {@linkplain #close() closed} (above, this is done implicitly, using the <em>try-with-resources construct<\/em>),\n- * all memory allocated within the session will be released\n- * <p>\n- * Closeable memory sessions, while powerful, must be used with caution. Closeable memory sessions must be closed\n- * when no longer in use, either explicitly (by calling the {@link #close} method), or implicitly (by wrapping the use of\n- * a closeable memory session in a <em>try-with-resources construct<\/em>). A failure to do so might result in memory leaks.\n- * To mitigate this problem, closeable memory sessions can be associated with a {@link Cleaner} instance,\n- * so that they are also closed automatically, once the session instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * This can be useful to allow for predictable, deterministic resource deallocation, while still preventing accidental\n- * native memory leaks. In case a client closes a memory session managed by a cleaner, no further action will be taken when\n- * the session becomes unreachable; that is, {@linkplain #addCloseAction(Runnable) close actions} associated with a\n- * memory session, whether managed or not, are called <em>exactly once<\/em>.\n+ * {@snippet lang = java:\n+ * MemorySegment segment = MemorySegment.allocateNative(100, MemorySession.implicit());\n+ * ...\n+ * segment = null; \/\/ the segment session is unreacheable here and becomes available for implicit close\n+ *}\n@@ -101,19 +86,2 @@\n- * <h2 id=\"non-closeable\">Non-closeable views<\/h2>\n- *\n- * There are situations in which it might not be desirable for a memory session to be reachable from one or\n- * more resources associated with it. For instance, an API might create a private memory session, and allocate\n- * a memory segment, and then expose one or more slices of this segment to its clients. Since the API's memory session\n- * would be reachable from the slices (using the {@link MemorySegment#session()} accessor), it might be possible for\n- * clients to compromise the API (e.g. by closing the session prematurely). To avoid leaking private memory sessions\n- * to untrusted clients, an API can instead return segments based on a non-closeable view of the session it created, as follows:\n- *\n- * {@snippet lang=java :\n- * MemorySession session = MemorySession.openConfined();\n- * MemorySession nonCloseableSession = session.asNonCloseable();\n- * MemorySegment segment = MemorySegment.allocateNative(100, nonCloseableSession);\n- * segment.session().close(); \/\/ throws\n- * session.close(); \/\/ok\n- * }\n- *\n- * In other words, only the owner of the original {@code session} object can close the session. External clients can only\n- * access the non-closeable session, and have no access to the underlying API session.\n+ * Sessions closed implicitly can be useful to manage long-lived segments, where timely deallocation is not critical,\n+ * or in unstructured cases where it is not easy to determine <em>when<\/em> a session should be closed.\n@@ -124,0 +92,1 @@\n+ * @see Arena\n@@ -132,1 +101,1 @@\n-public sealed interface MemorySession extends AutoCloseable, SegmentAllocator permits MemorySessionImpl, MemorySessionImpl.NonCloseableView {\n+public sealed interface MemorySession permits MemorySessionImpl {\n@@ -140,1 +109,2 @@\n-     * {@return {@code true}, if this session is a closeable memory session}.\n+     * {@return test if the provided thread is the owner thread associated with this memory session}\n+     * @param thread the thread to be compared against this session's owner thread.\n@@ -142,7 +112,1 @@\n-    boolean isCloseable();\n-\n-    \/**\n-     * {@return the owner thread associated with this memory session, or {@code null} if this session is shared\n-     * across multiple threads}\n-     *\/\n-    Thread ownerThread();\n+    boolean isOwnedBy(Thread thread);\n@@ -157,153 +121,2 @@\n-     * Adds a custom cleanup action which will be executed when the memory session is closed.\n-     * The order in which custom cleanup actions are invoked once the memory session is closed is unspecified.\n-     * @apiNote The provided action should not keep a strong reference to this memory session, so that implicitly\n-     * closed sessions can be handled correctly by a {@link Cleaner} instance.\n-     * @param runnable the custom cleanup action to be associated with this memory session.\n-     * @throws IllegalStateException if this memory session is not {@linkplain #isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain #ownerThread() owning} this memory session.\n-     *\/\n-    void addCloseAction(Runnable runnable);\n-\n-    \/**\n-     * Closes this memory session. If this operation completes without exceptions, this session\n-     * will be marked as <em>not alive<\/em>, the {@linkplain #addCloseAction(Runnable) close actions} associated\n-     * with this session will be executed, and all the resources associated with this session will be released.\n-     *\n-     * @apiNote This operation is not idempotent; that is, closing an already closed memory session <em>always<\/em> results in an\n-     * exception being thrown. This reflects a deliberate design choice: memory session state transitions should be\n-     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n-     * logic.\n-     *\n-     * @see MemorySession#isAlive()\n-     *\n-     * @throws IllegalStateException if this memory session is not {@linkplain #isAlive() alive}.\n-     * @throws IllegalStateException if this session is {@linkplain #whileAlive(Runnable) kept alive} by another client.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain #ownerThread() owning} this memory session.\n-     * @throws UnsupportedOperationException if this memory session is not {@linkplain #isCloseable() closeable}.\n-     *\/\n-    void close();\n-\n-    \/**\n-     * Returns a non-closeable view of this memory session. If this session is {@linkplain #isCloseable() non-closeable},\n-     * this session is returned. Otherwise, this method returns a non-closeable view of this memory session.\n-     * @apiNote a non-closeable view of a memory session {@code S} keeps {@code S} reachable. As such, {@code S}\n-     * cannot be closed implicitly (e.g. by a {@link Cleaner}) as long as one or more non-closeable views of {@code S}\n-     * are reachable.\n-     * @return a non-closeable view of this memory session.\n-     *\/\n-    MemorySession asNonCloseable();\n-\n-    \/**\n-     * Compares the specified object with this memory session for equality. Returns {@code true} if and only if the specified\n-     * object is also a memory session, and it refers to the same memory session as this memory session.\n-     * {@linkplain #asNonCloseable() A non-closeable view} {@code V} of a memory session {@code S} is considered\n-     * equal to {@code S}.\n-     *\n-     * @param that the object to be compared for equality with this memory session.\n-     * @return {@code true} if the specified object is equal to this memory session.\n-     *\/\n-    @Override\n-    boolean equals(Object that);\n-\n-    \/**\n-     * {@return the hash code value for this memory session}\n-     *\/\n-    @Override\n-    int hashCode();\n-\n-     \/**\n-     * Creates a native memory segment with the given size (in bytes), alignment constraint (in bytes) associated with\n-     * this memory session. The {@link MemorySegment#address()} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n-     * of the returned segment will be aligned according the provided alignment constraint.\n-     * <p>\n-     * A client is responsible for ensuring that this memory session is closed when the\n-     * segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n-     * <p>\n-     * The off-heap region of memory backing the returned native memory segment is initialized to zero.\n-     *\n-     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n-     * is not a power of 2.\n-     * @throws IllegalStateException if this session is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} this session.\n-     * @see MemorySegment#allocateNative(long, long)\n-     *\/\n-    @Override\n-    default MemorySegment allocate(long byteSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, this);\n-    }\n-\n-    \/**\n-     * Creates a new closeable, thread-confined memory session.\n-     * <p>\n-     * The returned memory session is confined to the current thread.\n-     * <p>\n-     * The returned memory session <em>must<\/em> eventually be {@linkplain #close() closed}\n-     * to prevent memory leaks.\n-     *\n-     * @return a new closeable, thread-confined memory session\n-     *\/\n-    static MemorySession openConfined() {\n-        return MemorySessionImpl.createConfined(Thread.currentThread(), null);\n-    }\n-\n-    \/**\n-     * Creates a new closeable, thread-confined memory session, managed by\n-     * the provided {@code cleaner}.\n-     * <p>\n-     * The returned memory session is confined to the current thread.\n-     *\n-     * @param cleaner the cleaner to be associated with the returned memory session\n-     * @return a new closeable thread-confined memory session, managed by the provided {@code cleaner}\n-     *\/\n-    static MemorySession openConfined(Cleaner cleaner) {\n-        Objects.requireNonNull(cleaner);\n-        return MemorySessionImpl.createConfined(Thread.currentThread(), cleaner);\n-    }\n-\n-    \/**\n-     * Creates a new closeable memory session that can be shared across threads.\n-     * <p>\n-     * The returned memory session can be used by any thread. Users are responsible for\n-     * assuring thread-safety across threads that use objects associated with this memory session.\n-     * <p>\n-     * The returned memory session <em>must<\/em> eventually be {@linkplain #close() closed}\n-     * to prevent memory leaks.\n-     *\n-     * @return a new closeable memory session that can be shared across threads\n-     *\/\n-    static MemorySession openShared() {\n-        return MemorySessionImpl.createShared(null);\n-    }\n-\n-    \/**\n-     * Creates a new closeable memory session that can be shared across threads,\n-     * managed by the provided {@code cleaner}.\n-     * <p>\n-     * The returned memory session can be used by any thread. Users are responsible for\n-     * assuring thread-safety across threads that use objects associated with this memory session.\n-     *\n-     * @param cleaner the cleaner to be associated with the returned memory session\n-     * @return a new closeable memory session that can be shared across threads, managed\n-     * by the provided {@code cleaner}\n-     *\/\n-    static MemorySession openShared(Cleaner cleaner) {\n-        Objects.requireNonNull(cleaner);\n-        return MemorySessionImpl.createShared(cleaner);\n-    }\n-\n-    \/**\n-     * Creates a new non-closeable memory session that can be shared across threads,\n-     * manage by a private {@link Cleaner} instance.\n-     * <p>\n-     * This is equivalent to (but likely more efficient than) the following code:\n-     * {@snippet lang=java :\n-     * openShared(Cleaner.create()).asNonCloseable();\n-     * }\n+     * Creates a new memory session that is closed, implicitly, by the garbage collector.\n+     * The returned session can be shared across threads.\n@@ -311,2 +124,1 @@\n-     * @return a new closeable memory session that can be shared across threads, managed\n-     * by a private {@link Cleaner} instance\n+     * @return a new memory session that is closed, implicitly, by the garbage collector.\n@@ -314,2 +126,2 @@\n-    static MemorySession openImplicit() {\n-        return MemorySessionImpl.createImplicit();\n+    static MemorySession implicit() {\n+        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":48,"deletions":236,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-import jdk.internal.foreign.ArenaAllocator;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.SlicingAllocator;\n@@ -48,4 +49,4 @@\n- *     <li>{@link #newNativeArena(MemorySession)} creates a more efficient arena-style allocator, where off-heap memory\n- *     is allocated in bigger blocks, which are then sliced accordingly to fit allocation requests;<\/li>\n- *     <li>{@link #implicitAllocator()} obtains an allocator which allocates native segment in independent,\n- *     {@linkplain MemorySession#openImplicit() implicit memory sessions}; and<\/li>\n+ *     <li>{@link #nativeAllocator(MemorySession)} obtains a simple allocator which can\n+ *     be used to allocate native segments;<\/li>\n+ *     <li>{@link #slicingAllocator(MemorySegment)} obtains an efficient slicing allocator, where memory\n+ *     is allocated by repeatedly slicing the provided memory segment;<\/li>\n@@ -348,41 +349,3 @@\n-     * Creates an unbounded arena-based allocator used to allocate native memory segments.\n-     * The returned allocator features a predefined block size and maximum arena size, and the segments it allocates\n-     * are associated with the provided memory session. Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * SegmentAllocator.newNativeArena(Long.MAX_VALUE, predefinedBlockSize, session);\n-     * }\n-     *\n-     * @param session the memory session associated with the segments allocated by the arena-based allocator.\n-     * @return a new unbounded arena-based allocator\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n-     *\/\n-    static SegmentAllocator newNativeArena(MemorySession session) {\n-        return newNativeArena(Long.MAX_VALUE, ArenaAllocator.DEFAULT_BLOCK_SIZE, session);\n-    }\n-\n-    \/**\n-     * Creates an arena-based allocator used to allocate native memory segments.\n-     * The returned allocator features a block size set to the specified arena size, and the native segments\n-     * it allocates are associated with the provided memory session. Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * SegmentAllocator.newNativeArena(arenaSize, arenaSize, session);\n-     * }\n-     *\n-     * @param arenaSize the size (in bytes) of the allocation arena.\n-     * @param session the memory session associated with the segments allocated by the arena-based allocator.\n-     * @return a new unbounded arena-based allocator\n-     * @throws IllegalArgumentException if {@code arenaSize <= 0}.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n-     *\/\n-    static SegmentAllocator newNativeArena(long arenaSize, MemorySession session) {\n-        return newNativeArena(arenaSize, arenaSize, session);\n-    }\n-\n-    \/**\n-     * Creates an arena-based allocator used to allocate native segments. The returned allocator features\n-     * the given block size {@code B} and the given arena size {@code A}, and the native segments\n-     * it allocates are associated with the provided memory session.\n+     * Returns a segment allocator which responds to allocation requests by returning consecutive slices\n+     * obtained from the provided segment. Each new allocation request will return a new slice starting at the\n+     * current offset (modulo additional padding to satisfy alignment constraint), with given size.\n@@ -390,18 +353,2 @@\n-     * The allocator arena is first initialized by {@linkplain MemorySession#allocate(long) allocating} a\n-     * native segment {@code S} of size {@code B}. The allocator then responds to allocation requests in one of the following ways:\n-     * <ul>\n-     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has a <em>free<\/em>\n-     *     slice {@code S'} which fits that allocation request, return that {@code S'}.\n-     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has no <em>free<\/em>\n-     *     slices which fits that allocation request, allocate a new segment {@code S'}, with size {@code B},\n-     *     and set {@code S = S'}; the allocator then tries to respond to the same allocation request again.\n-     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'},\n-     *     which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n-     * <\/ul>\n-     * <p>\n-     * This segment allocator can be useful when clients want to perform multiple allocation requests while avoiding the\n-     * cost associated with allocating a new off-heap memory region upon each allocation request.\n-     * <p>\n-     * The returned allocator might throw an {@link OutOfMemoryError} if the total memory allocated with this allocator\n-     * exceeds the arena size {@code A}, or the system capacity. Furthermore, the returned allocator is not thread safe.\n-     * Concurrent allocation needs to be guarded with synchronization primitives.\n+     * When the returned allocator cannot satisfy an allocation request, e.g. because a slice of the provided\n+     * segment with the requested size cannot be found, {@link MemorySegment#NULL} is returned instead.\n@@ -409,8 +356,2 @@\n-     * @param arenaSize the size (in bytes) of the allocation arena.\n-     * @param blockSize the block size associated with the arena-based allocator.\n-     * @param session the memory session associated with the segments returned by the arena-based allocator.\n-     * @return a new unbounded arena-based allocator\n-     * @throws IllegalArgumentException if {@code blockSize <= 0}, if {@code arenaSize <= 0} or if {@code arenaSize < blockSize}.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * @param segment the segment from which the returned allocator should slice from.\n+     * @return a new slicing allocator\n@@ -418,9 +359,3 @@\n-    static SegmentAllocator newNativeArena(long arenaSize, long blockSize, MemorySession session) {\n-        Objects.requireNonNull(session);\n-        if (blockSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid block size: \" + blockSize);\n-        }\n-        if (arenaSize <= 0 || arenaSize < blockSize) {\n-            throw new IllegalArgumentException(\"Invalid arena size: \" + arenaSize);\n-        }\n-        return new ArenaAllocator(blockSize, arenaSize, session);\n+    static SegmentAllocator slicingAllocator(MemorySegment segment) {\n+        Objects.requireNonNull(segment);\n+        return new SlicingAllocator(segment);\n@@ -454,4 +389,16 @@\n-     * Returns an allocator which allocates native segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n-     * Equivalent to (but likely more efficient than) the following code:\n-     * {@snippet lang=java :\n-     * SegmentAllocator implicitAllocator = MemorySegment::allocateNative;\n+     * Simple allocator used to allocate native segments. The returned allocator responds to an allocation request by\n+     * returning a native segment backed by a fresh off-heap region of memory, with given byte size and alignment constraint.\n+     * <p>\n+     * Each native segment obtained by the returned allocator is associated with the provided session. As such, the\n+     * off-heap region which backs the returned segment is freed when the session is closed.\n+     * <p>\n+     * The {@link MemorySegment#address()} of the native segments obtained by the returned allocator is the starting address of\n+     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n+     * of the native segment will be aligned according the provided alignment constraint.\n+     * <p>\n+     * The off-heap region of memory backing a native segment obtained by the returned allocator is initialized to zero.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * SegmentAllocator nativeAllocator = (byteSize, byteAlignment) ->\n+     *     MemorySegment.allocateNative(byteSize, byteAlignment, session);\n@@ -459,2 +406,2 @@\n-     *\n-     * @return an allocator which allocates native segments in independent {@linkplain MemorySession#openImplicit() implicit memory sessions}.\n+     * @param session the memory session associated with the segments returned by the native allocator.\n+     * @return a simple allocator used to allocate native segments.\n@@ -462,5 +409,3 @@\n-    static SegmentAllocator implicitAllocator() {\n-        final class Holder {\n-            static final SegmentAllocator IMPLICIT_ALLOCATOR = MemorySegment::allocateNative;\n-        }\n-        return Holder.IMPLICIT_ALLOCATOR;\n+    static SegmentAllocator nativeAllocator(MemorySession session) {\n+        Objects.requireNonNull(session);\n+        return (MemorySessionImpl)session;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":37,"deletions":92,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * with a {@linkplain  MemorySession memory session}; when the session is {@linkplain MemorySession#close() closed}, the library is unloaded:\n+ * with a {@linkplain  MemorySession memory session}; when the session is closed, the library is unloaded:\n@@ -68,2 +68,2 @@\n- * try (MemorySession session = MemorySession.openConfined()) {\n- *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\"); \/\/ libGL.so loaded here\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.session()); \/\/ libGL.so loaded here\n@@ -142,2 +142,2 @@\n-     * returned by this method is backed by a {@linkplain MemorySession#asNonCloseable() non-closeable}, shared memory\n-     * session which keeps the caller's class loader reachable. Therefore, libraries associated with the caller's class\n+     * returned by this method is backed by a shared memory session that is always alive and which keeps the caller's\n+     * class loader reachable. Therefore, libraries associated with the caller's class\n@@ -177,2 +177,1 @@\n-     * The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed},\n-     * if no other library lookup is still using it.\n+     * The library will be unloaded when the provided memory session is closed, if no other library lookup is still using it.\n@@ -204,1 +203,1 @@\n-     * in that library. The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed},\n+     * in that library. The library will be unloaded when the provided memory session is closed,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n- *    try (MemorySession session = MemorySession.openConfined()) {\n- *        VaList vaList = VaList.ofAddress(vaListSegment.address(), session);\n+ *    try (Arena arena = Arena.openConfined()) {\n+ *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.session());\n@@ -228,1 +228,1 @@\n-     * the lifecycle of the returned variable argument list: when the session is {@linkplain MemorySession#close() closed},\n+     * the lifecycle of the returned variable argument list: when the session is closed,\n@@ -241,1 +241,1 @@\n-     *                                       {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     *                                       {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n@@ -259,1 +259,1 @@\n-     * session, and will be released when the session is {@linkplain MemorySession#close closed}.\n+     * session, and will be released when the session is closed.\n@@ -273,1 +273,1 @@\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * {@linkplain MemorySession#isOwnedBy(Thread) owning} {@code session}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n- * {@snippet lang=java :\n- * MemorySegment segment = MemorySegment.allocateNative(10 * 4);\n+ * {@snippet lang = java:\n+ * MemorySegment segment = MemorySegment.allocateNative(10 * 4, MemorySession.implicit());\n@@ -49,1 +49,1 @@\n- * }\n+ *}\n@@ -53,4 +53,5 @@\n- * The off-heap memory backing the native segment will be released when the segment becomes\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>; this is similar to what happens\n- * with direct buffers created via {@link java.nio.ByteBuffer#allocateDirect(int)}. It is also possible to manage\n- * the lifecycle of allocated native segments more directly, as shown in a later section.\n+ * The segment is associated with a memory session that is {@linkplain java.lang.foreign.MemorySession#implicit() implicitly} closed,\n+ * by the garbage collector. As such, the off-heap memory backing the native segment will be released at some unspecified\n+ * point <em>after<\/em> the segment becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * This is similar to what happens with direct buffers created via {@link java.nio.ByteBuffer#allocateDirect(int)}.\n+ * It is also possible to manage the lifecycle of allocated native segments more directly, as shown in a later section.\n@@ -73,1 +74,1 @@\n- * This can be done, using the {@link java.lang.foreign.MemorySession} abstraction, as shown below:\n+ * This can be done, using the {@link java.lang.foreign.Arena} abstraction, as shown below:\n@@ -75,3 +76,3 @@\n- * {@snippet lang=java :\n- * try (MemorySession session = MemorySession.openConfined()) {\n- *     MemorySegment segment = session.allocate(10 * 4);\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     MemorySegment segment = arena.allocate(10 * 4);\n@@ -82,1 +83,1 @@\n- * }\n+ *}\n@@ -84,4 +85,6 @@\n- * This example is almost identical to the prior one; this time we first create a so called <em>memory session<\/em>,\n- * which is used to <em>bind<\/em> the life-cycle of the segment created immediately afterwards. Note the use of the\n- * <em>try-with-resources<\/em> construct: this idiom ensures that all the memory resources associated with the segment will be released\n- * at the end of the block, according to the semantics described in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n+ * This example is almost identical to the prior one; this time we first create an arena\n+ * which is used to allocate multiple native segments which share the same life-cycle. That is, all the segments\n+ * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.MemorySession memory session}.\n+ * Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures that the off-heap region of memory backing the\n+ * native segment will be released at the end of the block, according to the semantics described in Section {@jls 14.20.3}\n+ * of <cite>The Java Language Specification<\/cite>.\n@@ -121,3 +124,2 @@\n- * try (MemorySession session = MemorySession.openConfined()) {\n- *     MemorySegment cString = session.allocate(5 + 1);\n- *     cString.setUtf8String(0, \"Hello\");\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n@@ -137,4 +139,4 @@\n- * The {@link java.lang.foreign.MemorySegment} class also provides many useful methods for\n- * interacting with foreign code, such as converting Java strings\n- * {@linkplain java.lang.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} zero-terminated, UTF-8 strings and\n- * {@linkplain java.lang.foreign.MemorySegment#getUtf8String(long) back}, as demonstrated in the above example.\n+ * The {@link java.lang.foreign.Arena} class also provides many useful methods for\n+ * interacting with foreign code, such as\n+ * {@linkplain java.lang.foreign.SegmentAllocator#allocateUtf8String(java.lang.String) converting} Java strings into\n+ * zero-terminated, UTF-8 strings, as demonstrated in the above example.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1064,1 +1064,1 @@\n-     *          {@linkplain MemorySession#ownerThread() owning} the\n+     *          {@linkplain MemorySession#isOwnedBy(Thread) owning} the\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.SegmentAllocator;\n-\n-public final class ArenaAllocator implements SegmentAllocator {\n-\n-    public static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n-\n-    private MemorySegment segment;\n-\n-    private long sp = 0L;\n-    private long size = 0;\n-    private final long blockSize;\n-    private final long arenaSize;\n-    private final MemorySession session;\n-\n-    public ArenaAllocator(long blockSize, long arenaSize, MemorySession session) {\n-        this.blockSize = blockSize;\n-        this.arenaSize = arenaSize;\n-        this.session = session;\n-        this.segment = newSegment(blockSize, 1);\n-    }\n-\n-    MemorySegment trySlice(long byteSize, long byteAlignment) {\n-        long min = segment.address();\n-        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n-        if (segment.byteSize() - start < byteSize) {\n-            return null;\n-        } else {\n-            MemorySegment slice = segment.asSlice(start, byteSize);\n-            sp = start + byteSize;\n-            return slice;\n-        }\n-    }\n-\n-    private MemorySegment newSegment(long byteSize, long byteAlignment) {\n-        long allocatedSize = Utils.alignUp(byteSize, byteAlignment);\n-        if (size + allocatedSize > arenaSize) {\n-            throw new OutOfMemoryError();\n-        }\n-        size += allocatedSize;\n-        return session.allocate(byteSize, byteAlignment);\n-    }\n-\n-    @Override\n-    public MemorySegment allocate(long byteSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        MemorySessionImpl.toSessionImpl(session).checkValidState();\n-        \/\/ try to slice from current segment first...\n-        MemorySegment slice = trySlice(byteSize, byteAlignment);\n-        if (slice != null) {\n-            return slice;\n-        } else {\n-            long maxPossibleAllocationSize = byteSize + byteAlignment - 1;\n-            if (maxPossibleAllocationSize < 0) {\n-                throw new OutOfMemoryError();\n-            } else if (maxPossibleAllocationSize > blockSize) {\n-                \/\/ too big\n-                return newSegment(byteSize, byteAlignment);\n-            } else {\n-                \/\/ allocate a new segment and slice from there\n-                sp = 0L;\n-                segment = newSegment(blockSize, 1L);\n-                slice = trySlice(byteSize, byteAlignment);\n-                return slice;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+\n+public final class ArenaImpl implements Arena {\n+\n+    final MemorySessionImpl sessionImpl;\n+\n+    public ArenaImpl(MemorySessionImpl sessionImpl) {\n+        this.sessionImpl = sessionImpl;\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        return MemorySegment.allocateNative(byteSize, byteAlignment, session());\n+    }\n+\n+    @Override\n+    public MemorySession session() {\n+        return sessionImpl;\n+    }\n+\n+    @Override\n+    public void close() {\n+        sessionImpl.close();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -54,2 +54,2 @@\n-    public ConfinedSession(Thread owner, Cleaner cleaner) {\n-        super(owner, new ConfinedResourceList(), cleaner);\n+    public ConfinedSession(Thread owner) {\n+        super(owner, new ConfinedResourceList());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * The global, non-closeable, shared session. Similar to a shared session, but its {@link #close()} method throws unconditionally.\n+ * Adding new resources to the global session, does nothing: as the session can never become not-alive, there is nothing to track.\n+ * Acquiring and or releasing a memory session similarly does nothing.\n+ *\/\n+final class GlobalSession extends MemorySessionImpl {\n+\n+    final Object ref;\n+\n+    public GlobalSession(Object ref) {\n+        super(null, null);\n+        this.ref = ref;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public boolean isCloseable() {\n+        return false;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void acquire0() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    void addInternal(ResourceList.ResourceCleanup resource) {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public void justClose() {\n+        throw nonCloseable();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import sun.nio.ch.DirectBuffer;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+\n+\/**\n+ * This is an implicit, GC-backed memory session. Implicit sessions cannot be closed explicitly.\n+ * While it would be possible to model an implicit session as a non-closeable view of a shared\n+ * session, it is better to capture the fact that an implicit session is not just a non-closeable\n+ * view of some session which might be closeable. This is useful e.g. in the implementations of\n+ * {@link DirectBuffer#address()}, where obtaining an address of a buffer instance associated\n+ * with a potentially closeable session is forbidden.\n+ *\/\n+final class ImplicitSession extends SharedSession {\n+\n+    public ImplicitSession(Cleaner cleaner) {\n+        super();\n+        cleaner.register(this, resourceList);\n+    }\n+\n+    @Override\n+    public void release0() {\n+        Reference.reachabilityFence(this);\n+    }\n+\n+    @Override\n+    public void acquire0() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    public boolean isCloseable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void justClose() {\n+        throw nonCloseable();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ImplicitSession.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.nio.ch.DirectBuffer;\n@@ -45,1 +44,1 @@\n- * (this operation is triggered by {@link MemorySession#close()}). This bit is consulted prior\n+ * (this operation is triggered by {@link MemorySessionImpl#close()}). This bit is consulted prior\n@@ -57,1 +56,1 @@\n-        permits ConfinedSession, MemorySessionImpl.GlobalSessionImpl, SharedSession {\n+        permits ConfinedSession, GlobalSession, SharedSession {\n@@ -65,1 +64,1 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSessionImpl(null);\n+    public static final MemorySessionImpl GLOBAL = new GlobalSession(null);\n@@ -71,1 +70,0 @@\n-    final Cleaner.Cleanable cleanable;\n@@ -83,1 +81,0 @@\n-    @Override\n@@ -119,1 +116,1 @@\n-    protected MemorySessionImpl(Thread owner, ResourceList resourceList, Cleaner cleaner) {\n+    protected MemorySessionImpl(Thread owner, ResourceList resourceList) {\n@@ -122,2 +119,0 @@\n-        cleanable = (cleaner != null) ?\n-            cleaner.register(this, resourceList) : null;\n@@ -126,2 +121,2 @@\n-    public static MemorySession createConfined(Thread thread, Cleaner cleaner) {\n-        return new ConfinedSession(thread, cleaner);\n+    public static MemorySessionImpl createConfined(Thread thread) {\n+        return new ConfinedSession(thread);\n@@ -130,2 +125,2 @@\n-    public static MemorySession createShared(Cleaner cleaner) {\n-        return new SharedSession(cleaner);\n+    public static MemorySessionImpl createShared() {\n+        return new SharedSession();\n@@ -134,2 +129,2 @@\n-    public static MemorySessionImpl createImplicit() {\n-        return new ImplicitSession();\n+    public static MemorySessionImpl createImplicit(Cleaner cleaner) {\n+        return new ImplicitSession(cleaner);\n@@ -148,11 +143,0 @@\n-    @Override\n-    public final boolean equals(Object o) {\n-        return (o instanceof MemorySession other) &&\n-            toSessionImpl(other) == this;\n-    }\n-\n-    @Override\n-    public final int hashCode() {\n-        return super.hashCode();\n-    }\n-\n@@ -170,5 +154,1 @@\n-    \/**\n-     * Returns \"owner\" thread of this session.\n-     * @return owner thread (or null for a shared session)\n-     *\/\n-    public final Thread ownerThread() {\n+    public Thread ownerThread() {\n@@ -178,0 +158,11 @@\n+    public static boolean sameOwnerThread(MemorySession session1, MemorySession session2) {\n+        return MemorySessionImpl.toSessionImpl(session1).ownerThread() ==\n+                MemorySessionImpl.toSessionImpl(session2).ownerThread();\n+    }\n+\n+    @Override\n+    public final boolean isOwnedBy(Thread thread) {\n+        Objects.requireNonNull(thread);\n+        return owner == thread;\n+    }\n+\n@@ -186,6 +177,0 @@\n-    @Override\n-    public MemorySession asNonCloseable() {\n-        return isCloseable() ?\n-                new NonCloseableView(this) : this;\n-    }\n-\n@@ -194,2 +179,1 @@\n-        return session instanceof MemorySessionImpl sessionImpl ?\n-                sessionImpl : ((NonCloseableView)session).session;\n+        return (MemorySessionImpl)session;\n@@ -234,1 +218,0 @@\n-    @Override\n@@ -244,1 +227,0 @@\n-    @Override\n@@ -246,10 +228,2 @@\n-        try {\n-            justClose();\n-            if (cleanable != null) {\n-                cleanable.clean();\n-            } else {\n-                resourceList.cleanup();\n-            }\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n+        justClose();\n+        resourceList.cleanup();\n@@ -260,42 +234,0 @@\n-    \/**\n-     * The global, non-closeable, shared session. Similar to a shared session, but its {@link #close()} method throws unconditionally.\n-     * Adding new resources to the global session, does nothing: as the session can never become not-alive, there is nothing to track.\n-     * Acquiring and or releasing a memory session similarly does nothing.\n-     *\/\n-    static final class GlobalSessionImpl extends MemorySessionImpl {\n-\n-        final Object ref;\n-\n-        public GlobalSessionImpl(Object ref) {\n-            super(null, null ,null);\n-            this.ref = ref;\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public void release0() {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        public boolean isCloseable() {\n-            return false;\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public void acquire0() {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        void addInternal(ResourceList.ResourceCleanup resource) {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        public void justClose() {\n-            throw nonCloseable();\n-        }\n-    }\n-\n@@ -303,96 +235,1 @@\n-        return new GlobalSessionImpl(ref);\n-    }\n-\n-    \/**\n-     * This is an implicit, GC-backed memory session. Implicit sessions cannot be closed explicitly.\n-     * While it would be possible to model an implicit session as a non-closeable view of a shared\n-     * session, it is better to capture the fact that an implicit session is not just a non-closeable\n-     * view of some session which might be closeable. This is useful e.g. in the implementations of\n-     * {@link DirectBuffer#address()}, where obtaining an address of a buffer instance associated\n-     * with a potentially closeable session is forbidden.\n-     *\/\n-    static final class ImplicitSession extends SharedSession {\n-\n-        public ImplicitSession() {\n-            super(CleanerFactory.cleaner());\n-        }\n-\n-        @Override\n-        public void release0() {\n-            Reference.reachabilityFence(this);\n-        }\n-\n-        @Override\n-        public void acquire0() {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        public boolean isCloseable() {\n-            return false;\n-        }\n-\n-        @Override\n-        public void justClose() {\n-            throw nonCloseable();\n-        }\n-    }\n-\n-    \/**\n-     * This is a non-closeable view of another memory session. Instances of this class are used in resource session\n-     * accessors (see {@link MemorySegment#session()}). This class forwards all session methods to the underlying\n-     * \"root\" session implementation, and throws {@link UnsupportedOperationException} on close. This class contains\n-     * a strong reference to the original session, so even if the original session is dropped by the client\n-     * it would still be reachable by the GC, which is important if the session is implicitly closed.\n-     *\/\n-    public static final class NonCloseableView implements MemorySession {\n-        final MemorySessionImpl session;\n-\n-        public NonCloseableView(MemorySessionImpl session) {\n-            this.session = session;\n-        }\n-\n-        @Override\n-        public boolean isAlive() {\n-            return session.isAlive();\n-        }\n-\n-        @Override\n-        public boolean isCloseable() {\n-            return false;\n-        }\n-\n-        @Override\n-        public Thread ownerThread() {\n-            return session.ownerThread();\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            return session.equals(o);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return session.hashCode();\n-        }\n-\n-        @Override\n-        public void whileAlive(Runnable action) {\n-            session.whileAlive(action);\n-        }\n-\n-        @Override\n-        public MemorySession asNonCloseable() {\n-            return this;\n-        }\n-\n-        @Override\n-        public void addCloseAction(Runnable runnable) {\n-            session.addCloseAction(runnable);\n-        }\n-\n-        @Override\n-        public void close() {\n-            throw new UnsupportedOperationException();\n-        }\n+        return new GlobalSession(ref);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":26,"deletions":189,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.MemorySessionImpl.ResourceList.ResourceCleanup;\n@@ -140,0 +141,11 @@\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySession session, Runnable action) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        if (action == null) {\n+            sessionImpl.checkValidState();\n+        } else {\n+            sessionImpl.addCloseAction(action);\n+        }\n+        return new NativeMemorySegmentImpl(min, byteSize, false, session);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-sealed class SharedSession extends MemorySessionImpl permits MemorySessionImpl.ImplicitSession {\n+sealed class SharedSession extends MemorySessionImpl permits ImplicitSession {\n@@ -47,2 +47,2 @@\n-    SharedSession(Cleaner cleaner) {\n-        super(null, new SharedResourceList(), cleaner);\n+    SharedSession() {\n+        super(null, new SharedResourceList());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+\n+public final class SlicingAllocator implements SegmentAllocator {\n+\n+    public static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n+\n+    private final MemorySegment segment;\n+    private final long maxAlign;\n+\n+    private long sp = 0L;\n+\n+    public SlicingAllocator(MemorySegment segment) {\n+        this.segment = segment;\n+        this.maxAlign = ((AbstractMemorySegmentImpl)segment).maxAlignMask();\n+    }\n+\n+    MemorySegment trySlice(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        if (segment.byteSize() - start < byteSize) {\n+            return MemorySegment.NULL;\n+        } else {\n+            MemorySegment slice = segment.asSlice(start, byteSize);\n+            sp = start + byteSize;\n+            return slice;\n+        }\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment, maxAlign);\n+        \/\/ try to slice from current segment first...\n+        return trySlice(byteSize, byteAlignment);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -182,0 +182,7 @@\n+    public static void checkAllocationSizeAndAlign(long byteSize, long byteAlignment, long maxAlignment) {\n+        checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        if (maxAlignment != 0 && byteAlignment > maxAlignment) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + byteAlignment + \" > \" + maxAlignment);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -220,1 +221,1 @@\n-            session().close();\n+            throw new UnsupportedOperationException();\n@@ -227,2 +228,7 @@\n-            MemorySession scope = MemorySession.openConfined();\n-            return new Context(SegmentAllocator.newNativeArena(size, scope), scope);\n+            Arena arena = Arena.openConfined();\n+            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.session())), arena.session()) {\n+                @Override\n+                public void close() {\n+                    arena.close();\n+                }\n+            };\n@@ -249,2 +255,2 @@\n-            MemorySession scope = MemorySession.openConfined();\n-            return new Context(null, scope) {\n+            Arena arena = Arena.openConfined();\n+            return new Context(null, arena.session()) {\n@@ -253,0 +259,5 @@\n+\n+                @Override\n+                public void close() {\n+                    arena.close();\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -135,2 +135,2 @@\n-        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n-        ms.session().addCloseAction(() -> UNSAFE.freeMemory(ptr));\n+        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n+                MemorySession.implicit(), () -> UNSAFE.freeMemory(ptr));\n@@ -401,1 +401,1 @@\n-        MemorySegment copy = segment.session().allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n@@ -448,2 +448,2 @@\n-            this.gpRegs = session.allocate(LAYOUT_GP_REGS);\n-            this.fpRegs = session.allocate(LAYOUT_FP_REGS);\n+            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, session);\n+            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, session);\n@@ -542,1 +542,1 @@\n-            MemorySegment vaListSegment = session.allocate(LAYOUT);\n+            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, session);\n@@ -547,1 +547,1 @@\n-                stackArgsSegment = session.allocate(stackArgsSize, 16);\n+                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, session);\n@@ -566,2 +566,2 @@\n-            assert gpRegs.session().ownerThread() == vaListSegment.session().ownerThread();\n-            assert fpRegs.session().ownerThread() == vaListSegment.session().ownerThread();\n+            assert MemorySessionImpl.sameOwnerThread(gpRegs.session(), vaListSegment.session());\n+            assert MemorySessionImpl.sameOwnerThread(fpRegs.session(), vaListSegment.session());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-            MemorySegment segment = session.allocate(allocationSize);\n+            MemorySegment segment = MemorySegment.allocateNative(allocationSize, session);\n@@ -236,1 +236,1 @@\n-                            MemorySegment copy = session.allocate(arg.layout);\n+                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n-        base.session().addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(),\n+                MemorySession.implicit(), () -> U.freeMemory(ptr));\n@@ -339,1 +339,1 @@\n-        MemorySegment copy = segment.session().allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n@@ -373,1 +373,1 @@\n-            this.reg_save_area = session.allocate(LAYOUT_REG_SAVE_AREA);\n+            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, session);\n@@ -452,1 +452,1 @@\n-            MemorySegment vaListSegment = session.allocate(LAYOUT);\n+            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, session);\n@@ -457,1 +457,1 @@\n-                stackArgsSegment = session.allocate(stackArgsSize, 16);\n+                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, session);\n@@ -478,1 +478,1 @@\n-            assert reg_save_area.session().ownerThread() == vaListSegment.session().ownerThread();\n+            assert MemorySessionImpl.sameOwnerThread(reg_save_area.session(), vaListSegment.session());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            MemorySegment segment = session.allocate(VA_SLOT_SIZE_BYTES * args.size());\n+            MemorySegment segment = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size(), session);\n@@ -227,1 +227,1 @@\n-                            MemorySegment copy = session.allocate(arg.layout);\n+                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout);\n+            MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -385,1 +385,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1L);\n+            MemorySegment segment = MemorySegment.allocateNative(1L, MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.Arena;\n@@ -53,6 +54,6 @@\n-        try (MemorySession session0 = MemorySession.openConfined()) {\n-            callFunc(loadLibrary(session0));\n-            try (MemorySession session1 = MemorySession.openConfined()) {\n-                callFunc(loadLibrary(session1));\n-                try (MemorySession session2 = MemorySession.openConfined()) {\n-                    callFunc(loadLibrary(session2));\n+        try (Arena arena0 = Arena.openConfined()) {\n+            callFunc(loadLibrary(arena0.session()));\n+            try (Arena arena1 = Arena.openConfined()) {\n+                callFunc(loadLibrary(arena1.session()));\n+                try (Arena arena2 = Arena.openConfined()) {\n+                    callFunc(loadLibrary(arena2.session()));\n@@ -67,2 +68,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            addr = loadLibrary(session);\n+        try (Arena arena = Arena.openConfined()) {\n+            addr = loadLibrary(arena.session());\n@@ -118,2 +119,2 @@\n-                try (MemorySession session = MemorySession.openConfined()) {\n-                    callFunc(loadLibrary(session));\n+                try (Arena arena = Arena.openConfined()) {\n+                    callFunc(loadLibrary(arena.session()));\n@@ -127,2 +128,2 @@\n-        MemorySession session = MemorySession.openShared();\n-        MemorySegment addr = loadLibrary(session);\n+        Arena arena = Arena.openShared();\n+        MemorySegment addr = loadLibrary(arena.session());\n@@ -135,1 +136,1 @@\n-                session.close();\n+                arena.close();\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-            return LINKER.upcallStub(target, descriptor, MemorySession.openImplicit());\n+            return LINKER.upcallStub(target, descriptor, MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -42,0 +43,2 @@\n+import java.util.stream.Stream;\n+\n@@ -58,2 +61,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            segment = session.allocate(POINT);\n+        try (Arena arena = Arena.openConfined()) {\n+            segment = MemorySegment.allocateNative(POINT, arena.session());\n@@ -74,0 +77,6 @@\n+        record Allocation(Arena drop, MemorySegment segment) {\n+            static Allocation of(MemoryLayout layout) {\n+                Arena arena = Arena.openShared();\n+                return new Allocation(arena, MemorySegment.allocateNative(layout, arena.session()));\n+            }\n+        }\n@@ -75,7 +84,7 @@\n-            MemorySegment[] segments = new MemorySegment[]{\n-                    MemorySession.openShared().allocate(POINT),\n-                    MemorySession.openShared().allocate(POINT),\n-                    MemorySession.openShared().allocate(POINT),\n-                    MemorySession.openShared().allocate(POINT),\n-                    MemorySession.openShared().allocate(POINT),\n-                    MemorySession.openShared().allocate(POINT)\n+            Allocation[] allocations = new Allocation[]{\n+                    Allocation.of(POINT),\n+                    Allocation.of(POINT),\n+                    Allocation.of(POINT),\n+                    Allocation.of(POINT),\n+                    Allocation.of(POINT),\n+                    Allocation.of(POINT)\n@@ -84,1 +93,1 @@\n-            segments[i].session().close();\n+            allocations[i].drop().close();\n@@ -87,1 +96,1 @@\n-                    assertFalse(segments[j].session().isAlive());\n+                    assertFalse(allocations[j].drop().session().isAlive());\n@@ -89,1 +98,1 @@\n-                    assertTrue(segments[j].session().isAlive());\n+                    assertTrue(allocations[j].drop().session().isAlive());\n@@ -93,1 +102,1 @@\n-                handle.invokeWithArguments(segments);\n+                handle.invokeWithArguments(Stream.of(allocations).map(Allocation::segment).toArray());\n@@ -100,1 +109,1 @@\n-                    segments[j].session().close(); \/\/ should succeed!\n+                    allocations[j].drop().close(); \/\/ should succeed!\n@@ -109,2 +118,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            list = VaList.make(b -> b.addVarg(C_INT, 42), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n@@ -123,1 +132,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (Arena arena = Arena.openConfined()) {\n@@ -125,1 +134,1 @@\n-            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n+            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n@@ -143,3 +152,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), session);\n-            handle.invokeExact(list.segment(), sessionChecker(session));\n+        try (Arena arena = Arena.openConfined()) {\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.session());\n+            handle.invokeExact(list.segment(), sessionChecker(arena));\n@@ -155,3 +164,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(POINT);\n-            handle.invokeExact(segment, sessionChecker(session));\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(POINT, arena.session());\n+            handle.invokeExact(segment, sessionChecker(arena));\n@@ -167,1 +176,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (Arena arena = Arena.openConfined()) {\n@@ -169,2 +178,2 @@\n-            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n-            handle.invokeExact(upcall, sessionChecker(session));\n+            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.session());\n+            handle.invokeExact(upcall, sessionChecker(arena));\n@@ -174,1 +183,1 @@\n-    MemorySegment sessionChecker(MemorySession session) {\n+    MemorySegment sessionChecker(Arena arena) {\n@@ -177,3 +186,3 @@\n-                    MethodType.methodType(void.class, MemorySession.class));\n-            handle = handle.bindTo(session);\n-            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.openImplicit());\n+                    MethodType.methodType(void.class, Arena.class));\n+            handle = handle.bindTo(arena);\n+            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n@@ -185,1 +194,1 @@\n-    static void checkSession(MemorySession session) {\n+    static void checkSession(Arena arena) {\n@@ -187,1 +196,1 @@\n-            session.close();\n+            arena.close();\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":42,"deletions":33,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-            try (var session = MemorySession.openConfined()) {\n-                MemorySegment buf = session.allocate(s1.length() + s2.length() + 1);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment buf = arena.allocate(s1.length() + s2.length() + 1);\n@@ -201,1 +201,1 @@\n-                MemorySegment other = session.allocateUtf8String(s2);\n+                MemorySegment other = arena.allocateUtf8String(s2);\n@@ -207,3 +207,3 @@\n-            try (var session = MemorySession.openConfined()) {\n-                MemorySegment ns1 = session.allocateUtf8String(s1);\n-                MemorySegment ns2 = session.allocateUtf8String(s2);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment ns1 = arena.allocateUtf8String(s1);\n+                MemorySegment ns2 = arena.allocateUtf8String(s2);\n@@ -215,2 +215,2 @@\n-            try (var session = MemorySession.openConfined()) {\n-                MemorySegment s = session.allocateUtf8String(msg);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment s = arena.allocateUtf8String(msg);\n@@ -222,2 +222,2 @@\n-            try (var session = MemorySession.openConfined()) {\n-                MemorySegment s = session.allocateUtf8String(msg);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment s = arena.allocateUtf8String(msg);\n@@ -229,2 +229,2 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n-                MemorySegment time = session.allocate(8);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment time = arena.allocate(8);\n@@ -278,2 +278,2 @@\n-            try (var session = MemorySession.openConfined()) {\n-                MemorySegment nativeArr = session.allocateArray(C_INT, arr);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment nativeArr = arena.allocateArray(C_INT, arr);\n@@ -282,1 +282,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.session());\n@@ -301,2 +301,2 @@\n-            try (var session = MemorySession.openConfined()) {\n-                MemorySegment formatStr = session.allocateUtf8String(format);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment formatStr = arena.allocateUtf8String(format);\n@@ -304,1 +304,1 @@\n-                        args.stream().map(a -> a.nativeValue(session)).toArray());\n+                        args.stream().map(a -> a.nativeValue(arena)).toArray());\n@@ -309,3 +309,3 @@\n-            try (var session = MemorySession.openConfined()) {\n-                MemorySegment formatStr = session.allocateUtf8String(format);\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, session)), session);\n+            try (var arena = Arena.openConfined()) {\n+                MemorySegment formatStr = arena.allocateUtf8String(format);\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.session());\n@@ -387,1 +387,1 @@\n-    enum PrintfArg implements BiConsumer<VaList.Builder, MemorySession> {\n+    enum PrintfArg implements BiConsumer<VaList.Builder, Arena> {\n@@ -389,3 +389,3 @@\n-        INTEGRAL(int.class, C_INT, \"%d\", session -> 42, 42, VaList.Builder::addVarg),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", session -> {\n-            return session.allocateUtf8String(\"str\");\n+        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42, VaList.Builder::addVarg),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> {\n+            return arena.allocateUtf8String(\"str\");\n@@ -393,2 +393,2 @@\n-        CHAR(byte.class, C_CHAR, \"%c\", session -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", session ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n+        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n@@ -399,1 +399,1 @@\n-        final Function<MemorySession, ?> nativeValueFactory;\n+        final Function<Arena, ?> nativeValueFactory;\n@@ -404,1 +404,1 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<MemorySession, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n@@ -415,2 +415,2 @@\n-        public void accept(VaList.Builder builder, MemorySession session) {\n-            builderCall.build(builder, layout, nativeValueFactory.apply(session));\n+        public void accept(VaList.Builder builder, Arena arena) {\n+            builderCall.build(builder, layout, nativeValueFactory.apply(arena));\n@@ -423,2 +423,2 @@\n-        public Object nativeValue(MemorySession session) {\n-            return nativeValueFactory.apply(session);\n+        public Object nativeValue(Arena arena) {\n+            return nativeValueFactory.apply(arena);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -96,1 +97,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -115,1 +116,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -136,1 +137,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -193,2 +194,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment seg = session.allocate(ValueLayout.JAVA_INT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n@@ -204,2 +205,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment seg = session.allocate(ValueLayout.JAVA_INT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.session());\n@@ -213,1 +214,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -256,1 +257,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -294,1 +295,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -333,1 +334,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -376,1 +377,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -110,1 +111,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n@@ -129,2 +130,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(layout.byteSize() + 1, layout.byteSize());\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.session());\n@@ -138,2 +139,3 @@\n-        MemorySegment segment = MemorySession.openConfined().allocate(layout);\n-        segment.session().close();\n+        Arena arena = Arena.openConfined();\n+        MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n+        arena.close();\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -65,1 +66,0 @@\n-import java.util.Arrays;\n@@ -188,2 +188,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(tuples);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.session());;\n@@ -233,1 +233,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -235,1 +235,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n@@ -239,1 +239,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -241,1 +241,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.session());\n@@ -252,1 +252,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -255,1 +255,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.session());\n@@ -260,1 +260,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -263,1 +263,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n@@ -274,3 +274,3 @@\n-        try (MemorySession session = MemorySession.openConfined();\n-             FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, session);\n+        Arena arena = Arena.openConfined();\n+        try (FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.session());\n@@ -278,1 +278,1 @@\n-            segment.session().close();\n+            arena.close();\n@@ -293,1 +293,1 @@\n-            try (MemorySession session = MemorySession.openConfined();\n+            try (Arena arena = Arena.openConfined();\n@@ -296,1 +296,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), session);\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.session());\n@@ -304,1 +304,1 @@\n-            try (MemorySession session = MemorySession.openConfined();\n+            try (Arena arena = Arena.openConfined();\n@@ -307,1 +307,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), session);\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.session());\n@@ -325,1 +325,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -327,1 +327,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.session());\n@@ -363,2 +363,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(bytes);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n@@ -389,2 +389,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(bytes);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n@@ -423,2 +423,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(bytes);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.session());;\n@@ -436,2 +436,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(seq);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n@@ -474,2 +474,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(seq);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n@@ -485,2 +485,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            leaked = session.allocate(bytes);\n+        try (Arena arena = Arena.openConfined()) {\n+            leaked = MemorySegment.allocateNative(bytes, arena.session());;\n@@ -494,1 +494,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, MemorySession.openImplicit());\n+        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, MemorySession.implicit());\n@@ -504,1 +504,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, MemorySession.openImplicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, MemorySession.implicit());\n@@ -514,1 +514,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, MemorySession.openImplicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, MemorySession.implicit());\n@@ -526,1 +526,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -528,1 +528,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.session());\n@@ -536,1 +536,1 @@\n-            try (MemorySession session = MemorySession.openConfined();\n+            try (Arena arena = Arena.openConfined();\n@@ -538,1 +538,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, session);\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.session());\n@@ -550,1 +550,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -552,1 +552,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.session());\n@@ -562,1 +562,1 @@\n-        try (MemorySession session = MemorySession.openConfined();\n+        try (Arena arena = Arena.openConfined();\n@@ -564,1 +564,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, session);\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.session());\n@@ -579,1 +579,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, MemorySession.openImplicit());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, MemorySession.implicit());\n@@ -587,2 +587,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment nativeArray = session.allocate(bytes, 1);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.session());;\n@@ -600,2 +600,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment nativeArray = session.allocate(seq);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.session());;\n@@ -672,2 +672,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment ms = session.allocate(4, 1);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.session());;\n@@ -682,1 +682,2 @@\n-        MemorySegment s1 = MemorySession.openConfined().allocate(JAVA_INT);\n+        Arena arena = Arena.openConfined();\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.session());\n@@ -686,1 +687,1 @@\n-        s1.session().close();\n+        arena.close();\n@@ -691,2 +692,2 @@\n-    @Test(dataProvider = \"allSessions\")\n-    public void testIOOnSegmentBuffer(Supplier<MemorySession> sessionSupplier) throws IOException {\n+    @Test(dataProvider = \"closeableArenas\")\n+    public void closeableArenas(Supplier<Arena> arenaSupplier) throws IOException {\n@@ -695,1 +696,0 @@\n-        MemorySession session;\n@@ -697,2 +697,2 @@\n-            MemorySession scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n-            MemorySegment segment = session.allocate(10, 1);\n+            Arena arena = arenaSupplier.get()) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());;\n@@ -713,2 +713,2 @@\n-    @Test(dataProvider = \"closeableSessions\")\n-    public void testIOOnClosedSegmentBuffer(Supplier<MemorySession> sessionSupplier) throws IOException {\n+    @Test(dataProvider = \"closeableArenas\")\n+    public void testIOOnClosedSegmentBuffer(Supplier<Arena> arenaSupplier) throws IOException {\n@@ -717,0 +717,1 @@\n+        Arena arena = arenaSupplier.get();\n@@ -718,1 +719,1 @@\n-            MemorySegment segment = sessionSupplier.get().allocate(10);\n+            MemorySegment segment = MemorySegment.allocateNative(10, arena.session());\n@@ -723,1 +724,1 @@\n-            segment.session().close();\n+            arena.close();\n@@ -735,2 +736,2 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            MemorySegment segment = session.allocate(16);\n+        try (Arena arena = Arena.openShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n@@ -753,2 +754,2 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            MemorySegment segment = session.allocate(16);\n+        try (Arena arena = Arena.openShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, arena.session());;\n@@ -764,2 +765,2 @@\n-                { (Supplier<MemorySegment>) () -> MemorySession.openImplicit().allocate(16) },\n-                { (Supplier<MemorySegment>) () -> MemorySession.openConfined().allocate(16) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, MemorySession.implicit()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().session()) },\n@@ -770,2 +771,2 @@\n-    @DataProvider(name = \"closeableSessions\")\n-    public static Object[][] closeableSessions() {\n+    @DataProvider(name = \"closeableArenas\")\n+    public static Object[][] closeableArenas() {\n@@ -773,4 +774,2 @@\n-                { (Supplier<MemorySession>) MemorySession::openShared},\n-                { (Supplier<MemorySession>) MemorySession::openConfined},\n-                { (Supplier<MemorySession>) () -> MemorySession.openShared(Cleaner.create())   },\n-                { (Supplier<MemorySession>) () -> MemorySession.openConfined(Cleaner.create()) },\n+                { (Supplier<Arena>) Arena::openConfined },\n+                { (Supplier<Arena>) Arena::openShared },\n@@ -780,11 +779,0 @@\n-    @DataProvider(name = \"allSessions\")\n-    public static Object[][] allSessions() {\n-        return Stream.of(new Object[][] { { (Supplier<MemorySession>) MemorySession::global} }, closeableSessions())\n-                .flatMap(Arrays::stream)\n-                .toArray(Object[][]::new);\n-    }\n-\n-    static MemorySession closeableSessionOrNull(MemorySession session) {\n-        return session.isCloseable() ? session : null;\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":73,"deletions":85,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.foreign.Arena;\n@@ -44,1 +45,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -66,1 +66,1 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n+        try (Arena arena = Arena.openShared()) {\n@@ -69,1 +69,1 @@\n-                    SegmentAllocator.newNativeArena(session) :\n+                    SegmentAllocator.nativeAllocator(arena.session()) :\n@@ -76,1 +76,1 @@\n-                    assertEquals(((MemorySegment)res).session(), session);\n+                    assertEquals(((MemorySegment)res).session(), arena.session());\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.Arena;\n@@ -40,1 +41,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -62,1 +62,1 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n+        try (Arena arena = Arena.openShared()) {\n@@ -65,1 +65,1 @@\n-                    SegmentAllocator.newNativeArena(session) :\n+                    SegmentAllocator.nativeAllocator(arena.session()) :\n@@ -72,1 +72,1 @@\n-                    assertEquals(((MemorySegment)res).session(), session);\n+                    assertEquals(((MemorySegment)res).session(), arena.session());\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -36,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -70,2 +70,2 @@\n-            MemorySession session = MemorySession.openShared();\n-            MemorySegment segment = session.allocate(SEGMENT_SIZE, 1);\n+            Arena arena = Arena.openShared();\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.session());\n@@ -82,1 +82,1 @@\n-            accessExecutor.execute(new Handshaker(session));\n+            accessExecutor.execute(new Handshaker(arena));\n@@ -196,1 +196,1 @@\n-            this.copy = segment.session().allocate(SEGMENT_SIZE, 1);\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.session());\n@@ -241,1 +241,1 @@\n-        final MemorySession session;\n+        final Arena arena;\n@@ -243,2 +243,2 @@\n-        Handshaker(MemorySession session) {\n-            this.session = session;\n+        Handshaker(Arena arena) {\n+            this.arena = arena;\n@@ -252,1 +252,1 @@\n-                    session.close();\n+                    arena.close();\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-        NATIVE(MemorySegment.allocateNative(8), -1);\n+        NATIVE(MemorySegment.allocateNative(8, MemorySession.implicit()), -1);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import org.testng.annotations.DataProvider;\n@@ -35,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -36,1 +36,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -39,1 +38,0 @@\n-import static org.testng.Assert.*;\n@@ -49,2 +47,2 @@\n-        try (var session = MemorySession.openConfined()) {\n-            var segment = session.allocate((long) longArrayLength * Long.BYTES, Long.SIZE);\n+        try (var arena = Arena.openConfined()) {\n+            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.session());\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -35,1 +36,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -436,2 +436,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(layout);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n@@ -471,2 +471,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(layout);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(seq);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.Arena;\n@@ -37,1 +38,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -94,2 +94,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(session.allocate(layout));\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.session()));\n@@ -126,2 +126,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(session.allocate(seq));\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n@@ -195,2 +195,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(session.allocate(seq));\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.session()));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -31,1 +32,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -82,2 +82,2 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n-                MemorySegment segment = session.allocate(128);\n+            try (Arena arena = Arena.openConfined()) {\n+                MemorySegment segment = MemorySegment.allocateNative(128, arena.session());;\n@@ -95,2 +95,2 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n-                MemorySegment segment = session.allocate(64);\n+            try (Arena arena = Arena.openConfined()) {\n+                MemorySegment segment = MemorySegment.allocateNative(64, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -34,1 +35,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -55,2 +55,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(aligned);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.session());;\n@@ -73,2 +73,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(alignedGroup);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.session());;\n@@ -100,2 +100,2 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n-                MemorySegment segment = session.allocate(layout);\n+            try (Arena arena = Arena.openConfined()) {\n+                MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n@@ -124,2 +124,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(g);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(g, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -35,1 +34,0 @@\n-import java.util.HexFormat;\n@@ -298,2 +296,2 @@\n-        try (final MemorySession session = MemorySession.openConfined()) {\n-            var segment = session.allocate(size);\n+        try (final Arena arena = Arena.openConfined()) {\n+            var segment = MemorySegment.allocateNative(size, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.ref.Cleaner;\n+import java.lang.foreign.Arena;\n@@ -36,2 +36,0 @@\n-import jdk.internal.ref.CleanerFactory;\n-\n@@ -46,1 +44,0 @@\n-import java.util.function.Function;\n@@ -48,1 +45,0 @@\n-import java.util.function.UnaryOperator;\n@@ -55,2 +51,2 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testConfined(Supplier<Cleaner> cleanerSupplier, UnaryOperator<MemorySession> sessionFunc) {\n+    @Test\n+    public void testConfined() {\n@@ -58,5 +54,1 @@\n-        Cleaner cleaner = cleanerSupplier.get();\n-        MemorySession session = cleaner != null ?\n-                MemorySession.openConfined(cleaner) :\n-                MemorySession.openConfined();\n-        session = sessionFunc.apply(session);\n+        Arena arena = Arena.openConfined();\n@@ -65,1 +57,1 @@\n-            session.addCloseAction(() -> acc.addAndGet(delta));\n+            addCloseAction(arena.session(), () -> acc.addAndGet(delta));\n@@ -69,10 +61,2 @@\n-        if (cleaner == null) {\n-            session.close();\n-            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n-        } else {\n-            session = null;\n-            int expected = IntStream.range(0, N_THREADS).sum();\n-            while (acc.get() != expected) {\n-                kickGC();\n-            }\n-        }\n+        arena.close();\n+        assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n@@ -81,2 +65,2 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testSharedSingleThread(Supplier<Cleaner> cleanerSupplier, UnaryOperator<MemorySession> sessionFunc) {\n+    @Test(dataProvider = \"sharedSessions\")\n+    public void testSharedSingleThread(SessionSupplier sessionSupplier) {\n@@ -84,5 +68,1 @@\n-        Cleaner cleaner = cleanerSupplier.get();\n-        MemorySession session = cleaner != null ?\n-                MemorySession.openShared(cleaner) :\n-                MemorySession.openShared();\n-        session = sessionFunc.apply(session);\n+        MemorySession session = sessionSupplier.get();\n@@ -91,1 +71,1 @@\n-            session.addCloseAction(() -> acc.addAndGet(delta));\n+            addCloseAction(session, () -> acc.addAndGet(delta));\n@@ -95,2 +75,2 @@\n-        if (cleaner == null) {\n-            session.close();\n+        if (!SessionSupplier.isImplicit(session)) {\n+            SessionSupplier.close(session);\n@@ -107,2 +87,2 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testSharedMultiThread(Supplier<Cleaner> cleanerSupplier, UnaryOperator<MemorySession> sessionFunc) {\n+    @Test(dataProvider = \"sharedSessions\")\n+    public void testSharedMultiThread(SessionSupplier sessionSupplier) {\n@@ -110,1 +90,0 @@\n-        Cleaner cleaner = cleanerSupplier.get();\n@@ -112,4 +91,1 @@\n-        MemorySession session = cleaner != null ?\n-                MemorySession.openShared(cleaner) :\n-                MemorySession.openShared();\n-        session = sessionFunc.apply(session);\n+        MemorySession session = sessionSupplier.get();\n@@ -121,1 +97,1 @@\n-                    sessionRef.get().addCloseAction(() -> {\n+                    addCloseAction(sessionRef.get(), () -> {\n@@ -136,1 +112,1 @@\n-        if (cleaner == null) {\n+        if (!SessionSupplier.isImplicit(session)) {\n@@ -139,1 +115,1 @@\n-                    session.close();\n+                    SessionSupplier.close(session);\n@@ -155,1 +131,1 @@\n-        if (cleaner == null) {\n+        if (!SessionSupplier.isImplicit(session)) {\n@@ -169,2 +145,2 @@\n-        MemorySession session = MemorySession.openConfined();\n-        List<MemorySession> handles = new ArrayList<>();\n+        Arena arena = Arena.openConfined();\n+        List<Arena> handles = new ArrayList<>();\n@@ -172,2 +148,2 @@\n-            MemorySession handle = MemorySession.openConfined();\n-            keepAlive(handle, session);\n+            Arena handle = Arena.openConfined();\n+            keepAlive(handle.session(), arena.session());\n@@ -179,1 +155,1 @@\n-                session.close();\n+                arena.close();\n@@ -184,1 +160,1 @@\n-                MemorySession handle = handles.remove(0);\n+                Arena handle = handles.remove(0);\n@@ -192,1 +168,1 @@\n-        MemorySession session = MemorySession.openShared();\n+        Arena arena = Arena.openShared();\n@@ -196,2 +172,2 @@\n-                try (MemorySession handle = MemorySession.openConfined()) {\n-                    keepAlive(handle, session);\n+                try (Arena handle = Arena.openConfined()) {\n+                    keepAlive(handle.session(), arena.session());\n@@ -201,1 +177,0 @@\n-                    handle.close();\n@@ -210,1 +185,1 @@\n-                session.close();\n+                arena.close();\n@@ -221,1 +196,1 @@\n-        MemorySession.openConfined().close();\n+        Arena.openConfined().close();\n@@ -226,1 +201,1 @@\n-        MemorySession.openShared().close();\n+        Arena.openShared().close();\n@@ -231,3 +206,3 @@\n-        MemorySession session = MemorySession.openConfined();\n-        MemorySession handle = MemorySession.openConfined();\n-        keepAlive(handle, session);\n+        Arena arena = Arena.openConfined();\n+        Arena handle = Arena.openConfined();\n+        keepAlive(handle.session(), arena.session());\n@@ -252,3 +227,3 @@\n-    @Test(dataProvider = \"sessions\")\n-    public void testSessionAcquires(Supplier<MemorySession> sessionFactory) {\n-        MemorySession session = sessionFactory.get();\n+    @Test(dataProvider = \"allSessions\")\n+    public void testSessionAcquires(SessionSupplier sessionSupplier) {\n+        MemorySession session = sessionSupplier.get();\n@@ -256,3 +231,2 @@\n-        if (session.isCloseable()) {\n-            session.close();\n-        }\n+        if (!SessionSupplier.isImplicit(session))\n+            SessionSupplier.close(session);\n@@ -262,2 +236,2 @@\n-        try (MemorySession handle = MemorySession.openConfined()) {\n-            keepAlive(handle, session);\n+        try (Arena arena = Arena.openConfined()) {\n+            keepAlive(arena.session(), session);\n@@ -268,49 +242,2 @@\n-            if (session.isCloseable()) {\n-                assertThrows(IllegalStateException.class, session::close);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testConfinedSessionWithImplicitDependency() {\n-        MemorySession root = MemorySession.openConfined();\n-        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n-        for (int i = 0; i < N_THREADS; i++) {\n-            keepAlive(MemorySession.openConfined(Cleaner.create()), root);\n-        }\n-        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n-        \/\/ might be called from another thread (the Cleaner thread), so that the confined session lock count is updated racily.\n-        \/\/ If that happens, the loop below never terminates.\n-        while (true) {\n-            try {\n-                root.close();\n-                break; \/\/ success!\n-            } catch (IllegalStateException ex) {\n-                kickGC();\n-                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n-                    try (MemorySession session = MemorySession.openConfined()) {\n-                        keepAlive(session, root);\n-                        \/\/ dummy\n-                    }\n-                }\n-                \/\/ try again\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testConfinedSessionWithSharedDependency() {\n-        MemorySession root = MemorySession.openConfined();\n-        List<Thread> threads = new ArrayList<>();\n-        \/\/ Create many implicit sessions which depend on 'root', and let them become unreachable.\n-        for (int i = 0; i < N_THREADS; i++) {\n-            MemorySession session = MemorySession.openShared(); \/\/ create session inside same thread!\n-            keepAlive(session, root);\n-            Thread t = new Thread(session::close); \/\/ close from another thread!\n-            threads.add(t);\n-            t.start();\n-        }\n-        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n-            try (MemorySession session = MemorySession.openConfined()) {\n-                keepAlive(session, root);\n-                \/\/ dummy\n+            if (!SessionSupplier.isImplicit(session)) {\n+                assertThrows(IllegalStateException.class, () -> SessionSupplier.close(session));\n@@ -319,10 +246,0 @@\n-        threads.forEach(t -> {\n-            try {\n-                t.join();\n-            } catch (InterruptedException ex) {\n-                \/\/ ok\n-            }\n-        });\n-        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined session happen in different\n-        \/\/ threads, so that the confined session lock count is updated racily. If that happens, the following close will blow up.\n-        root.close();\n@@ -348,1 +265,1 @@\n-    static Object[][] cleaners() {\n+    static Object[][] drops() {\n@@ -350,5 +267,2 @@\n-                { (Supplier<Cleaner>)() -> null, UnaryOperator.identity() },\n-                { (Supplier<Cleaner>)Cleaner::create, UnaryOperator.identity() },\n-                { (Supplier<Cleaner>)CleanerFactory::cleaner, UnaryOperator.identity() },\n-                { (Supplier<Cleaner>)Cleaner::create, (UnaryOperator<MemorySession>)MemorySession::asNonCloseable },\n-                { (Supplier<Cleaner>)CleanerFactory::cleaner, (UnaryOperator<MemorySession>)MemorySession::asNonCloseable }\n+                { (Supplier<Arena>) Arena::openConfined},\n+                { (Supplier<Arena>) Arena::openShared},\n@@ -358,2 +272,32 @@\n-    @DataProvider\n-    static Object[][] sessions() {\n+    private void keepAlive(MemorySession child, MemorySession parent) {\n+        MemorySessionImpl parentImpl = MemorySessionImpl.toSessionImpl(parent);\n+        parentImpl.acquire0();\n+        addCloseAction(child, parentImpl::release0);\n+    }\n+\n+    private void addCloseAction(MemorySession session, Runnable action) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        sessionImpl.addCloseAction(action);\n+    }\n+\n+    interface SessionSupplier extends Supplier<MemorySession> {\n+\n+        static void close(MemorySession session) {\n+            ((MemorySessionImpl)session).close();\n+        }\n+\n+        static boolean isImplicit(MemorySession session) {\n+            return !((MemorySessionImpl)session).isCloseable();\n+        }\n+\n+        static SessionSupplier ofImplicit() {\n+            return MemorySession::implicit;\n+        }\n+\n+        static SessionSupplier ofArena(Supplier<Arena> arenaSupplier) {\n+            return () -> arenaSupplier.get().session();\n+        }\n+    }\n+\n+    @DataProvider(name = \"sharedSessions\")\n+    static Object[][] sharedSessions() {\n@@ -361,8 +305,2 @@\n-                { (Supplier<MemorySession>) MemorySession::openConfined},\n-                { (Supplier<MemorySession>) MemorySession::openShared},\n-                { (Supplier<MemorySession>) MemorySession::openImplicit},\n-                { (Supplier<MemorySession>) MemorySession::global},\n-                { (Supplier<MemorySession>) () -> MemorySession.openConfined().asNonCloseable() },\n-                { (Supplier<MemorySession>) () -> MemorySession.openShared().asNonCloseable() },\n-                { (Supplier<MemorySession>) () -> MemorySession.openImplicit().asNonCloseable() },\n-                { (Supplier<MemorySession>) () -> MemorySession.global().asNonCloseable()},\n+                { SessionSupplier.ofArena(Arena::openShared) },\n+                { SessionSupplier.ofImplicit() },\n@@ -372,4 +310,7 @@\n-    private void keepAlive(MemorySession child, MemorySession parent) {\n-        MemorySessionImpl parentImpl = MemorySessionImpl.toSessionImpl(parent);\n-        parentImpl.acquire0();\n-        child.addCloseAction(parentImpl::release0);\n+    @DataProvider(name = \"allSessions\")\n+    static Object[][] allSessions() {\n+        return new Object[][] {\n+                { SessionSupplier.ofArena(Arena::openConfined) },\n+                { SessionSupplier.ofArena(Arena::openShared) },\n+                { SessionSupplier.ofImplicit() },\n+        };\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":88,"deletions":147,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -174,2 +175,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            var nativeSegment = session.allocate(4, 4);\n+        try (Arena arena = Arena.openConfined()) {\n+            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.session());;\n@@ -186,3 +187,3 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n-                var s1 = session.allocate((long) Integer.MAX_VALUE + 10L, 8);\n-                var s2 = session.allocate((long) Integer.MAX_VALUE + 10L, 8);\n+            try (Arena arena = Arena.openConfined()) {\n+                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n+                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.session());;\n@@ -230,3 +231,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            s1 = session.allocate(4, 1);\n-            s2 = session.allocate(4, 1);\n+        try (Arena arena = Arena.openConfined()) {\n+            s1 = MemorySegment.allocateNative(4, 1, arena.session());;\n+            s2 = MemorySegment.allocateNative(4, 1, arena.session());;\n@@ -241,2 +242,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            var segment = session.allocate(4, 1);\n+        try (Arena arena = Arena.openConfined()) {\n+            var segment = MemorySegment.allocateNative(4, 1, arena.session());;\n@@ -283,1 +284,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i)),\n+        NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -147,2 +148,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(seq);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, arena.session());;\n@@ -157,2 +158,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(doubles);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.session());;\n@@ -170,3 +171,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            session.addCloseAction(() -> freeMemory(addr));\n-            MemorySegment mallocSegment = MemorySegment.ofAddress(addr.address(), 12, session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment mallocSegment = MemorySegment.ofAddress(addr.address(), 12,\n+                    arena.session(), () -> freeMemory(addr));\n@@ -181,3 +182,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            session.addCloseAction(() -> freeMemory(addr));\n-            mallocSegment = MemorySegment.ofAddress(addr.address(), 12, session);\n+        try (Arena arena = Arena.openConfined()) {\n+            mallocSegment = MemorySegment.ofAddress(addr.address(), 12,\n+                    arena.session(), () -> freeMemory(addr));\n@@ -200,2 +201,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(4, 1);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -82,0 +83,1 @@\n+            Arena.class,\n@@ -107,0 +109,1 @@\n+            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.MemorySession,java.lang.Runnable)\/3\/0\",\n@@ -182,1 +185,2 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.openShared());\n+        addDefaultMapping(Arena.class, Arena.openConfined());\n+        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n@@ -197,1 +201,1 @@\n-            }, MemorySession.openImplicit());\n+            }, MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -37,0 +38,1 @@\n+\n@@ -75,3 +77,3 @@\n-        MemorySession session = MemorySession.openConfined();\n-        Z obj = scopedOperation.apply(session);\n-        session.close();\n+        Arena arena = Arena.openConfined();\n+        Z obj = scopedOperation.apply(arena.session());\n+        arena.close();\n@@ -88,2 +90,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            Z obj = scopedOperation.apply(session);\n+        try (Arena arena = Arena.openConfined()) {\n+            Z obj = scopedOperation.apply(arena.session());\n@@ -112,3 +114,1 @@\n-        ScopedOperation.ofScope(session -> session.addCloseAction(() -> {\n-        }), \"MemorySession::addCloseAction\");\n-        ScopedOperation.ofScope(session -> session.allocate(100), \"MemorySession::allocate\");\n+        ScopedOperation.ofScope(session -> MemorySegment.allocateNative(100, session), \"MemorySession::allocate\");;\n@@ -124,1 +124,0 @@\n-        ScopedOperation.ofScope(SegmentAllocator::newNativeArena, \"SegmentAllocator::arenaAllocator\");\n@@ -220,1 +219,1 @@\n-            NATIVE(session -> session.allocate(10)),\n+            NATIVE(session -> MemorySegment.allocateNative(10, session)),\n@@ -248,2 +247,1 @@\n-            ARENA_BOUNDED(session -> SegmentAllocator.newNativeArena(1000, session)),\n-            ARENA_UNBOUNDED(SegmentAllocator::newNativeArena);\n+            NATIVE_ALLOCATOR(SegmentAllocator::nativeAllocator);\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n@@ -72,3 +70,3 @@\n-            MemorySession[] sessions = {\n-                    MemorySession.openConfined(),\n-                    MemorySession.openShared()\n+            Arena[] arenas = {\n+                    Arena.openConfined(),\n+                    Arena.openShared()\n@@ -76,3 +74,3 @@\n-            for (MemorySession session : sessions) {\n-                try (session) {\n-                    SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, session);\n+            for (Arena arena : arenas) {\n+                try (arena) {\n+                    SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, arena);\n@@ -90,1 +88,1 @@\n-                    } catch (OutOfMemoryError ex) {\n+                    } catch (IndexOutOfBoundsException | IllegalStateException ex) {\n@@ -95,5 +93,3 @@\n-                if (allocationFactory != AllocationFactory.IMPLICIT_ALLOCATOR) {\n-                    \/\/ addresses should be invalid now\n-                    for (MemorySegment address : addressList) {\n-                        assertFalse(address.session().isAlive());\n-                    }\n+                \/\/ addresses should be invalid now\n+                for (MemorySegment address : addressList) {\n+                    assertFalse(address.session().isAlive());\n@@ -109,2 +105,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n+        try (Arena arena = Arena.openConfined()) {\n@@ -112,0 +107,1 @@\n+                SegmentAllocator allocator = SegmentAllocator.slicingAllocator(arena.allocate(i * 2 + 1));\n@@ -123,12 +119,4 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(10, session);\n-            assertThrows(OutOfMemoryError.class, () -> allocator.allocate(12));\n-            allocator.allocate(5); \/\/ ok\n-        }\n-    }\n-\n-    @Test\n-    public void testBiggerThanBlockForBoundedArena() {\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(4 * 1024 * 2, session);\n-            allocator.allocate(4 * 1024 + 1); \/\/ should be ok\n+        try (Arena arena = Arena.openConfined()) {\n+            SegmentAllocator allocator = SegmentAllocator.slicingAllocator(arena.allocate(10));\n+            assertEquals(MemorySegment.NULL, allocator.allocate(12));\n+            assertNotEquals(MemorySegment.NULL, allocator.allocate(5));\n@@ -138,5 +126,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadUnboundedArenaSize() {\n-        SegmentAllocator.newNativeArena( -1, MemorySession.global());\n-    }\n-\n@@ -170,2 +153,3 @@\n-        SegmentAllocator segmentAllocator = SegmentAllocator.newNativeArena(MemorySession.openImplicit());\n-        segmentAllocator.allocate(Long.MAX_VALUE, 2);\n+        try (Arena arena = Arena.openConfined()) {\n+            arena.allocate(Long.MAX_VALUE, 2);\n+        }\n@@ -206,1 +190,1 @@\n-                return MemorySegment.allocateNative(byteSize, byteAlignment);\n+                return MemorySegment.allocateNative(byteSize, byteAlignment, MemorySession.implicit());\n@@ -223,3 +207,3 @@\n-        MemorySession[] sessions = {\n-                MemorySession.openConfined(),\n-                MemorySession.openShared()\n+        Arena[] arenas = {\n+                Arena.openConfined(),\n+                Arena.openShared()\n@@ -227,3 +211,3 @@\n-        for (MemorySession session : sessions) {\n-            try (session) {\n-                SegmentAllocator allocator = allocationFactory.allocator(100, session);\n+        for (Arena arena : arenas) {\n+            try (arena) {\n+                SegmentAllocator allocator = allocationFactory.allocator(100, arena);\n@@ -366,4 +350,2 @@\n-        ARENA_BOUNDED(true, SegmentAllocator::newNativeArena),\n-        ARENA_UNBOUNDED(false, (size, session) -> SegmentAllocator.newNativeArena(session)),\n-        NATIVE_ALLOCATOR(false, (size, session) -> session),\n-        IMPLICIT_ALLOCATOR(false, (size, session) -> SegmentAllocator.implicitAllocator());\n+        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.session()))),\n+        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.session()));\n@@ -372,1 +354,1 @@\n-        private final BiFunction<Long, MemorySession, SegmentAllocator> factory;\n+        private final BiFunction<Long, Arena, SegmentAllocator> factory;\n@@ -374,1 +356,1 @@\n-        AllocationFactory(boolean isBound, BiFunction<Long, MemorySession, SegmentAllocator> factory) {\n+        AllocationFactory(boolean isBound, BiFunction<Long, Arena, SegmentAllocator> factory) {\n@@ -379,2 +361,2 @@\n-        SegmentAllocator allocator(long size, MemorySession session) {\n-            return factory.apply(size, session);\n+        SegmentAllocator allocator(long size, Arena arena) {\n+            return factory.apply(size, arena);\n@@ -501,3 +483,2 @@\n-                { SegmentAllocator.implicitAllocator() },\n-                { SegmentAllocator.newNativeArena(MemorySession.global()) },\n-                { SegmentAllocator.prefixAllocator(MemorySession.global().allocate(10)) },\n+                { SegmentAllocator.nativeAllocator(MemorySession.global()) },\n+                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, MemorySession.global())) },\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":34,"deletions":53,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i)),\n+            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-            NATIVE(i -> MemorySession.openConfined().allocate(i)),\n+            NATIVE(i -> MemorySegment.allocateNative(i, MemorySession.implicit())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                () -> MemorySession.openConfined().allocate(16),\n+                () -> MemorySegment.allocateNative(16, MemorySession.implicit()),\n@@ -67,1 +67,1 @@\n-                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, MemorySession.openConfined());\n+                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, MemorySession.implicit());\n@@ -134,1 +134,1 @@\n-        NATIVE(() -> MemorySession.openConfined().allocate(16)),\n+        NATIVE(() -> MemorySegment.allocateNative(16, MemorySession.implicit())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -42,1 +43,0 @@\n-import java.util.function.Function;\n@@ -53,1 +53,1 @@\n-        MemorySegment.allocateNative(size, align);\n+        MemorySegment.allocateNative(size, align, MemorySession.implicit());\n@@ -58,2 +58,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            var segment = session.allocate(0);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySession session = arena.session();\n+            var segment = MemorySegment.allocateNative(0, session);\n@@ -62,1 +63,1 @@\n-            segment = session.allocate(seq);\n+            segment = MemorySegment.allocateNative(seq, session);\n@@ -65,1 +66,1 @@\n-            segment = session.allocate(0, 4);\n+            segment = MemorySegment.allocateNative(0, 4, session);\n@@ -77,1 +78,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE);\n+        MemorySegment.allocateNative(Long.MAX_VALUE, MemorySession.implicit());\n@@ -82,1 +83,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, MemorySession.implicit()); \/\/ 2M\n@@ -88,2 +89,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(1000, 1);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.session());\n@@ -99,2 +100,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(10, 1);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.session());\n@@ -119,2 +120,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(100);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n@@ -126,1 +127,1 @@\n-            MemorySegment segment2 = session.allocate(100);\n+            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.session());\n@@ -144,2 +145,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(100);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n@@ -164,1 +165,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10);\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, MemorySession.implicit());\n@@ -171,1 +172,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10L);\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10L, MemorySession.implicit());\n@@ -178,1 +179,1 @@\n-            var segment = MemorySession.global().allocate(10);\n+            var segment = MemorySegment.allocateNative(10, MemorySession.global());\n@@ -191,7 +192,0 @@\n-        tryClose(segment);\n-    }\n-\n-    static void tryClose(MemorySegment segment) {\n-        if (segment.session().isCloseable()) {\n-            segment.session().close();\n-        }\n@@ -210,6 +204,6 @@\n-                () -> MemorySegment.allocateNative(4L),\n-                () -> MemorySegment.allocateNative(4L, 8),\n-                () -> MemorySegment.allocateNative(JAVA_INT),\n-                () -> MemorySegment.allocateNative(4L),\n-                () -> MemorySegment.allocateNative(4L, 8),\n-                () -> MemorySegment.allocateNative(JAVA_INT)\n+                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(4L, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(4L, 8, MemorySession.implicit()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, MemorySession.implicit())\n@@ -221,28 +215,0 @@\n-    static class SegmentFactory {\n-        final MemorySession session;\n-        final Function<MemorySession, MemorySegment> segmentFunc;\n-\n-        SegmentFactory(MemorySession session, Function<MemorySession, MemorySegment> segmentFunc) {\n-            this.session = session;\n-            this.segmentFunc = segmentFunc;\n-        }\n-\n-        public void tryClose() {\n-            if (session.isCloseable()) {\n-                session.close();\n-            }\n-        }\n-\n-        public MemorySegment segment() {\n-            return segmentFunc.apply(session);\n-        }\n-\n-        static SegmentFactory ofArray(Supplier<MemorySegment> segmentSupplier) {\n-            return new SegmentFactory(MemorySession.global(), (_ignored) -> segmentSupplier.get());\n-        }\n-\n-        static SegmentFactory ofImplicitSession(Function<MemorySession, MemorySegment> segmentFunc) {\n-            return new SegmentFactory(MemorySession.openImplicit(), segmentFunc);\n-        }\n-    }\n-\n@@ -271,15 +237,0 @@\n-            tryClose(segment);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"segmentFactories\")\n-    public void testFillClosed(Supplier<MemorySegment> segmentSupplier) {\n-        MemorySegment segment = segmentSupplier.get();\n-        tryClose(segment);\n-        if (!segment.session().isAlive()) {\n-            try {\n-                segment.fill((byte) 0xFF);\n-                fail();\n-            } catch (IllegalStateException ex) {\n-                assertTrue(true);\n-            }\n@@ -293,1 +244,0 @@\n-        tryClose(segment);\n@@ -300,1 +250,0 @@\n-        tryClose(segment);\n@@ -318,1 +267,1 @@\n-        if (segment.session().ownerThread() != null) {\n+        if (segment.session().isOwnedBy(Thread.currentThread())) {\n@@ -326,1 +275,0 @@\n-        tryClose(segment);\n@@ -344,12 +292,0 @@\n-    @Test\n-    public void testSegmentAccessorWithWrappedLifetime() {\n-        MemorySession session = MemorySession.openConfined();\n-        MemorySession publicSession = session.asNonCloseable();\n-        assertEquals(session, publicSession);\n-        MemorySegment segment = publicSession.allocate(100);\n-        assertThrows(UnsupportedOperationException.class, publicSession::close);\n-        assertThrows(UnsupportedOperationException.class, segment.session()::close);\n-        session.close();\n-        assertFalse(publicSession.isAlive());\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":28,"deletions":92,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\n@@ -51,2 +52,2 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            MemorySegment s = session.allocate(layout);\n+        try (Arena arena = Arena.openShared()) {\n+            MemorySegment s = MemorySegment.allocateNative(layout, arena.session());;\n@@ -96,2 +97,2 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            MemorySegment s = session.allocate(4, 1);\n+        try (Arena arena = Arena.openShared()) {\n+            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.session());;\n@@ -101,1 +102,1 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), session);\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.session());\n@@ -123,2 +124,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment s1 = session.allocate(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT));\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -27,1 +28,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -49,2 +49,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n@@ -64,2 +64,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -45,0 +46,1 @@\n+\n@@ -60,2 +62,2 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            MemorySegment segment = session.allocate(layout);\n+        try (Arena arena = Arena.openShared()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, arena.session());;\n@@ -87,1 +89,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,2 +27,1 @@\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.SegmentAllocator;\n+\n@@ -42,3 +42,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(expectedByteLength, session);\n-            MemorySegment text = allocator.allocateUtf8String(testString);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment text = arena.allocateUtf8String(testString);\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -56,2 +56,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment s = session.allocate(8, 8);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n@@ -64,2 +64,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment s = session.allocate(8, 8);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n@@ -72,2 +72,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment s = session.allocate(8, 8);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n@@ -80,2 +80,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment s = session.allocate(8, 8);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), MemorySession.openImplicit());\n+        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), MemorySession.implicit());\n@@ -57,1 +57,1 @@\n-        VaList.ofAddress(0L, MemorySession.openImplicit());\n+        VaList.ofAddress(0L, MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.Arena;\n@@ -41,1 +42,1 @@\n-import java.lang.foreign.SegmentAllocator;\n+\n@@ -64,2 +65,1 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n+        try (Arena arena = Arena.openShared()) {\n@@ -67,2 +67,2 @@\n-            MethodHandle mh = downcallHandle(ABI, addr, allocator, descriptor);\n-            Object[] args = makeArgs(MemorySession.openImplicit(), ret, paramTypes, fields, returnChecks, argChecks);\n+            MethodHandle mh = downcallHandle(ABI, addr, arena, descriptor);\n+            Object[] args = makeArgs(MemorySession.implicit(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -75,1 +75,1 @@\n-            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, session);\n+            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.session());\n@@ -81,1 +81,1 @@\n-                    ? invoker.invoke(session, callback)\n+                    ? invoker.invoke(arena.session(), callback)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), MemorySession.openImplicit());\n+        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), MemorySession.implicit());\n@@ -155,1 +155,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.Arena;\n@@ -89,1 +90,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), MemorySession.implicit());\n@@ -104,2 +105,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.session());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -36,2 +37,1 @@\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.SegmentAllocator;\n+\n@@ -56,4 +56,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MethodHandle mh = downcallHandle(ABI, addr, allocator, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(session, ret, paramTypes, fields, returnChecks, argChecks);\n+        try (Arena arena = Arena.openConfined()) {\n+            MethodHandle mh = downcallHandle(ABI, addr, arena, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,1 +39,1 @@\n-import java.lang.foreign.SegmentAllocator;\n+\n@@ -57,4 +58,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MethodHandle mh = downcallHandle(ABI, addr, allocator, functionStack(ret, paramTypes, fields));\n-            Object[] args = makeArgsStack(session, ret, paramTypes, fields, returnChecks, argChecks);\n+        try (Arena arena = Arena.openConfined()) {\n+            MethodHandle mh = downcallHandle(ABI, addr, arena, functionStack(ret, paramTypes, fields));\n+            Object[] args = makeArgsStack(arena.session(), ret, paramTypes, fields, returnChecks, argChecks);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.Arena;\n@@ -92,3 +92,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n-            MemorySegment argSegment = session.allocate(S_PDI_LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.session());\n+            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.Arena;\n@@ -73,1 +73,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (Arena arena = Arena.openConfined()) {\n@@ -75,3 +75,3 @@\n-            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), session);\n-            MemorySegment callInfo = session.allocate(CallInfo.LAYOUT);\n-            MemorySegment argIDs = session.allocate(MemoryLayout.sequenceLayout(args.size(), C_INT));\n+            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.session());\n+            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.session());;\n+            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.session());;\n@@ -128,2 +128,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.session());\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -68,1 +69,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1L, 2);\n+        MemorySegment segment = MemorySegment.allocateNative(1L, 2, MemorySession.implicit());\n@@ -104,2 +105,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(inner_size * outer_size * 8, 4);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.session());;\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.Arena;\n@@ -75,2 +75,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.session());\n@@ -88,2 +88,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.session());\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,1 +39,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -68,2 +68,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment saveSeg = session.allocate(stl.layout());\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment saveSeg = arena.allocate(stl.layout());\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -54,5 +55,0 @@\n-    static MemorySession closeableSessionOrNull(MemorySession session) {\n-        return (session.isCloseable()) ?\n-                session : null;\n-    }\n-\n@@ -76,1 +72,1 @@\n-        var segment = session.allocate(size, 1);\n+        var segment = MemorySegment.allocateNative(size, 1, session);\n@@ -128,2 +124,2 @@\n-    @DataProvider(name = \"confinedSessions\")\n-    public static Object[][] confinedSessions() {\n+    @DataProvider(name = \"confinedArenas\")\n+    public static Object[][] confinedArenas() {\n@@ -131,1 +127,1 @@\n-                { SessionSupplier.NEW_CONFINED          },\n+                { ArenaSupplier.NEW_CONFINED          },\n@@ -135,16 +131,2 @@\n-    @DataProvider(name = \"sharedSessions\")\n-    public static Object[][] sharedSessions() {\n-        return new Object[][] {\n-                { SessionSupplier.NEW_SHARED          },\n-        };\n-    }\n-\n-    @DataProvider(name = \"closeableSessions\")\n-    public static Object[][] closeableSessions() {\n-        return Stream.of(sharedSessions(), confinedSessions())\n-                .flatMap(Arrays::stream)\n-                .toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider(name = \"implicitSessions\")\n-    public static Object[][] implicitSessions() {\n+    @DataProvider(name = \"sharedArenas\")\n+    public static Object[][] sharedArenas() {\n@@ -152,1 +134,1 @@\n-                { SessionSupplier.GLOBAL       },\n+                { ArenaSupplier.NEW_SHARED          },\n@@ -156,10 +138,3 @@\n-    @DataProvider(name = \"sharedAndImplicitSessions\")\n-    public static Object[][] sharedAndImplicitSessions() {\n-        return Stream.of(sharedSessions(), implicitSessions())\n-                .flatMap(Arrays::stream)\n-                .toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider(name = \"allSessions\")\n-    public static Object[][] allSessions() {\n-        return Stream.of(implicitSessions(), closeableSessions())\n+    @DataProvider(name = \"closeableArenas\")\n+    public static Object[][] closeableArenas() {\n+        return Stream.of(sharedArenas(), confinedArenas())\n@@ -170,2 +145,2 @@\n-    @DataProvider(name = \"sharedSessionsAndTimeouts\")\n-    public static Object[][] sharedSessionsAndTimeouts() {\n+    @DataProvider(name = \"sharedArenasAndTimeouts\")\n+    public static Object[][] sharedArenasAndTimeouts() {\n@@ -173,2 +148,2 @@\n-                { SessionSupplier.NEW_SHARED          ,  0 },\n-                { SessionSupplier.NEW_SHARED          , 30 },\n+                { ArenaSupplier.NEW_SHARED          ,  0 },\n+                { ArenaSupplier.NEW_SHARED          , 30 },\n@@ -178,1 +153,1 @@\n-    static class SessionSupplier implements Supplier<MemorySession> {\n+    static class ArenaSupplier implements Supplier<Arena> {\n@@ -180,8 +155,4 @@\n-        static final Supplier<MemorySession> NEW_CONFINED =\n-                new SessionSupplier(MemorySession::openConfined, \"newConfinedSession()\");\n-        static final Supplier<MemorySession> NEW_SHARED =\n-                new SessionSupplier(MemorySession::openShared, \"newSharedSession()\");\n-        static final Supplier<MemorySession> NEW_IMPLICIT =\n-                new SessionSupplier(MemorySession::openImplicit, \"newImplicitSession()\");\n-        static final Supplier<MemorySession> GLOBAL =\n-                new SessionSupplier(MemorySession::global, \"globalSession()\");\n+        static final Supplier<Arena> NEW_CONFINED =\n+                new ArenaSupplier(Arena::openConfined, \"confined arena\");\n+        static final Supplier<Arena> NEW_SHARED =\n+                new ArenaSupplier(Arena::openShared, \"shared arena\");\n@@ -189,1 +160,1 @@\n-        private final Supplier<MemorySession> supplier;\n+        private final Supplier<Arena> supplier;\n@@ -191,1 +162,1 @@\n-        private SessionSupplier(Supplier<MemorySession> supplier, String str) {\n+        private ArenaSupplier(Supplier<Arena> supplier, String str) {\n@@ -196,1 +167,1 @@\n-        @Override public MemorySession get() { return supplier.get(); }\n+        @Override public Arena get() { return supplier.get(); }\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":23,"deletions":52,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.Arena;\n@@ -70,2 +71,2 @@\n-    @Test(dataProvider = \"confinedSessions\")\n-    public void testWithConfined(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"confinedArenas\")\n+    public void testWithConfined(Supplier<Arena> arenaSupplier)\n@@ -77,2 +78,2 @@\n-             var session = closeableSessionOrNull(sessionSupplier.get())) {\n-            var segment = session.allocate(10, 1);\n+             var drop = arenaSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n@@ -103,2 +104,2 @@\n-    @Test(dataProvider = \"sharedSessionsAndTimeouts\")\n-    public void testIOWithClosedSharedSession(Supplier<MemorySession> sessionSupplier, int timeout)\n+    @Test(dataProvider = \"sharedArenasAndTimeouts\")\n+    public void testIOWithClosedSharedSession(Supplier<Arena> arenaSupplier, int timeout)\n@@ -110,4 +111,4 @@\n-            MemorySession session = sessionSupplier.get();\n-            ByteBuffer bb = segmentBufferOfSize(session, 64);\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, session, 32);\n-            ((MemorySession)session).close();\n+            Arena drop = arenaSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(drop.session(), 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 32);\n+            drop.close();\n@@ -154,2 +155,2 @@\n-    @Test(dataProvider = \"sharedAndImplicitSessions\")\n-    public void testBasicIOWithSupportedSession(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"sharedArenas\")\n+    public void testBasicIOWithSupportedSession(Supplier<Arena> arenaSupplier)\n@@ -158,1 +159,1 @@\n-        MemorySession session;\n+        Arena drop;\n@@ -162,3 +163,3 @@\n-             var scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n-            MemorySegment segment1 = session.allocate(10, 1);\n-            MemorySegment segment2 = session.allocate(10, 1);\n+             var scp = drop = arenaSupplier.get()) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n@@ -187,2 +188,2 @@\n-                var writeBuffers = mixedBuffersOfSize(16, session, 32);\n-                var readBuffers = mixedBuffersOfSize(16, session, 32);\n+                var writeBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n+                var readBuffers = mixedBuffersOfSize(16, drop.session(), 32);\n@@ -202,2 +203,2 @@\n-    @Test(dataProvider = \"sharedSessionsAndTimeouts\")\n-    public void testCloseWithOutstandingRead(Supplier<MemorySession> sessionSupplier, int timeout)\n+    @Test(dataProvider = \"sharedArenasAndTimeouts\")\n+    public void testCloseWithOutstandingRead(Supplier<Arena> arenaSupplier, int timeout)\n@@ -209,2 +210,2 @@\n-             var session = closeableSessionOrNull(sessionSupplier.get())) {\n-            var segment = session.allocate(10, 1);\n+             var drop = arenaSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n@@ -224,2 +225,2 @@\n-                assertTrue(session.isAlive());\n-                assertMessage(expectThrows(ISE, () -> session.close()), \"Session is acquired by\");\n+                assertTrue(drop.session().isAlive());\n+                assertMessage(expectThrows(ISE, () -> drop.close()), \"Session is acquired by\");\n@@ -231,1 +232,1 @@\n-                assertTrue(session.isAlive());\n+                assertTrue(drop.session().isAlive());\n@@ -238,2 +239,2 @@\n-    @Test(dataProvider = \"sharedSessionsAndTimeouts\")\n-    public void testCloseWithOutstandingWrite(Supplier<MemorySession> sessionSupplier, int timeout)\n+    @Test(dataProvider = \"sharedArenasAndTimeouts\")\n+    public void testCloseWithOutstandingWrite(Supplier<Arena> arenaSupplier, int timeout)\n@@ -245,1 +246,1 @@\n-             var session = closeableSessionOrNull(sessionSupplier.get())) {\n+             var drop = arenaSupplier.get()) {\n@@ -255,1 +256,1 @@\n-            var bba = segmentBuffersOfSize(32, session, 128);\n+            var bba = segmentBuffersOfSize(32, drop.session(), 128);\n@@ -264,1 +265,1 @@\n-                                var bba = segmentBuffersOfSize(32, session, 128);\n+                                var bba = segmentBuffersOfSize(32, drop.session(), 128);\n@@ -274,2 +275,2 @@\n-            assertMessage(expectThrows(ISE, () -> session.close()), \"Session is acquired by\");\n-            assertTrue(session.isAlive());\n+            assertMessage(expectThrows(ISE, () -> drop.close()), \"Session is acquired by\");\n+            assertTrue(drop.session().isAlive());\n@@ -283,1 +284,1 @@\n-            assertTrue(session.isAlive());\n+            assertTrue(drop.session().isAlive());\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.Arena;\n@@ -59,2 +60,2 @@\n-    @Test(dataProvider = \"closeableSessions\")\n-    public void testBasicIOWithClosedSegment(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"closeableArenas\")\n+    public void testBasicIOWithClosedSegment(Supplier<Arena> arenaSupplier)\n@@ -66,3 +67,3 @@\n-            MemorySession session = sessionSupplier.get();\n-            ByteBuffer bb = segmentBufferOfSize(session, 16);\n-            ((MemorySession)session).close();\n+            Arena drop = arenaSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(drop.session(), 16);\n+            drop.close();\n@@ -78,2 +79,2 @@\n-    @Test(dataProvider = \"closeableSessions\")\n-    public void testScatterGatherWithClosedSegment(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"closeableArenas\")\n+    public void testScatterGatherWithClosedSegment(Supplier<Arena> arenaSupplier)\n@@ -85,3 +86,3 @@\n-            MemorySession session = (MemorySession)sessionSupplier.get();\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, session, 16);\n-            session.close();\n+            Arena drop = arenaSupplier.get();\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.session(), 16);\n+            drop.close();\n@@ -95,2 +96,2 @@\n-    @Test(dataProvider = \"allSessions\")\n-    public void testBasicIO(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"closeableArenas\")\n+    public void testBasicIO(Supplier<Arena> arenaSupplier)\n@@ -99,1 +100,1 @@\n-        MemorySession session;\n+        Arena drop;\n@@ -103,3 +104,3 @@\n-             var scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n-            MemorySegment segment1 = session.allocate(10, 1);\n-            MemorySegment segment2 = session.allocate(10, 1);\n+             var scp = drop = arenaSupplier.get()) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.session());\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.session());\n@@ -135,2 +136,2 @@\n-    @Test(dataProvider = \"confinedSessions\")\n-    public void testIOOnConfinedFromAnotherThread(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"confinedArenas\")\n+    public void testIOOnConfinedFromAnotherThread(Supplier<Arena> arenaSupplier)\n@@ -142,2 +143,2 @@\n-             var session = closeableSessionOrNull(sessionSupplier.get())) {\n-            var segment = session.allocate(10, 1);\n+             var drop = arenaSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, drop.session());\n@@ -164,2 +165,2 @@\n-    @Test(dataProvider = \"allSessions\")\n-    public void testScatterGatherIO(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"closeableArenas\")\n+    public void testScatterGatherIO(Supplier<Arena> arenaSupplier)\n@@ -168,1 +169,1 @@\n-        MemorySession session;\n+        Arena drop;\n@@ -172,3 +173,3 @@\n-             var scp = closeableSessionOrNull(session = sessionSupplier.get())) {\n-            var writeBuffers = mixedBuffersOfSize(32, session, 64);\n-            var readBuffers = mixedBuffersOfSize(32, session, 64);\n+             var scp = drop = arenaSupplier.get()) {\n+            var writeBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n+            var readBuffers = mixedBuffersOfSize(32, drop.session(), 64);\n@@ -182,2 +183,2 @@\n-    @Test(dataProvider = \"closeableSessions\")\n-    public void testBasicIOWithDifferentSessions(Supplier<MemorySession> sessionSupplier)\n+    @Test(dataProvider = \"closeableArenas\")\n+    public void testBasicIOWithDifferentSessions(Supplier<Arena> arenaSupplier)\n@@ -189,3 +190,3 @@\n-             var session1 = closeableSessionOrNull(sessionSupplier.get());\n-             var session2 = closeableSessionOrNull(sessionSupplier.get())) {\n-            var writeBuffers = Stream.of(mixedBuffersOfSize(16, session1, 64), mixedBuffersOfSize(16, session2, 64))\n+             var drop1 = arenaSupplier.get();\n+             var drop2 = arenaSupplier.get()) {\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n@@ -194,1 +195,1 @@\n-            var readBuffers = Stream.of(mixedBuffersOfSize(16, session1, 64), mixedBuffersOfSize(16, session2, 64))\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.session(), 64), mixedBuffersOfSize(16, drop2.session(), 64))\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.Arena;\n@@ -52,3 +53,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(JAVA_INT);\n-            session.whileAlive(() -> {\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = arena.allocate(JAVA_INT);\n+            arena.session().whileAlive(() -> {\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.openShared());\n+        addDefaultMapping(MemorySession.class, MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.foreign.Arena;\n@@ -42,1 +43,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -118,1 +118,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (Arena arena = Arena.openConfined()) {\n@@ -121,1 +121,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, session);\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.session());\n@@ -188,2 +188,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.session());\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+import java.lang.foreign.Arena;\n@@ -85,1 +86,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -118,2 +118,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+import java.lang.foreign.Arena;\n@@ -84,1 +85,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -117,2 +117,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.session());\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.Arena;\n@@ -82,2 +82,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.session());\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            = actions -> Windowsx64Linker.newVaList(actions, MemorySession.openImplicit());\n+            = actions -> Windowsx64Linker.newVaList(actions, MemorySession.implicit());\n@@ -131,1 +131,1 @@\n-            = actions -> SysVx64Linker.newVaList(actions, MemorySession.openImplicit());\n+            = actions -> SysVx64Linker.newVaList(actions, MemorySession.implicit());\n@@ -133,1 +133,1 @@\n-            = actions -> LinuxAArch64Linker.newVaList(actions, MemorySession.openImplicit());\n+            = actions -> LinuxAArch64Linker.newVaList(actions, MemorySession.implicit());\n@@ -135,1 +135,1 @@\n-            = actions -> MacOsAArch64Linker.newVaList(actions, MemorySession.openImplicit());\n+            = actions -> MacOsAArch64Linker.newVaList(actions, MemorySession.implicit());\n@@ -137,1 +137,1 @@\n-            = (builder) -> VaList.make(builder, MemorySession.openConfined());\n+            = (builder) -> VaList.make(builder, MemorySession.implicit());\n@@ -228,2 +228,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment msInt = session.allocate(JAVA_INT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.session());;\n@@ -247,1 +247,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(pointLayout);\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, MemorySession.implicit());\n@@ -283,2 +283,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment struct = session.allocate(Point_LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n@@ -300,1 +300,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n@@ -336,2 +336,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment struct = session.allocate(BigPoint_LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.session());;\n@@ -353,1 +353,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n@@ -390,2 +390,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment struct = session.allocate(FloatPoint_LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.session());;\n@@ -411,1 +411,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n@@ -454,2 +454,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment struct = session.allocate(HugePoint_LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.session());;\n@@ -506,3 +506,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment longSum = session.allocate(longLayout);\n-            MemorySegment doubleSum = session.allocate(doubleLayout);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.session());;\n+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.session());;\n@@ -534,2 +534,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment stub = abi.upcallStub(callback, desc, session);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment stub = abi.upcallStub(callback, desc, arena.session());\n@@ -575,1 +575,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (Arena arena = Arena.openConfined()) {\n@@ -577,1 +577,1 @@\n-                    .addVarg(intLayout, 8), session);\n+                    .addVarg(intLayout, 8), arena.session());\n@@ -590,3 +590,3 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            try (MemorySession innerSession = MemorySession.openConfined()) {\n-                MemorySegment pointIn = innerSession.allocate(Point_LAYOUT);\n+        try (Arena arena = Arena.openConfined()) {\n+            try (Arena innerArena = Arena.openConfined()) {\n+                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.session());;\n@@ -596,1 +596,1 @@\n-                pointOut = session.allocate(Point_LAYOUT);\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.session());;\n@@ -619,1 +619,1 @@\n-        try (var session = MemorySession.openConfined()) {\n+        try (var arena = Arena.openConfined()) {\n@@ -621,1 +621,1 @@\n-                    .addVarg(intLayout, 8), session);\n+                    .addVarg(intLayout, 8), arena.session());\n@@ -643,1 +643,1 @@\n-        try (var session = MemorySession.openConfined()) {\n+        try (var arena = Arena.openConfined()) {\n@@ -645,1 +645,1 @@\n-                    .addVarg(intLayout, 8), session);\n+                    .addVarg(intLayout, 8), arena.session());\n@@ -683,1 +683,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n@@ -690,1 +690,1 @@\n-                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT);\n+                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n@@ -704,1 +704,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n@@ -716,1 +716,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, MemorySession.implicit());\n@@ -722,1 +722,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, MemorySession.implicit());\n@@ -729,1 +729,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT);\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, MemorySession.implicit());\n@@ -774,1 +774,1 @@\n-                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT);\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, MemorySession.implicit());\n@@ -824,1 +824,1 @@\n-        return VaList.ofAddress(segment.address(), MemorySession.openImplicit());\n+        return VaList.ofAddress(segment.address(), MemorySession.implicit());\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.lang.foreign.Arena;\n@@ -173,2 +174,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment seg = session.allocate(8);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment seg = arena.allocate(8);\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -68,2 +69,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(layout);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = arena.allocate(layout);\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                    MemorySegment.allocateNative(s)\n+                    MemorySegment.allocateNative(s, MemorySession.implicit())\n@@ -54,1 +54,1 @@\n-                    MemorySegment.allocateNative(s)\n+                    MemorySegment.allocateNative(s, MemorySession.implicit())\n@@ -63,1 +63,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -502,2 +502,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n@@ -531,2 +531,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n@@ -595,2 +595,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n@@ -626,2 +626,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE);\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, MemorySession.implicit()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, MemorySession.implicit());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.Arena;\n@@ -55,3 +56,2 @@\n-        CONFINED(MemorySession::openConfined),\n-        SHARED(MemorySession::openShared),\n-        IMPLICIT(MemorySession::openImplicit);\n+        CONFINED(Arena::openConfined),\n+        SHARED(Arena::openShared);\n@@ -59,1 +59,1 @@\n-        final Supplier<MemorySession> sessionFactory;\n+        final Supplier<Arena> arenaFactory;\n@@ -61,2 +61,2 @@\n-        SessionKind(Supplier<MemorySession> sessionFactory) {\n-            this.sessionFactory = sessionFactory;\n+        SessionKind(Supplier<Arena> arenaFactory) {\n+            this.arenaFactory = arenaFactory;\n@@ -65,2 +65,2 @@\n-        MemorySession makeSession() {\n-            return sessionFactory.get();\n+        Arena makeArena() {\n+            return arenaFactory.get();\n@@ -76,1 +76,1 @@\n-    MemorySession session;\n+    Arena arena;\n@@ -88,3 +88,3 @@\n-        session = sessionKind.makeSession();\n-        mismatchSegmentLarge1 = session.allocate(SIZE_WITH_TAIL);\n-        mismatchSegmentLarge2 = session.allocate(SIZE_WITH_TAIL);\n+        arena = sessionKind.makeArena();\n+        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL);\n+        mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL);\n@@ -95,2 +95,2 @@\n-        mismatchSegmentSmall1 = session.allocate(7);\n-        mismatchSegmentSmall2 = session.allocate(7);\n+        mismatchSegmentSmall1 = arena.allocate(7);\n+        mismatchSegmentSmall2 = arena.allocate(7);\n@@ -120,3 +120,1 @@\n-        if (session.isCloseable()) {\n-            session.close();\n-        }\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.Arena;\n@@ -41,1 +42,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -63,1 +63,1 @@\n-    final MemorySession session = MemorySession.openConfined();\n+    final Arena arena = Arena.openConfined();\n@@ -66,1 +66,1 @@\n-    final MemorySegment segment = MemorySession.openConfined().allocate(ALLOC_SIZE);\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n@@ -75,2 +75,2 @@\n-    final MemorySegment mismatchSegmentLarge1 = session.allocate(SIZE_WITH_TAIL);\n-    final MemorySegment mismatchSegmentLarge2 = session.allocate(SIZE_WITH_TAIL);\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.session());;\n@@ -81,2 +81,2 @@\n-    final MemorySegment mismatchSegmentSmall1 = session.allocate(7);\n-    final MemorySegment mismatchSegmentSmall2 = session.allocate(7);\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.session());;\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.session());;\n@@ -111,1 +111,1 @@\n-        session.close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -83,2 +84,2 @@\n-    static final MemorySegment sharedPoint = MemorySession.openShared().allocate(POINT_LAYOUT);\n-    static final MemorySegment confinedPoint = MemorySession.openConfined().allocate(POINT_LAYOUT);\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().session());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().session());\n@@ -86,1 +87,1 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT);\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit());\n@@ -88,1 +89,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, MemorySession.implicit()));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        return LINKER.upcallStub(BLANK, BLANK_DESC, MemorySession.openImplicit());\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, MemorySession.implicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, MemorySession.implicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -29,0 +30,1 @@\n+\n@@ -61,2 +63,2 @@\n-    final MemorySession session = MemorySession.openConfined();\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(session.allocate(ALLOC_LAYOUT));\n+    final Arena arena = Arena.openConfined();\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.session()));\n@@ -66,1 +68,1 @@\n-        session.close();\n+        arena.close();\n@@ -80,2 +82,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(ALLOC_SIZE, 4);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = arena.allocate(ALLOC_SIZE, 4);\n@@ -90,2 +92,2 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            MemorySegment segment = session.allocate(ALLOC_SIZE, 4);\n+        try (Arena arena = Arena.openShared()) {\n+            MemorySegment segment = arena.allocate(ALLOC_SIZE, 4);\n@@ -136,1 +138,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4);\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -58,0 +59,2 @@\n+\n+    Arena arena;\n@@ -69,1 +72,2 @@\n-        segment = MemorySession.openConfined().allocate(ALLOC_SIZE);\n+        arena = Arena.openConfined();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n@@ -81,1 +85,1 @@\n-        segment.session().close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -59,1 +60,1 @@\n-    MemorySession session;\n+    Arena arena;\n@@ -74,3 +75,3 @@\n-        session = MemorySession.openConfined();\n-        segmentIn = session.allocate(ALLOC_SIZE);\n-        segmentOut = session.allocate(ALLOC_SIZE);\n+        arena = Arena.openConfined();\n+        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n+        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n@@ -95,1 +96,1 @@\n-        session.close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            MemorySegment s = MemorySession.openConfined().allocate(ALLOC_SIZE, 1);\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, MemorySession.implicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,1 +27,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -82,0 +82,1 @@\n+    Arena arena;\n@@ -97,1 +98,2 @@\n-        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, MemorySession.openConfined());\n+        arena = Arena.openConfined();\n+        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.session());\n@@ -104,1 +106,1 @@\n-        segment.session().close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -58,0 +59,1 @@\n+    Arena arena;\n@@ -69,1 +71,2 @@\n-        segment = MemorySession.openConfined().allocate(ALLOC_SIZE, CARRIER_SIZE);\n+        arena = Arena.openConfined();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n@@ -81,1 +84,1 @@\n-        segment.session().close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -58,1 +59,1 @@\n-    MemorySession session;\n+    Arena arena;\n@@ -70,3 +71,3 @@\n-        session = MemorySession.openConfined();\n-        nativeSegment = session.allocate(ALLOC_SIZE, 4);\n-        nativeSharedSegment = session.allocate(ALLOC_SIZE, 4); \/\/ <- This segment is not shared!\n+        arena = Arena.openConfined();\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, arena.session());;\n+        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, arena.session());; \/\/ <- This segment is not shared!\n@@ -96,1 +97,1 @@\n-        session.close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -59,0 +60,1 @@\n+    Arena arena;\n@@ -64,1 +66,2 @@\n-        nativeSegment = MemorySession.openConfined().allocate(ALLOC_SIZE);\n+        arena = Arena.openConfined();\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.session());\n@@ -71,1 +74,2 @@\n-    public void tearDown() { nativeSegment.session().close();\n+    public void tearDown() {\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -27,0 +28,1 @@\n+\n@@ -41,2 +43,0 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n@@ -107,2 +107,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            return session.allocate(ALLOC_SIZE, 4);\n+        try (Arena arena = Arena.openConfined()) {\n+            return arena.allocate(ALLOC_SIZE, 4);\n@@ -114,2 +114,2 @@\n-        try (MemorySession session = MemorySession.openShared()) {\n-            return session.allocate(ALLOC_SIZE, 4);\n+        try (Arena arena = Arena.openShared()) {\n+            return arena.allocate(ALLOC_SIZE, 4);\n@@ -121,1 +121,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4);\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n@@ -127,1 +127,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4);\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, MemorySession.implicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.Arena;\n@@ -27,1 +28,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -30,0 +30,1 @@\n+\n@@ -71,0 +72,1 @@\n+    Arena arena;\n@@ -80,1 +82,2 @@\n-        segment = MemorySession.openShared().allocate(ALLOC_SIZE, CARRIER_SIZE);\n+        arena = Arena.openShared();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.session());\n@@ -89,1 +92,1 @@\n-        segment.session().close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -42,1 +43,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -55,2 +55,2 @@\n-    MemorySession session = MemorySession.openConfined();\n-    MemorySegment segment = session.allocate(100);\n+    Arena arena = Arena.openConfined();\n+    MemorySegment segment = MemorySegment.allocateNative(100, arena.session());\n@@ -75,1 +75,1 @@\n-        session.close();\n+        arena.close();\n@@ -90,1 +90,1 @@\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, session);\n+        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.session());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        INPUT_SEGMENT = MemorySession.global().allocate(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT));\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), MemorySession.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -59,1 +60,1 @@\n-    MemorySession session = MemorySession.openConfined();\n+    Arena arena = Arena.openConfined();\n@@ -62,1 +63,1 @@\n-    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(session);\n+    SegmentAllocator arenaAllocator = new RingAllocator(arena.session());\n@@ -83,1 +84,1 @@\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySession.openConfined().allocate(size + 1));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.session()));\n@@ -88,1 +89,1 @@\n-        session.close();\n+        arena.close();\n@@ -98,3 +99,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = session.allocate(str.length() + 1);\n-            segment.setUtf8String(0, str);\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment segment = arena.allocateUtf8String(str);\n@@ -106,1 +106,1 @@\n-    public int panama_strlen_arena() throws Throwable {\n+    public int panama_strlen_ring() throws Throwable {\n@@ -145,0 +145,25 @@\n+\n+    static class RingAllocator implements SegmentAllocator {\n+        final MemorySegment segment;\n+        SegmentAllocator current;\n+\n+        public RingAllocator(MemorySession session) {\n+            this.segment = MemorySegment.allocateNative(1024, session);\n+            reset();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment res = current.allocate(byteSize, byteAlignment);\n+            if (res.equals(MemorySegment.NULL)) {\n+                \/\/ reached the end of the segment, start again\n+                reset();\n+                res = current.allocate(byteSize, byteAlignment);\n+            }\n+            return res;\n+        }\n+\n+        void reset() {\n+            current = SegmentAllocator.slicingAllocator(segment);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":33,"deletions":8,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size);\n+        srcSegmentImplicit = MemorySegment.allocateNative(size, MemorySession.implicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.Arena;\n@@ -75,1 +75,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (Arena arena = Arena.openConfined()) {\n@@ -79,1 +79,1 @@\n-                            .addVarg(C_LONG_LONG, 3L), session);\n+                            .addVarg(C_LONG_LONG, 3L), arena.session());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -26,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -60,0 +61,1 @@\n+    Arena arena;\n@@ -64,1 +66,2 @@\n-        data = MemorySession.openConfined().allocate(JAVA_INT);\n+        arena = Arena.openConfined();\n+        data = MemorySegment.allocateNative(JAVA_INT, arena.session());\n@@ -69,1 +72,1 @@\n-        data.session().close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.Arena;\n@@ -39,1 +40,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -51,1 +51,1 @@\n-    final MemorySession session = MemorySession.openConfined();\n+    final Arena arena = Arena.openConfined();\n@@ -53,3 +53,3 @@\n-    Pointer<Integer> intPointer = Pointer.allocate(NativeType.C_INT, ELEM_SIZE, session);\n-    Pointer<Pointer<Integer>> intPointerPointer = Pointer.allocate(NativeType.C_INT_PTR, ELEM_SIZE, session);\n-    Pointer<Point> pointPointer = Pointer.allocate(Point.TYPE, ELEM_SIZE, session);\n+    Pointer<Integer> intPointer = Pointer.allocate(NativeType.C_INT, ELEM_SIZE, arena);\n+    Pointer<Pointer<Integer>> intPointerPointer = Pointer.allocate(NativeType.C_INT_PTR, ELEM_SIZE, arena);\n+    Pointer<Point> pointPointer = Pointer.allocate(Point.TYPE, ELEM_SIZE, arena);\n@@ -74,1 +74,1 @@\n-        session.close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -29,1 +30,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -64,0 +65,1 @@\n+    Arena arena;\n@@ -67,1 +69,2 @@\n-        this.segment = MemorySession.openConfined().allocate(LAYOUT);\n+        this.arena = Arena.openConfined();\n+        this.segment = MemorySegment.allocateNative(LAYOUT, arena.session());\n@@ -106,1 +109,1 @@\n-        segment.session().close();\n+        arena.close();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-    nativeIn = MemorySegment.allocateNative(size);\n-    nativeOut = MemorySegment.allocateNative(size);\n+    nativeIn = MemorySegment.allocateNative(size, MemorySession.implicit());\n+    nativeOut = MemorySegment.allocateNative(size, MemorySession.implicit());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.Arena;\n@@ -87,2 +88,2 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize());\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n@@ -165,3 +166,3 @@\n-    try (final var session = MemorySession.openConfined()) {\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, session);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, session);\n+    try (final var arena = Arena.openConfined()) {\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.Arena;\n@@ -92,2 +93,2 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize());\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.implicit());\n@@ -163,3 +164,3 @@\n-    try (final var session = MemorySession.openConfined()) {\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, session);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, session);\n+    try (final var arena = Arena.openConfined()) {\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.session());\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.session());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}