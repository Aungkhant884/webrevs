{"files":[{"patch":"@@ -219,1 +219,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.foreign;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.ref.Cleaner;\n@@ -105,0 +106,4 @@\n+ * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n+ * that segment will be released when the segment becomes <em>unreachable<\/em> (see {@link #registerCleaner(Cleaner)});\n+ * this might be useful to prevent native memory leaks.\n+ *\n@@ -190,0 +195,14 @@\n+    \/**\n+     * Register this memory segment instance against a {@link Cleaner} object. This allows for the segment to be closed\n+     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n+     * @apiNote Calling this method multiple times, even concurrently (from multiple threads, if this segment is shared)\n+     * is allowed; the implementation guarantees that the memory resources associated with this segment will be released\n+     * at most once. Also, in case the segment has been closed explicitly (see {@link #close}) no further action will be\n+     * taken by the GC when the segment later becomes unreachable.\n+     * @param cleaner the {@link Cleaner} object responsible for cleaning up this memory segment.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #CLOSE} access mode.\n+     *\/\n+    void registerCleaner(Cleaner cleaner);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.lang.ref.Cleaner;\n@@ -297,0 +298,8 @@\n+    @Override\n+    public void registerCleaner(Cleaner cleaner) {\n+        checkAccessModes(CLOSE);\n+        checkValidState();\n+        MemoryScope.CleanupAction cleanupAction = scope.cleanupAction;\n+        cleaner.register(this.scope, cleanupAction::cleanup);\n+    }\n+\n@@ -570,1 +579,1 @@\n-            bufferScope = MemoryScope.createConfined(bb, null);\n+            bufferScope = MemoryScope.createConfined(bb, MemoryScope.CleanupAction.DUMMY);\n@@ -586,1 +595,1 @@\n-        0, 0, MemoryScope.createShared(null, null)\n+        0, 0, MemoryScope.createShared(null, MemoryScope.CleanupAction.DUMMY)\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, null);\n+        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,6 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap);\n+            MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.BasicCleanupAction() {\n+                @Override\n+                void run() {\n+                    unmapperProxy.unmap();\n+                }\n+            });\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.ref.Reference;\n+import java.util.Objects;\n@@ -50,1 +52,2 @@\n-    private MemoryScope(Object ref, Runnable cleanupAction) {\n+    private MemoryScope(Object ref, CleanupAction cleanupAction) {\n+        Objects.requireNonNull(cleanupAction);\n@@ -59,1 +62,1 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -62,1 +65,1 @@\n-    static MemoryScope createConfined(Object ref, Runnable cleanupAction) {\n+    static MemoryScope createConfined(Object ref, CleanupAction cleanupAction) {\n@@ -69,1 +72,1 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -72,1 +75,1 @@\n-    static MemoryScope createConfined(Thread owner, Object ref, Runnable cleanupAction) {\n+    static MemoryScope createConfined(Thread owner, Object ref, CleanupAction cleanupAction) {\n@@ -79,1 +82,1 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -82,1 +85,1 @@\n-    static MemoryScope createShared(Object ref, Runnable cleanupAction) {\n+    static MemoryScope createShared(Object ref, CleanupAction cleanupAction) {\n@@ -87,1 +90,1 @@\n-    protected Runnable cleanupAction;\n+    protected CleanupAction cleanupAction;\n@@ -105,3 +108,5 @@\n-        justClose();\n-        if (cleanupAction != null) {\n-            cleanupAction.run();\n+        try {\n+            justClose();\n+            cleanupAction.cleanup();\n+        } finally {\n+            Reference.reachabilityFence(this);\n@@ -121,2 +126,6 @@\n-        justClose();\n-        return new ConfinedScope(newOwner, ref, cleanupAction);\n+        try {\n+            justClose();\n+            return new ConfinedScope(newOwner, ref, cleanupAction.dup());\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n@@ -133,2 +142,6 @@\n-        justClose();\n-        return new SharedScope(ref, cleanupAction);\n+        try {\n+            justClose();\n+            return new SharedScope(ref, cleanupAction.dup());\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n@@ -185,1 +198,1 @@\n-        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction) {\n+        public ConfinedScope(Thread owner, Object ref, CleanupAction cleanupAction) {\n@@ -231,1 +244,1 @@\n-        SharedScope(Object ref, Runnable cleanupAction) {\n+        SharedScope(Object ref, CleanupAction cleanupAction) {\n@@ -257,0 +270,84 @@\n+\n+    \/**\n+     * A functional interface modelling the cleanup action associated with a scope.\n+     *\/\n+    interface CleanupAction {\n+        void cleanup();\n+        CleanupAction dup();\n+\n+        \/** Dummy cleanup action *\/\n+        CleanupAction DUMMY = new CleanupAction() {\n+            @Override\n+            public void cleanup() {\n+                \/\/ do nothing\n+            }\n+\n+            @Override\n+            public CleanupAction dup() {\n+                return this;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * A stateful cleanup action; this action can only be called at most once. The implementation\n+     * guarantees this invariant even when multiple threads race to call the {@link #cleanup()} method.\n+     *\/\n+    static abstract class BasicCleanupAction implements CleanupAction {\n+\n+        static final VarHandle CALLED;\n+\n+        static {\n+            try {\n+                CALLED = MethodHandles.lookup().findVarHandle(BasicCleanupAction.class, \"called\", boolean.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+\n+        private boolean called = false;\n+\n+        abstract void run();\n+\n+        public final void cleanup() {\n+            disable();\n+            run();\n+        };\n+\n+        @Override\n+        public CleanupAction dup() {\n+            disable();\n+            return new BasicCleanupAction() {\n+                @Override\n+                void run() {\n+                    BasicCleanupAction.this.run();\n+                }\n+            };\n+        }\n+\n+        final void disable() {\n+            if (!CALLED.compareAndSet(this, false, true)) {\n+                \/\/ This can never happen under normal circumstances. The only case where this can happen is when\n+                \/\/ when two cleaners race to cleanup the same scope. It is never possible to have a race\n+                \/\/ between explicit\/implicit close because all the scope terminal operations have\n+                \/\/ reachability fences which prevent a scope to be deemed unreachable before we are done\n+                \/\/ marking the original cleanup action as \"dead\".\n+                throw new IllegalStateException(\"Already cleaned\");\n+            }\n+        }\n+\n+        \/**\n+         * Returns a custom {@code BasicCleanupAction} based on given {@link Runnable} instance.\n+         * @param runnable the runnable to be executed when {@link #cleanup()} is called on the returned cleanup action.\n+         * @return the new cleanup action.\n+         *\/\n+        static BasicCleanupAction of(Runnable runnable) {\n+            Objects.requireNonNull(runnable);\n+            return new BasicCleanupAction() {\n+                @Override\n+                void run() {\n+                    runnable.run();\n+                }\n+            };\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":114,"deletions":17,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -102,3 +102,6 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n-            unsafe.freeMemory(buf);\n-            nioAccess.unreserveMemory(alignedSize, bytesSize);\n+        MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.BasicCleanupAction() {\n+            @Override\n+            void run() {\n+                unsafe.freeMemory(buf);\n+                nioAccess.unreserveMemory(alignedSize, bytesSize);\n+            }\n@@ -116,0 +119,2 @@\n+        MemoryScope.CleanupAction cleanupAction = cleanup != null ?\n+                MemoryScope.BasicCleanupAction.of(cleanup) : MemoryScope.CleanupAction.DUMMY;\n@@ -117,2 +122,2 @@\n-                MemoryScope.createShared(attachment, cleanup) :\n-                MemoryScope.createConfined(owner, attachment, cleanup);\n+                MemoryScope.createShared(attachment, cleanupAction) :\n+                MemoryScope.createConfined(owner, attachment, cleanupAction);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\/jdk.incubator.foreign\n+ * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import java.lang.ref.Cleaner;\n+import jdk.internal.ref.CleanerFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+\n+public class TestCleaner {\n+\n+    static class SegmentState {\n+        private AtomicInteger cleanupCalls = new AtomicInteger(0);\n+\n+        void cleanup() {\n+            cleanupCalls.incrementAndGet();\n+        }\n+\n+        int cleanupCalls() {\n+            return cleanupCalls.get();\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void test(int n, Supplier<Cleaner> cleanerFactory) {\n+        SegmentState segmentState = new SegmentState();\n+        MemorySegment segment = makeSegment(segmentState);\n+        for (int i = 0 ; i < n ; i++) {\n+            segment.registerCleaner(cleanerFactory.get());\n+        }\n+        segment = null;\n+        while (segmentState.cleanupCalls() == 0) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        assertEquals(segmentState.cleanupCalls(), 1);\n+    }\n+\n+    MemorySegment makeSegment(SegmentState segmentState) {\n+        return MemorySegment.ofNativeRestricted(MemoryAddress.NULL, 10, null, segmentState::cleanup, null);\n+    }\n+\n+    @DataProvider\n+    static Object[][] cleaners() {\n+        Supplier<Cleaner> CLEANER = Cleaner::create;\n+        Supplier<Cleaner> CLEANER_FACTORY = CleanerFactory::cleaner;\n+\n+        return new Object[][]{\n+                { 1, CLEANER },\n+                { 2, CLEANER },\n+                { 4, CLEANER },\n+                { 8, CLEANER },\n+                { 16, CLEANER },\n+                { 1, CLEANER_FACTORY },\n+                { 2, CLEANER_FACTORY },\n+                { 4, CLEANER_FACTORY },\n+                { 8, CLEANER_FACTORY },\n+                { 16, CLEANER_FACTORY },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -338,1 +338,2 @@\n-                \"withOwnerThread\"\n+                \"withOwnerThread\",\n+                \"registerCleaner\"\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}