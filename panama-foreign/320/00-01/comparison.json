{"files":[{"patch":"@@ -302,2 +302,1 @@\n-        MemoryScope.CleanupAction cleanupAction = scope.cleanupAction;\n-        cleaner.register(this.scope, cleanupAction::cleanup);\n+        cleaner.register(this.scope, scope.cleanupAction);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -106,1 +104,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.BasicCleanupAction() {\n+            MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n@@ -108,1 +106,1 @@\n-                void run() {\n+                void doCleanup() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-    protected Object ref;\n-    protected CleanupAction cleanupAction;\n+    protected final Object ref;\n+    protected final CleanupAction cleanupAction;\n@@ -274,1 +274,1 @@\n-    interface CleanupAction {\n+    interface CleanupAction extends Runnable {\n@@ -278,0 +278,5 @@\n+        @Override\n+        default void run() {\n+            cleanup();\n+        }\n+\n@@ -290,1 +295,0 @@\n-    }\n@@ -292,5 +296,5 @@\n-    \/**\n-     * A stateful cleanup action; this action can only be called at most once. The implementation\n-     * guarantees this invariant even when multiple threads race to call the {@link #cleanup()} method.\n-     *\/\n-    static abstract class BasicCleanupAction implements CleanupAction {\n+        \/**\n+         * A stateful cleanup action; this action can only be called at most once. The implementation\n+         * guarantees this invariant even when multiple threads race to call the {@link #cleanup()} method.\n+         *\/\n+        abstract class AtMostOnceOnly implements CleanupAction {\n@@ -298,1 +302,1 @@\n-        static final VarHandle CALLED;\n+            static final VarHandle CALLED;\n@@ -300,5 +304,6 @@\n-        static {\n-            try {\n-                CALLED = MethodHandles.lookup().findVarHandle(BasicCleanupAction.class, \"called\", boolean.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError(ex);\n+            static {\n+                try {\n+                    CALLED = MethodHandles.lookup().findVarHandle(AtMostOnceOnly.class, \"called\", boolean.class);\n+                } catch (Throwable ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n@@ -306,1 +311,0 @@\n-        }\n@@ -308,1 +312,1 @@\n-        private boolean called = false;\n+            private boolean called = false;\n@@ -310,1 +314,1 @@\n-        abstract void run();\n+            abstract void doCleanup();\n@@ -312,12 +316,3 @@\n-        public final void cleanup() {\n-            disable();\n-            run();\n-        };\n-\n-        @Override\n-        public CleanupAction dup() {\n-            disable();\n-            return new BasicCleanupAction() {\n-                @Override\n-                void run() {\n-                    BasicCleanupAction.this.run();\n+            public final void cleanup() {\n+                if (disable()) {\n+                    doCleanup();\n@@ -326,1 +321,0 @@\n-        }\n@@ -328,3 +322,26 @@\n-        final void disable() {\n-            if (!CALLED.compareAndSet(this, false, true)) {\n-                \/\/ This can never happen under normal circumstances. The only case where this can happen is when\n+            @Override\n+            public CleanupAction dup() {\n+                disable();\n+                class DupAction extends AtMostOnceOnly {\n+                    final AtMostOnceOnly root;\n+\n+                    DupAction(AtMostOnceOnly root) {\n+                        this.root = root;\n+                    }\n+\n+                    @Override\n+                    void doCleanup() {\n+                        root.doCleanup();\n+                    }\n+\n+                    @Override\n+                    public CleanupAction dup() {\n+                        disable();\n+                        return new DupAction(root);\n+                    }\n+                }\n+                return new DupAction(this);\n+            }\n+\n+            final boolean disable() {\n+                \/\/ This can fail under normal circumstances. The only case where a failure can happen is when\n@@ -335,1 +352,1 @@\n-                throw new IllegalStateException(\"Already cleaned\");\n+                return CALLED.compareAndSet(this, false, true);\n@@ -337,1 +354,0 @@\n-        }\n@@ -339,13 +355,14 @@\n-        \/**\n-         * Returns a custom {@code BasicCleanupAction} based on given {@link Runnable} instance.\n-         * @param runnable the runnable to be executed when {@link #cleanup()} is called on the returned cleanup action.\n-         * @return the new cleanup action.\n-         *\/\n-        static BasicCleanupAction of(Runnable runnable) {\n-            Objects.requireNonNull(runnable);\n-            return new BasicCleanupAction() {\n-                @Override\n-                void run() {\n-                    runnable.run();\n-                }\n-            };\n+            \/**\n+             * Returns a custom {@code BasicCleanupAction} based on given {@link Runnable} instance.\n+             * @param runnable the runnable to be executed when {@link #cleanup()} is called on the returned cleanup action.\n+             * @return the new cleanup action.\n+             *\/\n+            static AtMostOnceOnly of(Runnable runnable) {\n+                Objects.requireNonNull(runnable);\n+                return new AtMostOnceOnly() {\n+                    @Override\n+                    void doCleanup() {\n+                        runnable.run();\n+                    }\n+                };\n+            }\n@@ -354,0 +371,1 @@\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":67,"deletions":49,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -102,1 +100,1 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.BasicCleanupAction() {\n+        MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n@@ -104,1 +102,1 @@\n-            void run() {\n+            void doCleanup() {\n@@ -120,1 +118,1 @@\n-                MemoryScope.BasicCleanupAction.of(cleanup) : MemoryScope.CleanupAction.DUMMY;\n+                MemoryScope.CleanupAction.AtMostOnceOnly.of(cleanup) : MemoryScope.CleanupAction.DUMMY;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -43,0 +44,1 @@\n+import java.util.function.Function;\n@@ -60,1 +62,1 @@\n-    public void test(int n, Supplier<Cleaner> cleanerFactory) {\n+    public void test(int n, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n@@ -63,0 +65,1 @@\n+        \/\/ register cleaners before\n@@ -66,0 +69,9 @@\n+        segment = segmentFunction.apply(segment);\n+        if (segment.isAlive()) {\n+            \/\/ also register cleaners after\n+            for (int i = 0; i < n; i++) {\n+                segment.registerCleaner(cleanerFactory.get());\n+            }\n+        }\n+        \/\/check that cleanup has not been called by any cleaner yet!\n+        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n@@ -80,1 +92,18 @@\n-        return MemorySegment.ofNativeRestricted(MemoryAddress.NULL, 10, null, segmentState::cleanup, null);\n+        return MemorySegment.ofNativeRestricted(MemoryAddress.NULL, 10, Thread.currentThread(), segmentState::cleanup, null);\n+    }\n+\n+    enum SegmentFunction implements Function<MemorySegment, MemorySegment> {\n+        IDENTITY(Function.identity()),\n+        CLOSE(s -> { s.close(); return s; }),\n+        SHARE(s -> { return s.withOwnerThread(null); });\n+\n+        private final Function<MemorySegment, MemorySegment> segmentFunction;\n+\n+        SegmentFunction(Function<MemorySegment, MemorySegment> segmentFunction) {\n+            this.segmentFunction = segmentFunction;\n+        }\n+\n+        @Override\n+        public MemorySegment apply(MemorySegment segment) {\n+            return segmentFunction.apply(segment);\n+        }\n@@ -85,14 +114,3 @@\n-        Supplier<Cleaner> CLEANER = Cleaner::create;\n-        Supplier<Cleaner> CLEANER_FACTORY = CleanerFactory::cleaner;\n-\n-        return new Object[][]{\n-                { 1, CLEANER },\n-                { 2, CLEANER },\n-                { 4, CLEANER },\n-                { 8, CLEANER },\n-                { 16, CLEANER },\n-                { 1, CLEANER_FACTORY },\n-                { 2, CLEANER_FACTORY },\n-                { 4, CLEANER_FACTORY },\n-                { 8, CLEANER_FACTORY },\n-                { 16, CLEANER_FACTORY },\n+        Supplier<?>[] cleaners = {\n+                (Supplier<Cleaner>)Cleaner::create,\n+                (Supplier<Cleaner>)CleanerFactory::cleaner\n@@ -100,0 +118,16 @@\n+\n+        int[] ncleaners = { 1, 2, 4, 8, 16 };\n+\n+        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n+        Object[][] data = new Object[cleaners.length * ncleaners.length * segmentFunctions.length][3];\n+\n+        for (int ncleaner = 0 ; ncleaner < ncleaners.length ; ncleaner++) {\n+            for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n+                for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n+                    data[ncleaner + ncleaners.length * cleaner + (cleaners.length * ncleaners.length * segmentFunction)] =\n+                            new Object[] { ncleaners[ncleaner], cleaners[cleaner], segmentFunctions[segmentFunction] };\n+                }\n+            }\n+        }\n+\n+        return data;\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"}]}