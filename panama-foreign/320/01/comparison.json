{"files":[{"patch":"@@ -219,1 +219,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.foreign;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.ref.Cleaner;\n@@ -105,0 +106,4 @@\n+ * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n+ * that segment will be released when the segment becomes <em>unreachable<\/em> (see {@link #registerCleaner(Cleaner)});\n+ * this might be useful to prevent native memory leaks.\n+ *\n@@ -190,0 +195,14 @@\n+    \/**\n+     * Register this memory segment instance against a {@link Cleaner} object. This allows for the segment to be closed\n+     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n+     * @apiNote Calling this method multiple times, even concurrently (from multiple threads, if this segment is shared)\n+     * is allowed; the implementation guarantees that the memory resources associated with this segment will be released\n+     * at most once. Also, in case the segment has been closed explicitly (see {@link #close}) no further action will be\n+     * taken by the GC when the segment later becomes unreachable.\n+     * @param cleaner the {@link Cleaner} object responsible for cleaning up this memory segment.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment\n+     * @throws UnsupportedOperationException if this segment does not feature the {@link #CLOSE} access mode.\n+     *\/\n+    void registerCleaner(Cleaner cleaner);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.lang.ref.Cleaner;\n@@ -297,0 +298,7 @@\n+    @Override\n+    public void registerCleaner(Cleaner cleaner) {\n+        checkAccessModes(CLOSE);\n+        checkValidState();\n+        cleaner.register(this.scope, scope.cleanupAction);\n+    }\n+\n@@ -570,1 +578,1 @@\n-            bufferScope = MemoryScope.createConfined(bb, null);\n+            bufferScope = MemoryScope.createConfined(bb, MemoryScope.CleanupAction.DUMMY);\n@@ -586,1 +594,1 @@\n-        0, 0, MemoryScope.createShared(null, null)\n+        0, 0, MemoryScope.createShared(null, MemoryScope.CleanupAction.DUMMY)\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, null);\n+        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -106,1 +104,6 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap);\n+            MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n+                @Override\n+                void doCleanup() {\n+                    unmapperProxy.unmap();\n+                }\n+            });\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.ref.Reference;\n+import java.util.Objects;\n@@ -50,1 +52,2 @@\n-    private MemoryScope(Object ref, Runnable cleanupAction) {\n+    private MemoryScope(Object ref, CleanupAction cleanupAction) {\n+        Objects.requireNonNull(cleanupAction);\n@@ -59,1 +62,1 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -62,1 +65,1 @@\n-    static MemoryScope createConfined(Object ref, Runnable cleanupAction) {\n+    static MemoryScope createConfined(Object ref, CleanupAction cleanupAction) {\n@@ -69,1 +72,1 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -72,1 +75,1 @@\n-    static MemoryScope createConfined(Thread owner, Object ref, Runnable cleanupAction) {\n+    static MemoryScope createConfined(Thread owner, Object ref, CleanupAction cleanupAction) {\n@@ -79,1 +82,1 @@\n-     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n+     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n@@ -82,1 +85,1 @@\n-    static MemoryScope createShared(Object ref, Runnable cleanupAction) {\n+    static MemoryScope createShared(Object ref, CleanupAction cleanupAction) {\n@@ -86,2 +89,2 @@\n-    protected Object ref;\n-    protected Runnable cleanupAction;\n+    protected final Object ref;\n+    protected final CleanupAction cleanupAction;\n@@ -105,3 +108,5 @@\n-        justClose();\n-        if (cleanupAction != null) {\n-            cleanupAction.run();\n+        try {\n+            justClose();\n+            cleanupAction.cleanup();\n+        } finally {\n+            Reference.reachabilityFence(this);\n@@ -121,2 +126,6 @@\n-        justClose();\n-        return new ConfinedScope(newOwner, ref, cleanupAction);\n+        try {\n+            justClose();\n+            return new ConfinedScope(newOwner, ref, cleanupAction.dup());\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n@@ -133,2 +142,6 @@\n-        justClose();\n-        return new SharedScope(ref, cleanupAction);\n+        try {\n+            justClose();\n+            return new SharedScope(ref, cleanupAction.dup());\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n@@ -185,1 +198,1 @@\n-        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction) {\n+        public ConfinedScope(Thread owner, Object ref, CleanupAction cleanupAction) {\n@@ -231,1 +244,1 @@\n-        SharedScope(Object ref, Runnable cleanupAction) {\n+        SharedScope(Object ref, CleanupAction cleanupAction) {\n@@ -257,0 +270,102 @@\n+\n+    \/**\n+     * A functional interface modelling the cleanup action associated with a scope.\n+     *\/\n+    interface CleanupAction extends Runnable {\n+        void cleanup();\n+        CleanupAction dup();\n+\n+        @Override\n+        default void run() {\n+            cleanup();\n+        }\n+\n+        \/** Dummy cleanup action *\/\n+        CleanupAction DUMMY = new CleanupAction() {\n+            @Override\n+            public void cleanup() {\n+                \/\/ do nothing\n+            }\n+\n+            @Override\n+            public CleanupAction dup() {\n+                return this;\n+            }\n+        };\n+\n+        \/**\n+         * A stateful cleanup action; this action can only be called at most once. The implementation\n+         * guarantees this invariant even when multiple threads race to call the {@link #cleanup()} method.\n+         *\/\n+        abstract class AtMostOnceOnly implements CleanupAction {\n+\n+            static final VarHandle CALLED;\n+\n+            static {\n+                try {\n+                    CALLED = MethodHandles.lookup().findVarHandle(AtMostOnceOnly.class, \"called\", boolean.class);\n+                } catch (Throwable ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            }\n+\n+            private boolean called = false;\n+\n+            abstract void doCleanup();\n+\n+            public final void cleanup() {\n+                if (disable()) {\n+                    doCleanup();\n+                }\n+            };\n+\n+            @Override\n+            public CleanupAction dup() {\n+                disable();\n+                class DupAction extends AtMostOnceOnly {\n+                    final AtMostOnceOnly root;\n+\n+                    DupAction(AtMostOnceOnly root) {\n+                        this.root = root;\n+                    }\n+\n+                    @Override\n+                    void doCleanup() {\n+                        root.doCleanup();\n+                    }\n+\n+                    @Override\n+                    public CleanupAction dup() {\n+                        disable();\n+                        return new DupAction(root);\n+                    }\n+                }\n+                return new DupAction(this);\n+            }\n+\n+            final boolean disable() {\n+                \/\/ This can fail under normal circumstances. The only case where a failure can happen is when\n+                \/\/ when two cleaners race to cleanup the same scope. It is never possible to have a race\n+                \/\/ between explicit\/implicit close because all the scope terminal operations have\n+                \/\/ reachability fences which prevent a scope to be deemed unreachable before we are done\n+                \/\/ marking the original cleanup action as \"dead\".\n+                return CALLED.compareAndSet(this, false, true);\n+            }\n+\n+            \/**\n+             * Returns a custom {@code BasicCleanupAction} based on given {@link Runnable} instance.\n+             * @param runnable the runnable to be executed when {@link #cleanup()} is called on the returned cleanup action.\n+             * @return the new cleanup action.\n+             *\/\n+            static AtMostOnceOnly of(Runnable runnable) {\n+                Objects.requireNonNull(runnable);\n+                return new AtMostOnceOnly() {\n+                    @Override\n+                    void doCleanup() {\n+                        runnable.run();\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":133,"deletions":18,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.internal.access.JavaNioAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -102,3 +100,6 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n-            unsafe.freeMemory(buf);\n-            nioAccess.unreserveMemory(alignedSize, bytesSize);\n+        MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n+            @Override\n+            void doCleanup() {\n+                unsafe.freeMemory(buf);\n+                nioAccess.unreserveMemory(alignedSize, bytesSize);\n+            }\n@@ -116,0 +117,2 @@\n+        MemoryScope.CleanupAction cleanupAction = cleanup != null ?\n+                MemoryScope.CleanupAction.AtMostOnceOnly.of(cleanup) : MemoryScope.CleanupAction.DUMMY;\n@@ -117,2 +120,2 @@\n-                MemoryScope.createShared(attachment, cleanup) :\n-                MemoryScope.createConfined(owner, attachment, cleanup);\n+                MemoryScope.createShared(attachment, cleanupAction) :\n+                MemoryScope.createConfined(owner, attachment, cleanupAction);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\/jdk.incubator.foreign\n+ * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import java.lang.ref.Cleaner;\n+import jdk.internal.ref.CleanerFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class TestCleaner {\n+\n+    static class SegmentState {\n+        private AtomicInteger cleanupCalls = new AtomicInteger(0);\n+\n+        void cleanup() {\n+            cleanupCalls.incrementAndGet();\n+        }\n+\n+        int cleanupCalls() {\n+            return cleanupCalls.get();\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void test(int n, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n+        SegmentState segmentState = new SegmentState();\n+        MemorySegment segment = makeSegment(segmentState);\n+        \/\/ register cleaners before\n+        for (int i = 0 ; i < n ; i++) {\n+            segment.registerCleaner(cleanerFactory.get());\n+        }\n+        segment = segmentFunction.apply(segment);\n+        if (segment.isAlive()) {\n+            \/\/ also register cleaners after\n+            for (int i = 0; i < n; i++) {\n+                segment.registerCleaner(cleanerFactory.get());\n+            }\n+        }\n+        \/\/check that cleanup has not been called by any cleaner yet!\n+        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n+        segment = null;\n+        while (segmentState.cleanupCalls() == 0) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n+        assertEquals(segmentState.cleanupCalls(), 1);\n+    }\n+\n+    MemorySegment makeSegment(SegmentState segmentState) {\n+        return MemorySegment.ofNativeRestricted(MemoryAddress.NULL, 10, Thread.currentThread(), segmentState::cleanup, null);\n+    }\n+\n+    enum SegmentFunction implements Function<MemorySegment, MemorySegment> {\n+        IDENTITY(Function.identity()),\n+        CLOSE(s -> { s.close(); return s; }),\n+        SHARE(s -> { return s.withOwnerThread(null); });\n+\n+        private final Function<MemorySegment, MemorySegment> segmentFunction;\n+\n+        SegmentFunction(Function<MemorySegment, MemorySegment> segmentFunction) {\n+            this.segmentFunction = segmentFunction;\n+        }\n+\n+        @Override\n+        public MemorySegment apply(MemorySegment segment) {\n+            return segmentFunction.apply(segment);\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] cleaners() {\n+        Supplier<?>[] cleaners = {\n+                (Supplier<Cleaner>)Cleaner::create,\n+                (Supplier<Cleaner>)CleanerFactory::cleaner\n+        };\n+\n+        int[] ncleaners = { 1, 2, 4, 8, 16 };\n+\n+        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n+        Object[][] data = new Object[cleaners.length * ncleaners.length * segmentFunctions.length][3];\n+\n+        for (int ncleaner = 0 ; ncleaner < ncleaners.length ; ncleaner++) {\n+            for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n+                for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n+                    data[ncleaner + ncleaners.length * cleaner + (cleaners.length * ncleaners.length * segmentFunction)] =\n+                            new Object[] { ncleaners[ncleaner], cleaners[cleaner], segmentFunctions[segmentFunction] };\n+                }\n+            }\n+        }\n+\n+        return data;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -338,1 +338,2 @@\n-                \"withOwnerThread\"\n+                \"withOwnerThread\",\n+                \"registerCleaner\"\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}