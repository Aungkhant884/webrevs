{"files":[{"patch":"@@ -95,1 +95,1 @@\n-<p><strong>September 2020<\/strong><\/p>\n+<p><strong>October 2020<\/strong><\/p>\n@@ -97,1 +97,2 @@\n-<li>Tweaked references to restricted segments to use new API<\/li>\n+<li>Adjust reference to NativeScope handoff<\/li>\n+<li>Tweak references to restricted segments to use new API<\/li>\n@@ -286,1 +287,1 @@\n-<a class=\"sourceLine\" id=\"cb19-2\" title=\"2\">    comparFunc = scope.<span class=\"fu\">register<\/span>(comparFunc);<\/a>\n+<a class=\"sourceLine\" id=\"cb19-2\" title=\"2\">    comparFunc = comparFunc.<span class=\"fu\">handoff<\/span>(scope);<\/a>\n@@ -291,1 +292,1 @@\n-<p>Not only native scope helps in making the allocation of the native array simpler (we no longer need to create an heap segment, and dump its contents onto the off-heap array); but we can also use the native scope to <em>register<\/em> the existing upcall stub segments. When we do that, we obtain a <em>new<\/em> segment, whose temporal bounds are the same as that of the native scope; the old segment will be killed and will no longer be usable. As with all segments returned by native scope, the registered segment we get back will be non-closeable — the only way to close it is to close the native scope it belongs to.<\/p>\n+<p>Not only native scope helps in making the allocation of the native array simpler (we no longer need to create an heap segment, and dump its contents onto the off-heap array); but we can also use the native scope as an <em>handoff target<\/em> for existing upcall stub segments. When we do that, we obtain a <em>new<\/em> segment, whose temporal bounds are the same as that of the native scope; the old segment will be killed and will no longer be usable. As with all segments returned by native scope, the new segment we get back will be non-closeable — the only way to close it is to close the native scope it belongs to.<\/p>\n@@ -396,1 +397,1 @@\n-<a class=\"sourceLine\" id=\"cb27-64\" title=\"64\">            comparFunc = scope.<span class=\"fu\">register<\/span>(comparFunc);<\/a>\n+<a class=\"sourceLine\" id=\"cb27-64\" title=\"64\">            comparFunc = comparFunc.<span class=\"fu\">handoff<\/span>(scope);<\/a>\n","filename":"doc\/panama_ffi.html","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-**September 2020**\n+**October 2020**\n@@ -5,1 +5,2 @@\n-* Tweaked references to restricted segments to use new API\n+* Adjust reference to NativeScope handoff\n+* Tweak references to restricted segments to use new API\n@@ -262,1 +263,1 @@\n-    comparFunc = scope.register(comparFunc);\n+    comparFunc = comparFunc.handoff(scope);\n@@ -269,1 +270,1 @@\n-Not only native scope helps in making the allocation of the native array simpler (we no longer need to create an heap segment, and dump its contents onto the off-heap array); but we can also use the native scope to *register* the existing upcall stub segments. When we do that, we obtain a *new* segment, whose temporal bounds are the same as that of the native scope; the old segment will be killed and will no longer be usable. As with all segments returned by native scope, the registered segment we get back will be non-closeable — the only way to close it is to close the native scope it belongs to.\n+Not only native scope helps in making the allocation of the native array simpler (we no longer need to create an heap segment, and dump its contents onto the off-heap array); but we can also use the native scope as an *handoff target* for existing upcall stub segments. When we do that, we obtain a *new* segment, whose temporal bounds are the same as that of the native scope; the old segment will be killed and will no longer be usable. As with all segments returned by native scope, the new segment we get back will be non-closeable — the only way to close it is to close the native scope it belongs to.\n@@ -413,1 +414,1 @@\n-            comparFunc = scope.register(comparFunc);\n+            comparFunc = comparFunc.handoff(scope);\n","filename":"doc\/panama_ffi.md","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-<p><strong>September 2020<\/strong><\/p>\n+<p><strong>October 2020<\/strong><\/p>\n@@ -99,0 +99,1 @@\n+<li>Reflect latest API changes in handoff\/implicit deallocation<\/li>\n@@ -239,2 +240,2 @@\n-<a class=\"sourceLine\" id=\"cb17-3\" title=\"3\">var segmentB = segmentA.<span class=\"fu\">withOwnerThread<\/span>(threadB); <span class=\"co\">\/\/ confined by thread B<\/span><\/a><\/code><\/pre><\/div>\n-<p>This pattern of access is also known as <em>serial confinement<\/em> and might be useful in producer\/consumer use cases where only one thread at a time needs to access a segment. Note that, to make the handoff operation safe, the API <em>kills<\/em> the original segment (as if <code>close<\/code> was called, but without releasing the underlying memory) and returns a <em>new<\/em> segment with the correct owner. The implementation also makes sure that all writes by the first thread are flushed into memory by the time the second thread accesses the segment.<\/p>\n+<a class=\"sourceLine\" id=\"cb17-3\" title=\"3\">var segmentB = segmentA.<span class=\"fu\">handoff<\/span>(threadB); <span class=\"co\">\/\/ confined by thread B<\/span><\/a><\/code><\/pre><\/div>\n+<p>This pattern of access is also known as <em>serial confinement<\/em> and might be useful in producer\/consumer use cases where only one thread at a time needs to access a segment. Note that, to make the handoff operation safe, the API <em>kills<\/em> the original segment (as if <code>close<\/code> was called, but without releasing the underlying memory) and returns a <em>new<\/em> segment with the correct owner. That is, handoff operations are <em>terminal operations<\/em> (like <code>MemorySegment::close<\/code>). The implementation also makes sure that all writes by the first thread are flushed into memory by the time the second thread accesses the segment.<\/p>\n@@ -244,1 +245,1 @@\n-<a class=\"sourceLine\" id=\"cb18-3\" title=\"3\">var sharedSegment = segmentA.<span class=\"fu\">withOwnerThread<\/span>(<span class=\"kw\">null<\/span>); <span class=\"co\">\/\/ shared segment<\/span><\/a><\/code><\/pre><\/div>\n+<a class=\"sourceLine\" id=\"cb18-3\" title=\"3\">var sharedSegment = segmentA.<span class=\"fu\">share<\/span>() <span class=\"co\">\/\/ shared segment<\/span><\/a><\/code><\/pre><\/div>\n@@ -250,1 +251,1 @@\n-<a class=\"sourceLine\" id=\"cb19-5\" title=\"5\"><span class=\"dt\">int<\/span> sum = StreamSupport.<span class=\"fu\">stream<\/span>(MemorySegment.<span class=\"fu\">spliterator<\/span>(segment.<span class=\"fu\">withOwnerThread<\/span>(<span class=\"kw\">null<\/span>), seq_bulk), <span class=\"kw\">true<\/span>)<\/a>\n+<a class=\"sourceLine\" id=\"cb19-5\" title=\"5\"><span class=\"dt\">int<\/span> sum = StreamSupport.<span class=\"fu\">stream<\/span>(MemorySegment.<span class=\"fu\">spliterator<\/span>(segment.<span class=\"fu\">share<\/span>(), seq_bulk), <span class=\"kw\">true<\/span>)<\/a>\n@@ -264,1 +265,1 @@\n-<a class=\"sourceLine\" id=\"cb20-4\" title=\"4\">segment = segment.<span class=\"fu\">withOwnerThread<\/span>(<span class=\"kw\">null<\/span>);<\/a>\n+<a class=\"sourceLine\" id=\"cb20-4\" title=\"4\">segment = segment.<span class=\"fu\">share<\/span>();<\/a>\n@@ -267,1 +268,1 @@\n-<a class=\"sourceLine\" id=\"cb20-7\" title=\"7\">segment.<span class=\"fu\">withOwnerThread<\/span>(<span class=\"bu\">Thread<\/span>.<span class=\"fu\">currentThread<\/span>()); <span class=\"co\">\/\/ now confined by thread B<\/span><\/a>\n+<a class=\"sourceLine\" id=\"cb20-7\" title=\"7\">segment.<span class=\"fu\">handoff<\/span>(<span class=\"bu\">Thread<\/span>.<span class=\"fu\">currentThread<\/span>()); <span class=\"co\">\/\/ now confined by thread B<\/span><\/a>\n@@ -274,1 +275,1 @@\n-<a class=\"sourceLine\" id=\"cb21-3\" title=\"3\">segment.<span class=\"fu\">registerCleaner<\/span>(cleaner);<\/a>\n+<a class=\"sourceLine\" id=\"cb21-3\" title=\"3\">segment = segment.<span class=\"fu\">registerCleaner<\/span>(cleaner);<\/a>\n@@ -277,1 +278,1 @@\n-<p>Note that registering a segment with a cleaner doesn't prevent clients from calling <code>MemorySegment::close<\/code> explicitly; the API will guarantee that the segment's cleanup action will be called at most once — either explicitly, or implicitly (by a cleaner). Moreover, since an unreachable segment cannot (by definition) be accessed by any thread, the cleaner can always release any memory resources associated with an unreachable segment, regardless of whether it is a confined, or a shared segment.<\/p>\n+<p>As for handoff, registering a segment with a cleaner <em>kills<\/em> the current segment and returns a new one which features implicit deallocation; this is also a <em>terminal operation<\/em>. Note that registering a segment with a cleaner doesn't prevent clients from calling <code>MemorySegment::close<\/code> explicitly on the returned segment; the API will guarantee that the segment's cleanup action will be called at most once — either explicitly, or implicitly (by a cleaner). Moreover, since an unreachable segment cannot (by definition) be accessed by any thread, the cleaner can always release any memory resources associated with an unreachable segment, regardless of whether it is a confined, or a shared segment.<\/p>\n","filename":"doc\/panama_memaccess.html","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-**September 2020**\n+**October 2020**\n@@ -5,0 +5,1 @@\n+* Reflect latest API changes in handoff\/implicit deallocation\n@@ -247,1 +248,1 @@\n-var segmentB = segmentA.withOwnerThread(threadB); \/\/ confined by thread B\n+var segmentB = segmentA.handoff(threadB); \/\/ confined by thread B\n@@ -250,1 +251,1 @@\n-This pattern of access is also known as *serial confinement* and might be useful in producer\/consumer use cases where only one thread at a time needs to access a segment. Note that, to make the handoff operation safe, the API *kills* the original segment (as if `close` was called, but without releasing the underlying memory) and returns a *new* segment with the correct owner. The implementation also makes sure that all writes by the first thread are flushed into memory by the time the second thread accesses the segment.\n+This pattern of access is also known as *serial confinement* and might be useful in producer\/consumer use cases where only one thread at a time needs to access a segment. Note that, to make the handoff operation safe, the API *kills* the original segment (as if `close` was called, but without releasing the underlying memory) and returns a *new* segment with the correct owner. That is, handoff operations are *terminal operations* (like `MemorySegment::close`). The implementation also makes sure that all writes by the first thread are flushed into memory by the time the second thread accesses the segment.\n@@ -257,1 +258,1 @@\n-var sharedSegment = segmentA.withOwnerThread(null); \/\/ shared segment\n+var sharedSegment = segmentA.share() \/\/ shared segment\n@@ -267,1 +268,1 @@\n-int sum = StreamSupport.stream(MemorySegment.spliterator(segment.withOwnerThread(null), seq_bulk), true)\n+int sum = StreamSupport.stream(MemorySegment.spliterator(segment.share(), seq_bulk), true)\n@@ -287,1 +288,1 @@\n-segment = segment.withOwnerThread(null);\n+segment = segment.share();\n@@ -290,1 +291,1 @@\n-segment.withOwnerThread(Thread.currentThread()); \/\/ now confined by thread B\n+segment.handoff(Thread.currentThread()); \/\/ now confined by thread B\n@@ -303,1 +304,1 @@\n-segment.registerCleaner(cleaner);\n+segment = segment.registerCleaner(cleaner);\n@@ -308,1 +309,1 @@\n-Note that registering a segment with a cleaner doesn't prevent clients from calling `MemorySegment::close` explicitly; the API will guarantee that the segment's cleanup action will be called at most once — either explicitly, or implicitly (by a cleaner). Moreover, since an unreachable segment cannot (by definition) be accessed by any thread, the cleaner can always release any memory resources associated with an unreachable segment, regardless of whether it is a confined, or a shared segment.\n+As for handoff, registering a segment with a cleaner *kills* the current segment and returns a new one which features implicit deallocation; this is also a *terminal operation*. Note that registering a segment with a cleaner doesn't prevent clients from calling `MemorySegment::close` explicitly on the returned segment; the API will guarantee that the segment's cleanup action will be called at most once — either explicitly, or implicitly (by a cleaner). Moreover, since an unreachable segment cannot (by definition) be accessed by any thread, the cleaner can always release any memory resources associated with an unreachable segment, regardless of whether it is a confined, or a shared segment.\n","filename":"doc\/panama_memaccess.md","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"}]}