{"files":[{"patch":"@@ -50,36 +50,3 @@\n-public abstract class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout> extends AbstractLayout<L> {\n-\n-    \/**\n-     * The group kind.\n-     *\/\n-    enum Kind {\n-        \/**\n-         * A 'struct' kind.\n-         *\/\n-        STRUCT(\"\", Math::addExact),\n-        \/**\n-         * A 'union' kind.\n-         *\/\n-        UNION(\"|\", Math::max);\n-\n-        final String delimTag;\n-        final LongBinaryOperator sizeOp;\n-\n-        Kind(String delimTag, LongBinaryOperator sizeOp) {\n-            this.delimTag = delimTag;\n-            this.sizeOp = sizeOp;\n-        }\n-\n-        long sizeof(List<MemoryLayout> elems) {\n-            long size = 0;\n-            for (MemoryLayout elem : elems) {\n-                size = sizeOp.applyAsLong(size, elem.bitSize());\n-            }\n-            return size;\n-        }\n-\n-        long alignof(List<MemoryLayout> elems) {\n-            return elems.stream().mapToLong(MemoryLayout::bitAlignment).max() \/\/ max alignment in case we have member layouts\n-                    .orElse(1); \/\/ or minimal alignment if no member layout is given\n-        }\n-    }\n+public sealed abstract class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout>\n+        extends AbstractLayout<L>\n+        permits StructLayoutImpl, UnionLayoutImpl {\n@@ -94,2 +61,2 @@\n-    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Optional<String> name) {\n-        super(kind.sizeof(elements), alignment, name);\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+        super(kind.sizeof(elements), bitAlignment, name); \/\/ Subclassing creates toctou problems here\n@@ -109,1 +76,1 @@\n-    public List<MemoryLayout> memberLayouts() {\n+    public final List<MemoryLayout> memberLayouts() {\n@@ -117,1 +84,1 @@\n-    public String toString() {\n+    public final String toString() {\n@@ -126,1 +93,1 @@\n-    public boolean isStruct() {\n+    public final boolean isStruct() {\n@@ -133,1 +100,1 @@\n-    public boolean isUnion() {\n+    public final boolean isUnion() {\n@@ -141,1 +108,1 @@\n-    public boolean equals(Object other) {\n+    public final boolean equals(Object other) {\n@@ -157,1 +124,1 @@\n-    public int hashCode() {\n+    public final int hashCode() {\n@@ -162,2 +129,2 @@\n-    public boolean hasNaturalAlignment() {\n-        return bitAlignment == kind.alignof(elements);\n+    public final boolean hasNaturalAlignment() {\n+        return bitAlignment() == kind.alignof(elements);\n@@ -166,0 +133,36 @@\n+    \/**\n+     * The group kind.\n+     *\/\n+    enum Kind {\n+        \/**\n+         * A 'struct' kind.\n+         *\/\n+        STRUCT(\"\", Math::addExact),\n+        \/**\n+         * A 'union' kind.\n+         *\/\n+        UNION(\"|\", Math::max);\n+\n+        final String delimTag;\n+        final LongBinaryOperator sizeOp;\n+\n+        Kind(String delimTag, LongBinaryOperator sizeOp) {\n+            this.delimTag = delimTag;\n+            this.sizeOp = sizeOp;\n+        }\n+\n+        long sizeof(List<MemoryLayout> elems) {\n+            long size = 0;\n+            for (MemoryLayout elem : elems) {\n+                size = sizeOp.applyAsLong(size, elem.bitSize());\n+            }\n+            return size;\n+        }\n+\n+        long alignof(List<MemoryLayout> elems) {\n+            return elems.stream()\n+                    .mapToLong(MemoryLayout::bitAlignment)\n+                    .max() \/\/ max alignment in case we have member layouts\n+                    .orElse(1); \/\/ or minimal alignment if no member layout is given\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":49,"deletions":46,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-abstract class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout> {\n+abstract sealed class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout>\n+        permits AbstractGroupLayout, PaddingLayoutImpl, SequenceLayoutImpl, ValueLayouts.AbstractValueLayout {\n@@ -39,1 +40,1 @@\n-    public final long bitAlignment;\n+    private final long bitAlignment;\n@@ -42,1 +43,1 @@\n-    long byteSize;\n+    private long byteSize;\n@@ -50,1 +51,1 @@\n-    public L withName(String name) {\n+    public final L withName(String name) {\n@@ -59,3 +60,1 @@\n-    abstract L dup(long alignment, Optional<String> name);\n-\n-    public L withBitAlignment(long alignmentBits) {\n+    public final L withBitAlignment(long alignmentBits) {\n@@ -66,7 +65,0 @@\n-    public void checkAlignment(long alignmentBitCount) {\n-        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n-                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n-            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n-        }\n-    }\n-\n@@ -78,1 +70,1 @@\n-    public long byteSize() {\n+    public final long byteSize() {\n@@ -86,1 +78,1 @@\n-    public long bitSize() {\n+    public final long bitSize() {\n@@ -90,10 +82,0 @@\n-    public String decorateLayoutString(String s) {\n-        if (name().isPresent()) {\n-            s = String.format(\"%s(%s)\", s, name().get());\n-        }\n-        if (!hasNaturalAlignment()) {\n-            s = bitAlignment + \"%\" + s;\n-        }\n-        return s;\n-    }\n-\n@@ -105,1 +87,1 @@\n-        return this instanceof PaddingLayout;\n+        return false;\n@@ -152,0 +134,21 @@\n+\n+    abstract L dup(long alignment, Optional<String> name);\n+\n+    String decorateLayoutString(String s) {\n+        if (name().isPresent()) {\n+            s = String.format(\"%s(%s)\", s, name().get());\n+        }\n+        if (!hasNaturalAlignment()) {\n+            s = bitAlignment + \"%\" + s;\n+        }\n+        return s;\n+    }\n+\n+    private static void checkAlignment(long alignmentBitCount) {\n+        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n+                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n+            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n+        }\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -48,11 +48,0 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static <V extends ValueLayout> V createIfNeeded(V nativeOrderValueLayout,\n-                                                           ByteOrder newByteOrder) {\n-        requireNonNull(nativeOrderValueLayout);\n-        if (ByteOrder.nativeOrder() == newByteOrder) {\n-            return nativeOrderValueLayout;\n-        } else {\n-            \/\/ This cast will always succeed because ValueLayout::withOrder returns an instance of the same type.\n-            return (V) nativeOrderValueLayout.withOrder(newByteOrder);\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,0 +76,4 @@\n+    @Override\n+    public boolean isPadding() {\n+        return true;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/PaddingLayoutImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        return new SequenceLayoutImpl(elementCount, elementLayout, bitAlignment, name());\n+        return new SequenceLayoutImpl(elementCount, elementLayout, bitAlignment(), name());\n@@ -212,1 +212,1 @@\n-        return bitAlignment == elementLayout.bitAlignment();\n+        return bitAlignment() == elementLayout.bitAlignment();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-    private static final Kind KIND = Kind.STRUCT;\n-\n@@ -38,1 +36,1 @@\n-        super(KIND, elements);\n+        super(Kind.STRUCT, elements);\n@@ -42,1 +40,1 @@\n-        super(KIND, elements, bitAlignment, name);\n+        super(Kind.STRUCT, elements, bitAlignment, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-    private static final Kind KIND = Kind.UNION;\n-\n@@ -38,1 +36,1 @@\n-        super(KIND, elements);\n+        super(Kind.UNION, elements);\n@@ -42,1 +40,1 @@\n-        super(KIND, elements, bitAlignment, name);\n+        super(Kind.UNION, elements, bitAlignment, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n-    abstract static class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n+    abstract sealed static class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n+\n+        static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n@@ -71,2 +73,2 @@\n-\n-        static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+        @Stable\n+        private VarHandle handle;\n@@ -88,1 +90,1 @@\n-        public ByteOrder order() {\n+        public final ByteOrder order() {\n@@ -105,1 +107,1 @@\n-        public String toString() {\n+        public final String toString() {\n@@ -130,1 +132,1 @@\n-        public VarHandle arrayElementVarHandle(int... shape) {\n+        public final VarHandle arrayElementVarHandle(int... shape) {\n@@ -148,1 +150,1 @@\n-        public Class<?> carrier() {\n+        public final Class<?> carrier() {\n@@ -190,2 +192,0 @@\n-        @Stable\n-        private VarHandle handle;\n@@ -194,1 +194,1 @@\n-        public VarHandle accessHandle() {\n+        public final VarHandle accessHandle() {\n@@ -203,1 +203,1 @@\n-        V self() {\n+        final V self() {\n@@ -232,1 +232,1 @@\n-            return new OfBooleanImpl(order, bitAlignment, name());\n+            return new OfBooleanImpl(order, bitAlignment(), name());\n@@ -264,1 +264,1 @@\n-            return new OfByteImpl(order, bitAlignment, name());\n+            return new OfByteImpl(order, bitAlignment(), name());\n@@ -298,1 +298,1 @@\n-            return new OfCharImpl(order, bitAlignment, name());\n+            return new OfCharImpl(order, bitAlignment(), name());\n@@ -332,1 +332,1 @@\n-            return new OfShortImpl(order, bitAlignment, name());\n+            return new OfShortImpl(order, bitAlignment(), name());\n@@ -366,1 +366,1 @@\n-            return new OfIntImpl(order, bitAlignment, name());\n+            return new OfIntImpl(order, bitAlignment(), name());\n@@ -400,1 +400,1 @@\n-            return new OfFloatImpl(order, bitAlignment, name());\n+            return new OfFloatImpl(order, bitAlignment(), name());\n@@ -434,1 +434,1 @@\n-            return new OfLongImpl(order, bitAlignment, name());\n+            return new OfLongImpl(order, bitAlignment(), name());\n@@ -466,1 +466,1 @@\n-            return new OfDoubleImpl(order, bitAlignment, name());\n+            return new OfDoubleImpl(order, bitAlignment(), name());\n@@ -504,1 +504,1 @@\n-            return new OfAddressImpl(order, bitSize(), bitAlignment, isUnbounded, name());\n+            return new OfAddressImpl(order, bitSize(), bitAlignment(), isUnbounded, name());\n@@ -522,1 +522,1 @@\n-            return new OfAddressImpl(order(), bitSize(), bitAlignment, true, name());\n+            return new OfAddressImpl(order(), bitSize(), bitAlignment(), true, name());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"}]}