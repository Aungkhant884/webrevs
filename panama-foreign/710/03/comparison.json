{"files":[{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-abstract non-sealed class AbstractLayout implements MemoryLayout {\n-\n-    private final long bitSize;\n-    final long bitAlignment;\n-    private final Optional<String> name;\n-    @Stable\n-    long byteSize;\n-\n-    AbstractLayout(long bitSize, long bitAlignment, Optional<String> name) {\n-        this.bitSize = bitSize;\n-        this.bitAlignment = bitAlignment;\n-        this.name = name;\n-    }\n-\n-    @Override\n-    public AbstractLayout withName(String name) {\n-        Objects.requireNonNull(name);\n-        return dup(bitAlignment, Optional.of(name));\n-    }\n-\n-    @Override\n-    public final Optional<String> name() {\n-        return name;\n-    }\n-\n-    abstract AbstractLayout dup(long bitAlignment, Optional<String> name);\n-\n-    @Override\n-    public AbstractLayout withBitAlignment(long bitAlignment) {\n-        checkAlignment(bitAlignment);\n-        return dup(bitAlignment, name);\n-    }\n-\n-    void checkAlignment(long alignmentBitCount) {\n-        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n-                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n-            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n-        }\n-    }\n-\n-    static void checkSize(long size) {\n-        checkSize(size, false);\n-    }\n-\n-    static void checkSize(long size, boolean allowZero) {\n-        if (size < 0 || (!allowZero && size == 0)) {\n-            throw new IllegalArgumentException(\"Invalid size for layout: \" + size);\n-        }\n-    }\n-\n-    @Override\n-    public final long bitAlignment() {\n-        return bitAlignment;\n-    }\n-\n-    @Override\n-    @ForceInline\n-    public long byteSize() {\n-        if (byteSize == 0) {\n-            byteSize = Utils.bitsToBytesOrThrow(bitSize(),\n-                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n-        }\n-        return byteSize;\n-    }\n-\n-    @Override\n-    public long bitSize() {\n-        return bitSize;\n-    }\n-\n-    String decorateLayoutString(String s) {\n-        if (name().isPresent()) {\n-            s = String.format(\"%s(%s)\", s, name().get());\n-        }\n-        if (!hasNaturalAlignment()) {\n-            s = bitAlignment + \"%\" + s;\n-        }\n-        return s;\n-    }\n-\n-    boolean hasNaturalAlignment() {\n-        return bitSize == bitAlignment;\n-    }\n-\n-    @Override\n-    public boolean isPadding() {\n-        return this instanceof PaddingLayout;\n-    }\n-\n-    \/\/ the following methods have to copy the same Javadoc as in MemoryLayout, or subclasses will just show\n-    \/\/ the Object methods javadoc\n-\n-    \/**\n-     * {@return the hash code value for this layout}\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(name, bitSize, bitAlignment);\n-    }\n-\n-    \/**\n-     * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified\n-     * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of\n-     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n-     * conditions must be satisfied:\n-     * <ul>\n-     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n-     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n-     *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and\n-     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal<\/li>\n-     *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},\n-     *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n-     * <\/ul>\n-     *\n-     * @param other the object to be compared for equality with this layout.\n-     * @return {@code true} if the specified object is equal to this layout.\n-     *\/\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-\n-        return other instanceof AbstractLayout otherLayout &&\n-                name.equals(otherLayout.name) &&\n-                bitSize == otherLayout.bitSize &&\n-                bitAlignment == otherLayout.bitAlignment;\n-    }\n-\n-    \/**\n-     * {@return the string representation of this layout}\n-     *\/\n-    public abstract String toString();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AbstractLayout.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Collections;\n@@ -30,4 +29,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.LongBinaryOperator;\n-import java.util.stream.Collectors;\n@@ -48,49 +43,1 @@\n-public final class GroupLayout extends AbstractLayout implements MemoryLayout {\n-\n-    \/**\n-     * The group kind.\n-     *\/\n-    enum Kind {\n-        \/**\n-         * A 'struct' kind.\n-         *\/\n-        STRUCT(\"\", Math::addExact),\n-        \/**\n-         * A 'union' kind.\n-         *\/\n-        UNION(\"|\", Math::max);\n-\n-        final String delimTag;\n-        final LongBinaryOperator sizeOp;\n-\n-        Kind(String delimTag, LongBinaryOperator sizeOp) {\n-            this.delimTag = delimTag;\n-            this.sizeOp = sizeOp;\n-        }\n-\n-        long sizeof(List<MemoryLayout> elems) {\n-            long size = 0;\n-            for (MemoryLayout elem : elems) {\n-                size = sizeOp.applyAsLong(size, elem.bitSize());\n-            }\n-            return size;\n-        }\n-\n-        long alignof(List<MemoryLayout> elems) {\n-            return elems.stream().mapToLong(MemoryLayout::bitAlignment).max() \/\/ max alignment in case we have member layouts\n-                    .orElse(1); \/\/ or minimal alignment if no member layout is given\n-        }\n-    }\n-\n-    private final Kind kind;\n-    private final List<MemoryLayout> elements;\n-\n-    GroupLayout(Kind kind, List<MemoryLayout> elements) {\n-        this(kind, elements, kind.alignof(elements), Optional.empty());\n-    }\n-\n-    GroupLayout(Kind kind, List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n-        super(kind.sizeof(elements), bitAlignment, name);\n-        this.kind = kind;\n-        this.elements = elements;\n-    }\n+public sealed interface GroupLayout extends MemoryLayout permits StructLayout, UnionLayout {\n@@ -107,13 +54,1 @@\n-    public List<MemoryLayout> memberLayouts() {\n-        return Collections.unmodifiableList(elements);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public String toString() {\n-        return decorateLayoutString(elements.stream()\n-                .map(Object::toString)\n-                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n-    }\n+    List<MemoryLayout> memberLayouts();\n@@ -124,3 +59,1 @@\n-    public boolean isStruct() {\n-        return kind == Kind.STRUCT;\n-    }\n+    boolean isStruct();\n@@ -131,3 +64,1 @@\n-    public boolean isUnion() {\n-        return kind == Kind.UNION;\n-    }\n+    boolean isUnion();\n@@ -135,3 +66,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -139,11 +67,1 @@\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof GroupLayout otherGroup &&\n-                kind == otherGroup.kind &&\n-                elements.equals(otherGroup.elements);\n-    }\n+    GroupLayout withName(String name);\n@@ -151,32 +69,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), kind, elements);\n-    }\n-\n-    @Override\n-    GroupLayout dup(long bitAlignment, Optional<String> name) {\n-        return new GroupLayout(kind, elements, bitAlignment, name);\n-    }\n-\n-    @Override\n-    boolean hasNaturalAlignment() {\n-        return bitAlignment == kind.alignof(elements);\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public GroupLayout withName(String name) {\n-        return (GroupLayout)super.withName(name);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -184,3 +70,1 @@\n-    public GroupLayout withBitAlignment(long bitAlignment) {\n-        return (GroupLayout)super.withBitAlignment(bitAlignment);\n-    }\n+    GroupLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":6,"deletions":122,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.foreign.layout.*;\n@@ -168,1 +169,1 @@\n-public sealed interface MemoryLayout permits AbstractLayout, SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n+public sealed interface MemoryLayout permits SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n@@ -617,3 +618,3 @@\n-    static MemoryLayout paddingLayout(long size) {\n-        AbstractLayout.checkSize(size);\n-        return new PaddingLayout(size);\n+    static PaddingLayout paddingLayout(long size) {\n+        MemoryLayoutUtil.checkSize(size);\n+        return PaddingLayoutImpl.of(size);\n@@ -645,1 +646,1 @@\n-            return new ValueLayout.OfBoolean(order);\n+            return ValueLayout.OfBoolean.of(order);\n@@ -647,1 +648,1 @@\n-            return new ValueLayout.OfChar(order);\n+            return ValueLayout.OfChar.of(order);\n@@ -649,1 +650,1 @@\n-            return new ValueLayout.OfByte(order);\n+            return ValueLayout.OfByte.of(order);\n@@ -651,1 +652,1 @@\n-            return new ValueLayout.OfShort(order);\n+            return ValueLayout.OfShort.of(order);\n@@ -653,1 +654,1 @@\n-            return new ValueLayout.OfInt(order);\n+            return ValueLayout.OfInt.of(order);\n@@ -655,1 +656,1 @@\n-            return new ValueLayout.OfFloat(order);\n+            return ValueLayout.OfFloat.of(order);\n@@ -657,1 +658,1 @@\n-            return new ValueLayout.OfLong(order);\n+            return ValueLayout.OfLong.of(order);\n@@ -659,1 +660,1 @@\n-            return new ValueLayout.OfDouble(order);\n+            return ValueLayout.OfDouble.of(order);\n@@ -661,1 +662,1 @@\n-            return new ValueLayout.OfAddress(order);\n+            return ValueLayout.OfAddress.of(order);\n@@ -676,4 +677,4 @@\n-            AbstractLayout.checkSize(elementCount, true);\n-            Objects.requireNonNull(elementLayout);\n-            return wrapOverflow(() ->\n-                    new SequenceLayout(elementCount, elementLayout));\n+        MemoryLayoutUtil.checkSize(elementCount, true);\n+        Objects.requireNonNull(elementLayout);\n+        return wrapOverflow(() ->\n+                SequenceLayoutImpl.of(elementCount, elementLayout));\n@@ -707,1 +708,1 @@\n-    static GroupLayout structLayout(MemoryLayout... elements) {\n+    static StructLayout structLayout(MemoryLayout... elements) {\n@@ -710,4 +711,3 @@\n-                new GroupLayout(GroupLayout.Kind.STRUCT,\n-                        Stream.of(elements)\n-                                .map(Objects::requireNonNull)\n-                                .collect(Collectors.toList())));\n+                StructLayoutImpl.of(Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList())));\n@@ -722,1 +722,1 @@\n-    static GroupLayout unionLayout(MemoryLayout... elements) {\n+    static UnionLayout unionLayout(MemoryLayout... elements) {\n@@ -724,4 +724,3 @@\n-        return new GroupLayout(GroupLayout.Kind.UNION,\n-                Stream.of(elements)\n-                        .map(Objects::requireNonNull)\n-                        .collect(Collectors.toList()));\n+        return UnionLayoutImpl.of(Stream.of(elements)\n+                .map(Objects::requireNonNull)\n+                .collect(Collectors.toList()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -1158,1 +1159,1 @@\n-        return (byte)layout.accessHandle().get(this, offset);\n+        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n@@ -1180,1 +1181,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n@@ -1201,1 +1202,1 @@\n-        return (boolean)layout.accessHandle().get(this, offset);\n+        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n@@ -1223,1 +1224,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n@@ -1244,1 +1245,1 @@\n-        return (char)layout.accessHandle().get(this, offset);\n+        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n@@ -1266,1 +1267,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n@@ -1287,1 +1288,1 @@\n-        return (short)layout.accessHandle().get(this, offset);\n+        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n@@ -1309,1 +1310,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n@@ -1330,1 +1331,1 @@\n-        return (int)layout.accessHandle().get(this, offset);\n+        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n@@ -1352,1 +1353,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n@@ -1373,1 +1374,1 @@\n-        return (float)layout.accessHandle().get(this, offset);\n+        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n@@ -1395,1 +1396,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n@@ -1416,1 +1417,1 @@\n-        return (long)layout.accessHandle().get(this, offset);\n+        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n@@ -1438,1 +1439,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n@@ -1459,1 +1460,1 @@\n-        return (double)layout.accessHandle().get(this, offset);\n+        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n@@ -1481,1 +1482,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n@@ -1505,1 +1506,1 @@\n-        return (MemorySegment)layout.accessHandle().get(this, offset);\n+        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n@@ -1527,1 +1528,1 @@\n-        layout.accessHandle().set(this, offset, value);\n+        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n@@ -1551,1 +1552,1 @@\n-        return (char)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1576,1 +1577,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1600,1 +1601,1 @@\n-        return (short)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1625,1 +1626,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1649,1 +1650,1 @@\n-        return (int)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1674,1 +1675,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1698,1 +1699,1 @@\n-        return (float)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1723,1 +1724,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1747,1 +1748,1 @@\n-        return (long)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1772,1 +1773,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1796,1 +1797,1 @@\n-        return (double)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1821,1 +1822,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1849,1 +1850,1 @@\n-        return (MemorySegment)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1874,1 +1875,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":33,"deletions":32,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import java.util.Objects;\n-import java.util.Optional;\n+import jdk.internal.foreign.layout.PaddingLayoutImpl;\n@@ -36,1 +35,1 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -38,46 +37,1 @@\n-\/* package-private *\/ final class PaddingLayout extends AbstractLayout implements MemoryLayout {\n-\n-    PaddingLayout(long bitSize) {\n-        this(bitSize, 1, Optional.empty());\n-    }\n-\n-    PaddingLayout(long bitSize, long bitAlignment, Optional<String> name) {\n-        super(bitSize, bitAlignment, name);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return decorateLayoutString(\"x\" + bitSize());\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        if (!(other instanceof PaddingLayout p)) {\n-            return false;\n-        }\n-        return bitSize() == p.bitSize();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), bitSize());\n-    }\n-\n-    @Override\n-    PaddingLayout dup(long bitAlignment, Optional<String> name) {\n-        return new PaddingLayout(bitSize(), bitAlignment, name);\n-    }\n-\n-    @Override\n-    public boolean hasNaturalAlignment() {\n-        return true;\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n+public sealed interface PaddingLayout extends MemoryLayout permits PaddingLayoutImpl {\n@@ -89,3 +43,1 @@\n-    public PaddingLayout withName(String name) {\n-        return (PaddingLayout)super.withName(name);\n-    }\n+    PaddingLayout withName(String name);\n@@ -97,3 +49,1 @@\n-    public PaddingLayout withBitAlignment(long bitAlignment) {\n-        return (PaddingLayout)super.withBitAlignment(bitAlignment);\n-    }\n+    PaddingLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":5,"deletions":55,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.util.Objects;\n-import java.util.Optional;\n-\n+import jdk.internal.foreign.layout.SequenceLayoutImpl;\n@@ -58,8 +56,1 @@\n-public final class SequenceLayout extends AbstractLayout implements MemoryLayout {\n-\n-    private final long elemCount;\n-    private final MemoryLayout elementLayout;\n-\n-    SequenceLayout(long elemCount, MemoryLayout elementLayout) {\n-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n-    }\n+public sealed interface SequenceLayout extends MemoryLayout permits SequenceLayoutImpl {\n@@ -67,5 +58,0 @@\n-    SequenceLayout(long elemCount, MemoryLayout elementLayout, long bitAlignment, Optional<String> name) {\n-        super(Math.multiplyExact(elemCount, elementLayout.bitSize()), bitAlignment, name);\n-        this.elemCount = elemCount;\n-        this.elementLayout = elementLayout;\n-    }\n@@ -76,3 +62,1 @@\n-    public MemoryLayout elementLayout() {\n-        return elementLayout;\n-    }\n+    MemoryLayout elementLayout();\n@@ -83,3 +67,1 @@\n-    public long elementCount() {\n-        return elemCount;\n-    }\n+    long elementCount();\n@@ -94,4 +76,1 @@\n-    public SequenceLayout withElementCount(long elementCount) {\n-        AbstractLayout.checkSize(elementCount, true);\n-        return new SequenceLayout(elementCount, elementLayout, bitAlignment, name());\n-    }\n+    SequenceLayout withElementCount(long elementCount);\n@@ -132,41 +111,1 @@\n-    public SequenceLayout reshape(long... elementCounts) {\n-        Objects.requireNonNull(elementCounts);\n-        if (elementCounts.length == 0) {\n-            throw new IllegalArgumentException();\n-        }\n-        SequenceLayout flat = flatten();\n-        long expectedCount = flat.elementCount();\n-\n-        long actualCount = 1;\n-        int inferPosition = -1;\n-        for (int i = 0 ; i < elementCounts.length ; i++) {\n-            if (elementCounts[i] == -1) {\n-                if (inferPosition == -1) {\n-                    inferPosition = i;\n-                } else {\n-                    throw new IllegalArgumentException(\"Too many unspecified element counts\");\n-                }\n-            } else if (elementCounts[i] <= 0) {\n-                throw new IllegalArgumentException(\"Invalid element count: \" + elementCounts[i]);\n-            } else {\n-                actualCount = elementCounts[i] * actualCount;\n-            }\n-        }\n-\n-        \/\/ infer an unspecified element count (if any)\n-        if (inferPosition != -1) {\n-            long inferredCount = expectedCount \/ actualCount;\n-            elementCounts[inferPosition] = inferredCount;\n-            actualCount = actualCount * inferredCount;\n-        }\n-\n-        if (actualCount != expectedCount) {\n-            throw new IllegalArgumentException(\"Element counts do not match expected size: \" + expectedCount);\n-        }\n-\n-        MemoryLayout res = flat.elementLayout();\n-        for (int i = elementCounts.length - 1 ; i >= 0 ; i--) {\n-            res = MemoryLayout.sequenceLayout(elementCounts[i], res);\n-        }\n-        return (SequenceLayout)res;\n-    }\n+    SequenceLayout reshape(long... elementCounts);\n@@ -190,28 +129,1 @@\n-    public SequenceLayout flatten() {\n-        long count = elementCount();\n-        MemoryLayout elemLayout = elementLayout();\n-        while (elemLayout instanceof SequenceLayout elemSeq) {\n-            count = count * elemSeq.elementCount();\n-            elemLayout = elemSeq.elementLayout();\n-        }\n-        return MemoryLayout.sequenceLayout(count, elemLayout);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return decorateLayoutString(String.format(\"[%s:%s]\",\n-                elemCount, elementLayout));\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof SequenceLayout otherSeq &&\n-                elemCount == otherSeq.elemCount &&\n-                elementLayout.equals(otherSeq.elementLayout);\n-    }\n+    SequenceLayout flatten();\n@@ -220,3 +132,1 @@\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), elemCount, elementLayout);\n-    }\n+    SequenceLayout withName(String name);\n@@ -225,27 +135,1 @@\n-    SequenceLayout dup(long bitAlignment, Optional<String> name) {\n-        return new SequenceLayout(elementCount(), elementLayout, bitAlignment, name);\n-    }\n-\n-    @Override\n-    boolean hasNaturalAlignment() {\n-        return bitAlignment == elementLayout.bitAlignment();\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public SequenceLayout withName(String name) {\n-        return (SequenceLayout)super.withName(name);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public SequenceLayout withBitAlignment(long bitAlignment) {\n-        return (SequenceLayout)super.withBitAlignment(bitAlignment);\n-    }\n+    SequenceLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":9,"deletions":125,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.layout.StructLayoutImpl;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A <em>struct<\/em> layout where member layouts are laid out one after the other (see {@link MemoryLayout#structLayout(MemoryLayout...)}).\n+ *\n+ * @implSpec\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface StructLayout extends GroupLayout permits StructLayoutImpl {\n+\n+    @Override\n+    StructLayout withName(String name);\n+\n+    @Override\n+    StructLayout withBitAlignment(long alignmentBits);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.layout.UnionLayoutImpl;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A <em>union<\/em> layout where member layouts are laid out at the same starting offset (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ *\n+ * @implSpec\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public sealed interface UnionLayout extends GroupLayout permits UnionLayoutImpl {\n+\n+    @Override\n+    UnionLayout withName(String name);\n+\n+    @Override\n+    UnionLayout withBitAlignment(long alignmentBits);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -31,2 +31,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -34,1 +32,0 @@\n-import java.util.Optional;\n@@ -36,1 +33,2 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.layout.MemoryLayoutUtil;\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -38,1 +36,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -40,4 +37,0 @@\n-import jdk.internal.reflect.Reflection;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-import sun.invoke.util.Wrapper;\n@@ -56,2 +49,1 @@\n- * @implSpec\n- * This class and its subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * @implSpec implementing classes and subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -62,17 +54,1 @@\n-public sealed class ValueLayout extends AbstractLayout implements MemoryLayout {\n-\n-    private final Class<?> carrier;\n-    private final ByteOrder order;\n-\n-    private static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n-\n-    ValueLayout(Class<?> carrier, ByteOrder order, long bitSize) {\n-        this(carrier, order, bitSize, bitSize, Optional.empty());\n-    }\n-\n-    ValueLayout(Class<?> carrier, ByteOrder order, long bitSize, long bitAlignment, Optional<String> name) {\n-        super(bitSize, bitAlignment, name);\n-        this.carrier = carrier;\n-        this.order = order;\n-        checkCarrierSize(carrier, bitSize);\n-    }\n+public sealed interface ValueLayout extends MemoryLayout {\n@@ -83,3 +59,1 @@\n-    public ByteOrder order() {\n-        return order;\n-    }\n+    ByteOrder order();\n@@ -94,31 +68,1 @@\n-    public ValueLayout withOrder(ByteOrder order) {\n-        return new ValueLayout(carrier, Objects.requireNonNull(order), bitSize(), bitAlignment, name());\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public String toString() {\n-        char descriptor = carrier == MemorySegment.class ? 'A' : carrier.descriptorString().charAt(0);\n-        if (order == ByteOrder.LITTLE_ENDIAN) {\n-            descriptor = Character.toLowerCase(descriptor);\n-        }\n-        return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof ValueLayout otherValue &&\n-                carrier.equals(otherValue.carrier) &&\n-                order.equals(otherValue.order);\n-    }\n+    ValueLayout withOrder(ByteOrder order);\n@@ -183,14 +127,1 @@\n-    public VarHandle arrayElementVarHandle(int... shape) {\n-        Objects.requireNonNull(shape);\n-        MemoryLayout layout = this;\n-        List<PathElement> path = new ArrayList<>();\n-        for (int i = shape.length ; i > 0 ; i--) {\n-            int size = shape[i - 1];\n-            if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n-            layout = MemoryLayout.sequenceLayout(size, layout);\n-            path.add(PathElement.sequenceElement());\n-        }\n-        layout = MemoryLayout.sequenceLayout(layout);\n-        path.add(PathElement.sequenceElement());\n-        return layout.varHandle(path.toArray(new PathElement[0]));\n-    }\n+    VarHandle arrayElementVarHandle(int... shape);\n@@ -201,3 +132,1 @@\n-    public Class<?> carrier() {\n-        return carrier;\n-    }\n+    Class<?> carrier();\n@@ -205,3 +134,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -209,3 +135,1 @@\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), order, carrier);\n-    }\n+    ValueLayout withName(String name);\n@@ -214,61 +138,1 @@\n-    ValueLayout dup(long bitAlignment, Optional<String> name) {\n-        return new ValueLayout(carrier, order, bitSize(), bitAlignment, name());\n-    }\n-\n-    \/\/hack: the declarations below are to make javadoc happy; we could have used generics in AbstractLayout\n-    \/\/but that causes issues with javadoc, see JDK-8224052\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public ValueLayout withName(String name) {\n-        return (ValueLayout)super.withName(name);\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public ValueLayout withBitAlignment(long bitAlignment) {\n-        return (ValueLayout)super.withBitAlignment(bitAlignment);\n-    }\n-\n-    static void checkCarrierSize(Class<?> carrier, long size) {\n-        if (!isValidCarrier(carrier)) {\n-            throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n-        }\n-        if (carrier == MemorySegment.class && size != ADDRESS_SIZE_BITS) {\n-            throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n-        }\n-        if (carrier.isPrimitive()) {\n-            int expectedSize =  carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n-            if (size != expectedSize) {\n-                throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n-            }\n-        }\n-    }\n-\n-    static boolean isValidCarrier(Class<?> carrier) {\n-        return carrier == boolean.class\n-                || carrier == byte.class\n-                || carrier == short.class\n-                || carrier == char.class\n-                || carrier == int.class\n-                || carrier == long.class\n-                || carrier == float.class\n-                || carrier == double.class\n-                || carrier == MemorySegment.class;\n-    }\n-\n-    @Stable\n-    private VarHandle handle;\n-\n-    @ForceInline\n-    VarHandle accessHandle() {\n-        if (handle == null) {\n-            \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n-            handle = Utils.makeSegmentViewVarHandle(this);\n-        }\n-        return handle;\n-    }\n+    ValueLayout withBitAlignment(long bitAlignment);\n@@ -281,9 +145,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfBoolean extends ValueLayout {\n-        OfBoolean(ByteOrder order) {\n-            super(boolean.class, order, 8);\n-        }\n-\n-        OfBoolean(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(boolean.class, order, 8, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n@@ -292,3 +149,1 @@\n-        OfBoolean dup(long bitAlignment, Optional<String> name) {\n-            return new OfBoolean(order(), bitAlignment, name);\n-        }\n+        OfBoolean withName(String name);\n@@ -297,3 +152,1 @@\n-        public OfBoolean withName(String name) {\n-            return (OfBoolean)super.withName(name);\n-        }\n+        OfBoolean withBitAlignment(long alignmentBits);\n@@ -302,3 +155,1 @@\n-        public OfBoolean withBitAlignment(long bitAlignment) {\n-            return (OfBoolean)super.withBitAlignment(bitAlignment);\n-        }\n+        OfBoolean withOrder(ByteOrder order);\n@@ -306,2 +157,6 @@\n-        @Override\n-        public OfBoolean withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfBoolean with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfBoolean of(ByteOrder order) {\n@@ -309,1 +164,1 @@\n-            return new OfBoolean(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfBooleanImpl.ofNativeOrder(), order);\n@@ -318,9 +173,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfByte extends ValueLayout {\n-        OfByte(ByteOrder order) {\n-            super(byte.class, order, 8);\n-        }\n-\n-        OfByte(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(byte.class, order, 8, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n@@ -329,3 +177,1 @@\n-        OfByte dup(long bitAlignment, Optional<String> name) {\n-            return new OfByte(order(), bitAlignment, name);\n-        }\n+        OfByte withName(String name);\n@@ -334,3 +180,1 @@\n-        public OfByte withName(String name) {\n-            return (OfByte)super.withName(name);\n-        }\n+        OfByte withBitAlignment(long alignmentBits);\n@@ -339,3 +183,1 @@\n-        public OfByte withBitAlignment(long bitAlignment) {\n-            return (OfByte)super.withBitAlignment(bitAlignment);\n-        }\n+        OfByte withOrder(ByteOrder order);\n@@ -343,2 +185,6 @@\n-        @Override\n-        public OfByte withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfByte with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfByte of(ByteOrder order) {\n@@ -346,1 +192,1 @@\n-            return new OfByte(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfByteImpl.ofNativeOrder(), order);\n@@ -355,9 +201,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfChar extends ValueLayout {\n-        OfChar(ByteOrder order) {\n-            super(char.class, order, 16);\n-        }\n-\n-        OfChar(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(char.class, order, 16, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n@@ -366,3 +205,1 @@\n-        OfChar dup(long bitAlignment, Optional<String> name) {\n-            return new OfChar(order(), bitAlignment, name);\n-        }\n+        OfChar withName(String name);\n@@ -371,3 +208,1 @@\n-        public OfChar withName(String name) {\n-            return (OfChar)super.withName(name);\n-        }\n+        OfChar withBitAlignment(long alignmentBits);\n@@ -376,3 +211,1 @@\n-        public OfChar withBitAlignment(long bitAlignment) {\n-            return (OfChar)super.withBitAlignment(bitAlignment);\n-        }\n+        OfChar withOrder(ByteOrder order);\n@@ -380,2 +213,6 @@\n-        @Override\n-        public OfChar withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfChar with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfChar of(ByteOrder order) {\n@@ -383,1 +220,1 @@\n-            return new OfChar(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfCharImpl.ofNativeOrder(), order);\n@@ -392,9 +229,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfShort extends ValueLayout {\n-        OfShort(ByteOrder order) {\n-            super(short.class, order, 16);\n-        }\n-\n-        OfShort(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(short.class, order, 16, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n@@ -403,3 +233,1 @@\n-        OfShort dup(long bitAlignment, Optional<String> name) {\n-            return new OfShort(order(), bitAlignment, name);\n-        }\n+        OfShort withName(String name);\n@@ -408,3 +236,1 @@\n-        public OfShort withName(String name) {\n-            return (OfShort)super.withName(name);\n-        }\n+        OfShort withBitAlignment(long alignmentBits);\n@@ -413,3 +239,1 @@\n-        public OfShort withBitAlignment(long bitAlignment) {\n-            return (OfShort)super.withBitAlignment(bitAlignment);\n-        }\n+        OfShort withOrder(ByteOrder order);\n@@ -417,2 +241,6 @@\n-        @Override\n-        public OfShort withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfShort with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfShort of(ByteOrder order) {\n@@ -420,1 +248,1 @@\n-            return new OfShort(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfShortImpl.ofNativeOrder(), order);\n@@ -429,9 +257,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfInt extends ValueLayout {\n-        OfInt(ByteOrder order) {\n-            super(int.class, order, 32);\n-        }\n-\n-        OfInt(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(int.class, order, 32, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n@@ -440,3 +261,1 @@\n-        OfInt dup(long bitAlignment, Optional<String> name) {\n-            return new OfInt(order(), bitAlignment, name);\n-        }\n+        OfInt withName(String name);\n@@ -445,3 +264,1 @@\n-        public OfInt withName(String name) {\n-            return (OfInt)super.withName(name);\n-        }\n+        OfInt withBitAlignment(long alignmentBits);\n@@ -450,3 +267,1 @@\n-        public OfInt withBitAlignment(long bitAlignment) {\n-            return (OfInt)super.withBitAlignment(bitAlignment);\n-        }\n+        OfInt withOrder(ByteOrder order);\n@@ -454,2 +269,6 @@\n-        @Override\n-        public OfInt withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfInt with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfInt of(ByteOrder order) {\n@@ -457,1 +276,1 @@\n-            return new OfInt(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfIntImpl.ofNativeOrder(), order);\n@@ -466,9 +285,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfFloat extends ValueLayout {\n-        OfFloat(ByteOrder order) {\n-            super(float.class, order, 32);\n-        }\n-\n-        OfFloat(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(float.class, order, 32, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n@@ -477,3 +289,1 @@\n-        OfFloat dup(long bitAlignment, Optional<String> name) {\n-            return new OfFloat(order(), bitAlignment, name);\n-        }\n+        OfFloat withName(String name);\n@@ -482,3 +292,1 @@\n-        public OfFloat withName(String name) {\n-            return (OfFloat)super.withName(name);\n-        }\n+        OfFloat withBitAlignment(long alignmentBits);\n@@ -487,3 +295,1 @@\n-        public OfFloat withBitAlignment(long bitAlignment) {\n-            return (OfFloat)super.withBitAlignment(bitAlignment);\n-        }\n+        OfFloat withOrder(ByteOrder order);\n@@ -491,2 +297,6 @@\n-        @Override\n-        public OfFloat withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfFloat with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfFloat of(ByteOrder order) {\n@@ -494,1 +304,1 @@\n-            return new OfFloat(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfFloatImpl.ofNativeOrder(), order);\n@@ -503,9 +313,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfLong extends ValueLayout {\n-        OfLong(ByteOrder order) {\n-            super(long.class, order, 64);\n-        }\n-\n-        OfLong(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(long.class, order, 64, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n@@ -514,3 +317,1 @@\n-        OfLong dup(long bitAlignment, Optional<String> name) {\n-            return new OfLong(order(), bitAlignment, name);\n-        }\n+        OfLong withName(String name);\n@@ -519,3 +320,1 @@\n-        public OfLong withName(String name) {\n-            return (OfLong)super.withName(name);\n-        }\n+        OfLong withBitAlignment(long alignmentBits);\n@@ -524,3 +323,1 @@\n-        public OfLong withBitAlignment(long bitAlignment) {\n-            return (OfLong)super.withBitAlignment(bitAlignment);\n-        }\n+        OfLong withOrder(ByteOrder order);\n@@ -528,2 +325,6 @@\n-        @Override\n-        public OfLong withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfLong with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfLong of(ByteOrder order) {\n@@ -531,1 +332,1 @@\n-            return new OfLong(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfLongImpl.ofNativeOrder(), order);\n@@ -540,9 +341,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfDouble extends ValueLayout {\n-        OfDouble(ByteOrder order) {\n-            super(double.class, order, 64);\n-        }\n-\n-        OfDouble(ByteOrder order, long bitAlignment, Optional<String> name) {\n-            super(double.class, order, 64, bitAlignment, name);\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n@@ -551,3 +345,1 @@\n-        OfDouble dup(long bitAlignment, Optional<String> name) {\n-            return new OfDouble(order(), bitAlignment, name);\n-        }\n+        OfDouble withName(String name);\n@@ -556,3 +348,1 @@\n-        public OfDouble withName(String name) {\n-            return (OfDouble)super.withName(name);\n-        }\n+        OfDouble withBitAlignment(long alignmentBits);\n@@ -561,3 +351,1 @@\n-        public OfDouble withBitAlignment(long bitAlignment) {\n-            return (OfDouble)super.withBitAlignment(bitAlignment);\n-        }\n+        OfDouble withOrder(ByteOrder order);\n@@ -565,2 +353,6 @@\n-        @Override\n-        public OfDouble withOrder(ByteOrder order) {\n+        \/**\n+         * {@return an OfDouble with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfDouble of(ByteOrder order) {\n@@ -568,1 +360,1 @@\n-            return new OfDouble(order, bitAlignment, name());\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfDoubleImpl.ofNativeOrder(), order);\n@@ -577,14 +369,2 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static final class OfAddress extends ValueLayout {\n-\n-        private final boolean isUnbounded;\n-\n-        OfAddress(ByteOrder order) {\n-            super(MemorySegment.class, order, ADDRESS_SIZE_BITS);\n-            this.isUnbounded = false; \/\/ safe\n-        }\n-\n-        OfAddress(ByteOrder order, long bitSize, long bitAlignment, boolean isUnbounded, Optional<String> name) {\n-            super(MemorySegment.class, order, bitSize, bitAlignment, name);\n-            this.isUnbounded = isUnbounded;\n-        }\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    sealed interface OfAddress extends ValueLayout permits ValueLayouts.OfAddressImpl {\n@@ -593,13 +373,1 @@\n-        OfAddress dup(long bitAlignment, Optional<String> name) {\n-            return new OfAddress(order(), bitSize(), bitAlignment, isUnbounded, name);\n-        }\n-\n-        @Override\n-        public OfAddress withName(String name) {\n-            return (OfAddress)super.withName(name);\n-        }\n-\n-        @Override\n-        public OfAddress withBitAlignment(long bitAlignment) {\n-            return (OfAddress)super.withBitAlignment(bitAlignment);\n-        }\n+        OfAddress withName(String name);\n@@ -608,4 +376,1 @@\n-        public OfAddress withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfAddress(order, bitSize(), bitAlignment, isUnbounded, name());\n-        }\n+        OfAddress withBitAlignment(long alignmentBits);\n@@ -614,9 +379,1 @@\n-        public boolean equals(Object other) {\n-            return super.equals(other) &&\n-                    ((OfAddress)other).isUnbounded == this.isUnbounded;\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), isUnbounded);\n-        }\n+        OfAddress withOrder(ByteOrder order);\n@@ -639,4 +396,1 @@\n-        public OfAddress asUnbounded() {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), ValueLayout.OfAddress.class, \"asUnbounded\");\n-            return new OfAddress(order(), bitSize(), bitAlignment, true, name());\n-        }\n+        OfAddress asUnbounded();\n@@ -647,2 +401,10 @@\n-        public boolean isUnbounded() {\n-            return isUnbounded;\n+        boolean isUnbounded();\n+\n+        \/**\n+         * {@return an OfAddress with the provided {@code order}} ;\n+         *\n+         * @param order the byte order to use\n+         *\/\n+        static OfAddress of(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return MemoryLayoutUtil.createIfNeeded(ValueLayouts.OfAddressImpl.ofNativeOrder(), order);\n@@ -657,1 +419,1 @@\n-     * MemoryLayout.valueLayout(MemorySegment.class, ByteOrder.nativeOrder())\n+     * OfAddress.of(ByteOrder.nativeOrder())\n@@ -661,1 +423,1 @@\n-    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder());\n+    OfAddress ADDRESS = ValueLayouts.OfAddressImpl.ofNativeOrder();\n@@ -668,1 +430,1 @@\n-     * MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * OfByte.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n@@ -671,1 +433,1 @@\n-    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder());\n+    OfByte JAVA_BYTE = ValueLayouts.OfByteImpl.ofNativeOrder();\n@@ -678,1 +440,1 @@\n-     * MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * OfBoolean.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n@@ -681,1 +443,1 @@\n-    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder());\n+    OfBoolean JAVA_BOOLEAN = ValueLayouts.OfBooleanImpl.ofNativeOrder();\n@@ -688,1 +450,1 @@\n-     * MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * OfChar.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n@@ -691,1 +453,1 @@\n-    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder());\n+    OfChar JAVA_CHAR = ValueLayouts.OfCharImpl.ofNativeOrder();\n@@ -698,1 +460,1 @@\n-     * MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * OfShort.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n@@ -701,1 +463,1 @@\n-    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder());\n+    OfShort JAVA_SHORT = ValueLayouts.OfShortImpl.ofNativeOrder();\n@@ -708,1 +470,1 @@\n-     * MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * OfInt.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n@@ -711,1 +473,1 @@\n-    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder());\n+    OfInt JAVA_INT = ValueLayouts.OfIntImpl.ofNativeOrder();\n@@ -718,1 +480,1 @@\n-     * MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * OfLong.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n@@ -721,1 +483,1 @@\n-    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder());\n+    OfLong JAVA_LONG = ValueLayouts.OfLongImpl.ofNativeOrder();\n@@ -728,1 +490,1 @@\n-     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * OfFloat.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n@@ -731,1 +493,1 @@\n-    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder());\n+    OfFloat JAVA_FLOAT = ValueLayouts.OfFloatImpl.ofNativeOrder();\n@@ -738,1 +500,1 @@\n-     * MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * OfDouble.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n@@ -741,1 +503,1 @@\n-    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder());\n+    OfDouble JAVA_DOUBLE = ValueLayouts.OfDoubleImpl.ofNativeOrder();\n@@ -753,1 +515,1 @@\n-    public static final OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+    OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n@@ -765,1 +527,1 @@\n-    public static final OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n+    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n@@ -777,1 +539,1 @@\n-    public static final OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n+    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n@@ -789,1 +551,1 @@\n-    public static final OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n+    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n@@ -801,1 +563,1 @@\n-    public static final OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n+    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n@@ -813,1 +575,1 @@\n-    public static final OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n+    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n@@ -825,1 +587,1 @@\n-    public static final OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n+    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":147,"deletions":385,"binary":false,"changes":532,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.LongBinaryOperator;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A compound layout that aggregates multiple <em>member layouts<\/em>. There are two ways in which member layouts\n+ * can be combined: if member layouts are laid out one after the other, the resulting group layout is said to be a <em>struct<\/em>\n+ * (see {@link MemoryLayout#structLayout(MemoryLayout...)}); conversely, if all member layouts are laid out at the same starting offset,\n+ * the resulting group layout is said to be a <em>union<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+ *\n+ * @implSpec\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+public abstract class AbstractGroupLayout<L extends AbstractGroupLayout<L> & MemoryLayout> extends AbstractLayout<L> {\n+\n+    \/**\n+     * The group kind.\n+     *\/\n+    enum Kind {\n+        \/**\n+         * A 'struct' kind.\n+         *\/\n+        STRUCT(\"\", Math::addExact),\n+        \/**\n+         * A 'union' kind.\n+         *\/\n+        UNION(\"|\", Math::max);\n+\n+        final String delimTag;\n+        final LongBinaryOperator sizeOp;\n+\n+        Kind(String delimTag, LongBinaryOperator sizeOp) {\n+            this.delimTag = delimTag;\n+            this.sizeOp = sizeOp;\n+        }\n+\n+        long sizeof(List<MemoryLayout> elems) {\n+            long size = 0;\n+            for (MemoryLayout elem : elems) {\n+                size = sizeOp.applyAsLong(size, elem.bitSize());\n+            }\n+            return size;\n+        }\n+\n+        long alignof(List<MemoryLayout> elems) {\n+            return elems.stream().mapToLong(MemoryLayout::bitAlignment).max() \/\/ max alignment in case we have member layouts\n+                    .orElse(1); \/\/ or minimal alignment if no member layout is given\n+        }\n+    }\n+\n+    private final Kind kind;\n+    private final List<MemoryLayout> elements;\n+\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements) {\n+        this(kind, elements, kind.alignof(elements), Optional.empty());\n+    }\n+\n+    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Optional<String> name) {\n+        super(kind.sizeof(elements), alignment, name);\n+        this.kind = kind;\n+        this.elements = List.copyOf(elements);\n+    }\n+\n+    \/**\n+     * Returns the member layouts associated with this group.\n+     *\n+     * @apiNote the order in which member layouts are returned is the same order in which member layouts have\n+     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n+     * {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n+     *\n+     * @return the member layouts associated with this group.\n+     *\/\n+    public List<MemoryLayout> memberLayouts() {\n+        return Collections.unmodifiableList(elements);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String toString() {\n+        return decorateLayoutString(elements.stream()\n+                .map(Object::toString)\n+                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n+    }\n+\n+    \/**\n+     * {@return {@code true}, if this group layout is a struct layout}\n+     *\/\n+    public boolean isStruct() {\n+        return kind == Kind.STRUCT;\n+    }\n+\n+    \/**\n+     * {@return {@code true}, if this group layout is a union layout}\n+     *\/\n+    public boolean isUnion() {\n+        return kind == Kind.UNION;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!super.equals(other)) {\n+            return false;\n+        }\n+        return other instanceof AbstractGroupLayout<?> otherGroup &&\n+                kind == otherGroup.kind &&\n+                elements.equals(otherGroup.elements);\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), kind, elements);\n+    }\n+\n+    @Override\n+    public boolean hasNaturalAlignment() {\n+        return bitAlignment == kind.alignof(elements);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.foreign.*;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+abstract class AbstractLayout<L extends AbstractLayout<L> & MemoryLayout> {\n+\n+    private final long bitSize;\n+    public final long bitAlignment;\n+    private final Optional<String> name;\n+    @Stable\n+    long byteSize;\n+\n+    AbstractLayout(long bitSize, long bitAlignment, Optional<String> name) {\n+        this.bitSize = bitSize;\n+        this.bitAlignment = bitAlignment;\n+        this.name = name;\n+    }\n+\n+    public L withName(String name) {\n+        Objects.requireNonNull(name);\n+        return dup(bitAlignment, Optional.of(name));\n+    }\n+\n+    public final Optional<String> name() {\n+        return name;\n+    }\n+\n+    abstract L dup(long alignment, Optional<String> name);\n+\n+    public L withBitAlignment(long alignmentBits) {\n+        checkAlignment(alignmentBits);\n+        return dup(alignmentBits, name);\n+    }\n+\n+    public void checkAlignment(long alignmentBitCount) {\n+        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n+                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n+            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n+        }\n+    }\n+\n+    public final long bitAlignment() {\n+        return bitAlignment;\n+    }\n+\n+    @ForceInline\n+    public long byteSize() {\n+        if (byteSize == 0) {\n+            byteSize = Utils.bitsToBytesOrThrow(bitSize(),\n+                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n+        }\n+        return byteSize;\n+    }\n+\n+    public long bitSize() {\n+        return bitSize;\n+    }\n+\n+    public String decorateLayoutString(String s) {\n+        if (name().isPresent()) {\n+            s = String.format(\"%s(%s)\", s, name().get());\n+        }\n+        if (!hasNaturalAlignment()) {\n+            s = bitAlignment + \"%\" + s;\n+        }\n+        return s;\n+    }\n+\n+    public boolean hasNaturalAlignment() {\n+        return bitSize == bitAlignment;\n+    }\n+\n+    public boolean isPadding() {\n+        return this instanceof PaddingLayout;\n+    }\n+\n+    \/\/ the following methods have to copy the same Javadoc as in MemoryLayout, or subclasses will just show\n+    \/\/ the Object methods javadoc\n+\n+    \/**\n+     * {@return the hash code value for this layout}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, bitSize, bitAlignment);\n+    }\n+\n+    \/**\n+     * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified\n+     * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of\n+     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n+     * conditions must be satisfied:\n+     * <ul>\n+     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n+     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n+     *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and\n+     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal<\/li>\n+     *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},\n+     *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     * <\/ul>\n+     *\n+     * @param other the object to be compared for equality with this layout.\n+     * @return {@code true} if the specified object is equal to this layout.\n+     *\/\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        return other instanceof AbstractLayout<?> otherLayout &&\n+                name.equals(otherLayout.name) &&\n+                bitSize == otherLayout.bitSize &&\n+                bitAlignment == otherLayout.bitAlignment;\n+    }\n+\n+    \/**\n+     * {@return the string representation of this layout}\n+     *\/\n+    public abstract String toString();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public final class MemoryLayoutUtil {\n+\n+    private MemoryLayoutUtil() {\n+    }\n+\n+    public static void checkSize(long size) {\n+        checkSize(size, false);\n+    }\n+\n+    public static void checkSize(long size, boolean includeZero) {\n+        if (size < 0 || (!includeZero && size == 0)) {\n+            throw new IllegalArgumentException(\"Invalid size for layout: \" + size);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <V extends ValueLayout> V createIfNeeded(V nativeOrderValueLayout,\n+                                                           ByteOrder newByteOrder) {\n+        requireNonNull(nativeOrderValueLayout);\n+        if (ByteOrder.nativeOrder() == newByteOrder) {\n+            return nativeOrderValueLayout;\n+        } else {\n+            \/\/ This cast will always succeed because ValueLayout::withOrder returns an instance of the same type.\n+            return (V) nativeOrderValueLayout.withOrder(newByteOrder);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.PaddingLayout;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public final class PaddingLayoutImpl extends AbstractLayout<PaddingLayoutImpl> implements PaddingLayout {\n+\n+    private PaddingLayoutImpl(long bitSize) {\n+        this(bitSize, 1, Optional.empty());\n+    }\n+\n+    private PaddingLayoutImpl(long bitSize, long bitAlignment, Optional<String> name) {\n+        super(bitSize, bitAlignment, name);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorateLayoutString(\"x\" + bitSize());\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!super.equals(other)) {\n+            return false;\n+        }\n+        if (!(other instanceof PaddingLayoutImpl p)) {\n+            return false;\n+        }\n+        return bitSize() == p.bitSize();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), bitSize());\n+    }\n+\n+    @Override\n+    PaddingLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new PaddingLayoutImpl(bitSize(), bitAlignment, name);\n+    }\n+\n+    @Override\n+    public boolean hasNaturalAlignment() {\n+        return true;\n+    }\n+\n+\n+    public static PaddingLayout of(long bitSize) {\n+        return new PaddingLayoutImpl(bitSize);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/PaddingLayoutImpl.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+public final class SequenceLayoutImpl extends AbstractLayout<SequenceLayoutImpl> implements SequenceLayout {\n+\n+    private final long elemCount;\n+    private final MemoryLayout elementLayout;\n+\n+    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout) {\n+        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n+    }\n+\n+    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout, long bitAlignment, Optional<String> name) {\n+        super(Math.multiplyExact(elemCount, elementLayout.bitSize()), bitAlignment, name);\n+        this.elemCount = elemCount;\n+        this.elementLayout = elementLayout;\n+    }\n+\n+    \/**\n+     * {@return the element layout associated with this sequence layout}\n+     *\/\n+    public MemoryLayout elementLayout() {\n+        return elementLayout;\n+    }\n+\n+    \/**\n+     * {@return the element count of this sequence layout}\n+     *\/\n+    public long elementCount() {\n+        return elemCount;\n+    }\n+\n+    \/**\n+     * Returns a sequence layout with the same element layout, alignment constraints and name as this sequence layout,\n+     * but with the specified element count.\n+     *\n+     * @param elementCount the new element count.\n+     * @return a sequence layout with the given element count.\n+     * @throws IllegalArgumentException if {@code elementCount < 0}.\n+     *\/\n+    public SequenceLayout withElementCount(long elementCount) {\n+        MemoryLayoutUtil.checkSize(elementCount, true);\n+        return new SequenceLayoutImpl(elementCount, elementLayout, bitAlignment, name());\n+    }\n+\n+    \/**\n+     * Re-arrange the elements in this sequence layout into a multi-dimensional sequence layout.\n+     * The resulting layout is a sequence layout where element layouts in the flattened projection of this\n+     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts\n+     * according to the provided element counts. This transformation preserves the layout size;\n+     * that is, multiplying the provided element counts must yield the same element count\n+     * as the flattened projection of this sequence layout.\n+     * <p>\n+     * For instance, given a sequence layout of the kind:\n+     * {@snippet lang = java:\n+     * var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n+     *}\n+     * calling {@code seq.reshape(2, 6)} will yield the following sequence layout:\n+     * {@snippet lang = java:\n+     * var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, ValueLayout.JAVA_INT));\n+     *}\n+     * <p>\n+     * If one of the provided element count is the special value {@code -1}, then the element\n+     * count in that position will be inferred from the remaining element counts and the\n+     * element count of the flattened projection of this layout. For instance, a layout equivalent to\n+     * the above {@code reshapeSeq} can also be computed in the following ways:\n+     * {@snippet lang = java:\n+     * var reshapeSeqImplicit1 = seq.reshape(-1, 6);\n+     * var reshapeSeqImplicit2 = seq.reshape(2, -1);\n+     *}\n+     *\n+     * @param elementCounts an array of element counts, of which at most one can be {@code -1}.\n+     * @return a sequence layout where element layouts in the flattened projection of this\n+     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts.\n+     * @throws IllegalArgumentException if two or more element counts are set to {@code -1}, or if one\n+     *                                  or more element count is {@code <= 0} (but other than {@code -1}) or, if, after any required inference,\n+     *                                  multiplying the element counts does not yield the same element count as the flattened projection of this\n+     *                                  sequence layout.\n+     *\/\n+    public SequenceLayout reshape(long... elementCounts) {\n+        Objects.requireNonNull(elementCounts);\n+        if (elementCounts.length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        SequenceLayout flat = flatten();\n+        long expectedCount = flat.elementCount();\n+\n+        long actualCount = 1;\n+        int inferPosition = -1;\n+        for (int i = 0; i < elementCounts.length; i++) {\n+            if (elementCounts[i] == -1) {\n+                if (inferPosition == -1) {\n+                    inferPosition = i;\n+                } else {\n+                    throw new IllegalArgumentException(\"Too many unspecified element counts\");\n+                }\n+            } else if (elementCounts[i] <= 0) {\n+                throw new IllegalArgumentException(\"Invalid element count: \" + elementCounts[i]);\n+            } else {\n+                actualCount = elementCounts[i] * actualCount;\n+            }\n+        }\n+\n+        \/\/ infer an unspecified element count (if any)\n+        if (inferPosition != -1) {\n+            long inferredCount = expectedCount \/ actualCount;\n+            elementCounts[inferPosition] = inferredCount;\n+            actualCount = actualCount * inferredCount;\n+        }\n+\n+        if (actualCount != expectedCount) {\n+            throw new IllegalArgumentException(\"Element counts do not match expected size: \" + expectedCount);\n+        }\n+\n+        MemoryLayout res = flat.elementLayout();\n+        for (int i = elementCounts.length - 1; i >= 0; i--) {\n+            res = MemoryLayout.sequenceLayout(elementCounts[i], res);\n+        }\n+        return (SequenceLayoutImpl) res;\n+    }\n+\n+    \/**\n+     * Returns a flattened sequence layout. The element layout of the returned sequence layout\n+     * is the first non-sequence element layout found by recursively traversing the element layouts of this sequence layout.\n+     * This transformation preserves the layout size; nested sequence layout in this sequence layout will\n+     * be dropped and their element counts will be incorporated into that of the returned sequence layout.\n+     * For instance, given a sequence layout of the kind:\n+     * {@snippet lang = java:\n+     * var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n+     *}\n+     * calling {@code seq.flatten()} will yield the following sequence layout:\n+     * {@snippet lang = java:\n+     * var flattenedSeq = MemoryLayout.sequenceLayout(12, ValueLayout.JAVA_INT);\n+     *}\n+     *\n+     * @return a sequence layout with the same size as this layout (but, possibly, with different\n+     * element count), whose element layout is not a sequence layout.\n+     *\/\n+    public SequenceLayout flatten() {\n+        long count = elementCount();\n+        MemoryLayout elemLayout = elementLayout();\n+        while (elemLayout instanceof SequenceLayoutImpl elemSeq) {\n+            count = count * elemSeq.elementCount();\n+            elemLayout = elemSeq.elementLayout();\n+        }\n+        return MemoryLayout.sequenceLayout(count, elemLayout);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorateLayoutString(String.format(\"[%s:%s]\",\n+                elemCount, elementLayout));\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!super.equals(other)) {\n+            return false;\n+        }\n+        return other instanceof SequenceLayoutImpl otherSeq &&\n+                elemCount == otherSeq.elemCount &&\n+                elementLayout.equals(otherSeq.elementLayout);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), elemCount, elementLayout);\n+    }\n+\n+    @Override\n+    SequenceLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new SequenceLayoutImpl(elementCount(), elementLayout, bitAlignment, name);\n+    }\n+\n+    @Override\n+    public boolean hasNaturalAlignment() {\n+        return bitAlignment == elementLayout.bitAlignment();\n+    }\n+\n+    public static SequenceLayout of(long elementCount, MemoryLayout elementLayout) {\n+        return new SequenceLayoutImpl(elementCount, elementLayout);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public final class StructLayoutImpl extends AbstractGroupLayout<StructLayoutImpl> implements StructLayout {\n+\n+    private static final Kind KIND = Kind.STRUCT;\n+\n+    private StructLayoutImpl(List<MemoryLayout> elements) {\n+        super(KIND, elements);\n+    }\n+\n+    private StructLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+        super(KIND, elements, bitAlignment, name);\n+    }\n+\n+    @Override\n+    StructLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new StructLayoutImpl(memberLayouts(), bitAlignment, name);\n+    }\n+\n+    public static StructLayout of(List<MemoryLayout> elements) {\n+        return new StructLayoutImpl(elements);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public final class UnionLayoutImpl extends AbstractGroupLayout<UnionLayoutImpl> implements UnionLayout {\n+\n+    private static final Kind KIND = Kind.UNION;\n+\n+    private UnionLayoutImpl(List<MemoryLayout> elements) {\n+        super(KIND, elements);\n+    }\n+\n+    private UnionLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+        super(KIND, elements, bitAlignment, name);\n+    }\n+\n+    @Override\n+    UnionLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new UnionLayoutImpl(memberLayouts(), bitAlignment, name);\n+    }\n+\n+    public static UnionLayout of(List<MemoryLayout> elements) {\n+        return new UnionLayoutImpl(elements);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign.layout;\n+\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * A value layout. A value layout is used to model the memory layout associated with values of basic data types, such as <em>integral<\/em> types\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, an alignment (in bits),\n+ * a {@linkplain ByteOrder byte order}, and a <em>carrier<\/em>, that is, the Java type that should be used when\n+ * {@linkplain MemorySegment#get(ValueLayout.OfInt, long) accessing} a memory region using the value layout.\n+ * <p>\n+ * This class defines useful value layout constants for Java primitive types and addresses.\n+ * The layout constants in this class make implicit alignment and byte-ordering assumption: all layout\n+ * constants in this class are byte-aligned, and their byte order is set to the {@linkplain ByteOrder#nativeOrder() platform default},\n+ * thus making it easy to work with other APIs, such as arrays and {@link java.nio.ByteBuffer}.\n+ *\n+ * @implSpec This class and its subclasses are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+public final class ValueLayouts {\n+\n+    private ValueLayouts() {\n+    }\n+\n+    abstract static class AbstractValueLayout<V extends AbstractValueLayout<V> & ValueLayout> extends AbstractLayout<V> {\n+\n+        private final Class<?> carrier;\n+        private final ByteOrder order;\n+\n+        static final int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+\n+        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize) {\n+            this(carrier, order, bitSize, bitSize, Optional.empty());\n+        }\n+\n+        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize, long bitAlignment, Optional<String> name) {\n+            super(bitSize, bitAlignment, name);\n+            this.carrier = carrier;\n+            this.order = order;\n+            checkCarrierSize(carrier, bitSize);\n+        }\n+\n+        \/**\n+         * {@return the value's byte order}\n+         *\/\n+        public ByteOrder order() {\n+            return order;\n+        }\n+\n+        \/**\n+         * Returns a value layout with the same carrier, alignment constraints and name as this value layout,\n+         * but with the specified byte order.\n+         *\n+         * @param order the desired byte order.\n+         * @return a value layout with the given byte order.\n+         *\/\n+        abstract V withOrder(ByteOrder order);\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public String toString() {\n+            char descriptor = carrier == MemorySegment.class ? 'A' : carrier.descriptorString().charAt(0);\n+            if (order == ByteOrder.LITTLE_ENDIAN) {\n+                descriptor = Character.toLowerCase(descriptor);\n+            }\n+            return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (!super.equals(other)) {\n+                return false;\n+            }\n+            return other instanceof AbstractValueLayout<?> otherValue &&\n+                    carrier.equals(otherValue.carrier) &&\n+                    order.equals(otherValue.order);\n+        }\n+\n+\n+        public VarHandle arrayElementVarHandle(int... shape) {\n+            Objects.requireNonNull(shape);\n+            MemoryLayout layout = self();\n+            List<MemoryLayout.PathElement> path = new ArrayList<>();\n+            for (int i = shape.length; i > 0; i--) {\n+                int size = shape[i - 1];\n+                if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n+                layout = MemoryLayout.sequenceLayout(size, layout);\n+                path.add(MemoryLayout.PathElement.sequenceElement());\n+            }\n+            layout = MemoryLayout.sequenceLayout(layout);\n+            path.add(MemoryLayout.PathElement.sequenceElement());\n+            return layout.varHandle(path.toArray(new MemoryLayout.PathElement[0]));\n+        }\n+\n+        \/**\n+         * {@return the carrier associated with this value layout}\n+         *\/\n+        public Class<?> carrier() {\n+            return carrier;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), order, carrier);\n+        }\n+\n+        @Override\n+        abstract V dup(long bitAlignment, Optional<String> name);\n+\n+        static void checkCarrierSize(Class<?> carrier, long size) {\n+            if (!isValidCarrier(carrier)) {\n+                throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n+            }\n+            if (carrier == MemorySegment.class && size != ADDRESS_SIZE_BITS) {\n+                throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n+            }\n+            if (carrier.isPrimitive()) {\n+                int expectedSize = carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n+                if (size != expectedSize) {\n+                    throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+                }\n+            }\n+        }\n+\n+        static boolean isValidCarrier(Class<?> carrier) {\n+            return carrier == boolean.class\n+                    || carrier == byte.class\n+                    || carrier == short.class\n+                    || carrier == char.class\n+                    || carrier == int.class\n+                    || carrier == long.class\n+                    || carrier == float.class\n+                    || carrier == double.class\n+                    || carrier == MemorySegment.class;\n+        }\n+\n+        @Stable\n+        private VarHandle handle;\n+\n+        @ForceInline\n+        public VarHandle accessHandle() {\n+            if (handle == null) {\n+                \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n+                handle = Utils.makeSegmentViewVarHandle(self());\n+            }\n+            return handle;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        V self() {\n+            return (V) this;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code boolean.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfBooleanImpl extends AbstractValueLayout<OfBooleanImpl> implements ValueLayout.OfBoolean {\n+\n+        private static final OfBoolean NATIVE_ORDER = new OfBooleanImpl(ByteOrder.nativeOrder());\n+\n+        private OfBooleanImpl(ByteOrder order) {\n+            super(boolean.class, order, 8);\n+        }\n+\n+        private OfBooleanImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(boolean.class, order, 8, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfBooleanImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfBooleanImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfBooleanImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfBooleanImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfBoolean ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code byte.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfByteImpl extends AbstractValueLayout<OfByteImpl> implements ValueLayout.OfByte {\n+\n+        private static final OfByte NATIVE_ORDER = new OfByteImpl(ByteOrder.nativeOrder());\n+\n+        private OfByteImpl(ByteOrder order) {\n+            super(byte.class, order, 8);\n+        }\n+\n+        private OfByteImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(byte.class, order, 8, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfByteImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfByteImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfByteImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfByteImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfByte ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code char.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfCharImpl extends AbstractValueLayout<OfCharImpl> implements ValueLayout.OfChar {\n+\n+        private static final OfChar NATIVE_ORDER = new OfCharImpl(ByteOrder.nativeOrder());\n+\n+        private OfCharImpl(ByteOrder order) {\n+            super(char.class, order, 16);\n+        }\n+\n+        private OfCharImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(char.class, order, 16, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfCharImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfCharImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfCharImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfCharImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfChar ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code short.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfShortImpl extends AbstractValueLayout<OfShortImpl> implements ValueLayout.OfShort {\n+\n+        private static final OfShort NATIVE_ORDER = new OfShortImpl(ByteOrder.nativeOrder());\n+\n+        private OfShortImpl(ByteOrder order) {\n+            super(short.class, order, 16);\n+        }\n+\n+        private OfShortImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(short.class, order, 16, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfShortImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfShortImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfShortImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfShortImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfShort ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code int.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfIntImpl extends AbstractValueLayout<OfIntImpl> implements ValueLayout.OfInt {\n+\n+        private static final OfInt NATIVE_ORDER = new OfIntImpl(ByteOrder.nativeOrder());\n+\n+        private OfIntImpl(ByteOrder order) {\n+            super(int.class, order, 32);\n+        }\n+\n+        private OfIntImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(int.class, order, 32, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfIntImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfIntImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfIntImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfIntImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfInt ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code float.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfFloatImpl extends AbstractValueLayout<OfFloatImpl> implements ValueLayout.OfFloat {\n+\n+        private static final OfFloat NATIVE_ORDER = new OfFloatImpl(ByteOrder.nativeOrder());\n+\n+        private OfFloatImpl(ByteOrder order) {\n+            super(float.class, order, 32);\n+        }\n+\n+        private OfFloatImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(float.class, order, 32, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfFloatImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfFloatImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfFloatImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfFloatImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfFloat ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code long.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfLongImpl extends AbstractValueLayout<OfLongImpl> implements ValueLayout.OfLong {\n+\n+        private static final OfLong NATIVE_ORDER = new OfLongImpl(ByteOrder.nativeOrder());\n+\n+        private OfLongImpl(ByteOrder order) {\n+            super(long.class, order, 64);\n+        }\n+\n+        private OfLongImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(long.class, order, 64, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfLongImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfLongImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfLongImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfLongImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfLong ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code double.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfDoubleImpl extends AbstractValueLayout<OfDoubleImpl> implements ValueLayout.OfDouble {\n+\n+        private static final OfDouble NATIVE_ORDER = new OfDoubleImpl(ByteOrder.nativeOrder());\n+\n+        private OfDoubleImpl(ByteOrder order) {\n+            super(double.class, order, 64);\n+        }\n+\n+        private OfDoubleImpl(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            super(double.class, order, 64, bitAlignment, name);\n+        }\n+\n+        @Override\n+        OfDoubleImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfDoubleImpl(order(), bitAlignment, name);\n+        }\n+\n+        @Override\n+        public OfDoubleImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfDoubleImpl(order, bitAlignment, name());\n+        }\n+\n+        public static OfDouble ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code MemorySegment.class}.\n+     *\n+     * @since 19\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+    public static final class OfAddressImpl extends AbstractValueLayout<OfAddressImpl> implements ValueLayout.OfAddress {\n+\n+        private static final OfAddress NATIVE_ORDER = new OfAddressImpl(ByteOrder.nativeOrder());\n+\n+        private final boolean isUnbounded;\n+\n+        private OfAddressImpl(ByteOrder order) {\n+            super(MemorySegment.class, order, ADDRESS_SIZE_BITS);\n+            this.isUnbounded = false; \/\/ safe\n+        }\n+\n+        private OfAddressImpl(ByteOrder order, long size, long bitAlignment, boolean isUnbounded, Optional<String> name) {\n+            super(MemorySegment.class, order, size, bitAlignment, name);\n+            this.isUnbounded = isUnbounded;\n+        }\n+\n+        @Override\n+        OfAddressImpl dup(long alignment, Optional<String> name) {\n+            return new OfAddressImpl(order(), bitSize(), alignment, isUnbounded, name);\n+        }\n+\n+\n+        @Override\n+        public OfAddressImpl withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfAddressImpl(order, bitSize(), bitAlignment, isUnbounded, name());\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            return super.equals(other) &&\n+                    ((OfAddressImpl) other).isUnbounded == this.isUnbounded;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), isUnbounded);\n+        }\n+\n+        @Override\n+        @CallerSensitive\n+        public OfAddress asUnbounded() {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), OfAddress.class, \"asUnbounded\");\n+            return new OfAddressImpl(order(), bitSize(), bitAlignment, true, name());\n+        }\n+\n+        @Override\n+        public boolean isUnbounded() {\n+            return isUnbounded;\n+        }\n+\n+        public static OfAddress ofNativeOrder() {\n+            return NATIVE_ORDER;\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng\/othervm MemoryLayoutPrincipalTotalityTest\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+public class MemoryLayoutPrincipalTotalityTest extends NativeTestHelper {\n+\n+    \/\/ The tests in this class is mostly there to ensure compile-time pattern matching totality.\n+\n+    @Test\n+    public void testBasicTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        int v0 = switch (memoryLayout) {\n+            case MemoryLayout ml -> 1;\n+        };\n+        assertEquals(v0, 1);\n+    }\n+\n+    @Test\n+    public void testMLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v1 = switch (memoryLayout) {\n+            case GroupLayout gl -> 0;\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case ValueLayout vl -> 1;\n+        };\n+        assertEquals(v1, 1);\n+    }\n+\n+    @Test\n+    public void testMLGLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v2 = switch (memoryLayout) {\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case ValueLayout vl -> 1;\n+            case StructLayout sl -> 0; \/\/ leaf\n+            case UnionLayout ul -> 0; \/\/ leaf\n+        };\n+        assertEquals(v2, 1);\n+    }\n+\n+    @Test\n+    public void testMLGLVLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v3 = switch (memoryLayout) {\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case StructLayout sl -> 0; \/\/ leaf\n+            case UnionLayout ul -> 0; \/\/ leaf\n+            case OfAddress oa -> 0; \/\/ leaf\n+            case OfBoolean ob -> 0; \/\/ leaf\n+            case OfByte ob -> 0; \/\/ leaf\n+            case OfChar oc -> 0; \/\/ leaf\n+            case OfDouble od -> 0; \/\/ leaf\n+            case OfFloat of -> 0; \/\/ leaf\n+            case OfInt oi -> 1; \/\/ leaf\n+            case OfLong ol -> 0; \/\/ leaf\n+            case OfShort os -> 0; \/\/ leaf\n+        };\n+        assertEquals(v3, 1);\n+    }\n+\n+    @Test\n+    public void testMLVLRemovedTotality() {\n+        MemoryLayout memoryLayout = javaIntMemoryLayout();\n+        var v4 = switch (memoryLayout) {\n+            case GroupLayout gl -> 0;\n+            case PaddingLayout pl -> 0; \/\/ leaf\n+            case SequenceLayout sl -> 0; \/\/ leaf\n+            case OfAddress oa -> 0; \/\/ leaf\n+            case OfBoolean ob -> 0; \/\/ leaf\n+            case OfByte ob -> 0; \/\/ leaf\n+            case OfChar oc -> 0; \/\/ leaf\n+            case OfDouble od -> 0; \/\/ leaf\n+            case OfFloat of -> 0; \/\/ leaf\n+            case OfInt oi -> 1; \/\/ leaf\n+            case OfLong ol -> 0; \/\/ leaf\n+            case OfShort os -> 0; \/\/ leaf\n+        };\n+        assertEquals(v4, 1);\n+    }\n+\n+    private static MemoryLayout javaIntMemoryLayout() {\n+        return JAVA_INT;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng\/othervm MemoryLayoutTypeRetentionTest\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+public class MemoryLayoutTypeRetentionTest extends NativeTestHelper {\n+\n+    \/\/ These tests check both compile-time and runtime properties.\n+    \/\/ withName() et al. should return the same type as the original object.\n+\n+    private static final String NAME = \"a\";\n+    private static final long BIT_ALIGNMENT = 64;\n+    private static final ByteOrder BYTE_ORDER = ByteOrder.LITTLE_ENDIAN;\n+\n+    @Test\n+    public void testOfBoolean() {\n+        OfBoolean v = JAVA_BOOLEAN\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfByte() {\n+        OfByte v = JAVA_BYTE\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfShort() {\n+        OfShort v = JAVA_SHORT\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfInt() {\n+        OfInt v = JAVA_INT\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfChar() {\n+        OfChar v = JAVA_CHAR\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfLong() {\n+        OfLong v = JAVA_LONG\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfFloat() {\n+        OfFloat v = JAVA_FLOAT\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfDouble() {\n+        OfDouble v = JAVA_DOUBLE\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testOfAddress() {\n+        OfAddress v = ADDRESS\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME)\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+        assertFalse(v.isUnbounded());\n+        OfAddress v2 = v.asUnbounded();\n+        assertTrue(v2.isUnbounded());\n+    }\n+\n+    @Test\n+    public void testPaddingLayout() {\n+        PaddingLayout v = MemoryLayout.paddingLayout(8)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testGroupLayout() {\n+        GroupLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testStructLayout() {\n+        StructLayout v = MemoryLayout.structLayout(JAVA_INT, JAVA_LONG)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    @Test\n+    public void testUnionLayout() {\n+        UnionLayout v = MemoryLayout.unionLayout(JAVA_INT, JAVA_LONG)\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withName(NAME);\n+        check(v);\n+    }\n+\n+    public void check(ValueLayout v) {\n+        check((MemoryLayout) v);\n+        assertEquals(v.order(), BYTE_ORDER);\n+    }\n+\n+    public void check(MemoryLayout v) {\n+        assertEquals(v.name().orElseThrow(), NAME);\n+        assertEquals(v.bitAlignment(), BIT_ALIGNMENT);\n+        assertEquals(v.byteSize() * 8, v.bitSize());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"}]}