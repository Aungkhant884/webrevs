{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -35,0 +34,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -44,0 +44,1 @@\n+            case QUAD_BYTE -> readFast_int(segment, offset, charset);\n@@ -52,0 +53,1 @@\n+            case QUAD_BYTE -> writeFast_int(segment, offset, charset, string);\n@@ -58,1 +60,1 @@\n-        MemorySegment.copy(segment, ValueLayout.JAVA_BYTE, offset, bytes, 0, (int)len);\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n@@ -64,2 +66,2 @@\n-        MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, offset, bytes.length);\n-        segment.set(ValueLayout.JAVA_BYTE, offset + bytes.length, (byte)0);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_BYTE, offset + bytes.length, (byte)0);\n@@ -71,1 +73,1 @@\n-        MemorySegment.copy(segment, ValueLayout.JAVA_BYTE, offset, bytes, 0, (int)len);\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n@@ -81,0 +83,13 @@\n+    private static String readFast_int(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_int(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeFast_int(MemorySegment segment, long offset, Charset charset, String string) {\n+        byte[] bytes = string.getBytes(charset);\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+        segment.set(JAVA_INT, offset + bytes.length, 0);\n+    }\n+\n@@ -103,0 +118,11 @@\n+    private static int strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n@@ -105,1 +131,2 @@\n-        DOUBLE_BYTE(2);\n+        DOUBLE_BYTE(2),\n+        QUAD_BYTE(4);\n@@ -122,0 +149,2 @@\n+            } else if (charset == StandardCharsets.UTF_32LE || charset == StandardCharsets.UTF_32BE || charset == StandardCharsets.UTF_32) {\n+                return CharsetKind.QUAD_BYTE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -54,0 +54,3 @@\n+                    \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                    \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                    \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}