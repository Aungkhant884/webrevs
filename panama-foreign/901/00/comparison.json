{"files":[{"patch":"@@ -80,1 +80,1 @@\n- * SequenceLayout taggedValues = MemoryLayout.sequenceLayout(5,\n+ * SequenceLayout TAGGED_VALUES = MemoryLayout.sequenceLayout(5,\n@@ -135,1 +135,1 @@\n- * long valueOffset = taggedValues.byteOffset(PathElement.sequenceElement(0),\n+ * long valueOffset = TAGGED_VALUES.byteOffset(PathElement.sequenceElement(0),\n@@ -141,1 +141,1 @@\n- * MemoryLayout value = taggedValues.select(PathElement.sequenceElement(),\n+ * MemoryLayout value = TAGGED_VALUES.select(PathElement.sequenceElement(),\n@@ -154,1 +154,1 @@\n- * VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n+ * VarHandle valueHandle = TAGGED_VALUES.varHandle(PathElement.sequenceElement(),\n@@ -156,2 +156,5 @@\n- * MemorySegment valuesSegment = ...\n- * int val = (int) valueHandle.get(valuesSegment, 2); \/\/ reads the \"value\" field of the third struct in the array\n+ * MemorySegment taggedValues = ...\n+ * \/\/ reads the \"value\" field of the third struct in the array (taggedValues[2].value)\n+ * int val = (int) valueHandle.get(taggedValues,\n+ *         0L,  \/\/ base offset\n+ *         2L); \/\/ sequence index\n@@ -167,1 +170,1 @@\n- * MethodHandle offsetHandle = taggedValues.byteOffsetHandle(PathElement.sequenceElement(),\n+ * MethodHandle offsetHandle = TAGGED_VALUES.byteOffsetHandle(PathElement.sequenceElement(),\n@@ -169,2 +172,2 @@\n- * long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n- * long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+ * long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 0 + (1 * 8) = 8\n+ * long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 0 + (2 * 8) = 16\n@@ -208,1 +211,4 @@\n- * int rect_y_4 = (int) rectPointYs.get(rect, 2); \/\/ rect.points[2]->y\n+ * \/\/ dereferences the third point struct in the \"points\" array, and reads its \"y\" coordinate (rect.points[2]->y)\n+ * int rect_y_2 = (int) rectPointYs.get(rect,\n+ *     0L,  \/\/ base offset\n+ *     2L); \/\/ sequence index\n@@ -272,0 +278,61 @@\n+ * <h2 id=\"variable-length\">Working with variable-length structs<\/h2>\n+ *\n+ * Memory layouts allow clients to describe the contents of a region of memory whose size is knonw <em>statically<\/em>.\n+ * There are, however, cases, where the size of a region of memory is only known <em>dynamically<\/em>, as it depends\n+ * on the value of one or more struct fields. Consider the following struct declaration in C:\n+ *\n+ * {@snippet lang=c :\n+ * typedef struct {\n+ *     int size;\n+ *     struct {\n+ *         int x;\n+ *         int y;\n+ *     } points[];\n+ * } Polygon;\n+ * }\n+ *\n+ * In the above code, a polygon is modelled as a size (the number of edges in the polygon) and an array of points\n+ * (one for each vertex in the polygon). The number of vertices depends on the number of edges in the polygon. As such,\n+ * the size of the {@code points} array is left <em>unspecified<\/em> in the C declaration, using a <em>Flexible Array Member<\/em>\n+ * (a feature standardized in C99).\n+ * <p>\n+ * Memory layouts do not support sequence layouts whose size is unknown. As such, it is not possible to model\n+ * the above struct directly. That said, clients can still enjoy structured access provided by memory layouts, as\n+ * demonstrated below:\n+ *\n+ * {@snippet lang=java :\n+ * StructLayout POINT = MemoryLayout.structLayout(\n+ *             ValueLayout.JAVA_INT.withName(\"x\"),\n+ *             ValueLayout.JAVA_INT.withName(\"y\")\n+ * );\n+ *\n+ * StructLayout POLYGON = MemoryLayout.structLayout(\n+ *             ValueLayout.JAVA_INT.withName(\"size\"),\n+ *             MemoryLayout.sequenceLayout(0, POINT_2D).withName(\"points\")\n+ * );\n+ *\n+ * VarHandle POLYGON_SIZE = POLYGON_2D.varHandle(0, PathElement.groupElement(\"size\"));\n+ * VarHandle POINT_X = POINT.varHandle(PathElement.groupElement(\"x\"));\n+ * long POINTS_OFFSET = POLYGON.byteOffset(PathElement.groupElement(\"points\"));\n+ * }\n+ *\n+ * Note how we have split the polygon struct in two. The {@code POLYGON} layout contains a sequence layout\n+ * of size <em>zero<\/em>. The element layout of the sequence layout is the {@code POINT} layout, which defines\n+ * the {@code x} and {@code y} coordinates, accordingly. The first layout is used to obtain a var handle\n+ * that provides access to the polygon size; the second layout is used to obtain a var handle that provides\n+ * access to the {@code x} coordinate of a point struct. Finally, an offset to the start of the variable-length\n+ * {@code points} array is also obtained.\n+ * <p>\n+ * The {@code x} coordinates of all the points in a polygon can then be accessed as follows:\n+ * {@snippet lang=java :\n+ * MemorySegment polygon = ...\n+ * int size = POLYGON_SIZE.get(polygon, 0L);\n+ * for (int i = 0 ; i < size ; i++) {\n+ *     int x = POINT_X.get(polygon, POINT.scaleOffset(POINTS_OFFSET, i));\n+ * }\n+ *  }\n+ * Here, we first obtain the polygon size, using the {@code POLYGON_SIZE} var handle. Then, in a loop, we read\n+ * the {@code x} coordinates of all the points in the polygon. This is done by providing a custom base offset to\n+ * the {@code POINT_X} var handle. The custom offset is computed as {@code POINTS_OFFSET + (i * POINT.byteSize())}, where\n+ * {@code i} is the loop induction variable.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":77,"deletions":10,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.foreign.ValueLayout.OfInt;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n@@ -123,1 +126,0 @@\n- * MemorySegment segment = ...\n@@ -127,6 +129,3 @@\n- * More complex access operations can be implemented using var handles. The {@link ValueLayout#varHandle()}\n- * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout on a memory segment.\n- * A var handle obtained from a layout supports several additional <a href=MemoryLayout.html#access-mode-restrictions>\n- * access modes<\/a>. More importantly, var handles can be <em>combined<\/em> with method handles to express complex access\n- * operations. For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n- * index can be created as follows:\n+ * Access operations on memory segments are implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout\n+ * on a memory segment at the given offset:\n@@ -135,3 +134,8 @@\n- * MemorySegment segment = ...\n- * VarHandle intHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n- * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle(); \/\/ <base offset> + <index> * JAVA_INT.byteSize()\n+ * VarHandle intAtOffsetHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * int value = (int) intAtOffsetHandle.get(segment, 10L);          \/\/ segment.get(ValueLayout.JAVA_INT, 10L)\n+ * }\n+ *\n+ * The var handle returned by {@link ValueLayout#varHandle()} features a <em>base offset<\/em> parameter. This parameter\n+ * allows clients to express complex access operations, by injecting additional offset computation into the var handle.\n+ * For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -139,2 +143,5 @@\n- * intHandle = MethodHandles.filterCoordinates(intHandle, 1, scale);\n- * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + 3 * 4 = 12\n+ * {@snippet lang=java:\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle();              \/\/ (long, long)long\n+ * VarHandle intAtOffsetAndIndexHandle =\n+ *         MethodHandles.filterCoordinates(intAtOffsetHandle, 1, scale); \/\/ (MemorySegment, long, long)\n+ * int value = (int) intAtOffsetAndIndexHandle.get(segment, 2L, 3L);     \/\/ segment.get(ValueLayout.JAVA_INT, 2L + (3L * 4L))\n@@ -143,5 +150,3 @@\n- * To make the process of creating these var handles easier, the method\n- * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)} can be used, by providing it a so called\n- * <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>. A layout path, consisting of several <em>layout\n- * path elements<\/em>, selects a value layout to be accessed, which can be nested inside another memory layout. For example,\n- * we can express the access to an element of an {@code int} array using layout paths like so:\n+ * <p>\n+ * Clients can also drop the base offset parameter, in order to make the access expression simpler. This can be used to\n+ * implement access operation such as {@link #getAtIndex(OfInt, long)}:\n@@ -149,9 +154,4 @@\n- * {@snippet lang=java :\n- * MemorySegment segment = ...\n- * MemoryLayout segmentLayout = MemoryLayout.structLayout(\n- *     ValueLayout.JAVA_INT.withName(\"size\"),\n- *     MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n- * );\n- * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElemenet.groupElement(\"data\"),\n- *                                               MemoryLayout.PathElement.sequenceElement());\n- * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n+ * {@snippet lang=java:\n+ * VarHandle intAtIndexHandle =\n+ *         MethodHandles.insertCoordinates(intAtOffsetAndIndexHandle, 1, 0L); \/\/ (MemorySegment, long)\n+ * int value = (int) intAtIndexHandle.get(segment, 3L);                       \/\/ segment.getAtIndex(ValueLayout.JAVA_INT, 3L);\n@@ -159,9 +159,3 @@\n- * Where {@code offsetof(data)} is the offset of the {@code data} element layout of the {@code segmentLayout} layout\n- *\n- * Both the var handle returned by {@link ValueLayout#varHandle()} and\n- * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)}, as well as the method handle returned by\n- * {@link MemoryLayout#byteOffsetHandle(MemoryLayout.PathElement...)} and {@link MemoryLayout#sliceHandle(MemoryLayout.PathElement...)}\n- * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This\n- * parameter allows a client to combine these handles further with additional offset computations. This is demonstrated\n- * in the first of the two examples above, where {@code intHandle} is combined with a\n- * {@linkplain MemoryLayout#scaleHandle() scale handle} obtained from {@code ValueLayout.JAVA_INT}.\n+ *\n+ * Var handles for more complex access expressions (e.g. struct field access, pointer dereference) can be created directly\n+ * from memory layouts, using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":29,"deletions":35,"binary":false,"changes":64,"status":"modified"}]}