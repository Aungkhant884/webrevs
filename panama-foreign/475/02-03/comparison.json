{"files":[{"patch":"@@ -54,4 +54,1 @@\n-void foo(int i, int *size);\n-\n-int size = 5;\n-foo(42, &size);\n+int arr[] = { 1, 2, 3, 4, 5 };\n@@ -60,1 +57,1 @@\n-Here the function `foo` takes an output parameter, a pointer to an `int` variable. Unfortunately (and we have seen part of that pain in the `qsort` example above), implementing this idiom in Panama is not straightforward:\n+Here the function `foo` takes an output parameter, a pointer to an `int` variable. This idiom can be implemented as follows, using the Foreign Memory Access API:\n@@ -63,4 +60,4 @@\n-MethodHandle foo = ...\n-MemorySegment size = MemorySegment.allocateNative(C_INT);\n-MemoryAccess.setInt(size.address(), 5);\n-foo.invokeExact(42, size);\n+MemorySegment arr = MemorySegment.allocateNative(C_INT);\n+for (int i = 1 ; i <= 5 ; i++) {\n+    MemoryAccess.setInt(arr, i);\n+}\n@@ -71,3 +68,3 @@\n-* compared to the C code, it is very verbose\n-* allocation is very slow compared to C; allocating the `size` variable now takes a full `malloc`, while in C the variable was simply stack-allocated\n-* we end up with a standalone segment with its own temporal bounds, which will have to be *closed* later, to avoid leaks\n+* compared to the C code, it is more verbose - the native array has to be initialized *element by element*\n+* allocation is very slow compared to C; allocating the `arr` variable now takes a full `malloc`, while in C the variable was simply stack-allocated\n+* when having multiple declarations like the one above, it might become increasingly harder to manage the lifecycle of the various segments\n@@ -78,2 +75,1 @@\n-MemorySegment size = SegmentAllocator.ofDefault().allocate(C_INT, 5);\n-foo.invokeExact(42, size.address());\n+MemorySegment arr = SegmentAllocator.ofDefault().allocateArray(C_INT, new int[] { 1, 2, 3, 4, 5 });\n@@ -82,1 +78,3 @@\n-The above code retrieves the *default allocator* (an allocator built on top of `MemorySegment::allocateNative`), and then uses this allocator to create a new memory segment holding the int value `5`. Memory associated with segments returned by the default allocator is released as soon as said segments become *unreachable*. To have better control over the lifetime of the segments returned by an allocator, clients can use the so called *scoped* allocator, which returns segments associated with a given scope:\n+The above code retrieves the *default allocator* (an allocator built on top of `MemorySegment::allocateNative`), and then uses this allocator to create a native array which is initialized to the values `{ 1, 2, 3, 4, 5}`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment.\n+\n+Memory associated with segments returned by the default allocator is released as soon as said segments become *unreachable*. To have better control over the lifetime of the segments returned by an allocator, clients can use the so called *scoped* allocator, which returns segments associated with a given scope:\n@@ -86,3 +84,2 @@\n-    MemorySegment size = SegmentAllocator.scoped(scope).allocate(C_INT, 5);\n-    foo.invokeExact(42, size.address());\n-} \/\/ 'size' is released here\n+    MemorySegment arr = SegmentAllocator.scoped(scope).allocateArray(C_INT, new int[] { 1, 2, 3, 4, 5 });\n+} \/\/ 'arr' is released here\n@@ -91,1 +88,1 @@\n-Scoped allocator make sure that all segments allocated with a scoped allocator are no longer usable after the scope associated with the allocator has been closed.\n+Scoped allocator make sure that all segments allocated with a scoped allocator are no longer usable after the scope associated with the allocator has been closed. This makes it easier to manage multiple resources which share the same lifecycle.\n@@ -93,1 +90,1 @@\n-Custom segment allocators are critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the `SegmentAllocator` interface. For instance, it is possible to create an arena-based allocator, as follows:\n+Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the `SegmentAllocator` interface. For instance, it is possible to create an arena-based allocator, as follows:\n@@ -99,1 +96,1 @@\n-        allocator.allocate(C_INT, i);\n+        allocator.allocateArray(C_INT, new int[] { 1, 2, 3, 4, 5 });\n@@ -107,0 +104,2 @@\n+For these reasons, all the methods in the Foreign Linker API which *produce* memory segments (see `CLinker::toCString`), allow an optional allocator to be provided by user code â€” this is key in ensuring that an application using the Foreign Linker API achieves optimal allocation performances, especially in non-trivial use cases.\n+\n@@ -217,1 +216,1 @@\n-        CLinker.toCString(\"Hello\").address()\n+        CLinker.toCString(\"Hello\", scope).address()\n@@ -300,1 +299,1 @@\n-The snippet then creates an off-heap array from a Java array (using a `SegmemntAllocator`), which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side-effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n+The snippet then creates an off-heap array from a Java array (using a `SegmentAllocator`), which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side-effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n","filename":"doc\/panama_ffi.md","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"}]}