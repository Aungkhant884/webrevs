{"files":[{"patch":"@@ -71,0 +71,5 @@\n+ * All the arguments of type {@link Addressable} passed to a downcall method handle are {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive}\n+ * by the linker implementation. This ensures that the resource scopes associated with a by-reference parameters passed\n+ * to a downcall method handle can never be closed, either implicitly or {@linkplain ResourceScope#close() explicitly}\n+ * until the downcall method handle completes.\n+ * <p>\n@@ -77,1 +82,2 @@\n- * clients at link time.\n+ * clients at link time. As for other by-reference parameters (see above) this leading parameter will be\n+ * {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -334,4 +334,0 @@\n-            \/\/ make sure arguments are reachable during the call\n-            \/\/ technically we only need to do all Addressable parameters here\n-            Reference.reachabilityFence(address);\n-            Reference.reachabilityFence(args);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -49,0 +50,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -69,0 +71,1 @@\n+import static java.lang.invoke.MethodHandles.filterArguments;\n@@ -97,0 +100,2 @@\n+    private static final MethodHandle ACQUIRE_MH;\n+    private static final MethodHandle RELEASE_MH;\n@@ -117,0 +122,4 @@\n+            ACQUIRE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"acquire\",\n+                    MethodType.methodType(Addressable.class, Addressable.class));\n+            RELEASE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"release\",\n+                    MethodType.methodType(void.class, Addressable.class));\n@@ -385,14 +394,0 @@\n-        if (!upcall) {\n-            \/\/ now for each Addressable parameter, add a reachability fence\n-            MethodType specType = specializedHandle.type();\n-            \/\/ skip 3 for address, segment allocator, and binding context\n-            for (int i = 3; i < specType.parameterCount(); i++) {\n-                Class<?> param = specType.parameterType(i);\n-                if (Addressable.class.isAssignableFrom(param)) {\n-                    closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(param));\n-                } else {\n-                    closer = dropArguments(closer, insertPos++, param);\n-                }\n-            }\n-        }\n-\n@@ -415,0 +410,49 @@\n+    @ForceInline\n+    public static Addressable acquire(Addressable addressable) {\n+        ((ResourceScopeImpl)addressable.scope()).acquire0();\n+        return addressable;\n+    }\n+\n+    @ForceInline\n+    public static void release(Addressable addressable) {\n+        ((ResourceScopeImpl)addressable.scope()).release0();\n+    }\n+\n+    \/*\n+     * This method adds a try\/finally block to a downcall method handle, to make sure that all by-reference\n+     * parameters (including the target address of the native function) are kept alive for the duration of\n+     * the downcall.\n+     *\/\n+    public static MethodHandle wrapDowncall(MethodHandle downcallHandle, FunctionDescriptor descriptor) {\n+        boolean hasReturn = descriptor.returnLayout().isPresent();\n+        boolean hasAllocator = hasReturn && descriptor.returnLayout().get() instanceof GroupLayout;\n+        MethodHandle tryBlock = downcallHandle;\n+        MethodHandle cleanup = hasReturn ?\n+                MethodHandles.identity(downcallHandle.type().returnType()) :\n+                MethodHandles.empty(MethodType.methodType(void.class));\n+        for (int i = 0 ; i < descriptor.argumentLayouts().size() ; i++) {\n+            int paramIndex = i + (hasAllocator ? 2 : 1); \/\/ skip Addressable, and SegmentAllocator (if present)\n+            int cleanupIndex = i + (hasReturn ? 1 : 0); \/\/ skip Throwable and result (if present), and Addressable\n+            MemoryLayout layout = descriptor.argumentLayouts().get(i);\n+            Class<?> carrier = downcallHandle.type().parameterType(paramIndex);\n+            if (layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemoryAddress.class) {\n+                \/\/ add acquire filter\n+                tryBlock = filterArguments(tryBlock, paramIndex, ACQUIRE_MH);\n+                \/\/ add cleanup filter\n+                cleanup = collectArguments(cleanup, cleanupIndex, RELEASE_MH);\n+            } else {\n+                cleanup = dropArguments(cleanup, cleanupIndex, carrier);\n+            }\n+        }\n+        cleanup = dropArguments(cleanup, 0, Throwable.class);\n+        \/\/ acquire\/release target addressable\n+        tryBlock = filterArguments(tryBlock, 0, ACQUIRE_MH);\n+        cleanup = collectArguments(cleanup, hasReturn ? 2 : 1, RELEASE_MH);\n+        \/\/ fixup allocator\n+        if (hasAllocator) {\n+            \/\/ cleanup always has a result here, of type MemorySegment\n+            cleanup = dropArguments(cleanup, 3, SegmentAllocator.class);\n+        }\n+        return tryFinally(tryBlock, cleanup);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":58,"deletions":14,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,57 @@\n+\n+    @Test\n+    public void testClosedVaListCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n+            handle.invoke(list, scopeChecker(scope));\n+        }\n+    }\n+\n+    @Test\n+    public void testClosedStructCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(POINT, scope);\n+            handle.invoke(segment, scopeChecker(scope));\n+        }\n+    }\n+\n+    @Test\n+    public void testClosedUpcallCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MethodHandle dummy = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"dummy\", MethodType.methodType(void.class));\n+            CLinker.UpcallStub upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+            handle.invoke(upcall, scopeChecker(scope));\n+        }\n+    }\n+\n+    CLinker.UpcallStub scopeChecker(ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"checkScope\",\n+                    MethodType.methodType(void.class, ResourceScope.class));\n+            handle = handle.bindTo(scope);\n+            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), ResourceScope.newConfinedScope());\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static void checkScope(ResourceScope scope) {\n+        try {\n+            scope.close();\n+            fail(\"Scope closed unexpectedly!\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"kept alive\")); \/\/if acquired, fine\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+\n+EXPORT void addr_func_cb(void* p, void (*callback)()) {\n+   callback();\n+}\n","filename":"test\/jdk\/java\/foreign\/libSafeAccess.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-    public MemorySegment panama_identity_struct() throws Throwable {\n-        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, point);\n+    public MemorySegment panama_identity_struct_confined() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, confinedPoint);\n@@ -75,1 +75,56 @@\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+    public MemorySegment panama_identity_struct_shared() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_confined_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3.invokeExact(recycling_allocator, confinedPoint, confinedPoint, confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_shared_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3.invokeExact(recycling_allocator, sharedPoint, sharedPoint, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n@@ -80,1 +135,1 @@\n-    public MemoryAddress panama_identity_memory_address_non_exact() throws Throwable {\n+    public MemoryAddress panama_identity_memory_address_null_non_exact() throws Throwable {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":59,"deletions":4,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+    static final MethodHandle identity_struct_3;\n+    static final MethodHandle identity_struct_3_v;\n+    static Addressable identity_struct_3_addr;\n@@ -56,0 +59,3 @@\n+    static final MethodHandle identity_memory_address_3;\n+    static final MethodHandle identity_memory_address_3_v;\n+    static Addressable identity_memory_address_3_addr;\n@@ -76,1 +82,1 @@\n-            C_LONG_LONG, C_LONG_LONG\n+            C_INT, C_INT\n@@ -79,0 +85,3 @@\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n+\n@@ -106,0 +115,5 @@\n+        identity_struct_3_addr = lookup.lookup(\"identity_struct_3\").orElseThrow();\n+        identity_struct_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct_3 = insertArguments(identity_struct_3_v, 0, identity_struct_3_addr);\n+\n@@ -111,0 +125,5 @@\n+        identity_memory_address_3_addr = lookup.lookup(\"identity_memory_address_3\").orElseThrow();\n+        identity_memory_address_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n+        identity_memory_address_3 = insertArguments(identity_memory_address_3_v, 0, identity_memory_address_3_addr);\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -63,0 +64,59 @@\n+    public MemorySegment panama_identity_struct_confined() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_shared() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_confined_3() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, confinedPoint, confinedPoint, confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_shared_3() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, sharedPoint, sharedPoint, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact((Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact((Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact((Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact((Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n+    }\n+\n@@ -74,1 +134,1 @@\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    long long x;\n-    long long y;\n+    int x;\n+    int y;\n@@ -45,0 +45,4 @@\n+EXPORT Point identity_struct_3(Point p1, Point p2, Point p3) {\n+    return p1;\n+}\n+\n@@ -49,0 +53,4 @@\n+EXPORT void* identity_memory_address_3(void* p1, void* p2, void* p3) {\n+    return p1;\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverhead.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}