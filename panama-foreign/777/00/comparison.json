{"files":[{"patch":"@@ -40,1 +40,1 @@\n- * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.\n+ * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Linker.Option...) upcall stubs}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.<\/li>\n+ * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Option...) upcall stubs}.<\/li>\n@@ -89,1 +89,1 @@\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) Creating an upcall stub} requires a method\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Option...) Creating an upcall stub} requires a method\n@@ -163,1 +163,1 @@\n-     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stub}.\n+     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Option...) upcall stub}.\n@@ -256,0 +256,1 @@\n+     * @param options  any linker options.\n@@ -264,1 +265,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope, Linker.Option... options);\n@@ -335,0 +336,13 @@\n+        \/**\n+         * {@return a linker option that can be used to specify the uncaught exception handler that should be executed\n+         *          if an exception is thrown, but not caught, during an upcall}\n+         * <p>\n+         * Note that using a custom exception handler will not prevent the VM from exiting in the case of an uncaught\n+         * exception during an upcall.\n+         *\n+         * @param handler the handler\n+         *\/\n+        static Option uncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) {\n+            return new LinkerOptions.UncaughtExceptionHandler(handler);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, SegmentScope) create}\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, SegmentScope, Linker.Option...) create}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope, Linker.Option... options) {\n@@ -81,0 +81,1 @@\n+        LinkerOptions optionSet = LinkerOptions.forUpcall(function, options);\n@@ -86,1 +87,1 @@\n-        return arrangeUpcall(target, target.type(), function, scope);\n+        return arrangeUpcall(target, target.type(), function, scope, optionSet);\n@@ -90,1 +91,2 @@\n-                                                   FunctionDescriptor function, SegmentScope scope);\n+                                                   FunctionDescriptor function, SegmentScope scope,\n+                                                   LinkerOptions options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -675,1 +675,1 @@\n-            stack.push(((MemorySegment)stack.pop()).address());\n+            stack.push(SharedUtils.unboxSegment((MemorySegment)stack.pop()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class).descriptorString();\n+    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class, Thread.UncaughtExceptionHandler.class).descriptorString();\n@@ -166,1 +166,2 @@\n-            MethodHandles.Lookup definedClassLookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, false);\n+            MethodHandles.Lookup definedClassLookup = MethodHandles.lookup()\n+                    .defineHiddenClassWithClassData(bytes, leafHandle, false);\n@@ -183,1 +184,4 @@\n-            MethodHandles.Lookup defineClassLookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+            Thread.UncaughtExceptionHandler uncaughtExceptionHandler = callingSequence.uncaughtExceptionHandler();\n+            MethodHandles.Lookup defineClassLookup = uncaughtExceptionHandler != null\n+                ? MethodHandles.lookup().defineHiddenClassWithClassData(bytes, uncaughtExceptionHandler, true)\n+                : MethodHandles.lookup().defineHiddenClass(bytes, true);\n@@ -423,7 +427,12 @@\n-           emitInvokeStatic(SharedUtils.class, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n-           if (callerMethodType.returnType() != void.class) {\n-               emitConstZero(callerMethodType.returnType());\n-               emitReturn(callerMethodType.returnType());\n-           } else {\n-               mv.visitInsn(RETURN);\n-           }\n+            if (callingSequence.uncaughtExceptionHandler() != null) {\n+                emitConst(CLASS_DATA_CONDY);\n+            } else {\n+                emitConst(null);\n+            }\n+            emitInvokeStatic(SharedUtils.class, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n+            if (callerMethodType.returnType() != void.class) {\n+                emitConstZero(callerMethodType.returnType());\n+                emitReturn(callerMethodType.returnType());\n+            } else {\n+                mv.visitInsn(RETURN);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -198,0 +198,4 @@\n+    public Thread.UncaughtExceptionHandler uncaughtExceptionHandler() {\n+        return linkerOptions.uncaughtExceptionHandler();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.BiConsumer;\n@@ -48,1 +49,10 @@\n-        Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n+        return forShared(LinkerOptionImpl::validateForDowncall, desc, options);\n+    }\n+\n+    public static LinkerOptions forUpcall(FunctionDescriptor desc, Linker.Option[] options) {\n+        return forShared(LinkerOptionImpl::validateForUpcall, desc, options);\n+    }\n+\n+    private static LinkerOptions forShared(BiConsumer<LinkerOptionImpl, FunctionDescriptor> validator,\n+                                           FunctionDescriptor desc, Linker.Option... options) {\n+       Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n@@ -55,1 +65,1 @@\n-            opImpl.validateForDowncall(desc);\n+            validator.accept(opImpl, desc);\n@@ -94,0 +104,5 @@\n+    public Thread.UncaughtExceptionHandler uncaughtExceptionHandler() {\n+        UncaughtExceptionHandler ueh = getOption(UncaughtExceptionHandler.class);\n+        return ueh != null ? ueh.handler() : null;\n+    }\n+\n@@ -107,1 +122,1 @@\n-            permits CaptureCallStateImpl, FirstVariadicArg, IsTrivial {\n+            permits CaptureCallStateImpl, FirstVariadicArg, IsTrivial, UncaughtExceptionHandler {\n@@ -111,0 +126,4 @@\n+\n+        default void validateForUpcall(FunctionDescriptor descriptor) {\n+            throw new IllegalArgumentException(\"Not supported for upcall: \" + this);\n+        }\n@@ -149,0 +168,6 @@\n+    public record UncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler) implements LinkerOptionImpl {\n+        @Override\n+        public void validateForUpcall(FunctionDescriptor descriptor) {\n+            \/\/ always allowed\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-    public static void handleUncaughtException(Throwable t) {\n+    public static void handleUncaughtException(Throwable t, Thread.UncaughtExceptionHandler handler) {\n@@ -267,2 +267,10 @@\n-            t.printStackTrace();\n-            JLA.exit(1);\n+            try {\n+                Thread currentThread = Thread.currentThread();\n+                if (handler == null) {\n+                     handler = currentThread.getUncaughtExceptionHandler();\n+                }\n+                handler.uncaughtException(currentThread, t);\n+            } finally {\n+                System.err.println(\"Unrecoverable uncaught exception encountered. The VM will now exit\");\n+                JLA.exit(1);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-            SharedUtils.handleUncaughtException(t);\n+            SharedUtils.handleUncaughtException(t, invData.callingSequence().uncaughtExceptionHandler());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Linker;\n@@ -192,2 +193,2 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, scope);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, scope, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, scope);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, scope, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return  CallArranger.WINDOWS.arrangeUpcall(target, targetType, function, scope);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+        return  CallArranger.WINDOWS.arrangeUpcall(target, targetType, function, scope, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.Linker;\n@@ -109,1 +110,1 @@\n-                                          SegmentScope scope) {\n+                                          SegmentScope scope, LinkerOptions options) {\n@@ -116,1 +117,1 @@\n-        return LibFallback.createClosure(cif, doUpcallMH, scope);\n+        return LibFallback.createClosure(cif, doUpcallMH, options.uncaughtExceptionHandler(), scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,1 +125,2 @@\n-    static MemorySegment createClosure(MemorySegment cif, MethodHandle target, SegmentScope scope)\n+    static MemorySegment createClosure(MemorySegment cif, MethodHandle target,\n+                                       Thread.UncaughtExceptionHandler handler, SegmentScope scope)\n@@ -132,1 +133,2 @@\n-        checkStatus(createClosure(cif.address(), target, ptrs));\n+        UpcallData upcallData = new UpcallData(target, handler);\n+        checkStatus(createClosure(cif.address(), upcallData, ptrs));\n@@ -140,0 +142,2 @@\n+    private record UpcallData(MethodHandle target, Thread.UncaughtExceptionHandler handler) {}\n+\n@@ -141,1 +145,1 @@\n-    private static void doUpcall(long retPtr, long argPtrs, MethodHandle target) {\n+    private static void doUpcall(long retPtr, long argPtrs, UpcallData data) {\n@@ -143,1 +147,1 @@\n-            target.invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs));\n+            data.target().invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs));\n@@ -145,1 +149,1 @@\n-            SharedUtils.handleUncaughtException(t);\n+            SharedUtils.handleUncaughtException(t, data.handler());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -123,3 +123,2 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n-\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return LinuxRISCV64CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+        return LinuxRISCV64CallArranger.arrangeUpcall(target, targetType, function, scope, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,2 +135,2 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, scope, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, scope, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-static const char* LibFallback_doUpcall_sig = \"(JJLjava\/lang\/invoke\/MethodHandle;)V\";\n+static const char* LibFallback_doUpcall_sig = \"(JJLjdk\/internal\/foreign\/abi\/fallback\/LibFallback$UpcallData;)V\";\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+import java.lang.foreign.SegmentScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -47,0 +51,1 @@\n+    private static final MethodHandle DUMMY_TARGET_MH = MethodHandles.empty(MethodType.methodType(void.class));\n@@ -50,1 +55,1 @@\n-    public void testTypeMismatch(FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testIllegalLayouts(FunctionDescriptor desc, String expectedExceptionMessage) {\n@@ -60,0 +65,32 @@\n+    @Test(dataProvider = \"upcallOnlyOptions\",\n+          expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Not supported for downcall.*\")\n+    public void testIllegalDowncallOptions(Linker.Option upcallOnlyOption) {\n+        ABI.downcallHandle(DUMMY_TARGET, FunctionDescriptor.ofVoid(), upcallOnlyOption);\n+    }\n+\n+    @Test(dataProvider = \"downcallOnlyOptions\",\n+          expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Not supported for upcall.*\")\n+    public void testIllegalUpcallOptions(Linker.Option downcallOnlyOption) {\n+        ABI.upcallStub(DUMMY_TARGET_MH, FunctionDescriptor.ofVoid(), SegmentScope.auto(), downcallOnlyOption);\n+    }\n+\n+    \/\/ where\n+\n+    @DataProvider\n+    public static Object[][] upcallOnlyOptions() {\n+        return new Object[][]{\n+            { Linker.Option.uncaughtExceptionHandler((thread, ex) -> {}) }\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] downcallOnlyOptions() {\n+        return new Object[][]{\n+            { Linker.Option.firstVariadicArg(0) },\n+            { Linker.Option.captureCallState(\"errno\") },\n+            { Linker.Option.isTrivial() },\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @build ThrowingUpcall TestUpcallException\n+ * @build TestUpcallException\n@@ -40,0 +40,7 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -43,3 +50,3 @@\n-    @Test(dataProvider = \"cases\")\n-    public void testException(boolean useSpec, boolean isVoid) throws InterruptedException, IOException {\n-        runInNewProcess(ThrowingUpcall.class, useSpec, isVoid ? \"void\" : \"\")\n+    @Test(dataProvider = \"exceptionCases\")\n+    public void testException(Class<?> target, boolean useSpec) throws InterruptedException, IOException {\n+        runInNewProcess(target, useSpec)\n@@ -50,1 +57,1 @@\n-    public static Object[][] cases() {\n+    public static Object[][] exceptionCases() {\n@@ -52,4 +59,4 @@\n-            { false, true,  },\n-            { false, false, },\n-            { true,  true,  },\n-            { true,  false, }\n+            { VoidUpcallRunner.class,    false },\n+            { NonVoidUpcallRunner.class, false },\n+            { VoidUpcallRunner.class,    true  },\n+            { NonVoidUpcallRunner.class, true  }\n@@ -58,0 +65,97 @@\n+\n+    public static class VoidUpcallRunner extends ExceptionRunnerBase {\n+        public static void main(String[] args) throws Throwable {\n+            try (Arena arena = Arena.openConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena.scope());\n+\n+                downcallVoid.invoke(stub); \/\/ should call Shutdown.exit(1);\n+            }\n+        }\n+    }\n+\n+    public static class NonVoidUpcallRunner extends ExceptionRunnerBase {\n+        public static void main(String[] args) throws Throwable {\n+            MethodHandle handle = MethodHandles.identity(int.class);\n+            handle = MethodHandles.collectArguments(handle, 0, MH_throwException);\n+            MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(int.class, int.class));\n+            handle = MethodHandles.insertArguments(invoker, 0, handle);\n+\n+            try (Arena arena = Arena.openConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.scope());\n+\n+                downcallNonVoid.invoke(42, stub); \/\/ should call Shutdown.exit(1);\n+            }\n+        }\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    @Test(dataProvider = \"uncaughtHandlerCases\")\n+    public void testUncaughtExceptionHandlerOption(Class<?> target) throws InterruptedException, IOException {\n+        runInNewProcess(target, true)\n+                .assertStdOutContains(\"From uncaught exception handler\");\n+    }\n+\n+    @DataProvider\n+    public static Object[][] uncaughtHandlerCases() {\n+        return new Object[][]{\n+            { UncaughtHandlerOptionRunner.class },\n+            { UncaughtHandlerThreadRunner.class }\n+        };\n+    }\n+\n+    public static class UncaughtHandlerOptionRunner extends VoidUpcallRunner {\n+        public static void main(String[] args) throws Throwable {\n+            try (Arena arena = Arena.openConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(),\n+                        arena.scope(), Linker.Option.uncaughtExceptionHandler(UNCAUGHT_EXCEPTION_HANDLER));\n+                downcallVoid.invoke(stub);\n+            }\n+        }\n+    }\n+\n+    public static class UncaughtHandlerThreadRunner extends VoidUpcallRunner {\n+        public static void main(String[] args) throws Throwable {\n+            Thread.currentThread().setUncaughtExceptionHandler(UNCAUGHT_EXCEPTION_HANDLER);\n+            try (Arena arena = Arena.openConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena.scope());\n+                downcallVoid.invoke(stub);\n+            }\n+        }\n+    }\n+\n+    \/\/ where\n+\n+    private static class ExceptionRunnerBase {\n+        static final MethodHandle downcallVoid;\n+        static final MethodHandle downcallNonVoid;\n+        static final MethodHandle MH_throwException;\n+        static final MethodHandle VOID_TARGET;\n+\n+        static final Thread.UncaughtExceptionHandler UNCAUGHT_EXCEPTION_HANDLER\n+                = (thread, throwable) -> System.out.println(\"From uncaught exception handler\");\n+\n+        static {\n+                System.loadLibrary(\"TestUpcall\");\n+            downcallVoid = Linker.nativeLinker().downcallHandle(\n+                findNativeOrThrow(\"f0_V__\"),\n+                    FunctionDescriptor.ofVoid(C_POINTER)\n+            );\n+            downcallNonVoid = Linker.nativeLinker().downcallHandle(\n+                    findNativeOrThrow(\"f10_I_I_\"),\n+                    FunctionDescriptor.of(C_INT, C_INT, C_POINTER)\n+            );\n+            try {\n+                MH_throwException = MethodHandles.lookup().findStatic(ExceptionRunnerBase.class, \"throwException\",\n+                        MethodType.methodType(void.class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+            MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(void.class));\n+            VOID_TARGET = MethodHandles.insertArguments(invoker, 0, MH_throwException);\n+        }\n+\n+        public static void throwException() throws Throwable {\n+            throw new Throwable(\"Testing upcall exceptions\");\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":113,"deletions":9,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n@@ -36,1 +36,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-public class ThrowingUpcall extends NativeTestHelper {\n-\n-    private static final MethodHandle downcallVoid;\n-    private static final MethodHandle downcallNonVoid;\n-    public static final MethodHandle MH_throwException;\n-\n-    static {\n-        System.loadLibrary(\"TestUpcall\");\n-        downcallVoid = Linker.nativeLinker().downcallHandle(\n-            findNativeOrThrow(\"f0_V__\"),\n-                FunctionDescriptor.ofVoid(C_POINTER)\n-        );\n-        downcallNonVoid = Linker.nativeLinker().downcallHandle(\n-                findNativeOrThrow(\"f10_I_I_\"),\n-                FunctionDescriptor.of(C_INT, C_INT, C_POINTER)\n-        );\n-\n-        try {\n-            MH_throwException = MethodHandles.lookup().findStatic(ThrowingUpcall.class, \"throwException\",\n-                    MethodType.methodType(void.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n-    public static void throwException() throws Throwable {\n-        throw new Throwable(\"Testing upcall exceptions\");\n-    }\n-\n-    public static void main(String[] args) throws Throwable {\n-        if (args[0].equals(\"void\")) {\n-            testVoid();\n-        } else {\n-            testNonVoid();\n-        }\n-    }\n-\n-    public static void testVoid() throws Throwable {\n-        MethodHandle handle = MH_throwException;\n-        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(void.class));\n-        handle = MethodHandles.insertArguments(invoker, 0, handle);\n-\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.scope());\n-\n-            downcallVoid.invoke(stub); \/\/ should call Shutdown.exit(1);\n-        }\n-    }\n-\n-    public static void testNonVoid() throws Throwable {\n-        MethodHandle handle = MethodHandles.identity(int.class);\n-        handle = MethodHandles.collectArguments(handle, 0, MH_throwException);\n-        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(int.class, int.class));\n-        handle = MethodHandles.insertArguments(invoker, 0, handle);\n-\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.scope());\n-\n-            downcallNonVoid.invoke(42, stub); \/\/ should call Shutdown.exit(1);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -45,1 +45,1 @@\n-        public void assertStdErrContains(String shouldInclude) {\n+        public Output assertStdErrContains(String shouldInclude) {\n@@ -47,0 +47,1 @@\n+            return this;\n@@ -49,1 +50,1 @@\n-        public void assertStdOutContains(String shouldInclude) {\n+        public Output assertStdOutContains(String shouldInclude) {\n@@ -51,0 +52,1 @@\n+            return this;\n@@ -66,1 +68,1 @@\n-            \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n+            \"-Djdk.internal.foreign.UpcallLinker.USE_SPEC=\" + useSpec,\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}