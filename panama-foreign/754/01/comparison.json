{"files":[{"patch":"@@ -179,0 +179,4 @@\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->fmovd(as_Register(to_reg), from_reg);\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64VaList;\n@@ -107,1 +108,1 @@\n-public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n+public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, WindowsAArch64VaList, SharedUtils.EmptyVaList {\n@@ -302,1 +303,1 @@\n-    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n+    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder, WindowsAArch64VaList.Builder {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-    MAC_OS_AARCH_64;\n+    MAC_OS_AARCH_64,\n+    WIN_AARCH_64;\n@@ -57,0 +58,2 @@\n+            } else if (OS.startsWith(\"Windows\")) {\n+                ABI = WIN_AARCH_64;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                case WIN_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n+                case WIN_64, WIN_AARCH_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n@@ -123,1 +123,1 @@\n-            case WIN_64 -> \"bin\";\n+            case WIN_64, WIN_AARCH_64 -> \"bin\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -46,1 +47,1 @@\n-                                                                      SysVx64Linker, Windowsx64Linker {\n+                                                                      SysVx64Linker, WindowsAArch64Linker, Windowsx64Linker {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,0 +84,5 @@\n+    public boolean isVariadicFunction() {\n+        FirstVariadicArg fva = getOption(FirstVariadicArg.class);\n+        return fva != null && fva.index >= 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -186,0 +187,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.getInstance();\n@@ -293,0 +295,1 @@\n+\n@@ -297,0 +300,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaList(actions, scope);\n@@ -306,0 +310,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaListOfAddress(address, scope);\n@@ -315,0 +320,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.emptyVaList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64CallArranger;\n@@ -63,1 +64,1 @@\n- * public constants CallArranger.LINUX and CallArranger.MACOS.\n+ * public constants CallArranger.LINUX, CallArranger.MACOS, and CallArranger.WINDOWS.\n@@ -82,1 +83,1 @@\n-    private static final ABIDescriptor C = abiFor(\n+    protected static final ABIDescriptor C = abiFor(\n@@ -101,0 +102,1 @@\n+    public static final CallArranger WINDOWS = new WindowsAArch64CallArranger();\n@@ -115,0 +117,25 @@\n+    \/**\n+     * Are floating point arguments to variadic functions passed in general purpose registers\n+     * instead of floating point registers?\n+     *\n+     * {@return true if this ABI uses general purpose registers for variadic floating point arguments.}\n+     *\/\n+    protected abstract boolean useIntRegsForVariadicFloatingPointArgs();\n+\n+    \/**\n+     * Should some fields of structs that assigned to registers be passed in registers when there\n+     * are not enough registers for all the fields of the struct?\n+     *\n+     * {@return true if this ABI passes some fields of a struct in registers.}\n+     *\/\n+    protected abstract boolean spillsVariadicStructsPartially();\n+\n+    \/**\n+     * @return The ABIDescriptor used by the CallArranger for the current platform.\n+     *\/\n+    protected abstract ABIDescriptor abiDescriptor();\n+\n+    protected TypeClass getArgumentClassForBindings(MemoryLayout layout, boolean forVariadicFunction) {\n+        return TypeClass.classifyLayout(layout);\n+    }\n+\n@@ -122,1 +149,3 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall, options);\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(abiDescriptor(), forUpcall, options);\n+\n+        boolean forVariadicFunction = options.isVariadicFunction();\n@@ -124,2 +153,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, forVariadicFunction);\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, forVariadicFunction) : new BoxBindingCalculator(false);\n@@ -152,1 +181,1 @@\n-        MethodHandle handle = new DowncallLinker(C, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new DowncallLinker(abiDescriptor(), bindings.callingSequence).getBoundMethodHandle();\n@@ -168,1 +197,1 @@\n-        return UpcallLinker.make(C, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(abiDescriptor(), target, bindings.callingSequence, session);\n@@ -180,0 +209,1 @@\n+        private final boolean forVariadicFunction;\n@@ -185,1 +215,1 @@\n-        public StorageCalculator(boolean forArguments) {\n+        public StorageCalculator(boolean forArguments, boolean forVariadicFunction) {\n@@ -187,0 +217,1 @@\n+            this.forVariadicFunction = forVariadicFunction;\n@@ -215,0 +246,1 @@\n+                ABIDescriptor abiDescriptor = abiDescriptor();\n@@ -216,1 +248,1 @@\n-                    (forArguments ? C.inputStorage : C.outputStorage)[type];\n+                    (forArguments ? abiDescriptor.inputStorage : abiDescriptor.outputStorage)[type];\n@@ -231,1 +263,19 @@\n-            return regAlloc(type, (int)Utils.alignUp(layout.byteSize(), 8) \/ 8);\n+            boolean spillRegistersPartially = forVariadicFunction && spillsVariadicStructsPartially();\n+\n+            return spillRegistersPartially ?\n+                regAllocPartial(type, layout) :\n+                regAlloc(type, requiredRegisters(layout));\n+        }\n+\n+        int requiredRegisters(MemoryLayout layout) {\n+            return (int)Utils.alignUp(layout.byteSize(), 8) \/ 8;\n+        }\n+\n+        VMStorage[] regAllocPartial(int type, MemoryLayout layout) {\n+            int availableRegisters = MAX_REGISTER_ARGUMENTS - nRegs[type];\n+            if (availableRegisters <= 0) {\n+                return null;\n+            }\n+\n+            int requestRegisters = Math.min(requiredRegisters(layout), availableRegisters);\n+            return regAlloc(type, requestRegisters);\n@@ -235,0 +285,9 @@\n+            if (type == StorageType.VECTOR) {\n+                boolean forVariadicFunctionArgs = forArguments && forVariadicFunction;\n+                boolean useIntRegsForFloatingPointArgs = forVariadicFunctionArgs && useIntRegsForVariadicFloatingPointArgs();\n+\n+                if (useIntRegsForFloatingPointArgs) {\n+                    type = StorageType.INTEGER;\n+                }\n+            }\n+\n@@ -275,2 +334,2 @@\n-        protected BindingCalculator(boolean forArguments) {\n-            this.storageCalculator = new StorageCalculator(forArguments);\n+        protected BindingCalculator(boolean forArguments, boolean forVariadicFunction) {\n+            this.storageCalculator = new StorageCalculator(forArguments, forVariadicFunction);\n@@ -285,1 +344,4 @@\n-            long offset = 0;\n+            spillPartialStructUnbox(bindings, layout, 0);\n+        }\n+\n+        protected void spillPartialStructUnbox(Binding.Builder bindings, MemoryLayout layout, long offset) {\n@@ -337,2 +399,7 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n-            super(forArguments);\n+        protected final boolean forArguments;\n+        protected final boolean forVariadicFunction;\n+\n+        UnboxBindingCalculator(boolean forArguments, boolean forVariadicFunction) {\n+            super(forArguments, forVariadicFunction);\n+            this.forArguments = forArguments;\n+            this.forVariadicFunction = forVariadicFunction;\n@@ -351,1 +418,1 @@\n-            TypeClass argumentClass = TypeClass.classifyLayout(layout);\n+            TypeClass argumentClass = getArgumentClassForBindings(layout, forVariadicFunction);\n@@ -353,0 +420,1 @@\n+\n@@ -356,2 +424,2 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                        StorageType.INTEGER, layout);\n+                    VMStorage[] regs = storageCalculator.regAlloc(StorageType.INTEGER, layout);\n+\n@@ -361,1 +429,1 @@\n-                        while (offset < layout.byteSize()) {\n+                        while (offset < layout.byteSize() && regIndex < regs.length) {\n@@ -364,2 +432,1 @@\n-                            boolean useFloat = storage.type() == StorageType.VECTOR;\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -373,0 +440,5 @@\n+\n+                        final long bytesLeft = Math.min(layout.byteSize() - offset, 8);\n+                        if (bytesLeft > 0) {\n+                            spillPartialStructUnbox(bindings, layout, offset);\n+                        }\n@@ -438,1 +510,1 @@\n-            super(forArguments);\n+            super(forArguments, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":94,"deletions":22,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.ABIDescriptor;\n@@ -46,0 +47,15 @@\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return C;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.ABIDescriptor;\n@@ -46,0 +47,15 @@\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return C;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n+import jdk.internal.foreign.abi.ABIDescriptor;\n+import jdk.internal.foreign.abi.VMStorage;\n+\n+import java.lang.foreign.MemoryLayout;\n+\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for Windows ABI.\n+ *\/\n+public class WindowsAArch64CallArranger extends CallArranger {\n+\n+    private static final VMStorage INDIRECT_RESULT = r8;\n+\n+    \/\/ This is derived from the AAPCS64 spec, restricted to what's\n+    \/\/ possible when calling to\/from C code.\n+    \/\/\n+    \/\/ The indirect result register, r8, is used to return a large\n+    \/\/ struct by value. It's treated as an input here as the caller is\n+    \/\/ responsible for allocating storage and passing this into the\n+    \/\/ function.\n+    \/\/\n+    \/\/ Although the AAPCS64 says r0-7 and v0-7 are all valid return\n+    \/\/ registers, it's not possible to generate a C function that uses\n+    \/\/ r2-7 and v4-7 so they are omitted here.\n+    private static final ABIDescriptor WindowsAArch64AbiDescriptor = abiFor(\n+        new VMStorage[] { r0, r1, r2, r3, r4, r5, r6, r7, INDIRECT_RESULT},\n+        new VMStorage[] { v0, v1, v2, v3, v4, v5, v6, v7 },\n+        new VMStorage[] { r0, r1 },\n+        new VMStorage[] { v0, v1, v2, v3 },\n+        new VMStorage[] { r9, r10, r11, r12, r13, r14, r15, r16, r17 },\n+        new VMStorage[] { v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n+                          v26, v27, v28, v29, v30, v31 },\n+        16,  \/\/ Stack is always 16 byte aligned on AArch64\n+        0,   \/\/ No shadow space\n+        r9,  \/\/ target addr reg\n+        r10  \/\/ return buffer addr reg\n+    );\n+\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return WindowsAArch64AbiDescriptor;\n+    }\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean requiresSubSlotStackPacking() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        \/\/ The Windows ABI requires floating point arguments to be passed in\n+        \/\/ general purpose registers when calling variadic functions.\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected TypeClass getArgumentClassForBindings(MemoryLayout layout, boolean forVariadicFunction) {\n+        TypeClass argumentClass = TypeClass.classifyLayout(layout);\n+\n+        \/\/ HFA struct arguments are classified as STRUCT_REGISTER when\n+        \/\/ general purpose registers are being used to pass floating point\n+        \/\/ arguments. If the HFA is too big to pass entirely in general\n+        \/\/ purpose registers, it is classified as an ordinary struct\n+        \/\/ (i.e. as a STRUCT_REFERENCE).\n+        if (argumentClass == TypeClass.STRUCT_HFA && forVariadicFunction) {\n+            \/\/ The Windows ABI requires the members of the variadic HFA to be\n+            \/\/ passed in general purpose registers but only a STRUCT_HFA that\n+            \/\/ is at most 16 bytes can be passed in general purpose registers.\n+            argumentClass = layout.byteSize() <= 16 ? TypeClass.STRUCT_REGISTER : TypeClass.STRUCT_REFERENCE;\n+        }\n+\n+        return argumentClass;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64CallArranger.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Microsoft. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope ;\n+import java.lang.foreign.VaList;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * ABI implementation for Windows\/AArch64. Based on AAPCS with\n+ * changes to va_list.\n+ *\/\n+public final class WindowsAArch64Linker extends AbstractLinker {\n+    private static WindowsAArch64Linker instance;\n+\n+    public static WindowsAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new WindowsAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.WINDOWS.arrangeDowncall(inferredMethodType, function, options);\n+    }\n+\n+    @Override\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n+        return  CallArranger.WINDOWS.arrangeUpcall(target, targetType, function, scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n+        WindowsAArch64VaList.Builder builder = WindowsAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n+        return WindowsAArch64VaList.ofAddress(address, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return WindowsAArch64VaList.empty();\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n+\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n+import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n+\n+\/\/ see vadefs.h (VC header) for the ARM64 va_arg impl\n+\/\/\n+\/\/    typedef char* va_list;\n+\/\/\n+\/\/    #define __crt_va_arg(ap, t)                                                \\\n+\/\/        ((sizeof(t) > (2 * sizeof(__int64)))                                   \\\n+\/\/            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))               \\\n+\/\/            : *(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))\n+\/\/\n+public non-sealed class WindowsAArch64VaList implements VaList {\n+    private static final long VA_SLOT_SIZE_BYTES = 8;\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n+\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n+\n+    private MemorySegment segment;\n+\n+    private WindowsAArch64VaList(MemorySegment segment) {\n+        this.segment = segment;\n+    }\n+\n+    public static VaList empty() {\n+        return EMPTY;\n+    }\n+\n+    @Override\n+    public int nextVarg(ValueLayout.OfInt layout) {\n+        return (int) read(layout);\n+    }\n+\n+    @Override\n+    public long nextVarg(ValueLayout.OfLong layout) {\n+        return (long) read(layout);\n+    }\n+\n+    @Override\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n+        return (double) read(layout);\n+    }\n+\n+    @Override\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n+    }\n+\n+    @Override\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(layout, allocator);\n+    }\n+\n+    private Object read(MemoryLayout layout) {\n+        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n+    }\n+\n+    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(layout);\n+        Object res;\n+        if (layout instanceof GroupLayout) {\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            res = switch (typeClass) {\n+                case STRUCT_REFERENCE -> {\n+                    checkElement(layout, VA_SLOT_SIZE_BYTES);\n+                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(struct);\n+                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+                    yield seg;\n+                }\n+                case STRUCT_REGISTER, STRUCT_HFA -> {\n+                    long size = alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+                    checkElement(layout, size);\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n+                    segment = segment.asSlice(size);\n+                    yield struct;\n+                }\n+                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+            };\n+        } else {\n+            checkElement(layout, VA_SLOT_SIZE_BYTES);\n+            VarHandle reader = layout.varHandle();\n+            res = reader.get(segment);\n+            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+        }\n+        return res;\n+    }\n+\n+    private static long sizeOf(MemoryLayout layout) {\n+        return switch (TypeClass.classifyLayout(layout)) {\n+            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+            default -> VA_SLOT_SIZE_BYTES;\n+        };\n+    }\n+\n+    @Override\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n+\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            long size = sizeOf(layout);\n+            checkElement(layout, size);\n+            segment = segment.asSlice(size);\n+        }\n+    }\n+\n+    private void checkElement(MemoryLayout layout, long size) {\n+        if (segment.byteSize() < size) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n+    static WindowsAArch64VaList ofAddress(long address, SegmentScope session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n+        return new WindowsAArch64VaList(segment);\n+    }\n+\n+    static Builder builder(SegmentScope session) {\n+        return new Builder(session);\n+    }\n+\n+    @Override\n+    public VaList copy() {\n+        ((MemorySessionImpl) segment.scope()).checkValidState();\n+        return new WindowsAArch64VaList(segment);\n+    }\n+\n+    @Override\n+    public MemorySegment segment() {\n+        \/\/ make sure that returned segment cannot be accessed\n+        return segment.asSlice(0, 0);\n+    }\n+\n+    public static non-sealed class Builder implements VaList.Builder {\n+\n+        private final SegmentScope session;\n+        private final List<SimpleVaArg> args = new ArrayList<>();\n+\n+        public Builder(SegmentScope session) {\n+            ((MemorySessionImpl) session).checkValidState();\n+            this.session = session;\n+        }\n+\n+        private Builder arg(MemoryLayout layout, Object value) {\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n+            args.add(new SimpleVaArg(layout, value));\n+            return this;\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n+            return arg(layout, value);\n+        }\n+\n+        public VaList build() {\n+            if (args.isEmpty()) {\n+                return EMPTY;\n+            }\n+\n+            long allocationSize = args.stream().reduce(0L, (acc, e) -> acc + sizeOf(e.layout), Long::sum);\n+            MemorySegment segment = MemorySegment.allocateNative(allocationSize, session);\n+            MemorySegment cursor = segment;\n+\n+            for (SimpleVaArg arg : args) {\n+                if (arg.layout instanceof GroupLayout) {\n+                    MemorySegment msArg = ((MemorySegment) arg.value);\n+                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n+                    switch (typeClass) {\n+                        case STRUCT_REFERENCE -> {\n+                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n+                            copy.copyFrom(msArg); \/\/ by-value\n+                            VH_address.set(cursor, copy);\n+                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor = cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+                    }\n+                } else {\n+                    VarHandle writer = arg.varHandle();\n+                    writer.set(cursor, arg.value);\n+                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                }\n+            }\n+\n+            return new WindowsAArch64VaList(segment);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64VaList.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -37,0 +38,2 @@\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -49,0 +53,1 @@\n+import static org.testng.Assert.*;\n@@ -68,1 +73,1 @@\n-    @Test(dataProvider = \"functions\")\n+    @Test(dataProvider = \"variadicFunctions\")\n@@ -109,0 +114,52 @@\n+    private static List<ParamType> createParameterTypesForStruct(int extraIntArgs) {\n+        List<ParamType> paramTypes = new ArrayList<ParamType>();\n+        for (int i = 0; i < extraIntArgs; i++) {\n+            paramTypes.add(ParamType.INT);\n+        }\n+        paramTypes.add(ParamType.STRUCT);\n+        return paramTypes;\n+    }\n+\n+    private static List<StructFieldType> createFieldsForStruct(int fieldCount, StructFieldType fieldType) {\n+        List<StructFieldType> fields = new ArrayList<StructFieldType>();\n+        for (int i = 0; i < fieldCount; i++) {\n+            fields.add(fieldType);\n+        }\n+        return fields;\n+    }\n+\n+    @DataProvider(name = \"variadicFunctions\")\n+    public static Object[][] variadicFunctions() {\n+        List<Object[]> downcalls = new ArrayList<>();\n+\n+        var functionsDowncalls = functions();\n+        for (var array : functionsDowncalls) {\n+            downcalls.add(array);\n+        }\n+\n+        \/\/ Test struct with 4 floats\n+        int extraIntArgs = 0;\n+        List<StructFieldType> fields = createFieldsForStruct(4, StructFieldType.FLOAT);\n+        List<ParamType> paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        \/\/ Test struct with 4 floats without enough registers for all fields\n+        extraIntArgs = 6;\n+        fields = createFieldsForStruct(4, StructFieldType.FLOAT);\n+        paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        \/\/ Test struct with 2 doubles without enough registers for all fields\n+        extraIntArgs = 7;\n+        fields = createFieldsForStruct(2, StructFieldType.DOUBLE);\n+        paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        \/\/ Test struct with 2 ints without enough registers for all fields\n+        fields = createFieldsForStruct(2, StructFieldType.INT);\n+        paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        return downcalls.toArray(new Object[0][]);\n+    }\n+\n@@ -265,0 +322,1 @@\n+            S_FFFF,\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n+ * @build CallArrangerTestBase\n+ * @run testng TestWindowsAArch64CallArranger\n+ *\/\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.MemorySegment;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestWindowsAArch64CallArranger extends CallArrangerTestBase {\n+\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n+\n+    @Test\n+    public void testWindowsArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class, double.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(v1, double.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class, double.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, float.class) },\n+            { vmStore(r3, double.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsArgsInRegsAndOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, double.class, int.class, float.class,\n+                                              double.class, float.class, float.class, double.class,\n+                                              float.class, float.class, float.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_DOUBLE, C_INT, C_FLOAT,\n+                                              C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE,\n+                                              C_FLOAT, C_FLOAT, C_FLOAT, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(v1, float.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, float.class) },\n+            { vmStore(v4, float.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, float.class) },\n+            { vmStore(v7, float.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { vmStore(r1, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVarArgsInRegsAndOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, double.class, int.class, float.class,\n+                                              double.class, float.class, float.class, double.class,\n+                                              float.class, float.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_DOUBLE, C_INT, C_FLOAT,\n+                                              C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE,\n+                                              C_FLOAT, C_FLOAT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_DOUBLE, C_INT, C_FLOAT, C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE, C_FLOAT, C_FLOAT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, double.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, float.class) },\n+            { vmStore(r3, double.class) },\n+            { vmStore(r4, float.class) },\n+            { vmStore(r5, float.class) },\n+            { vmStore(r6, double.class) },\n+            { vmStore(r7, float.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { vmStore(stackStorage((short) 4, 8), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa4FloatsInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                dup(),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class),\n+                bufferLoad(12, float.class),\n+                vmStore(v3, float.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa4FloatsInIntRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(r0, long.class),\n+                bufferLoad(8, long.class),\n+                vmStore(r1, long.class),\n+            },\n+            { vmStore(r2, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa2DoublesInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, double.class),\n+                vmStore(v0, double.class),\n+                bufferLoad(8, double.class),\n+                vmStore(v1, double.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa2DoublesInIntRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(r0, long.class),\n+                bufferLoad(8, long.class),\n+                vmStore(r1, long.class),\n+            },\n+            { vmStore(r2, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa3DoublesInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, double.class),\n+                vmStore(v0, double.class),\n+                dup(),\n+                bufferLoad(8, double.class),\n+                vmStore(v1, double.class),\n+                bufferLoad(16, double.class),\n+                vmStore(v2, double.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa3DoublesAsReferenceStruct() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n+            { vmStore(r1, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -131,0 +131,1 @@\n+    T_S_FFFF,\n@@ -230,0 +231,1 @@\n+            CASE(T_S_FFFF, struct S_FFFF)\n","filename":"test\/jdk\/java\/foreign\/libVarArgs.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+struct S_FFFF { float p0; float p1; float p2; float p3; };\n","filename":"test\/jdk\/java\/foreign\/shared.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -135,1 +136,1 @@\n-    private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n+            private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n@@ -137,0 +138,2 @@\n+    private static final Function<Consumer<VaList.Builder>, VaList> winAArch64VaListFactory\n+            = actions -> WindowsAArch64Linker.newVaList(actions, SegmentScope.auto());\n@@ -148,0 +151,2 @@\n+    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> winAArch64VaListScopedFactory\n+            = WindowsAArch64Linker::newVaList;\n@@ -163,0 +168,1 @@\n+                { winAArch64VaListFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n@@ -191,0 +197,1 @@\n+                { winAArch64VaListFactory,   sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n@@ -221,0 +228,1 @@\n+                { winAArch64VaListFactory,   getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n@@ -276,0 +284,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_INT, sumStructJavaFact),\n@@ -329,0 +338,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n@@ -382,0 +392,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_FLOAT, sumStructJavaFact),\n@@ -444,0 +455,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n@@ -498,0 +510,1 @@\n+                { winAArch64VaListFactory,    sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n@@ -552,0 +565,2 @@\n+                { WindowsAArch64Linker.emptyVaList()       },\n+                { winAArch64VaListFactory.apply(b -> {})   },\n@@ -567,0 +582,1 @@\n+                { winAArch64VaListScopedFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n@@ -615,0 +631,1 @@\n+                { winAArch64VaListScopedFactory,   AArch64.C_INT },\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}