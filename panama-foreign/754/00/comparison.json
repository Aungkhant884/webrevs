{"files":[{"patch":"@@ -179,0 +179,4 @@\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->fmovd(as_Register(to_reg), from_reg);\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64VaList;\n@@ -100,1 +101,1 @@\n-public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n+public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, WindowsAArch64VaList, SharedUtils.EmptyVaList {\n@@ -298,1 +299,1 @@\n-    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n+    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder, WindowsAArch64VaList.Builder {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-    MAC_OS_AARCH_64;\n+    MAC_OS_AARCH_64,\n+    WIN_AARCH_64;\n@@ -57,0 +58,2 @@\n+            } else if (OS.startsWith(\"Windows\")) {\n+                ABI = WIN_AARCH_64;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                case WIN_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n+                case WIN_64, WIN_AARCH_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n@@ -123,1 +123,1 @@\n-            case WIN_64 -> \"bin\";\n+            case WIN_64, WIN_AARCH_64 -> \"bin\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -46,1 +47,1 @@\n-                                                                      SysVx64Linker, Windowsx64Linker {\n+                                                                      SysVx64Linker, WindowsAArch64Linker, Windowsx64Linker {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,0 +84,5 @@\n+    public boolean isVariadicFunction() {\n+        FirstVariadicArg fva = getOption(FirstVariadicArg.class);\n+        return fva != null && fva.index >= 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -188,0 +189,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.getInstance();\n@@ -299,0 +301,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaList(actions, session);\n@@ -308,0 +311,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaListOfAddress(address, session);\n@@ -317,0 +321,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.emptyVaList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64CallArranger;\n@@ -63,1 +64,1 @@\n- * public constants CallArranger.LINUX and CallArranger.MACOS.\n+ * public constants CallArranger.LINUX, CallArranger.MACOS, and CallArranger.WINDOWS.\n@@ -82,1 +83,1 @@\n-    private static final ABIDescriptor C = abiFor(\n+    protected static final ABIDescriptor C = abiFor(\n@@ -101,0 +102,1 @@\n+    public static final CallArranger WINDOWS = new WindowsAArch64CallArranger();\n@@ -115,0 +117,25 @@\n+    \/**\n+     * Are floating point arguments to variadic functions passed in general purpose registers\n+     * instead of floating point registers?\n+     *\n+     * {@return true if this ABI uses general purpose registers for variadic floating point arguments.}\n+     *\/\n+    protected abstract boolean useIntRegsForVariadicFloatingPointArgs();\n+\n+    \/**\n+     * Should some fields of structs that assigned to registers be passed in registers when there\n+     * are not enough registers for all the fields of the struct?\n+     *\n+     * {@return true if this ABI passes some fields of a struct in registers.}\n+     *\/\n+    protected abstract boolean spillsVariadicStructsPartially();\n+\n+    \/**\n+     * @return The ABIDescriptor used by the CallArranger for the current platform.\n+     *\/\n+    protected abstract ABIDescriptor abiDescriptor();\n+\n+    protected TypeClass getArgumentClassForBindings(MemoryLayout layout, boolean forVariadicFunction) {\n+        return TypeClass.classifyLayout(layout);\n+    }\n+\n@@ -122,1 +149,1 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall, options);\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(abiDescriptor(), forUpcall, options);\n@@ -124,2 +151,4 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        boolean forVariadicFunction = options.isVariadicFunction();\n+\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, forVariadicFunction);\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, forVariadicFunction) : new BoxBindingCalculator(false);\n@@ -152,1 +181,1 @@\n-        MethodHandle handle = new DowncallLinker(C, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new DowncallLinker(abiDescriptor(), bindings.callingSequence).getBoundMethodHandle();\n@@ -168,1 +197,1 @@\n-        return UpcallLinker.make(C, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(abiDescriptor(), target, bindings.callingSequence, session);\n@@ -215,0 +244,1 @@\n+                ABIDescriptor abiDescriptor = abiDescriptor();\n@@ -216,1 +246,1 @@\n-                    (forArguments ? C.inputStorage : C.outputStorage)[type];\n+                    (forArguments ? abiDescriptor.inputStorage : abiDescriptor.outputStorage)[type];\n@@ -231,1 +261,15 @@\n-            return regAlloc(type, (int)Utils.alignUp(layout.byteSize(), 8) \/ 8);\n+            return regAlloc(type, requiredRegisters(layout));\n+        }\n+\n+        int requiredRegisters(MemoryLayout layout) {\n+            return (layout == null) ? 0 : (int)Utils.alignUp(layout.byteSize(), 8) \/ 8;\n+        }\n+\n+        VMStorage[] regAllocPartial(int type, MemoryLayout layout) {\n+            int availableRegisters = MAX_REGISTER_ARGUMENTS - nRegs[type];\n+            if (availableRegisters <= 0) {\n+                return null;\n+            }\n+\n+            int requestRegisters = Math.min(requiredRegisters(layout), availableRegisters);\n+            return regAlloc(type, requestRegisters);\n@@ -285,1 +329,4 @@\n-            long offset = 0;\n+            spillPartialStructUnbox(bindings, layout, 0);\n+        }\n+\n+        protected void spillPartialStructUnbox(Binding.Builder bindings, MemoryLayout layout, long offset) {\n@@ -337,1 +384,4 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n+        protected final boolean forArguments;\n+        protected final boolean forVariadicFunction;\n+\n+        UnboxBindingCalculator(boolean forArguments, boolean forVariadicFunction) {\n@@ -339,0 +389,2 @@\n+            this.forArguments = forArguments;\n+            this.forVariadicFunction = forVariadicFunction;\n@@ -351,1 +403,1 @@\n-            TypeClass argumentClass = TypeClass.classifyLayout(layout);\n+            TypeClass argumentClass = getArgumentClassForBindings(layout, forVariadicFunction);\n@@ -353,0 +405,4 @@\n+\n+            boolean forVariadicFunctionArgs = forArguments && forVariadicFunction;\n+            boolean useIntRegsForFloatingPointArgs = forVariadicFunctionArgs && useIntRegsForVariadicFloatingPointArgs();\n+\n@@ -356,2 +412,7 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                        StorageType.INTEGER, layout);\n+                    VMStorage[] regs;\n+\n+                    boolean spillRegistersPartially = forVariadicFunctionArgs && spillsVariadicStructsPartially();\n+                    regs = spillRegistersPartially ?\n+                        storageCalculator.regAllocPartial(StorageType.INTEGER, layout) :\n+                        storageCalculator.regAlloc(StorageType.INTEGER, layout);\n+\n@@ -361,1 +422,1 @@\n-                        while (offset < layout.byteSize()) {\n+                        while (offset < layout.byteSize() && regIndex < regs.length) {\n@@ -364,1 +425,1 @@\n-                            boolean useFloat = storage.type() == StorageType.VECTOR;\n+                            boolean useFloat = (!useIntRegsForFloatingPointArgs) && storage.type() == StorageType.VECTOR;\n@@ -373,0 +434,7 @@\n+\n+                        if (spillRegistersPartially) {\n+                            final long bytesLeft = Math.min(layout.byteSize() - offset, 8);\n+                            if (bytesLeft > 0) {\n+                                spillPartialStructUnbox(bindings, layout, offset);\n+                            }\n+                        }\n@@ -424,0 +492,1 @@\n+                    int type = useIntRegsForFloatingPointArgs ? StorageType.INTEGER : StorageType.VECTOR;\n@@ -425,1 +494,1 @@\n-                        storageCalculator.nextStorage(StorageType.VECTOR, layout);\n+                        storageCalculator.nextStorage(type, layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":86,"deletions":17,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.ABIDescriptor;\n@@ -46,0 +47,15 @@\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return C;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.ABIDescriptor;\n@@ -46,0 +47,15 @@\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return C;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n+import jdk.internal.foreign.abi.ABIDescriptor;\n+import jdk.internal.foreign.abi.VMStorage;\n+\n+import java.lang.foreign.MemoryLayout;\n+\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for Windows ABI.\n+ *\/\n+public class WindowsAArch64CallArranger extends CallArranger {\n+\n+    private static final VMStorage INDIRECT_RESULT = r8;\n+\n+    \/\/ This is derived from the AAPCS64 spec, restricted to what's\n+    \/\/ possible when calling to\/from C code.\n+    \/\/\n+    \/\/ The indirect result register, r8, is used to return a large\n+    \/\/ struct by value. It's treated as an input here as the caller is\n+    \/\/ responsible for allocating storage and passing this into the\n+    \/\/ function.\n+    \/\/\n+    \/\/ Although the AAPCS64 says r0-7 and v0-7 are all valid return\n+    \/\/ registers, it's not possible to generate a C function that uses\n+    \/\/ r2-7 and v4-7 so they are omitted here.\n+    private static final ABIDescriptor WindowsAArch64AbiDescriptor = abiFor(\n+        new VMStorage[] { r0, r1, r2, r3, r4, r5, r6, r7, INDIRECT_RESULT},\n+        new VMStorage[] { v0, v1, v2, v3, v4, v5, v6, v7 },\n+        new VMStorage[] { r0, r1 },\n+        new VMStorage[] { v0, v1, v2, v3 },\n+        new VMStorage[] { r9, r10, r11, r12, r13, r14, r15, r16, r17 },\n+        new VMStorage[] { v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n+                          v26, v27, v28, v29, v30, v31 },\n+        16,  \/\/ Stack is always 16 byte aligned on AArch64\n+        0,   \/\/ No shadow space\n+        r9,  \/\/ target addr reg\n+        r10  \/\/ return buffer addr reg\n+    );\n+\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return WindowsAArch64AbiDescriptor;\n+    }\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean requiresSubSlotStackPacking() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        \/\/ The Windows ABI requires floating point arguments to be passed in\n+        \/\/ general purpose registers when calling variadic functions.\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected TypeClass getArgumentClassForBindings(MemoryLayout layout, boolean forVariadicFunction) {\n+        TypeClass argumentClass = TypeClass.classifyLayout(layout);\n+\n+        \/\/ HFA struct arguments are classified as STRUCT_REGISTER when\n+        \/\/ general purpose registers are being used to pass floating point\n+        \/\/ arguments. If the HFA is too big to pass entirely in general\n+        \/\/ purpose registers, it is classified as an ordinary struct\n+        \/\/ (i.e. as a STRUCT_REFERENCE).\n+        if (argumentClass == TypeClass.STRUCT_HFA && forVariadicFunction) {\n+            \/\/ The Windows ABI requires the members of the variadic HFA to be\n+            \/\/ passed in general purpose registers but only a STRUCT_HFA that\n+            \/\/ is at most 16 bytes can be passed in general purpose registers.\n+            argumentClass = layout.byteSize() <= 16 ? TypeClass.STRUCT_REGISTER : TypeClass.STRUCT_REFERENCE;\n+        }\n+\n+        return argumentClass;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64CallArranger.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Microsoft. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.VaList;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * ABI implementation for Windows\/AArch64. Based on AAPCS with\n+ * changes to va_list.\n+ *\/\n+public final class WindowsAArch64Linker extends AbstractLinker {\n+    private static WindowsAArch64Linker instance;\n+\n+    public static WindowsAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new WindowsAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.WINDOWS.arrangeDowncall(inferredMethodType, function, options);\n+    }\n+\n+    @Override\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+        return  CallArranger.WINDOWS.arrangeUpcall(target, targetType, function, scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, MemorySession session) {\n+        WindowsAArch64VaList.Builder builder = WindowsAArch64VaList.builder(session);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return WindowsAArch64VaList.ofAddress(address, session);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return WindowsAArch64VaList.empty();\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n+\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n+import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n+\n+\/\/ see vadefs.h (VC header) for the ARM64 va_arg impl\n+\/\/\n+\/\/    typedef char* va_list;\n+\/\/\n+\/\/    #define __crt_va_arg(ap, t)                                                \\\n+\/\/        ((sizeof(t) > (2 * sizeof(__int64)))                                   \\\n+\/\/            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))               \\\n+\/\/            : *(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))\n+\/\/\n+public non-sealed class WindowsAArch64VaList implements VaList {\n+    private static final long VA_SLOT_SIZE_BYTES = 8;\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n+\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n+\n+    private MemorySegment segment;\n+\n+    private WindowsAArch64VaList(MemorySegment segment) {\n+        this.segment = segment;\n+    }\n+\n+    public static VaList empty() {\n+        return EMPTY;\n+    }\n+\n+    @Override\n+    public int nextVarg(ValueLayout.OfInt layout) {\n+        return (int) read(layout);\n+    }\n+\n+    @Override\n+    public long nextVarg(ValueLayout.OfLong layout) {\n+        return (long) read(layout);\n+    }\n+\n+    @Override\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n+        return (double) read(layout);\n+    }\n+\n+    @Override\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n+    }\n+\n+    @Override\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(layout, allocator);\n+    }\n+\n+    private Object read(MemoryLayout layout) {\n+        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n+    }\n+\n+    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(layout);\n+        Object res;\n+        if (layout instanceof GroupLayout) {\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            res = switch (typeClass) {\n+                case STRUCT_REFERENCE -> {\n+                    checkElement(layout, VA_SLOT_SIZE_BYTES);\n+                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(struct);\n+                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+                    yield seg;\n+                }\n+                case STRUCT_REGISTER, STRUCT_HFA -> {\n+                    long size = alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+                    checkElement(layout, size);\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n+                    segment = segment.asSlice(size);\n+                    yield struct;\n+                }\n+                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+            };\n+        } else {\n+            checkElement(layout, VA_SLOT_SIZE_BYTES);\n+            VarHandle reader = layout.varHandle();\n+            res = reader.get(segment);\n+            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+        }\n+        return res;\n+    }\n+\n+    private static long sizeOf(MemoryLayout layout) {\n+        return switch (TypeClass.classifyLayout(layout)) {\n+            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+            default -> VA_SLOT_SIZE_BYTES;\n+        };\n+    }\n+\n+    @Override\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            long size = sizeOf(layout);\n+            checkElement(layout, size);\n+            segment = segment.asSlice(size);\n+        }\n+    }\n+\n+    private void checkElement(MemoryLayout layout, long size) {\n+        if (segment.byteSize() < size) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n+    }\n+\n+    static WindowsAArch64VaList ofAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n+        return new WindowsAArch64VaList(segment);\n+    }\n+\n+    static Builder builder(MemorySession session) {\n+        return new Builder(session);\n+    }\n+\n+    @Override\n+    public VaList copy() {\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        return new WindowsAArch64VaList(segment);\n+    }\n+\n+    @Override\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n+    }\n+\n+    public static non-sealed class Builder implements VaList.Builder {\n+\n+        private final MemorySession session;\n+        private final List<SimpleVaArg> args = new ArrayList<>();\n+\n+        public Builder(MemorySession session) {\n+            MemorySessionImpl.toSessionImpl(session).checkValidState();\n+            this.session = session;\n+        }\n+\n+        private Builder arg(MemoryLayout layout, Object value) {\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n+            args.add(new SimpleVaArg(layout, value));\n+            return this;\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n+        }\n+\n+        @Override\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n+            return arg(layout, value);\n+        }\n+\n+        public VaList build() {\n+            if (args.isEmpty()) {\n+                return EMPTY;\n+            }\n+\n+            long allocationSize = args.stream().reduce(0L, (acc, e) -> acc + sizeOf(e.layout), Long::sum);\n+            MemorySegment segment = MemorySegment.allocateNative(allocationSize, session);\n+            MemorySegment cursor = segment;\n+\n+            for (SimpleVaArg arg : args) {\n+                if (arg.layout instanceof GroupLayout) {\n+                    MemorySegment msArg = ((MemorySegment) arg.value);\n+                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n+                    switch (typeClass) {\n+                        case STRUCT_REFERENCE -> {\n+                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n+                            copy.copyFrom(msArg); \/\/ by-value\n+                            VH_address.set(cursor, copy);\n+                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor = cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n+                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n+                    }\n+                } else {\n+                    VarHandle writer = arg.varHandle();\n+                    writer.set(cursor, arg.value);\n+                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n+                }\n+            }\n+\n+            return new WindowsAArch64VaList(segment);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64VaList.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -37,0 +38,2 @@\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -49,0 +53,1 @@\n+import static org.testng.Assert.*;\n@@ -67,0 +72,5 @@\n+    static final MemorySegment SUM_HFA_FLOATS_ADDR = findNativeOrThrow(\"sum_struct_hfa_floats\");\n+    static final MemorySegment SUM_HFA_DOUBLES_ADDR = findNativeOrThrow(\"sum_struct_hfa_doubles\");\n+    static final MemorySegment SUM_SPILLED_STRUCT_INTS_ADDR = findNativeOrThrow(\"sum_spilled_struct_ints\");\n+    static final MemorySegment SUM_SPILLED_HFA_FLOATS_ADDR = findNativeOrThrow(\"sum_spilled_struct_hfa_floats\");\n+    static final MemorySegment SUM_SPILLED_HFA_DOUBLES_ADDR = findNativeOrThrow(\"sum_spilled_struct_hfa_doubles\");\n@@ -109,0 +119,119 @@\n+    @DataProvider(name = \"variadicStructDescriptions\")\n+    public static Object[][] variadicStructDescriptions() {\n+        return new Object[][] {\n+            new Object[] { StructFieldType.FLOAT, 0, SUM_HFA_FLOATS_ADDR },\n+            new Object[] { StructFieldType.FLOAT, 6, SUM_SPILLED_HFA_FLOATS_ADDR },\n+            new Object[] { StructFieldType.DOUBLE, 0, SUM_HFA_DOUBLES_ADDR },\n+            new Object[] { StructFieldType.DOUBLE, 6, SUM_SPILLED_HFA_DOUBLES_ADDR },\n+            new Object[] { StructFieldType.INT, 6, SUM_SPILLED_STRUCT_INTS_ADDR },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"variadicStructDescriptions\")\n+    public void testSumVariadicHfa(StructFieldType structFieldType, int extraIntArgs, MemorySegment foreignFunctionSymbol) throws Throwable {\n+        assertTrue(structFieldType == StructFieldType.INT ||\n+            structFieldType == StructFieldType.FLOAT ||\n+            structFieldType == StructFieldType.DOUBLE);\n+\n+        int maxFields = structFieldType == StructFieldType.DOUBLE ? 2 : 4;\n+\n+        for (int num_fields = 1; num_fields <= maxFields; num_fields++) {\n+            List<StructFieldType> fields = new ArrayList<StructFieldType>();\n+            for (int i=0; i < num_fields; i++) {\n+                fields.add(structFieldType);\n+            }\n+\n+            try (Arena arena = Arena.openConfined()) {\n+                GroupLayout groupLayout = (GroupLayout)ParamType.STRUCT.layout(fields);\n+                MemorySegment structMemorySegment = MemorySegment.allocateNative(groupLayout, arena.session());\n+\n+                int expectedSumOfFieldsAsInt = 0;\n+                float expectedSumOfFieldsAsFloat = 0;\n+                double expectedSumOfFieldsAsDouble = 0;\n+\n+                int fieldId = 1;\n+                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                    if (memberLayout instanceof PaddingLayout) continue;\n+\n+                    assertTrue(memberLayout instanceof ValueLayout);\n+                    assertTrue(!isPointer(memberLayout));\n+                    if (isIntegral(memberLayout)) {\n+                        assertTrue(structFieldType == StructFieldType.INT);\n+                    }\n+\n+                    VarHandle accessor = groupLayout.varHandle(MemoryLayout.PathElement.groupElement(memberLayout.name().get()));\n+\n+                    switch (structFieldType) {\n+                        case FLOAT: {\n+                            float fieldValueAsFloat = fieldId * 42.0f;\n+                            expectedSumOfFieldsAsFloat += fieldValueAsFloat;\n+                            accessor.set(structMemorySegment, fieldValueAsFloat);\n+                            break;\n+                        }\n+                        case DOUBLE: {\n+                            double fieldValueAsDouble = fieldId * 51.75;\n+                            expectedSumOfFieldsAsDouble += fieldValueAsDouble;\n+                            accessor.set(structMemorySegment, fieldValueAsDouble);\n+                            break;\n+                        }\n+                        case INT: {\n+                            int fieldValueAsInt = fieldId * 2022;\n+                            expectedSumOfFieldsAsInt += fieldValueAsInt;\n+                            accessor.set(structMemorySegment, fieldValueAsInt);\n+                            break;\n+                        }\n+                    }\n+\n+                    fieldId++;\n+                }\n+\n+                List<MemoryLayout> argLayouts = new ArrayList<>();\n+                argLayouts.add(C_INT); \/\/ number of fields\n+                for (int i=0; i < extraIntArgs; i++) {\n+                    argLayouts.add(C_INT);\n+                }\n+\n+                MemoryLayout resLayout;\n+\n+                switch (structFieldType) {\n+                    case FLOAT: resLayout = C_FLOAT; break;\n+                    case DOUBLE: resLayout = C_DOUBLE; break;\n+                    case INT: resLayout = C_INT; break;\n+                    default: throw new UnsupportedOperationException(\"Unhandled field type \" + structFieldType);\n+                }\n+\n+                FunctionDescriptor baseDesc = FunctionDescriptor.of(resLayout, argLayouts.toArray(MemoryLayout[]::new));\n+                Linker.Option varargIndex = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+                FunctionDescriptor desc = baseDesc.appendArgumentLayouts(groupLayout);\n+\n+                MethodHandle downcallHandle = LINKER.downcallHandle(foreignFunctionSymbol, desc, varargIndex);\n+\n+                List<Object> argValues = new ArrayList<>();\n+                argValues.add(num_fields);\n+\n+                for (int i=0; i < extraIntArgs; i++) {\n+                    argValues.add(i+1);\n+                }\n+\n+                argValues.add(structMemorySegment);\n+\n+                Object result = downcallHandle.invokeWithArguments(argValues);\n+\n+                switch (structFieldType) {\n+                    case FLOAT: {\n+                        assertEquals((float)result, expectedSumOfFieldsAsFloat);\n+                        break;\n+                    }\n+                    case DOUBLE: {\n+                        assertEquals((double)result, expectedSumOfFieldsAsDouble);\n+                        break;\n+                    }\n+                    case INT: {\n+                        assertEquals((int)result, expectedSumOfFieldsAsInt);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -647,0 +647,286 @@\n+\n+    @Test\n+    public void testWindowsArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class, double.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(v1, double.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class, double.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, float.class) },\n+            { vmStore(r3, double.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsArgsInRegsAndOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, double.class, int.class, float.class,\n+                                              double.class, float.class, float.class, double.class,\n+                                              float.class, float.class, float.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_DOUBLE, C_INT, C_FLOAT,\n+                                              C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE,\n+                                              C_FLOAT, C_FLOAT, C_FLOAT, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(v1, float.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, float.class) },\n+            { vmStore(v4, float.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, float.class) },\n+            { vmStore(v7, float.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { vmStore(r1, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVarArgsInRegsAndOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, double.class, int.class, float.class,\n+                                              double.class, float.class, float.class, double.class,\n+                                              float.class, float.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_DOUBLE, C_INT, C_FLOAT,\n+                                              C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE,\n+                                              C_FLOAT, C_FLOAT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_DOUBLE, C_INT, C_FLOAT, C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE, C_FLOAT, C_FLOAT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, double.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, float.class) },\n+            { vmStore(r3, double.class) },\n+            { vmStore(r4, float.class) },\n+            { vmStore(r5, float.class) },\n+            { vmStore(r6, double.class) },\n+            { vmStore(r7, float.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { vmStore(stackStorage((short) 4, 8), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa4FloatsInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                dup(),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class),\n+                bufferLoad(12, float.class),\n+                vmStore(v3, float.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa4FloatsInIntRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(r0, long.class),\n+                bufferLoad(8, long.class),\n+                vmStore(r1, long.class),\n+            },\n+            { vmStore(r2, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa2DoublesInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, double.class),\n+                vmStore(v0, double.class),\n+                bufferLoad(8, double.class),\n+                vmStore(v1, double.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa2DoublesInIntRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(r0, long.class),\n+                bufferLoad(8, long.class),\n+                vmStore(r1, long.class),\n+            },\n+            { vmStore(r2, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa3DoublesInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, double.class),\n+                vmStore(v0, double.class),\n+                dup(),\n+                bufferLoad(8, double.class),\n+                vmStore(v1, double.class),\n+                bufferLoad(16, double.class),\n+                vmStore(v2, double.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa3DoublesAsReferenceStruct() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n+            { vmStore(r1, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -236,0 +236,178 @@\n+\n+EXPORT float sum_struct_hfa_floats(int num_floats, ...)\n+{\n+    va_list argptr;\n+    va_start(argptr, num_floats);\n+\n+    float sum = 0.0f;\n+\n+    switch (num_floats)\n+    {\n+        case 1: {\n+            struct S_F data = va_arg(argptr, struct S_F);\n+            sum = data.p0;\n+            break;\n+        }\n+        case 2: {\n+            struct S_FF data = va_arg(argptr, struct S_FF);\n+            sum = data.p0 + data.p1;\n+            break;\n+        }\n+        case 3: {\n+            struct S_FFF data = va_arg(argptr, struct S_FFF);\n+            sum = data.p0 + data.p1 + data.p2;\n+            break;\n+        }\n+        case 4: {\n+            struct S_FFFF data = va_arg(argptr, struct S_FFFF);\n+            sum = data.p0 + data.p1 + data.p2 + data.p3;\n+            break;\n+        }\n+    }\n+\n+    va_end(argptr);\n+    return sum;\n+}\n+\n+EXPORT double sum_struct_hfa_doubles(int num_doubles, ...)\n+{\n+    va_list argptr;\n+    va_start(argptr, num_doubles);\n+\n+    double sum = 0.0f;\n+\n+    switch (num_doubles)\n+    {\n+        case 1: {\n+            struct S_D data = va_arg(argptr, struct S_D);\n+            sum = data.p0;\n+            break;\n+        }\n+        case 2: {\n+            struct S_DD data = va_arg(argptr, struct S_DD);\n+            sum = data.p0 + data.p1;\n+            break;\n+        }\n+        case 3: {\n+            struct S_DDD data = va_arg(argptr, struct S_DDD);\n+            sum = data.p0 + data.p1 + data.p2;\n+            break;\n+        }\n+        case 4: {\n+            struct S_DDDD data = va_arg(argptr, struct S_DDDD);\n+            sum = data.p0 + data.p1 + data.p2 + data.p3;\n+            break;\n+        }\n+    }\n+\n+    va_end(argptr);\n+    return sum;\n+}\n+\n+EXPORT int sum_spilled_struct_ints(int num_ints,\n+    int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ...)\n+{\n+    va_list argptr;\n+    va_start(argptr, arg6);\n+\n+    int sum = 0;\n+\n+    switch (num_ints)\n+    {\n+        case 1: {\n+            struct S_I data = va_arg(argptr, struct S_I);\n+            sum += data.p0;\n+            break;\n+        }\n+        case 2: {\n+            struct S_II data = va_arg(argptr, struct S_II);\n+            sum += data.p0 + data.p1;\n+            break;\n+        }\n+        case 3: {\n+            struct S_III data = va_arg(argptr, struct S_III);\n+            sum += data.p0 + data.p1 + data.p2;\n+            break;\n+        }\n+        case 4: {\n+            struct S_IIII data = va_arg(argptr, struct S_IIII);\n+            sum += data.p0 + data.p1 + data.p2 + data.p3;\n+            break;\n+        }\n+    }\n+\n+    va_end(argptr);\n+    return sum;\n+}\n+\n+EXPORT float sum_spilled_struct_hfa_floats(int num_floats,\n+    int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ...)\n+{\n+    va_list argptr;\n+    va_start(argptr, arg6);\n+\n+    float sum = 0.0f;\n+\n+    switch (num_floats)\n+    {\n+        case 1: {\n+            struct S_F data = va_arg(argptr, struct S_F);\n+            sum = data.p0;\n+            break;\n+        }\n+        case 2: {\n+            struct S_FF data = va_arg(argptr, struct S_FF);\n+            sum = data.p0 + data.p1;\n+            break;\n+        }\n+        case 3: {\n+            struct S_FFF data = va_arg(argptr, struct S_FFF);\n+            sum = data.p0 + data.p1 + data.p2;\n+            break;\n+        }\n+        case 4: {\n+            struct S_FFFF data = va_arg(argptr, struct S_FFFF);\n+            sum = data.p0 + data.p1 + data.p2 + data.p3;\n+            break;\n+        }\n+    }\n+\n+    va_end(argptr);\n+    return sum;\n+}\n+\n+EXPORT double sum_spilled_struct_hfa_doubles(int num_doubles,\n+    int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, ...)\n+{\n+    va_list argptr;\n+    va_start(argptr, arg6);\n+\n+    double sum = 0.0f;\n+\n+    switch (num_doubles)\n+    {\n+        case 1: {\n+            struct S_D data = va_arg(argptr, struct S_D);\n+            sum = data.p0;\n+            break;\n+        }\n+        case 2: {\n+            struct S_DD data = va_arg(argptr, struct S_DD);\n+            sum = data.p0 + data.p1;\n+            break;\n+        }\n+        case 3: {\n+            struct S_DDD data = va_arg(argptr, struct S_DDD);\n+            sum = data.p0 + data.p1 + data.p2;\n+            break;\n+        }\n+        case 4: {\n+            struct S_DDDD data = va_arg(argptr, struct S_DDDD);\n+            sum = data.p0 + data.p1 + data.p2 + data.p3;\n+            break;\n+        }\n+    }\n+\n+    va_end(argptr);\n+    return sum;\n+}\n","filename":"test\/jdk\/java\/foreign\/libVarArgs.c","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+struct S_IIII { int p0; int p1; int p2; int p3; };\n+struct S_FFFF { float p0; float p1; float p2; float p3; };\n+struct S_DDDD { double p0; double p1; double p2; double p3; };\n","filename":"test\/jdk\/java\/foreign\/shared.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -136,0 +137,2 @@\n+    private static final Function<Consumer<VaList.Builder>, VaList> winAArch64VaListFactory\n+            = actions -> WindowsAArch64Linker.newVaList(actions, MemorySession.implicit());\n@@ -147,0 +150,2 @@\n+    private static final BiFunction<Consumer<VaList.Builder>, MemorySession, VaList> winAArch64VaListScopedFactory\n+            = WindowsAArch64Linker::newVaList;\n@@ -162,0 +167,1 @@\n+                { winAArch64VaListFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n@@ -190,0 +196,1 @@\n+                { winAArch64VaListFactory,   sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n@@ -220,0 +227,1 @@\n+                { winAArch64VaListFactory,   getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n@@ -275,0 +283,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_INT, sumStructJavaFact),\n@@ -328,0 +337,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n@@ -381,0 +391,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_FLOAT, sumStructJavaFact),\n@@ -443,0 +454,1 @@\n+                argsFact.apply(winAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n@@ -497,0 +509,1 @@\n+                { winAArch64VaListFactory,    sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n@@ -551,0 +564,2 @@\n+                { WindowsAArch64Linker.emptyVaList()       },\n+                { winAArch64VaListFactory.apply(b -> {})   },\n@@ -566,0 +581,1 @@\n+                { winAArch64VaListScopedFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n@@ -614,0 +630,1 @@\n+                { winAArch64VaListScopedFactory,   AArch64.C_INT },\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}