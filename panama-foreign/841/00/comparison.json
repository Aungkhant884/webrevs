{"files":[{"patch":"@@ -751,24 +751,0 @@\n-    \/**\n-     * Returns the offset, in bytes, of the provided segment, relative to this\n-     * segment.\n-     *\n-     * <p>The offset is relative to the address of this segment and can be\n-     * a negative or positive value. For instance, if both segments are native\n-     * segments, or heap segments backed by the same array, the resulting offset\n-     * can be computed as follows:\n-     *\n-     * {@snippet lang=java :\n-     * other.address() - address()\n-     * }\n-     *\n-     * If the segments share the same address, {@code 0} is returned. If\n-     * {@code other} is a slice of this segment, the offset is always\n-     * {@code 0 <= x < this.byteSize()}.\n-     *\n-     * @param other the segment to retrieve an offset to.\n-     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n-     * different kinds, or because they are backed by different Java arrays.\n-     * @return the relative offset, in bytes, of the provided segment.\n-     *\/\n-    long segmentOffset(MemorySegment other);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-                long offsetToThat = this.segmentOffset(that);\n+                long offsetToThat = that.address() - this.address();\n@@ -275,9 +275,0 @@\n-    @Override\n-    public final long segmentOffset(MemorySegment other) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n-        if (unsafeGetBase() == that.unsafeGetBase()) {\n-            return that.unsafeGetOffset() - this.unsafeGetOffset();\n-        }\n-        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import org.testng.SkipException;\n@@ -47,0 +48,3 @@\n+        if (s1.kind != s2.kind) {\n+            throw new SkipException(\"Slices of different segment kinds\");\n+        }\n@@ -49,1 +53,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -56,9 +60,0 @@\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that offset from s1 to s2 fails\n-            try {\n-                long offset = s1.segment.segmentOffset(s2.segment);\n-                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n-                fail(\"offset unexpectedly passed!\");\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n-            }\n@@ -67,1 +62,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -119,0 +114,4 @@\n+\n+        long offset(SegmentSlice that) {\n+            return that.segment.address() - segment.address();\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-            long lastOffset = segment.segmentOffset(res) + res.byteSize();\n+            long lastOffset = res.address() - segment.address() + res.byteSize();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}