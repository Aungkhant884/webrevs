{"files":[{"patch":"@@ -72,0 +72,2 @@\n+    private final long maxAlignMask;\n+\n@@ -79,1 +81,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySession session) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, long maxAlignMask, MemorySession session) {\n@@ -82,0 +84,1 @@\n+        this.maxAlignMask = maxAlignMask;\n@@ -322,1 +325,3 @@\n-    public abstract long maxAlignMask();\n+    public final long maxAlignMask() {\n+        return maxAlignMask;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly) {\n-        super(length, readOnly, MemorySession.global());\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly, long maxAlignMask) {\n+        super(length, readOnly, maxAlignMask, MemorySession.global());\n@@ -98,1 +98,1 @@\n-            super(offset, base, length, readOnly);\n+            super(offset, base, length, readOnly, MAX_ALIGN_1);\n@@ -117,5 +117,0 @@\n-        @Override\n-        public long maxAlignMask() {\n-            return MAX_ALIGN_1;\n-        }\n-\n@@ -131,1 +126,1 @@\n-            super(offset, base, length, readOnly);\n+            super(offset, base, length, readOnly, MAX_ALIGN_2);\n@@ -150,5 +145,0 @@\n-        @Override\n-        public long maxAlignMask() {\n-            return MAX_ALIGN_2;\n-        }\n-\n@@ -164,1 +154,1 @@\n-            super(offset, base, length, readOnly);\n+            super(offset, base, length, readOnly, MAX_ALIGN_2);\n@@ -183,5 +173,0 @@\n-        @Override\n-        public long maxAlignMask() {\n-            return MAX_ALIGN_2;\n-        }\n-\n@@ -197,1 +182,1 @@\n-            super(offset, base, length, readOnly);\n+            super(offset, base, length, readOnly, MAX_ALIGN_4);\n@@ -216,5 +201,0 @@\n-        @Override\n-        public long maxAlignMask() {\n-            return MAX_ALIGN_4;\n-        }\n-\n@@ -230,1 +210,1 @@\n-            super(offset, base, length, readOnly);\n+            super(offset, base, length, readOnly, MAX_ALIGN_8);\n@@ -249,5 +229,0 @@\n-        @Override\n-        public long maxAlignMask() {\n-            return MAX_ALIGN_8;\n-        }\n-\n@@ -263,1 +238,1 @@\n-            super(offset, base, length, readOnly);\n+            super(offset, base, length, readOnly, MAX_ALIGN_4);\n@@ -282,5 +257,0 @@\n-        @Override\n-        public long maxAlignMask() {\n-            return MAX_ALIGN_4;\n-        }\n-\n@@ -296,1 +266,1 @@\n-            super(offset, base, length, readOnly);\n+            super(offset, base, length, readOnly, MAX_ALIGN_8);\n@@ -315,5 +285,0 @@\n-        @Override\n-        public long maxAlignMask() {\n-            return MAX_ALIGN_8;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":9,"deletions":44,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        super(length, readOnly, session);\n+        super(length, readOnly, 0, session);\n@@ -98,5 +98,0 @@\n-    @Override\n-    public long maxAlignMask() {\n-        return 0;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.jmh.annotations.CompilerControl.Mode.DONT_INLINE;\n+import static org.openjdk.jmh.annotations.Mode.AverageTime;\n+\n+@BenchmarkMode(AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\", \"--enable-preview\"})\n+public class MixedAccessBenchmarks {\n+    private static final VectorSpecies<Byte> SPECIES_BYTE = VectorSpecies.ofLargestShape(byte.class);\n+\n+    private MemorySegment heapIn, heapOu, directIn, directOu;\n+    @Param(\"1048576\")\n+    private int size;\n+\n+    @Setup\n+    public void setup() {\n+        var session = MemorySession.openConfined();\n+        heapIn = MemorySegment.ofArray(new byte[size]);\n+        heapOu = MemorySegment.ofArray(new byte[size]);\n+\n+        directIn = MemorySegment.allocateNative(size, session);\n+        directOu = MemorySegment.allocateNative(size, session);\n+    }\n+\n+    @Benchmark\n+    public void directCopy() {\n+        copyMemorySegments1(directIn, directOu);\n+    }\n+\n+    @Benchmark\n+    public void pollutedAccessCopy() {\n+        copyMemorySegments1(heapIn, heapOu);\n+        copyMemorySegments1(directIn, directOu);\n+    }\n+\n+    @CompilerControl(DONT_INLINE)\n+    private static void copyMemorySegments1(MemorySegment in, MemorySegment out) {\n+        long sz = in.byteSize();\n+        for (long i = 0; i < SPECIES_BYTE.loopBound(sz); i += SPECIES_BYTE.vectorByteSize()) {\n+            var v1 = ByteVector.fromMemorySegment(SPECIES_BYTE, in, i, ByteOrder.nativeOrder());\n+            v1.intoMemorySegment(out, i, ByteOrder.nativeOrder());\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MixedAccessBenchmarks.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}