{"files":[{"patch":"@@ -50,0 +50,1 @@\n+  bool _needs_transition;\n@@ -63,1 +64,2 @@\n-                         int captured_state_mask)\n+                         int captured_state_mask,\n+                         bool needs_transition)\n@@ -73,0 +75,1 @@\n+     _needs_transition(needs_transition),\n@@ -102,1 +105,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n@@ -107,1 +111,2 @@\n-                          needs_return_buffer, captured_state_mask);\n+                          needs_return_buffer, captured_state_mask,\n+                          needs_transition);\n@@ -164,1 +169,1 @@\n-  bool should_save_return_value = !_needs_return_buffer;\n+  bool should_save_return_value = !_needs_return_buffer && _needs_transition;\n@@ -192,1 +197,1 @@\n-  _oop_maps  = new OopMapSet();\n+  _oop_maps  = _needs_transition ? new OopMapSet() : nullptr;\n@@ -202,4 +207,5 @@\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, rfp, the_pc, tmp1);\n-  OopMap* map = new OopMap(_frame_size_slots, 0);\n-  _oop_maps->add_gc_map(the_pc - start, map);\n+  if (_needs_transition) {\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, rfp, the_pc, tmp1);\n+    OopMap* map = new OopMap(_frame_size_slots, 0);\n+    _oop_maps->add_gc_map(the_pc - start, map);\n@@ -207,4 +213,5 @@\n-  \/\/ State transition\n-  __ mov(tmp1, _thread_in_native);\n-  __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n-  __ stlrw(tmp1, tmp2);\n+    \/\/ State transition\n+    __ mov(tmp1, _thread_in_native);\n+    __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n+    __ stlrw(tmp1, tmp2);\n+  }\n@@ -258,11 +265,0 @@\n-  __ mov(tmp1, _thread_in_native_trans);\n-  __ strw(tmp1, Address(rthread, JavaThread::thread_state_offset()));\n-\n-  \/\/ Force this write out before the read below\n-  if (!UseSystemMemoryBarrier) {\n-    __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n-              Assembler::StoreLoad | Assembler::StoreStore);\n-  }\n-\n-  __ verify_sve_vector_length(tmp1);\n-\n@@ -271,0 +267,11 @@\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  if (_needs_transition) {\n+    __ mov(tmp1, _thread_in_native_trans);\n+    __ strw(tmp1, Address(rthread, JavaThread::thread_state_offset()));\n+\n+    \/\/ Force this write out before the read below\n+    if (!UseSystemMemoryBarrier) {\n+      __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n+                Assembler::StoreLoad | Assembler::StoreStore);\n+    }\n@@ -272,1 +279,1 @@\n-  __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/, tmp1);\n+    __ verify_sve_vector_length(tmp1);\n@@ -274,2 +281,1 @@\n-  __ ldrw(tmp1, Address(rthread, JavaThread::suspend_flags_offset()));\n-  __ cbnzw(tmp1, L_safepoint_poll_slow_path);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/, tmp1);\n@@ -277,1 +283,2 @@\n-  __ bind(L_after_safepoint_poll);\n+    __ ldrw(tmp1, Address(rthread, JavaThread::suspend_flags_offset()));\n+    __ cbnzw(tmp1, L_safepoint_poll_slow_path);\n@@ -279,4 +286,1 @@\n-  \/\/ change thread state\n-  __ mov(tmp1, _thread_in_Java);\n-  __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n-  __ stlrw(tmp1, tmp2);\n+    __ bind(L_after_safepoint_poll);\n@@ -284,7 +288,10 @@\n-  __ block_comment(\"reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ ldrb(tmp1, Address(rthread, JavaThread::stack_guard_state_offset()));\n-  __ cmpw(tmp1, StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ br(Assembler::EQ, L_reguard);\n-  __ bind(L_after_reguard);\n+    \/\/ change thread state\n+    __ mov(tmp1, _thread_in_Java);\n+    __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n+    __ stlrw(tmp1, tmp2);\n+\n+    __ block_comment(\"reguard stack check\");\n+    __ ldrb(tmp1, Address(rthread, JavaThread::stack_guard_state_offset()));\n+    __ cmpw(tmp1, StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ br(Assembler::EQ, L_reguard);\n+    __ bind(L_after_reguard);\n@@ -292,1 +299,2 @@\n-  __ reset_last_Java_frame(true);\n+    __ reset_last_Java_frame(true);\n+  }\n@@ -299,2 +307,3 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n+  if (_needs_transition) {\n+    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ bind(L_safepoint_poll_slow_path);\n@@ -302,4 +311,4 @@\n-  if (should_save_return_value) {\n-    \/\/ Need to save the native result registers around any runtime calls.\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      \/\/ Need to save the native result registers around any runtime calls.\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -307,4 +316,4 @@\n-  __ mov(c_rarg0, rthread);\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-  __ lea(tmp1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ blr(tmp1);\n+    __ mov(c_rarg0, rthread);\n+    assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+    __ lea(tmp1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+    __ blr(tmp1);\n@@ -312,3 +321,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n@@ -316,2 +325,2 @@\n-  __ b(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+    __ b(L_after_safepoint_poll);\n+    __ block_comment(\"} L_safepoint_poll_slow_path\");\n@@ -321,2 +330,2 @@\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n+    __ block_comment(\"{ L_reguard\");\n+    __ bind(L_reguard);\n@@ -324,3 +333,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -328,1 +337,1 @@\n-  __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), tmp1);\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), tmp1);\n@@ -330,3 +339,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n@@ -334,1 +343,1 @@\n-  __ b(L_after_reguard);\n+    __ b(L_after_reguard);\n@@ -336,1 +345,2 @@\n-  __ block_comment(\"} L_reguard\");\n+    __ block_comment(\"} L_reguard\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":76,"deletions":66,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  bool _needs_transition;\n@@ -62,1 +63,2 @@\n-                         int captured_state_mask)\n+                         int captured_state_mask,\n+                         bool needs_transition)\n@@ -72,0 +74,1 @@\n+     _needs_transition(needs_transition),\n@@ -101,1 +104,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n@@ -106,1 +110,2 @@\n-                          needs_return_buffer, captured_state_mask);\n+                          needs_return_buffer, captured_state_mask,\n+                          needs_transition);\n@@ -162,1 +167,1 @@\n-  bool should_save_return_value = !_needs_return_buffer;\n+  bool should_save_return_value = !_needs_return_buffer && _needs_transition;\n@@ -191,1 +196,1 @@\n-  _oop_maps  = new OopMapSet();\n+  _oop_maps  = _needs_transition ? new OopMapSet() : nullptr;\n@@ -201,1 +206,6 @@\n-  address the_pc = __ pc();\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread java2native\");\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(rsp, rbp, (address)the_pc, rscratch1);\n+    OopMap* map = new OopMap(_frame_size_slots, 0);\n+    _oop_maps->add_gc_map(the_pc - start, map);\n@@ -203,8 +213,4 @@\n-  __ block_comment(\"{ thread java2native\");\n-  __ set_last_Java_frame(rsp, rbp, (address)the_pc, rscratch1);\n-  OopMap* map = new OopMap(_frame_size_slots, 0);\n-  _oop_maps->add_gc_map(the_pc - start, map);\n-\n-  \/\/ State transition\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-  __ block_comment(\"} thread java2native\");\n+    \/\/ State transition\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+    __ block_comment(\"} thread java2native\");\n+  }\n@@ -264,12 +270,0 @@\n-  __ block_comment(\"{ thread native2java\");\n-  __ restore_cpu_control_state_after_jni(rscratch1);\n-\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  \/\/ Force this write out before the read below\n-  if (!UseSystemMemoryBarrier) {\n-    __ membar(Assembler::Membar_mask_bits(\n-            Assembler::LoadLoad | Assembler::LoadStore |\n-            Assembler::StoreLoad | Assembler::StoreStore));\n-  }\n-\n@@ -278,0 +272,7 @@\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread native2java\");\n+    __ restore_cpu_control_state_after_jni(rscratch1);\n+\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n@@ -279,3 +280,6 @@\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n+    \/\/ Force this write out before the read below\n+    if (!UseSystemMemoryBarrier) {\n+      __ membar(Assembler::Membar_mask_bits(\n+              Assembler::LoadLoad | Assembler::LoadStore |\n+              Assembler::StoreLoad | Assembler::StoreStore));\n+    }\n@@ -283,1 +287,3 @@\n-  __ bind(L_after_safepoint_poll);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+    __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n+    __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n@@ -285,2 +291,1 @@\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n+    __ bind(L_after_safepoint_poll);\n@@ -288,6 +293,2 @@\n-  __ block_comment(\"reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n+    \/\/ change thread state\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n@@ -295,2 +296,8 @@\n-  __ reset_last_Java_frame(r15_thread, true);\n-  __ block_comment(\"} thread native2java\");\n+    __ block_comment(\"reguard stack check\");\n+    __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ jcc(Assembler::equal, L_reguard);\n+    __ bind(L_after_reguard);\n+\n+    __ reset_last_Java_frame(r15_thread, true);\n+    __ block_comment(\"} thread native2java\");\n+  }\n@@ -303,3 +310,4 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n+  if (_needs_transition) {\n+    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ bind(L_safepoint_poll_slow_path);\n+    __ vzeroupper();\n@@ -307,3 +315,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n@@ -311,7 +319,7 @@\n-  __ mov(c_rarg0, r15_thread);\n-  __ mov(r12, rsp); \/\/ remember sp\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-  __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ mov(rsp, r12); \/\/ restore sp\n-  __ reinit_heapbase();\n+    __ mov(c_rarg0, r15_thread);\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n@@ -319,3 +327,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n@@ -323,2 +331,2 @@\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+    __ jmp(L_after_safepoint_poll);\n+    __ block_comment(\"} L_safepoint_poll_slow_path\");\n@@ -328,7 +336,3 @@\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n-  }\n+    __ block_comment(\"{ L_reguard\");\n+    __ bind(L_reguard);\n+    __ vzeroupper();\n@@ -336,6 +340,3 @@\n-  __ mov(r12, rsp); \/\/ remember sp\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-  __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ mov(rsp, r12); \/\/ restore sp\n-  __ reinit_heapbase();\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n@@ -343,3 +344,6 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n-  }\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n@@ -347,1 +351,3 @@\n-  __ jmp(L_after_reguard);\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n@@ -349,1 +355,1 @@\n-  __ block_comment(\"} L_reguard\");\n+    __ jmp(L_after_reguard);\n@@ -351,0 +357,2 @@\n+    __ block_comment(\"} L_reguard\");\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":84,"deletions":76,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-                                         int captured_state_mask);\n+                                         int captured_state_mask,\n+                                         bool needs_transition);\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-                                      jboolean needs_return_buffer, jint captured_state_mask))\n+                                      jboolean needs_return_buffer, jint captured_state_mask,\n+                                      jboolean needs_transition))\n@@ -80,1 +81,2 @@\n-                                                    needs_return_buffer, captured_state_mask)->code_begin();\n+                                                    needs_return_buffer, captured_state_mask,\n+                                                    needs_transition)->code_begin();\n@@ -100,1 +102,1 @@\n-  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"ZI)J\", FN_PTR(NEP_makeDowncallStub)},\n+  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"ZIZ)J\", FN_PTR(NEP_makeDowncallStub)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  guarantee(thread->thread_state() == _thread_in_native, \"wrong thread state for upcall\");\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -318,0 +318,16 @@\n+        \/**\n+         * {@return A linker option used to mark a foreign function as <em>trivial<\/em>}\n+         * <p>\n+         * A trivial function is a function that has an extremely short running time\n+         * in all cases (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * <p>\n+         * Using this linker option is a hint which some implementations may use to apply\n+         * optimizations that are only valid for trivial functions.\n+         * <p>\n+         * Using this linker option when linking non trivial functions is likely to have adverse effects,\n+         * such as loss of performance, or JVM crashes.\n+         *\/\n+        static Option isTrivial() {\n+            return LinkerOptions.IsTrivial.INSTANCE;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+    public boolean needsTransition() {\n+        return !linkerOptions.isTrivial();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,2 @@\n-            callingSequence.capturedStateMask()\n+            callingSequence.capturedStateMask(),\n+            callingSequence.needsTransition()\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -89,0 +89,5 @@\n+    public boolean isTrivial() {\n+        IsTrivial it = getOption(IsTrivial.class);\n+        return it != null;\n+    }\n+\n@@ -102,2 +107,1 @@\n-                                             permits FirstVariadicArg,\n-                                                     CaptureCallStateImpl {\n+            permits CaptureCallStateImpl, FirstVariadicArg, IsTrivial {\n@@ -136,0 +140,9 @@\n+    public record IsTrivial() implements LinkerOptionImpl {\n+        public static IsTrivial INSTANCE = new IsTrivial();\n+\n+        @Override\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            \/\/ always allowed\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-                            boolean needsReturnBuffer, int capturedStateMask) {}\n+                            boolean needsReturnBuffer, int capturedStateMask,\n+                            boolean needsTransition) {}\n@@ -61,1 +62,2 @@\n-                                        int capturedStateMask) {\n+                                        int capturedStateMask,\n+                                        boolean needsTransition) {\n@@ -67,1 +69,2 @@\n-        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer, capturedStateMask);\n+        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves),\n+                                    needsReturnBuffer, capturedStateMask, needsTransition);\n@@ -69,1 +72,2 @@\n-            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer, capturedStateMask);\n+            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer,\n+                                                 capturedStateMask, needsTransition);\n@@ -90,1 +94,2 @@\n-                                                int capturedStateMask);\n+                                                int capturedStateMask,\n+                                                boolean needsTransition);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        private static void assertContains(List<String> lines, String shouldInclude) {\n+        private static void assertContains(List<String> lines, String shouldInclude, String name) {\n@@ -42,1 +42,1 @@\n-                \"Did not find '\" + shouldInclude + \"' in stderr\");\n+                \"Did not find '\" + shouldInclude + \"' in \" + name);\n@@ -46,1 +46,5 @@\n-            assertContains(stderr, shouldInclude);\n+            assertContains(stderr, shouldInclude, \"stderr\");\n+        }\n+\n+        public void assertStdOutContains(String shouldInclude) {\n+            assertContains(stdout, shouldInclude, \"stdout\");\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivial\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTrivial extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"Trivial\");\n+    }\n+\n+    @Test\n+    public void testEmpty() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.isTrivial());\n+        handle.invokeExact();\n+    }\n+\n+    @Test\n+    public void testIdentity() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.isTrivial());\n+        int result = (int) handle.invokeExact(42);\n+        assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    public void testWithReturnBuffer() throws Throwable {\n+        StructLayout bigLayout = MemoryLayout.structLayout(\n+                C_LONG_LONG.withName(\"x\"),\n+                C_LONG_LONG.withName(\"y\"));\n+\n+        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.isTrivial());\n+        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+        try (Arena arena  = Arena.openConfined()) {\n+            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n+            long x = (long) vhX.get(result);\n+            assertEquals(x, 10);\n+            long y = (long) vhY.get(result);\n+            assertEquals(y, 11);\n+        }\n+    }\n+\n+    @Test\n+    public void testCaptureErrno() throws Throwable {\n+        Linker.Option.CaptureCallState ccs = Linker.Option.captureCallState(\"errno\");\n+        MethodHandle handle = downcallHandle(\"capture_errno\", FunctionDescriptor.ofVoid(C_INT), Linker.Option.isTrivial(), ccs);\n+        VarHandle errnoHandle = ccs.layout().varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n+        try (Arena arena  = Arena.openConfined()) {\n+            MemorySegment captureSeg = arena.allocate(ccs.layout());\n+            handle.invokeExact(captureSeg, 42);\n+            int capturedErrno = (int) errnoHandle.get(captureSeg);\n+            assertEquals(capturedErrno, 42);\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivialUpcall\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestTrivialUpcall extends UpcallTestHelper {\n+\n+    @Test\n+    public void testUpcallFailure() throws IOException, InterruptedException {\n+        \/\/ test to see if we catch a trivial downcall doing an upcall\n+        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n+    }\n+\n+    public static class Runner extends NativeTestHelper {\n+        public static void main(String[] args) throws Throwable {\n+            System.loadLibrary(\"Trivial\");\n+\n+            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.isTrivial());\n+            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n+            mh.invokeExact(stub);\n+        }\n+\n+        public static void target() {\n+            fail(\"Should not get here\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivialUpcall.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void empty() {}\n+\n+EXPORT int identity(int value) {\n+    return value;\n+}\n+\n+\/\/ 128 bit struct returned in buffer on SysV\n+struct Big {\n+    long long x;\n+    long long y;\n+};\n+\n+EXPORT struct Big with_return_buffer() {\n+    struct Big b;\n+    b.x = 10;\n+    b.y = 11;\n+    return b;\n+}\n+\n+EXPORT void capture_errno(int value) {\n+    errno = value;\n+}\n+\n+EXPORT void do_upcall(void(*f)(void)) {\n+    f();\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/libTrivial.c","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}