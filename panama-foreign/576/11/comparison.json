{"files":[{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n@@ -71,0 +73,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -112,2 +115,4 @@\n-    \/\/ true, if this module allows restricted native access\n-    private volatile boolean enableNativeAccess;\n+    \/\/ true, if this module allows restricted native access; @Stable makes sure that modules that allow native\n+    \/\/ access capture this property as a constant.\n+    @Stable\n+    private boolean enableNativeAccess;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-                public Scope.Handle acquireScope(Buffer buffer, boolean async) {\n+                public Runnable acquireScope(Buffer buffer, boolean async) {\n@@ -831,1 +831,2 @@\n-                    return scope.acquire();\n+                    scope.acquire0();\n+                    return scope::release0;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    Scope.Handle acquireScope(Buffer buffer, boolean async);\n+    Runnable acquireScope(Buffer buffer, boolean async);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,4 +106,0 @@\n-       interface Handle {\n-            Scope scope();\n-        }\n-\n@@ -114,3 +110,1 @@\n-        boolean isImplicit();\n-\n-        Handle acquire();\n+        void acquire0();\n@@ -118,1 +112,1 @@\n-        void release(Handle handle);\n+        void release0();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -109,0 +110,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -468,1 +468,1 @@\n-    static Scope.Handle acquireScope(ByteBuffer bb, boolean async) {\n+    static Runnable acquireScope(ByteBuffer bb, boolean async) {\n@@ -472,1 +472,1 @@\n-    private static void releaseScope(Scope.Handle handle) {\n+    private static void releaseScope(Runnable handle) {\n@@ -476,1 +476,1 @@\n-            handle.scope().release(handle);\n+            handle.run();\n@@ -528,1 +528,1 @@\n-    static record Releaser(Scope.Handle handle) implements Runnable {\n+    static record Releaser(Runnable handle) implements Runnable {\n@@ -531,2 +531,2 @@\n-        static Runnable of(Scope.Handle handle) { return new Releaser(handle); }\n-        static Runnable ofNullable(Scope.Handle handle) {\n+        static Runnable of(Runnable handle) { return new Releaser(handle); }\n+        static Runnable ofNullable(Runnable handle) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -29,1 +32,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +33,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -37,3 +38,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -43,2 +41,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -55,1 +51,3 @@\n-    final Map<String, Constable> attributes;\n+    private final Optional<String> name;\n+    @Stable\n+    long cachedSize;\n@@ -57,1 +55,1 @@\n-    public AbstractLayout(OptionalLong size, long alignment, Map<String, Constable> attributes) {\n+    public AbstractLayout(OptionalLong size, long alignment, Optional<String> name) {\n@@ -60,1 +58,1 @@\n-        this.attributes = Collections.unmodifiableMap(attributes);\n+        this.name = name;\n@@ -66,1 +64,1 @@\n-        return withAttribute(LAYOUT_NAME, name);\n+        return dup(alignment, Optional.of(name));\n@@ -71,20 +69,1 @@\n-        return attribute(LAYOUT_NAME).map(String.class::cast);\n-    }\n-\n-    @Override\n-    public Optional<Constable> attribute(String name) {\n-        Objects.requireNonNull(name);\n-        return Optional.ofNullable(attributes.get(name));\n-    }\n-\n-    @Override\n-    public Stream<String> attributes() {\n-        return attributes.keySet().stream();\n-    }\n-\n-    @Override\n-    public AbstractLayout withAttribute(String name, Constable value) {\n-        Objects.requireNonNull(name);\n-        Map<String, Constable> newAttributes = new HashMap<>(attributes);\n-        newAttributes.put(name, value);\n-        return dup(alignment, newAttributes);\n+        return name;\n@@ -93,1 +72,1 @@\n-    abstract AbstractLayout dup(long alignment, Map<String, Constable> annos);\n+    abstract AbstractLayout dup(long alignment, Optional<String> name);\n@@ -98,1 +77,1 @@\n-        return dup(alignmentBits, attributes);\n+        return dup(alignmentBits, name);\n@@ -123,0 +102,9 @@\n+    @Override\n+    public long byteSize() {\n+        if (cachedSize == 0) {\n+            cachedSize = Utils.bitsToBytesOrThrow(bitSize(),\n+                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n+        }\n+        return cachedSize;\n+    }\n+\n@@ -148,5 +136,0 @@\n-        if (!attributes.isEmpty()) {\n-            s += attributes.entrySet().stream()\n-                                      .map(e -> e.getKey() + \"=\" + e.getValue())\n-                                      .collect(Collectors.joining(\",\", \"[\", \"]\"));\n-        }\n@@ -161,3 +144,3 @@\n-        for (var e : attributes.entrySet()) {\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withAttribute\", desc.constantType(), MH_WITH_ATTRIBUTE,\n-                    desc, e.getKey(), e.getValue().describeConstable().orElseThrow());\n+        if (name().isPresent()) {\n+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withName\", desc.constantType(), MH_WITH_NAME,\n+                    desc, name().get().describeConstable().orElseThrow());\n@@ -180,1 +163,1 @@\n-        return attributes.hashCode() << Long.hashCode(alignment);\n+        return name.hashCode() << Long.hashCode(alignment);\n@@ -193,1 +176,1 @@\n-        return Objects.equals(attributes, ((AbstractLayout) other).attributes) &&\n+        return Objects.equals(name, ((AbstractLayout) other).name) &&\n@@ -211,2 +194,0 @@\n-    static final ClassDesc CD_Constable = Constable.class.describeConstable().get();\n-\n@@ -220,3 +201,0 @@\n-    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n-                MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_long, CD_BYTEORDER));\n-\n@@ -244,2 +222,2 @@\n-    static final MethodHandleDesc MH_WITH_ATTRIBUTE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withAttribute\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String, CD_Constable));\n+    static final MethodHandleDesc MH_WITH_NAME = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withName\",\n+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":28,"deletions":50,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -30,2 +30,13 @@\n- * a memory address instance (see {@link #address()}). Examples of addressable types are {@link MemorySegment},\n- * {@link MemoryAddress} and {@link CLinker.VaList}.\n+ * a {@linkplain #address() memory address}. Examples of addressable types are {@link MemorySegment},\n+ * {@link MemoryAddress}, {@link VaList} and {@link CLinker.UpcallStub}.\n+ * <p>\n+ * An addressable instance is associated with a {@linkplain ResourceScope resource scope}; the resource scope determines the\n+ * lifecycle of the addressable instance, as well as whether the instance can be used from multiple threads. Some\n+ * addressable instances might not be associated with a lifecycle, in which case {@link #scope()} returns the\n+ * {@linkplain ResourceScope#globalScope() global scope}. Attempting to obtain a memory address\n+ * from an addressable instance whose backing scope has already been {@linkplain ResourceScope#isAlive() closed} always\n+ * results in an exception.\n+ * <p>\n+ * The {@link Addressable} type is used by the {@link CLinker C linker} to model the types of\n+ * {@link CLinker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n+ * (e.g. memory addresses, va lists and upcall stubs).\n@@ -37,0 +48,1 @@\n+\n@@ -38,2 +50,4 @@\n-     * Map this object into a {@link MemoryAddress} instance.\n-     * @return the {@link MemoryAddress} instance associated with this object.\n+     * Returns the memory address associated with this addressable.\n+     * @return The memory address associated with this addressable.\n+     * @throws IllegalStateException if the scope associated with this addressable has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -42,0 +56,6 @@\n+\n+    \/**\n+     * Obtains the resource scope associated with this addressable.\n+     * @return the resource scope associated with this addressable.\n+     *\/\n+    ResourceScope scope();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -33,4 +30,5 @@\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n-import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n-import jdk.internal.foreign.abi.x64.windows.WinVaList;\n+import jdk.internal.foreign.abi.UpcallStubs;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n@@ -40,1 +38,0 @@\n-import java.lang.constant.Constable;\n@@ -42,7 +39,1 @@\n-import java.lang.invoke.MethodType;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-import static jdk.internal.foreign.PlatformLayouts.*;\n+import java.util.Optional;\n@@ -53,7 +44,3 @@\n- * follow the JVM's target platform C ABI.\n- * <p>\n- * Linking a foreign function is a process which requires two components: a method type, and\n- * a function descriptor. The method type, consists of a set of <em>carrier<\/em> types, which, together,\n- * specify the Java signature which clients must adhere to when calling the underlying foreign function.\n- * The function descriptor contains a set of memory layouts which, together, specify the foreign function\n- * signature and classification information (via a custom layout attributes, see {@link TypeKind}), so that linking can take place.\n+ * follow the JVM's target platform C ABI. A C linker provides two main capabilities: first, it allows Java code\n+ * to <em>link<\/em> foreign functions into a so called <em>downcall method handle<\/em>; secondly, it allows\n+ * native code to call Java method handles via the generation of <em>upcall stubs<\/em>.\n@@ -61,6 +48,1 @@\n- * Clients of this API can build function descriptors using the predefined memory layout constants\n- * (based on a subset of the built-in types provided by the C language), found in this interface; alternatively,\n- * they can also decorate existing value layouts using the required {@link TypeKind} classification attribute\n- * (this can be done using the {@link MemoryLayout#withAttribute(String, Constable)} method). A failure to do so might\n- * result in linkage errors, given that linking requires additional classification information to determine, for instance,\n- * how arguments should be loaded into registers during a foreign function call.\n+ * On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n@@ -68,5 +50,4 @@\n- * Implementations of this interface support the following primitive carrier types:\n- * {@code byte}, {@code short}, {@code char}, {@code int}, {@code long}, {@code float},\n- * and {@code double}, as well as {@link MemoryAddress} for passing pointers, and\n- * {@link MemorySegment} for passing structs and unions. Finally, the {@link VaList}\n- * carrier type can be used to match the native {@code va_list} type.\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n+ * <h2><a id = \"downcall-method-handles\">Downcall method handles<\/a><\/h2>\n@@ -74,3 +55,6 @@\n- * For the linking process to be successful, some requirements must be satisfied; if {@code M} and {@code F} are\n- * the method type (obtained after dropping any prefix arguments) and the function descriptor, respectively,\n- * used during the linking process, then it must be that:\n+ * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n+ * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n+ * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target native function.\n+ * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is derived from the\n+ * argument and return layouts in the function descriptor. More specifically, given each layout {@code L} in the\n+ * function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n@@ -78,5 +62,1 @@\n- *     <li>The arity of {@code M} is the same as that of {@code F};<\/li>\n- *     <li>If the return type of {@code M} is {@code void}, then {@code F} should have no return layout\n- *     (see {@link FunctionDescriptor#ofVoid(MemoryLayout...)});<\/li>\n- *     <li>for each pair of carrier type {@code C} and layout {@code L} in {@code M} and {@code F}, respectively,\n- *     where {@code C} and {@code L} refer to the same argument, or to the return value, the following conditions must hold:\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n@@ -84,8 +64,5 @@\n- *       <li>If {@code C} is a primitve type, then {@code L} must be a {@code ValueLayout}, and the size of the layout must match\n- *       that of the carrier type (see {@link Integer#SIZE} and similar fields in other primitive wrapper classes);<\/li>\n- *       <li>If {@code C} is {@code MemoryAddress.class}, then {@code L} must be a {@code ValueLayout}, and its size must match\n- *       the platform's address size (see {@link MemoryLayouts#ADDRESS}). For this purpose, the {@link CLinker#C_POINTER} layout\n- *       constant can  be used;<\/li>\n- *       <li>If {@code C} is {@code MemorySegment.class}, then {@code L} must be a {@code GroupLayout}<\/li>\n- *     <\/ul>\n- *     <\/li>\n+ *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n@@ -93,1 +70,8 @@\n- *\n+ * <p>\n+ * Furthermore, if the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n+ * an extra parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n+ * memory region associated with the struct returned by  the downcall method handle.\n+ * <p>\n+ * Finally, downcall method handles feature a leading parameter of type {@link Addressable}, from which the\n+ * address of the target native function can be derived. The address, when known statically, can also be provided by\n+ * clients at link time.\n@@ -95,9 +79,5 @@\n- * list or with an empty formal parameter list, are not supported directly. It is not possible to create a method handle\n- * that takes a variable number of arguments, and neither is it possible to create an upcall stub wrapping a method\n- * handle that accepts a variable number of arguments. However, for downcalls only, it is possible to link a native\n- * variadic function by using a <em>specialized<\/em> method type and function descriptor: for each argument that is to be\n- * passed as a variadic argument, an explicit, additional, carrier type and memory layout must be present in the method type and\n- * function descriptor objects passed to the linker. Furthermore, as memory layouts corresponding to variadic arguments in\n- * a function descriptor must contain additional classification information, it is required that\n- * {@link #asVarArg(MemoryLayout)} is used to create the memory layouts for each parameter corresponding to a variadic\n- * argument in a specialized function descriptor.\n+ * list or with an empty formal parameter list, are not supported directly. However, it is possible to link a native\n+ * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>} function descriptor,\n+ * in which the specialized signature of a given variable arity callsite is described in full. Alternatively,\n+ * if the foreign library allows it, clients might also be able to interact with variable arity methods\n+ * using by passing a trailing parameter of type {@link VaList}.\n@@ -105,1 +85,1 @@\n- * <p>On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n+ * <h2><a id = \"upcall-stubs\">Upcall stubs<\/a><\/h2>\n@@ -107,2 +87,25 @@\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) Creating an upcall stub} requires a method\n+ * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n+ * specify the signature of the function pointer associated with the upcall stub.\n+ * <p>\n+ * The type of the provided method handle has to match the Java {@link java.lang.invoke.MethodType method type}\n+ * associated with the upcall stub, which is derived from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n+ *     <ul>\n+ *         <li>if {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n+ * Upcall stubs are modelled by instances of type {@link UpcallStub}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link UpcallStub} implements the {@link Addressable} interface) and,\n+ * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain UpcallStub#scope() scope}.\n+ *\n+ * <h2>System lookup<\/h2>\n+ *\n+ * This class implements the {@link SymbolLookup} interface; as such clients can {@linkplain #lookup(String) lookup} symbols\n+ * in the standard libraries associated with this linker. The set of symbols available for lookup is unspecified,\n+ * as it depends on the platform and on the operating system.\n@@ -113,1 +116,1 @@\n-public sealed interface CLinker permits AbstractCLinker {\n+public sealed interface CLinker extends SymbolLookup permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n@@ -129,1 +132,1 @@\n-    static CLinker getInstance() {\n+    static CLinker systemCLinker() {\n@@ -135,11 +138,3 @@\n-     * Obtains a system lookup which is suitable to find symbols in the standard C libraries. The set of symbols\n-     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * Lookup a symbol in the standard libraries associated with this linker.\n+     * The set of symbols available for lookup is unspecified, as it depends on the platform and on the operating system.\n+     * @return a linker-specific library lookup which is suitable to find symbols in the standard libraries associated with this linker.\n@@ -147,4 +142,3 @@\n-    @CallerSensitive\n-    static SymbolLookup systemLookup() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return SystemLookup.getInstance();\n+    @Override\n+    default Optional<MemoryAddress> lookup(String name) {\n+        return SystemLookup.getInstance().lookup(name);\n@@ -160,0 +154,5 @@\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+<blockquote><pre>{@code\n+    linker.downcallHandle(function).bindTo(symbol);\n+}<\/pre><\/blockquote>\n@@ -162,1 +161,0 @@\n-     * @param type     the method type.\n@@ -164,3 +162,3 @@\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n-     *                                  is {@link MemoryAddress#NULL}\n+     * @return the downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout,\n+     * or if the symbol is {@link MemoryAddress#NULL}\n@@ -170,20 +168,4 @@\n-    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n-\n-    \/**\n-     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n-     * which can be used to call a target foreign function at the given address.\n-     * <p>\n-     * If the provided method type's return type is {@code MemorySegment}, then the provided allocator will be used by\n-     * the linker runtime to allocate structs returned by-value.\n-     *\n-     * @param symbol    downcall symbol.\n-     * @param allocator the segment allocator.\n-     * @param type      the method type.\n-     * @param function  the function descriptor.\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n-     *                                  is {@link MemoryAddress#NULL}\n-     *\n-     * @see SymbolLookup\n-     *\/\n-    MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function);\n+    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n+        SharedUtils.checkSymbol(symbol);\n+        return downcallHandle(function).bindTo(symbol);\n+    }\n@@ -197,1 +179,1 @@\n-     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features an\n+     * If the provided function descriptor's return layout is a {@link GroupLayout}, then the resulting method handle features an\n@@ -204,1 +186,0 @@\n-     * @param type     the method type.\n@@ -206,2 +187,3 @@\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     * @return the downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * from the provided function descriptor.\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout.\n@@ -211,1 +193,1 @@\n-    MethodHandle downcallHandle(MethodType type, FunctionDescriptor function);\n+    MethodHandle downcallHandle(FunctionDescriptor function);\n@@ -218,1 +200,1 @@\n-     * The returned memory address is associated with the provided scope. When such scope is closed,\n+     * The returned function pointer is associated with the provided scope. When such scope is closed,\n@@ -231,88 +213,3 @@\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch, or\n-     *         if it is determined that the target method handle can throw an exception.\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n-     *\/\n-    MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n-\n-    \/**\n-     * The layout for the {@code bool} C type\n-     *\/\n-    ValueLayout C_BOOL = pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);\n-    \/**\n-     * The layout for the {@code char} C type\n-     *\/\n-    ValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n-    \/**\n-     * The layout for the {@code short} C type\n-     *\/\n-    ValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n-    \/**\n-     * The layout for the {@code int} C type\n-     *\/\n-    ValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n-    \/**\n-     * The layout for the {@code long} C type\n-     *\/\n-    ValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n-    \/**\n-     * The layout for the {@code long long} C type.\n-     *\/\n-    ValueLayout C_LONG_LONG = pick(SysV.C_LONG_LONG, Win64.C_LONG_LONG, AArch64.C_LONG_LONG);\n-    \/**\n-     * The layout for the {@code float} C type\n-     *\/\n-    ValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n-    \/**\n-     * The layout for the {@code double} C type\n-     *\/\n-    ValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n-    \/**\n-     * The {@code T*} native type.\n-     *\/\n-    ValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n-\n-    \/**\n-     * Returns a memory layout that is suitable to use as the layout for variadic arguments in a specialized\n-     * function descriptor.\n-     * @param <T> the memory layout type\n-     * @param layout the layout the adapt\n-     * @return a potentially newly created layout with the right attributes\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    static <T extends MemoryLayout> T asVarArg(T layout) {\n-        Objects.requireNonNull(layout);\n-        return (T) PlatformLayouts.asVarArg(layout);\n-    }\n-\n-    \/**\n-     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n-     * storing the result into a native memory segment allocated using the provided allocator.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param allocator the allocator to be used for the native segment allocation.\n-     * @return a new native memory segment containing the converted C string.\n-     *\/\n-    static MemorySegment toCString(String str, SegmentAllocator allocator) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(allocator);\n-        return toCString(str.getBytes(StandardCharsets.UTF_8), allocator);\n-    }\n-\n-    \/**\n-     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n-     * storing the result into a native memory segment associated with the provided resource scope.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param scope the resource scope to be associated with the returned segment.\n-     * @return a new native memory segment containing the converted C string.\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout,\n+     * or if it is determined that the target method handle can throw an exception, or if the target method handle\n+     * has a type that does not match the upcall stub <a href=\"CLinker.html#upcall-stubs\"><em>inferred type<\/em><\/a>.\n@@ -322,3 +219,1 @@\n-    static MemorySegment toCString(String str, ResourceScope scope) {\n-        return toCString(str, SegmentAllocator.ofScope(scope));\n-    }\n+    UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n@@ -327,71 +222,5 @@\n-     * Converts a UTF-8 encoded, null-terminated C string stored at given address into a Java string.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform,\n-     * or if {@code addr == MemoryAddress.NULL}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static String toJavaString(MemoryAddress addr) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        SharedUtils.checkAddress(addr);\n-        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue());\n-    }\n-\n-    \/**\n-     * Converts a UTF-8 encoded, null-terminated C string stored at given address into a Java string.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n-     * @throws IllegalStateException if the size of the native string is greater than the size of the segment\n-     * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive<\/em>.\n-     *\/\n-    static String toJavaString(MemorySegment addr) {\n-        Objects.requireNonNull(addr);\n-        return SharedUtils.toJavaStringInternal(addr, 0L);\n-    }\n-\n-    private static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n-    }\n-\n-    private static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocates memory of given size using malloc.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param size memory size to be allocated\n-     * @return addr memory address of the allocated memory\n-     * @throws OutOfMemoryError if malloc could not allocate the required amount of native memory.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * An upcall stub is a pointer to a stub of code which can be passed to native functions to call a given <em>target<\/em> Java method handle.\n+     * Created by {@link #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}, an upcall stub can be passed by\n+     * reference to other downcall method handles, as this interface extends {@link Addressable}.\n+     * When no longer required, resources associated with an upcall stub can be {@link ResourceScope#close() released},\n+     * via its {@linkplain UpcallStub#scope() scope}.\n@@ -399,376 +228,1 @@\n-    @CallerSensitive\n-    static MemoryAddress allocateMemory(long size) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        MemoryAddress addr = SharedUtils.allocateMemoryInternal(size);\n-        if (addr.equals(MemoryAddress.NULL)) {\n-            throw new OutOfMemoryError();\n-        } else {\n-            return addr;\n-        }\n-    }\n-\n-    \/**\n-     * Frees the memory pointed by the given memory address.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr memory address of the native memory to be freed\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * @throws IllegalArgumentException if {@code addr == MemoryAddress.NULL}.\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static void freeMemory(MemoryAddress addr) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        SharedUtils.checkAddress(addr);\n-        SharedUtils.freeMemoryInternal(addr);\n-    }\n-\n-    \/**\n-     * An interface that models a C {@code va_list}.\n-     * <p>\n-     * A va list is a stateful cursor used to iterate over a set of variadic arguments. A va list can be passed\n-     * {@linkplain #address() by reference} e.g. to a downcall method handle.\n-     * <p>\n-     * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n-     * arguments to variadic calls are erased by way of 'default argument promotions',\n-     * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n-     * and which erases all {@code float} arguments to {@code double}.\n-     * <p>\n-     * As such, this interface only supports reading {@code int}, {@code double},\n-     * and any other type that fits into a {@code long}.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n-     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n-     *\/\n-    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n-\n-        \/**\n-         * Reads the next value as an {@code int} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code int}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-         *\/\n-        int vargAsInt(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code long} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code long}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-         *\/\n-        long vargAsLong(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code double} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code double}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-         *\/\n-        double vargAsDouble(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemoryAddress} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code MemoryAddress}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-         *\/\n-        MemoryAddress vargAsAddress(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n-         *\n-         * @param layout the layout of the value\n-         * @param allocator the allocator to be used for the native segment allocation\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be associated with the given {@link ResourceScope}.\n-         *\n-         * @param layout the layout of the value\n-         * @param scope the resource scope to be associated with the returned segment\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope);\n-\n-        \/**\n-         * Skips a number of elements with the given memory layouts, and advances this va list's position.\n-         *\n-         * @param layouts the layout of the value\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         *\/\n-        void skip(MemoryLayout... layouts);\n-\n-        \/**\n-         * Returns the resource scope associated with this instance.\n-         * @return the resource scope associated with this instance.\n-         *\/\n-        ResourceScope scope();\n-\n-        \/**\n-         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-         * starting from the current position, without affecting the state of the original va list, essentially\n-         * allowing the elements to be traversed multiple times.\n-         * <p>\n-         * Any native resource required by the execution of this method will be allocated in the resource scope\n-         * associated with this instance (see {@link #scope()}).\n-         * <p>\n-         * This method only copies the va list cursor itself and not the memory that may be attached to the\n-         * va list which holds its elements. That means that if this va list was created with the\n-         * {@link #make(Consumer, ResourceScope)} method, closing this va list will also release the native memory that holds its\n-         * elements, making the copy unusable.\n-         *\n-         * @return a copy of this C {@code va_list}.\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         *\/\n-        VaList copy();\n-\n-        \/**\n-         * Returns the memory address of the C {@code va_list} associated with this instance.\n-         * The returned memory address is associated with same resource scope as that associated with this instance.\n-         *\n-         * @return the memory address of the C {@code va_list} associated with this instance.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-\n-        \/**\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param address a memory address pointing to an existing C {@code va_list}.\n-         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-         *\/\n-        @CallerSensitive\n-        static VaList ofAddress(MemoryAddress address) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-            return SharedUtils.newVaListOfAddress(address, ResourceScope.globalScope());\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n-         * with given resource scope.\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param address a memory address pointing to an existing C {@code va_list}.\n-         * @param scope the resource scope to be associated with the returned {@code VaList} instance.\n-         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-         *\/\n-        @CallerSensitive\n-        static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-            Objects.requireNonNull(address);\n-            Objects.requireNonNull(scope);\n-            return SharedUtils.newVaListOfAddress(address, scope);\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a given\n-         * {@linkplain ResourceScope resource scope}.\n-         * <p>\n-         * If this method needs to allocate native memory, such memory will be managed by the given\n-         * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n-         * <p>\n-         * Note that when there are no elements added to the created va list,\n-         * this method will return the same as {@link #empty()}.\n-         *\n-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-         *                of the underlying C {@code va_list}.\n-         * @param scope the scope to be used for the valist allocation.\n-         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         *\/\n-        static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n-            Objects.requireNonNull(actions);\n-            Objects.requireNonNull(scope);\n-            return SharedUtils.newVaList(actions, scope);\n-        }\n-\n-        \/**\n-         * Returns an empty C {@code va_list} constant.\n-         * <p>\n-         * The returned {@code VaList} can not be closed.\n-         *\n-         * @return a {@code VaList} modelling an empty C {@code va_list}.\n-         *\/\n-        static VaList empty() {\n-            return SharedUtils.emptyVaList();\n-        }\n-\n-        \/**\n-         * A builder interface used to construct a C {@code va_list}.\n-         *\n-         * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n-         * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n-         *\/\n-        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n-\n-            \/**\n-             * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as an {@code int}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-             *\/\n-            Builder vargFromInt(ValueLayout layout, int value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code long}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-             *\/\n-            Builder vargFromLong(ValueLayout layout, long value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code double}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-             *\/\n-            Builder vargFromDouble(ValueLayout layout, double value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code Addressable}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-             *\/\n-            Builder vargFromAddress(ValueLayout layout, Addressable value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code MemorySegment}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-             *\/\n-            Builder vargFromSegment(GroupLayout layout, MemorySegment value);\n-        }\n-    }\n-\n-    \/**\n-     * A C type kind. Each kind corresponds to a particular C language builtin type, and can be attached to\n-     * {@link ValueLayout} instances using the {@link MemoryLayout#withAttribute(String, Constable)} in order\n-     * to obtain a layout which can be classified accordingly by {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}\n-     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}.\n-     *\/\n-    enum TypeKind {\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code bool} type\n-         *\/\n-        BOOL(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code char} type\n-         *\/\n-        CHAR(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code short} type\n-         *\/\n-        SHORT(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code int} type\n-         *\/\n-        INT(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code long} type\n-         *\/\n-        LONG(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code long long} type\n-         *\/\n-        LONG_LONG(true),\n-        \/**\n-         * A kind corresponding to the <em>floating-point<\/em> C {@code float} type\n-         *\/\n-        FLOAT(false),\n-        \/**\n-         * A kind corresponding to the <em>floating-point<\/em> C {@code double} type\n-         *\/\n-        DOUBLE(false),\n-        \/**\n-         * A kind corresponding to the an <em>integral<\/em> C pointer type\n-         *\/\n-        POINTER(false);\n-\n-        private final boolean isIntegral;\n-\n-        TypeKind(boolean isIntegral) {\n-            this.isIntegral = isIntegral;\n-        }\n-\n-        \/**\n-         * Is this kind integral?\n-         *\n-         * @return true if this kind is integral\n-         *\/\n-        public boolean isIntegral() {\n-            return isIntegral;\n-        }\n-\n-        \/**\n-         * Is this kind a floating point type?\n-         *\n-         * @return true if this kind is a floating point type\n-         *\/\n-        public boolean isFloat() {\n-            return !isIntegral() && !isPointer();\n-        }\n-\n+    sealed interface UpcallStub extends Addressable permits UpcallStubs.UpcallStubImpl {\n@@ -776,3 +230,2 @@\n-         * Is this kind a pointer kind?\n-         *\n-         * @return true if this kind is a pointer kind\n+         * Obtains the function descriptor with which this upcall stub was {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) created}.\n+         * @return the function descriptor with which this upcall stub was {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) created}.\n@@ -780,3 +233,1 @@\n-        public boolean isPointer() {\n-            return this == POINTER;\n-        }\n+        FunctionDescriptor descriptor();\n@@ -785,6 +236,2 @@\n-         * The layout attribute name associated with this classification kind. Clients can retrieve the type kind\n-         * of a layout using the following code:\n-         * <blockquote><pre>{@code\n-        ValueLayout layout = ...\n-        TypeKind = layout.attribute(TypeKind.ATTR_NAME).orElse(null);\n-         * }<\/pre><\/blockquote>\n+         * Obtains the target Java method handle invoked by this upcall stub.\n+         * @return the target Java method handle invoked by this upcall stub.\n@@ -792,1 +239,1 @@\n-        public static final String ATTR_NAME = \"abi\/kind\";\n+        MethodHandle target();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":107,"deletions":660,"binary":false,"changes":767,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n@@ -36,1 +34,0 @@\n-import java.util.Map;\n@@ -49,7 +46,1 @@\n-public final class FunctionDescriptor implements Constable {\n-\n-    \/**\n-     * The name of the function descriptor attribute (see {@link #attributes()} used to mark trivial functions. The\n-     * attribute value must be a boolean.\n-     *\/\n-    public static final String TRIVIAL_ATTRIBUTE_NAME = \"abi\/trivial\";\n+public sealed class FunctionDescriptor implements Constable permits FunctionDescriptor.VariadicFunction {\n@@ -59,1 +50,0 @@\n-    private final Map<String, Constable> attributes;\n@@ -61,1 +51,1 @@\n-    private FunctionDescriptor(MemoryLayout resLayout, Map<String, Constable> attributes, MemoryLayout... argLayouts) {\n+    private FunctionDescriptor(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n@@ -63,1 +53,0 @@\n-        this.attributes = attributes;\n@@ -67,36 +56,0 @@\n-    \/**\n-     * Returns the attribute with the given name (if it exists).\n-     *\n-     * @param name the attribute name.\n-     * @return the attribute with the given name (if it exists).\n-     *\/\n-    public Optional<Constable> attribute(String name) {\n-        Objects.requireNonNull(name);\n-        return Optional.ofNullable(attributes.get(name));\n-    }\n-\n-    \/**\n-     * Returns a stream of the attribute names associated with this function descriptor.\n-     *\n-     * @return a stream of the attribute names associated with this function descriptor.\n-     *\/\n-    public Stream<String> attributes() {\n-        return attributes.keySet().stream();\n-    }\n-\n-    \/**\n-     * Returns a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.\n-     * If this descriptor already contains an attribute with the same name, the existing attribute value is overwritten in the returned\n-     * descriptor.\n-     *\n-     * @param name the attribute name.\n-     * @param value the attribute value.\n-     * @return a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.\n-     *\/\n-    public FunctionDescriptor withAttribute(String name, Constable value) {\n-        Objects.requireNonNull(name);\n-        Map<String, Constable> newAttributes = new HashMap<>(attributes);\n-        newAttributes.put(name, value);\n-        return new FunctionDescriptor(resLayout, newAttributes, argLayouts);\n-    }\n-\n@@ -129,1 +82,1 @@\n-        return new FunctionDescriptor(resLayout, Map.of(), argLayouts);\n+        return new FunctionDescriptor(resLayout, argLayouts);\n@@ -140,1 +93,25 @@\n-        return new FunctionDescriptor(null, Map.of(), argLayouts);\n+        return new FunctionDescriptor(null, argLayouts);\n+    }\n+\n+    \/**\n+     * Obtain a specialized variadic function descriptor, by appending given variadic layouts to this\n+     * function descriptor argument layouts. The resulting function descriptor can report the position\n+     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n+     * in any way: for instance, calling {@link #withReturnLayout(MemoryLayout)} on the resulting descriptor\n+     * will throw an {@link UnsupportedOperationException}.\n+     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n+     * @return a new variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n+     *\/\n+    public FunctionDescriptor asVariadic(MemoryLayout... variadicLayouts) {\n+        Objects.requireNonNull(variadicLayouts);\n+        Arrays.stream(variadicLayouts).forEach(Objects::requireNonNull);\n+        return variadicLayouts.length == 0 ? this : new VariadicFunction(this, variadicLayouts);\n+    }\n+\n+    \/**\n+     * The index of the first variadic argument layout (where defined).\n+     * @return The index of the first variadic argument layout, or {@code -1} if this is not a\n+     * {@linkplain #asVariadic(MemoryLayout...) variadic} layout.\n+     *\/\n+    public int firstVariadicArgumentIndex() {\n+        return -1;\n@@ -154,1 +131,1 @@\n-        return new FunctionDescriptor(resLayout, attributes, newLayouts);\n+        return new FunctionDescriptor(resLayout, newLayouts);\n@@ -164,1 +141,1 @@\n-        return new FunctionDescriptor(newReturn, attributes, argLayouts);\n+        return new FunctionDescriptor(newReturn, argLayouts);\n@@ -172,1 +149,1 @@\n-        return new FunctionDescriptor(null, attributes, argLayouts);\n+        return new FunctionDescriptor(null, argLayouts);\n@@ -190,1 +167,1 @@\n-     * object is also a function descriptor, and all of the following conditions are met:\n+     * object is also a function descriptor, and all the following conditions are met:\n@@ -204,1 +181,1 @@\n-        if (!(other instanceof FunctionDescriptor)) {\n+        if (!(other instanceof FunctionDescriptor f)) {\n@@ -207,1 +184,0 @@\n-        FunctionDescriptor f = (FunctionDescriptor) other;\n@@ -234,0 +210,39 @@\n+\n+    static final class VariadicFunction extends FunctionDescriptor {\n+\n+        private final int firstVariadicIndex;\n+\n+        public VariadicFunction(FunctionDescriptor descriptor, MemoryLayout... argLayouts) {\n+            super(descriptor.returnLayout().orElse(null),\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toArray(MemoryLayout[]::new));\n+            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n+        }\n+\n+        public boolean isVariadicIndex(int pos) {\n+            return pos >= firstVariadicIndex;\n+        }\n+\n+        public int firstVariadicArgumentIndex() {\n+            return firstVariadicIndex;\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withAppendedArgumentLayouts(MemoryLayout... addedLayouts) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withReturnLayout(MemoryLayout newReturn) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withVoidReturnLayout() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Optional<DynamicConstantDesc<FunctionDescriptor>> describeConstable() {\n+            return Optional.empty();\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":72,"deletions":57,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -35,1 +34,0 @@\n-import java.util.Map;\n@@ -43,1 +41,1 @@\n- * A group layout is used to combine together multiple <em>member layouts<\/em>. There are two ways in which member layouts\n+ * A group layout is used to combine multiple <em>member layouts<\/em>. There are two ways in which member layouts\n@@ -108,1 +106,1 @@\n-        this(kind, elements, kind.alignof(elements), Map.of());\n+        this(kind, elements, kind.alignof(elements), Optional.empty());\n@@ -111,2 +109,2 @@\n-    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Map<String, Constable> attributes) {\n-        super(kind.sizeof(elements), alignment, attributes);\n+    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Optional<String> name) {\n+        super(kind.sizeof(elements), alignment, name);\n@@ -163,1 +161,1 @@\n-        if (!(other instanceof GroupLayout)) {\n+        if (!(other instanceof GroupLayout g)) {\n@@ -166,1 +164,0 @@\n-        GroupLayout g = (GroupLayout)other;\n@@ -176,2 +173,2 @@\n-    GroupLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new GroupLayout(kind, elements, alignment, attributes);\n+    GroupLayout dup(long alignment, Optional<String> name) {\n+        return new GroupLayout(kind, elements, alignment, name);\n@@ -215,8 +212,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public GroupLayout withAttribute(String name, Constable value) {\n-        return (GroupLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,1518 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-\n-\/**\n- * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.\n- * <p>\n- * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long, ByteOrder)}) take a segment, an offset\n- * (expressed in bytes) and a byte order. The final address at which the dereference will occur will be computed by offsetting\n- * the base address by the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n- * <p>\n- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment, ByteOrder)}) so that\n- * clients can omit the offset coordinate.\n- * <p>\n- * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long, ByteOrder)}),\n- * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n- * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n- * be dereferenced.\n- * <p>\n- * In cases where native byte order is preferred, overloads are provided (see {@link #getIntAtOffset(MemorySegment, long)})\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException} to be thrown. Moreover,\n- * attempting to dereference a segment whose {@linkplain MemorySegment#scope() scope} has already been closed,\n- * or from a thread other than the thread owning the scope causes an {@link IllegalStateException} to be thrown.\n- * Finally, attempting to dereference a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n- * {@linkplain MemorySegment#byteSize() size} {@code S}) at addresses that are {@code < B}, or {@code >= B + S},\n- * causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n- *\/\n-public final class MemoryAccess {\n-\n-    private MemoryAccess() {\n-        \/\/ just the one\n-    }\n-\n-    private static final VarHandle byte_handle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n-    private static final VarHandle bool_handle = MemoryHandles.varHandle(boolean.class, ByteOrder.nativeOrder());\n-    private static final VarHandle char_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, char.class);\n-    private static final VarHandle short_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, short.class);\n-    private static final VarHandle int_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, int.class);\n-    private static final VarHandle float_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, float.class);\n-    private static final VarHandle long_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, long.class);\n-    private static final VarHandle double_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, double.class);\n-    private static final VarHandle char_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, char.class);\n-    private static final VarHandle short_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, short.class);\n-    private static final VarHandle int_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, int.class);\n-    private static final VarHandle float_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, float.class);\n-    private static final VarHandle long_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, long.class);\n-    private static final VarHandle double_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, double.class);\n-    private static final VarHandle address_handle;\n-\n-    static {\n-        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n-            case 4 -> int.class;\n-            case 8 -> long.class;\n-            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n-        };\n-        address_handle = MemoryHandles.asAddressVarHandle(unalignedHandle(MemoryLayouts.ADDRESS, carrier));\n-    }\n-\n-    private static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n-        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());\n-    }\n-\n-    \/\/ Note: all the accessor methods defined below take advantage of argument type profiling\n-    \/\/ (see src\/hotspot\/share\/oops\/methodData.cpp) which greatly enhances performance when the same accessor\n-    \/\/ method is used repeatedly with different segment kinds (e.g. on-heap vs. off-heap).\n-\n-    \/**\n-     * Reads a byte from given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n-        Objects.requireNonNull(segment);\n-        return (byte)byte_handle.get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n-        Objects.requireNonNull(segment);\n-        byte_handle.set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a boolean from given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a boolean value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static boolean getBooleanAtOffset(MemorySegment segment, long offset) {\n-        Objects.requireNonNull(segment);\n-        return (boolean)bool_handle.get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a boolean at given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the boolean value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setBooleanAtOffset(MemorySegment segment, long offset, boolean value) {\n-        Objects.requireNonNull(segment);\n-        bool_handle.set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtOffset(MemorySegment segment, long offset) {\n-        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n-        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtOffset(MemorySegment segment, long offset) {\n-        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n-        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtOffset(MemorySegment segment, long offset) {\n-        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n-        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n-        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n-        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtOffset(MemorySegment segment, long offset) {\n-        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n-        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n-        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n-        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a memory address read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n-        Objects.requireNonNull(segment);\n-        return (MemoryAddress)address_handle.get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    handle.set(segment, offset, value.address());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(value);\n-        address_handle.set(segment, offset, value.address());\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n-    char value = (char)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (char)((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n-    short value = (short)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (short)((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n-    int value = (int)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (int)((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n-    float value = (float)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (float)((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n-    long value = (long)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (long)((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n-    double value = (double)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (double)((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a byte from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    byte value = getByteAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByte(MemorySegment segment) {\n-        return getByteAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByte(MemorySegment segment, byte value) {\n-        setByteAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a boolean from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    boolean value = getBooleanAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a boolean value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static boolean getBoolean(MemorySegment segment) {\n-        return getBooleanAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a boolean at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setBooleanAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the boolean value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setBoolean(MemorySegment segment, boolean value) {\n-        setBooleanAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment) {\n-        return getCharAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, char value) {\n-        setCharAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment) {\n-        return getShortAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, short value) {\n-        setShortAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment) {\n-        return getIntAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, int value) {\n-        setIntAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment) {\n-        return getFloatAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, float value) {\n-        setFloatAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment) {\n-        return getLongAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, long value) {\n-        setLongAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment) {\n-        return getDoubleAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, double value) {\n-        setDoubleAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemoryAddress value = getAddressAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a memory address read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddress(MemorySegment segment) {\n-        return getAddressAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddress(MemorySegment segment, Addressable value) {\n-        setAddressAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment, ByteOrder order) {\n-        return getCharAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, ByteOrder order, char value) {\n-        setCharAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment, ByteOrder order) {\n-        return getShortAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, ByteOrder order, short value) {\n-        setShortAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment, ByteOrder order) {\n-        return getIntAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, ByteOrder order, int value) {\n-        setIntAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment, ByteOrder order) {\n-        return getFloatAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment, ByteOrder order) {\n-        return getLongAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, ByteOrder order, long value) {\n-        setLongAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment, ByteOrder order) {\n-        return getDoubleAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index) {\n-        return getCharAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index) {\n-        return getShortAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index) {\n-        return getIntAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index) {\n-        return getLongAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getCharAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, ByteOrder order, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getShortAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, ByteOrder order, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getIntAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, ByteOrder order, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getLongAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, ByteOrder order, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    @ForceInline\n-    private static long scale(MemorySegment address, long index, int size) {\n-        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":0,"deletions":1518,"binary":false,"changes":1518,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -33,1 +32,1 @@\n-import java.lang.ref.Cleaner;\n+import java.nio.ByteOrder;\n@@ -36,14 +35,29 @@\n- * A memory address models a reference into a memory location. Memory addresses are typically obtained using the\n- * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory. Off-heap memory\n- * addresses are referred to as <em>native<\/em> memory addresses (see {@link #isNative()}). Native memory addresses\n- * allow clients to obtain a raw memory address (expressed as a long value) which can then be used e.g. when interacting\n- * with native code.\n- * <p>\n- * Given an address, it is possible to compute its offset relative to a given segment, which can be useful\n- * when performing memory dereference operations using a memory access var handle (see {@link MemoryHandles}).\n- * <p>\n- * A memory address is associated with a {@linkplain ResourceScope resource scope}; the resource scope determines the\n- * lifecycle of the memory address, and whether the address can be used from multiple threads. Memory addresses\n- * obtained from {@linkplain #ofLong(long) numeric values}, or from native code, are associated with the\n- * {@linkplain ResourceScope#globalScope() global resource scope}. Memory addresses obtained from segments\n- * are associated with the same scope as the segment from which they have been obtained.\n+ * A memory address models a reference into a memory location. Memory addresses are typically obtained in three ways:\n+ * <ul>\n+ *     <li>By calling {@link Addressable#address()} on an instance of type {@link Addressable} (e.g. a memory segment);<\/li>\n+ *     <li>By invoking a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle} which returns a pointer;<\/li>\n+ *     <li>By reading an address from memory, e.g. via {@link MemorySegment#get(ValueLayout.OfAddress, long)}.<\/li>\n+ * <\/ul>\n+ * A memory address is backed by a raw machine pointer, expressed as a {@linkplain #toRawLongValue() long value}.\n+ *\n+ * <h2>Dereference<\/h2>\n+ *\n+ * A memory address can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * <blockquote><pre>{@code\n+MemoryAddress address = ...\n+int value = address.get(ValueLayout.JAVA_INT, 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * can be expressed as follows:\n+ * <blockquote><pre>{@code\n+MemoryAddress address = ...\n+int value = address.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * All the dereference methods in this class are <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>: since\n+ * a memory address does not feature temporal nor spatial bounds, the runtime has no way to check the correctness\n+ * of the memory dereference operation.\n@@ -66,4 +80,5 @@\n-    @Override\n-    default MemoryAddress address() {\n-        return this;\n-    }\n+    \/**\n+     * Returns the raw long value associated with this memory address.\n+     * @return The raw long value associated with this memory address.\n+     *\/\n+    long toRawLongValue();\n@@ -79,2 +94,19 @@\n-     * Returns the resource scope associated with this memory address.\n-     * @return the resource scope associated with this memory address.\n+     * Reads a UTF-8 encoded, null-terminated string from this address and offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a Java UTF-8 string containing all the bytes read from the given starting address ({@code toRowLongValue() + offset})\n+     * up to (but not including) the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -82,1 +114,2 @@\n-    ResourceScope scope();\n+    @CallerSensitive\n+    String getUtf8String(long offset);\n@@ -85,6 +118,1 @@\n-     * Returns the offset of this memory address into the given segment. More specifically, if both the segment's\n-     * base address and this address are native addresses, the result is computed as\n-     * {@code this.toRawLongValue() - segment.address().toRawLongValue()}. Otherwise, if both addresses in the form\n-     * {@code (B, O1)}, {@code (B, O2)}, where {@code B} is the same base heap object and {@code O1}, {@code O2}\n-     * are byte offsets (relative to the base object) associated with this address and the segment's base address,\n-     * the result is computed as {@code O1 - O2}.\n+     * Writes a UTF-8 encoded, null-terminated string to this address at given offset.\n@@ -92,9 +120,39 @@\n-     * If the segment's base address and this address are both heap addresses, but with different base objects, the result is undefined\n-     * and an exception is thrown. Similarly, if the segment's base address is an heap address (resp. off-heap) and\n-     * this address is an off-heap (resp. heap) address, the result is undefined and an exception is thrown.\n-     * Otherwise, the result is a byte offset {@code SO}. If this address falls within the\n-     * spatial bounds of the given segment, then {@code 0 <= SO < segment.byteSize()}; otherwise, {@code SO < 0 || SO > segment.byteSize()}.\n-     * @return the offset of this memory address into the given segment.\n-     * @param segment the segment relative to which this address offset should be computed\n-     * @throws IllegalArgumentException if {@code segment} is not compatible with this address; this can happen, for instance,\n-     * when {@code segment} models an heap memory region, while this address is a {@linkplain #isNative() native} address.\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param str the Java string to be written at this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setUtf8String(long offset, String str);\n+\n+    \/**\n+     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n+     * object is also an address, and it refers to the same memory location as this address.\n+     *\n+     * @param that the object to be compared for equality with this address.\n+     * @return {@code true} if the specified object is equal to this address.\n+     *\/\n+    @Override\n+    boolean equals(Object that);\n+\n+    \/**\n+     * Returns the hash code value for this address.\n+     * @return the hash code value for this address.\n+     *\/\n+    @Override\n+    int hashCode();\n+\n+    \/**\n+     * The native memory address instance modelling the {@code NULL} address.\n+     *\/\n+    MemoryAddress NULL = new MemoryAddressImpl(0L);\n+\n+    \/**\n+     * Obtain a native memory address instance from given long address.\n+     * @param value the long address.\n+     * @return the new memory address instance.\n@@ -102,1 +160,5 @@\n-    long segmentOffset(MemorySegment segment);\n+    static MemoryAddress ofLong(long value) {\n+        return value == 0 ?\n+                NULL :\n+                new MemoryAddressImpl(value);\n+    }\n@@ -105,6 +167,1 @@\n-     Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n-     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n-     * native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided resource scope.\n+     * Reads a byte from this address and offset with given layout.\n@@ -112,3 +169,17 @@\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a byte value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    byte get(ValueLayout.OfByte layout, long offset);\n+\n+    \/**\n+     * Writes a byte to this address instance and offset with given layout.\n@@ -116,4 +187,17 @@\n-     * This method is equivalent to the following code:\n-     * <pre>{@code\n-    asSegment(byteSize, null, scope);\n-     * }<\/pre>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfByte layout, long offset, byte value);\n+\n+    \/**\n+     * Reads a boolean from this address and offset with given layout.\n@@ -126,8 +210,3 @@\n-     * @param bytesSize the desired size.\n-     * @param scope the native segment scope.\n-     * @return a new native memory segment with given base address, size and scope.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n-     * have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a boolean value read from this address.\n@@ -139,1 +218,1 @@\n-    MemorySegment asSegment(long bytesSize, ResourceScope scope);\n+    boolean get(ValueLayout.OfBoolean layout, long offset);\n@@ -142,5 +221,1 @@\n-     * Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n-     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n-     * native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * The returned segment is associated with the provided resource scope.\n+     * Writes a boolean to this address instance and offset with given layout.\n@@ -148,3 +223,17 @@\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the boolean value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfBoolean layout, long offset, boolean value);\n+\n+    \/**\n+     * Reads a char from this address and offset with given layout.\n@@ -152,2 +241,17 @@\n-     * Calling {@link ResourceScope#close()} on the scope associated with the returned segment will result in calling\n-     * the provided cleanup action (if any).\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a char value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    char get(ValueLayout.OfChar layout, long offset);\n+\n+    \/**\n+     * Writes a char to this address instance and offset with given layout.\n@@ -160,9 +264,3 @@\n-     * @param bytesSize the desired size.\n-     * @param cleanupAction the cleanup action; can be {@code null}.\n-     * @param scope the native segment scope.\n-     * @return a new native memory segment with given base address, size and scope.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n-     * have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the char value to be written.\n@@ -174,1 +272,1 @@\n-    MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope);\n+    void set(ValueLayout.OfChar layout, long offset, char value);\n@@ -177,2 +275,13 @@\n-     * Is this an off-heap memory address?\n-     * @return true, if this is an off-heap memory address.\n+     * Reads a short from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a short value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -180,1 +289,2 @@\n-    boolean isNative();\n+    @CallerSensitive\n+    short get(ValueLayout.OfShort layout, long offset);\n@@ -183,5 +293,13 @@\n-     * Returns the raw long value associated with this native memory address.\n-     * @return The raw long value associated with this native memory address.\n-     * @throws UnsupportedOperationException if this memory address is not a {@linkplain #isNative() native} address.\n-     * @throws IllegalStateException if the scope associated with this segment has been already closed,\n-     * or if access occurs from a thread other than the thread owning either segment.\n+     * Writes a short to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the short value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -189,1 +307,2 @@\n-    long toRawLongValue();\n+    @CallerSensitive\n+    void set(ValueLayout.OfShort layout, long offset, short value);\n@@ -192,2 +311,6 @@\n-     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n-     * object is also an address, and it refers to the same memory location as this address.\n+     * Reads an int from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -195,4 +318,17 @@\n-     * @apiNote two addresses might be considered equal despite their associated resource scopes differ. This\n-     * can happen, for instance, if the same memory address is used to create memory segments with different\n-     * scopes (using {@link #asSegment(long, ResourceScope)}), and the base address of the resulting segments is\n-     * then compared.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return an int value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    int get(ValueLayout.OfInt layout, long offset);\n+\n+    \/**\n+     * Writes an int to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -200,2 +336,6 @@\n-     * @param that the object to be compared for equality with this address.\n-     * @return {@code true} if the specified object is equal to this address.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the int value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -203,2 +343,2 @@\n-    @Override\n-    boolean equals(Object that);\n+    @CallerSensitive\n+    void set(ValueLayout.OfInt layout, long offset, int value);\n@@ -207,2 +347,13 @@\n-     * Returns the hash code value for this address.\n-     * @return the hash code value for this address.\n+     * Reads a float from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a float value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -210,2 +361,20 @@\n-    @Override\n-    int hashCode();\n+    @CallerSensitive\n+    float get(ValueLayout.OfFloat layout, long offset);\n+\n+    \/**\n+     * Writes a float to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the float value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfFloat layout, long offset, float value);\n@@ -214,2 +383,13 @@\n-     * The native memory address instance modelling the {@code NULL} address, associated\n-     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * Reads a long from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a long value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -217,1 +397,2 @@\n-    MemoryAddress NULL = new MemoryAddressImpl(null, 0L);\n+    @CallerSensitive\n+    long get(ValueLayout.OfLong layout, long offset);\n@@ -220,4 +401,13 @@\n-     * Obtain a native memory address instance from given long address. The returned address is associated\n-     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     * @param value the long address.\n-     * @return the new memory address instance.\n+     * Writes a long to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the long value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -225,4 +415,334 @@\n-    static MemoryAddress ofLong(long value) {\n-        return value == 0 ?\n-                NULL :\n-                new MemoryAddressImpl(null, value);\n+    @CallerSensitive\n+    void set(ValueLayout.OfLong layout, long offset, long value);\n+\n+    \/**\n+     * Reads a double from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a double value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    double get(ValueLayout.OfDouble layout, long offset);\n+\n+    \/**\n+     * Writes a double to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the double value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfDouble layout, long offset, double value);\n+\n+    \/**\n+     * Reads an address from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return an address value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    MemoryAddress get(ValueLayout.OfAddress layout, long offset);\n+\n+    \/**\n+     * Writes an address to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the address value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfAddress layout, long offset, Addressable value);\n+\n+    \/**\n+     * Reads a char from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a char value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    char getAtIndex(ValueLayout.OfChar layout, long index);\n+\n+    \/**\n+     * Writes a char to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the char value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfChar layout, long index, char value);\n+\n+    \/**\n+     * Reads a short from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a short value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    short getAtIndex(ValueLayout.OfShort layout, long index);\n+\n+    \/**\n+     * Writes a short to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfShort layout, long index, short value);\n+\n+    \/**\n+     * Reads an int from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an int value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    int getAtIndex(ValueLayout.OfInt layout, long index);\n+\n+    \/**\n+     * Writes an int to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the int value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfInt layout, long index, int value);\n+\n+    \/**\n+     * Reads a float from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a float value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    float getAtIndex(ValueLayout.OfFloat layout, long index);\n+\n+    \/**\n+     * Writes a float to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the float value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfFloat layout, long index, float value);\n+\n+    \/**\n+     * Reads a long from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a long value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    long getAtIndex(ValueLayout.OfLong layout, long index);\n+\n+    \/**\n+     * Writes a long to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the long value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfLong layout, long index, long value);\n+\n+    \/**\n+     * Reads a double from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a double value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    double getAtIndex(ValueLayout.OfDouble layout, long index);\n+\n+    \/**\n+     * Writes a double to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the double value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfDouble layout, long index, double value);\n+\n+    \/**\n+     * Reads an address from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an address value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index);\n+\n+    \/**\n+     * Writes an address to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the address value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value);\n+\n+    \/**\n+     * Returns the {@linkplain ResourceScope#globalScope() global scope}.\n+     * @return the {@linkplain ResourceScope#globalScope() global scope}.\n+     *\/\n+    @Override\n+    default ResourceScope scope() {\n+        return ResourceScope.globalScope();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":635,"deletions":115,"binary":false,"changes":750,"status":"modified"},{"patch":"@@ -1,713 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * This class provides convenient methods for copying data between primitive arrays and memory segments.\n- *\n- * <p>If the source (destination) segment is actually a view of the destination (source) array,\n- * and if the copy region of the source overlaps with the copy region of the destination,\n- * the copy of the overlapping region is performed as if the data in the overlapping region\n- * were first copied into a temporary segment before being copied to the destination.<\/p>\n- *\n- * <p>\n- * Copy operations defined in this class accept a <em>byte order<\/em> parameter. If the specified byte order is different\n- * from the <em>native<\/em> byte order, a byte swap operation is performed on each array elements\n- * as they are copied from the source (destination) segment to the destination (source) array.\n- * Additional overloads are provided (see {@link #copyFromArray(double[], int, int, MemorySegment, long)}),\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException} to be thrown. Moreover,\n- * attempting to copy to\/from a segment whose {@linkplain MemorySegment#scope() scope} has already been closed,\n- * or from a thread other than the thread owning the scope causes an {@link IllegalStateException} to be thrown.\n- * Finally, attempting to copy to\/from a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n- * {@linkplain MemorySegment#byteSize() size} {@code S}) at addresses that are {@code < B}, or {@code >= B + S},\n- * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n- * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n- *\/\n-public final class MemoryCopy {\n-\n-    private static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    private static final int BYTE_BASE = unsafe.arrayBaseOffset(byte[].class);\n-    private static final int CHAR_BASE = unsafe.arrayBaseOffset(char[].class);\n-    private static final int SHORT_BASE = unsafe.arrayBaseOffset(short[].class);\n-    private static final int INT_BASE = unsafe.arrayBaseOffset(int[].class);\n-    private static final int FLOAT_BASE = unsafe.arrayBaseOffset(float[].class);\n-    private static final int LONG_BASE = unsafe.arrayBaseOffset(long[].class);\n-    private static final int DOUBLE_BASE = unsafe.arrayBaseOffset(double[].class);\n-\n-    private MemoryCopy() { \/* singleton *\/ }\n-\n-    \/\/BYTE\n-    \/**\n-     * Copies a number of byte elements from a source byte array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source byte array.\n-     * @param srcIndexBytes the starting index of the source byte array.\n-     * @param srcCopyLengthBytes the number of byte elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            byte[] srcArray, int srcIndexBytes, int srcCopyLengthBytes,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.checkFromIndexSize(srcIndexBytes, srcCopyLengthBytes, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthBytes, false);\n-        scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                srcArray, BYTE_BASE + srcIndexBytes,\n-                destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthBytes);\n-    }\n-\n-    \/**\n-     * Copies a number of byte elements from a source segment to a destination byte array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination byte array.\n-     * @param dstIndexBytes the starting index of the destination byte array.\n-     * @param dstCopyLengthBytes the number of byte elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            byte[] dstArray, int dstIndexBytes, int dstCopyLengthBytes) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthBytes, true);\n-        Objects.checkFromIndexSize(dstIndexBytes, dstCopyLengthBytes, dstArray.length);\n-        scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                dstArray, BYTE_BASE + dstIndexBytes, dstCopyLengthBytes);\n-    }\n-\n-    \/\/CHAR\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source char array.\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexChars, srcCopyLengthChars, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source char array.\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexChars, srcCopyLengthChars, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthChars << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1, 2);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexChars, dstCopyLengthChars, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthChars << 1, true);\n-        Objects.checkFromIndexSize(dstIndexChars, dstCopyLengthChars, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1, 2);\n-        }\n-    }\n-\n-    \/\/SHORT\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source short array.\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexShorts, srcCopyLengthShorts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source short array.\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexShorts, srcCopyLengthShorts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthShorts << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1, 2);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexShorts, dstCopyLengthShorts, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthShorts << 1, true);\n-        Objects.checkFromIndexSize(dstIndexShorts, dstCopyLengthShorts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1, 2);\n-        }\n-    }\n-\n-    \/\/INT\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source int array.\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexInts, srcCopyLengthInts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source int array.\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexInts, srcCopyLengthInts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthInts << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2, 4);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexInts, dstCopyLengthInts, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthInts << 2, true);\n-        Objects.checkFromIndexSize(dstIndexInts, dstCopyLengthInts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2, 4);\n-        }\n-    }\n-\n-    \/\/FLOAT\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source float array.\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexFloats, srcCopyLengthFloats, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source float array.\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexFloats, srcCopyLengthFloats, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthFloats << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2, 4);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexFloats, dstCopyLengthFloats, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a float swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthFloats << 2, true);\n-        Objects.checkFromIndexSize(dstIndexFloats, dstCopyLengthFloats, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2, 4);\n-        }\n-    }\n-\n-    \/\/LONG\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source long array.\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexLongs, srcCopyLengthLongs, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source long array.\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexLongs, srcCopyLengthLongs, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthLongs << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3, 8);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexLongs, dstCopyLengthLongs, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthLongs << 3, true);\n-        Objects.checkFromIndexSize(dstIndexLongs, dstCopyLengthLongs, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3, 8);\n-        }\n-    }\n-\n-    \/\/DOUBLE\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source double array.\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexDoubles, srcCopyLengthDoubles, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source double array.\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexDoubles, srcCopyLengthDoubles, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthDoubles << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3, 8);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexDoubles, dstCopyLengthDoubles, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthDoubles << 3, true);\n-        Objects.checkFromIndexSize(dstIndexDoubles, dstCopyLengthDoubles, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3, 8);\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":0,"deletions":713,"binary":false,"changes":713,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -37,1 +36,0 @@\n-import java.nio.ByteOrder;\n@@ -43,5 +41,4 @@\n- * To obtain a memory access var handle, clients must start from one of the <em>leaf<\/em> methods\n- * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},\n- * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type\n- * (all primitive types but {@code void}, as well as {@link MemoryAddress} are supported), as well as the alignment constraint and the\n- * byte order associated with a memory access var handle. The resulting memory access var handle can then be combined in various ways\n+ * Memory access var handles can be obtained using {@link MemoryHandles#varHandle(ValueLayout)}. The provided value layout\n+ * determines the type, as well as the alignment constraint and the byte order associated with the memory access var handle.\n+ * <p>\n+ * The resulting memory access var handle can then be combined in various ways\n@@ -56,1 +53,1 @@\n-        MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN).withName(\"value\")\n+        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n@@ -61,1 +58,1 @@\n-VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); \/\/(MemorySegment, long) -> int\n+VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n@@ -112,2 +109,0 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n-    private static final MethodHandle ADDRESS_TO_LONG;\n@@ -127,4 +122,0 @@\n-            LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, \"longToAddress\",\n-                    MethodType.methodType(MemoryAddress.class, long.class));\n-            ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, \"addressToLong\",\n-                    MethodType.methodType(long.class, MemoryAddress.class));\n@@ -157,28 +148,4 @@\n-     * Creates a memory access var handle with the given carrier type and byte order.\n-     *\n-     * The returned var handle's type is {@code carrier} and the list of coordinate types is\n-     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n-     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n-     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n-     * the alignment constraint (in bytes) for the resulting memory access var handle is the same as the size (in bytes) of the\n-     * carrier type {@code carrier}.\n-     *\n-     * @apiNote the resulting var handle features certain <a href=\"#memaccess-mode\">access mode restrictions<\/a>,\n-     * which are common to all memory access var handles.\n-     *\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code boolean}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, {@code double} and {@link MemoryAddress}.\n-     * @param byteOrder the required byte order.\n-     * @return the new memory access var handle.\n-     * @throws IllegalArgumentException when an illegal carrier type is used\n-     *\/\n-    public static VarHandle varHandle(Class<?> carrier, ByteOrder byteOrder) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(byteOrder);\n-        return varHandle(carrier,\n-                carrierSize(carrier),\n-                byteOrder);\n-    }\n-\n-    \/**\n-     * Creates a memory access var handle with the given carrier type, alignment constraint, and byte order.\n+     * Creates a memory access var handle from given value layout. The provided layout will specify the\n+     * {@linkplain ValueLayout#carrier() carrier type}, the {@linkplain ValueLayout#byteSize() the byte size},\n+     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n+     * associated to the returned var handle.\n@@ -195,4 +162,1 @@\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code boolean}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, {@code double} and {@link MemoryAddress}.\n-     * @param alignmentBytes the alignment constraint (in bytes). Must be a power of two.\n-     * @param byteOrder the required byte order.\n+     * @param layout the value layout for which a memory access handle is to be obtained.\n@@ -202,43 +166,3 @@\n-    public static VarHandle varHandle(Class<?> carrier, long alignmentBytes, ByteOrder byteOrder) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(byteOrder);\n-        checkCarrier(carrier);\n-\n-        if (alignmentBytes <= 0\n-                || (alignmentBytes & (alignmentBytes - 1)) != 0) { \/\/ is power of 2?\n-            throw new IllegalArgumentException(\"Bad alignment: \" + alignmentBytes);\n-        }\n-\n-        return Utils.makeMemoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder);\n-    }\n-\n-    \/**\n-     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemorySegment}.\n-     * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,\n-     * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});\n-     * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted\n-     * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)\n-     * memory depends on the carrier of the original memory access var handle.\n-     *\n-     * @param target the memory access var handle to be adapted\n-     * @return the adapted var handle.\n-     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},\n-     * {@code float}, or {@code double}, or is not a primitive type.\n-     *\/\n-    public static VarHandle asAddressVarHandle(VarHandle target) {\n-        Objects.requireNonNull(target);\n-        Class<?> carrier = target.varType();\n-        if (!carrier.isPrimitive() || carrier == boolean.class ||\n-                carrier == float.class || carrier == double.class) {\n-            throw new IllegalArgumentException(\"Unsupported carrier type: \" + carrier.getName());\n-        }\n-\n-        if (carrier != long.class) {\n-            \/\/ slow-path, we need to adapt\n-            return filterValue(target,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),\n-                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));\n-        } else {\n-            \/\/ fast-path\n-            return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);\n-        }\n+    public static VarHandle varHandle(ValueLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return layout.accessHandle();\n@@ -257,2 +181,2 @@\n-    MemorySegment segment = MemorySegment.allocateNative(2, ResourceScope.newImplicitScope());\n-    VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);\n+    MemorySegment segment = MemorySegment.allocateNative(2, ResourceScope.newConfinedScope());\n+    VarHandle SHORT_VH = ValueLayout.JAVA_SHORT.varHandle();\n@@ -279,1 +203,1 @@\n-     * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access\n+     * java.lang.invoke.VarHandle.AccessMode}), and the same atomic access\n@@ -287,1 +211,1 @@\n-     * adaptedType} is not one of {@code int}, or {@code long}; if the bitwidth\n+     * adaptedType} is not one of {@code int}, or {@code long}; if the bit width\n@@ -327,1 +251,1 @@\n-     * For the boxing and unboxing filters to be well formed, their types must be of the form {@code (A... , S) -> T} and\n+     * For the boxing and unboxing filters to be well-formed, their types must be of the form {@code (A... , S) -> T} and\n@@ -335,1 +259,1 @@\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and\n+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n@@ -359,1 +283,1 @@\n-     * For the coordinate filters to be well formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n+     * For the coordinate filters to be well-formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n@@ -391,1 +315,1 @@\n-     * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },\n+     * For the bound coordinates to be well-formed, their types must be {@code T1, T2 ... Tn },\n@@ -418,1 +342,1 @@\n-     * {@code newCoordinates.size()}, and call {@code #O} the number\n+     * {@code newCoordinates.size()}), and call {@code #O} the number\n@@ -453,1 +377,1 @@\n-     * Adapts a target var handle handle by pre-processing\n+     * Adapts a target var handle by pre-processing\n@@ -517,22 +441,0 @@\n-    private static void checkAddressFirstCoordinate(VarHandle handle) {\n-        if (handle.coordinateTypes().size() < 1 ||\n-                handle.coordinateTypes().get(0) != MemorySegment.class) {\n-            throw new IllegalArgumentException(\"Expected var handle with leading coordinate of type MemorySegment\");\n-        }\n-    }\n-\n-    private static void checkCarrier(Class<?> carrier) {\n-        if ((!carrier.isPrimitive() && carrier != MemoryAddress.class) || carrier == void.class) {\n-            throw new IllegalArgumentException(\"Illegal carrier: \" + carrier.getSimpleName());\n-        }\n-    }\n-\n-    private static long carrierSize(Class<?> carrier) {\n-        if (carrier == MemoryAddress.class) {\n-            return MemoryLayouts.ADDRESS.byteSize();\n-        } else {\n-            long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());\n-            return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);\n-        }\n-    }\n-\n@@ -557,8 +459,0 @@\n-\n-    private static MemoryAddress longToAddress(long value) {\n-        return MemoryAddress.ofLong(value);\n-    }\n-\n-    private static long addressToLong(MemoryAddress value) {\n-        return value.toRawLongValue();\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":24,"deletions":130,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.nio.ByteOrder;\n@@ -49,1 +48,1 @@\n- * A memory layout can be used to describe the contents of a memory segment in a <em>language neutral<\/em> fashion.\n+ * A memory layout can be used to describe the contents of a memory segment.\n@@ -53,1 +52,1 @@\n- * Some common value layout constants are defined in the {@link MemoryLayouts} class.\n+ * Some common value layout constants are defined in the {@link ValueLayout} class.\n@@ -73,1 +72,1 @@\n-        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        ValueLayout.JAVA_BYTE.withName(\"kind\"),\n@@ -75,1 +74,1 @@\n-        MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"value\")\n+        ValueLayout.JAVA_INT.withName(\"value\")\n@@ -125,5 +124,5 @@\n- * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout\n- * (see {@link MemoryLayout#bitOffset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected\n- * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside\n- * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside\n- * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).\n+ * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#bitOffset(PathElement...) offsets} of\n+ * arbitrarily nested layouts inside another layout, to quickly obtain a {@linkplain #varHandle(PathElement...) memory access handle}\n+ * corresponding to the selected layout, to {@linkplain #select(PathElement...) select} an arbitrarily nested layout inside\n+ * another layout, or to {@link #map(UnaryOperator, PathElement...) transform} a nested layout element inside\n+ * another layout.\n@@ -155,1 +154,1 @@\n-        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        ValueLayout.JAVA_BYTE.withName(\"kind\"),\n@@ -167,2 +166,1 @@\n-VarHandle valueHandle = taggedValues.varHandle(int.class,\n-                                               PathElement.sequenceElement(),\n+VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n@@ -192,3 +190,1 @@\n- * Layouts can be optionally associated with one or more <em>attributes<\/em>. A layout attribute forms a <em>name\/value<\/em>\n- * pair, where the name is a {@link String} and the value is a {@link Constable}. The most common form of layout attribute\n- * is the <em>layout name<\/em> (see {@link #LAYOUT_NAME}), a custom name that can be associated with memory layouts and that can be referred to when\n+ * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be referred to when\n@@ -239,4 +235,1 @@\n-    default long byteSize() {\n-        return Utils.bitsToBytesOrThrow(bitSize(),\n-                () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n-    }\n+    long byteSize();\n@@ -246,5 +239,0 @@\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    attribute(LAYOUT_NAME).map(String.class::cast);\n-     * }<\/pre><\/blockquote>\n@@ -259,5 +247,0 @@\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    withAttribute(LAYOUT_NAME, name);\n-     * }<\/pre><\/blockquote>\n@@ -316,1 +299,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than than 8.\n+     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than 8.\n@@ -320,26 +303,0 @@\n-    \/**\n-     * Returns the attribute with the given name (if it exists).\n-     *\n-     * @param name the attribute name\n-     * @return the attribute with the given name (if it exists).\n-     *\/\n-    Optional<Constable> attribute(String name);\n-\n-    \/**\n-     * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.\n-     * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned\n-     * layout.\n-     *\n-     * @param name the attribute name.\n-     * @param value the attribute value.\n-     * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.\n-     *\/\n-    MemoryLayout withAttribute(String name, Constable value);\n-\n-    \/**\n-     * Returns a stream of the attribute names associated with this layout.\n-     *\n-     * @return a stream of the attribute names associated with this layout.\n-     *\/\n-    Stream<String> attributes();\n-\n@@ -369,1 +326,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -420,1 +377,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -480,1 +437,0 @@\n-     * @param carrier the var handle carrier type.\n@@ -485,3 +441,1 @@\n-     * @throws IllegalArgumentException if the carrier is {@code void}, or a non-primitive type other than {@link MemoryAddress},\n-     * or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),\n-     * or if the selected value layout has a size that that does not match that of the specified carrier type.\n+     * @throws IllegalArgumentException if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}).\n@@ -489,3 +443,2 @@\n-    default VarHandle varHandle(Class<?> carrier, PathElement... elements) {\n-        Objects.requireNonNull(carrier);\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -> path.dereferenceHandle(carrier),\n+    default VarHandle varHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::dereferenceHandle,\n@@ -501,1 +454,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -518,1 +471,1 @@\n-     * <p>After the offset is computed, the returned segment is create as if by calling:\n+     * <p>After the offset is computed, the returned segment is created as if by calling:\n@@ -615,1 +568,1 @@\n-         * method will select the first one; that is, the group element with lowest offset from current path is selected.\n+         * method will select the first one; that is, the group element with the lowest offset from current path is selected.\n@@ -730,14 +683,0 @@\n-    \/**\n-     * Create a value layout of given byte order and size.\n-     *\n-     * @param size the value layout size.\n-     * @param order the value layout's byte order.\n-     * @return a new value layout.\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n-     *\/\n-    static ValueLayout valueLayout(long size, ByteOrder order) {\n-        Objects.requireNonNull(order);\n-        AbstractLayout.checkSize(size);\n-        return new ValueLayout(order, size);\n-    }\n-\n@@ -795,5 +734,0 @@\n-\n-    \/**\n-     * Attribute name used to specify the <em>name<\/em> property of a memory layout (see {@link #name()} and {@link #withName(String)}).\n-     *\/\n-    String LAYOUT_NAME = \"layout\/name\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":22,"deletions":88,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.misc.Unsafe;\n-\n-import java.nio.ByteOrder;\n-\n-\/**\n- * This class defines useful layout constants. Some of the constants defined in this class are explicit in both\n- * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the\n- * contents of a memory segment. Other constants make implicit byte order assumptions (see\n- * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,\n- * such as {@link java.nio.ByteBuffer}.\n- *\/\n-public final class MemoryLayouts {\n-\n-    private MemoryLayouts() {\n-        \/\/just the one, please\n-    }\n-\n-    \/**\n-     * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_8_LE = MemoryLayout.valueLayout(8, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_16_LE = MemoryLayout.valueLayout(16, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_32_LE = MemoryLayout.valueLayout(32, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_64_LE = MemoryLayout.valueLayout(64, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_8_BE = MemoryLayout.valueLayout(8, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_16_BE = MemoryLayout.valueLayout(16, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_32_BE = MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_64_BE = MemoryLayout.valueLayout(64, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A padding layout constant with size of one byte.\n-     *\/\n-    public static final MemoryLayout PAD_8 = MemoryLayout.paddingLayout(8);\n-\n-    \/**\n-     * A padding layout constant with size of two bytes.\n-     *\/\n-    public static final MemoryLayout PAD_16 = MemoryLayout.paddingLayout(16);\n-\n-    \/**\n-     * A padding layout constant with size of four bytes.\n-     *\/\n-    public static final MemoryLayout PAD_32 = MemoryLayout.paddingLayout(32);\n-\n-    \/**\n-     * A padding layout constant with size of eight bytes.\n-     *\/\n-    public static final MemoryLayout PAD_64 = MemoryLayout.paddingLayout(64);\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}), and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout ADDRESS = MemoryLayout.valueLayout(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code byte}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_BYTE = MemoryLayout.valueLayout(8, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code boolean}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_BOOLEAN = MemoryLayout.valueLayout(8, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code char}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_CHAR = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code short}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_SHORT = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code int}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_INT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code long}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n-     * invariant holds:\n-     * <blockquote><pre>{@code\n-    MemoryLayouts.JAVA_LONG.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n-     * }<\/pre><\/blockquote>\n-     *\/\n-    public static final ValueLayout JAVA_LONG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n-            .withBitAlignment(ADDRESS.bitSize());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code float}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_FLOAT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n-     * invariant holds:\n-     * <blockquote><pre>{@code\n-    MemoryLayouts.JAVA_DOUBLE.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n-     * }<\/pre><\/blockquote>\n-     *\/\n-    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n-            .withBitAlignment(ADDRESS.bitSize());\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Array;\n@@ -37,0 +38,4 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n@@ -39,0 +44,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -43,0 +49,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -90,1 +97,1 @@\n- * these capabilities are suitable replacements for some of the functionality in the {@link java.nio.MappedByteBuffer} class.\n+ * these capabilities are suitable replacements for some capabilities in the {@link java.nio.MappedByteBuffer} class.\n@@ -98,1 +105,36 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegment(long, Runnable, ResourceScope)}.\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddressNative(MemoryAddress, long, ResourceScope)}.\n+ *\n+ * <h2>Restricted native segments<\/h2>\n+ *\n+ * Sometimes it is necessary to turn a memory address obtained from native code into a memory segment with\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddressNative(MemoryAddress, long, ResourceScope) obtain}\n+ * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain ResourceScope scope}.\n+ * This is a <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> operation and should be used with\n+ * caution: for instance, an incorrect segment size could result in a VM crash when attempting to dereference\n+ * the memory segment.\n+ *\n+ * <h2>Dereference<\/h2>\n+ *\n+ * A memory segment can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+int value = segment.get(ValueLayout.JAVA_INT, 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * can be expressed as follows:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+int value = segment.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * For more complex dereference operations (e.g. structured memory access), clients can obtain a <em>memory access var handle<\/em>,\n+ * that is, a var handle that accepts a segment and, optionally, one or more additional {@code long} coordinates. Memory\n+ * access var handles can be obtained from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n+ * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>.\n+ * Alternatively, clients can obtain raw memory access var handles from a given\n+ * {@linkplain MemoryHandles#varHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n+ * functions defined in the {@link MemoryHandles} class.\n@@ -109,1 +151,1 @@\n-    segment = MemorySegment.allocateNative(8, 1, scope);\n+    segment = scope.allocate(8);\n@@ -111,1 +153,1 @@\n-MemoryAccess.getLong(segment); \/\/ already closed!\n+segment.get(ValueLayout.JAVA_LONG, 0); \/\/ already closed!\n@@ -147,5 +189,4 @@\n-    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n-    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n-    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-    int sum = segment.elements(MemoryLayouts.JAVA_INT).parallel()\n-                           .mapToInt(s -> (int)VH_int.get(s.address()))\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n+    MemorySegment segment = scope.allocate(SEQUENCE_LAYOUT);\n+    int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+                           .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n@@ -162,2 +203,4 @@\n-     * The base memory address associated with this memory segment.\n-     * The returned memory address is associated with same resource scope as that associated with this segment.\n+     * The base memory address associated with this native memory segment.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -221,2 +264,0 @@\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(MemoryAddress, long)\n@@ -231,22 +272,0 @@\n-    \/**\n-     * Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.\n-     * <p>\n-     * Equivalent to the following code:\n-     * <pre>{@code\n-    asSlice(newBase.segmentOffset(this), newSize);\n-     * }<\/pre>\n-     *\n-     * @see #asSlice(long)\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(long, long)\n-     *\n-     * @param newBase The new segment base address.\n-     * @param newSize The new segment size, specified in bytes.\n-     * @return a new memory segment view with updated base\/limit addresses.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n-     *\/\n-    default MemorySegment asSlice(MemoryAddress newBase, long newSize) {\n-        Objects.requireNonNull(newBase);\n-        return asSlice(newBase.segmentOffset(this), newSize);\n-    }\n-\n@@ -262,2 +281,0 @@\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(MemoryAddress, long)\n@@ -274,22 +291,0 @@\n-    \/**\n-     * Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting\n-     * the address offset relative to this segment (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.\n-     * <p>\n-     * Equivalent to the following code:\n-     * <pre>{@code\n-    asSlice(newBase.segmentOffset(this));\n-     * }<\/pre>\n-     *\n-     * @see #asSlice(long)\n-     * @see #asSlice(MemoryAddress, long)\n-     * @see #asSlice(long, long)\n-     *\n-     * @param newBase The new segment base offset (relative to the current segment base address), specified in bytes.\n-     * @return a new memory segment view with updated base\/limit addresses.\n-     * @throws IndexOutOfBoundsException if {@code address.segmentOffset(this) < 0}, or {@code address.segmentOffset(this) > byteSize()}.\n-     *\/\n-    default MemorySegment asSlice(MemoryAddress newBase) {\n-        Objects.requireNonNull(newBase);\n-        return asSlice(newBase.segmentOffset(this));\n-    }\n-\n@@ -335,1 +330,1 @@\n-byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+byteHandle = MemoryLayout.ofSequence(ValueLayout.JAVA_BYTE)\n@@ -350,1 +345,1 @@\n-     * a thread other than the thread owning that scope,\n+     * a thread other than the thread owning that scope.\n@@ -355,22 +350,0 @@\n-    \/**\n-     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment\n-     * at offset {@code 0} through {@code src.byteSize() - 1}.\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     *\n-     * @param src the source segment.\n-     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    void copyFrom(MemorySegment src);\n-\n@@ -382,21 +355,4 @@\n-     * The copy occurs in an element-wise fashion: the source bytes are interpreted as a sequence of elements\n-     * whose layout is {@code srcElementLayout}, whereas the bytes in this segment are interpreted as a sequence of\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S} and\n-     * alignment {@code A}, and the size of the source segment must be a multiple of {@code S} for the copy operation\n-     * to be correctly specified. If the byte order of the two element layouts differ, the bytes corresponding to each\n-     * element to be copied are swapped accordingly during the copy operation.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     *\n-     * @implSpec\n-     * If {@code srcElementLayout.byteSize() == 1}, or if {@code srcElementLayout.order() == dstElementLayout.order()}, calling\n-     * this method must be equivalent to calling {@link #copyFrom(MemorySegment)} with the same source segment.\n-     *\n-     * @param dstElementLayout the element layout associated with this segment.\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(src, 0, this, 0, src.byteSize);\n+     * }<\/pre><\/blockquote>\n@@ -404,1 +360,0 @@\n-     * @param srcElementLayout the element layout associated with the source segment.\n@@ -414,0 +369,1 @@\n+     * @return this segment.\n@@ -415,1 +371,4 @@\n-    void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout);\n+    default MemorySegment copyFrom(MemorySegment src) {\n+        MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+        return this;\n+    }\n@@ -425,1 +384,1 @@\n-     * the length of the common prefix and it follows that there is a mismatch\n+     * the length of the common prefix, and it follows that there is a mismatch\n@@ -427,2 +386,2 @@\n-     * If one segment is a proper prefix of the other then the returned offset is\n-     * the smaller of the segment sizes, and it follows that the offset is only\n+     * If one segment is a proper prefix of the other, then the returned offset is\n+     * the smallest of the segment sizes, and it follows that the offset is only\n@@ -442,1 +401,1 @@\n-     * Tells whether or not the contents of this mapped segment is resident in physical\n+     * Tells whether the contents of this mapped segment is resident in physical\n@@ -446,1 +405,1 @@\n-     * that all of the data in this segment is resident in physical memory and\n+     * that all the data in this segment is resident in physical memory and\n@@ -525,1 +484,1 @@\n-     * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to\n+     * Wraps this segment in a {@link ByteBuffer}. Some properties of the returned buffer are linked to\n@@ -528,1 +487,1 @@\n-     * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is\n+     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native memory segment, the resulting buffer is\n@@ -531,1 +490,1 @@\n-     * The returned buffer's position (see {@link ByteBuffer#position()} is initially set to zero, while\n+     * The returned buffer's position (see {@link ByteBuffer#position()}) is initially set to zero, while\n@@ -537,1 +496,1 @@\n-     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}, will throw an {@link IllegalStateException}.\n+     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}), will throw an {@link IllegalStateException}.\n@@ -549,1 +508,1 @@\n-     * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater\n+     * e.g. because it models a heap-based segment that is not based on a {@code byte[]}), or if its size is greater\n@@ -556,0 +515,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -561,1 +522,1 @@\n-    byte[] toByteArray();\n+    byte[] toArray(ValueLayout.OfByte elementLayout);\n@@ -565,0 +526,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -570,1 +533,1 @@\n-    short[] toShortArray();\n+    short[] toArray(ValueLayout.OfShort elementLayout);\n@@ -574,0 +537,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -579,1 +544,1 @@\n-    char[] toCharArray();\n+    char[] toArray(ValueLayout.OfChar elementLayout);\n@@ -583,0 +548,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -588,1 +555,1 @@\n-    int[] toIntArray();\n+    int[] toArray(ValueLayout.OfInt elementLayout);\n@@ -592,0 +559,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -597,1 +566,1 @@\n-    float[] toFloatArray();\n+    float[] toArray(ValueLayout.OfFloat elementLayout);\n@@ -601,0 +570,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -606,1 +577,1 @@\n-    long[] toLongArray();\n+    long[] toArray(ValueLayout.OfLong elementLayout);\n@@ -610,0 +581,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -615,1 +588,1 @@\n-    double[] toDoubleArray();\n+    double[] toArray(ValueLayout.OfDouble elementLayout);\n@@ -618,1 +591,39 @@\n-     * Creates a new confined buffer memory segment that models the memory associated with the given byte\n+     * Reads a UTF-8 encoded, null-terminated string from this segment at given offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a Java UTF-8 string containing all the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n+     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    default String getUtf8String(long offset) {\n+        return SharedUtils.toJavaStringInternal(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a UTF-8 encoded, null-terminated string into this segment at given offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param str the Java string to be written into this segment.\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n+     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    default void setUtf8String(long offset, String str) {\n+        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    }\n+\n+\n+    \/**\n+     * Creates a new buffer memory segment that models the memory associated with the given byte\n@@ -625,1 +636,1 @@\n-     * or to some other (possibly closeable) resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * or some other resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n@@ -637,1 +648,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.\n@@ -648,1 +659,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.\n@@ -659,1 +670,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.\n@@ -670,1 +681,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.\n@@ -681,1 +692,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.\n@@ -692,1 +703,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.\n@@ -703,1 +714,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.\n@@ -713,0 +724,41 @@\n+\n+    \/**\n+     * Creates a new native memory segment with given size and resource scope, and whose base address is this address.\n+     * This method can be useful when interacting with custom\n+     * native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided resource scope.\n+     * <p>\n+     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     *\n+     * @param address the returned segment's base address.\n+     * @param bytesSize the desired size.\n+     * @param scope the native segment scope.\n+     * @return a new native memory segment with given base address, size and scope.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws IllegalStateException if the provided scope has been already closed,\n+     * or if access occurs from a thread other than the thread owning the scope.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static MemorySegment ofAddressNative(MemoryAddress address, long bytesSize, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, bytesSize, (ResourceScopeImpl)scope);\n+    }\n+\n@@ -714,1 +766,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout\n@@ -739,1 +791,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n@@ -762,1 +814,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size\n@@ -800,1 +852,1 @@\n-     * this (or another) program.  Whether or not such changes occur, and when they\n+     * this (or another) program.  Whether such changes occur, and when they\n@@ -818,1 +870,1 @@\n-     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode\n+     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the mapping mode\n@@ -821,1 +873,1 @@\n-     * @return a new confined mapped memory segment.\n+     * @return a new mapped memory segment.\n@@ -828,1 +880,1 @@\n-     * @throws  SecurityException If a security manager is installed and it denies an unspecified permission required by the implementation.\n+     * @throws  SecurityException If a security manager is installed, and it denies an unspecified permission required by the implementation.\n@@ -839,7 +891,3 @@\n-     * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n-     * This method can be very useful when dereferencing memory addresses obtained when interacting with native libraries.\n-     * The returned segment is associated with the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n-     * Equivalent to (but likely more efficient than) the following code:\n-     * <pre>{@code\n-    MemoryAddress.NULL.asSegment(Long.MAX_VALUE)\n-     * }<\/pre>\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n@@ -847,4 +895,102 @@\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n+\n+    \/**\n+     * Reads a byte from this segment and offset with given layout.\n@@ -852,4 +998,8 @@\n-     * @return a memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a byte value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n@@ -857,4 +1007,617 @@\n-    @CallerSensitive\n-    static MemorySegment globalNativeSegment() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return NativeMemorySegmentImpl.EVERYTHING;\n+    @ForceInline\n+    default byte get(ValueLayout.OfByte layout, long offset) {\n+        return (byte)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a byte to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a boolean from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a boolean value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        return (boolean)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a boolean to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a char from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a char value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default char get(ValueLayout.OfChar layout, long offset) {\n+        return (char)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a char to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfChar layout, long offset, char value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a short from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a short value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default short get(ValueLayout.OfShort layout, long offset) {\n+        return (short)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a short to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfShort layout, long offset, short value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an int from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return an int value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default int get(ValueLayout.OfInt layout, long offset) {\n+        return (int)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes an int to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfInt layout, long offset, int value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a float from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a float value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default float get(ValueLayout.OfFloat layout, long offset) {\n+        return (float)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a float to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a long from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a long value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default long get(ValueLayout.OfLong layout, long offset) {\n+        return (long)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a long to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfLong layout, long offset, long value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a double from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a double value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default double get(ValueLayout.OfDouble layout, long offset) {\n+        return (double)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a double to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an address from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return an address value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n+        return (MemoryAddress)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes an address to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n+        layout.accessHandle().set(this, offset, value.address());\n+    }\n+\n+    \/**\n+     * Reads a char from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a char value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        return (char)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a char to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a short from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a short value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        return (short)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a short to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads an int from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an int value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default int getAtIndex(ValueLayout.OfInt layout, long index) {\n+        return (int)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes an int to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a float from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a float value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+        return (float)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a float to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a long from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a long value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default long getAtIndex(ValueLayout.OfLong layout, long index) {\n+        return (long)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a long to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a double from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a double value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default double getAtIndex(ValueLayout.OfDouble layout, long index) {\n+        return (double)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a double to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads an address from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an address value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+        return (MemoryAddress)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes an address to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@link #isNative()} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value.address());\n+    }\n+\n+\n+    \/**\n+     * Copies a number of elements from a source segment to a destination array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given source element layout.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+     * @param srcSegment the source segment.\n+     * @param srcLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported,\n+     * or if the destination array component type does not match the carrier of the source element layout.\n+     *\/\n+    @ForceInline\n+    static void copy(\n+            MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(srcLayout);\n+        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n+        }\n+        int dstBase = (int)baseAndScale;\n+        int dstWidth = (int)(baseAndScale >> 32);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of elements from a source array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given destination element layout.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n+     * @param dstSegment the destination segment.\n+     * @param dstLayout the destination element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported,\n+     * or if the source array component type does not match the carrier of the destination element layout.\n+     *\/\n+    @ForceInline\n+    static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset, int elementCount) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstLayout);\n+        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n+        }\n+        int srcBase = (int)baseAndScale;\n+        int srcWidth = (int)(baseAndScale >> 32);\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n+    }\n+\n+    private static long getBaseAndScale(Class<?> arrayType) {\n+        if (arrayType.equals(byte[].class)) {\n+            return (long)Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(char[].class)) {\n+            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(short[].class)) {\n+            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(int[].class)) {\n+            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(float[].class)) {\n+            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(long[].class)) {\n+            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(double[].class)) {\n+            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n+        } else {\n+            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":921,"deletions":158,"binary":false,"changes":1079,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Map;\n@@ -56,1 +54,1 @@\n-        this(size, 1, Map.of());\n+        this(size, 1, Optional.empty());\n@@ -59,2 +57,2 @@\n-    PaddingLayout(long size, long alignment, Map<String, Constable> attributes) {\n-        super(OptionalLong.of(size), alignment, attributes);\n+    PaddingLayout(long size, long alignment, Optional<String> name) {\n+        super(OptionalLong.of(size), alignment, name);\n@@ -76,1 +74,1 @@\n-        if (!(other instanceof PaddingLayout)) {\n+        if (!(other instanceof PaddingLayout p)) {\n@@ -79,1 +77,0 @@\n-        PaddingLayout p = (PaddingLayout)other;\n@@ -89,2 +86,2 @@\n-    PaddingLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new PaddingLayout(bitSize(), alignment, attributes);\n+    PaddingLayout dup(long alignment, Optional<String> name) {\n+        return new PaddingLayout(bitSize(), alignment, name);\n@@ -122,8 +119,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public PaddingLayout withAttribute(String name, Constable value) {\n-        return (PaddingLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/PaddingLayout.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -34,1 +35,0 @@\n-import java.util.Objects;\n@@ -40,1 +40,3 @@\n- * and by the thread associated with the resource scope (if any).\n+ * and by the thread associated with the resource scope (if any). A resource scope can be used as a\n+ * {@linkplain SegmentAllocator segment allocator}; that is, this interface provides many methods which can be\n+ * used to allocate native segments, associated with this scope.\n@@ -42,1 +44,1 @@\n- * <h2>Explicit resource scopes<\/h2>\n+ * <h2>Deterministic deallocation<\/h2>\n@@ -45,3 +47,3 @@\n- * We call these resource scopes <em>explicit scopes<\/em>. Explicit resource scopes can be closed explicitly (see {@link ResourceScope#close()}).\n- * When a resource scope is closed, it is no longer <em>alive<\/em> (see {@link #isAlive()}, and subsequent operations on\n- * resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * Resource scopes can be closed explicitly (see {@link ResourceScope#close()}). When a resource scope is closed,\n+ * it is no longer <em>alive<\/em> (see {@link #isAlive()}), and subsequent operations on resources associated with that scope\n+ * (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n@@ -59,9 +61,0 @@\n- * <p>\n- * Sometimes, explicit scopes can be associated with a {@link Cleaner} instance (see {@link #newConfinedScope(Cleaner)} and\n- * {@link #newSharedScope(Cleaner)}). We call these resource scopes <em>managed<\/em> resource scopes. A managed resource scope\n- * is closed automatically once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * <p>\n- * Managed scopes can be useful to allow for predictable, deterministic resource deallocation, while still prevent accidental native memory leaks.\n- * In case a managed resource scope is closed explicitly, no further action will be taken when the scope becomes unreachable;\n- * that is, cleanup actions (see {@link #addCloseAction(Runnable)}) associated with a resource scope, whether managed or not,\n- * are called <em>exactly once<\/em>.\n@@ -69,1 +62,1 @@\n- * <h2>Implicit resource scopes<\/h2>\n+ * <h2>Implicit deallocation<\/h2>\n@@ -71,4 +64,5 @@\n- * Resource scopes obtained from {@link #newImplicitScope()} cannot be closed explicitly. We call these resource scopes\n- * <em>implicit scopes<\/em>. Calling {@link #close()} on an implicit resource scope always results in an exception.\n- * Resources associated with implicit scopes are released once the scope instance becomes\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * Resource scopes are also closed automatically once the scope instance becomes\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>. This can be useful to allow for predictable,\n+ * deterministic resource deallocation, while still preventing accidental native memory leaks. In case a managed resource scope\n+ * is closed explicitly, no further action will be taken when the scope becomes unreachable; that is, cleanup actions\n+ * (see {@link #addCloseAction(Runnable)}) associated with a resource scope, whether managed or not, are called <em>exactly once<\/em>.\n@@ -76,0 +70,7 @@\n+ * Clients can opt out of implicit deallocation, by passing a {@code null} cleaner parameter to some of the\n+ * {@linkplain #newConfinedScope(Cleaner) scope factories}. This should be done with care: if a scope is not associated\n+ * with a {@linkplain Cleaner cleaner}, it is possible for the resources associated to the scope to never be cleaned up,\n+ * should the scope become unreachable before the {@link #close()} method is called.\n+ *\n+ * <h2>Global scope<\/h2>\n+ *\n@@ -77,1 +78,1 @@\n- * an implicit scope that is guaranteed to never become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * a resource scope that cannot be closed, and that is guaranteed to never become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n@@ -92,1 +93,1 @@\n- * Shared resource scopes (see {@link #newSharedScope()} and {@link #newImplicitScope()}), on the other hand, have no owner thread;\n+ * Shared resource scopes (see {@link #newSharedScope()}), on the other hand, have no owner thread;\n@@ -100,1 +101,0 @@\n-SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n@@ -102,5 +102,5 @@\n-    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n-    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n-        .mapToInt(s -> (int)VH_int.get(s.address()))\n-        .sum();\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n+    MemorySegment segment = scope.allocate(SEQUENCE_LAYOUT);\n+    int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+                        .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n+                        .sum();\n@@ -111,1 +111,1 @@\n- * Explicit shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n+ * Shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n@@ -118,1 +118,1 @@\n- * <h2>Resource scope handles<\/h2>\n+ * <h2>Temporal dependencies<\/h2>\n@@ -120,5 +120,5 @@\n- * Resource scopes can be made <em>non-closeable<\/em> by acquiring one or more resource scope <em>handles<\/em> (see\n- * {@link #acquire()}. A resource scope handle can be used to make sure that resources associated with a given resource scope\n- * (either explicit or implicit) cannot be released for a certain period of time - e.g. during a critical region of code\n- * involving one or more resources associated with the scope. For instance, an explicit resource scope can only be closed\n- * <em>after<\/em> all the handles acquired against that scope have been closed (see {@link Handle#close()}).\n+ * Resource scopes can depend on each other. More specifically, a scope can feature\n+ * {@linkplain #keepAlive(ResourceScope) temporal dependencies} on one or more other resource scopes.\n+ * Such a resource scope cannot be closed (either implicitly or explicitly) until <em>all<\/em> the scopes it is bound to\n+ * have also been closed.\n+ * <p>\n@@ -126,1 +126,1 @@\n- * to ensure that the segment will not be released; this can be done as follows:\n+ * to ensure that the scope associated with that segment will not be closed; this can be done as follows:\n@@ -130,5 +130,3 @@\n-ResourceScope.Handle segmentHandle = segment.scope().acquire()\n-try {\n-   <critical operation on segment>\n-} finally {\n-   segment.scope().release(segmentHandle);\n+try (ResourceScope criticalScope = ResourceScope.newConfinedScope()) {\n+    criticalScope.keepAlive(segment.scope());\n+    <critical operation on segment>\n@@ -138,4 +136,2 @@\n- * Acquiring implicit resource scopes is also possible, but it is often unnecessary: since resources associated with\n- * an implicit scope will only be released when the scope becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n- * clients can use e.g. {@link java.lang.ref.Reference#reachabilityFence(Object)} to make sure that resources associated\n- * with implicit scopes are not released prematurely. That said, the above code snippet works (trivially) for implicit scopes too.\n+ * Note that a resource scope does not become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>\n+ * until all the scopes it depends on have been closed.\n@@ -146,1 +142,1 @@\n-public sealed interface ResourceScope extends AutoCloseable permits ResourceScopeImpl {\n+public sealed interface ResourceScope extends AutoCloseable, SegmentAllocator permits ResourceScopeImpl {\n@@ -161,9 +157,1 @@\n-     * Is this resource scope an <em>implicit scope<\/em>?\n-     * @return true if this scope is an <em>implicit scope<\/em>.\n-     * @see #newImplicitScope()\n-     * @see #globalScope()\n-     *\/\n-    boolean isImplicit();\n-\n-    \/**\n-     * Closes this resource scope. As a side-effect, if this operation completes without exceptions, this scope will be marked\n+     * Closes this resource scope. As a side effect, if this operation completes without exceptions, this scope will be marked\n@@ -183,1 +171,1 @@\n-     *     <li>one or more handles (see {@link #acquire()}) associated with this resource scope have not been {@linkplain #release(Handle) released}<\/li>\n+     *     <li>one or more scopes which {@linkplain #keepAlive(ResourceScope) depend} on this resource scope have not been closed.\n@@ -185,1 +173,1 @@\n-     * @throws UnsupportedOperationException if this resource scope is {@linkplain #isImplicit() implicit}.\n+     * @throws UnsupportedOperationException if this resource scope is the {@linkplain #globalScope() global scope}.\n@@ -193,1 +181,2 @@\n-     * @throws IllegalStateException if this scope has already been closed.\n+     * @throws IllegalStateException if this scope has been closed, or if access occurs from\n+     * a thread other than the thread owning this scope.\n@@ -198,11 +187,7 @@\n-     * Acquires a resource scope handle associated with this resource scope. An explicit resource scope cannot be\n-     * {@linkplain #close() closed} until all the resource scope handles acquired from it have been {@linkplain #release(Handle)} released}.\n-     * @return a resource scope handle.\n-     *\/\n-    Handle acquire();\n-\n-    \/**\n-     * Release the provided resource scope handle. This method is idempotent, that is, releasing the same handle\n-     * multiple times has no effect.\n-     * @param handle the resource scope handle to be released.\n-     * @throws IllegalArgumentException if the provided handle is not associated with this scope.\n+     * Creates a temporal dependency between this scope and the target scope. As a result, the target scope cannot\n+     * be {@linkplain #close() closed} <em>before<\/em> this scope.\n+     * @implNote A given scope can support up to {@link Integer#MAX_VALUE} pending keep alive requests.\n+     * @param target the scope that needs to be kept alive.\n+     * @throws IllegalArgumentException if {@code target == this}.\n+     * @throws IllegalStateException if this scope has been closed, or if access occurs from\n+     * a thread other than the thread owning this scope.\n@@ -210,1 +195,1 @@\n-    void release(Handle handle);\n+    void keepAlive(ResourceScope target);\n@@ -213,4 +198,7 @@\n-     * An abstraction modelling a resource scope handle. A resource scope handle is typically {@linkplain #acquire() acquired} by clients\n-     * in order to prevent an explicit resource scope from being closed while executing a certain operation.\n-     * Once obtained, resource scope handles can be {@linkplain #release(Handle)} released}; an explicit resource scope can\n-     * be closed only <em>after<\/em> all the resource scope handles acquired from it have been released.\n+     * Allocate a native segment with given size and alignment constraint. This is equivalent to:\n+     * <blockquote><pre>{@code\n+    MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+     * }<\/pre><\/blockquote>\n+     * @param bytesSize the size (in bytes) of the native segment to be allocated.\n+     * @param bytesAlignment the alignment (in bytes) of the native segment to be allocated.\n+     * @return a new native segment with given size and alignment.\n@@ -218,8 +206,1 @@\n-    sealed interface Handle permits ResourceScopeImpl.HandleImpl {\n-\n-        \/**\n-         * Returns the resource scope associated with this handle.\n-         * @return the resource scope associated with this handle.\n-         *\/\n-        ResourceScope scope();\n-    }\n+    MemorySegment allocate(long bytesSize, long bytesAlignment);\n@@ -228,1 +209,4 @@\n-     * Create a new confined scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * Create a new confined scope. Equivalent to (but likely more efficient than) the following code:\n+     * <pre>{@code\n+    newConfinedScope(Cleaner.create());\n+     * }<\/pre>\n@@ -232,1 +216,1 @@\n-        return ResourceScopeImpl.createConfined( null);\n+        return ResourceScopeImpl.createConfined( Thread.currentThread(), CleanerFactory.cleaner());\n@@ -236,4 +220,4 @@\n-     * Create a new confined scope managed by a {@link Cleaner}.\n-     * @param cleaner the cleaner to be associated with the returned scope.\n-     * @return a new confined scope, managed by {@code cleaner}.\n-     * @throws NullPointerException if {@code cleaner == null}.\n+     * Create a new confined scope. If {@code cleaner != null}, the resulting scope is managed by the provided\n+     * cleaner instance; otherwise the resulting scope will <em>not<\/em> feature implicit deallocation.\n+     * @param cleaner the cleaner to be associated with the returned scope (can be {@code null}).\n+     * @return a new confined scope, managed by {@code cleaner}, if {@code cleaner != null}.\n@@ -242,2 +226,1 @@\n-        Objects.requireNonNull(cleaner);\n-        return ResourceScopeImpl.createConfined( cleaner);\n+        return ResourceScopeImpl.createConfined(Thread.currentThread(), cleaner);\n@@ -247,1 +230,4 @@\n-     * Create a new shared scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * Create a new shared scope. Equivalent to (but likely more efficient than) the following code:\n+     * <pre>{@code\n+newSharedScope(Cleaner.create());\n+     * }<\/pre>\n@@ -251,1 +237,1 @@\n-        return ResourceScopeImpl.createShared(null);\n+        return ResourceScopeImpl.createShared(CleanerFactory.cleaner());\n@@ -255,4 +241,4 @@\n-     * Create a new shared scope managed by a {@link Cleaner}.\n-     * @param cleaner the cleaner to be associated with the returned scope.\n-     * @return a new shared scope, managed by {@code cleaner}.\n-     * @throws NullPointerException if {@code cleaner == null}.\n+     * Create a new shared scope. If {@code cleaner != null}, the resulting scope is managed by the provided\n+     * cleaner instance; otherwise the resulting scope will <em>not<\/em> feature implicit deallocation.\n+     * @param cleaner the cleaner to be associated with the returned scope (can be {@code null}).\n+     * @return a new shared scope, managed by {@code cleaner}, if {@code cleaner != null}.\n@@ -261,1 +247,0 @@\n-        Objects.requireNonNull(cleaner);\n@@ -265,13 +250,0 @@\n-    \/**\n-     * Create a new <em>implicit scope<\/em>. The implicit scope is a managed, shared, and non-closeable scope which only features\n-     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>.\n-     * Since implicit scopes can only be closed implicitly by the garbage collector, it is recommended that implicit\n-     * scopes are only used in cases where deallocation performance is not a critical concern, to avoid unnecessary\n-     * memory pressure.\n-     *\n-     * @return a new implicit scope.\n-     *\/\n-    static ResourceScope newImplicitScope() {\n-        return ResourceScopeImpl.createImplicitScope();\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":82,"deletions":110,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -35,0 +34,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -37,1 +37,0 @@\n-import java.util.stream.Stream;\n@@ -47,13 +46,2 @@\n- * This interface provides a factory, namely {@link SegmentAllocator#ofScope(ResourceScope)} which can be used to obtain\n- * a <em>scoped<\/em> allocator, that is, an allocator which creates segment bound by a given scope. This can be useful\n- * when working inside a <em>try-with-resources<\/em> construct:\n- *\n- * <blockquote><pre>{@code\n-try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-   SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-   ...\n-}\n- * }<\/pre><\/blockquote>\n- *\n- * In addition, this interface also defines factories for commonly used allocators; for instance {@link #arenaAllocator(ResourceScope)}\n- * and {@link #arenaAllocator(long, ResourceScope)} are arena-style native allocators. Finally {@link #ofSegment(MemorySegment)}\n+ * This interface also defines factories for commonly used allocators; for instance {@link #arenaAllocator(ResourceScope)}\n+ * and {@link #arenaAllocator(long, ResourceScope)} are arena-style native allocators. Finally {@link #prefixAllocator(MemorySegment)}\n@@ -65,0 +53,17 @@\n+    \/**\n+     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n+     * storing the result into a native memory segment allocated using the provided allocator.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native memory segment containing the converted C string.\n+     *\/\n+    default MemorySegment allocateUtf8String(String str) {\n+        Objects.requireNonNull(str);\n+        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+    }\n+\n@@ -71,1 +76,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.\n@@ -73,1 +77,1 @@\n-    default MemorySegment allocate(ValueLayout layout, byte value) {\n+    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n@@ -75,1 +79,1 @@\n-        VarHandle handle = layout.varHandle(byte.class);\n+        VarHandle handle = layout.varHandle();\n@@ -87,1 +91,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a char value.\n@@ -89,1 +92,1 @@\n-    default MemorySegment allocate(ValueLayout layout, char value) {\n+    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n@@ -91,1 +94,1 @@\n-        VarHandle handle = layout.varHandle(char.class);\n+        VarHandle handle = layout.varHandle();\n@@ -103,1 +106,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.\n@@ -105,1 +107,1 @@\n-    default MemorySegment allocate(ValueLayout layout, short value) {\n+    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n@@ -107,1 +109,1 @@\n-        VarHandle handle = layout.varHandle(short.class);\n+        VarHandle handle = layout.varHandle();\n@@ -119,1 +121,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.\n@@ -121,1 +122,1 @@\n-    default MemorySegment allocate(ValueLayout layout, int value) {\n+    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n@@ -123,1 +124,1 @@\n-        VarHandle handle = layout.varHandle(int.class);\n+        VarHandle handle = layout.varHandle();\n@@ -135,1 +136,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.\n@@ -137,1 +137,1 @@\n-    default MemorySegment allocate(ValueLayout layout, float value) {\n+    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n@@ -139,1 +139,1 @@\n-        VarHandle handle = layout.varHandle(float.class);\n+        VarHandle handle = layout.varHandle();\n@@ -151,1 +151,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.\n@@ -153,1 +152,1 @@\n-    default MemorySegment allocate(ValueLayout layout, long value) {\n+    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n@@ -155,1 +154,1 @@\n-        VarHandle handle = layout.varHandle(long.class);\n+        VarHandle handle = layout.varHandle();\n@@ -167,1 +166,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.\n@@ -169,1 +167,1 @@\n-    default MemorySegment allocate(ValueLayout layout, double value) {\n+    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n@@ -171,1 +169,1 @@\n-        VarHandle handle = layout.varHandle(double.class);\n+        VarHandle handle = layout.varHandle();\n@@ -180,1 +178,1 @@\n-     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * The address value might be narrowed according to the platform address size (see {@link ValueLayout#ADDRESS}).\n@@ -185,1 +183,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n@@ -187,1 +184,1 @@\n-    default MemorySegment allocate(ValueLayout layout, Addressable value) {\n+    default MemorySegment allocate(ValueLayout.OfAddress layout, Addressable value) {\n@@ -190,8 +187,3 @@\n-        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        return switch ((int)layout.byteSize()) {\n-            case 4 -> allocate(layout, (int)value.address().toRawLongValue());\n-            case 8 -> allocate(layout, value.address().toRawLongValue());\n-            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        };\n+        MemorySegment segment = allocate(layout);\n+        layout.varHandle().set(segment, value.address());\n+        return segment;\n@@ -206,1 +198,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.\n@@ -208,1 +199,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte[] array) {\n@@ -218,1 +209,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.\n@@ -220,1 +210,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short[] array) {\n@@ -230,1 +220,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.\n@@ -232,1 +221,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char[] array) {\n@@ -242,1 +231,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.\n@@ -244,1 +232,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int[] array) {\n@@ -254,1 +242,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.\n@@ -256,1 +243,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float[] array) {\n@@ -266,1 +253,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.\n@@ -268,1 +254,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long[] array) {\n@@ -278,1 +264,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.\n@@ -280,1 +265,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfDouble elementLayout, double[] array) {\n@@ -284,27 +269,0 @@\n-    \/**\n-     * Allocate a block of memory with given layout and initialize it with given address array.\n-     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n-     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, Addressable[] array) {\n-        Objects.requireNonNull(elementLayout);\n-        Objects.requireNonNull(array);\n-        Stream.of(array).forEach(Objects::requireNonNull);\n-        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        return switch ((int)elementLayout.byteSize()) {\n-            case 4 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToInt(a -> (int)a.address().toRawLongValue()).toArray(),\n-                    elementLayout, MemorySegment::ofArray);\n-            case 8 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToLong(a -> a.address().toRawLongValue()).toArray(),\n-                    elementLayout, MemorySegment::ofArray);\n-            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        };\n-    }\n-\n@@ -315,3 +273,4 @@\n-        Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(Array.getLength(array), elementLayout));\n-        addr.copyFrom(elementLayout, heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()));\n+        int size = Array.getLength(array);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout));\n+        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n+                addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n@@ -430,1 +389,2 @@\n-     * constraints are ignored by this allocator). This can be useful to limit allocation requests in case a client\n+     * constraints are ignored by this allocator), hence the name <em>prefix allocator<\/em>.\n+     * This allocator can be useful to limit allocation requests in case a client\n@@ -440,1 +400,1 @@\n-    static SegmentAllocator ofSegment(MemorySegment segment) {\n+    static SegmentAllocator prefixAllocator(MemorySegment segment) {\n@@ -445,16 +405,0 @@\n-    \/**\n-     * Returns a native allocator which responds to allocation requests by allocating new segments\n-     * bound by the given resource scope, using the {@link MemorySegment#allocateNative(long, long, ResourceScope)}\n-     * factory. This code is equivalent (but likely more efficient) to the following:\n-     * <blockquote><pre>{@code\n-    Resource scope = ...\n-    SegmentAllocator scoped = (size, align) -> MemorySegment.allocateNative(size, align, scope);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param scope the resource scope associated with the segments created by the returned allocator.\n-     * @return an allocator which allocates new memory segment bound by the provided resource scope.\n-     *\/\n-    static SegmentAllocator ofScope(ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (ResourceScopeImpl)scope;\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":53,"deletions":109,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Map;\n@@ -38,1 +36,1 @@\n- * The repetition count, where it exists (e.g. for <em>finite<\/em> sequence layouts) is said to be the the sequence layout's <em>element count<\/em>.\n+ * The repetition count, where it exists (e.g. for <em>finite<\/em> sequence layouts) is said to be the sequence layout's <em>element count<\/em>.\n@@ -43,1 +41,1 @@\n-MemoryLayout.sequenceLayout(3, MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n+MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -50,3 +48,3 @@\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -75,1 +73,1 @@\n-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Map.of());\n+        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n@@ -78,1 +76,1 @@\n-    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Map<String, Constable> attributes) {\n+    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Optional<String> name) {\n@@ -81,1 +79,1 @@\n-                OptionalLong.empty(), alignment, attributes);\n+                OptionalLong.empty(), alignment, name);\n@@ -113,1 +111,1 @@\n-        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, attributes);\n+        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, name());\n@@ -125,1 +123,1 @@\n-    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n@@ -129,1 +127,1 @@\n-    var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, MemoryLayouts.JAVA_INT));\n+    var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, ValueLayout.JAVA_INT));\n@@ -154,1 +152,1 @@\n-        if (!elementCount().isPresent()) {\n+        if (elementCount().isEmpty()) {\n@@ -201,1 +199,1 @@\n-    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n@@ -205,1 +203,1 @@\n-    var flattenedSeq = MemoryLayout.sequenceLayout(12, MemoryLayouts.JAVA_INT);\n+    var flattenedSeq = MemoryLayout.sequenceLayout(12, ValueLayout.JAVA_INT);\n@@ -213,1 +211,1 @@\n-        if (!elementCount().isPresent()) {\n+        if (elementCount().isEmpty()) {\n@@ -218,2 +216,1 @@\n-        while (elemLayout instanceof SequenceLayout) {\n-            SequenceLayout elemSeq = (SequenceLayout)elemLayout;\n+        while (elemLayout instanceof SequenceLayout elemSeq) {\n@@ -244,1 +241,1 @@\n-        if (!(other instanceof SequenceLayout)) {\n+        if (!(other instanceof SequenceLayout s)) {\n@@ -247,1 +244,0 @@\n-        SequenceLayout s = (SequenceLayout)other;\n@@ -257,2 +253,2 @@\n-    SequenceLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new SequenceLayout(elementCount(), elementLayout, alignment, attributes);\n+    SequenceLayout dup(long alignment, Optional<String> name) {\n+        return new SequenceLayout(elementCount(), elementLayout, alignment, name);\n@@ -293,8 +289,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public SequenceLayout withAttribute(String name, Constable value) {\n-        return (SequenceLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","additions":19,"deletions":31,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * A symbol lookup can be used to lookup a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n+ * A symbol lookup can be used to look up a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n@@ -40,2 +40,2 @@\n- * Alternatively, clients can obtain a {@linkplain CLinker#systemLookup() platform-dependent lookup}, to search symbols\n- * in the standard C library.\n+ * Alternatively, clients can search symbols in the standard C library using a {@link CLinker}, which conveniently\n+ * implements this interface.\n@@ -52,1 +52,1 @@\n-     * @return the memory address associated with the symbol (if any).\n+     * @return the symbol (if any).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n+import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n+import jdk.internal.foreign.abi.x64.windows.WinVaList;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * An interface that models a C {@code va_list}.\n+ * <p>\n+ * A va list is a stateful cursor used to iterate over a set of variadic arguments. A va list can be passed\n+ * by reference e.g. to a downcall method handle.\n+ * <p>\n+ * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n+ * arguments to variadic calls are erased by way of 'default argument promotions',\n+ * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n+ * and which erases all {@code float} arguments to {@code double}.\n+ * <p>\n+ * As such, this interface only supports reading {@code int}, {@code double},\n+ * and any other type that fits into a {@code long}.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\/\n+sealed public interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n+\n+    \/**\n+     * Reads the next value as an {@code int} and advances this va list's position.\n+     *\n+     * @param layout the layout of the value\n+     * @return the value read as an {@code int}\n+     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+     * (see {@link #scope()}).\n+     *\/\n+    int nextVarg(ValueLayout.OfInt layout);\n+\n+    \/**\n+     * Reads the next value as a {@code long} and advances this va list's position.\n+     *\n+     * @param layout the layout of the value\n+     * @return the value read as an {@code long}\n+     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+     * (see {@link #scope()}).\n+     *\/\n+    long nextVarg(ValueLayout.OfLong layout);\n+\n+    \/**\n+     * Reads the next value as a {@code double} and advances this va list's position.\n+     *\n+     * @param layout the layout of the value\n+     * @return the value read as an {@code double}\n+     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+     * (see {@link #scope()}).\n+     *\/\n+    double nextVarg(ValueLayout.OfDouble layout);\n+\n+    \/**\n+     * Reads the next value as a {@code MemoryAddress} and advances this va list's position.\n+     *\n+     * @param layout the layout of the value\n+     * @return the value read as an {@code MemoryAddress}\n+     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+     * (see {@link #scope()}).\n+     *\/\n+    MemoryAddress nextVarg(ValueLayout.OfAddress layout);\n+\n+    \/**\n+     * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n+     * <p>\n+     * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n+     *\n+     * @param layout the layout of the value\n+     * @param allocator the allocator to be used for the native segment allocation\n+     * @return the value read as an {@code MemorySegment}\n+     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+     * (see {@link #scope()}).\n+     *\/\n+    MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator);\n+\n+    \/**\n+     * Skips a number of elements with the given memory layouts, and advances this va list's position.\n+     *\n+     * @param layouts the layout of the value\n+     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+     * (see {@link #scope()}).\n+     *\/\n+    void skip(MemoryLayout... layouts);\n+\n+    \/**\n+     * Returns the resource scope associated with this instance.\n+     * @return the resource scope associated with this instance.\n+     *\/\n+    ResourceScope scope();\n+\n+    \/**\n+     * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n+     * starting from the current position, without affecting the state of the original va list, essentially\n+     * allowing the elements to be traversed multiple times.\n+     * <p>\n+     * Any native resource required by the execution of this method will be allocated in the resource scope\n+     * associated with this instance (see {@link #scope()}).\n+     * <p>\n+     * This method only copies the va list cursor itself and not the memory that may be attached to the\n+     * va list which holds its elements. That means that if this va list was created with the\n+     * {@link #make(Consumer, ResourceScope)} method, closing this va list will also release the native memory that holds its\n+     * elements, making the copy unusable.\n+     *\n+     * @return a copy of this C {@code va_list}.\n+     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+     * (see {@link #scope()}).\n+     *\/\n+    VaList copy();\n+\n+    \/**\n+     * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param address a memory address pointing to an existing C {@code va_list}.\n+     * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static VaList ofAddress(MemoryAddress address) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return SharedUtils.newVaListOfAddress(address, ResourceScope.globalScope());\n+    }\n+\n+    \/**\n+     * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n+     * with given resource scope.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param address a memory address pointing to an existing C {@code va_list}.\n+     * @param scope the resource scope to be associated with the returned {@code VaList} instance.\n+     * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaListOfAddress(address, scope);\n+    }\n+\n+    \/**\n+     * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a given\n+     * {@linkplain ResourceScope resource scope}.\n+     * <p>\n+     * If this method needs to allocate native memory, such memory will be managed by the given\n+     * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n+     * <p>\n+     * Note that when there are no elements added to the created va list,\n+     * this method will return the same as {@link #empty()}.\n+     *\n+     * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n+     *                of the underlying C {@code va_list}.\n+     * @param scope the scope to be used for the valist allocation.\n+     * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     *\/\n+    static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n+        Objects.requireNonNull(actions);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaList(actions, scope);\n+    }\n+\n+    \/**\n+     * Returns an empty C {@code va_list} constant.\n+     * <p>\n+     * The returned {@code VaList} can not be closed.\n+     *\n+     * @return a {@code VaList} modelling an empty C {@code va_list}.\n+     *\/\n+    static VaList empty() {\n+        return SharedUtils.emptyVaList();\n+    }\n+\n+    \/**\n+     * A builder interface used to construct a C {@code va_list}.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+     *\/\n+    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n+\n+        \/**\n+         * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.\n+         *\n+         * @param layout the native layout of the value.\n+         * @param value the value, represented as an {@code int}.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfInt layout, int value);\n+\n+        \/**\n+         * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.\n+         *\n+         * @param layout the native layout of the value.\n+         * @param value the value, represented as a {@code long}.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfLong layout, long value);\n+\n+        \/**\n+         * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.\n+         *\n+         * @param layout the native layout of the value.\n+         * @param value the value, represented as a {@code double}.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfDouble layout, double value);\n+\n+        \/**\n+         * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.\n+         *\n+         * @param layout the native layout of the value.\n+         * @param value the value, represented as a {@code Addressable}.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfAddress layout, Addressable value);\n+\n+        \/**\n+         * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.\n+         *\n+         * @param layout the native layout of the value.\n+         * @param value the value, represented as a {@code MemorySegment}.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(GroupLayout layout, MemorySegment value);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -28,2 +28,8 @@\n-import java.lang.constant.Constable;\n-import java.lang.constant.ConstantDescs;\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n@@ -31,0 +37,3 @@\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.VarHandle;\n@@ -32,1 +41,0 @@\n-import java.util.Map;\n@@ -37,0 +45,3 @@\n+import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n+import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n+\n@@ -39,2 +50,8 @@\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size and a byte order (see {@link ByteOrder}).\n- *\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, a {@linkplain ByteOrder byte order})\n+ * and a <em>carrier<\/em>, that is, the Java type that should be used when {@linkplain MemorySegment#get(OfInt, long) accessing}\n+ * a memory region using the value layout.\n+ * <p>\n+ * This class defines useful value layout constants for Java primitive types and addresses.\n+ * The layout constants in this class make implicit alignment and byte-ordering assumption: all layout\n+ * constants in this class are byte-aligned, and their byte order is set to the {@linkplain ByteOrder#nativeOrder() platform default},\n+ * thus making it easy to work with other APIs, such as arrays and {@link java.nio.ByteBuffer}.\n@@ -55,1 +72,1 @@\n-public final class ValueLayout extends AbstractLayout implements MemoryLayout {\n+public sealed class ValueLayout extends AbstractLayout implements MemoryLayout {\n@@ -57,0 +74,1 @@\n+    private final Class<?> carrier;\n@@ -59,2 +77,2 @@\n-    ValueLayout(ByteOrder order, long size) {\n-        this(order, size, size, Map.of());\n+    ValueLayout(Class<?> carrier, ByteOrder order, long size) {\n+        this(carrier, order, size, size, Optional.empty());\n@@ -63,2 +81,3 @@\n-    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n-        super(OptionalLong.of(size), alignment, attributes);\n+    ValueLayout(Class<?> carrier, ByteOrder order, long size, long alignment, Optional<String> name) {\n+        super(OptionalLong.of(size), alignment, name);\n+        this.carrier = carrier;\n@@ -66,0 +85,1 @@\n+        checkCarrierSize(carrier, size);\n@@ -84,1 +104,1 @@\n-        return new ValueLayout(Objects.requireNonNull(order), bitSize(), alignment, attributes);\n+        return new ValueLayout(carrier, Objects.requireNonNull(order), bitSize(), alignment, name());\n@@ -102,1 +122,1 @@\n-        if (!(other instanceof ValueLayout)) {\n+        if (!(other instanceof ValueLayout v)) {\n@@ -105,2 +125,2 @@\n-        ValueLayout v = (ValueLayout)other;\n-        return order.equals(v.order) &&\n+        return carrier.equals(v.carrier) &&\n+            order.equals(v.order) &&\n@@ -111,0 +131,8 @@\n+    \/**\n+     * Returns the carrier associated with this value layout.\n+     * @return the carrier associated with this value layout.\n+     *\/\n+    public Class<?> carrier() {\n+        return carrier;\n+    }\n+\n@@ -117,2 +145,2 @@\n-    ValueLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new ValueLayout(order, bitSize(), alignment, attributes);\n+    ValueLayout dup(long alignment, Optional<String> name) {\n+        return new ValueLayout(carrier, order, bitSize(), alignment, name());\n@@ -123,2 +151,14 @@\n-        return Optional.of(decorateLayoutConstant(DynamicConstantDesc.ofNamed(ConstantDescs.BSM_INVOKE, \"value\",\n-                CD_VALUE_LAYOUT, MH_VALUE, bitSize(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));\n+        ClassDesc THIS_DESC = getClass().describeConstable().get();\n+        DynamicConstantDesc<ValueLayout> desc = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, specializedConstantName(), THIS_DESC, CD_VALUE_LAYOUT);\n+        if (order != ByteOrder.nativeOrder()) {\n+            MethodHandleDesc MH_WITH_ORDER = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, THIS_DESC, \"withOrder\",\n+                    MethodTypeDesc.of(THIS_DESC, CD_BYTEORDER));\n+\n+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withOrder\", desc.constantType(), MH_WITH_ORDER,\n+                    desc, order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN);\n+        }\n+        return Optional.of(decorateLayoutConstant(desc));\n+    }\n+\n+    String specializedConstantName() {\n+        throw new IllegalStateException();\n@@ -146,0 +186,38 @@\n+    static void checkCarrierSize(Class<?> carrier, long size) {\n+        if (!isValidCarrier(carrier)) {\n+            throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n+        }\n+        if (carrier == void.class) return;\n+        if (carrier == MemoryAddress.class && size != (Unsafe.ADDRESS_SIZE * 8)) {\n+            throw new IllegalArgumentException(\"Address size mismatch: \" + (Unsafe.ADDRESS_SIZE * 8) + \" != \" + size);\n+        }\n+        if (carrier.isPrimitive() && Wrapper.forPrimitiveType(carrier).bitWidth() != size &&\n+                carrier != boolean.class && size != 8) {\n+            throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+        }\n+    }\n+\n+    static boolean isValidCarrier(Class<?> carrier) {\n+        return carrier == void.class\n+                || carrier == boolean.class\n+                || carrier == byte.class\n+                || carrier == short.class\n+                || carrier == char.class\n+                || carrier == int.class\n+                || carrier == long.class\n+                || carrier == float.class\n+                || carrier == double.class\n+                || carrier == MemoryAddress.class;\n+    }\n+\n+    @Stable\n+    private VarHandle handle;\n+\n+    @ForceInline\n+    VarHandle accessHandle() {\n+        if (handle == null) {\n+            handle = Utils.makeMemoryAccessVarHandle(carrier, false, byteAlignment() - 1, order());\n+        }\n+        return handle;\n+    }\n+\n@@ -147,1 +225,1 @@\n-     * {@inheritDoc}\n+     * A value layout whose carrier is {@code boolean.class}.\n@@ -149,3 +227,34 @@\n-    @Override\n-    public ValueLayout withAttribute(String name, Constable value) {\n-        return (ValueLayout)super.withAttribute(name, value);\n+    public static final class OfBoolean extends ValueLayout {\n+        OfBoolean(ByteOrder order) {\n+            super(boolean.class, order, 8);\n+        }\n+\n+        OfBoolean(ByteOrder order, long alignment, Optional<String> name) {\n+            super(boolean.class, order, 8, alignment, name);\n+        }\n+\n+        @Override\n+        OfBoolean dup(long alignment, Optional<String> name) {\n+            return new OfBoolean(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfBoolean withName(String name) {\n+            return (OfBoolean)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfBoolean withBitAlignment(long alignmentBits) {\n+            return (OfBoolean)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfBoolean withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfBoolean(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_BOOLEAN\";\n+        }\n@@ -153,0 +262,367 @@\n+\n+    \/**\n+     * A value layout whose carrier is {@code byte.class}.\n+     *\/\n+    public static final class OfByte extends ValueLayout {\n+        OfByte(ByteOrder order) {\n+            super(byte.class, order, 8);\n+        }\n+\n+        OfByte(ByteOrder order, long alignment, Optional<String> name) {\n+            super(byte.class, order, 8, alignment, name);\n+        }\n+\n+        @Override\n+        OfByte dup(long alignment, Optional<String> name) {\n+            return new OfByte(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfByte withName(String name) {\n+            return (OfByte)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfByte withBitAlignment(long alignmentBits) {\n+            return (OfByte)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfByte withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfByte(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_BYTE\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code char.class}.\n+     *\/\n+    public static final class OfChar extends ValueLayout {\n+        OfChar(ByteOrder order) {\n+            super(char.class, order, 16);\n+        }\n+\n+        OfChar(ByteOrder order, long alignment, Optional<String> name) {\n+            super(char.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfChar dup(long alignment, Optional<String> name) {\n+            return new OfChar(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfChar withName(String name) {\n+            return (OfChar)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfChar withBitAlignment(long alignmentBits) {\n+            return (OfChar)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfChar withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfChar(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_CHAR\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code short.class}.\n+     *\/\n+    public static final class OfShort extends ValueLayout {\n+        OfShort(ByteOrder order) {\n+            super(short.class, order, 16);\n+        }\n+\n+        OfShort(ByteOrder order, long alignment, Optional<String> name) {\n+            super(short.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfShort dup(long alignment, Optional<String> name) {\n+            return new OfShort(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfShort withName(String name) {\n+            return (OfShort)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfShort withBitAlignment(long alignmentBits) {\n+            return (OfShort)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfShort withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfShort(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_SHORT\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code int.class}.\n+     *\/\n+    public static final class OfInt extends ValueLayout {\n+        OfInt(ByteOrder order) {\n+            super(int.class, order, 32);\n+        }\n+\n+        OfInt(ByteOrder order, long alignment, Optional<String> name) {\n+            super(int.class, order, 32, alignment, name);\n+        }\n+\n+        @Override\n+        OfInt dup(long alignment, Optional<String> name) {\n+            return new OfInt(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfInt withName(String name) {\n+            return (OfInt)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfInt withBitAlignment(long alignmentBits) {\n+            return (OfInt)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfInt withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfInt(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_INT\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code float.class}.\n+     *\/\n+    public static final class OfFloat extends ValueLayout {\n+        OfFloat(ByteOrder order) {\n+            super(float.class, order, 32);\n+        }\n+\n+        OfFloat(ByteOrder order, long alignment, Optional<String> name) {\n+            super(float.class, order, 32, alignment, name);\n+        }\n+\n+        @Override\n+        OfFloat dup(long alignment, Optional<String> name) {\n+            return new OfFloat(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfFloat withName(String name) {\n+            return (OfFloat)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfFloat withBitAlignment(long alignmentBits) {\n+            return (OfFloat)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfFloat withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfFloat(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_FLOAT\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code long.class}.\n+     *\/\n+    public static final class OfLong extends ValueLayout {\n+        OfLong(ByteOrder order) {\n+            super(long.class, order, 64);\n+        }\n+\n+        OfLong(ByteOrder order, long alignment, Optional<String> name) {\n+            super(long.class, order, 64, alignment, name);\n+        }\n+\n+        @Override\n+        OfLong dup(long alignment, Optional<String> name) {\n+            return new OfLong(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfLong withName(String name) {\n+            return (OfLong)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfLong withBitAlignment(long alignmentBits) {\n+            return (OfLong)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfLong withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfLong(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_LONG\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code double.class}.\n+     *\/\n+    public static final class OfDouble extends ValueLayout {\n+        OfDouble(ByteOrder order) {\n+            super(double.class, order, 64);\n+        }\n+\n+        OfDouble(ByteOrder order, long alignment, Optional<String> name) {\n+            super(double.class, order, 64, alignment, name);\n+        }\n+\n+        @Override\n+        OfDouble dup(long alignment, Optional<String> name) {\n+            return new OfDouble(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfDouble withName(String name) {\n+            return (OfDouble)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfDouble withBitAlignment(long alignmentBits) {\n+            return (OfDouble)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfDouble withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfDouble(order, alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"JAVA_DOUBLE\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code MemoryAddress.class}.\n+     *\/\n+    public static final class OfAddress extends ValueLayout {\n+        OfAddress(ByteOrder order, long size) {\n+            super(MemoryAddress.class, order, size);\n+        }\n+\n+        OfAddress(ByteOrder order, long size, long alignment, Optional<String> name) {\n+            super(MemoryAddress.class, order, size, alignment, name);\n+        }\n+\n+        @Override\n+        OfAddress dup(long alignment, Optional<String> name) {\n+            return new OfAddress(order(), bitSize(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfAddress withName(String name) {\n+            return (OfAddress)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfAddress withBitAlignment(long alignmentBits) {\n+            return (OfAddress)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfAddress withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfAddress(order, bitSize(), alignment, name());\n+        }\n+\n+        @Override\n+        String specializedConstantName() {\n+            return \"ADDRESS\";\n+        }\n+    }\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}),\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder(), Unsafe.ADDRESS_SIZE * 8).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code byte},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code boolean},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code char},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code short},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code int},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code long},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder())\n+            .withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code float},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code double},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder()).withBitAlignment(8);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":498,"deletions":22,"binary":false,"changes":520,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n- * The key abstractions introduced to support foreign memory access are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.\n- * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which also can\n- * reside either inside or outside the Java heap (and can sometimes be expressed as an offset into a given segment).\n+ * The main abstractions introduced to support foreign memory access is {@link jdk.incubator.foreign.MemorySegment}, which\n+ * models a contiguous memory region, which can reside either inside or outside the Java heap.\n@@ -38,1 +37,1 @@\n- * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * common dereference and copy operations is provided also by the {@link jdk.incubator.foreign.MemorySegment} class, which can\n@@ -48,1 +47,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newImplicitScope());\n+MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newConfinedScope());\n@@ -50,1 +49,1 @@\n-   MemoryAccess.setIntAtIndex(segment, i, 42);\n+   segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n@@ -54,1 +53,1 @@\n- * Here create a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n@@ -57,3 +56,6 @@\n- * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n- * more specifically, if we view the memory segment as a set of 10 adjacent slots,\n- * {@code s[i]}, where {@code 0 <= i < 10}, where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n+ * {@link jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int)} dereference method. Note how\n+ * the dereference method accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout},\n+ * which specifies the size, alignment constraints, byte order as well\n+ * as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * if we view the memory segment as a set of 10 adjacent slots, {@code s[i]}, where {@code 0 <= i < 10},\n+ * where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n@@ -73,1 +75,1 @@\n-    MemorySegment segment = MemorySegment.allocateNative(10 * 4, scope);\n+    MemorySegment segment = scope.allocate(10 * 4);\n@@ -75,1 +77,1 @@\n-        MemoryAccess.setIntAtIndex(segment, i, 42);\n+        segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n@@ -84,0 +86,2 @@\n+ * Since a resource scope acts as a {@link jdk.incubator.foreign.SegmentAllocator segment allocators}, we can also\n+ * allocate the native memory segment more directly, through the scope.\n@@ -99,3 +103,4 @@\n- * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup} and {@link jdk.incubator.foreign.CLinker}.\n- * The former is used to lookup symbols inside native libraries; the latter\n- * provides linking capabilities which allow to model foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup},\n+ * {@link jdk.incubator.foreign.MemoryAddress} and {@link jdk.incubator.foreign.CLinker}.\n+ * The first is used to lookup symbols inside native libraries; the second is used to model native addresses (more on that later),\n+ * while the third provides linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -109,4 +114,4 @@\n-      MethodHandle strlen = CLinker.getInstance().downcallHandle(\n-        CLinker.systemLookup().lookup(\"strlen\").get(),\n-        MethodType.methodType(long.class, MemoryAddress.class),\n-        FunctionDescriptor.of(CLinker.C_LONG, CLinker.C_POINTER)\n+      var linker = CLinker.systemCLinker();\n+      MethodHandle strlen = linker.downcallHandle(\n+        linker.lookup(\"strlen\").get(),\n+        FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n@@ -116,2 +121,2 @@\n-         var cString = CLinker.toCString(\"Hello\", scope);\n-         long len = (long)strlen.invokeExact(cString.address()); \/\/ 5\n+         var cString = scope.allocateUtf8String(\"Hello\");\n+         long len = (long)strlen.invoke(cString); \/\/ 5\n@@ -121,12 +126,13 @@\n- * Here, we lookup the {@code strlen} symbol in the {@linkplain jdk.incubator.foreign.CLinker#systemLookup() system lookup}.\n- * Then, we obtain a linker instance (see {@link jdk.incubator.foreign.CLinker#getInstance()}) and we use it to\n- * obtain a method handle which targets the {@code strlen} library symbol. To complete the linking successfully,\n- * we must provide (i) a {@link java.lang.invoke.MethodType} instance, describing the type of the resulting method handle\n- * and (ii) a {@link jdk.incubator.foreign.FunctionDescriptor} instance, describing the signature of the {@code strlen}\n- * function. From this information, the linker will uniquely determine the sequence of steps which will turn\n- * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n- * into a foreign function call, according to the rules specified by the platform C ABI. The {@link jdk.incubator.foreign.CLinker}\n- * class also provides many useful methods for interacting with native code, such as converting Java strings into\n- * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String, ResourceScope)} and\n- * {@link jdk.incubator.foreign.CLinker#toJavaString(jdk.incubator.foreign.MemorySegment)}, respectively), as\n- * demonstrated in the above example.\n+ * Here, we obtain a {@linkplain jdk.incubator.foreign.CLinker#systemCLinker() linker instance} and we use it\n+ * to {@linkplain jdk.incubator.foreign.CLinker#lookup(java.lang.String) lookup} the {@code strlen} symbol in the\n+ * standard C library; a <em>downcall method handle<\/em> targeting said symbol is subsequently\n+ * {@linkplain jdk.incubator.foreign.CLinker#downcallHandle(jdk.incubator.foreign.FunctionDescriptor) obtained}.\n+ * To complete the linking successfully, we must provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance,\n+ * describing the signature of the {@code strlen} function.\n+ * From this information, the linker will uniquely determine the sequence of steps which will turn\n+ * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invoke(java.lang.Object...)})\n+ * into a foreign function call, according to the rules specified by the platform C ABI.\n+ * The {@link jdk.incubator.foreign.MemorySegment} class also provides many useful methods for\n+ * interacting with native code, such as converting Java strings into native strings and back\n+ * (see {@link jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String)} and\n+ * {@link jdk.incubator.foreign.MemorySegment#getUtf8String(long)}, respectively), as demonstrated in the above example.\n@@ -141,7 +147,4 @@\n- * When clients receive a {@link jdk.incubator.foreign.MemoryAddress} instance from a foreign function call, it might be\n- * necessary to obtain a {@link jdk.incubator.foreign.MemorySegment} instance to dereference the memory pointed to by that address.\n- * To do that, clients can proceed in three different ways, described below.\n- * <p>\n- * First, if the memory address is known to belong to a segment the client already owns, a <em>rebase<\/em> operation can be performed;\n- * in other words, the client can ask the address what its offset relative to a given segment is, and, then, proceed to dereference\n- * the original segment accordingly, as follows:\n+ * Raw pointers are modelled using the {@link jdk.incubator.foreign.MemoryAddress} class. When clients receive a\n+ * memory address instance from a foreign function call, they can perform memory dereference on it directly,\n+ * using one of the many <em>unsafe<\/em> dereference methods provided\n+ * (see {@link jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long)}):\n@@ -150,1 +153,0 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, scope);\n@@ -153,1 +155,1 @@\n-int x = MemoryAccess.getIntAtOffset(segment, addr.segmentOffset(segment));\n+int x = addr.get(ValueLayout.JAVA_INT, 0);\n@@ -156,3 +158,3 @@\n- * Secondly, if the client does <em>not<\/em> have a segment which contains a given memory address, it can create one <em>unsafely<\/em>,\n- * using the {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} factory. This allows the client to\n- * inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n+ * Alternatively, the client can create a memory segment <em>unsafely<\/em>, using the\n+ * {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)} factory.\n+ * This allows the client to inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n@@ -164,11 +166,2 @@\n-MemorySegment segment = addr.asSegment(4, scope); \/\/ segment is 4 bytes long\n-int x = MemoryAccess.getInt(segment);\n- * }<\/pre>\n- *\n- * Alternatively, the client can fall back to use the so called <em>everything<\/em> segment - that is, a primordial segment\n- * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#globalNativeSegment()}\n- * method, so that dereference can happen without the need of creating any additional segment instances:\n- *\n- * <pre>{@code\n-MemoryAddress addr = ... \/\/obtain address from native code\n-int x = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+MemorySegment segment = MemorySegment.ofAddressNative(addr, 4, scope); \/\/ segment is 4 bytes long\n+int x = segment.get(ValueLayout.JAVA_INT, 0);\n@@ -179,3 +172,2 @@\n- * to a Java method) into a native memory address (see {@link jdk.incubator.foreign.MemoryAddress}), so that Java code\n- * can effectively be passed to other foreign functions. For instance, we can write a method that compares two\n- * integer values, as follows:\n+ * to a Java method) into a memory address, so that Java code can effectively be passed to other foreign functions.\n+ * For instance, we can write a method that compares two integer values, as follows:\n@@ -186,2 +178,1 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) -\n-               MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n+        return addr1.get(ValueLayout.JAVA_INT, 0) - addr2.get(ValueLayout.JAVA_INT, 0);\n@@ -206,1 +197,1 @@\n-MemoryAddress comparFunc = CLinker.getInstance().upcallStub(\n+Addressable comparFunc = CLinker.systemCLinker().upcallStub(\n@@ -208,1 +199,1 @@\n-     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+     FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS),\n@@ -214,3 +205,3 @@\n- * of the function pointer we want to create; as before, this, coupled with the method handle type, uniquely determines the\n- * sequence of steps which will allow foreign code to call {@code intCompareHandle} according to the rules specified\n- * by the platform C ABI. The lifecycle of the memory address returned by\n+ * of the function pointer we want to create; this descriptor allows the linker to determine the\n+ * sequence of steps which allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified\n+ * by the platform C ABI. The lifecycle of the stub returned by\n@@ -218,1 +209,2 @@\n- * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method.\n+ * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method. This\n+ * is made available by the {@link jdk.incubator.foreign.CLinker.UpcallStub} instance returned by that method.\n@@ -224,2 +216,2 @@\n- * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} can be used to create\n- * a fresh segment with given spatial bounds out of a native address.\n+ * the restricted method {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)}\n+ * can be used to create a fresh segment with given spatial bounds out of a native address.\n@@ -228,2 +220,2 @@\n- * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)}, if the provided\n- * spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n+ * For instance, in the case of {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)},\n+ * if the provided spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":64,"deletions":72,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-\n-public abstract non-sealed class AbstractCLinker implements CLinker {\n-\n-    public final MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        SharedUtils.checkSymbol(symbol);\n-        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-    }\n-\n-    public final MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n-        SharedUtils.checkSymbol(symbol);\n-        Objects.requireNonNull(allocator);\n-        MethodHandle downcall = MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-        if (type.returnType().equals(MemorySegment.class)) {\n-            downcall = MethodHandles.insertArguments(downcall, 0, allocator);\n-        }\n-        return downcall;\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -39,0 +41,1 @@\n+import java.nio.ByteOrder;\n@@ -46,0 +49,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -143,36 +148,0 @@\n-    public void copyFrom(MemorySegment src) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n-                that.base(), that.min(),\n-                base(), min(), size);\n-    }\n-\n-    public void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout) {\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n-        }\n-        if (((AbstractMemorySegmentImpl)src).min() % srcElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (min() % dstElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n-        }\n-        long size = src.byteSize();\n-        if (size % srcElementLayout.byteSize() != 0) {\n-            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n-        }\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            copyFrom(src);\n-        } else {\n-            AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) src;\n-            checkAccess(0, size, false);\n-            that.checkAccess(0, size, true);\n-            SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                    that.base(), that.min(),\n-                    base(), min(), size, srcElementLayout.byteSize());\n-        }\n-    }\n-\n@@ -194,1 +163,1 @@\n-            if (MemoryAccess.getByte(this) != MemoryAccess.getByte(that)) {\n+            if (get(JAVA_BYTE, 0) != that.get(JAVA_BYTE, 0)) {\n@@ -209,1 +178,1 @@\n-            if (MemoryAccess.getByteAtOffset(this, i) != MemoryAccess.getByteAtOffset(that, i)) {\n+            if (get(JAVA_BYTE, i) != that.get(JAVA_BYTE, i)) {\n@@ -249,3 +218,2 @@\n-    @ForceInline\n-    public final MemoryAddress address() {\n-        return new MemoryAddressImpl(this, 0L);\n+    public MemoryAddress address() {\n+        throw new UnsupportedOperationException(\"Cannot obtain address of on-heap segment\");\n@@ -309,2 +277,2 @@\n-    public final byte[] toByteArray() {\n-        return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);\n+    public final byte[] toArray(ValueLayout.OfByte elementLayout) {\n+        return toArray(byte[].class, elementLayout, byte[]::new, MemorySegment::ofArray);\n@@ -314,2 +282,2 @@\n-    public final short[] toShortArray() {\n-        return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);\n+    public final short[] toArray(ValueLayout.OfShort elementLayout) {\n+        return toArray(short[].class, elementLayout, short[]::new, MemorySegment::ofArray);\n@@ -319,2 +287,2 @@\n-    public final char[] toCharArray() {\n-        return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);\n+    public final char[] toArray(ValueLayout.OfChar elementLayout) {\n+        return toArray(char[].class, elementLayout, char[]::new, MemorySegment::ofArray);\n@@ -324,2 +292,2 @@\n-    public final int[] toIntArray() {\n-        return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);\n+    public final int[] toArray(ValueLayout.OfInt elementLayout) {\n+        return toArray(int[].class, elementLayout, int[]::new, MemorySegment::ofArray);\n@@ -329,2 +297,2 @@\n-    public final float[] toFloatArray() {\n-        return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);\n+    public final float[] toArray(ValueLayout.OfFloat elementLayout) {\n+        return toArray(float[].class, elementLayout, float[]::new, MemorySegment::ofArray);\n@@ -334,2 +302,2 @@\n-    public final long[] toLongArray() {\n-        return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);\n+    public final long[] toArray(ValueLayout.OfLong elementLayout) {\n+        return toArray(long[].class, elementLayout, long[]::new, MemorySegment::ofArray);\n@@ -339,2 +307,2 @@\n-    public final double[] toDoubleArray() {\n-        return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);\n+    public final double[] toArray(ValueLayout.OfDouble elementLayout) {\n+        return toArray(double[].class, elementLayout, double[]::new, MemorySegment::ofArray);\n@@ -343,2 +311,2 @@\n-    private <Z> Z toArray(Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n-        int size = checkArraySize(arrayClass.getSimpleName(), elemSize);\n+    private <Z> Z toArray(Class<Z> arrayClass, ValueLayout elemLayout, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n+        int size = checkArraySize(arrayClass.getSimpleName(), (int)elemLayout.byteSize());\n@@ -347,1 +315,1 @@\n-        arrSegment.copyFrom(this);\n+        MemorySegment.copy(this, elemLayout, 0, arrSegment, elemLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n@@ -401,2 +369,2 @@\n-                offset < Integer.MAX_VALUE && length < Integer.MAX_VALUE &&\n-                offset > Integer.MIN_VALUE && length > Integer.MIN_VALUE) {\n+                offset <= Integer.MAX_VALUE && length <= Integer.MAX_VALUE &&\n+                offset >= Integer.MIN_VALUE && length >= Integer.MIN_VALUE) {\n@@ -404,2 +372,3 @@\n-        } else {\n-            if (length < 0 ||\n+        } else if (this != NativeMemorySegmentImpl.EVERYTHING) { \/\/ oob not possible for everything segment\n+            if (\n+                    length < 0 ||\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":31,"deletions":62,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import sun.security.action.GetPropertyAction;\n-\n-import static jdk.incubator.foreign.MemoryLayouts.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        super(cleaner, new ConfinedResourceList());\n+        super(new ConfinedResourceList(), cleaner);\n@@ -67,1 +67,2 @@\n-    public HandleImpl acquire() {\n+    @ForceInline\n+    public void acquire0() {\n@@ -69,0 +70,3 @@\n+        if (lockCount == MAX_FORKS) {\n+            throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n+        }\n@@ -70,1 +74,6 @@\n-        return new ConfinedHandle();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        lockCount--;\n@@ -78,1 +87,1 @@\n-            throw new IllegalStateException(\"Scope is acquired by \" + lockCount + \" locks\");\n+            throw new IllegalStateException(\"Scope is kept alive by \" + lockCount + \" scopes\");\n@@ -112,21 +121,0 @@\n-\n-    \/**\n-     * A confined resource scope handle; no races are possible here.\n-     *\/\n-    final class ConfinedHandle implements HandleImpl {\n-        boolean released = false;\n-\n-        @Override\n-        public ResourceScopeImpl scope() {\n-            return ConfinedScope.this;\n-        }\n-\n-        @Override\n-        public void release() {\n-            checkValidState(); \/\/ thread check\n-            if (!released) {\n-                released = true;\n-                lockCount--;\n-            }\n-        }\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * given an address pointing to a segment associated with the root layout (see {@link #dereferenceHandle(Class)}).\n+ * given an address pointing to a segment associated with the root layout (see {@link #dereferenceHandle()}).\n@@ -155,2 +155,4 @@\n-    public VarHandle dereferenceHandle(Class<?> carrier) {\n-        Utils.checkPrimitiveCarrierCompat(carrier, layout);\n+    public VarHandle dereferenceHandle() {\n+        if (!(layout instanceof ValueLayout)) {\n+            throw new IllegalArgumentException(\"Path does not select a value layout\");\n+        }\n@@ -159,0 +161,2 @@\n+        Class<?> carrier = ((ValueLayout)layout).carrier();\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -30,0 +31,2 @@\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,2 +36,1 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import java.util.Objects;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -42,1 +44,0 @@\n-    private final AbstractMemorySegmentImpl segment;\n@@ -45,2 +46,1 @@\n-    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {\n-        this.segment = segment;\n+    public MemoryAddressImpl(long offset) {\n@@ -50,2 +50,5 @@\n-    Object base() {\n-        return segment != null ? segment.base() : null;\n+    \/\/ MemoryAddress methods\n+\n+    @Override\n+    public MemoryAddress addOffset(long offset) {\n+        return new MemoryAddressImpl(this.offset + offset);\n@@ -54,3 +57,3 @@\n-    long offset() {\n-        return segment != null ?\n-                segment.min() + offset : offset;\n+    @Override\n+    public long toRawLongValue() {\n+        return offset;\n@@ -59,1 +62,6 @@\n-    \/\/ MemoryAddress methods\n+    @Override\n+    public final MemoryAddress address() {\n+        return this;\n+    }\n+\n+    \/\/ Object methods\n@@ -62,3 +70,2 @@\n-    public ResourceScope scope() {\n-        return segment != null ?\n-                segment.scope() : ResourceScope.globalScope();\n+    public int hashCode() {\n+        return (int) toRawLongValue();\n@@ -68,2 +75,3 @@\n-    public MemoryAddress addOffset(long offset) {\n-        return new MemoryAddressImpl(segment, this.offset + offset);\n+    public boolean equals(Object that) {\n+        return (that instanceof MemoryAddressImpl addressImpl &&\n+            offset == addressImpl.offset);\n@@ -73,7 +81,14 @@\n-    public long segmentOffset(MemorySegment segment) {\n-        Objects.requireNonNull(segment);\n-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;\n-        if (segmentImpl.base() != base()) {\n-            throw new IllegalArgumentException(\"Incompatible segment: \" + segment);\n-        }\n-        return offset() - segmentImpl.min();\n+    public String toString() {\n+        return \"MemoryAddress{ offset=0x\" + Long.toHexString(offset) + \" }\";\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value) {\n+        return ofLongUnchecked(value, Long.MAX_VALUE);\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, resourceScope);\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, ResourceScopeImpl.GLOBAL);\n@@ -83,2 +98,6 @@\n-    public boolean isNative() {\n-        return base() == null;\n+    @CallerSensitive\n+    @ForceInline\n+    public String getUtf8String(long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkAddress(this);\n+        return NativeMemorySegmentImpl.EVERYTHING.getUtf8String(toRawLongValue() + offset);\n@@ -88,8 +107,6 @@\n-    public long toRawLongValue() {\n-        if (segment != null) {\n-            if (segment.base() != null) {\n-                throw new UnsupportedOperationException(\"Not a native address\");\n-            }\n-            segment.checkValidState();\n-        }\n-        return offset();\n+    @CallerSensitive\n+    @ForceInline\n+    public void setUtf8String(long offset, String str) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkAddress(this);\n+        NativeMemorySegmentImpl.EVERYTHING.setUtf8String(toRawLongValue() + offset, str);\n@@ -98,1 +115,7 @@\n-    \/\/ Object methods\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public byte get(ValueLayout.OfByte layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n@@ -101,2 +124,5 @@\n-    public int hashCode() {\n-        return Objects.hash(base(), offset());\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -106,8 +132,5 @@\n-    public boolean equals(Object that) {\n-        if (that instanceof MemoryAddressImpl) {\n-            MemoryAddressImpl addr = (MemoryAddressImpl)that;\n-            return Objects.equals(base(), addr.base()) &&\n-                    offset() == addr.offset();\n-        } else {\n-            return false;\n-        }\n+    @ForceInline\n+    @CallerSensitive\n+    public boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -117,2 +140,5 @@\n-    public String toString() {\n-        return \"MemoryAddress{ base: \" + base() + \" offset=0x\" + Long.toHexString(offset()) + \" }\";\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -122,0 +148,1 @@\n+    @ForceInline\n@@ -123,1 +150,1 @@\n-    public final MemorySegment asSegment(long bytesSize, ResourceScope scope) {\n+    public char get(ValueLayout.OfChar layout, long offset) {\n@@ -125,1 +152,1 @@\n-        return asSegment(bytesSize, null, scope);\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -129,0 +156,1 @@\n+    @ForceInline\n@@ -130,1 +158,1 @@\n-    public final MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope) {\n+    public void set(ValueLayout.OfChar layout, long offset, char value) {\n@@ -132,7 +160,1 @@\n-        Objects.requireNonNull(scope);\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize,\n-                cleanupAction,\n-                (ResourceScopeImpl) scope);\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -141,2 +163,6 @@\n-    public static MemorySegment ofLongUnchecked(long value) {\n-        return ofLongUnchecked(value, Long.MAX_VALUE);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public short get(ValueLayout.OfShort layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -145,2 +171,6 @@\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, resourceScope);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfShort layout, long offset, short value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -149,2 +179,190 @@\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, ResourceScopeImpl.GLOBAL);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public int get(ValueLayout.OfInt layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfInt layout, long offset, int value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public float get(ValueLayout.OfFloat layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public long get(ValueLayout.OfLong layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfLong layout, long offset, long value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public double get(ValueLayout.OfDouble layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value.address());\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public int getAtIndex(ValueLayout.OfInt layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public long getAtIndex(ValueLayout.OfLong layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public double getAtIndex(ValueLayout.OfDouble layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value.address());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":280,"deletions":62,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, null, ResourceScopeImpl.GLOBAL);\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, ResourceScopeImpl.GLOBAL);\n@@ -50,2 +50,0 @@\n-    public static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n-\n@@ -66,0 +64,7 @@\n+    @ForceInline\n+    @Override\n+    public MemoryAddress address() {\n+        checkValidState();\n+        return MemoryAddress.ofLong(unsafeGetOffset());\n+    }\n+\n@@ -126,1 +131,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, ResourceScopeImpl scope) {\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, ResourceScopeImpl scope) {\n@@ -129,3 +134,0 @@\n-        if (cleanupAction != null) {\n-            scope.addCloseAction(cleanupAction);\n-        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,4 +31,0 @@\n-import java.nio.ByteOrder;\n-\n-import static java.nio.ByteOrder.LITTLE_ENDIAN;\n-\n@@ -45,58 +40,0 @@\n-    public static MemoryLayout asVarArg(MemoryLayout ml) {\n-        return switch (CABI.current()) {\n-            case Win64 -> Win64.asVarArg(ml);\n-            case MacOsAArch64 -> AArch64.asVarArg(ml);\n-            default -> ml;\n-        };\n-    }\n-\n-    private static ValueLayout ofBool(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.BOOL);\n-    }\n-\n-    private static ValueLayout ofChar(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.CHAR);\n-    }\n-\n-    private static ValueLayout ofShort(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.SHORT);\n-    }\n-\n-    private static ValueLayout ofInt(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.INT);\n-    }\n-\n-    private static ValueLayout ofLong(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONG);\n-    }\n-\n-    private static ValueLayout ofLongLong(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONG_LONG);\n-    }\n-\n-    private static ValueLayout ofFloat(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.FLOAT);\n-    }\n-\n-    private static ValueLayout ofDouble(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.DOUBLE);\n-    }\n-\n-    private static ValueLayout ofPointer(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.POINTER);\n-    }\n-\n-    public static CLinker.TypeKind getKind(MemoryLayout layout) {\n-        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-            () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n-    }\n-\n@@ -114,1 +51,1 @@\n-        public static final ValueLayout C_BOOL = ofBool(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n@@ -119,1 +56,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -124,1 +61,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -129,1 +66,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -134,1 +71,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -139,1 +76,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -144,1 +81,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -149,1 +86,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -154,1 +91,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -159,1 +96,1 @@\n-        public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;\n+        public static final ValueLayout.OfAddress C_VA_LIST = SysV.C_POINTER;\n@@ -171,6 +108,0 @@\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()}) used to mark variadic parameters. The\n-         * attribute value must be a boolean.\n-         *\/\n-        public static final String VARARGS_ATTRIBUTE_NAME = \"abi\/windows\/varargs\";\n-\n@@ -180,1 +111,1 @@\n-        public static final ValueLayout C_BOOL = ofBool(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n@@ -185,1 +116,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -190,1 +121,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -195,1 +126,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -199,1 +130,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -204,1 +135,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -209,1 +140,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -214,1 +145,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -219,1 +150,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -224,11 +155,1 @@\n-        public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;\n-\n-        \/**\n-         * Return a new memory layout which describes a variadic parameter to be passed to a function.\n-         * @param layout the original parameter layout.\n-         * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},\n-         * which is set to {@code true}.\n-         *\/\n-        public static MemoryLayout asVarArg(MemoryLayout layout) {\n-            return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);\n-        }\n+        public static final ValueLayout.OfAddress C_VA_LIST = Win64.C_POINTER;\n@@ -249,1 +170,1 @@\n-        public static final ValueLayout C_BOOL = ofBool(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n@@ -254,1 +175,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -259,1 +180,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -264,1 +185,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -269,1 +190,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -274,1 +195,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -279,1 +200,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -284,1 +205,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -289,1 +210,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -294,21 +215,1 @@\n-        public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;\n-\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()})\n-         * used to mark variadic parameters on systems such as macOS which pass these\n-         * entirely on the stack. The attribute value must be a boolean.\n-         *\/\n-        public final static String STACK_VARARGS_ATTRIBUTE_NAME = \"abi\/aarch64\/stack_varargs\";\n-\n-        \/**\n-         * Return a new memory layout which describes a variadic parameter to be\n-         * passed to a function. This is only required on platforms such as macOS\n-         * which pass variadic parameters entirely on the stack.\n-         * @param layout the original parameter layout.\n-         * @return a layout which is the same as {@code layout}, except for\n-         * the extra attribute {@link #STACK_VARARGS_ATTRIBUTE_NAME}, which is set\n-         * to {@code true}.\n-         *\/\n-        public static MemoryLayout asVarArg(MemoryLayout layout) {\n-            return layout.withAttribute(STACK_VARARGS_ATTRIBUTE_NAME, true);\n-        }\n+        public static final ValueLayout.OfAddress C_VA_LIST = AArch64.C_POINTER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":30,"deletions":129,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -37,0 +36,1 @@\n+import java.nio.file.Path;\n@@ -55,0 +55,3 @@\n+    final Cleaner.Cleanable cleanable;\n+\n+    static final int MAX_FORKS = Integer.MAX_VALUE;\n@@ -62,5 +65,0 @@\n-    @Override\n-    public boolean isImplicit() {\n-        return false;\n-    }\n-\n@@ -94,1 +92,1 @@\n-    protected ResourceScopeImpl(Cleaner cleaner, ResourceList resourceList) {\n+    protected ResourceScopeImpl(ResourceList resourceList, Cleaner cleaner) {\n@@ -96,7 +94,2 @@\n-        if (cleaner != null) {\n-            cleaner.register(this, resourceList);\n-        }\n-    }\n-\n-    public static ResourceScopeImpl createImplicitScope() {\n-        return new ImplicitScopeImpl(CleanerFactory.cleaner());\n+        cleanable = (cleaner != null) ?\n+            cleaner.register(this, resourceList) : null;\n@@ -109,13 +102,0 @@\n-    \/**\n-     * Creates a confined memory scope with given attachment and cleanup action. The returned scope\n-     * is assumed to be confined on the current thread.\n-     * @return a confined memory scope\n-     *\/\n-    public static ResourceScopeImpl createConfined(Cleaner cleaner) {\n-        return new ConfinedScope(Thread.currentThread(), cleaner);\n-    }\n-\n-    \/**\n-     * Creates a shared memory scope with given attachment and cleanup action.\n-     * @return a shared memory scope\n-     *\/\n@@ -126,16 +106,1 @@\n-    private final void release0(HandleImpl handle) {\n-        try {\n-            Objects.requireNonNull(handle);\n-            if (handle.scope() != this) {\n-                throw new IllegalArgumentException(\"Cannot release an handle acquired from another scope\");\n-            }\n-            handle.release();\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    @Override\n-    public final void release(ResourceScope.Handle handle) {\n-        release0((HandleImpl)handle);\n-    }\n+    public abstract void release0();\n@@ -143,4 +108,1 @@\n-    @Override\n-    public final void release(ScopedMemoryAccess.Scope.Handle handle) {\n-        release0((HandleImpl)handle);\n-    }\n+    public abstract void acquire0();\n@@ -149,11 +111,7 @@\n-    public abstract HandleImpl acquire();\n-\n-    \/**\n-     * Internal interface used to implement resource scope handles.\n-     *\/\n-    public non-sealed interface HandleImpl extends ResourceScope.Handle, ScopedMemoryAccess.Scope.Handle {\n-\n-        @Override\n-        ResourceScopeImpl scope();\n-\n-        void release();\n+    public void keepAlive(ResourceScope target) {\n+        if (target == this) {\n+            throw new IllegalArgumentException(\"Invalid target scope.\");\n+        }\n+        ResourceScopeImpl targetImpl = (ResourceScopeImpl)target;\n+        targetImpl.acquire0();\n+        addCloseAction(targetImpl::release0);\n@@ -170,1 +128,5 @@\n-            resourceList.cleanup();\n+            if (cleanable != null) {\n+                cleanable.clean();\n+            } else {\n+                resourceList.cleanup();\n+            }\n@@ -218,1 +180,1 @@\n-     * Allocates a segment using this scope. Used by {@link SegmentAllocator#ofScope(ResourceScope)}.\n+     * Allocates a segment using this scope.\n@@ -226,3 +188,3 @@\n-     * A non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n-     * In addition, non-closeable scopes feature a much simpler scheme for generating resource scope handles, where\n-     * the scope itself also acts as a resource scope handle and is returned by {@link #acquire()}.\n+     * The global, always alive, non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n+     * Adding new resources to the global scope, does nothing: as the scope can never become not-alive, there is nothing to track.\n+     * Acquiring and or releasing a resource scope similarly does nothing.\n@@ -230,10 +192,1 @@\n-    static class ImplicitScopeImpl extends SharedScope implements HandleImpl {\n-\n-        public ImplicitScopeImpl(Cleaner cleaner) {\n-            super(cleaner);\n-        }\n-\n-        @Override\n-        public HandleImpl acquire() {\n-            return this;\n-        }\n+    static class GlobalScopeImpl extends SharedScope {\n@@ -241,3 +194,2 @@\n-        @Override\n-        public boolean isImplicit() {\n-            return true;\n+        public GlobalScopeImpl() {\n+            super(null);\n@@ -252,1 +204,1 @@\n-        public void release() {\n+        public void release0() {\n@@ -257,2 +209,2 @@\n-        public ResourceScopeImpl scope() {\n-            return this;\n+        public void acquire0() {\n+            \/\/ do nothing\n@@ -260,1 +212,0 @@\n-    }\n@@ -262,6 +213,0 @@\n-    \/**\n-     * The global, always alive, non-closeable, shared scope. This is like a {@link ImplicitScopeImpl non-closeable scope},\n-     * except that the operation which adds new resources to the global scope does nothing: as the scope can never\n-     * become not-alive, there is nothing to track.\n-     *\/\n-    public static final ResourceScopeImpl GLOBAL = new ImplicitScopeImpl( null) {\n@@ -272,1 +217,3 @@\n-    };\n+    }\n+\n+    public static final ResourceScopeImpl GLOBAL = new GlobalScopeImpl();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":34,"deletions":87,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -53,1 +54,0 @@\n-    private static final int MAX_FORKS = Integer.MAX_VALUE;\n@@ -68,1 +68,1 @@\n-        super(cleaner, new SharedResourceList());\n+        super(new SharedResourceList(), cleaner);\n@@ -84,1 +84,2 @@\n-    public HandleImpl acquire() {\n+    @ForceInline\n+    public void acquire0() {\n@@ -93,1 +94,1 @@\n-                throw new IllegalStateException(\"Segment acquire limit exceeded\");\n+                throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n@@ -96,1 +97,13 @@\n-        return new SharedHandle();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n+            if (value <= ALIVE) {\n+                \/\/cannot get here - we can't close segment twice\n+                throw new IllegalStateException(\"Already closed\");\n+            }\n+        } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n@@ -104,1 +117,1 @@\n-            throw new IllegalStateException(\"Scope is acquired by \" + prevState + \" locks\");\n+            throw new IllegalStateException(\"Scope is kept alive by \" + prevState + \" scopes\");\n@@ -170,26 +183,0 @@\n-\n-    \/**\n-     * A shared resource scope handle; this implementation has to handle close vs. close races.\n-     *\/\n-    class SharedHandle implements HandleImpl {\n-        final AtomicBoolean released = new AtomicBoolean(false);\n-\n-        @Override\n-        public ResourceScopeImpl scope() {\n-            return SharedScope.this;\n-        }\n-\n-        @Override\n-        public void release() {\n-            if (released.compareAndSet(false, true)) {\n-                int value;\n-                do {\n-                    value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n-                    if (value <= ALIVE) {\n-                        \/\/cannot get here - we can't close segment twice\n-                        throw new IllegalStateException(\"Already closed\");\n-                    }\n-                } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n-            }\n-        }\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -42,1 +41,1 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -74,2 +73,2 @@\n-            MemorySegment funcs = fallbackLibLookup.lookup(\"funcs\").orElseThrow()\n-                .asSegment(C_POINTER.byteSize() * numSymbols, ResourceScope.newImplicitScope());\n+            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow(),\n+                ADDRESS.byteSize() * numSymbols, ResourceScope.globalScope());\n@@ -78,1 +77,1 @@\n-                .map(symbol -> MemoryAccess.getAddressAtIndex(funcs, symbol.ordinal()));\n+                .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-import jdk.internal.misc.VM;\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -40,1 +39,0 @@\n-import java.util.Optional;\n@@ -43,0 +41,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -56,0 +55,2 @@\n+    private static final MethodHandle ADDRESS_TO_LONG;\n+    private static final MethodHandle LONG_TO_ADDRESS;\n@@ -70,0 +71,4 @@\n+            ADDRESS_TO_LONG = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+                    MethodType.methodType(long.class));\n+            LONG_TO_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n+                    MethodType.methodType(MemoryAddress.class, long.class));\n@@ -105,1 +110,1 @@\n-            baseCarrier = switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+            baseCarrier = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n@@ -124,1 +129,3 @@\n-            return MemoryHandles.asAddressVarHandle(handle);\n+            return MemoryHandles.filterValue(handle,\n+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n@@ -134,11 +141,2 @@\n-    public static void checkPrimitiveCarrierCompat(Class<?> carrier, MemoryLayout layout) {\n-        checkLayoutType(layout, ValueLayout.class);\n-        if (!isValidPrimitiveCarrier(carrier) && carrier != MemoryAddress.class)\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier);\n-        if (carrier == MemoryAddress.class && layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()) {\n-            throw new IllegalArgumentException(\"Address size mismatch: \" + MemoryLayouts.ADDRESS.byteSize() + \" != \" + layout.bitSize());\n-        }\n-        if (carrier.isPrimitive() && Wrapper.forPrimitiveType(carrier).bitWidth() != layout.bitSize() &&\n-                carrier != boolean.class && layout.byteSize() != 1) {\n-            throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier + \" != \" + layout);\n-        }\n+    private static boolean byteToBoolean(byte b) {\n+        return b != 0;\n@@ -147,9 +145,2 @@\n-    public static boolean isValidPrimitiveCarrier(Class<?> carrier) {\n-        return carrier == boolean.class\n-            || carrier == byte.class\n-            || carrier == short.class\n-            || carrier == char.class\n-            || carrier == int.class\n-            || carrier == long.class\n-            || carrier == float.class\n-            || carrier == double.class;\n+    private static byte booleanToByte(boolean b) {\n+        return b ? (byte)1 : (byte)0;\n@@ -158,3 +149,4 @@\n-    public static void checkLayoutType(MemoryLayout layout, Class<? extends MemoryLayout> layoutType) {\n-        if (!layoutType.isInstance(layout))\n-            throw new IllegalArgumentException(\"Expected a \" + layoutType.getSimpleName() + \": \" + layout);\n+    public static void copy(MemorySegment addr, byte[] bytes) {\n+        var heapSegment = MemorySegment.ofArray(bytes);\n+        addr.copyFrom(heapSegment);\n+        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n@@ -163,2 +155,4 @@\n-    private static boolean byteToBoolean(byte b) {\n-        return b != 0;\n+    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n+        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n+        copy(addr, bytes);\n+        return addr;\n@@ -167,2 +161,4 @@\n-    private static byte booleanToByte(boolean b) {\n-        return b ? (byte)1 : (byte)0;\n+    @ForceInline\n+    public static long scaleOffset(MemorySegment segment, long index, long size) {\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return MemorySegmentProxy.multiplyOffsets(index, (int)size, (AbstractMemorySegmentImpl)segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":28,"deletions":32,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -33,0 +34,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -38,0 +40,1 @@\n+import java.lang.invoke.MethodType;\n@@ -207,1 +210,0 @@\n-    private static final MethodHandle MH_BASE_ADDRESS;\n@@ -219,2 +221,0 @@\n-            MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, \"address\",\n-                    methodType(MemoryAddress.class));\n@@ -324,1 +324,0 @@\n-        BASE_ADDRESS,\n@@ -391,1 +390,1 @@\n-        return UnboxAddress.INSTANCE;\n+        return UnboxAddress.INSTANCE.get(MemoryAddress.class);\n@@ -394,2 +393,2 @@\n-    public static BaseAddress baseAddress() {\n-        return BaseAddress.INSTANCE;\n+    public static UnboxAddress unboxAddress(Class<?> carrier) {\n+        return UnboxAddress.INSTANCE.get(carrier);\n@@ -470,2 +469,2 @@\n-        public Binding.Builder baseAddress() {\n-            bindings.add(Binding.baseAddress());\n+        public Binding.Builder unboxAddress(Class<?> carrier) {\n+            bindings.add(Binding.unboxAddress(carrier));\n@@ -633,1 +632,23 @@\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, 1, ByteOrder.nativeOrder()), 1, offset);\n+            ValueLayout layout;\n+            if (type() == boolean.class) {\n+                layout = ValueLayout.JAVA_BOOLEAN;\n+            } else if (type() == char.class) {\n+                layout = ValueLayout.JAVA_CHAR;\n+            } else if (type() == byte.class) {\n+                layout = ValueLayout.JAVA_BYTE;\n+            } else if (type() == short.class) {\n+                layout = ValueLayout.JAVA_SHORT;\n+            } else if (type() == int.class) {\n+                layout = ValueLayout.JAVA_INT;\n+            } else if (type() == float.class) {\n+                layout = ValueLayout.JAVA_FLOAT;\n+            } else if (type() == long.class) {\n+                layout = ValueLayout.JAVA_LONG;\n+            } else if (type() == double.class) {\n+                layout = ValueLayout.JAVA_DOUBLE;\n+            } else if (type() == MemoryAddress.class) {\n+                layout = ValueLayout.ADDRESS;\n+            } else {\n+                throw new IllegalStateException(\"Unsupported carrier: \" + type().getName());\n+            }\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout.withOrder(ByteOrder.nativeOrder()).withBitAlignment(8)), 1, offset);\n@@ -743,3 +764,2 @@\n-            MemorySegment copy = context.allocator().allocate(size, alignment);\n-            copy.copyFrom(operand.asSlice(0, size));\n-            return copy;\n+            return context.allocator().allocate(size, alignment)\n+                            .copyFrom(operand.asSlice(0, size));\n@@ -878,2 +898,12 @@\n-        private static final UnboxAddress INSTANCE = new UnboxAddress();\n-        private UnboxAddress() {\n+\n+        static final ClassValue<UnboxAddress> INSTANCE = new ClassValue<>() {\n+            @Override\n+            protected UnboxAddress computeValue(Class<?> type) {\n+                return new UnboxAddress(type);\n+            }\n+        };\n+\n+        final Class<?> carrier;\n+        final MethodHandle toAddress;\n+\n+        private UnboxAddress(Class<?> carrier) {\n@@ -881,0 +911,6 @@\n+            this.carrier = carrier;\n+            try {\n+                this.toAddress = MethodHandles.lookup().findVirtual(carrier, \"address\", MethodType.methodType(MemoryAddress.class));\n+            } catch (Throwable ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n@@ -886,1 +922,1 @@\n-            SharedUtils.checkType(actualType, MemoryAddress.class);\n+            SharedUtils.checkType(actualType, carrier);\n@@ -893,1 +929,1 @@\n-            stack.push(((MemoryAddress)stack.pop()).toRawLongValue());\n+            stack.push(((Addressable)stack.pop()).address().toRawLongValue());\n@@ -898,1 +934,2 @@\n-            return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);\n+            return filterArguments(specializedHandle, insertPos,\n+                    MethodHandles.filterReturnValue(toAddress, MH_UNBOX_ADDRESS));\n@@ -942,35 +979,0 @@\n-    \/**\n-     * BASE_ADDRESS()\n-     *   Pops a MemorySegment from the operand stack, and takes the base address of the segment\n-     *   (the MemoryAddress that points to the start), and pushes that onto the operand stack\n-     *\/\n-    public static class BaseAddress extends Binding {\n-        private static final BaseAddress INSTANCE = new BaseAddress();\n-        private BaseAddress() {\n-            super(Tag.BASE_ADDRESS);\n-        }\n-\n-        @Override\n-        public void verify(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemorySegment.class);\n-            stack.push(MemoryAddress.class);\n-        }\n-\n-        @Override\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(((MemorySegment) stack.pop()).address());\n-        }\n-\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"BaseAddress{}\";\n-        }\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":55,"deletions":53,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -37,1 +37,1 @@\n-    static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-        BASE_ADDRESS,\n@@ -132,1 +131,0 @@\n-        \/\/BASE_ADDRESS,\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -33,0 +31,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -73,1 +72,1 @@\n-    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n@@ -176,2 +175,2 @@\n-        MemoryAddress ma = SharedUtils.checkSymbol(addr);\n-        return ma.toRawLongValue();\n+        SharedUtils.checkSymbol(addr);\n+        return addr.address().toRawLongValue();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -29,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -32,3 +33,1 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -36,0 +35,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -71,1 +71,1 @@\n-    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n@@ -90,1 +90,1 @@\n-    public static UpcallHandler make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n+    public static CLinker.UpcallStub make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n@@ -136,1 +136,1 @@\n-        return () -> entryPoint;\n+        return new UpcallStubs.UpcallStubImpl(entryPoint, callingSequence.functionDesc(), target, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -38,1 +37,1 @@\n-import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.VaList;\n@@ -56,1 +55,0 @@\n-import java.nio.charset.Charset;\n@@ -71,1 +69,0 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n@@ -77,1 +74,9 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -230,28 +235,0 @@\n-    public static void checkCompatibleType(Class<?> carrier, MemoryLayout layout, long addressSize) {\n-        if (carrier.isPrimitive()) {\n-            Utils.checkPrimitiveCarrierCompat(carrier, layout);\n-        } else if (carrier == MemoryAddress.class) {\n-            Utils.checkLayoutType(layout, ValueLayout.class);\n-            if (layout.bitSize() != addressSize)\n-                throw new IllegalArgumentException(\"Address size mismatch: \" + addressSize + \" != \" + layout.bitSize());\n-        } else if (carrier == MemorySegment.class) {\n-            Utils.checkLayoutType(layout, GroupLayout.class);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier);\n-        }\n-    }\n-\n-    public static void checkFunctionTypes(MethodType mt, FunctionDescriptor cDesc, long addressSize) {\n-        if (mt.returnType() == void.class != cDesc.returnLayout().isEmpty())\n-            throw new IllegalArgumentException(\"Return type mismatch: \" + mt + \" != \" + cDesc);\n-        List<MemoryLayout> argLayouts = cDesc.argumentLayouts();\n-        if (mt.parameterCount() != argLayouts.size())\n-            throw new IllegalArgumentException(\"Arity mismatch: \" + mt + \" != \" + cDesc);\n-\n-        int paramCount = mt.parameterCount();\n-        for (int i = 0; i < paramCount; i++) {\n-            checkCompatibleType(mt.parameterType(i), argLayouts.get(i), addressSize);\n-        }\n-        cDesc.returnLayout().ifPresent(rl -> checkCompatibleType(mt.returnType(), rl, addressSize));\n-    }\n-\n@@ -292,2 +269,1 @@\n-        MemorySegment.ofArray(bytes)\n-                .copyFrom(segment.asSlice(start, len));\n+        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n@@ -300,1 +276,1 @@\n-            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n@@ -451,3 +427,2 @@\n-        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n-                        MethodType.methodType(MemoryAddress.class, long.class),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"malloc\").get(),\n+                FunctionDescriptor.of(ADDRESS, JAVA_LONG));\n@@ -455,3 +430,2 @@\n-        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n-                        MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER));\n+        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"free\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS));\n@@ -460,2 +434,2 @@\n-    public static MemoryAddress checkSymbol(Addressable symbol) {\n-        return checkAddressable(symbol, \"Symbol is NULL\");\n+    public static void checkSymbol(Addressable symbol) {\n+        checkAddressable(symbol, \"Symbol is NULL\");\n@@ -464,2 +438,2 @@\n-    public static MemoryAddress checkAddress(MemoryAddress address) {\n-        return checkAddressable(address, \"Address is NULL\");\n+    public static void checkAddress(MemoryAddress address) {\n+        checkAddressable(address, \"Address is NULL\");\n@@ -468,1 +442,1 @@\n-    private static MemoryAddress checkAddressable(Addressable symbol, String msg) {\n+    private static void checkAddressable(Addressable symbol, String msg) {\n@@ -470,4 +444,2 @@\n-        MemoryAddress symbolAddr = symbol.address();\n-        if (symbolAddr.equals(MemoryAddress.NULL))\n-            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbolAddr);\n-        return symbolAddr;\n+        if (symbol.address().toRawLongValue() == 0)\n+            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbol);\n@@ -486,1 +458,1 @@\n-            AllocHolder.MH_FREE.invokeExact(addr);\n+            AllocHolder.MH_FREE.invokeExact((Addressable)addr);\n@@ -527,3 +499,6 @@\n-        return cDesc.attribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME)\n-                .map(Boolean.class::cast)\n-                .orElse(false);\n+        return false; \/\/ FIXME: use system property?\n+    }\n+\n+    public static boolean isVarargsIndex(FunctionDescriptor descriptor, int argIndex) {\n+        int firstPos = descriptor.firstVariadicArgumentIndex();\n+        return firstPos != -1 && argIndex >= firstPos;\n@@ -544,1 +519,1 @@\n-            return layout.varHandle(carrier);\n+            return layout.varHandle();\n@@ -561,1 +536,1 @@\n-        public int vargAsInt(MemoryLayout layout) {\n+        public int nextVarg(ValueLayout.OfInt layout) {\n@@ -566,1 +541,1 @@\n-        public long vargAsLong(MemoryLayout layout) {\n+        public long nextVarg(ValueLayout.OfLong layout) {\n@@ -571,1 +546,1 @@\n-        public double vargAsDouble(MemoryLayout layout) {\n+        public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -576,1 +551,1 @@\n-        public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+        public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -581,6 +556,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -614,1 +584,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            ptr.set(JAVA_LONG, 0, (long) o);\n@@ -616,1 +586,1 @@\n-            MemoryAccess.setLong(ptr, (int) o);\n+            ptr.set(JAVA_LONG, 0, (int) o);\n@@ -618,1 +588,1 @@\n-            MemoryAccess.setLong(ptr, (short) o);\n+            ptr.set(JAVA_LONG, 0, (short) o);\n@@ -620,1 +590,1 @@\n-            MemoryAccess.setLong(ptr, (char) o);\n+            ptr.set(JAVA_LONG, 0, (char) o);\n@@ -622,1 +592,1 @@\n-            MemoryAccess.setLong(ptr, (byte) o);\n+            ptr.set(JAVA_LONG, 0, (byte) o);\n@@ -624,1 +594,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            ptr.set(JAVA_FLOAT, 0, (float) o);\n@@ -626,1 +596,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            ptr.set(JAVA_DOUBLE, 0, (double) o);\n@@ -628,1 +598,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n@@ -636,1 +606,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            ptr.set(JAVA_LONG, 0, (long) o);\n@@ -638,1 +608,1 @@\n-            MemoryAccess.setInt(ptr, (int) o);\n+            ptr.set(JAVA_INT, 0, (int) o);\n@@ -640,1 +610,1 @@\n-            MemoryAccess.setShort(ptr, (short) o);\n+            ptr.set(JAVA_SHORT, 0, (short) o);\n@@ -642,1 +612,1 @@\n-            MemoryAccess.setChar(ptr, (char) o);\n+            ptr.set(JAVA_CHAR, 0, (char) o);\n@@ -644,1 +614,1 @@\n-            MemoryAccess.setByte(ptr, (byte) o);\n+            ptr.set(JAVA_BYTE, 0, (byte) o);\n@@ -646,1 +616,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            ptr.set(JAVA_FLOAT, 0, (float) o);\n@@ -648,1 +618,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            ptr.set(JAVA_DOUBLE, 0, (double) o);\n@@ -650,1 +620,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n@@ -658,1 +628,1 @@\n-            return MemoryAccess.getLong(ptr);\n+            return ptr.get(JAVA_LONG, 0);\n@@ -660,1 +630,1 @@\n-            return MemoryAccess.getInt(ptr);\n+            return ptr.get(JAVA_INT, 0);\n@@ -662,1 +632,1 @@\n-            return MemoryAccess.getShort(ptr);\n+            return ptr.get(JAVA_SHORT, 0);\n@@ -664,1 +634,1 @@\n-            return MemoryAccess.getChar(ptr);\n+            return ptr.get(JAVA_CHAR, 0);\n@@ -666,1 +636,1 @@\n-            return MemoryAccess.getByte(ptr);\n+            return ptr.get(JAVA_BYTE, 0);\n@@ -668,1 +638,1 @@\n-            return MemoryAccess.getFloat(ptr);\n+            return ptr.get(JAVA_FLOAT, 0);\n@@ -670,1 +640,1 @@\n-            return MemoryAccess.getDouble(ptr);\n+            return ptr.get(JAVA_DOUBLE, 0);\n@@ -672,1 +642,1 @@\n-            return MemoryAccess.getBoolean(ptr);\n+            return ptr.get(JAVA_BOOLEAN, 0);\n@@ -677,0 +647,20 @@\n+\n+    public static MethodType inferMethodType(FunctionDescriptor descriptor, boolean upcall) {\n+        MethodType type = MethodType.methodType(descriptor.returnLayout().isPresent() ?\n+                carrierFor(descriptor.returnLayout().get(), upcall) : void.class);\n+        for (MemoryLayout argLayout : descriptor.argumentLayouts()) {\n+            type = type.appendParameterTypes(carrierFor(argLayout, !upcall));\n+        }\n+        return type;\n+    }\n+\n+    static Class<?> carrierFor(MemoryLayout layout, boolean forArg) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return (forArg && valueLayout.carrier().equals(MemoryAddress.class)) ?\n+                    Addressable.class : valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":81,"deletions":91,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package jdk.internal.foreign.abi;\n-\n-public interface UpcallHandler {\n-    long entryPoint();\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallHandler.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -29,0 +32,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -30,1 +34,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -32,1 +35,1 @@\n-public class UpcallStubs {\n+import java.lang.invoke.MethodHandle;\n@@ -34,5 +37,1 @@\n-    public static MemoryAddress upcallAddress(UpcallHandler handler, ResourceScopeImpl scope) {\n-        long stubAddress = handler.entryPoint();\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0,\n-                () -> freeUpcallStub(stubAddress), scope).address();\n-    }\n+public class UpcallStubs {\n@@ -55,0 +54,19 @@\n+\n+\n+    \/\/ where\n+    public record UpcallStubImpl(long entry, FunctionDescriptor descriptor, MethodHandle target, ResourceScope scope) implements CLinker.UpcallStub {\n+        public UpcallStubImpl {\n+            ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+                @Override\n+                public void cleanup() {\n+                    freeUpcallStub(entry);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public MemoryAddress address() {\n+            ((ResourceScopeImpl)scope).checkValidStateSlow();\n+            return MemoryAddress.ofLong(entry);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -33,0 +34,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -35,1 +37,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -99,2 +100,0 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64.C_POINTER.bitSize());\n-\n@@ -119,0 +118,3 @@\n+            if (SharedUtils.isVarargsIndex(cDesc, i)) {\n+                argCalc.storageCalculator.adjustForVarArgs();\n+            }\n@@ -139,1 +141,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -146,1 +148,1 @@\n-        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence,scope);\n@@ -211,8 +213,5 @@\n-        void adjustForVarArgs(MemoryLayout layout) {\n-            if (layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME)\n-                    .map(Boolean.class::cast).orElse(false)) {\n-                \/\/ This system passes all variadic parameters on the stack. Ensure\n-                \/\/ no further arguments are allocated to registers.\n-                nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n-                nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n-            }\n+        void adjustForVarArgs() {\n+            \/\/ This system passes all variadic parameters on the stack. Ensure\n+            \/\/ no further arguments are allocated to registers.\n+            nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+            nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n@@ -291,1 +290,0 @@\n-            storageCalculator.adjustForVarArgs(layout);\n@@ -320,2 +318,1 @@\n-                            .baseAddress()\n-                            .unboxAddress();\n+                            .unboxAddress(MemorySegment.class);\n@@ -352,1 +349,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n@@ -394,1 +391,0 @@\n-            assert !layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME).isPresent() : \"no variadic upcalls\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -32,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -45,5 +45,11 @@\n-        return switch (PlatformLayouts.getKind(type)) {\n-            case BOOL, CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n-            case POINTER -> POINTER;\n-            case FLOAT, DOUBLE -> FLOAT;\n-        };\n+        Class<?> carrier = type.carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            return FLOAT;\n+        } else if (carrier == MemoryAddress.class) {\n+            return POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -32,1 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n+import jdk.incubator.foreign.VaList;\n@@ -48,1 +50,1 @@\n-public final class LinuxAArch64Linker extends AbstractCLinker {\n+public final class LinuxAArch64Linker implements CLinker {\n@@ -61,2 +63,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -64,0 +65,1 @@\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n@@ -73,1 +75,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -78,1 +80,5 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.nio.ByteOrder;\n@@ -42,1 +41,2 @@\n-import static jdk.incubator.foreign.CLinker.VaList;\n+\n+import jdk.incubator.foreign.VaList;\n@@ -46,1 +46,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;\n@@ -78,1 +77,1 @@\n-        = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n+        = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n@@ -80,1 +79,1 @@\n-        = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n+        = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n@@ -93,6 +92,3 @@\n-    private static final VarHandle VH_stack\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__stack\")));\n-    private static final VarHandle VH_gr_top\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__gr_top\")));\n-    private static final VarHandle VH_vr_top\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__vr_top\")));\n+    private static final VarHandle VH_stack = LAYOUT.varHandle(groupElement(\"__stack\"));\n+    private static final VarHandle VH_gr_top = LAYOUT.varHandle(groupElement(\"__gr_top\"));\n+    private static final VarHandle VH_vr_top = LAYOUT.varHandle(groupElement(\"__vr_top\"));\n@@ -100,1 +96,1 @@\n-        = LAYOUT.varHandle(int.class, groupElement(\"__gr_offs\"));\n+        = LAYOUT.varHandle(groupElement(\"__gr_offs\"));\n@@ -102,1 +98,1 @@\n-        = LAYOUT.varHandle(int.class, groupElement(\"__vr_offs\"));\n+        = LAYOUT.varHandle(groupElement(\"__vr_offs\"));\n@@ -119,1 +115,1 @@\n-        MemorySegment gpRegsArea = grTop(segment).addOffset(-MAX_GP_OFFSET).asSegment(\n+        MemorySegment gpRegsArea = MemorySegment.ofAddressNative(grTop(segment).addOffset(-MAX_GP_OFFSET),\n@@ -122,1 +118,1 @@\n-        MemorySegment fpRegsArea = vrTop(segment).addOffset(-MAX_FP_OFFSET).asSegment(\n+        MemorySegment fpRegsArea = MemorySegment.ofAddressNative(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n@@ -129,2 +125,4 @@\n-        MemorySegment ms = MemoryAddress.ofLong(ptr).asSegment(\n-                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n+        ResourceScope scope = ResourceScope.newSharedScope();\n+        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySegment ms = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+                LAYOUT.byteSize(), scope);\n@@ -217,1 +215,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -222,1 +220,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -227,1 +225,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -232,1 +230,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -237,1 +235,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -242,5 +240,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -253,2 +246,0 @@\n-        checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n-\n@@ -260,1 +251,1 @@\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n@@ -267,2 +258,2 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    VarHandle reader = layout.varHandle();\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n@@ -282,2 +273,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));\n+                        MemorySegment.copy(gpRegsArea, currentGPOffset(), value, offset, copy);\n@@ -298,2 +288,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));\n+                        MemorySegment.copy(gpRegsArea, currentFPOffset(), value, offset, copy);\n@@ -307,1 +296,1 @@\n-                    VarHandle ptrReader = AArch64.C_POINTER.varHandle(MemoryAddress.class);\n+                    VarHandle ptrReader = AArch64.C_POINTER.varHandle();\n@@ -312,1 +301,1 @@\n-                    MemorySegment slice = ptr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddressNative(ptr, layout.byteSize(), scope());\n@@ -318,1 +307,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -324,1 +313,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -357,1 +346,1 @@\n-        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n@@ -367,1 +356,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n+        MemorySegment copy = segment.scope().allocate(LAYOUT);\n@@ -414,2 +403,2 @@\n-            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n-            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n+            this.gpRegs = scope.allocate(LAYOUT_GP_REGS);\n+            this.fpRegs = scope.allocate(LAYOUT_FP_REGS);\n@@ -419,1 +408,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -424,1 +413,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -429,1 +418,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -434,1 +423,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -439,1 +428,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -446,2 +435,0 @@\n-            checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n-\n@@ -459,2 +446,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            gpRegs.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentGPOffset, copy);\n@@ -474,2 +460,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            fpRegs.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentFPOffset, copy);\n@@ -483,1 +468,1 @@\n-                        VarHandle writer = AArch64.C_POINTER.varHandle(MemoryAddress.class);\n+                        VarHandle writer = AArch64.C_POINTER.varHandle();\n@@ -489,1 +474,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n@@ -494,1 +479,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":43,"deletions":58,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -31,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -34,1 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n+import jdk.incubator.foreign.VaList;\n@@ -46,2 +46,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -52,1 +50,1 @@\n-public final class MacOsAArch64Linker extends AbstractCLinker {\n+public final class MacOsAArch64Linker implements CLinker {\n@@ -65,2 +63,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -68,0 +65,1 @@\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n@@ -77,1 +75,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -81,1 +79,5 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.incubator.foreign.VaList;\n@@ -51,1 +51,1 @@\n-    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n@@ -68,1 +68,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -73,1 +73,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -78,1 +78,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -83,1 +83,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -88,1 +88,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -93,5 +93,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -104,1 +99,0 @@\n-        SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n@@ -111,1 +105,1 @@\n-                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n@@ -118,2 +112,2 @@\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -126,1 +120,1 @@\n-            VarHandle reader = layout.varHandle(carrier);\n+            VarHandle reader = layout.varHandle();\n@@ -147,1 +141,1 @@\n-        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n@@ -184,1 +178,0 @@\n-            SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n@@ -190,1 +183,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -195,1 +188,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -200,1 +193,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -205,1 +198,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -210,1 +203,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -240,4 +233,3 @@\n-                        case STRUCT_REGISTER, STRUCT_HFA -> {\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n-                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":20,"deletions":28,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -33,0 +34,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -89,2 +90,0 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, SysVx64Linker.ADDRESS_SIZE);\n-\n@@ -137,1 +136,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -144,1 +143,1 @@\n-        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence, scope);\n@@ -283,1 +282,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.nio.ByteOrder;\n@@ -41,1 +40,2 @@\n-import static jdk.incubator.foreign.CLinker.VaList;\n+\n+import jdk.incubator.foreign.VaList;\n@@ -45,1 +45,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;\n@@ -69,2 +68,2 @@\n-    private static final MemoryLayout GP_REG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n-    private static final MemoryLayout FP_REG = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n+    private static final MemoryLayout GP_REG = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n+    private static final MemoryLayout FP_REG = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n@@ -107,6 +106,4 @@\n-    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(int.class, groupElement(\"fp_offset\"));\n-    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(int.class, groupElement(\"gp_offset\"));\n-    private static final VarHandle VH_overflow_arg_area\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"overflow_arg_area\")));\n-    private static final VarHandle VH_reg_save_area\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"reg_save_area\")));\n+    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(groupElement(\"fp_offset\"));\n+    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(groupElement(\"gp_offset\"));\n+    private static final VarHandle VH_overflow_arg_area = LAYOUT.varHandle(groupElement(\"overflow_arg_area\"));\n+    private static final VarHandle VH_reg_save_area = LAYOUT.varHandle(groupElement(\"reg_save_area\"));\n@@ -132,2 +129,4 @@\n-        MemorySegment base = MemoryAddress.ofLong(ptr).asSegment(\n-                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n+        ResourceScope scope = ResourceScope.newSharedScope();\n+        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySegment base = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+                LAYOUT.byteSize(), scope);\n@@ -175,1 +174,1 @@\n-        return ((MemoryAddress)VH_reg_save_area.get(segment)).asSegment(\n+        return MemorySegment.ofAddressNative(((MemoryAddress)VH_reg_save_area.get(segment)),\n@@ -190,1 +189,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -195,1 +194,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -200,1 +199,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -205,1 +204,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -210,1 +209,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -215,5 +214,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -226,1 +220,0 @@\n-        checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);\n@@ -233,1 +226,1 @@\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n@@ -240,1 +233,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -242,1 +235,1 @@\n-                        MemorySegment slice = stackPtr().asSegment(layout.byteSize(), localScope);\n+                        MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), localScope);\n@@ -258,1 +251,0 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n@@ -260,1 +252,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentFPOffset(), value, offset, copy);\n@@ -263,1 +255,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentGPOffset(), value, offset, copy);\n@@ -271,1 +263,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -277,1 +269,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -307,1 +299,1 @@\n-        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n@@ -317,1 +309,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n+        MemorySegment copy = segment.scope().allocate(LAYOUT);\n@@ -351,1 +343,1 @@\n-            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n+            this.reg_save_area = scope.allocate(LAYOUT_REG_SAVE_AREA);\n@@ -355,1 +347,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -360,1 +352,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -365,1 +357,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -370,1 +362,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -375,1 +367,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -382,1 +374,0 @@\n-            checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);\n@@ -397,1 +388,0 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n@@ -399,1 +389,1 @@\n-                                reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentFPOffset, copy);\n@@ -402,1 +392,1 @@\n-                                reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentGPOffset, copy);\n@@ -409,1 +399,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n@@ -414,1 +404,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":37,"deletions":47,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -32,1 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n+import jdk.incubator.foreign.VaList;\n@@ -46,1 +48,1 @@\n-public final class SysVx64Linker extends AbstractCLinker {\n+public final class SysVx64Linker implements CLinker {\n@@ -71,2 +73,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -74,0 +75,1 @@\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n@@ -83,1 +85,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -88,1 +90,5 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -31,1 +32,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -110,5 +110,11 @@\n-        return switch (PlatformLayouts.getKind(layout)) {\n-            case BOOL, CHAR, SHORT, INT, LONG, LONG_LONG -> ArgumentClassImpl.INTEGER;\n-            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;\n-            case POINTER -> ArgumentClassImpl.POINTER;\n-        };\n+        Class<?> carrier = ((ValueLayout)layout).carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return ArgumentClassImpl.INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            return ArgumentClassImpl.SSE;\n+        } else if (carrier == MemoryAddress.class) {\n+            return ArgumentClassImpl.POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -32,0 +33,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -85,2 +86,0 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, Windowsx64Linker.ADDRESS_SIZE);\n-\n@@ -94,2 +93,2 @@\n-            void addArgumentBindings(Class<?> carrier, MemoryLayout layout) {\n-                csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));\n+            void addArgumentBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+                csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout, isVararg));\n@@ -99,1 +98,1 @@\n-                csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout));\n+                csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout, false));\n@@ -108,1 +107,1 @@\n-            csb.addArgumentBindings(carrier, layout);\n+            csb.addArgumentBindings(carrier, layout, false);\n@@ -117,1 +116,1 @@\n-            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i));\n+            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i), SharedUtils.isVarargsIndex(cDesc, i));\n@@ -137,1 +136,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -144,1 +143,1 @@\n-        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence, scope);\n@@ -188,1 +187,1 @@\n-        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout);\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg);\n@@ -199,2 +198,2 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {\n-            TypeClass argumentClass = TypeClass.typeClassFor(layout);\n+        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+            TypeClass argumentClass = TypeClass.typeClassFor(layout, isVararg);\n@@ -214,2 +213,1 @@\n-                            .baseAddress()\n-                            .unboxAddress();\n+                            .unboxAddress(MemorySegment.class);\n@@ -221,1 +219,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n@@ -262,2 +260,2 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {\n-            TypeClass argumentClass = TypeClass.typeClassFor(layout);\n+        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+            TypeClass argumentClass = TypeClass.typeClassFor(layout, isVararg);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,3 +31,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n-\n-import static jdk.internal.foreign.PlatformLayouts.Win64.VARARGS_ATTRIBUTE_NAME;\n@@ -42,1 +40,1 @@\n-    private static TypeClass classifyValueType(ValueLayout type) {\n+    private static TypeClass classifyValueType(ValueLayout type, boolean isVararg) {\n@@ -52,9 +50,9 @@\n-        return switch (PlatformLayouts.getKind(type)) {\n-            case BOOL, CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n-            case POINTER -> POINTER;\n-            case FLOAT, DOUBLE -> {\n-                 if (type.attribute(VARARGS_ATTRIBUTE_NAME)\n-                        .map(Boolean.class::cast).orElse(false)) {\n-                    yield VARARG_FLOAT;\n-                }\n-                yield FLOAT;\n+        Class<?> carrier = type.carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            if (isVararg) {\n+                return VARARG_FLOAT;\n+            } else {\n+                return FLOAT;\n@@ -62,1 +60,5 @@\n-        };\n+        } else if (carrier == MemoryAddress.class) {\n+            return POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n@@ -80,1 +82,1 @@\n-    static TypeClass typeClassFor(MemoryLayout type) {\n+    static TypeClass typeClassFor(MemoryLayout type, boolean isVararg) {\n@@ -82,1 +84,1 @@\n-            return classifyValueType((ValueLayout) type);\n+            return classifyValueType((ValueLayout) type, isVararg);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.incubator.foreign.VaList;\n@@ -61,1 +61,1 @@\n-    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n@@ -78,1 +78,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -83,1 +83,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -88,1 +88,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -93,1 +93,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -98,1 +98,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -103,5 +103,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -114,1 +109,0 @@\n-        SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);\n@@ -117,1 +111,1 @@\n-            TypeClass typeClass = TypeClass.typeClassFor(layout);\n+            TypeClass typeClass = TypeClass.typeClassFor(layout, false);\n@@ -121,1 +115,1 @@\n-                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n@@ -126,5 +120,2 @@\n-                case STRUCT_REGISTER -> {\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n-                    yield struct;\n-                }\n+                case STRUCT_REGISTER ->\n+                    allocator.allocate(layout).copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -134,1 +125,1 @@\n-            VarHandle reader = layout.varHandle(carrier);\n+            VarHandle reader = layout.varHandle();\n@@ -149,1 +140,1 @@\n-        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n@@ -186,1 +177,0 @@\n-            SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);\n@@ -192,1 +182,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -197,1 +187,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -202,1 +192,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -207,1 +197,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -212,1 +202,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -229,1 +219,1 @@\n-                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout);\n+                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout, false);\n@@ -237,4 +227,2 @@\n-                        case STRUCT_REGISTER -> {\n-                            MemorySegment slice = cursor.asSlice(0, VA_SLOT_SIZE_BYTES);\n-                            slice.copyFrom(msArg);\n-                        }\n+                        case STRUCT_REGISTER ->\n+                            cursor.copyFrom(msArg.asSlice(0, VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":21,"deletions":33,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -31,1 +33,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n+import jdk.incubator.foreign.VaList;\n@@ -45,1 +47,1 @@\n-public final class Windowsx64Linker extends AbstractCLinker {\n+public final class Windowsx64Linker implements CLinker {\n@@ -72,2 +74,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -75,0 +76,1 @@\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n@@ -84,1 +86,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -89,1 +91,5 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -33,0 +36,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -48,1 +53,1 @@\n-    static SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+    static SegmentAllocator CONFINED_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newSharedScope());\n@@ -61,1 +66,1 @@\n-                VarHandle vh = g.varHandle(vhCarrier(field), MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n+                VarHandle vh = g.varHandle(MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n@@ -373,1 +378,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newSharedScope());\n@@ -377,1 +382,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1, ResourceScope.newImplicitScope());\n+            MemorySegment segment = MemorySegment.allocateNative(1, ResourceScope.newSharedScope());\n@@ -413,1 +418,1 @@\n-            VarHandle accessor = g.varHandle(structFieldCarrier(l), MemoryLayout.PathElement.groupElement(l.name().get()));\n+            VarHandle accessor = g.varHandle(MemoryLayout.PathElement.groupElement(l.name().get()));\n@@ -416,3 +421,0 @@\n-            if (isPointer(l)) {\n-                value = ((MemoryAddress)value).toRawLongValue();\n-            }\n@@ -427,5 +429,1 @@\n-                        if (isPointer(l)) {\n-                            fieldsCheck.get(0).accept(MemoryAddress.ofLong((long)accessor.get(actual)));\n-                        } else {\n-                            fieldsCheck.get(0).accept(accessor.get(actual));\n-                        }\n+                        fieldsCheck.get(0).accept(accessor.get(actual));\n@@ -440,17 +438,1 @@\n-    static Class<?> structFieldCarrier(MemoryLayout layout) {\n-        if (isPointer(layout)) {\n-            return long.class;\n-        } else if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            } else {\n-                return double.class;\n-            }\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n-        }\n-    }\n-\n-    static Class<?> paramCarrier(MemoryLayout layout) {\n+    static Class<?> carrier(MemoryLayout layout, boolean param) {\n@@ -460,9 +442,3 @@\n-            return MemoryAddress.class;\n-        } else if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            } else {\n-                return double.class;\n-            }\n+            return param ? Addressable.class : MemoryAddress.class;\n+        } else if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n@@ -473,0 +449,8 @@\n+\n+    MethodHandle downcallHandle(CLinker abi, Addressable addr, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+        MethodHandle mh = abi.downcallHandle(addr, descriptor);\n+        if (descriptor.returnLayout().isPresent() && descriptor.returnLayout().get() instanceof GroupLayout) {\n+            mh = mh.bindTo(allocator);\n+        }\n+        return mh;\n+    }\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":23,"deletions":39,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -26,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,0 +33,3 @@\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n@@ -33,3 +39,2 @@\n-    static CLinker.TypeKind kind(MemoryLayout layout) {\n-        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-                () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+    public static boolean isIntegral(MemoryLayout layout) {\n+        return layout instanceof ValueLayout valueLayout && isIntegral(valueLayout.carrier());\n@@ -38,2 +43,3 @@\n-    public static boolean isIntegral(MemoryLayout layout) {\n-        return kind(layout).isIntegral();\n+    static boolean isIntegral(Class<?> clazz) {\n+        return clazz == byte.class || clazz == char.class || clazz == short.class\n+                || clazz == int.class || clazz == long.class;\n@@ -43,1 +49,1 @@\n-        return kind(layout).isPointer();\n+        return layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemoryAddress.class;\n@@ -48,1 +54,1 @@\n-        final ResourceScope.Handle scopeHandle;\n+        final ResourceScope privateScope;\n@@ -55,1 +61,2 @@\n-            this.scopeHandle = resourceScope.acquire();\n+            this.privateScope = ResourceScope.newConfinedScope();\n+            privateScope.keepAlive(resourceScope);\n@@ -75,1 +82,1 @@\n-            resourceScope.release(scopeHandle);\n+            privateScope.close();\n@@ -79,0 +86,60 @@\n+\n+    \/\/ the constants below are useful aliases for C types. The type\/carrier association is only valid for 64-bit platforms.\n+\n+    \/**\n+     * The layout for the {@code bool} C type\n+     *\/\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    \/**\n+     * The layout for the {@code char} C type\n+     *\/\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    \/**\n+     * The layout for the {@code short} C type\n+     *\/\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    \/**\n+     * The layout for the {@code int} C type\n+     *\/\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n+\n+    \/**\n+     * The layout for the {@code long long} C type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    \/**\n+     * The layout for the {@code float} C type\n+     *\/\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    \/**\n+     * The layout for the {@code double} C type\n+     *\/\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    \/**\n+     * The {@code T*} native type.\n+     *\/\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+\n+    private static CLinker LINKER = CLinker.systemCLinker();\n+\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":76,"deletions":9,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -39,0 +40,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -41,0 +43,1 @@\n+import jdk.incubator.foreign.VaList;\n@@ -42,0 +45,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -44,1 +49,1 @@\n-public class SafeFunctionAccessTest {\n+public class SafeFunctionAccessTest extends NativeTestHelper {\n@@ -50,1 +55,1 @@\n-            CLinker.C_INT, CLinker.C_INT\n+            C_INT, C_INT\n@@ -62,1 +67,1 @@\n-        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n@@ -64,1 +69,0 @@\n-                MethodType.methodType(void.class, MemorySegment.class),\n@@ -71,2 +75,2 @@\n-    public void testClosedPointer() throws Throwable {\n-        MemoryAddress address;\n+    public void testClosedVaList() throws Throwable {\n+        VaList list;\n@@ -74,1 +78,1 @@\n-            address = MemorySegment.allocateNative(POINT, scope).address();\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n@@ -76,2 +80,2 @@\n-        assertFalse(address.scope().isAlive());\n-        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+        assertFalse(list.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n@@ -79,2 +83,1 @@\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(CLinker.C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER));\n@@ -82,1 +85,1 @@\n-        handle.invokeExact(address);\n+        handle.invokeExact((Addressable)list);\n@@ -84,0 +87,17 @@\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedUpcall() throws Throwable {\n+        CLinker.UpcallStub upcall;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MethodHandle dummy = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"dummy\", MethodType.methodType(void.class));\n+            upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+        }\n+        assertFalse(upcall.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER));\n+\n+        handle.invokeExact((Addressable)upcall);\n+    }\n+\n+    static void dummy() { }\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":32,"deletions":12,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Optional;\n@@ -51,2 +50,0 @@\n-import static jdk.incubator.foreign.MemoryAccess.*;\n-\n@@ -55,1 +52,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -59,1 +55,1 @@\n-public class StdLibTest {\n+public class StdLibTest extends NativeTestHelper {\n@@ -61,1 +57,1 @@\n-    final static CLinker abi = CLinker.getInstance();\n+    final static CLinker abi = CLinker.systemCLinker();\n@@ -158,5 +154,3 @@\n-        static final SymbolLookup LOOKUP = CLinker.systemLookup();\n-\n-        final static MethodHandle strcat = abi.downcallHandle(LOOKUP.lookup(\"strcat\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));\n+        final static MethodHandle strcat = abi.downcallHandle(abi.lookup(\"strcat\").get(),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER))\n+                .asType(MethodType.methodType(MemoryAddress.class, MemorySegment.class, MemorySegment.class)); \/\/ exact signature match\n@@ -164,2 +158,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(LOOKUP.lookup(\"strcmp\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),\n+        final static MethodHandle strcmp = abi.downcallHandle(abi.lookup(\"strcmp\").get(),\n@@ -168,2 +161,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(LOOKUP.lookup(\"puts\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        final static MethodHandle puts = abi.downcallHandle(abi.lookup(\"puts\").get(),\n@@ -172,2 +164,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(LOOKUP.lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        final static MethodHandle strlen = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n@@ -176,2 +167,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(LOOKUP.lookup(\"gmtime\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+        final static MethodHandle gmtime = abi.downcallHandle(abi.lookup(\"gmtime\").get(),\n@@ -180,2 +170,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(LOOKUP.lookup(\"qsort\").get(),\n-                MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+        final static MethodHandle qsort = abi.downcallHandle(abi.lookup(\"qsort\").get(),\n@@ -188,2 +177,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(LOOKUP.lookup(\"rand\").get(),\n-                MethodType.methodType(int.class),\n+        final static MethodHandle rand = abi.downcallHandle(abi.lookup(\"rand\").get(),\n@@ -192,2 +180,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(LOOKUP.lookup(\"vprintf\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),\n+        final static MethodHandle vprintf = abi.downcallHandle(abi.lookup(\"vprintf\").get(),\n@@ -196,1 +183,1 @@\n-        final static MemoryAddress printfAddr = LOOKUP.lookup(\"printf\").get();\n+        final static MemoryAddress printfAddr = abi.lookup(\"printf\").get();\n@@ -204,1 +191,1 @@\n-                        MethodType.methodType(int.class, MemorySegment.class, MemoryAddress.class, MemoryAddress.class));\n+                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n@@ -212,8 +199,4 @@\n-                MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1, scope);\n-                MemorySegment other = toCString(s2, scope);\n-                char[] chars = s1.toCharArray();\n-                for (long i = 0 ; i < chars.length ; i++) {\n-                    setByteAtOffset(buf, i, (byte)chars[(int)i]);\n-                }\n-                setByteAtOffset(buf, chars.length, (byte)'\\0');\n-                return toJavaString(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));\n+                MemorySegment buf = scope.allocate(s1.length() + s2.length() + 1);\n+                buf.setUtf8String(0, s1);\n+                MemorySegment other = scope.allocateUtf8String(s2);\n+                return ((MemoryAddress)strcat.invokeExact(buf, other)).getUtf8String(0);\n@@ -225,3 +208,3 @@\n-                MemorySegment ns1 = toCString(s1, scope);\n-                MemorySegment ns2 = toCString(s2, scope);\n-                return (int)strcmp.invokeExact(ns1.address(), ns2.address());\n+                MemorySegment ns1 = scope.allocateUtf8String(s1);\n+                MemorySegment ns2 = scope.allocateUtf8String(s2);\n+                return (int)strcmp.invoke(ns1, ns2);\n@@ -233,2 +216,2 @@\n-                MemorySegment s = toCString(msg, scope);\n-                return (int)puts.invokeExact(s.address());\n+                MemorySegment s = scope.allocateUtf8String(msg);\n+                return (int)puts.invoke(s);\n@@ -240,2 +223,2 @@\n-                MemorySegment s = toCString(msg, scope);\n-                return (int)strlen.invokeExact(s.address());\n+                MemorySegment s = scope.allocateUtf8String(msg);\n+                return (int)strlen.invoke(s);\n@@ -247,3 +230,3 @@\n-                MemorySegment time = MemorySegment.allocateNative(8, scope);\n-                setLong(time, arg);\n-                return new Tm((MemoryAddress)gmtime.invokeExact(time.address()));\n+                MemorySegment time = scope.allocate(8);\n+                time.set(C_LONG_LONG, 0, arg);\n+                return new Tm((MemoryAddress)gmtime.invoke(time));\n@@ -261,1 +244,1 @@\n-                this.base = addr.asSegment(SIZE, ResourceScope.globalScope());\n+                this.base = MemorySegment.ofAddressNative(addr, SIZE, ResourceScope.globalScope());\n@@ -265,1 +248,1 @@\n-                return getIntAtOffset(base, 0);\n+                return base.get(C_INT, 0);\n@@ -268,1 +251,1 @@\n-                return getIntAtOffset(base, 4);\n+                return base.get(C_INT, 4);\n@@ -271,1 +254,1 @@\n-                return getIntAtOffset(base, 8);\n+                return base.get(C_INT, 8);\n@@ -274,1 +257,1 @@\n-                return getIntAtOffset(base, 12);\n+                return base.get(C_INT, 12);\n@@ -277,1 +260,1 @@\n-                return getIntAtOffset(base, 16);\n+                return base.get(C_INT, 16);\n@@ -280,1 +263,1 @@\n-                return getIntAtOffset(base, 20);\n+                return base.get(C_INT, 20);\n@@ -283,1 +266,1 @@\n-                return getIntAtOffset(base, 24);\n+                return base.get(C_INT, 24);\n@@ -286,1 +269,1 @@\n-                return getIntAtOffset(base, 28);\n+                return base.get(C_INT, 28);\n@@ -289,2 +272,1 @@\n-                byte b = getByteAtOffset(base, 32);\n-                return b != 0;\n+                return base.get(C_BOOL, 32);\n@@ -297,2 +279,1 @@\n-                SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-                MemorySegment nativeArr = allocator.allocateArray(C_INT, arr);\n+                MemorySegment nativeArr = scope.allocateArray(C_INT, arr);\n@@ -301,1 +282,1 @@\n-                MemoryAddress qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope);\n+                CLinker.UpcallStub qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n@@ -303,1 +284,1 @@\n-                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                qsort.invoke(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n@@ -306,1 +287,1 @@\n-                return nativeArr.toIntArray();\n+                return nativeArr.toArray(C_INT);\n@@ -310,3 +291,3 @@\n-        static int qsortCompare(MemorySegment base, MemoryAddress addr1, MemoryAddress addr2) {\n-            return getIntAtOffset(base, addr1.segmentOffset(base)) -\n-                   getIntAtOffset(base, addr2.segmentOffset(base));\n+        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+            return addr1.get(C_INT, 0) -\n+                   addr2.get(C_INT, 0);\n@@ -321,2 +302,2 @@\n-                MemorySegment formatStr = toCString(format, scope);\n-                return (int)specializedPrintf(args).invokeExact(formatStr.address(),\n+                MemorySegment formatStr = scope.allocateUtf8String(format);\n+                return (int)specializedPrintf(args).invoke(formatStr,\n@@ -329,1 +310,1 @@\n-                MemorySegment formatStr = toCString(format, scope);\n+                MemorySegment formatStr = scope.allocateUtf8String(format);\n@@ -331,1 +312,1 @@\n-                return (int)vprintf.invokeExact(formatStr.address(), vaList.address());\n+                return (int)vprintf.invoke(formatStr, vaList);\n@@ -339,0 +320,1 @@\n+            List<MemoryLayout> variadicLayouts = new ArrayList<>(args.size());\n@@ -341,1 +323,1 @@\n-                fd = fd.withAppendedArgumentLayouts(arg.layout);\n+                variadicLayouts.add(arg.layout);\n@@ -343,1 +325,2 @@\n-            MethodHandle mh = abi.downcallHandle(printfAddr, mt, fd);\n+            MethodHandle mh = abi.downcallHandle(printfAddr,\n+                    fd.asVariadic(variadicLayouts.toArray(new MemoryLayout[args.size()])));\n@@ -404,4 +387,4 @@\n-        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", scope -> 42, 42, VaList.Builder::vargFromInt),\n-        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", scope -> toCString(\"str\", scope).address(), \"str\", VaList.Builder::vargFromAddress),\n-        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n-        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n+        INTEGRAL(int.class, C_INT, \"%d\", scope -> 42, 42, VaList.Builder::addVarg),\n+        STRING(MemoryAddress.class, C_POINTER, \"%s\", scope -> scope.allocateUtf8String(\"str\").address(), \"str\", VaList.Builder::addVarg),\n+        CHAR(byte.class, C_CHAR, \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n@@ -417,1 +400,1 @@\n-        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n@@ -432,2 +415,2 @@\n-        interface VaListBuilderCall<V> {\n-            void build(VaList.Builder builder, ValueLayout layout, V value);\n+        interface VaListBuilderCall<V, L> {\n+            void build(VaList.Builder builder, L layout, V value);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":60,"deletions":77,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -89,2 +88,2 @@\n-    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -92,1 +91,1 @@\n-    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -94,1 +93,1 @@\n-    static final VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n+    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n@@ -98,3 +97,3 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        VarHandle intHandle = layout.varHandle();\n@@ -117,3 +116,3 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        VarHandle intHandle = layout.varHandle();\n@@ -138,3 +137,3 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        VarHandle intHandle = layout.varHandle();\n@@ -162,1 +161,1 @@\n-        VarHandle floatHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle floatHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -168,1 +167,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -174,1 +173,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -182,1 +181,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -188,1 +187,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -194,1 +193,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -197,1 +196,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n@@ -205,1 +204,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -208,1 +207,1 @@\n-            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n@@ -215,2 +214,2 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n@@ -258,2 +257,2 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n@@ -296,2 +295,2 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n@@ -335,2 +334,2 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n@@ -378,2 +377,2 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":32,"deletions":33,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle\n- *\/\n-\n-import java.lang.invoke.*;\n-import java.nio.ByteOrder;\n-import jdk.incubator.foreign.*;\n-\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestAddressHandle {\n-\n-    static final MethodHandle INT_TO_BOOL;\n-    static final MethodHandle BOOL_TO_INT;\n-    static final MethodHandle INT_TO_STRING;\n-    static final MethodHandle STRING_TO_INT;\n-\n-    static {\n-        try {\n-            INT_TO_BOOL = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"intToBool\",\n-                    MethodType.methodType(boolean.class, int.class));\n-            BOOL_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"boolToInt\",\n-                    MethodType.methodType(int.class, boolean.class));\n-            INT_TO_STRING = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"intToString\",\n-                    MethodType.methodType(String.class, int.class));\n-            STRING_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"stringToInt\",\n-                    MethodType.methodType(int.class, String.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"addressHandles\")\n-    public void testAddressHandle(VarHandle addrHandle, int byteSize) {\n-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n-            MemorySegment target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n-                    segment.asSlice(8 - byteSize) :\n-                    segment;\n-            longHandle.set(segment, 42L);\n-            MemoryAddress address = (MemoryAddress)addrHandle.get(target);\n-            assertEquals(address.toRawLongValue(), 42L);\n-            addrHandle.set(target, address.addOffset(1));\n-            long result = (long)longHandle.get(segment);\n-            assertEquals(43L, result);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"addressHandles\")\n-    public void testNull(VarHandle addrHandle, int byteSize) {\n-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n-            longHandle.set(segment, 0L);\n-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment);\n-            assertTrue(address == MemoryAddress.NULL);\n-        }\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptFloat() {\n-        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n-        MemoryHandles.asAddressVarHandle(floatHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptDouble() {\n-        VarHandle doubleHandle = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);\n-        MemoryHandles.asAddressVarHandle(doubleHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptBoolean() {\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        VarHandle boolHandle = MemoryHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);\n-        MemoryHandles.asAddressVarHandle(boolHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptString() {\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        VarHandle stringHandle = MemoryHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);\n-        MemoryHandles.asAddressVarHandle(stringHandle);\n-    }\n-\n-    @DataProvider(name = \"addressHandles\")\n-    static Object[][] addressHandles() {\n-        return new Object[][] {\n-                \/\/ long\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)), 8 },\n-\n-                \/\/ int\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)), 4 },\n-\n-                \/\/ short\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)), 2 },\n-\n-                \/\/ char\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)), 2 },\n-\n-                \/\/ byte\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)), 1 }\n-        };\n-    }\n-\n-    static VarHandle at(VarHandle handle, long offset) {\n-        return MemoryHandles.insertCoordinates(handle, 1, offset);\n-    }\n-\n-    static int boolToInt(boolean value) {\n-        return value ? 1 : 0;\n-    }\n-\n-    static boolean intToBool(int value) {\n-        return value != 0;\n-    }\n-\n-    static int stringToInt(String value) {\n-        return value.length();\n-    }\n-\n-    static String intToString(int value) {\n-        return String.valueOf(value);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -0,0 +1,542 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floorston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCopy\n+ *\/\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n+ * To make these tests more challenging the segment is a view of the given array,\n+ * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\/\n+public class TestArrayCopy {\n+    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n+    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n+            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n+\n+    private static final int SEG_LENGTH_BYTES = 32;\n+    private static final int SEG_OFFSET_BYTES = 8;\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testSelfCopy(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        assertEquals(truth.mismatch(dstSeg), -1);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemorySegment result = helper.fromArray(dstArr);\n+        assertEquals(truth.mismatch(result), -1);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testUnalignedCopy(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? (SEG_OFFSET_BYTES - 1) : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : (SEG_OFFSET_BYTES - 1);\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobLength(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeIndices(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeOffsets(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobIndices(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobOffsets(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNotAnArraySrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_BYTE, 0, new String[] { \"hello\" }, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNotAnArrayDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(new String[] { \"hello\" }, 0, segment, JAVA_BYTE, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testCarrierMismatchSrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_INT, 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testCarrierMismatchDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_INT, 0, 4);\n+    }\n+\n+    \/***** Utilities *****\/\n+\n+    public static MemorySegment srcSegment(int bytesLength) {\n+        byte[] arr = new byte[bytesLength];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte)i;\n+        }\n+        return MemorySegment.ofArray(arr);\n+    }\n+\n+    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?, ?> helper, int indexShifts, CopyMode mode) {\n+        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n+                                                .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n+                                                 .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toArray(JAVA_BYTE));\n+        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n+        if (mode.direction) {\n+            if (mode.swap) {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            } else {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            }\n+        } else { \/\/down\n+            if (mode.swap) {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            } else {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            }\n+        }\n+        return dstSeg;\n+    }\n+\n+    enum CopyMode {\n+        UP_NO_SWAP(true, false),\n+        UP_SWAP(true, true),\n+        DOWN_NO_SWAP(false, false),\n+        DOWN_SWAP(false, true);\n+\n+        final boolean direction;\n+        final boolean swap;\n+\n+        CopyMode(boolean direction, boolean swap) {\n+            this.direction = direction;\n+            this.swap = swap;\n+        }\n+    }\n+\n+    abstract static class CopyHelper<X, L extends ValueLayout> {\n+\n+        final L elementLayout;\n+        final Class<?> carrier;\n+\n+        public CopyHelper(L elementLayout, Class<X> carrier) {\n+            this.elementLayout = elementLayout;\n+            this.carrier = carrier;\n+        }\n+\n+        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n+        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n+        abstract X toArray(MemorySegment segment);\n+        abstract MemorySegment fromArray(X array);\n+        abstract int length(X arr);\n+\n+        @Override\n+        public String toString() {\n+            return \"CopyHelper{\" +\n+                    \"elementLayout=\" + elementLayout +\n+                    \", carrier=\" + carrier.getName() +\n+                    '}';\n+        }\n+\n+        static final CopyHelper<byte[], ValueLayout.OfByte> BYTE = new CopyHelper<>(JAVA_BYTE, byte[].class) {\n+            @Override\n+            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            byte[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(byte[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(byte[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<char[], ValueLayout.OfChar> CHAR = new CopyHelper<>(ValueLayout.JAVA_CHAR, char[].class) {\n+            @Override\n+            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            char[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(char[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(char[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<short[], ValueLayout.OfShort> SHORT = new CopyHelper<>(ValueLayout.JAVA_SHORT, short[].class) {\n+            @Override\n+            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            short[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(short[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(short[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<int[], ValueLayout.OfInt> INT = new CopyHelper<>(ValueLayout.JAVA_INT, int[].class) {\n+            @Override\n+            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            int[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(int[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(int[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<float[], ValueLayout.OfFloat> FLOAT = new CopyHelper<>(ValueLayout.JAVA_FLOAT, float[].class) {\n+            @Override\n+            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            float[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(float[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(float[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<long[], ValueLayout.OfLong> LONG = new CopyHelper<>(ValueLayout.JAVA_LONG, long[].class) {\n+            @Override\n+            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            long[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(long[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(long[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<double[], ValueLayout.OfDouble> DOUBLE = new CopyHelper<>(ValueLayout.JAVA_DOUBLE, double[].class) {\n+            @Override\n+            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            double[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(double[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(double[] arr) {\n+                return arr.length;\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] copyModesAndHelpers() {\n+        CopyHelper<?, ?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n+                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n+        List<Object[]> results = new ArrayList<>();\n+        for (CopyHelper<?, ?> helper : helpers) {\n+            for (CopyMode mode : CopyMode.values()) {\n+                results.add(new Object[] { mode, helper, helper.toString() });\n+            }\n+        }\n+        return results.stream().toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":542,"deletions":0,"binary":false,"changes":542,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -46,0 +45,7 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -51,1 +57,1 @@\n-            MemoryLayouts.JAVA_BYTE\n+            JAVA_BYTE\n@@ -55,1 +61,1 @@\n-            MemoryLayouts.JAVA_CHAR\n+            JAVA_CHAR\n@@ -59,1 +65,1 @@\n-            MemoryLayouts.JAVA_SHORT\n+            JAVA_SHORT\n@@ -63,1 +69,1 @@\n-            MemoryLayouts.JAVA_INT\n+            JAVA_INT\n@@ -67,1 +73,1 @@\n-            MemoryLayouts.JAVA_FLOAT\n+            JAVA_FLOAT\n@@ -71,1 +77,1 @@\n-            MemoryLayouts.JAVA_LONG\n+            JAVA_LONG\n@@ -75,1 +81,1 @@\n-            MemoryLayouts.JAVA_DOUBLE\n+            JAVA_DOUBLE\n@@ -78,7 +84,7 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());\n+    static VarHandle byteHandle = bytes.varHandle(PathElement.sequenceElement());\n+    static VarHandle charHandle = chars.varHandle(PathElement.sequenceElement());\n+    static VarHandle shortHandle = shorts.varHandle(PathElement.sequenceElement());\n+    static VarHandle intHandle = ints.varHandle(PathElement.sequenceElement());\n+    static VarHandle floatHandle = floats.varHandle(PathElement.sequenceElement());\n+    static VarHandle longHandle = longs.varHandle(PathElement.sequenceElement());\n+    static VarHandle doubleHandle = doubles.varHandle(PathElement.sequenceElement());\n@@ -104,1 +110,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n@@ -115,1 +121,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, seq.byteSize(), ResourceScope.globalScope());\n@@ -155,1 +161,1 @@\n-                (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n@@ -157,1 +163,1 @@\n-                (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n@@ -159,1 +165,1 @@\n-                (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n@@ -161,1 +167,1 @@\n-                (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n@@ -163,1 +169,1 @@\n-                (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n@@ -165,1 +171,1 @@\n-                (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n@@ -167,1 +173,1 @@\n-                (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n@@ -183,7 +189,7 @@\n-                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegment::toByteArray },\n-                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegment::toShortArray },\n-                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegment::toCharArray },\n-                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegment::toIntArray },\n-                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegment::toFloatArray },\n-                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegment::toLongArray },\n-                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegment::toDoubleArray }\n+                { JAVA_BYTE, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_BYTE)},\n+                { JAVA_SHORT, (Function<MemorySegment, Object>) s -> s.toArray(JAVA_SHORT)},\n+                { JAVA_CHAR, (Function<MemorySegment, Object>) s -> s.toArray(JAVA_CHAR)},\n+                { JAVA_INT, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_INT)},\n+                { JAVA_FLOAT, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_FLOAT)},\n+                { JAVA_LONG, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_LONG)},\n+                { JAVA_DOUBLE, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_DOUBLE)}\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -85,0 +83,7 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -105,2 +110,2 @@\n-                    MemoryLayouts.BITS_32_BE.withName(\"index\"),\n-                    MemoryLayouts.BITS_32_BE.withName(\"value\")\n+                    JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"index\"),\n+                    JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n@@ -110,1 +115,1 @@\n-            MemoryLayouts.BITS_8_BE\n+            JAVA_BYTE\n@@ -114,1 +119,1 @@\n-            MemoryLayouts.BITS_16_BE\n+            JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -118,1 +123,1 @@\n-            MemoryLayouts.BITS_16_BE\n+            JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -122,1 +127,1 @@\n-            MemoryLayouts.BITS_32_BE\n+            JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -126,1 +131,1 @@\n-            MemoryLayouts.BITS_32_BE\n+            JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -130,1 +135,1 @@\n-            MemoryLayouts.BITS_64_BE\n+            JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -134,1 +139,1 @@\n-            MemoryLayouts.BITS_64_BE\n+            JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -137,2 +142,2 @@\n-    static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement(\"index\"));\n-    static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement(\"value\"));\n+    static VarHandle indexHandle = tuples.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"index\"));\n+    static VarHandle valueHandle = tuples.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"value\"));\n@@ -266,1 +271,1 @@\n-    @Test(dataProvider = \"mappedOps\", expectedExceptions = UnsupportedOperationException.class)\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n@@ -272,1 +277,1 @@\n-        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n@@ -486,1 +491,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(Integer.MAX_VALUE + 10L, ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.globalScope());\n@@ -495,1 +500,1 @@\n-        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n@@ -503,1 +508,1 @@\n-        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n@@ -517,1 +522,1 @@\n-                MemoryAccess.setByteAtOffset(segment, offset, offset);\n+                segment.set(JAVA_BYTE, offset, offset);\n@@ -525,1 +530,1 @@\n-                assertEquals(MemoryAccess.getByte(segment), offset);\n+                assertEquals(segment.get(JAVA_BYTE, 0), offset);\n@@ -562,1 +567,1 @@\n-        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n+        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n@@ -642,1 +647,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, ResourceScope.newConfinedScope());\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n@@ -648,1 +653,1 @@\n-        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n+        s2.set(JAVA_INT, 0, 10); \/\/ Dead access!\n@@ -660,1 +665,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                segment.set(JAVA_BYTE, i, (byte) i);\n@@ -680,1 +685,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                segment.set(JAVA_BYTE, i, (byte) i);\n@@ -700,1 +705,1 @@\n-            var bytes = slice.toByteArray();\n+            var bytes = slice.toArray(JAVA_BYTE);\n@@ -724,1 +729,1 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newImplicitScope()) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()) },\n@@ -732,12 +737,2 @@\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope()   },\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope() },\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope(Cleaner.create())   },\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) }\n-        };\n-    }\n-\n-    @DataProvider(name = \"implicitScopes\")\n-    public static Object[][] implicitScopes() {\n-        return new Object[][] {\n-                { (Supplier<ResourceScope>) ResourceScope::newImplicitScope },\n-                { (Supplier<ResourceScope>) ResourceScope::globalScope      },\n+                { (Supplier<ResourceScope>)ResourceScope::newConfinedScope },\n+                { (Supplier<ResourceScope>)ResourceScope::newSharedScope }\n@@ -749,1 +744,1 @@\n-        return Stream.of(implicitScopes(), closeableScopes())\n+        return Stream.of(new Object[][] { { (Supplier<ResourceScope>)ResourceScope::globalScope } }, closeableScopes())\n@@ -755,1 +750,1 @@\n-        if (scope.isImplicit())\n+        if (scope == ResourceScope.globalScope())\n@@ -818,1 +813,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtOffset(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> addr.set(JAVA_BYTE, pos, (byte)(long)pos));\n@@ -820,1 +815,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> addr.setAtIndex(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), pos, (char)(long)pos));\n@@ -822,1 +817,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> addr.setAtIndex(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), pos, (short)(long)pos));\n@@ -824,1 +819,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> addr.setAtIndex(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), pos, (int)(long)pos));\n@@ -826,1 +821,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> addr.setAtIndex(JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), pos, (float)(long)pos));\n@@ -828,1 +823,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> addr.setAtIndex(JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), pos, (long)pos));\n@@ -830,1 +825,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> addr.setAtIndex(JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), pos, (double)(long)pos));\n@@ -833,1 +828,1 @@\n-                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtOffset(addr, pos), ByteBuffer::get);\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> addr.get(JAVA_BYTE, pos), ByteBuffer::get);\n@@ -835,1 +830,1 @@\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> addr.getAtIndex(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), pos), CharBuffer::get);\n@@ -837,1 +832,1 @@\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> addr.getAtIndex(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), pos), ShortBuffer::get);\n@@ -839,1 +834,1 @@\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> addr.getAtIndex(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), pos), IntBuffer::get);\n@@ -841,1 +836,1 @@\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> addr.getAtIndex(JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), pos), FloatBuffer::get);\n@@ -843,1 +838,1 @@\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> addr.getAtIndex(JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), pos), LongBuffer::get);\n@@ -845,1 +840,1 @@\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> addr.getAtIndex(JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), pos), DoubleBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":50,"deletions":55,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm TestCircularInit1\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.internal.foreign.PlatformLayouts;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertNotNull;\n-\n-public class TestCircularInit1 {\n-\n-    @Test\n-    public void testCircularInit() {\n-        System.out.println(PlatformLayouts.Win64.C_CHAR); \/\/ trigger clinit\n-        assertNotNull(CLinker.C_CHAR); \/\/ should not be null\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit1.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm TestCircularInit2\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.internal.foreign.PlatformLayouts;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertNotNull;\n-\n-public class TestCircularInit2 {\n-\n-    @Test\n-    public void testCircularInit() {\n-        System.out.println(CLinker.C_CHAR); \/\/ trigger clinit\n-        assertNotNull(PlatformLayouts.Win64.C_CHAR);\n-        assertNotNull(PlatformLayouts.SysV.C_CHAR);\n-        assertNotNull(PlatformLayouts.AArch64.C_CHAR);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit2.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -42,1 +42,9 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -56,8 +64,9 @@\n-        C_CHAR,\n-        C_SHORT,\n-        C_INT,\n-        C_LONG,\n-        C_LONG_LONG,\n-        C_FLOAT,\n-        C_DOUBLE,\n-        C_POINTER\n+        JAVA_BOOLEAN,\n+        JAVA_CHAR,\n+        JAVA_BYTE,\n+        JAVA_SHORT,\n+        JAVA_INT,\n+        JAVA_FLOAT,\n+        JAVA_LONG,\n+        JAVA_DOUBLE,\n+        ADDRESS\n@@ -81,1 +90,1 @@\n-        testValues.add(FunctionDescriptor.of(C_CHAR, constants));\n+        testValues.add(FunctionDescriptor.of(JAVA_BYTE, constants));\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,214 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestCopyFrom\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestCopyFrom {\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.byteSize(), s2.byteSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s2, i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s1, i, i);\n-        }\n-        \/\/perform copy\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.check(s2, i, i);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n-        if (s1.type.carrier != s2.type.carrier) return;\n-        int size = Math.min(s1.elementSize(), s2.elementSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            s2.set(i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            s1.set(i, i);\n-        }\n-        \/\/perform copy\n-        s2.segment.copyFrom(s2.type.layout, s1.segment.asSlice(0, size * s1.type.size()), s1.type.layout);\n-        \/\/check that copy actually worked\n-        for (int i = 0; i < size; i++) {\n-            s2.check(i, i);\n-        }\n-    }\n-\n-    interface Getter<X> {\n-        X get(MemorySegment segment, long index, ByteOrder order);\n-    }\n-\n-    interface Setter<X> {\n-        void set(MemorySegment segment, long index, ByteOrder order, X val);\n-    }\n-\n-    enum Type {\n-        \/\/ Byte\n-        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByteAtOffset(s, i), (s, i, o, v) -> MemoryAccess.setByteAtOffset(s, i, v), i -> (byte)i),\n-        \/\/LE\n-        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i),\n-        \/\/BE\n-        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i);\n-\n-        final ValueLayout layout;\n-        final Getter<Object> getter;\n-        final Setter<Object> setter;\n-        final IntFunction<Object> valueConverter;\n-        final Class<?> carrier;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        <Z> Type(Class<Z> carrier, ValueLayout layout, Getter<Z> getter, Setter<Z> setter, IntFunction<Z> valueConverter) {\n-            this.carrier = carrier;\n-            this.layout = layout;\n-            this.getter = (Getter<Object>)getter;\n-            this.setter = (Setter<Object>)setter;\n-            this.valueConverter = (IntFunction<Object>)valueConverter;\n-        }\n-\n-        int size() {\n-            return (int)layout.byteSize();\n-        }\n-\n-        void set(SegmentSlice slice, int index, int val) {\n-            setter.set(slice.segment, index * size(), layout.order(), valueConverter.apply(val));\n-        }\n-\n-        void check(SegmentSlice slice, int index, int val) {\n-            assertEquals(getter.get(slice.segment, index * size(), layout.order()), valueConverter.apply(val));\n-        }\n-    }\n-\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n-\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final Type type;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.type = type;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n-\n-        void set(int index, int val) {\n-            type.set(this, index, val);\n-        }\n-\n-        void check(int index, int val) {\n-            type.check(this, index, val);\n-        }\n-\n-        int byteSize() {\n-            return last - first + 1;\n-        }\n-\n-        int elementSize() {\n-            return byteSize() \/ type.size();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n-        }\n-    }\n-\n-    @DataProvider(name = \"slices\")\n-    static Object[][] elementSlices() {\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (Type type : Type.values()) {\n-                for (int index = 0; index < 16; index += type.size()) {\n-                    MemorySegment first = segment.asSlice(0, index);\n-                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n-                    MemorySegment second = segment.asSlice(index);\n-                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n-                }\n-            }\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -55,1 +56,1 @@\n-    static CLinker abi = CLinker.getInstance();\n+    static CLinker abi = CLinker.systemCLinker();\n@@ -97,1 +98,1 @@\n-        Object res = doCall(addr, IMPLICIT_ALLOCATOR, mt, descriptor, args);\n+        Object res = doCall(addr, CONFINED_ALLOCATOR, mt, descriptor, args);\n@@ -102,6 +103,1 @@\n-                try {\n-                    ((MemorySegment)res).scope().close(); \/\/ should throw\n-                    fail(\"Expected exception!\");\n-                } catch (UnsupportedOperationException ex) {\n-                    \/\/ ok\n-                }\n+                ((MemorySegment)res).scope().close(); \/\/ should be ok\n@@ -112,2 +108,3 @@\n-    Object doCall(MemoryAddress addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n-        MethodHandle mh = abi.downcallHandle(addr, allocator, type, descriptor);\n+\n+    Object doCall(Addressable addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n@@ -120,1 +117,1 @@\n-                MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));\n+                MethodType.methodType(void.class) : MethodType.methodType(carrier(params.get(0).layout(fields), false));\n@@ -122,1 +119,1 @@\n-            mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));\n+            mt = mt.appendParameterTypes(carrier(p.layout(fields), true));\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -38,1 +37,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -41,1 +39,1 @@\n-public class TestFree {\n+public class TestFree extends NativeTestHelper {\n@@ -43,1 +41,1 @@\n-        return addr.asSegment(numElements * layout.byteSize(), ResourceScope.globalScope());\n+        return MemorySegment.ofAddressNative(addr, numElements * layout.byteSize(), ResourceScope.globalScope());\n@@ -51,2 +49,2 @@\n-        MemoryAccess.setByteAtOffset(seg, str.length(), (byte)0);\n-        assertEquals(str, toJavaString(seg));\n+        seg.set(C_CHAR, str.length(), (byte)0);\n+        assertEquals(str, seg.getUtf8String(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng TestFunctionDescriptor\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFunctionDescriptor\n@@ -40,4 +40,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -48,1 +44,1 @@\n-public class TestFunctionDescriptor {\n+public class TestFunctionDescriptor extends NativeTestHelper {\n@@ -71,15 +67,0 @@\n-    @Test\n-    public void testAttribute() {\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n-        fd = fd.withAttribute(DUMMY_ATTR, true);\n-\n-        assertEquals(fd.argumentLayouts(), List.of(C_DOUBLE, C_LONG_LONG));\n-        Optional<MemoryLayout> returnLayoutOp = fd.returnLayout();\n-        assertTrue(returnLayoutOp.isPresent());\n-        assertEquals(returnLayoutOp.get(), C_INT);\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n-        Optional<Constable> attr = fd.attribute(DUMMY_ATTR);\n-        assertTrue(attr.isPresent());\n-        assertEquals(attr.get(), true);\n-    }\n-\n@@ -88,2 +69,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -96,1 +76,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n@@ -101,2 +80,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -109,1 +87,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n@@ -114,2 +91,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -121,1 +97,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -51,0 +50,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -153,1 +154,1 @@\n-                sum += MemoryAccess.getByteAtOffset(segment, i);\n+                sum += segment.get(JAVA_BYTE, i);\n@@ -196,1 +197,1 @@\n-            MemoryAccess.setByteAtOffset(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+            copy.set(JAVA_BYTE, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n@@ -40,3 +38,0 @@\n-import java.lang.invoke.MethodType;\n-\n-import static jdk.incubator.foreign.CLinker.C_INT;\n@@ -46,1 +41,1 @@\n-public class TestIllegalLink {\n+public class TestIllegalLink extends NativeTestHelper {\n@@ -49,1 +44,1 @@\n-    private static final CLinker ABI = CLinker.getInstance();\n+    private static final CLinker ABI = CLinker.systemCLinker();\n@@ -52,1 +47,1 @@\n-    public void testTypeMismatch(MethodType mt, FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testTypeMismatch(FunctionDescriptor desc, String expectedExceptionMessage) {\n@@ -54,1 +49,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, mt, desc);\n+            ABI.downcallHandle(DUMMY_TARGET, desc);\n@@ -65,13 +60,2 @@\n-                MethodType.methodType(void.class),\n-                FunctionDescriptor.of(C_INT),\n-                \"Return type mismatch\"\n-            },\n-            {\n-                MethodType.methodType(void.class),\n-                FunctionDescriptor.ofVoid(C_INT),\n-                \"Arity mismatch\"\n-            },\n-            {\n-                MethodType.methodType(void.class, int.class),\n-                FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(32)),\n-                \"Expected a ValueLayout\"\n+                FunctionDescriptor.of(MemoryLayout.paddingLayout(64)),\n+                \"Unsupported layout: x64\"\n@@ -80,6 +64,0 @@\n-                MethodType.methodType(void.class, int.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Carrier size mismatch\"\n-            },\n-            {\n-                MethodType.methodType(void.class, MemoryAddress.class),\n@@ -87,6 +65,1 @@\n-                \"Expected a ValueLayout\"\n-            },\n-            {\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_16_LE),\n-                \"Address size mismatch\"\n+                \"Unsupported layout: x64\"\n@@ -95,3 +68,2 @@\n-                MethodType.methodType(void.class, MemorySegment.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Expected a GroupLayout\"\n+                    FunctionDescriptor.of(MemoryLayout.sequenceLayout(C_INT)),\n+                    \"Unsupported layout: [:b32]\"\n@@ -100,3 +72,2 @@\n-                MethodType.methodType(void.class, String.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Unsupported carrier\"\n+                    FunctionDescriptor.ofVoid(MemoryLayout.sequenceLayout(C_INT)),\n+                    \"Unsupported layout: [:b32]\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":11,"deletions":40,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n-import static jdk.incubator.foreign.FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n@@ -53,1 +52,1 @@\n-public class TestIntrinsics {\n+public class TestIntrinsics extends NativeTestHelper {\n@@ -55,1 +54,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -95,3 +94,2 @@\n-            tests.add(abi.downcallHandle(ma, mt, fd), arg, arg);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), arg, arg);\n-            tests.add(abi.downcallHandle(mt, fd), arg, ma, arg);\n+            tests.add(abi.downcallHandle(ma, fd), arg, arg);\n+            tests.add(abi.downcallHandle(fd), arg, ma, arg);\n@@ -104,2 +102,1 @@\n-            tests.add(abi.downcallHandle(ma, mt, fd), null);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), null);\n+            tests.add(abi.downcallHandle(ma, fd), null);\n@@ -119,4 +116,2 @@\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, asVarArg(C_DOUBLE),\n-                    asVarArg(C_INT), asVarArg(C_FLOAT), asVarArg(C_LONG_LONG));\n-            tests.add(abi.downcallHandle(ma, mt, fd), 1, 1, 10D, 2, 3F, 4L);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), 1, 1, 10D, 2, 3F, 4L);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd), 1, 1, 10D, 2, 3F, 4L);\n@@ -129,1 +124,1 @@\n-                    C_SHORT, C_SHORT);\n+                    C_SHORT, JAVA_CHAR);\n@@ -136,2 +131,1 @@\n-                tests.add(abi.downcallHandle(ma, mt, fd), expected, args);\n-                tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), expected, args);\n+                tests.add(abi.downcallHandle(ma, fd), expected, args);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestLayoutAttributes\n- *\/\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import org.testng.annotations.Test;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-public class TestLayoutAttributes {\n-\n-    @Test\n-    public void testAttribute() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 10L);\n-    }\n-\n-    @Test\n-    public void testAttributeOverwrite() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 10L);\n-        ml = ml.withAttribute(\"MyAttribute\", 11L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 11L);\n-    }\n-\n-    @Test\n-    public void testAttributeNonExistent() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertTrue(ml.attribute(\"Foo\").isEmpty());\n-    }\n-\n-    @Test\n-    public void testNameAttribute() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withName(\"foo\");\n-        assertEquals(ml.name().orElseThrow(), \"foo\");\n-        assertEquals(ml.attribute(MemoryLayout.LAYOUT_NAME).orElseThrow(), \"foo\");\n-    }\n-\n-    @Test\n-    public void testAttributesStream() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withName(\"foo\")\n-                .withAttribute(\"MyAttribute\", 10L);\n-        List<String> attribs = ml.attributes().collect(Collectors.toList());\n-        assertEquals(attribs.size(), 2);\n-        assertTrue(attribs.contains(\"MyAttribute\"));\n-        assertTrue(attribs.contains(MemoryLayout.LAYOUT_NAME));\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestLayoutAttributes.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -34,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -69,5 +70,5 @@\n-                { MemoryLayouts.PAD_32 },\n-                { MemoryLayout.sequenceLayout(MemoryLayouts.PAD_32) },\n-                { MemoryLayout.sequenceLayout(5, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.structLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.unionLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n+                {MemoryLayout.paddingLayout(32)},\n+                { MemoryLayout.sequenceLayout(MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.sequenceLayout(5, MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.unionLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n@@ -75,1 +76,1 @@\n-                { MemoryLayouts.BITS_32_BE },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN) },\n@@ -77,2 +78,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        MemoryLayouts.BITS_32_BE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n@@ -80,2 +81,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        MemoryLayouts.BITS_32_BE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n@@ -83,1 +84,1 @@\n-                { MemoryLayouts.BITS_32_LE },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN) },\n@@ -85,2 +86,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        MemoryLayouts.BITS_32_LE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n@@ -88,2 +89,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        MemoryLayouts.BITS_32_LE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n@@ -92,1 +93,1 @@\n-                        MemoryLayouts.PAD_16,\n+                        MemoryLayout.paddingLayout(16),\n@@ -94,2 +95,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -97,1 +98,1 @@\n-                        MemoryLayouts.PAD_16,\n+                        MemoryLayout.paddingLayout(16),\n@@ -99,2 +100,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -103,2 +104,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -107,5 +108,4 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n-                { MemoryLayouts.BITS_32_LE.withName(\"myInt\") },\n-                { MemoryLayouts.BITS_32_LE.withBitAlignment(8) },\n-                { MemoryLayouts.BITS_32_LE.withAttribute(\"xyz\", \"abc\") },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"myInt\") },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withBitAlignment(8) },\n","filename":"test\/jdk\/java\/foreign\/TestLayoutConstants.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -42,0 +42,9 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -48,1 +57,3 @@\n-        ValueLayout newLayout = MemoryLayout.valueLayout(layout.bitSize(), layout.order());\n+        ValueLayout newLayout = valueLayoutForCarrier(layout.carrier());\n+        newLayout = newLayout.withBitAlignment(layout.bitAlignment());\n+        newLayout = newLayout.withOrder(layout.order());\n@@ -54,2 +65,0 @@\n-        assertEquals(newLayout.attributes().toArray().length, 0);\n-        assertEquals(layout.attributes().toArray().length, 1);\n@@ -57,2 +66,2 @@\n-        \/\/ but equals should return false, because one is a ValueLayout with a CLinker kind\n-        assertNotEquals(newLayout, layout);\n+        \/\/ layouts should be equals\n+        assertEquals(newLayout, layout);\n@@ -79,0 +88,23 @@\n+    static ValueLayout valueLayoutForCarrier(Class<?> carrier) {\n+        if (carrier == boolean.class) {\n+            return JAVA_BOOLEAN;\n+        } else if (carrier == char.class) {\n+            return JAVA_CHAR;\n+        } else if (carrier == byte.class) {\n+            return JAVA_BYTE;\n+        } else if (carrier == short.class) {\n+            return JAVA_SHORT;\n+        } else if (carrier == int.class) {\n+            return JAVA_INT;\n+        } else if (carrier == long.class) {\n+            return JAVA_LONG;\n+        } else if (carrier == float.class) {\n+            return JAVA_FLOAT;\n+        } else if (carrier == double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (carrier == MemoryAddress.class) {\n+            return ADDRESS;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -48,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -156,1 +155,1 @@\n-        seq.varHandle(int.class, sequenceElement());\n+        seq.varHandle(sequenceElement());\n@@ -224,1 +223,1 @@\n-            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n+            g.varHandle(groupElement(\"foo\")); \/\/ok\n@@ -235,1 +234,1 @@\n-        GroupLayout g = MemoryLayout.structLayout(MemoryLayouts.PAD_8, JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n@@ -243,1 +242,1 @@\n-            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n+            g.varHandle(groupElement(\"foo\")); \/\/ok\n@@ -302,4 +301,4 @@\n-                MemoryLayouts.JAVA_BYTE.withName(\"1\"),\n-                MemoryLayouts.JAVA_CHAR.withName(\"2\"),\n-                MemoryLayouts.JAVA_FLOAT.withName(\"3\"),\n-                MemoryLayouts.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"1\"),\n+                ValueLayout.JAVA_CHAR.withName(\"2\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n+                ValueLayout.JAVA_LONG.withName(\"4\")\n@@ -327,1 +326,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -331,1 +330,1 @@\n-                    assertEquals(g2.memberLayouts().get(j), MemoryLayouts.JAVA_DOUBLE);\n+                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n@@ -343,4 +342,4 @@\n-                MemoryLayouts.JAVA_BYTE.withName(\"1\"),\n-                MemoryLayouts.JAVA_CHAR.withName(\"2\"),\n-                MemoryLayouts.JAVA_FLOAT.withName(\"3\"),\n-                MemoryLayouts.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"1\"),\n+                ValueLayout.JAVA_CHAR.withName(\"2\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n+                ValueLayout.JAVA_LONG.withName(\"4\")\n@@ -368,1 +367,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -372,1 +371,1 @@\n-                    assertEquals(g2.memberLayouts().get(j), MemoryLayouts.JAVA_DOUBLE);\n+                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n@@ -383,1 +382,1 @@\n-        SequenceLayout g = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_BYTE);\n+        SequenceLayout g = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_BYTE);\n@@ -388,1 +387,1 @@\n-        assertTrue(selected == MemoryLayouts.JAVA_BYTE);\n+        assertTrue(selected == ValueLayout.JAVA_BYTE);\n@@ -401,2 +400,2 @@\n-        SequenceLayout seq2 = (SequenceLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, sequenceElement());\n-        assertTrue(seq2.elementLayout() == MemoryLayouts.JAVA_DOUBLE);\n+        SequenceLayout seq2 = (SequenceLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, sequenceElement());\n+        assertTrue(seq2.elementLayout() == ValueLayout.JAVA_DOUBLE);\n@@ -509,1 +508,1 @@\n-            assertEquals(slice.address().segmentOffset(segment), expectedBitOffset \/ 8);\n+            assertEquals(slice.address().toRawLongValue() - segment.address().toRawLongValue(), expectedBitOffset \/ 8);\n@@ -514,10 +513,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testSliceHandleUOEInvalidSize() {\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"x\"),\n-            MemoryLayout.valueLayout(31, ByteOrder.nativeOrder()).withName(\"y\") \/\/ size not a multiple of 8\n-        );\n-\n-        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n-    }\n-\n@@ -528,1 +517,1 @@\n-            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+            JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n@@ -539,1 +528,1 @@\n-                MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+                    JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -41,5 +46,0 @@\n-    @Test(dataProvider = \"badLayoutSizes\", expectedExceptions = IllegalArgumentException.class)\n-    public void testBadLayoutSize(SizedLayoutFactory factory, long size) {\n-        factory.make(size);\n-    }\n-\n@@ -54,1 +54,1 @@\n-                MemoryLayouts.JAVA_INT.withName(\"size\"),\n+                ValueLayout.JAVA_INT.withName(\"size\"),\n@@ -56,1 +56,1 @@\n-                MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE).withName(\"arr\"));\n+                MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE).withName(\"arr\"));\n@@ -58,2 +58,2 @@\n-        VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(double.class,\n+        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n+        VarHandle array_elem_handle = layout.varHandle(\n@@ -80,1 +80,1 @@\n-                MemoryLayouts.JAVA_INT.withName(\"size\"),\n+                ValueLayout.JAVA_INT.withName(\"size\"),\n@@ -82,1 +82,1 @@\n-                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE)).withName(\"arr\"));\n+                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE)).withName(\"arr\"));\n@@ -84,2 +84,2 @@\n-        VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(double.class,\n+        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n+        VarHandle array_elem_handle = layout.varHandle(\n@@ -106,1 +106,1 @@\n-        MemoryLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(10, ValueLayout.JAVA_INT);\n@@ -109,1 +109,1 @@\n-            VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+            VarHandle indexHandle = seq.varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -116,1 +116,1 @@\n-                VarHandle preindexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(i));\n+                VarHandle preindexHandle = seq.varHandle(MemoryLayout.PathElement.sequenceElement(i));\n@@ -146,1 +146,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -152,1 +152,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, ValueLayout.JAVA_INT);\n@@ -171,4 +171,4 @@\n-                MemoryLayouts.JAVA_BYTE,\n-                MemoryLayouts.JAVA_CHAR,\n-                MemoryLayouts.JAVA_INT,\n-                MemoryLayouts.JAVA_LONG\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_LONG\n@@ -177,1 +177,1 @@\n-        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n+        assertEquals(struct.byteAlignment(), ValueLayout.ADDRESS.byteAlignment());\n@@ -202,4 +202,4 @@\n-                MemoryLayouts.JAVA_BYTE,\n-                MemoryLayouts.JAVA_CHAR,\n-                MemoryLayouts.JAVA_INT,\n-                MemoryLayouts.JAVA_LONG\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_LONG\n@@ -208,1 +208,1 @@\n-        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n+        assertEquals(struct.byteAlignment(), ValueLayout.ADDRESS.byteAlignment());\n@@ -227,13 +227,0 @@\n-    @DataProvider(name = \"badLayoutSizes\")\n-    public Object[][] factoriesAndSizes() {\n-        return new Object[][] {\n-                { SizedLayoutFactory.VALUE_BE, 0 },\n-                { SizedLayoutFactory.VALUE_BE, -1 },\n-                { SizedLayoutFactory.VALUE_LE, 0 },\n-                { SizedLayoutFactory.VALUE_LE, -1 },\n-                { SizedLayoutFactory.PADDING, 0 },\n-                { SizedLayoutFactory.PADDING, -1 },\n-                { SizedLayoutFactory.SEQUENCE, -1 }\n-        };\n-    }\n-\n@@ -242,0 +229,1 @@\n+        ValueLayout alignedInt = JAVA_INT.withBitAlignment(32);\n@@ -243,9 +231,9 @@\n-                { MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT), 32 },\n-                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n+                { MemoryLayout.sequenceLayout(alignedInt), 32 },\n+                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n@@ -274,2 +262,2 @@\n-        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n-        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n+        VALUE_LE(size -> valueLayoutForSize((int)size).withOrder(ByteOrder.LITTLE_ENDIAN)),\n+        VALUE_BE(size -> valueLayoutForSize((int)size).withOrder(ByteOrder.BIG_ENDIAN)),\n@@ -277,1 +265,1 @@\n-        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayouts.PAD_8));\n+        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayout.paddingLayout(8)));\n@@ -290,0 +278,10 @@\n+    static ValueLayout valueLayoutForSize(int size) {\n+        return switch (size) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new UnsupportedOperationException();\n+        };\n+    }\n+\n@@ -291,6 +289,5 @@\n-        VALUE_LE(MemoryLayouts.BITS_8_LE),\n-        VALUE_BE(MemoryLayouts.BITS_8_BE),\n-        PADDING(MemoryLayouts.PAD_8),\n-        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayouts.PAD_8)),\n-        STRUCT(MemoryLayout.structLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8)),\n-        UNION(MemoryLayout.unionLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8));\n+        VALUE(ValueLayout.JAVA_BYTE),\n+        PADDING(MemoryLayout.paddingLayout(8)),\n+        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayout.paddingLayout(8))),\n+        STRUCT(MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8))),\n+        UNION(MemoryLayout.unionLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8)));\n@@ -336,7 +333,7 @@\n-            MemoryLayouts.JAVA_BYTE,\n-            MemoryLayouts.JAVA_CHAR,\n-            MemoryLayouts.JAVA_SHORT,\n-            MemoryLayouts.JAVA_INT,\n-            MemoryLayouts.JAVA_FLOAT,\n-            MemoryLayouts.JAVA_LONG,\n-            MemoryLayouts.JAVA_DOUBLE,\n+            ValueLayout.JAVA_BYTE,\n+            ValueLayout.JAVA_CHAR,\n+            ValueLayout.JAVA_SHORT,\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.JAVA_FLOAT,\n+            ValueLayout.JAVA_LONG,\n+            ValueLayout.JAVA_DOUBLE,\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":63,"deletions":66,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -43,0 +42,1 @@\n+import java.nio.ByteOrder;\n@@ -51,1 +51,1 @@\n-    public void testAccess(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testAccess(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, Checker checker) {\n@@ -53,1 +53,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(), checker);\n@@ -57,1 +57,1 @@\n-    public void testPaddedAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testPaddedAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Checker checker) {\n@@ -59,1 +59,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.groupElement(\"elem\")), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(PathElement.groupElement(\"elem\")), checker);\n@@ -63,1 +63,1 @@\n-    public void testPaddedAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testPaddedAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Checker checker) {\n@@ -65,1 +65,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.sequenceElement(1)), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(PathElement.sequenceElement(1)), checker);\n@@ -69,1 +69,1 @@\n-    public void testArrayAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testArrayAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -71,1 +71,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(PathElement.sequenceElement()), checker);\n@@ -75,1 +75,1 @@\n-    public void testPaddedArrayAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testPaddedArrayAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -77,1 +77,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(\"elem\")), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(\"elem\")), checker);\n@@ -81,1 +81,1 @@\n-    public void testPaddedArrayAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testPaddedArrayAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -83,1 +83,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);\n@@ -153,1 +153,1 @@\n-    public void testMatrixAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testMatrixAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -156,1 +156,1 @@\n-        testMatrixAccessInternal(viewFactory, seq, seq.varHandle(carrier,\n+        testMatrixAccessInternal(viewFactory, seq, seq.varHandle(\n@@ -161,1 +161,1 @@\n-    public void testPaddedMatrixAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testPaddedMatrixAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -165,1 +165,1 @@\n-                seq.varHandle(carrier,\n+                seq.varHandle(\n@@ -171,1 +171,1 @@\n-    public void testPaddedMatrixAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testPaddedMatrixAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -175,1 +175,1 @@\n-                seq.varHandle(carrier,\n+                seq.varHandle(\n@@ -180,7 +180,0 @@\n-    @Test(dataProvider = \"badCarriers\",\n-          expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarriers(Class<?> carrier) {\n-        ValueLayout l = MemoryLayouts.BITS_32_LE.withName(\"elem\");\n-        l.varHandle(carrier);\n-    }\n-\n@@ -231,7 +224,7 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), Checker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), Checker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), Checker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), Checker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), Checker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), Checker.DOUBLE },\n@@ -239,7 +232,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), Checker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), Checker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), Checker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), Checker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), Checker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), Checker.DOUBLE },\n@@ -247,7 +240,7 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.DOUBLE },\n@@ -255,7 +248,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.DOUBLE },\n@@ -308,7 +301,7 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.DOUBLE },\n@@ -316,7 +309,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.DOUBLE },\n@@ -324,7 +317,7 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.DOUBLE },\n@@ -332,7 +325,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.DOUBLE },\n@@ -385,9 +378,9 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_8_BE, boolean.class, MatrixChecker.BOOLEAN },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },\n-                { ID, MemoryLayouts.BITS_64_BE, MemoryAddress.class, MatrixChecker.ADDR },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { ID, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.LONG },\n+                { ID, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.ADDR },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.DOUBLE },\n@@ -395,9 +388,9 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, boolean.class, MatrixChecker.BOOLEAN },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, MemoryAddress.class, MatrixChecker.ADDR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.LONG },\n+                { IMMUTABLE, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.ADDR },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.DOUBLE },\n@@ -405,9 +398,9 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_8_LE, boolean.class, MatrixChecker.BOOLEAN },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },\n-                { ID, MemoryLayouts.BITS_64_LE, MemoryAddress.class, MatrixChecker.ADDR },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { ID, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.LONG },\n+                { ID, ValueLayout.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.ADDR },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.DOUBLE },\n@@ -415,9 +408,9 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, boolean.class, MatrixChecker.BOOLEAN },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, MemoryAddress.class, MatrixChecker.ADDR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.LONG },\n+                { IMMUTABLE, ValueLayout.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.ADDR },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.DOUBLE },\n@@ -475,9 +468,0 @@\n-\n-    @DataProvider(name = \"badCarriers\")\n-    public Object[][] createBadCarriers() {\n-        return new Object[][] {\n-                { void.class },\n-                { Object.class },\n-                { int[].class }\n-        };\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":111,"deletions":127,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryAccessInstance\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.function.Function;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryAccessInstance {\n+\n+    static class Accessor<T, X, L> {\n+\n+        interface SegmentGetter<T, X, L> {\n+            X get(T buffer, L layout, long offset);\n+        }\n+\n+        interface SegmentSetter<T, X, L> {\n+            void set(T buffer, L layout, long offset, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment, int offset);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, int offset, X o);\n+        }\n+\n+        final X value;\n+        final L layout;\n+        final Function<MemorySegment, T> transform;\n+        final SegmentGetter<T, X, L> segmentGetter;\n+        final SegmentSetter<T, X, L> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(Function<MemorySegment, T> transform, L layout, X value,\n+                 SegmentGetter<T, X, L> segmentGetter, SegmentSetter<T, X, L> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.transform = transform;\n+            this.layout = layout;\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment segment = MemorySegment.allocateNative(64, scope);\n+                ByteBuffer buffer = segment.asByteBuffer();\n+                T t = transform.apply(segment);\n+                segmentSetter.set(t, layout, 4, value);\n+                assertEquals(bufferGetter.get(buffer, 4), value);\n+                bufferSetter.set(buffer, 4, value);\n+                assertEquals(value, segmentGetter.get(t, layout, 4));\n+            }\n+        }\n+\n+        static <L, X> Accessor<MemorySegment, X, L> ofSegment(L layout, X value,\n+                         SegmentGetter<MemorySegment, X, L> segmentGetter, SegmentSetter<MemorySegment, X, L> segmentSetter,\n+                         BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            return new Accessor<>(Function.identity(), layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+\n+        static <L, X> Accessor<MemoryAddress, X, L> ofAddress(L layout, X value,\n+                                                              SegmentGetter<MemoryAddress, X, L> segmentGetter, SegmentSetter<MemoryAddress, X, L> segmentSetter,\n+                                                              BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            return new Accessor<>(MemorySegment::address, layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"segmentAccessors\")\n+    public void testSegmentAccess(String testName, Accessor<?, ?, ?> accessor) {\n+        accessor.test();\n+    }\n+\n+    @Test(dataProvider = \"addressAccessors\")\n+    public void testAddressAccess(String testName, Accessor<?, ?, ?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"segmentAccessors\")\n+    static Object[][] segmentAccessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", Accessor.ofSegment(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        ByteBuffer::get, ByteBuffer::put)\n+                },\n+                {\"bool\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n+                },\n+                {\"char\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n+                },\n+                {\"int\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n+                },\n+                {\"float\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n+                },\n+                {\"long\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n+                },\n+                {\"double\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n+                },\n+                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos) : nb.getInt(pos);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+\n+                {\"char\/index\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n+                },\n+                {\"int\/index\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n+                },\n+                {\"float\/index\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n+                },\n+                {\"long\/index\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n+                },\n+                {\"double\/index\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n+                },\n+                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos * 8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+\n+    @DataProvider(name = \"addressAccessors\")\n+    static Object[][] addressAccessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", Accessor.ofAddress(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        ByteBuffer::get, ByteBuffer::put)\n+                },\n+                {\"bool\", Accessor.ofAddress(ValueLayout.JAVA_BOOLEAN, false,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n+                },\n+                {\"char\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n+                },\n+                {\"int\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n+                },\n+                {\"float\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n+                },\n+                {\"long\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n+                },\n+                {\"double\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n+                },\n+                { \"address\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos) : nb.getInt(pos);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                {\"char\/index\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n+                },\n+                {\"int\/index\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n+                },\n+                {\"float\/index\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n+                },\n+                {\"long\/index\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n+                },\n+                {\"double\/index\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n+                },\n+                { \"address\/index\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos * 8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -1,373 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestMemoryAccessStatics\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestMemoryAccessStatics {\n-\n-    static class Accessor<X> {\n-\n-        interface SegmentGetter<X> {\n-            X get(MemorySegment segment);\n-        }\n-\n-        interface SegmentSetter<X> {\n-            void set(MemorySegment segment, X o);\n-        }\n-\n-        interface BufferGetter<X> {\n-            X get(ByteBuffer segment);\n-        }\n-\n-        interface BufferSetter<X> {\n-            void set(ByteBuffer buffer, X o);\n-        }\n-\n-        final X value;\n-        final SegmentGetter<X> segmentGetter;\n-        final SegmentSetter<X> segmentSetter;\n-        final BufferGetter<X> bufferGetter;\n-        final BufferSetter<X> bufferSetter;\n-\n-        Accessor(X value,\n-                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n-                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n-            this.value = value;\n-            this.segmentGetter = segmentGetter;\n-            this.segmentSetter = segmentSetter;\n-            this.bufferGetter = bufferGetter;\n-            this.bufferSetter = bufferSetter;\n-        }\n-\n-        void test() {\n-            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n-            ByteBuffer buffer = segment.asByteBuffer();\n-            segmentSetter.set(segment, value);\n-            assertEquals(bufferGetter.get(buffer), value);\n-            bufferSetter.set(buffer, value);\n-            assertEquals(value, segmentGetter.get(segment));\n-        }\n-\n-        <Z> Accessor<Z> of(Z value,\n-                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n-                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n-            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"accessors\")\n-    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n-        accessor.test();\n-    }\n-\n-    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n-    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n-    static final ByteOrder NE = ByteOrder.nativeOrder();\n-\n-    @DataProvider(name = \"accessors\")\n-    static Object[][] accessors() {\n-        return new Object[][]{\n-\n-                {\"byte\", new Accessor<>((byte) 42,\n-                        MemoryAccess::getByte, MemoryAccess::setByte,\n-                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n-                },\n-                {\"bool\", new Accessor<>(false,\n-                        MemoryAccess::getBoolean, MemoryAccess::setBoolean,\n-                        (bb) -> bb.get(0) != 0, (bb, v) -> bb.put(0, v ? (byte)1 : (byte)0))\n-                },\n-                {\"char\", new Accessor<>((char) 42,\n-                        MemoryAccess::getChar, MemoryAccess::setChar,\n-                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n-                },\n-                {\"char\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n-                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n-                },\n-                {\"char\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n-                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n-                },\n-                {\"short\", new Accessor<>((short) 42,\n-                        MemoryAccess::getShort, MemoryAccess::setShort,\n-                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n-                },\n-                {\"short\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n-                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n-                },\n-                {\"short\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n-                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n-                },\n-                {\"int\", new Accessor<>(42,\n-                        MemoryAccess::getInt, MemoryAccess::setInt,\n-                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n-                },\n-                {\"int\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n-                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n-                },\n-                {\"int\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n-                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n-                },\n-                \/\/ float, no offset\n-                {\"float\", new Accessor<>(42f,\n-                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n-                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n-                },\n-                {\"float\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n-                },\n-                {\"float\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n-                },\n-                \/\/ double, no offset\n-                {\"double\", new Accessor<>(42d,\n-                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n-                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n-                },\n-                {\"double\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n-                },\n-                {\"double\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n-                },\n-\n-\n-                \/\/ byte, offset\n-                {\"byte\/offset\", new Accessor<>((byte) 42,\n-                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n-                        (bb) -> bb.get(4), (bb, v) -> bb.put(4, v))\n-                },\n-                \/\/ bool, offset\n-                {\"bool\", new Accessor<>(false,\n-                        s -> MemoryAccess.getBooleanAtOffset(s, 4), (s, x) -> MemoryAccess.setBooleanAtOffset(s, 4, x),\n-                        (bb) -> bb.get(4) != 0, (bb, v) -> bb.put(4, v ? (byte)1 : (byte)0))\n-                },\n-                \/\/ char, offset\n-                {\"char\/offset\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getChar(4), (bb, v) -> bb.order(NE).putChar(4, v))\n-                },\n-                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getChar(4), (bb, v) -> bb.order(LE).putChar(4, v))\n-                },\n-                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getChar(4), (bb, v) -> bb.order(BE).putChar(4, v))\n-                },\n-                \/\/ short, offset\n-                {\"short\/offset\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getShort(4), (bb, v) -> bb.order(NE).putShort(4, v))\n-                },\n-                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getShort(4), (bb, v) -> bb.order(LE).putShort(4, v))\n-                },\n-                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getShort(4), (bb, v) -> bb.order(BE).putShort(4, v))\n-                },\n-                \/\/ int, offset\n-                {\"int\/offset\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getInt(4), (bb, v) -> bb.order(NE).putInt(4, v))\n-                },\n-                {\"int\/offset\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getInt(4), (bb, v) -> bb.order(LE).putInt(4, v))\n-                },\n-                {\"int\/offset\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getInt(4), (bb, v) -> bb.order(BE).putInt(4, v))\n-                },\n-                \/\/ float, offset\n-                {\"float\/offset\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getFloat(4), (bb, v) -> bb.order(NE).putFloat(4, v))\n-                },\n-                {\"float\/offset\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(4), (bb, v) -> bb.order(LE).putFloat(4, v))\n-                },\n-                {\"float\/offset\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(4), (bb, v) -> bb.order(BE).putFloat(4, v))\n-                },\n-                \/\/ double, offset\n-                {\"double\/offset\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getDouble(4), (bb, v) -> bb.order(NE).putDouble(4, v))\n-                },\n-                {\"double\/offset\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(4), (bb, v) -> bb.order(LE).putDouble(4, v))\n-                },\n-                {\"double\/offset\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(4), (bb, v) -> bb.order(BE).putDouble(4, v))\n-                },\n-\n-\n-                \/\/ char, index\n-                {\"char\/index\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n-                },\n-                \/\/ short, index\n-                {\"short\/index\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n-                },\n-                {\"int\/index\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n-                },\n-                {\"float\/index\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n-                },\n-                {\"double\/index\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n-                },\n-\n-                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(0) : nb.getInt(0);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(0, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(0, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(4) : nb.getInt(4);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(4, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(4, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.asLongBuffer().put(2, v.toRawLongValue());\n-                            } else {\n-                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":0,"deletions":373,"binary":false,"changes":373,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -39,0 +38,1 @@\n+import java.nio.ByteOrder;\n@@ -48,1 +48,3 @@\n-        ValueLayout layout = MemoryLayouts.BITS_32_BE;\n+        ValueLayout layout = ValueLayout.JAVA_INT\n+                .withBitAlignment(32)\n+                .withOrder(ByteOrder.BIG_ENDIAN);\n@@ -52,1 +54,1 @@\n-        VarHandle vh = aligned.varHandle(int.class);\n+        VarHandle vh = aligned.varHandle();\n@@ -63,1 +65,3 @@\n-        ValueLayout layout = MemoryLayouts.BITS_32_BE;\n+        ValueLayout layout = ValueLayout.JAVA_INT\n+                .withBitAlignment(32)\n+                .withOrder(ByteOrder.BIG_ENDIAN);\n@@ -66,1 +70,1 @@\n-        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n+        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -68,1 +72,1 @@\n-        VarHandle vh = aligned.varHandle(int.class);\n+        VarHandle vh = aligned.varHandle();\n@@ -80,1 +84,1 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_32_BE;\n+        MemoryLayout layout = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -82,1 +86,1 @@\n-        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n+        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -84,1 +88,1 @@\n-            alignedGroup.varHandle(int.class, PathElement.groupElement(\"value\"));\n+            alignedGroup.varHandle(PathElement.groupElement(\"value\"));\n@@ -93,1 +97,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n@@ -95,1 +99,1 @@\n-            VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());\n+            VarHandle vh = layout.varHandle(PathElement.sequenceElement());\n@@ -109,3 +113,3 @@\n-        ValueLayout vChar = MemoryLayouts.BITS_8_BE;\n-        ValueLayout vShort = MemoryLayouts.BITS_16_BE;\n-        ValueLayout vInt = MemoryLayouts.BITS_32_BE;\n+        ValueLayout vChar = ValueLayout.JAVA_BYTE;\n+        ValueLayout vShort = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        ValueLayout vInt = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -117,3 +121,3 @@\n-        VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement(\"a\"));\n-        VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement(\"b\"));\n-        VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement(\"c\"));\n+        VarHandle vh_c = g.varHandle(PathElement.groupElement(\"a\"));\n+        VarHandle vh_s = g.varHandle(PathElement.groupElement(\"b\"));\n+        VarHandle vh_i = g.varHandle(PathElement.groupElement(\"c\"));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,518 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestMemoryCopy\n- *\/\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.incubator.foreign.MemoryCopy;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-\/**\n- * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n- * To make these tests more challenging the segment is a view of the given array,\n- * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n- *\n- * <p>If the source (destination) segment is actually a view of the destination (source) array,\n- * and if the copy region of the source overlaps with the copy region of the destination,\n- * the copy of the overlapping region is performed as if the data in the overlapping region\n- * were first copied into a temporary segment before being copied to the destination.<\/p>\n- *\/\n-public class TestMemoryCopy {\n-    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n-    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n-            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n-\n-    private static final int SEG_LENGTH_BYTES = 32;\n-    private static final int SEG_OFFSET_BYTES = 8;\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testSelfCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n-        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        int srcIndex = mode.direction ? 0 : indexShifts;\n-        int srcCopyLen = helper.length(srcArr) - indexShifts;\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-        assertEquals(truth.mismatch(dstSeg), -1);\n-        \/\/CopyTo\n-        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        int dstIndex = mode.direction ? indexShifts : 0;\n-        int dstCopyLen = helper.length(dstArr) - indexShifts;\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-        MemorySegment result = helper.fromArray(dstArr);\n-        assertEquals(truth.mismatch(result), -1);\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testUnalignedCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        int srcIndex = mode.direction ? 0 : indexShifts;\n-        int srcCopyLen = helper.length(srcArr) - indexShifts;\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        long dstOffsetBytes = mode.direction ? (SEG_OFFSET_BYTES - 1) : 0;\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-        \/\/CopyTo\n-        long srcOffsetBytes = mode.direction ? 0 : (SEG_OFFSET_BYTES - 1);\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        int dstIndex = mode.direction ? indexShifts : 0;\n-        int dstCopyLen = helper.length(dstArr) - indexShifts;\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyOobLength(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyNegativeIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyNegativeOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyOobIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyOobOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    \/***** Utilities *****\/\n-\n-    public static MemorySegment srcSegment(int bytesLength) {\n-        byte[] arr = new byte[bytesLength];\n-        for (int i = 0; i < arr.length; i++) {\n-            arr[i] = (byte)i;\n-        }\n-        return MemorySegment.ofArray(arr);\n-    }\n-\n-    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?> helper, int indexShifts, CopyMode mode) {\n-        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n-                                                .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n-        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n-                                                 .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n-        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toByteArray());\n-        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n-        if (mode.direction) {\n-            if (mode.swap) {\n-                for (int i = indexLength - 1; i >= indexShifts; i--) {\n-                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n-                    indexedHandleNO.set(dstSeg, i, v);\n-                }\n-            } else {\n-                for (int i = indexLength - 1; i >= indexShifts; i--) {\n-                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n-                    indexedHandleNO.set(dstSeg, i, v);\n-                }\n-            }\n-        } else { \/\/down\n-            if (mode.swap) {\n-                for (int i = indexShifts; i < indexLength; i++) {\n-                    Object v = indexedHandleNNO.get(dstSeg, i);\n-                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n-                }\n-            } else {\n-                for (int i = indexShifts; i < indexLength; i++) {\n-                    Object v = indexedHandleNO.get(dstSeg, i);\n-                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n-                }\n-            }\n-        }\n-        return dstSeg;\n-    }\n-\n-    enum CopyMode {\n-        UP_NO_SWAP(true, false),\n-        UP_SWAP(true, true),\n-        DOWN_NO_SWAP(false, false),\n-        DOWN_SWAP(false, true);\n-\n-        final boolean direction;\n-        final boolean swap;\n-\n-        CopyMode(boolean direction, boolean swap) {\n-            this.direction = direction;\n-            this.swap = swap;\n-        }\n-    }\n-\n-    abstract static class CopyHelper<X> {\n-\n-        final ValueLayout elementLayout;\n-        final Class<?> carrier;\n-\n-        public CopyHelper(ValueLayout elementLayout, Class<X> carrier) {\n-            this.elementLayout = elementLayout;\n-            this.carrier = carrier;\n-        }\n-\n-        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n-        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n-        abstract X toArray(MemorySegment segment);\n-        abstract MemorySegment fromArray(X array);\n-        abstract int length(X arr);\n-\n-        @Override\n-        public String toString() {\n-            return \"CopyHelper{\" +\n-                    \"elementLayout=\" + elementLayout +\n-                    \", carrier=\" + carrier.getName() +\n-                    '}';\n-        }\n-\n-        static final CopyHelper<byte[]> BYTE = new CopyHelper<>(MemoryLayouts.JAVA_BYTE, byte[].class) {\n-            @Override\n-            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n-            }\n-\n-            @Override\n-            byte[] toArray(MemorySegment segment) {\n-                return segment.toByteArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(byte[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(byte[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<char[]> CHAR = new CopyHelper<>(MemoryLayouts.JAVA_CHAR, char[].class) {\n-            @Override\n-            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            char[] toArray(MemorySegment segment) {\n-                return segment.toCharArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(char[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(char[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<short[]> SHORT = new CopyHelper<>(MemoryLayouts.JAVA_SHORT, short[].class) {\n-            @Override\n-            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            short[] toArray(MemorySegment segment) {\n-                return segment.toShortArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(short[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(short[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<int[]> INT = new CopyHelper<>(MemoryLayouts.JAVA_INT, int[].class) {\n-            @Override\n-            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            int[] toArray(MemorySegment segment) {\n-                return segment.toIntArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(int[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(int[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<float[]> FLOAT = new CopyHelper<>(MemoryLayouts.JAVA_FLOAT, float[].class) {\n-            @Override\n-            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            float[] toArray(MemorySegment segment) {\n-                return segment.toFloatArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(float[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(float[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<long[]> LONG = new CopyHelper<>(MemoryLayouts.JAVA_LONG, long[].class) {\n-            @Override\n-            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            long[] toArray(MemorySegment segment) {\n-                return segment.toLongArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(long[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(long[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<double[]> DOUBLE = new CopyHelper<>(MemoryLayouts.JAVA_DOUBLE, double[].class) {\n-            @Override\n-            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            double[] toArray(MemorySegment segment) {\n-                return segment.toDoubleArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(double[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(double[] arr) {\n-                return arr.length;\n-            }\n-        };\n-    }\n-\n-    @DataProvider\n-    Object[][] copyModesAndHelpers() {\n-        CopyHelper<?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n-                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n-        List<Object[]> results = new ArrayList<>();\n-        for (CopyHelper<?> helper : helpers) {\n-            for (CopyMode mode : CopyMode.values()) {\n-                results.add(new Object[] { mode, helper, helper.toString() });\n-            }\n-        }\n-        return results.stream().toArray(Object[][]::new);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":0,"deletions":518,"binary":false,"changes":518,"status":"deleted"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestMemoryDereference\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.*;\n+\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryDereference {\n+\n+    static class Accessor<X> {\n+\n+        interface SegmentGetter<X> {\n+            X get(MemorySegment segment);\n+        }\n+\n+        interface SegmentSetter<X> {\n+            void set(MemorySegment segment, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, X o);\n+        }\n+\n+        final X value;\n+        final SegmentGetter<X> segmentGetter;\n+        final SegmentSetter<X> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(X value,\n+                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            segmentSetter.set(segment, value);\n+            assertEquals(bufferGetter.get(buffer), value);\n+            bufferSetter.set(buffer, value);\n+            assertEquals(value, segmentGetter.get(segment));\n+        }\n+\n+        <Z> Accessor<Z> of(Z value,\n+                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n+                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n+            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n+    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"accessors\")\n+    static Object[][] accessors() {\n+        return new Object[][]{\n+\n+                \/\/ byte, offset\n+                {\"byte\/offset\", new Accessor<>((byte) 42,\n+                        s -> s.get(JAVA_BYTE, 8), (s, x) -> s.set(JAVA_BYTE, 8, x),\n+                        (bb) -> bb.get(8), (bb, v) -> bb.put(8, v))\n+                },\n+                \/\/ bool, offset\n+                {\"bool\", new Accessor<>(false,\n+                        s -> s.get(JAVA_BOOLEAN, 8), (s, x) -> s.set(JAVA_BOOLEAN, 8, x),\n+                        (bb) -> bb.get(8) != 0, (bb, v) -> bb.put(8, v ? (byte)1 : (byte)0))\n+                },\n+                \/\/ char, offset\n+                {\"char\/offset\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR, 8), (s, x) -> s.set(JAVA_CHAR, 8, x),\n+                        (bb) -> bb.order(NE).getChar(8), (bb, v) -> bb.order(NE).putChar(8, v))\n+                },\n+                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getChar(8), (bb, v) -> bb.order(LE).putChar(8, v))\n+                },\n+                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getChar(8), (bb, v) -> bb.order(BE).putChar(8, v))\n+                },\n+                \/\/ short, offset\n+                {\"short\/offset\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT, 8), (s, x) -> s.set(JAVA_SHORT, 8, x),\n+                        (bb) -> bb.order(NE).getShort(8), (bb, v) -> bb.order(NE).putShort(8, v))\n+                },\n+                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getShort(8), (bb, v) -> bb.order(LE).putShort(8, v))\n+                },\n+                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getShort(8), (bb, v) -> bb.order(BE).putShort(8, v))\n+                },\n+                \/\/ int, offset\n+                {\"int\/offset\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT, 8), (s, x) -> s.set(JAVA_INT, 8, x),\n+                        (bb) -> bb.order(NE).getInt(8), (bb, v) -> bb.order(NE).putInt(8, v))\n+                },\n+                {\"int\/offset\/LE\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getInt(8), (bb, v) -> bb.order(LE).putInt(8, v))\n+                },\n+                {\"int\/offset\/BE\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getInt(8), (bb, v) -> bb.order(BE).putInt(8, v))\n+                },\n+                \/\/ float, offset\n+                {\"float\/offset\", new Accessor<>(42f,\n+                        s -> s.get(JAVA_FLOAT, 8), (s, x) -> s.set(JAVA_FLOAT, 8, x),\n+                        (bb) -> bb.order(NE).getFloat(8), (bb, v) -> bb.order(NE).putFloat(8, v))\n+                },\n+                {\"float\/offset\/LE\", new Accessor<>(42f,\n+                        s -> s.get(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getFloat(8), (bb, v) -> bb.order(LE).putFloat(8, v))\n+                },\n+                {\"float\/offset\/BE\", new Accessor<>(42f,\n+                        s -> s.get(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getFloat(8), (bb, v) -> bb.order(BE).putFloat(8, v))\n+                },\n+                \/\/ double, offset\n+                {\"double\/offset\", new Accessor<>(42d,\n+                        s -> s.get(JAVA_DOUBLE, 8), (s, x) -> s.set(JAVA_DOUBLE, 8, x),\n+                        (bb) -> bb.order(NE).getDouble(8), (bb, v) -> bb.order(NE).putDouble(8, v))\n+                },\n+                {\"double\/offset\/LE\", new Accessor<>(42d,\n+                        s -> s.get(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getDouble(8), (bb, v) -> bb.order(LE).putDouble(8, v))\n+                },\n+                {\"double\/offset\/BE\", new Accessor<>(42d,\n+                        s -> s.get(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getDouble(8), (bb, v) -> bb.order(BE).putDouble(8, v))\n+                },\n+                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> s.get(ADDRESS, 8), (s, x) -> s.set(ADDRESS, 8, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(8) : nb.getInt(8);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(8, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import java.nio.ByteOrder;\n@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,2 +58,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_8_BE;\n-        VarHandle byteHandle = layout.varHandle(byte.class);\n+        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n+        VarHandle byteHandle = layout.varHandle();\n@@ -80,2 +81,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_8_BE;\n-        VarHandle byteHandle = layout.varHandle(byte.class);\n+        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n+        VarHandle byteHandle = layout.varHandle();\n@@ -103,2 +104,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_16_BE;\n-        VarHandle shortHandle = layout.varHandle(short.class);\n+        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle shortHandle = layout.varHandle();\n@@ -126,2 +127,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_16_BE;\n-        VarHandle shortHandle = layout.varHandle(short.class);\n+        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle shortHandle = layout.varHandle();\n@@ -153,2 +154,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_32_BE;\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        MemoryLayout layout = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle intHandle = layout.varHandle();\n@@ -168,2 +169,2 @@\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(2, MemoryLayouts.BITS_8_BE);\n-        VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_BYTE);\n+        VarHandle byteHandle = layout.varHandle(PathElement.sequenceElement());\n@@ -187,2 +188,2 @@\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                    .varHandle(byte.class, PathElement.sequenceElement());\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                    .varHandle(PathElement.sequenceElement());\n@@ -193,2 +194,2 @@\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                    .varHandle(byte.class, PathElement.sequenceElement());\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                    .varHandle(PathElement.sequenceElement());\n@@ -204,1 +205,1 @@\n-        VarHandle handle = MemoryHandles.varHandle(byte.class, BIG_ENDIAN);\n+        VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withOrder(BIG_ENDIAN));\n@@ -212,2 +213,2 @@\n-    static void assertIllegalArgumentExceptionIllegalCarrier(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIllegalCarrier(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -219,2 +220,2 @@\n-    static void assertIllegalArgumentExceptionIllegalAdapter(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIllegalAdapter(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -226,2 +227,2 @@\n-    static void assertIllegalArgumentExceptionIsNotWiderThan(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -235,20 +236,20 @@\n-        assertIllegalArgumentExceptionIllegalCarrier(char.class,   long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(double.class, long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(float.class,  long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(long.class,   long.class);\n-\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, void.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, byte.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, short.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, char.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, double.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, float.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Object.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Integer.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Long.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, long[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, int[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Integer[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Long[].class);\n-\n-        assertIllegalArgumentExceptionIsNotWiderThan(int.class, int.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_CHAR,   long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_DOUBLE, long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_FLOAT,  long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_LONG,   long.class);\n+\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, void.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, byte.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, short.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, char.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, double.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, float.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Object.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, long[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, int[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long[].class);\n+\n+        assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout.JAVA_INT, int.class);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryHandleAsUnsigned.java","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -46,1 +46,1 @@\n-    final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n+    final static VarHandle BYTE_HANDLE = ValueLayout.JAVA_BYTE.varHandle();\n@@ -115,1 +115,1 @@\n-        if (MemoryLayouts.ADDRESS.byteSize() > 32) {\n+        if (ValueLayout.ADDRESS.byteSize() > 32) {\n@@ -208,1 +208,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+        NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-import java.lang.invoke.MethodType;\n-import java.nio.charset.Charset;\n@@ -45,1 +43,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -51,1 +49,0 @@\n-                MethodType.methodType(void.class),\n@@ -58,1 +55,0 @@\n-                MethodType.methodType(void.class),\n@@ -64,2 +60,2 @@\n-    public void testNULLtoJavaString() {\n-        CLinker.toJavaString(MemoryAddress.NULL);\n+    public void testNULLgetString() {\n+        MemoryAddress.NULL.getUtf8String(0);\n@@ -69,2 +65,2 @@\n-    public void testNULLfreeMemory() {\n-        CLinker.freeMemory(MemoryAddress.NULL);\n+    public void testNULLsetString() {\n+        MemoryAddress.NULL.setUtf8String(0, \"hello\");\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -37,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -41,0 +38,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -59,0 +57,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -61,1 +60,1 @@\n-public class TestNative {\n+public class TestNative extends NativeTestHelper {\n@@ -64,1 +63,1 @@\n-            MemoryLayouts.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())\n@@ -68,1 +67,1 @@\n-            MemoryLayouts.JAVA_CHAR.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_CHAR.withOrder(ByteOrder.nativeOrder())\n@@ -72,1 +71,1 @@\n-            MemoryLayouts.JAVA_SHORT.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_SHORT.withOrder(ByteOrder.nativeOrder())\n@@ -76,1 +75,1 @@\n-            MemoryLayouts.JAVA_INT.withOrder(ByteOrder.nativeOrder())\n+            JAVA_INT.withOrder(ByteOrder.nativeOrder())\n@@ -80,1 +79,1 @@\n-            MemoryLayouts.JAVA_FLOAT.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.nativeOrder())\n@@ -84,1 +83,1 @@\n-            MemoryLayouts.JAVA_LONG.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_LONG.withOrder(ByteOrder.nativeOrder())\n@@ -88,1 +87,1 @@\n-            MemoryLayouts.JAVA_DOUBLE.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.nativeOrder())\n@@ -91,7 +90,7 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = doubles.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = longs.varHandle(double.class, PathElement.sequenceElement());\n+    static VarHandle byteHandle = bytes.varHandle(PathElement.sequenceElement());\n+    static VarHandle charHandle = chars.varHandle(PathElement.sequenceElement());\n+    static VarHandle shortHandle = shorts.varHandle(PathElement.sequenceElement());\n+    static VarHandle intHandle = ints.varHandle(PathElement.sequenceElement());\n+    static VarHandle floatHandle = floats.varHandle(PathElement.sequenceElement());\n+    static VarHandle longHandle = longs.varHandle(PathElement.sequenceElement());\n+    static VarHandle doubleHandle = doubles.varHandle(PathElement.sequenceElement());\n@@ -147,8 +146,0 @@\n-    public static MemoryAddress allocate(int size) {\n-        return CLinker.allocateMemory(size);\n-    }\n-\n-    public static void free(MemoryAddress addr) {\n-        CLinker.freeMemory(addr);\n-    }\n-\n@@ -179,1 +170,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -181,1 +172,2 @@\n-            MemorySegment mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            scope.addCloseAction(() -> freeMemory(addr));\n+            MemorySegment mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n@@ -186,6 +178,0 @@\n-    @Test\n-    public void testDefaultAccessModesEverthing() {\n-        MemorySegment everything = MemorySegment.globalNativeSegment();\n-        assertFalse(everything.isReadOnly());\n-    }\n-\n@@ -194,1 +180,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -197,1 +183,2 @@\n-            mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            scope.addCloseAction(() -> freeMemory(addr));\n+            mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n@@ -205,6 +192,5 @@\n-    public void testEverythingSegment() {\n-        MemoryAddress addr = allocate(4);\n-        MemorySegment everything = MemorySegment.globalNativeSegment();\n-        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);\n-        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);\n-        free(addr);\n+    public void testAddressAccess() {\n+        MemoryAddress addr = allocateMemory(4);\n+        addr.set(JAVA_INT, 0, 42);\n+        assertEquals(addr.get(JAVA_INT, 0), 42);\n+        freeMemory(addr);\n@@ -217,1 +203,1 @@\n-            segment.address().asSegment(0, ResourceScope.globalScope());\n+            MemorySegment.ofAddressNative(segment.address(), 0, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":29,"deletions":43,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -85,0 +87,9 @@\n+            ValueLayout.OfBoolean.class,\n+            ValueLayout.OfByte.class,\n+            ValueLayout.OfChar.class,\n+            ValueLayout.OfShort.class,\n+            ValueLayout.OfInt.class,\n+            ValueLayout.OfFloat.class,\n+            ValueLayout.OfLong.class,\n+            ValueLayout.OfDouble.class,\n+            ValueLayout.OfAddress.class,\n@@ -88,2 +99,0 @@\n-            MemoryAccess.class,\n-            MemoryLayouts.class,\n@@ -92,2 +101,2 @@\n-            CLinker.VaList.class,\n-            CLinker.VaList.Builder.class,\n+            VaList.class,\n+            VaList.Builder.class,\n@@ -96,2 +105,1 @@\n-            ResourceScope.class,\n-            MemoryCopy.class\n+            ResourceScope.class\n@@ -101,0 +109,2 @@\n+            \"jdk.incubator.foreign.ResourceScope\/newConfinedScope(java.lang.ref.Cleaner)\/0\/0\",\n+            \"jdk.incubator.foreign.ResourceScope\/newSharedScope(java.lang.ref.Cleaner)\/0\/0\",\n@@ -102,3 +112,0 @@\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)\/1\/0\",\n@@ -107,0 +114,9 @@\n+            \"jdk.incubator.foreign.ValueLayout$OfAddress\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfBoolean\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfByte\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfChar\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfShort\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfInt\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfFloat\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfLong\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfDouble\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n@@ -143,1 +159,1 @@\n-        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()));\n+        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(JAVA_INT));\n@@ -151,4 +167,13 @@\n-        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n-        addDefaultMapping(ValueLayout.class, MemoryLayouts.JAVA_INT);\n-        addDefaultMapping(GroupLayout.class, MemoryLayout.structLayout(MemoryLayouts.JAVA_INT));\n-        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(MemoryLayout.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(ValueLayout.OfByte.class, ValueLayout.JAVA_BYTE);\n+        addDefaultMapping(ValueLayout.OfBoolean.class, ValueLayout.JAVA_BOOLEAN);\n+        addDefaultMapping(ValueLayout.OfChar.class, ValueLayout.JAVA_CHAR);\n+        addDefaultMapping(ValueLayout.OfShort.class, ValueLayout.JAVA_SHORT);\n+        addDefaultMapping(ValueLayout.OfInt.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfFloat.class, ValueLayout.JAVA_FLOAT);\n+        addDefaultMapping(ValueLayout.OfLong.class, JAVA_LONG);\n+        addDefaultMapping(ValueLayout.OfDouble.class, ValueLayout.JAVA_DOUBLE);\n+        addDefaultMapping(GroupLayout.class, MemoryLayout.structLayout(ValueLayout.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n@@ -157,4 +182,4 @@\n-        addDefaultMapping(CLinker.class, CLinker.getInstance());\n-        addDefaultMapping(CLinker.VaList.class, VaListHelper.vaList);\n-        addDefaultMapping(CLinker.VaList.Builder.class, VaListHelper.vaListBuilder);\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n+        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n+        addDefaultMapping(VaList.class, VaListHelper.vaList);\n+        addDefaultMapping(VaList.Builder.class, VaListHelper.vaListBuilder);\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newConfinedScope());\n@@ -163,1 +188,0 @@\n-        addDefaultMapping(ResourceScope.Handle.class, ResourceScope.globalScope().acquire());\n@@ -165,1 +189,1 @@\n-        addDefaultMapping(SymbolLookup.class, CLinker.systemLookup());\n+        addDefaultMapping(SymbolLookup.class, CLinker.systemCLinker());\n@@ -169,2 +193,2 @@\n-        static final CLinker.VaList vaList;\n-        static final CLinker.VaList.Builder vaListBuilder;\n+        static final VaList vaList;\n+        static final VaList.Builder vaListBuilder;\n@@ -173,2 +197,2 @@\n-            AtomicReference<CLinker.VaList.Builder> builderRef = new AtomicReference<>();\n-            vaList = CLinker.VaList.make(b -> {\n+            AtomicReference<VaList.Builder> builderRef = new AtomicReference<>();\n+            vaList = VaList.make(b -> {\n@@ -176,2 +200,2 @@\n-                b.vargFromLong(CLinker.C_LONG_LONG, 42L);\n-            }, ResourceScope.newImplicitScope());\n+                b.addVarg(JAVA_LONG, 42L);\n+            }, ResourceScope.newConfinedScope());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":50,"deletions":26,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestRebase\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestRebase {\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testRebase(SegmentSlice s1, SegmentSlice s2) {\n-        if (s1.contains(s2)) {\n-            \/\/check that an address and its rebased counterpart point to same element\n-            MemoryAddress base = s2.segment.address();\n-            long offset = base.segmentOffset(s1.segment);\n-            for (int i = 0; i < s2.size(); i++) {\n-                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);\n-                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n-                assertEquals(found, expected);\n-            }\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that rebase s1 to s2 fails\n-            try {\n-                s1.segment.address().segmentOffset(s2.segment);\n-                fail(\"Rebase unexpectedly passed!\");\n-            } catch (IllegalArgumentException ex) {\n-                assertTrue(true);\n-            }\n-        } else if (!s2.contains(s1)) {\n-            \/\/disjoint segments - check that rebased address is out of bounds\n-            MemoryAddress base = s2.segment.address();\n-            long offset = base.segmentOffset(s1.segment);\n-            for (int i = 0; i < s2.size(); i++) {\n-                MemoryAccess.getByteAtOffset(s2.segment, i);\n-                try {\n-                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n-                    fail(\"Rebased address on a disjoint segment is not out of bounds!\");\n-                } catch (IndexOutOfBoundsException ex) {\n-                    assertTrue(true);\n-                }\n-            }\n-        }\n-    }\n-\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n-\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n-\n-        boolean contains(SegmentSlice other) {\n-            return kind == other.kind &&\n-                    first <= other.first &&\n-                    last >= other.last;\n-        }\n-\n-        int size() {\n-            return last - first + 1;\n-        }\n-    }\n-\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n-        int[] sizes = { 16, 8, 4, 2, 1 };\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            \/\/init root segment\n-            MemorySegment segment = kind.makeSegment(16);\n-            for (int i = 0 ; i < 16 ; i++) {\n-                MemoryAccess.setByteAtOffset(segment, i, (byte)i);\n-            }\n-            \/\/compute all slices\n-            for (int size : sizes) {\n-                for (int index = 0 ; index < 16 ; index += size) {\n-                    MemorySegment slice = segment.asSlice(index, size);\n-                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n-                }\n-            }\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,1 +57,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -63,1 +63,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -69,1 +69,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -75,1 +75,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -81,1 +81,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -87,1 +87,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -93,1 +93,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n@@ -128,2 +128,2 @@\n-            MemoryLayouts.JAVA_INT,\n-            MemoryLayouts.JAVA_INT\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.JAVA_INT\n@@ -135,48 +135,48 @@\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_INT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_LONG, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 8, 16, 2 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 256 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_SHORT, new long[] { 256 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_CHAR, new long[] { 256 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_INT, new long[] { 256 } },\n+                { ValueLayout.JAVA_INT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_INT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_INT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_INT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_INT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_LONG, new long[] { 256 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_FLOAT, new long[] { 256 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 256 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 8, 16, 2 } },\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -55,3 +55,1 @@\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newConfinedScope(cleaner) :\n-                ResourceScope.newConfinedScope();\n+        ResourceScope scope = ResourceScope.newConfinedScope(cleaner);\n@@ -80,3 +78,1 @@\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newSharedScope(cleaner) :\n-                ResourceScope.newSharedScope();\n+        ResourceScope scope = ResourceScope.newSharedScope(cleaner);\n@@ -106,3 +102,1 @@\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newSharedScope(cleaner) :\n-                ResourceScope.newSharedScope();\n+        ResourceScope scope = ResourceScope.newSharedScope(cleaner);\n@@ -160,7 +154,4 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testLockSingleThread(Supplier<Cleaner> cleanerSupplier) {\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newConfinedScope(cleaner) :\n-                ResourceScope.newConfinedScope();\n-        List<ResourceScope.Handle> handles = new ArrayList<>();\n+    @Test\n+    public void testLockSingleThread() {\n+        ResourceScope scope = ResourceScope.newConfinedScope();\n+        List<ResourceScope> handles = new ArrayList<>();\n@@ -168,1 +159,3 @@\n-            handles.add(scope.acquire());\n+            ResourceScope handle = ResourceScope.newConfinedScope();\n+            handle.keepAlive(scope);\n+            handles.add(handle);\n@@ -178,4 +171,2 @@\n-                ResourceScope.Handle handle = handles.remove(0);\n-                scope.release(handle);\n-                scope.release(handle); \/\/ make sure it's idempotent\n-                scope.release(handle); \/\/ make sure it's idempotent\n+                ResourceScope handle = handles.remove(0);\n+                handle.close();\n@@ -186,6 +177,3 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testLockSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newSharedScope(cleaner) :\n-                ResourceScope.newSharedScope();\n+    @Test\n+    public void testLockSharedMultiThread() {\n+        ResourceScope scope = ResourceScope.newSharedScope();\n@@ -195,2 +183,2 @@\n-                try {\n-                    ResourceScope.Handle handle = scope.acquire(); \/\/ this can throw if segment has been closed\n+                try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n+                    handle.keepAlive(scope);\n@@ -200,3 +188,1 @@\n-                    scope.release(handle); \/\/ cannot throw (acquired segments cannot be closed)\n-                    scope.release(handle); \/\/ cannot throw (idempotent)\n-                    scope.release(handle); \/\/ cannot throw (idempotent)\n+                    handle.close();\n@@ -233,1 +219,2 @@\n-        ResourceScope.Handle handle = scope.acquire();\n+        ResourceScope handle = ResourceScope.newConfinedScope();\n+        handle.keepAlive(scope);\n@@ -237,3 +224,1 @@\n-                scope.release(handle);\n-                scope.release(handle); \/\/ make sure it's idempotent\n-                scope.release(handle); \/\/ make sure it's idempotent\n+                handle.close();\n@@ -258,1 +243,1 @@\n-        if (!scope.isImplicit()) {\n+        if (scope != ResourceScope.globalScope()) {\n@@ -263,0 +248,6 @@\n+    @Test(dataProvider = \"scopes\", expectedExceptions = IllegalArgumentException.class)\n+    public void testAcquireSelf(Supplier<ResourceScope> scopeSupplier) {\n+        ResourceScope scope = scopeSupplier.get();\n+        scope.keepAlive(scope);\n+    }\n+\n@@ -264,8 +255,9 @@\n-        ResourceScope.Handle handle = scope.acquire();\n-        assertEquals(handle.scope(), scope);\n-        if (acquireCount > 0) {\n-            \/\/ recursive acquire\n-            acquireRecursive(scope, acquireCount - 1);\n-        }\n-        if (!scope.isImplicit()) {\n-            assertThrows(IllegalStateException.class, scope::close);\n+        try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n+            handle.keepAlive(scope);\n+            if (acquireCount > 0) {\n+                \/\/ recursive acquire\n+                acquireRecursive(scope, acquireCount - 1);\n+            }\n+            if (scope != ResourceScope.globalScope()) {\n+                assertThrows(IllegalStateException.class, scope::close);\n+            }\n@@ -273,3 +265,0 @@\n-        scope.release(handle);\n-        scope.release(handle); \/\/ make sure it's idempotent\n-        scope.release(handle); \/\/ make sure it's idempotent\n@@ -308,1 +297,0 @@\n-                { (Supplier<ResourceScope>)ResourceScope::newImplicitScope },\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":37,"deletions":49,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -41,1 +42,1 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"globalNativeSegment\");\n+        Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -47,3 +48,3 @@\n-        var mh = MethodHandles.lookup().findStatic(MemorySegment.class,\n-                \"globalNativeSegment\", MethodType.methodType(MemorySegment.class));\n-        var seg = (MemorySegment)mh.invokeExact();\n+        var mh = MethodHandles.lookup().findStatic(CLinker.class,\n+                \"systemCLinker\", MethodType.methodType(CLinker.class));\n+        var seg = (CLinker)mh.invokeExact();\n@@ -54,1 +55,1 @@\n-        MemorySegment.globalNativeSegment();\n+        CLinker.systemCLinker();\n@@ -59,2 +60,2 @@\n-        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegment\", long.class, ResourceScope.class);\n-        method.invoke(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddressNative\", MemoryAddress.class, long.class, ResourceScope.class);\n+        method.invoke(null, MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n@@ -65,2 +66,2 @@\n-        var mh = MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class));\n+        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class));\n@@ -72,1 +73,1 @@\n-        MemoryAddress.NULL.asSegment(4000L, ResourceScope.globalScope());\n+        MemorySegment.ofAddressNative(MemoryAddress.NULL, 4000, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -33,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -37,0 +35,2 @@\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -50,0 +50,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -109,3 +110,4 @@\n-            ResourceScope.Handle handle = scope.acquire();\n-            scope.release(handle);\n-        }, \"ResourceScope::lock\");\n+            ResourceScope scope2 = ResourceScope.newConfinedScope();\n+            scope2.keepAlive(scope);\n+            scope2.close();\n+        }, \"ResourceScope::keepAlive\");\n@@ -120,3 +122,2 @@\n-        ScopedOperation.ofScope(scope -> CLinker.VaList.make(b -> {}, scope), \"VaList::make\");\n-        ScopedOperation.ofScope(scope -> CLinker.VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n-        ScopedOperation.ofScope(scope -> CLinker.toCString(\"Hello\", scope), \"CLinker::toCString\");\n+        ScopedOperation.ofScope(scope -> VaList.make(b -> {}, scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n@@ -125,7 +126,1 @@\n-        ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n+        ScopedOperation.ofSegment(s -> s.toArray(JAVA_BYTE), \"MemorySegment::toArray(BYTE)\");\n@@ -133,1 +128,1 @@\n-        ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n+        ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), JAVA_BYTE), \"MemorySegment::spliterator\");\n@@ -137,3 +132,0 @@\n-        \/\/ address operations\n-        ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n-        ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n@@ -141,8 +133,8 @@\n-        ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n-        ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n-        ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n-        ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n-        ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n-        ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n-        ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n-        ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.structLayout(MemoryLayouts.JAVA_INT), ResourceScope.newImplicitScope()), \"VaList::vargAsSegment\/1\");\n+        ScopedOperation.ofVaList(VaList::address, \"VaList::address\");\n+        ScopedOperation.ofVaList(VaList::copy, \"VaList::copy\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.ADDRESS), \"VaList::nextVarg\/address\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_INT), \"VaList::nextVarg\/int\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_LONG), \"VaList::nextVarg\/long\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_DOUBLE), \"VaList::nextVarg\/double\");\n+        ScopedOperation.ofVaList(VaList::skip, \"VaList::skip\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(MemoryLayout.structLayout(ValueLayout.JAVA_INT), ResourceScope.newConfinedScope()), \"VaList::vargAsSegment\/1\");\n@@ -152,16 +144,16 @@\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n@@ -194,1 +186,1 @@\n-        static void ofVaList(Consumer<CLinker.VaList> vaListConsumer, String name) {\n+        static void ofVaList(Consumer<VaList> vaListConsumer, String name) {\n@@ -196,1 +188,1 @@\n-                CLinker.VaList vaList = CLinker.VaList.make((builder) -> {}, scope);\n+                VaList vaList = VaList.make((builder) -> {}, scope);\n@@ -210,9 +202,0 @@\n-        static void ofAddress(Consumer<MemoryAddress> addressConsumer, String name) {\n-            for (SegmentFactory segmentFactory : SegmentFactory.values()) {\n-                scopedOperations.add(new ScopedOperation(scope -> {\n-                    MemoryAddress segment = segmentFactory.segmentFactory.apply(scope).address();\n-                    addressConsumer.accept(segment);\n-                }, segmentFactory.name() + \"\/\" + name));\n-            }\n-        }\n-\n@@ -238,1 +221,1 @@\n-            UNSAFE(scope -> MemoryAddress.NULL.asSegment(10, scope));\n+            UNSAFE(scope -> MemorySegment.ofAddressNative(MemoryAddress.NULL, 10, scope));\n@@ -262,3 +245,2 @@\n-                return SegmentAllocator.ofSegment(segment);\n-            }),\n-            FROM_SCOPE(SegmentAllocator::ofScope);\n+                return SegmentAllocator.prefixAllocator(segment);\n+            });\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":40,"deletions":58,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.CharBuffer;\n@@ -54,1 +55,1 @@\n-    final static Class<?> ADDRESS_CARRIER = MemoryLayouts.ADDRESS.bitSize() == 64 ? long.class : int.class;\n+    final static Class<?> ADDRESS_CARRIER = ValueLayout.ADDRESS.bitSize() == 64 ? long.class : int.class;\n@@ -57,2 +58,4 @@\n-    public <Z> void testAllocation(Z value, AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n-        ValueLayout[] layouts = {\n+    @SuppressWarnings(\"unchecked\")\n+    public <Z, L extends ValueLayout> void testAllocation(Z value, AllocationFactory allocationFactory, L layout, AllocationFunction<Z, L> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n+        layout = (L)layout.withBitAlignment(layout.bitSize());\n+        L[] layouts = (L[])new ValueLayout[] {\n@@ -64,1 +67,1 @@\n-        for (ValueLayout alignedLayout : layouts) {\n+        for (L alignedLayout : layouts) {\n@@ -131,1 +134,1 @@\n-    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n+    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object, ValueLayout> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n@@ -150,9 +153,9 @@\n-                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { (byte)42, AllocationFactory.BOUNDED, ValueLayout.JAVA_BYTE,\n+                        (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { (short)42, AllocationFactory.BOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { (char)42, AllocationFactory.BOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n@@ -160,25 +163,22 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42f, AllocationFactory.BOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42L, AllocationFactory.BOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42d, AllocationFactory.BOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+\n+                { (short)42, AllocationFactory.BOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { (char)42, AllocationFactory.BOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n@@ -186,25 +186,25 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42f, AllocationFactory.BOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42L, AllocationFactory.BOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42d, AllocationFactory.BOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+\n+                { (byte)42, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_BYTE,\n+                        (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { (short)42, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { (char)42, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n@@ -212,25 +212,22 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42f, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42L, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42d, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+\n+                { (short)42, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { (char)42, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n@@ -238,15 +235,15 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42f, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42L, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { 42d, AllocationFactory.UNBOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n+                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle() },\n@@ -259,2 +256,2 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_BYTE,\n+                        (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n@@ -262,2 +259,5 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toCharArray },\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n@@ -266,2 +266,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n@@ -269,2 +269,2 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n@@ -272,2 +272,2 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n@@ -275,2 +275,2 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n@@ -278,3 +278,0 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n@@ -282,6 +279,5 @@\n-\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toCharArray },\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n@@ -290,2 +286,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n@@ -293,2 +289,2 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n@@ -296,2 +292,2 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n@@ -299,2 +295,2 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.BOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n@@ -302,3 +298,0 @@\n-                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n@@ -306,2 +299,2 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_BYTE,\n+                        (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n@@ -309,2 +302,5 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toCharArray },\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n@@ -313,2 +309,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n@@ -316,2 +312,2 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n@@ -319,2 +315,2 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n@@ -322,2 +318,2 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n@@ -325,3 +321,0 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n@@ -329,6 +322,5 @@\n-\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toCharArray },\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n@@ -337,2 +329,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n@@ -340,2 +332,2 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n@@ -343,2 +335,2 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n@@ -346,2 +338,2 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                { AllocationFactory.UNBOUNDED, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n@@ -349,3 +341,0 @@\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n@@ -355,2 +344,20 @@\n-    interface AllocationFunction<X> {\n-        MemorySegment allocate(SegmentAllocator allocator, ValueLayout layout, X value);\n+    interface AllocationFunction<X, L extends ValueLayout> {\n+        MemorySegment allocate(SegmentAllocator allocator, L layout, X value);\n+\n+        interface OfByte extends AllocationFunction<Byte, ValueLayout.OfByte> { }\n+        interface OfBoolean extends AllocationFunction<Boolean, ValueLayout.OfBoolean> { }\n+        interface OfChar extends AllocationFunction<Character, ValueLayout.OfChar> { }\n+        interface OfShort extends AllocationFunction<Short, ValueLayout.OfShort> { }\n+        interface OfInt extends AllocationFunction<Integer, ValueLayout.OfInt> { }\n+        interface OfFloat extends AllocationFunction<Float, ValueLayout.OfFloat> { }\n+        interface OfLong extends AllocationFunction<Long, ValueLayout.OfLong> { }\n+        interface OfDouble extends AllocationFunction<Double, ValueLayout.OfDouble> { }\n+        interface OfAddress extends AllocationFunction<MemoryAddress, ValueLayout.OfAddress> { }\n+\n+        interface OfByteArray extends AllocationFunction<byte[], ValueLayout.OfByte> { }\n+        interface OfCharArray extends AllocationFunction<char[], ValueLayout.OfChar> { }\n+        interface OfShortArray extends AllocationFunction<short[], ValueLayout.OfShort> { }\n+        interface OfIntArray extends AllocationFunction<int[], ValueLayout.OfInt> { }\n+        interface OfFloatArray extends AllocationFunction<float[], ValueLayout.OfFloat> { }\n+        interface OfLongArray extends AllocationFunction<long[], ValueLayout.OfLong> { }\n+        interface OfDoubleArray extends AllocationFunction<double[], ValueLayout.OfDouble> { }\n@@ -399,0 +406,15 @@\n+        ToArrayHelper<char[]> toCharArray = new ToArrayHelper<>() {\n+            @Override\n+            public char[] array() {\n+                return new char[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public char[] toArray(MemorySegment segment, ValueLayout layout) {\n+                CharBuffer buffer = segment.asByteBuffer().order(layout.order()).asCharBuffer();\n+                char[] found = new char[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n@@ -477,1 +499,1 @@\n-                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+                return switch ((int) ValueLayout.ADDRESS.byteSize()) {\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":193,"deletions":171,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestSegmentCopy\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentCopy {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n+        int size = Math.min(s1.byteSize(), s2.byteSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s2, i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s1, i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, 0, s2.segment, 0, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.check(s2, i, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.type.carrier != s2.type.carrier) return;\n+        int size = Math.min(s1.elementSize(), s2.elementSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            s2.set(i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            s1.set(i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0; i < size; i++) {\n+            s2.check(i, i);\n+        }\n+    }\n+\n+    interface Getter<X> {\n+        X get(MemorySegment segment, ValueLayout layout, long index);\n+    }\n+\n+    interface Setter<X> {\n+        void set(MemorySegment segment, ValueLayout layout, long index, X val);\n+    }\n+\n+    enum Type {\n+        \/\/ Byte\n+        BYTE(byte.class, ValueLayout.JAVA_BYTE, i -> (byte)i),\n+        \/\/LE\n+        SHORT_LE(short.class, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (short)i),\n+        CHAR_LE(char.class, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (char)i),\n+        INT_LE(int.class, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> i),\n+        FLOAT_LE(float.class, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (float)i),\n+        LONG_LE(long.class, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (long)i),\n+        DOUBLE_LE(double.class, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (double)i),\n+        \/\/BE\n+        SHORT_BE(short.class, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), i -> (short)i),\n+        CHAR_BE(char.class, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), i -> (char)i),\n+        INT_BE(int.class, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), i -> i),\n+        FLOAT_BE(float.class, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), i -> (float)i),\n+        LONG_BE(long.class, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), i -> (long)i),\n+        DOUBLE_BE(double.class, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), i -> (double)i);\n+\n+        final ValueLayout layout;\n+        final IntFunction<Object> valueConverter;\n+        final Class<?> carrier;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <Z> Type(Class<Z> carrier, ValueLayout layout, IntFunction<Z> valueConverter) {\n+            this.carrier = carrier;\n+            this.layout = layout;\n+            this.valueConverter = (IntFunction<Object>)valueConverter;\n+        }\n+\n+        int size() {\n+            return (int)layout.byteSize();\n+        }\n+\n+        VarHandle handle() {\n+            return MemoryHandles.varHandle(layout);\n+        }\n+\n+        void set(SegmentSlice slice, int index, int val) {\n+            handle().set(slice.segment, index * size(), valueConverter.apply(val));\n+        }\n+\n+        void check(SegmentSlice slice, int index, int val) {\n+            assertEquals(handle().get(slice.segment, index * size()), valueConverter.apply(val));\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final Type type;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.type = type;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        void set(int index, int val) {\n+            type.set(this, index, val);\n+        }\n+\n+        void check(int index, int val) {\n+            type.check(this, index, val);\n+        }\n+\n+        int byteSize() {\n+            return last - first + 1;\n+        }\n+\n+        int elementSize() {\n+            return byteSize() \/ type.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] elementSlices() {\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            MemorySegment segment = kind.makeSegment(16);\n+            \/\/compute all slices\n+            for (Type type : Type.values()) {\n+                for (int index = 0; index < 16; index += type.size()) {\n+                    MemorySegment first = segment.asSlice(0, index);\n+                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n+                    MemorySegment second = segment.asSlice(index);\n+                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -40,1 +39,0 @@\n-import java.nio.ByteOrder;\n@@ -44,1 +42,0 @@\n-import java.util.function.LongFunction;\n@@ -47,0 +44,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -53,6 +51,1 @@\n-        MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n-    }\n-\n-    @Test(dataProvider = \"badLayouts\", expectedExceptions = UnsupportedOperationException.class)\n-    public void testBadAllocateLayout(MemoryLayout layout) {\n-        MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment.allocateNative(size, align, ResourceScope.newConfinedScope());\n@@ -64,1 +57,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE, ResourceScope.newImplicitScope());\n+        MemorySegment.allocateNative(Long.MAX_VALUE, ResourceScope.newConfinedScope());\n@@ -69,1 +62,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, ResourceScope.newImplicitScope()); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, ResourceScope.newConfinedScope()); \/\/ 2M\n@@ -74,2 +67,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -86,2 +79,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -109,2 +102,2 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n+        memorySegment.get(JAVA_INT, offset);\n@@ -116,2 +109,2 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n+        memorySegment.get(JAVA_INT, offset);\n@@ -128,1 +121,1 @@\n-        if (!segment.scope().isImplicit()) {\n+        if (segment.scope() != ResourceScope.globalScope()) {\n@@ -143,3 +136,0 @@\n-                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newImplicitScope()),\n@@ -148,1 +138,4 @@\n-                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newConfinedScope())\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope()),\n+                () -> MemorySegment.allocateNative(4, ResourceScope.newConfinedScope()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newConfinedScope()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope())\n@@ -156,2 +149,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -196,1 +189,1 @@\n-    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {\n+    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) {\n@@ -199,1 +192,1 @@\n-            segment.address().toRawLongValue();\n+            segment.address();\n@@ -201,1 +194,0 @@\n-            assertTrue(segment.address().isNative());\n@@ -204,1 +196,0 @@\n-            assertFalse(segment.address().isNative());\n@@ -265,27 +256,0 @@\n-    @DataProvider(name = \"badLayouts\")\n-    public Object[][] layouts() {\n-        SizedLayoutFactory[] layoutFactories = SizedLayoutFactory.values();\n-        Object[][] values = new Object[layoutFactories.length * 2][2];\n-        for (int i = 0; i < layoutFactories.length ; i++) {\n-            values[i * 2] = new Object[] { MemoryLayout.structLayout(layoutFactories[i].make(7), MemoryLayout.paddingLayout(9)) }; \/\/ good size, bad align\n-            values[(i * 2) + 1] = new Object[] { layoutFactories[i].make(15).withBitAlignment(16) }; \/\/ bad size, good align\n-        }\n-        return values;\n-    }\n-\n-    enum SizedLayoutFactory {\n-        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n-        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n-        PADDING(MemoryLayout::paddingLayout);\n-\n-        private final LongFunction<MemoryLayout> factory;\n-\n-        SizedLayoutFactory(LongFunction<MemoryLayout> factory) {\n-            this.factory = factory;\n-        }\n-\n-        MemoryLayout make(long size) {\n-            return factory.apply(size);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":22,"deletions":58,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -50,1 +50,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -101,1 +101,1 @@\n-            MemorySegment sharedSegment = s.address().asSegment(s.byteSize(), scope);\n+            MemorySegment sharedSegment = MemorySegment.ofAddressNative(s.address(), s.byteSize(), scope);\n@@ -124,1 +124,1 @@\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, MemoryLayouts.JAVA_INT), scope);\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), scope);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +42,1 @@\n-            MemoryLayout.sequenceLayout(5, MemoryLayouts.JAVA_INT));\n+            MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT));\n@@ -44,1 +44,1 @@\n-    static VarHandle VH_ALL = LAYOUT.varHandle(int.class,\n+    static VarHandle VH_ALL = LAYOUT.varHandle(\n@@ -79,1 +79,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -82,1 +82,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -85,1 +85,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -88,1 +88,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -43,1 +42,0 @@\n-import java.util.stream.StreamSupport;\n@@ -45,0 +43,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -51,2 +50,2 @@\n-    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -58,1 +57,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(size, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(size, ValueLayout.JAVA_INT);\n@@ -85,1 +84,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -88,1 +87,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n@@ -103,1 +102,1 @@\n-        MemorySegment.ofArray(new byte[2]).spliterator(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[2]).spliterator(ValueLayout.JAVA_INT);\n@@ -108,1 +107,1 @@\n-        MemorySegment.ofArray(new byte[2]).elements(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[2]).elements(ValueLayout.JAVA_INT);\n@@ -113,1 +112,1 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[7]).spliterator(ValueLayout.JAVA_INT);\n@@ -118,1 +117,1 @@\n-        MemorySegment.ofArray(new byte[7]).elements(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[7]).elements(ValueLayout.JAVA_INT);\n@@ -123,1 +122,1 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n@@ -128,1 +127,1 @@\n-        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -43,1 +42,1 @@\n-            MemorySegment text = CLinker.toCString(testString, scope);\n+            MemorySegment text = scope.allocateUtf8String(testString);\n@@ -47,1 +46,1 @@\n-            String roundTrip = CLinker.toJavaString(text);\n+            String roundTrip = text.getUtf8String(0);\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -32,2 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -36,0 +35,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -38,0 +38,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -64,2 +65,2 @@\n-        MemorySegment segment = LOOKUP.lookup(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n+        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        assertEquals(segment.get(JAVA_BYTE, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -34,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -41,3 +40,2 @@\n-    static final VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-\n-    static final VarHandle ADDR_HANDLE = MemoryHandles.asAddressVarHandle(INT_HANDLE);\n+    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle ADDR_HANDLE = ValueLayout.ADDRESS.varHandle();\n@@ -47,4 +45,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n-            int v = (int)INT_HANDLE.get(\"string\");\n-        }\n+        int v = (int)INT_HANDLE.get(\"string\");\n@@ -55,4 +50,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n-            int v = (int)INT_HANDLE.get(1);\n-        }\n+        int v = (int)INT_HANDLE.get(1);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        CLinker.getInstance(); \/\/ trigger initialization\n+        CLinker.systemCLinker(); \/\/ trigger initialization\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedPlatform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,24 +25,0 @@\n-\/*\n- * @test id=scope\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=SCOPE\n- *   TestUpcall\n- *\/\n-\n-\/*\n- * @test id=no_scope\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=NO_SCOPE\n- *   TestUpcall\n- *\/\n-\n@@ -61,0 +37,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -85,1 +62,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -103,1 +79,1 @@\n-    static CLinker abi = CLinker.getInstance();\n+    static CLinker abi = CLinker.systemCLinker();\n@@ -120,1 +96,1 @@\n-    static MemoryAddress dummyStub;\n+    static CLinker.UpcallStub dummyStub;\n@@ -124,1 +100,1 @@\n-        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newSharedScope());\n@@ -129,1 +105,1 @@\n-            throw new SkipException(\"Skipping tests that were not selected\");\n+            return;\/\/throw new SkipException(\"Skipping tests that were not selected\");\n@@ -139,1 +115,0 @@\n-        MethodType mtype = methodType(ret, paramTypes, fields);\n@@ -141,1 +116,1 @@\n-            MethodHandle mh = abi.downcallHandle(addr, scope, mtype, function(ret, paramTypes, fields));\n+            MethodHandle mh = downcallHandle(abi, addr, scope, function(ret, paramTypes, fields));\n@@ -159,3 +134,2 @@\n-        MethodType mtype = methodType(ret, paramTypes, fields);\n-        MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+        MethodHandle mh = downcallHandle(abi, addr, CONFINED_ALLOCATOR, function(ret, paramTypes, fields));\n+        Object[] args = makeArgs(ResourceScope.newSharedScope(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -170,0 +144,1 @@\n+\n@@ -173,1 +148,0 @@\n-\n@@ -177,1 +151,0 @@\n-        MethodType mtype = methodType(ret, paramTypes, fields);\n@@ -180,2 +153,2 @@\n-            MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, descriptor);\n-            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+            MethodHandle mh = reverse(downcallHandle(abi, addr, CONFINED_ALLOCATOR, descriptor));\n+            Object[] args = makeArgs(ResourceScope.newSharedScope(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -188,1 +161,1 @@\n-            MemoryAddress callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n+            CLinker.UpcallStub callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n@@ -210,2 +183,1 @@\n-                    MethodType.methodType(void.class, MemoryAddress.class),\n-                    FunctionDescriptor.ofVoid(C_POINTER)));\n+                        FunctionDescriptor.ofVoid(C_POINTER)));\n@@ -220,1 +192,0 @@\n-            MethodType type = MethodType.methodType(paramCarrier(returnLayout), MemoryAddress.class);\n@@ -223,1 +194,1 @@\n-            return abi.downcallHandle(invokerSymbol, type, desc);\n+            return abi.downcallHandle(invokerSymbol, desc);\n@@ -227,10 +198,0 @@\n-    static MethodType methodType(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        MethodType mt = ret == Ret.VOID ?\n-                MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));\n-        for (ParamType p : params) {\n-            mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));\n-        }\n-        mt = mt.appendParameterTypes(MemoryAddress.class); \/\/the callback\n-        return mt;\n-    }\n-\n@@ -256,1 +217,1 @@\n-    static MemoryAddress makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static CLinker.UpcallStub makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n@@ -258,1 +219,1 @@\n-            return dummyStub.address();\n+            return dummyStub;\n@@ -268,1 +229,1 @@\n-            Class<?> carrier = paramCarrier(layout);\n+            Class<?> carrier = carrier(layout, false);\n@@ -281,1 +242,1 @@\n-        Class<?> firstCarrier = paramCarrier(firstlayout);\n+        Class<?> firstCarrier = carrier(firstlayout, true);\n@@ -302,1 +263,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newSharedScope());\n@@ -314,0 +275,13 @@\n+\n+    static MethodHandle reverse(MethodHandle handle) {\n+        MethodType type = handle.type();\n+        if (type.returnType().equals(MemoryAddress.class)) {\n+            type = type.changeReturnType(Addressable.class);\n+        }\n+        for (int i = 0 ; i < type.parameterCount() ; i++) {\n+            if (type.parameterType(i).equals(Addressable.class)) {\n+                type.changeParameterType(i, MemoryAddress.class);\n+            }\n+        }\n+        return handle.asType(type);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":32,"deletions":58,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.ResourceScope;\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -52,1 +53,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -58,1 +58,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -73,6 +73,1 @@\n-                MethodType.methodType(void.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER,\n+                    FunctionDescriptor.ofVoid(C_POINTER,\n@@ -95,1 +90,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newConfinedScope());\n@@ -111,1 +106,1 @@\n-            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n+            CLinker.UpcallStub upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n@@ -113,1 +108,1 @@\n-            args[0] = upcallStub.address();\n+            args[0] = upcallStub;\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -55,3 +56,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -60,1 +58,1 @@\n-public class TestUpcallStructScope {\n+public class TestUpcallStructScope extends NativeTestHelper {\n@@ -62,1 +60,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -77,2 +75,1 @@\n-            MethodType.methodType(void.class, MemoryAddress.class, MemorySegment.class),\n-            FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n+                FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n@@ -99,1 +96,1 @@\n-            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            CLinker.UpcallStub upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n@@ -101,1 +98,1 @@\n-            MH_do_upcall.invokeExact(upcallStub.address(), argSegment);\n+            MH_do_upcall.invoke(upcallStub, argSegment);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -52,1 +51,1 @@\n-public class TestVarArgs {\n+public class TestVarArgs extends NativeTestHelper {\n@@ -58,2 +57,2 @@\n-    static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(long.class, groupElement(\"writeback\"));\n-    static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(long.class, groupElement(\"argIDs\"));\n+    static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(groupElement(\"writeback\"));\n+    static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(groupElement(\"argIDs\"));\n@@ -61,1 +60,1 @@\n-    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(sequenceElement());\n@@ -63,1 +62,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -83,2 +82,2 @@\n-            VH_CallInfo_writeback.set(callInfo, writeBack.address().toRawLongValue());\n-            VH_CallInfo_argIDs.set(callInfo, argIDs.address().toRawLongValue());\n+            VH_CallInfo_writeback.set(callInfo, writeBack.address());\n+            VH_CallInfo_argIDs.set(callInfo, argIDs.address());\n@@ -93,1 +92,0 @@\n-            args.forEach(a -> argLayouts.add(asVarArg(a.layout)));\n@@ -95,1 +93,2 @@\n-            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new));\n+            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.stream().toArray(MemoryLayout[]::new))\n+                    .asVariadic(args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));\n@@ -104,1 +103,1 @@\n-            MethodHandle downcallHandle = abi.downcallHandle(VARARGS_ADDR, mt, desc);\n+            MethodHandle downcallHandle = abi.downcallHandle(VARARGS_ADDR, desc);\n@@ -143,1 +142,1 @@\n-            this.vh = layout.varHandle(carrier);\n+            this.vh = layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -46,1 +47,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE);\n@@ -55,1 +56,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n@@ -63,10 +64,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testAlignNotPowerOf2() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 3, ByteOrder.nativeOrder());\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testAlignNegative() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, -1, ByteOrder.nativeOrder());\n-    }\n-\n@@ -75,1 +66,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n@@ -77,1 +68,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1, 2, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(1, 2, ResourceScope.newConfinedScope());\n@@ -84,1 +75,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN));\n@@ -94,1 +85,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -109,1 +100,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n@@ -124,16 +115,0 @@\n-\n-    @Test(dataProvider = \"badCarriers\", expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarrier(Class<?> carrier) {\n-        MemoryHandles.varHandle(carrier, ByteOrder.nativeOrder());\n-    }\n-\n-    @DataProvider(name = \"badCarriers\")\n-    public Object[][] createBadCarriers() {\n-        return new Object[][] {\n-                { void.class },\n-                { Object.class },\n-                { int[].class },\n-                { MemorySegment.class }\n-        };\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":8,"deletions":33,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -33,1 +34,0 @@\n-import java.security.Permission;\n@@ -35,3 +35,1 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-\n-public class ThrowingUpcall {\n+public class ThrowingUpcall extends NativeTestHelper {\n@@ -45,1 +43,1 @@\n-        downcall = CLinker.getInstance().downcallHandle(\n+        downcall = CLinker.systemCLinker().downcallHandle(\n@@ -47,2 +45,1 @@\n-            MethodType.methodType(void.class, MemoryAddress.class),\n-            FunctionDescriptor.ofVoid(C_POINTER)\n+                FunctionDescriptor.ofVoid(C_POINTER)\n@@ -73,1 +70,1 @@\n-            MemoryAddress stub = CLinker.getInstance().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+            CLinker.UpcallStub stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n@@ -75,1 +72,1 @@\n-            downcall.invokeExact(stub); \/\/ should call Shutdown.exit(1);\n+            downcall.invoke(stub); \/\/ should call Shutdown.exit(1);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -160,2 +160,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -201,2 +200,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -207,2 +205,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -369,2 +366,2 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(r0, long.class) },\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(r1, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r0, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r1, long.class) },\n@@ -377,1 +374,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -159,2 +159,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -181,1 +180,1 @@\n-                C_INT, C_DOUBLE, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE));\n+                C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n@@ -254,2 +253,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -353,1 +351,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(rcx, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(rcx, long.class) },\n@@ -357,1 +355,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n@@ -361,1 +359,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(4), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(4), long.class) },\n@@ -365,1 +363,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(8), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(8), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.ref.Cleaner;\n@@ -32,1 +31,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -37,0 +36,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -54,1 +55,1 @@\n-        if (scope.isImplicit())\n+        if (scope == ResourceScope.globalScope())\n@@ -78,1 +79,1 @@\n-            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+            segment.set(JAVA_BYTE, i, ((byte)RANDOM.nextInt()));\n@@ -132,1 +133,0 @@\n-                { ScopeSupplier.NEW_CONFINED_EXPLICIT },\n@@ -140,1 +140,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT },\n@@ -154,1 +153,0 @@\n-                { ScopeSupplier.NEW_IMPLICIT },\n@@ -177,1 +175,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT ,  0 },\n@@ -179,1 +176,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT , 30 },\n@@ -187,2 +183,0 @@\n-        static final Supplier<ResourceScope> NEW_CONFINED_EXPLICIT =\n-                new ScopeSupplier(() -> ResourceScope.newConfinedScope(Cleaner.create()), \"newConfinedScope(Cleaner)\");\n@@ -191,4 +185,0 @@\n-        static final Supplier<ResourceScope> NEW_SHARED_EXPLICIT =\n-                new ScopeSupplier(() -> ResourceScope.newSharedScope(Cleaner.create()), \"newSharedScope(Cleaner)\");\n-        static final Supplier<ResourceScope> NEW_IMPLICIT =\n-                new ScopeSupplier(() -> ResourceScope.newImplicitScope(), \"newImplicitScope()\");\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -57,0 +57,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -165,1 +166,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n@@ -224,1 +225,1 @@\n-                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n@@ -273,1 +274,1 @@\n-            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -47,0 +47,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -104,1 +106,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n@@ -122,1 +124,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -41,1 +41,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -48,1 +48,1 @@\n-       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n@@ -55,1 +55,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -35,0 +34,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -55,1 +55,1 @@\n-            throw new AssertionError(\"Call to restricted method did not fail as expected!\");\n+            throw new AssertionError(\"Call to restricted method did not fail as expected!\", ex);\n@@ -66,2 +66,1 @@\n-        addDefaultMapping(CLinker.class, CLinker.getInstance());\n-        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n@@ -76,1 +75,1 @@\n-        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(MemoryLayout.class, ValueLayout.JAVA_INT);\n@@ -79,1 +78,1 @@\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newConfinedScope());\n@@ -81,0 +80,17 @@\n+        addDefaultMapping(ValueLayout.OfByte.class, ValueLayout.JAVA_BYTE);\n+        addDefaultMapping(ValueLayout.OfBoolean.class, ValueLayout.JAVA_BOOLEAN);\n+        addDefaultMapping(ValueLayout.OfChar.class, ValueLayout.JAVA_CHAR);\n+        addDefaultMapping(ValueLayout.OfShort.class, ValueLayout.JAVA_SHORT);\n+        addDefaultMapping(ValueLayout.OfInt.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfFloat.class, ValueLayout.JAVA_FLOAT);\n+        addDefaultMapping(ValueLayout.OfLong.class, ValueLayout.JAVA_LONG);\n+        addDefaultMapping(ValueLayout.OfDouble.class, ValueLayout.JAVA_DOUBLE);\n+        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(byte.class, (byte)0);\n+        addDefaultMapping(boolean.class, true);\n+        addDefaultMapping(char.class, (char)0);\n+        addDefaultMapping(short.class, (short)0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -32,3 +31,0 @@\n-import java.nio.charset.Charset;\n-import java.nio.file.Path;\n-import java.util.Optional;\n@@ -36,1 +32,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.Addressable;\n@@ -39,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -42,1 +37,0 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -44,0 +38,2 @@\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,13 +53,4 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n-                            MethodType.methodType(CLinker.class)), \"CLinker::getInstance\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"toJavaString\",\n-                            MethodType.methodType(String.class, MemoryAddress.class)),\n-                            \"CLinker::toJavaString\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"allocateMemory\",\n-                            MethodType.methodType(MemoryAddress.class, long.class)),\n-                            \"CLinker::allocateMemory\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"freeMemory\",\n-                            MethodType.methodType(void.class, MemoryAddress.class)),\n-                            \"CLinker::freeMemory\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n-                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class)),\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n+                            MethodType.methodType(CLinker.class)), \"ForeignLinker::systemCLinker\" },\n+                    { MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\",\n+                            MethodType.methodType(VaList.class, MemoryAddress.class)),\n@@ -71,2 +58,2 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n-                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class, ResourceScope.class)),\n+                    { MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\",\n+                            MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)),\n@@ -74,3 +61,0 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemLookup\",\n-                            MethodType.methodType(SymbolLookup.class)),\n-                            \"CLinker::systemLookup\" },\n@@ -80,9 +64,63 @@\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-                            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class)),\n-                            \"MemoryAddress::asSegment\/1\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-                            MethodType.methodType(MemorySegment.class, long.class, Runnable.class, ResourceScope.class)),\n-                            \"MemoryAddress::asSegment\/2\" },\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"globalNativeSegment\",\n-                            MethodType.methodType(MemorySegment.class)),\n-                            \"MemoryAddress::globalNativeSegment\" }\n+                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class)),\n+                            \"MemorySegment::ofAddressNative\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getUtf8String\",\n+                            MethodType.methodType(String.class, long.class)),\n+                            \"MemoryAddress::getUtf8String\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setUtf8String\",\n+                            MethodType.methodType(void.class, long.class, String.class)),\n+                            \"MemoryAddress::setUtf8String\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(byte.class, ValueLayout.OfByte.class, long.class)),\n+                            \"MemoryAddress::get\/byte\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(boolean.class, ValueLayout.OfBoolean.class, long.class)),\n+                            \"MemoryAddress::get\/boolean\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n+                            \"MemoryAddress::get\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n+                            \"MemoryAddress::get\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n+                            \"MemoryAddress::get\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n+                            \"MemoryAddress::get\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n+                            \"MemoryAddress::get\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n+                            \"MemoryAddress::get\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n+                            \"MemoryAddress::get\/address\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfByte.class, long.class, byte.class)),\n+                            \"MemoryAddress::set\/byte\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfBoolean.class, long.class, boolean.class)),\n+                            \"MemoryAddress::set\/boolean\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n+                            \"MemoryAddress::set\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n+                            \"MemoryAddress::set\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n+                            \"MemoryAddress::set\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n+                            \"MemoryAddress::set\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n+                            \"MemoryAddress::set\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n+                            \"MemoryAddress::set\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n+                            \"MemoryAddress::set\/address\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":72,"deletions":34,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library ..\/\n@@ -32,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -40,1 +40,0 @@\n-import java.lang.invoke.MethodType;\n@@ -42,1 +41,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -45,1 +44,1 @@\n-public class TestMixedMallocFree {\n+public class TestMixedMallocFree extends NativeTestHelper {\n@@ -53,1 +52,1 @@\n-        MH_my_malloc = CLinker.getInstance().downcallHandle(\n+        MH_my_malloc = CLinker.systemCLinker().downcallHandle(\n@@ -55,2 +54,1 @@\n-            MethodType.methodType(MemoryAddress.class, long.class),\n-            FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n@@ -62,3 +60,3 @@\n-        MemorySegment seg = ma.asSegment(4L, ResourceScope.newImplicitScope());\n-        MemoryAccess.setInt(seg, 42);\n-        assertEquals(MemoryAccess.getInt(seg), 42);\n+        MemorySegment seg = MemorySegment.ofAddressNative(ma, 4L, ResourceScope.newConfinedScope());\n+        seg.set(JAVA_INT, 0, 42);\n+        assertEquals(seg.get(JAVA_INT, 0), 42);\n@@ -67,1 +65,1 @@\n-        CLinker.freeMemory(ma);\n+        freeMemory(ma);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library ..\/\n@@ -55,0 +56,1 @@\n+ * @library ..\/\n@@ -83,0 +85,1 @@\n+ * @library ..\/\n@@ -107,0 +110,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -119,1 +123,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -122,1 +125,1 @@\n-public class TestAsyncStackWalk {\n+public class TestAsyncStackWalk extends NativeTestHelper {\n@@ -125,1 +128,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -136,1 +139,0 @@\n-                    MethodType.methodType(void.class, MemoryAddress.class),\n@@ -149,1 +151,1 @@\n-            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            CLinker.UpcallStub stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n@@ -159,1 +161,1 @@\n-        MH_asyncStackWalk.invokeExact(cb);\n+        MH_asyncStackWalk.invoke(cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library ..\/\n@@ -55,0 +56,1 @@\n+ * @library ..\/\n@@ -83,0 +85,1 @@\n+ * @library ..\/\n@@ -107,0 +110,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -120,1 +124,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -122,1 +125,1 @@\n-public class TestStackWalk {\n+public class TestStackWalk extends NativeTestHelper {\n@@ -125,1 +128,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -136,1 +139,0 @@\n-                    MethodType.methodType(void.class, MemoryAddress.class),\n@@ -148,1 +150,1 @@\n-            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            CLinker.UpcallStub stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n@@ -161,1 +163,1 @@\n-        MH_foo.invokeExact(cb);\n+        MH_foo.invoke(cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.incubator.foreign.VaList;\n@@ -58,7 +58,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_FLOAT;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -66,1 +59,3 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -72,1 +67,1 @@\n-    private static final CLinker abi = CLinker.getInstance();\n+    private static final CLinker abi = CLinker.systemCLinker();\n@@ -79,1 +74,0 @@\n-    private static final MethodHandle VALIST_TO_ADDRESS;\n@@ -84,1 +78,0 @@\n-            VALIST_TO_ADDRESS = MethodHandles.lookup().findVirtual(VaList.class, \"address\", MethodType.methodType(MemoryAddress.class));\n@@ -93,1 +86,0 @@\n-            MethodType.methodType(int.class, int.class, MemoryAddress.class),\n@@ -96,1 +88,0 @@\n-            MethodType.methodType(double.class, int.class, MemoryAddress.class),\n@@ -99,1 +90,0 @@\n-            MethodType.methodType(int.class, MemoryAddress.class),\n@@ -102,1 +92,0 @@\n-            MethodType.methodType(int.class, MemoryAddress.class),\n@@ -105,1 +94,0 @@\n-            MethodType.methodType(long.class, MemoryAddress.class),\n@@ -108,1 +96,0 @@\n-            MethodType.methodType(long.class, MemoryAddress.class),\n@@ -111,1 +98,0 @@\n-            MethodType.methodType(float.class, MemoryAddress.class),\n@@ -114,1 +100,0 @@\n-            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),\n@@ -117,2 +102,2 @@\n-    private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {\n-        return linkInternal(symbol, mt, fd, false);\n+    private static MethodHandle link(String symbol, FunctionDescriptor fd) {\n+        return linkInternal(symbol, fd);\n@@ -121,2 +106,2 @@\n-    private static MethodHandle linkVaList(String symbol, MethodType mt, FunctionDescriptor fd) {\n-        return linkInternal(symbol, mt, fd, true);\n+    private static MethodHandle linkVaList(String symbol, FunctionDescriptor fd) {\n+        return linkInternal(symbol, fd);\n@@ -126,5 +111,2 @@\n-    private static MethodHandle linkInternal(String symbol, MethodType mt, FunctionDescriptor fd, boolean hasVaListParam) {\n-        MethodHandle handle = abi.downcallHandle(LOOKUP.lookup(symbol).get(), mt, fd);\n-        return hasVaListParam ?\n-                MethodHandles.filterArguments(handle, handle.type().parameterCount() - 1, VALIST_TO_ADDRESS) :\n-                handle;\n+    private static MethodHandle linkInternal(String symbol, FunctionDescriptor fd) {\n+        return abi.downcallHandle(LOOKUP.lookup(symbol).get(), fd);\n@@ -135,1 +117,0 @@\n-                MethodType.methodType(void.class, MemoryAddress.class),\n@@ -165,2 +146,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();\n+        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n+                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -181,1 +162,1 @@\n-                           ValueLayout intLayout) {\n+                           ValueLayout.OfInt intLayout) {\n@@ -183,3 +164,3 @@\n-            b.vargFromInt(intLayout, 10)\n-                    .vargFromInt(intLayout, 15)\n-                    .vargFromInt(intLayout, 20));\n+            b.addVarg(intLayout, 10)\n+                    .addVarg(intLayout, 15)\n+                    .addVarg(intLayout, 20));\n@@ -194,2 +175,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n-                (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();\n+        Function<ValueLayout.OfDouble, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n+                (num, list) -> DoubleStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -210,1 +191,1 @@\n-                              ValueLayout doubleLayout) {\n+                              ValueLayout.OfDouble doubleLayout) {\n@@ -212,3 +193,3 @@\n-            b.vargFromDouble(doubleLayout, 3.0D)\n-                    .vargFromDouble(doubleLayout, 4.0D)\n-                    .vargFromDouble(doubleLayout, 5.0D));\n+            b.addVarg(doubleLayout, 3.0D)\n+                    .addVarg(doubleLayout, 4.0D)\n+                    .addVarg(doubleLayout, 5.0D));\n@@ -223,1 +204,1 @@\n-        Function<MemoryLayout, Function<VaList, Integer>> getIntJavaFact = layout ->\n+        Function<ValueLayout.OfAddress, Function<VaList, Integer>> getIntJavaFact = layout ->\n@@ -225,2 +206,2 @@\n-                    MemoryAddress ma = list.vargAsAddress(layout);\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n+                    MemoryAddress ma = list.nextVarg(layout);\n+                    return ma.get(JAVA_INT, 0);\n@@ -241,1 +222,1 @@\n-                                        ValueLayout pointerLayout) {\n+                                        ValueLayout.OfAddress pointerLayout) {\n@@ -244,2 +225,2 @@\n-            MemoryAccess.setInt(msInt, 10);\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()));\n+            msInt.set(JAVA_INT, 0, 10);\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt.address()));\n@@ -259,1 +240,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n@@ -262,1 +243,1 @@\n-                    MemorySegment struct = list.vargAsSegment(pointLayout, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = list.nextVarg(pointLayout, ResourceScope.newConfinedScope());\n@@ -268,1 +249,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n@@ -273,1 +254,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n@@ -279,2 +260,2 @@\n-            VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(\"x\"));\n-            VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(\"y\"));\n+            VarHandle VH_Point_x = pointLayout.varHandle(groupElement(\"x\"));\n+            VarHandle VH_Point_y = pointLayout.varHandle(groupElement(\"y\"));\n@@ -302,1 +283,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, struct));\n@@ -312,1 +293,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n@@ -315,1 +296,1 @@\n-                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = list.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -321,1 +302,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n@@ -326,1 +307,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n@@ -332,2 +313,2 @@\n-            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n+            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -355,1 +336,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(BigPoint_LAYOUT, struct));\n@@ -365,1 +346,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n@@ -368,1 +349,1 @@\n-                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = list.nextVarg(FloatPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -374,1 +355,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n@@ -379,1 +360,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n@@ -385,2 +366,2 @@\n-            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"x\"));\n-            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"y\"));\n+            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -409,1 +390,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(FloatPoint_LAYOUT, struct));\n@@ -423,1 +404,1 @@\n-        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n+        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n@@ -426,1 +407,1 @@\n-                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = list.nextVarg(HugePoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -433,1 +414,1 @@\n-        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n+        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n@@ -438,1 +419,1 @@\n-                QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n+                QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n@@ -445,3 +426,3 @@\n-            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n-            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"z\"));\n+            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n+            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n@@ -474,1 +455,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(HugePoint_LAYOUT, struct));\n@@ -487,1 +468,1 @@\n-        BiFunction<MemoryLayout, MemoryLayout, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n+        BiFunction<ValueLayout.OfLong, ValueLayout.OfDouble, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n@@ -491,1 +472,1 @@\n-                        lSum += list.vargAsLong(longLayout);\n+                        lSum += list.nextVarg(longLayout);\n@@ -493,1 +474,1 @@\n-                    MemoryAccess.setLong(longSum, lSum);\n+                    longSum.set(JAVA_LONG, 0, lSum);\n@@ -496,1 +477,1 @@\n-                        dSum += list.vargAsDouble(doubleLayout);\n+                        dSum += list.nextVarg(doubleLayout);\n@@ -498,1 +479,1 @@\n-                    MemoryAccess.setDouble(doubleSum, dSum);\n+                    doubleSum.set(JAVA_DOUBLE, 0, dSum);\n@@ -502,1 +483,1 @@\n-                MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);\n+                MH_sumStack.invoke(longSum, doubleSum, list);\n@@ -519,2 +500,2 @@\n-                          ValueLayout longLayout,\n-                          ValueLayout doubleLayout) {\n+                          ValueLayout.OfLong longLayout,\n+                          ValueLayout.OfDouble doubleLayout) {\n@@ -524,2 +505,2 @@\n-            MemoryAccess.setLong(longSum, 0L);\n-            MemoryAccess.setDouble(doubleSum, 0D);\n+            longSum.set(JAVA_LONG, 0, 0L);\n+            doubleSum.set(JAVA_DOUBLE, 0, 0D);\n@@ -529,1 +510,1 @@\n-                    b.vargFromLong(longLayout, l);\n+                    b.addVarg(longLayout, l);\n@@ -532,1 +513,1 @@\n-                    b.vargFromDouble(doubleLayout, d);\n+                    b.addVarg(doubleLayout, d);\n@@ -542,2 +523,2 @@\n-            long lSum = MemoryAccess.getLong(longSum);\n-            double dSum = MemoryAccess.getDouble(doubleSum);\n+            long lSum = longSum.get(JAVA_LONG, 0);\n+            double dSum = doubleSum.get(JAVA_DOUBLE, 0);\n@@ -554,2 +535,2 @@\n-            MemoryAddress stub = abi.upcallStub(callback, desc, scope);\n-            target.invokeExact(stub.address());\n+            CLinker.UpcallStub stub = abi.upcallStub(callback, desc, scope);\n+            target.invoke(stub);\n@@ -583,2 +564,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();\n+        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n+                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -599,1 +580,1 @@\n-                                 ValueLayout intLayout) {\n+                                 ValueLayout.OfInt intLayout) {\n@@ -602,2 +583,2 @@\n-            VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                            .vargFromInt(intLayout, 8),\n+            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                            .addVarg(intLayout, 8),\n@@ -622,2 +603,2 @@\n-                VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn));\n-                pointOut = list.vargAsSegment(Point_LAYOUT, scope);\n+                VaList list = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, pointIn));\n+                pointOut = list.nextVarg(Point_LAYOUT, scope);\n@@ -645,3 +626,3 @@\n-    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n+    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n+        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                .addVarg(intLayout, 8));\n@@ -649,2 +630,2 @@\n-        assertEquals(copy.vargAsInt(intLayout), 4);\n-        assertEquals(copy.vargAsInt(intLayout), 8);\n+        assertEquals(copy.nextVarg(intLayout), 4);\n+        assertEquals(copy.nextVarg(intLayout), 8);\n@@ -659,2 +640,2 @@\n-        assertEquals(list.vargAsInt(intLayout), 4);\n-        assertEquals(list.vargAsInt(intLayout), 8);\n+        assertEquals(list.nextVarg(intLayout), 4);\n+        assertEquals(list.nextVarg(intLayout), 8);\n@@ -667,3 +648,3 @@\n-                                                    ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n+                                                    ValueLayout.OfInt intLayout) {\n+        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                .addVarg(intLayout, 8));\n@@ -673,1 +654,1 @@\n-        copy.vargAsInt(intLayout); \/\/ should throw\n+        copy.nextVarg(intLayout); \/\/ should throw\n@@ -682,2 +663,2 @@\n-        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n+        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -688,2 +669,2 @@\n-        VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(\"x\"));\n-        VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(\"y\"));\n+        VarHandle VH_Point_x = Point_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_Point_y = Point_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -694,2 +675,2 @@\n-        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"x\"));\n-        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"y\"));\n+        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -701,3 +682,3 @@\n-        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n-        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"z\"));\n+        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n+        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n@@ -707,1 +688,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -713,1 +694,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -721,1 +702,1 @@\n-                    struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    struct = copy.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -726,1 +707,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -730,1 +711,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n@@ -734,1 +715,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n@@ -737,1 +718,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = vaList.nextVarg(Point_LAYOUT, ResourceScope.newConfinedScope());\n@@ -742,1 +723,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = vaList.nextVarg(HugePoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -748,1 +729,1 @@\n-                    MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = vaList.nextVarg(FloatPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -753,3 +734,3 @@\n-                    MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);\n-                    MemorySegment ms = intPtr.asSegment(C_INT.byteSize(), ResourceScope.globalScope());\n-                    int x = MemoryAccess.getInt(ms);\n+                    MemoryAddress intPtr = vaList.nextVarg(C_POINTER);\n+                    MemorySegment ms = MemorySegment.ofAddressNative(intPtr, C_INT.byteSize(), ResourceScope.globalScope());\n+                    int x = ms.get(JAVA_INT, 0);\n@@ -759,3 +740,3 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 3.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 4.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 5.0);\n@@ -764,3 +745,3 @@\n-                    assertEquals(vaList.vargAsInt(C_INT), 10);\n-                    assertEquals(vaList.vargAsInt(C_INT), 15);\n-                    assertEquals(vaList.vargAsInt(C_INT), 20);\n+                    assertEquals(vaList.nextVarg(C_INT), 10);\n+                    assertEquals(vaList.nextVarg(C_INT), 15);\n+                    assertEquals(vaList.nextVarg(C_INT), 20);\n@@ -771,1 +752,1 @@\n-                        assertEquals(vaList.vargAsLong(C_LONG_LONG), l);\n+                        assertEquals(vaList.nextVarg(C_LONG_LONG), l);\n@@ -774,1 +755,1 @@\n-                        assertEquals(vaList.vargAsDouble(C_DOUBLE), d);\n+                        assertEquals(vaList.nextVarg(C_DOUBLE), d);\n@@ -778,16 +759,16 @@\n-                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);\n-                    assertEquals((char) vaList.vargAsInt(C_INT), 'a');\n-                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);\n-                    assertEquals(vaList.vargAsInt(C_INT), 4);\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 5L);\n-                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);\n-                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);\n-                    assertEquals((char) vaList.vargAsInt(C_INT), 'b');\n-                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);\n-                    assertEquals(vaList.vargAsInt(C_INT), 11);\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 12L);\n-                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);\n-\n-                    MemorySegment point = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 1);\n+                    assertEquals((char) vaList.nextVarg(C_INT), 'a');\n+                    assertEquals((short) vaList.nextVarg(C_INT), (short) 3);\n+                    assertEquals(vaList.nextVarg(C_INT), 4);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n+                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 6.0F);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 7.0D);\n+                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 8);\n+                    assertEquals((char) vaList.nextVarg(C_INT), 'b');\n+                    assertEquals((short) vaList.nextVarg(C_INT), (short) 10);\n+                    assertEquals(vaList.nextVarg(C_INT), 11);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 12L);\n+                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 13.0F);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 14.0D);\n+\n+                    MemorySegment point = vaList.nextVarg(Point_LAYOUT, ResourceScope.newConfinedScope());\n@@ -798,1 +779,1 @@\n-                    MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment bigPoint = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -806,1 +787,1 @@\n-                    MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = copy.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n@@ -813,1 +794,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 5L);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n@@ -815,1 +796,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 10L);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 10L);\n@@ -817,1 +798,1 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 1.0D);\n@@ -819,1 +800,1 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 6.0D);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":143,"deletions":162,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library ..\/\n@@ -37,1 +38,0 @@\n-import java.lang.invoke.MethodType;\n@@ -43,1 +43,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -46,1 +45,1 @@\n-public class TestVirtualCalls {\n+public class TestVirtualCalls extends NativeTestHelper {\n@@ -48,1 +47,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -51,3 +50,3 @@\n-    static final MemoryAddress funcA;\n-    static final MemoryAddress funcB;\n-    static final MemoryAddress funcC;\n+    static final Addressable funcA;\n+    static final Addressable funcB;\n+    static final Addressable funcC;\n@@ -57,2 +56,1 @@\n-            MethodType.methodType(int.class),\n-            FunctionDescriptor.of(C_INT));\n+                FunctionDescriptor.of(C_INT));\n@@ -69,3 +67,3 @@\n-        assertEquals((int) func.invokeExact((Addressable) funcA), 1);\n-        assertEquals((int) func.invokeExact((Addressable) funcB), 2);\n-        assertEquals((int) func.invokeExact((Addressable) funcC), 3);\n+        assertEquals((int) func.invokeExact(funcA), 1);\n+        assertEquals((int) func.invokeExact(funcB), 2);\n+        assertEquals((int) func.invokeExact(funcC), 3);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -39,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,1 +43,1 @@\n-        Function<MemorySegment, Byte> mapper = MemoryAccess::getByte;\n+        Function<MemorySegment, Byte> mapper = s -> s.get(ValueLayout.JAVA_BYTE, 0);\n@@ -55,1 +54,1 @@\n-        Function<MemorySegment, Character> mapper = MemoryAccess::getChar;\n+        Function<MemorySegment, Character> mapper = s -> s.get(ValueLayout.JAVA_CHAR, 0);\n@@ -66,1 +65,1 @@\n-        Function<MemorySegment, Short> mapper = MemoryAccess::getShort;\n+        Function<MemorySegment, Short> mapper = s -> s.get(ValueLayout.JAVA_SHORT, 0);\n@@ -77,1 +76,1 @@\n-        Function<MemorySegment, Integer> mapper = MemoryAccess::getInt;\n+        Function<MemorySegment, Integer> mapper = s -> s.get(ValueLayout.JAVA_INT, 0);\n@@ -88,1 +87,1 @@\n-        Function<MemorySegment, Long> mapper = MemoryAccess::getLong;\n+        Function<MemorySegment, Long> mapper = s-> s.get(ValueLayout.JAVA_LONG, 0);\n@@ -99,1 +98,1 @@\n-        Function<MemorySegment, Float> mapper = MemoryAccess::getFloat;\n+        Function<MemorySegment, Float> mapper = s -> s.get(ValueLayout.JAVA_FLOAT, 0);\n@@ -118,1 +117,1 @@\n-        Function<MemorySegment, Double> mapper = MemoryAccess::getDouble;\n+        Function<MemorySegment, Double> mapper = s -> s.get(ValueLayout.JAVA_DOUBLE, 0);\n@@ -130,1 +129,1 @@\n-            MemoryAccess.setByte(segment, (byte)i);\n+            segment.set(ValueLayout.JAVA_BYTE, 0, (byte)i);\n@@ -135,7 +134,7 @@\n-            { \"bytes\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n-            { \"chars\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n-            { \"shorts\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n-            { \"ints\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n-            { \"longs\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n-            { \"floats\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n-            { \"doubles\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n+            { \"bytes\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n+            { \"chars\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n+            { \"shorts\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n+            { \"ints\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n+            { \"longs\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n+            { \"floats\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n+            { \"doubles\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -41,1 +40,0 @@\n-import sun.misc.Unsafe;\n@@ -48,2 +46,0 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n-\n@@ -60,2 +56,1 @@\n-        SHARED(ResourceScope::newSharedScope),\n-        IMPLICIT(ResourceScope::newImplicitScope);\n+        SHARED(ResourceScope::newSharedScope);\n@@ -74,1 +69,1 @@\n-    @Param({\"CONFINED\", \"SHARED\", \"IMPLICIT\"})\n+    @Param({\"CONFINED\", \"SHARED\"})\n@@ -124,2 +119,1 @@\n-        if (!scope.isImplicit())\n-            scope.close();\n+        scope.close();\n@@ -137,2 +131,2 @@\n-        var handle = mismatchSegmentLarge1.scope().acquire();\n-        try {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            scope.keepAlive(mismatchSegmentLarge1.scope());\n@@ -140,2 +134,0 @@\n-        } finally {\n-            mismatchSegmentLarge1.scope().release(handle);\n@@ -160,2 +152,2 @@\n-        var handle = mismatchSegmentLarge1.scope().acquire();\n-        try {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+            scope.keepAlive(mismatchSegmentLarge1.scope());\n@@ -163,2 +155,0 @@\n-        } finally {\n-            mismatchSegmentLarge1.scope().release(handle);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Setup;\n@@ -35,0 +37,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -40,0 +43,1 @@\n+import java.nio.IntBuffer;\n@@ -42,1 +46,2 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -58,2 +63,1 @@\n-    static final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final ResourceScope scope = ResourceScope.newConfinedScope();\n@@ -61,3 +65,7 @@\n-    static final int[] bytes = new int[ELEM_SIZE];\n-    static final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n-    static final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n+    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n+\n+    final int[] bytes = new int[ELEM_SIZE];\n+    final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n+    final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n@@ -67,4 +75,4 @@\n-    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n-    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n-    static final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-    static final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n@@ -73,5 +81,7 @@\n-    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n-    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n-    static final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-    static final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-    static {\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n+    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n+    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n+\n+    @Setup\n+    public void setup() {\n@@ -93,1 +103,0 @@\n-    }\n@@ -95,1 +104,0 @@\n-    static {\n@@ -101,0 +109,5 @@\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n@@ -125,0 +138,44 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small_dontinline() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void unsafe_copy_small() {\n+        unsafe.copyMemory(bytes, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy_small() {\n+        buffer.put(0, bytes, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy() {\n+        buffer.put(0, bytes, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_dontinline() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, 0, bytes.length);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":74,"deletions":17,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+public class CLayouts {\n+\n+    \/\/ the constants below are useful aliases for C types. The type\/carrier association is only valid for 64-bit platforms.\n+\n+    \/**\n+     * The layout for the {@code bool} C type\n+     *\/\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    \/**\n+     * The layout for the {@code char} C type\n+     *\/\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    \/**\n+     * The layout for the {@code short} C type\n+     *\/\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    \/**\n+     * The layout for the {@code int} C type\n+     *\/\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+\n+    \/**\n+     * The layout for the {@code long long} C type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    \/**\n+     * The layout for the {@code float} C type\n+     *\/\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    \/**\n+     * The layout for the {@code double} C type\n+     *\/\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    \/**\n+     * The {@code T*} native type.\n+     *\/\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+\n+    private static CLinker LINKER = CLinker.systemCLinker();\n+\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CLayouts.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -58,5 +59,0 @@\n-    @Benchmark\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n-    }\n-\n@@ -73,5 +69,0 @@\n-    @Benchmark\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n-    }\n-\n@@ -85,1 +76,6 @@\n-        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)MemoryAddress.NULL);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_non_exact() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invoke(MemoryAddress.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -44,1 +40,1 @@\n-public class CallOverheadHelper {\n+public class CallOverheadHelper extends CLayouts {\n@@ -46,1 +42,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -78,4 +74,0 @@\n-    static final MethodHandle func_trivial;\n-    static final MethodHandle func_trivial_v;\n-    static final MethodHandle identity_trivial;\n-    static final MethodHandle identity_trivial_v;\n@@ -87,1 +79,1 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n@@ -89,1 +81,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope()));\n@@ -100,1 +92,1 @@\n-            func_v = abi.downcallHandle(mt, fd);\n+            func_v = abi.downcallHandle(fd);\n@@ -102,2 +94,0 @@\n-            func_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n@@ -107,1 +97,0 @@\n-            MethodType mt = MethodType.methodType(int.class, int.class);\n@@ -109,1 +98,1 @@\n-            identity_v = abi.downcallHandle(mt, fd);\n+            identity_v = abi.downcallHandle(fd);\n@@ -111,2 +100,0 @@\n-            identity_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n@@ -116,1 +103,0 @@\n-                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n@@ -122,1 +108,0 @@\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n@@ -128,1 +113,0 @@\n-                MethodType.methodType(void.class, long.class),\n@@ -134,1 +118,0 @@\n-                MethodType.methodType(void.class, long.class, double.class),\n@@ -140,1 +123,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class),\n@@ -146,1 +128,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class),\n@@ -152,1 +133,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n@@ -158,2 +138,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n-                                                  double.class, long.class, double.class, long.class, double.class),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":6,"deletions":28,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -58,5 +58,0 @@\n-    @Benchmark\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial_v.invokeExact(func_addr);\n-    }\n-\n@@ -73,5 +68,0 @@\n-    @Benchmark\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -75,2 +75,2 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newImplicitScope());\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverConstant.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -64,1 +64,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -67,1 +67,1 @@\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.ofSegment(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n@@ -85,1 +85,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n@@ -95,1 +95,1 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope(null)) {\n@@ -141,1 +141,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+public class LoopOverNewHeap {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+\n+    @Param(value = {\"false\", \"true\"})\n+    boolean polluteProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (polluteProfile) {\n+            for (int i = 0 ; i < 10000 ; i++) {\n+                MemorySegment intB = MemorySegment.ofArray(new byte[ELEM_SIZE]);\n+                MemorySegment intI = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+                MemorySegment intD = MemorySegment.ofArray(new double[ELEM_SIZE]);\n+                MemorySegment intF = MemorySegment.ofArray(new float[ELEM_SIZE]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unsafe_loop() {\n+        int[] elems = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(elems, Unsafe.ARRAY_INT_BASE_OFFSET + (i * CARRIER_SIZE) , i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void segment_loop() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public void segment_loop_dontinline() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void buffer_loop() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            buffer.put(i , i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNewHeap.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -63,1 +63,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -120,4 +120,4 @@\n-    public int segment_loop_static() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i ++) {\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+    public int segment_loop() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(segment, (long) i);\n@@ -125,1 +125,1 @@\n-        return res;\n+        return sum;\n@@ -129,1 +129,1 @@\n-    public int segment_loop() {\n+    public int segment_loop_instance() {\n@@ -132,1 +132,30 @@\n-            sum += (int) VH_int.get(segment, (long) i);\n+            sum += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_index() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.getAtIndex(JAVA_INT, i);\n+\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address_index() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.address().getAtIndex(JAVA_INT, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,1 +44,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n@@ -78,1 +77,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentIn, i, i);\n+            segmentIn.setAtIndex(JAVA_DOUBLE, i, i);\n@@ -81,1 +80,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i, i);\n+            segmentOut.setAtIndex(JAVA_DOUBLE, i, i);\n@@ -115,3 +114,3 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i,\n-                    MemoryAccess.getDoubleAtIndex(segmentIn, i) +\n-                    MemoryAccess.getDoubleAtIndex(segmentOut, i));\n+            segmentOut.setAtIndex(JAVA_DOUBLE, i,\n+                    segmentIn.getAtIndex(JAVA_DOUBLE, i) +\n+                    segmentOut.getAtIndex(JAVA_DOUBLE, i));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -49,1 +48,4 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -66,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -82,1 +84,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope(Cleaner.create()));\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope());\n@@ -84,5 +86,5 @@\n-                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                MemoryAccess.setIntAtIndex(intI, i, i);\n-                MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                MemoryAccess.setFloatAtIndex(intF, i, i);\n-                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n+                intB.set(JAVA_BYTE, i, (byte)i);\n+                intI.setAtIndex(JAVA_INT, i, i);\n+                intD.setAtIndex(JAVA_DOUBLE, i, i);\n+                intF.setAtIndex(JAVA_FLOAT, i, i);\n+                s.set(JAVA_BYTE, i, (byte) i);\n@@ -137,1 +139,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -140,1 +142,10 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -54,1 +53,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -84,1 +83,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -146,1 +145,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -149,1 +148,10 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -47,1 +46,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -63,1 +62,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -120,1 +119,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -123,1 +122,10 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,1 +44,2 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -65,1 +65,1 @@\n-    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -82,2 +82,2 @@\n-                MemoryAccess.setIntAtIndex(nativeSegment, i, i);\n-                MemoryAccess.setFloatAtIndex(nativeSegment, i, i);\n+                nativeSegment.setAtIndex(JAVA_INT, i, i);\n+                nativeSegment.setAtIndex(JAVA_FLOAT, i, i);\n@@ -85,2 +85,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentBytes, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentBytes, i, i);\n+                heapSegmentBytes.setAtIndex(JAVA_INT, i, i);\n+                heapSegmentBytes.setAtIndex(JAVA_FLOAT, i, i);\n@@ -88,2 +88,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentFloats, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentFloats, i, i);\n+                heapSegmentFloats.setAtIndex(JAVA_INT, i, i);\n+                heapSegmentFloats.setAtIndex(JAVA_FLOAT, i, i);\n@@ -116,1 +116,1 @@\n-    public int native_segment_static() {\n+    public int native_segment_instance() {\n@@ -119,2 +119,2 @@\n-            MemoryAccess.setIntAtOffset(nativeSegment, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(nativeSegment, k);\n+            nativeSegment.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = nativeSegment.getAtIndex(JAVA_INT, k);\n@@ -138,1 +138,1 @@\n-    public int heap_segment_ints_static() {\n+    public int heap_segment_ints_instance() {\n@@ -141,2 +141,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentBytes, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentBytes, k);\n+            heapSegmentBytes.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = heapSegmentBytes.getAtIndex(JAVA_INT, k);\n@@ -160,1 +160,1 @@\n-    public int heap_segment_floats_static() {\n+    public int heap_segment_floats_instance() {\n@@ -163,2 +163,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentFloats, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentFloats, k);\n+            heapSegmentFloats.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = heapSegmentFloats.getAtIndex(JAVA_INT, k);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -55,1 +55,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -68,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -70,1 +70,1 @@\n-    final static MemoryLayout ELEM_LAYOUT = MemoryLayouts.JAVA_INT;\n+    final static MemoryLayout ELEM_LAYOUT = ValueLayout.JAVA_INT;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -26,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,1 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -47,4 +47,1 @@\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -58,1 +55,1 @@\n-public class QSort {\n+public class QSort extends CLayouts {\n@@ -60,1 +57,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -63,1 +60,1 @@\n-    static final MemoryAddress panama_upcall_compar;\n+    static final Addressable panama_upcall_compar;\n@@ -77,1 +74,0 @@\n-            SymbolLookup systemLookup = CLinker.systemLookup();\n@@ -79,2 +75,1 @@\n-                    systemLookup.lookup(\"qsort\").orElseThrow(),\n-                    MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+                    abi.lookup(\"qsort\").orElseThrow(),\n@@ -128,1 +123,1 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+        return addr.get(JAVA_INT, 0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n@@ -127,1 +127,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ResourceScopeClose.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -48,1 +48,0 @@\n-import java.lang.invoke.MethodType;\n@@ -51,1 +50,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -59,1 +58,1 @@\n-public class StrLenTest {\n+public class StrLenTest extends CLayouts {\n@@ -75,3 +74,0 @@\n-    static final MethodHandle STRLEN_TRIVIAL;\n-    static final MethodHandle MALLOC_TRIVIAL;\n-    static final MethodHandle FREE_TRIVIAL;\n@@ -80,3 +76,2 @@\n-        CLinker abi = CLinker.getInstance();\n-        STRLEN = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        CLinker abi = CLinker.systemCLinker();\n+        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n@@ -84,10 +79,0 @@\n-        STRLEN_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        MALLOC_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n-                MethodType.methodType(MemoryAddress.class, long.class),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-\n-        FREE_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n@@ -99,1 +84,1 @@\n-        segmentAllocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(size + 1, ResourceScope.newImplicitScope()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, ResourceScope.newConfinedScope()));\n@@ -114,3 +99,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = CLinker.toCString(str, scope);\n-            return (int)STRLEN.invokeExact(segment.address());\n+        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+            MemorySegment segment = scope.allocateUtf8String(str);\n+            return (int)STRLEN.invokeExact((Addressable)segment);\n@@ -122,1 +107,1 @@\n-        return (int)STRLEN.invokeExact(CLinker.toCString(str, arenaAllocator).address());\n+        return (int)STRLEN.invokeExact((Addressable)arenaAllocator.allocateUtf8String(str));\n@@ -127,1 +112,1 @@\n-        return (int)STRLEN.invokeExact(CLinker.toCString(str, segmentAllocator).address());\n+        return (int)STRLEN.invokeExact((Addressable)segmentAllocator.allocateUtf8String(str));\n@@ -133,10 +118,2 @@\n-        int res = (int) STRLEN.invokeExact(address);\n-        CLinker.freeMemory(address);\n-        return res;\n-    }\n-\n-    @Benchmark\n-    public int panama_strlen_unsafe_trivial() throws Throwable {\n-        MemoryAddress address = makeStringUnsafeTrivial(str);\n-        int res = (int) STRLEN_TRIVIAL.invokeExact(address);\n-        FREE_TRIVIAL.invokeExact(address);\n+        int res = (int) STRLEN.invokeExact((Addressable)address);\n+        freeMemory(address);\n@@ -149,12 +126,2 @@\n-        MemoryAddress address = CLinker.allocateMemory(len + 1);\n-        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n-        str.copyFrom(MemorySegment.ofArray(bytes));\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n-        return address;\n-    }\n-\n-    static MemoryAddress makeStringUnsafeTrivial(String s) throws Throwable {\n-        byte[] bytes = s.getBytes();\n-        int len = bytes.length;\n-        MemoryAddress address = (MemoryAddress)MALLOC_TRIVIAL.invokeExact((long)len + 1);\n-        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n+        MemoryAddress address = allocateMemory(len + 1);\n+        MemorySegment str = MemorySegment.ofAddressNative(address, len + 1, ResourceScope.globalScope());\n@@ -162,1 +129,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        str.set(JAVA_BYTE, len, (byte)0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":16,"deletions":49,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -88,2 +88,2 @@\n-    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestAdaptVarHandles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,3 +28,0 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorSpecies;\n@@ -47,1 +41,0 @@\n-import java.nio.ByteOrder;\n@@ -50,0 +43,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -75,1 +70,1 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size, ResourceScope.newImplicitScope());\n+        srcSegmentImplicit = MemorySegment.allocateNative(size, ResourceScope.newConfinedScope());\n@@ -122,1 +117,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n@@ -132,1 +127,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import static jdk.incubator.foreign.MemoryAccess.*;\n@@ -37,0 +36,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -49,2 +50,2 @@\n-    static final VarHandle LONG_HANDLE = MemoryLayout.sequenceLayout(SIZE, MemoryLayouts.JAVA_LONG)\n-            .varHandle(long.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle LONG_HANDLE = MemoryLayout.sequenceLayout(SIZE, JAVA_LONG)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -68,2 +69,2 @@\n-            this.inputSegment = MemoryAddress.ofLong(inputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n-            this.outputSegment = MemoryAddress.ofLong(outputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n+            this.inputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(inputAddress), 8*SIZE, ResourceScope.globalScope());\n+            this.outputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(outputAddress), 8*SIZE, ResourceScope.globalScope());\n@@ -99,1 +100,1 @@\n-    public void static_handle_loop(Data state) {\n+    public void handle_loop_instance(Data state) {\n@@ -104,4 +105,4 @@\n-            setLongAtIndex(os, i,getLongAtIndex(is, i) + MemoryAccess.getLongAtIndex(os, i));\n-            setLongAtIndex(os, i+1,getLongAtIndex(is, i+1) + getLongAtIndex(os, i+1));\n-            setLongAtIndex(os, i+2,getLongAtIndex(is, i+2) + getLongAtIndex(os, i+2));\n-            setLongAtIndex(os, i+3,getLongAtIndex(is, i+3) + getLongAtIndex(os, i+3));\n+            os.setAtIndex(JAVA_LONG, i, is.getAtIndex(JAVA_LONG, i) + os.get(JAVA_LONG, i));\n+            os.setAtIndex(JAVA_LONG, i+1, is.getAtIndex(JAVA_LONG, i+1) + os.get(JAVA_LONG, i+1));\n+            os.setAtIndex(JAVA_LONG, i+2, is.getAtIndex(JAVA_LONG, i+2) + os.get(JAVA_LONG, i+2));\n+            os.setAtIndex(JAVA_LONG, i+3, is.getAtIndex(JAVA_LONG, i+3) + os.get(JAVA_LONG, i+3));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -27,1 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -44,4 +45,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -55,1 +52,1 @@\n-public class Upcalls {\n+public class Upcalls extends CLayouts {\n@@ -57,1 +54,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -63,4 +60,4 @@\n-    static final MemoryAddress cb_blank;\n-    static final MemoryAddress cb_identity;\n-    static final MemoryAddress cb_args5;\n-    static final MemoryAddress cb_args10;\n+    static final Addressable cb_blank;\n+    static final Addressable cb_identity;\n+    static final Addressable cb_args5;\n+    static final Addressable cb_args10;\n@@ -130,2 +127,1 @@\n-            baseType.insertParameterTypes(baseType.parameterCount(), MemoryAddress.class),\n-            baseDesc.withAppendedArgumentLayouts(C_POINTER)\n+                baseDesc.withAppendedArgumentLayouts(C_POINTER)\n@@ -135,1 +131,1 @@\n-    static MemoryAddress makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static CLinker.UpcallStub makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n@@ -139,1 +135,1 @@\n-        ).address();\n+        );\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.Addressable;\n@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -39,1 +41,0 @@\n-import java.lang.invoke.MethodType;\n@@ -42,6 +43,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-import static jdk.incubator.foreign.CLinker.asVarArg;\n-\n@@ -54,1 +49,1 @@\n-public class VaList {\n+public class VaList extends CLayouts {\n@@ -56,1 +51,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -67,2 +62,1 @@\n-                MethodType.methodType(void.class, int.class, int.class, double.class, long.class),\n-                FunctionDescriptor.ofVoid(C_INT, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_LONG_LONG)));\n+                FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_DOUBLE, C_LONG_LONG));\n@@ -70,1 +64,0 @@\n-                MethodType.methodType(void.class, int.class, CLinker.VaList.class),\n@@ -83,4 +76,4 @@\n-            CLinker.VaList vaList = CLinker.VaList.make(b ->\n-                    b.vargFromInt(C_INT, 1)\n-                            .vargFromDouble(C_DOUBLE, 2D)\n-                            .vargFromLong(C_LONG_LONG, 3L), scope);\n+            jdk.incubator.foreign.VaList vaList = jdk.incubator.foreign.VaList.make(b ->\n+                    b.addVarg(C_INT, 1)\n+                            .addVarg(C_DOUBLE, 2D)\n+                            .addVarg(C_LONG_LONG, 3L), scope);\n@@ -88,1 +81,1 @@\n-                    vaList.address());\n+                    (Addressable)vaList);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -57,1 +57,1 @@\n-        generic = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        generic = MemoryHandles.varHandle(JAVA_INT);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VarHandleExact.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -26,1 +27,0 @@\n-import jdk.incubator.foreign.SymbolLookup;\n@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,0 +32,1 @@\n+import org.openjdk.bench.jdk.incubator.foreign.CLayouts;\n@@ -38,1 +39,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -40,1 +40,1 @@\n-public class PanamaPoint implements AutoCloseable {\n+public class PanamaPoint extends CLayouts implements AutoCloseable {\n@@ -47,2 +47,2 @@\n-    private static final VarHandle VH_x = LAYOUT.varHandle(int.class, groupElement(\"x\"));\n-    private static final VarHandle VH_y = LAYOUT.varHandle(int.class, groupElement(\"y\"));\n+    private static final VarHandle VH_x = LAYOUT.varHandle(groupElement(\"x\"));\n+    private static final VarHandle VH_y = LAYOUT.varHandle(groupElement(\"y\"));\n@@ -53,1 +53,1 @@\n-        CLinker abi = CLinker.getInstance();\n+        CLinker abi = CLinker.systemCLinker();\n@@ -58,2 +58,1 @@\n-            methodType(double.class, MemorySegment.class, MemorySegment.class),\n-            FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n+                FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n@@ -63,2 +62,1 @@\n-            methodType(double.class, MemoryAddress.class, MemoryAddress.class),\n-            FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n+                FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -49,0 +47,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -112,1 +112,1 @@\n-    implicitScope = ResourceScope.newImplicitScope();\n+    implicitScope = ResourceScope.newConfinedScope();\n@@ -119,2 +119,2 @@\n-    srcAddress = CLinker.allocateMemory(size);\n-    dstAddress = CLinker.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n@@ -235,2 +235,2 @@\n-      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n-      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+      var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n+      dstSegmentImplicit.set(JAVA_BYTE, i, v);\n@@ -243,2 +243,2 @@\n-      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker;\n+\n@@ -115,1 +115,1 @@\n-    implicitScope = ResourceScope.newImplicitScope();\n+    implicitScope = ResourceScope.newConfinedScope();\n@@ -122,2 +122,2 @@\n-    srcAddress = CLinker.allocateMemory(size);\n-    dstAddress = CLinker.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n@@ -133,6 +133,0 @@\n-  @TearDown\n-  public void tearDown() {\n-    CLinker.freeMemory(srcAddress);\n-    CLinker.freeMemory(dstAddress);\n-  }\n-\n@@ -219,2 +213,2 @@\n-      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"}]}