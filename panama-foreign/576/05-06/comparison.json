{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -35,0 +36,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -96,1 +98,1 @@\n-     * Reads a UTF-8 encoded, null-terminated string from this address and offset with given layout.\n+     * Reads a UTF-8 encoded, null-terminated string from this address and offset.\n@@ -120,1 +122,1 @@\n-     * Frees the memory pointed to by this memory address.\n+     * Writes a UTF-8 encoded, null-terminated string into this address at given offset.\n@@ -122,5 +124,5 @@\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n@@ -128,1 +130,0 @@\n-     * @throws IllegalArgumentException if {@code addr == MemoryAddress.NULL}.\n@@ -133,1 +134,1 @@\n-    void freeMemory();\n+    void setUtf8String(long offset, String str);\n@@ -168,26 +169,0 @@\n-    \/**\n-     * Allocates memory of given size using malloc.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param size the size (expressed in bytes) of the memory region to be allocated.\n-     * @return addr the memory address associated with the newly allocated memory region.\n-     * @throws OutOfMemoryError if {@code malloc} could not allocate the required amount of native memory.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static MemoryAddress allocateMemory(long size) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        MemoryAddress addr = SharedUtils.allocateMemoryInternal(size);\n-        if (addr.equals(NULL)) {\n-            throw new OutOfMemoryError();\n-        } else {\n-            return addr;\n-        }\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":10,"deletions":35,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    public void freeMemory() {\n+    public String getUtf8String(long offset) {\n@@ -103,1 +103,1 @@\n-        SharedUtils.freeMemoryInternal(this);\n+        return NativeMemorySegmentImpl.EVERYTHING.getUtf8String(toRawLongValue() + offset);\n@@ -109,1 +109,1 @@\n-    public String getUtf8String(long offset) {\n+    public void setUtf8String(long offset, String str) {\n@@ -112,1 +112,1 @@\n-        return NativeMemorySegmentImpl.EVERYTHING.getUtf8String(toRawLongValue() + offset);\n+        NativeMemorySegmentImpl.EVERYTHING.setUtf8String(toRawLongValue() + offset, str);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -32,0 +35,2 @@\n+import java.lang.invoke.MethodHandle;\n+\n@@ -117,0 +122,24 @@\n+\n+    private static CLinker LINKER = CLinker.systemCLinker();\n+\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        MemoryAddress addr = MemoryAddress.allocateMemory(str.length() + 1);\n+        MemoryAddress addr = allocateMemory(str.length() + 1);\n@@ -51,1 +51,1 @@\n-        addr.freeMemory();\n+        freeMemory(addr);\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng TestFunctionDescriptor\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFunctionDescriptor\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public void testNULLtoJavaString() {\n+    public void testNULLgetString() {\n@@ -65,2 +65,2 @@\n-    public void testNULLfreeMemory() {\n-        MemoryAddress.NULL.freeMemory();\n+    public void testNULLsetString() {\n+        MemoryAddress.NULL.setUtf8String(0, \"hello\");\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-public class TestNative {\n+public class TestNative extends NativeTestHelper {\n@@ -146,8 +146,0 @@\n-    public static MemoryAddress allocate(int size) {\n-        return MemoryAddress.allocateMemory(size);\n-    }\n-\n-    public static void free(MemoryAddress addr) {\n-        addr.freeMemory();\n-    }\n-\n@@ -178,1 +170,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -180,1 +172,1 @@\n-            scope.addCloseAction(() -> free(addr));\n+            scope.addCloseAction(() -> freeMemory(addr));\n@@ -188,1 +180,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -191,1 +183,1 @@\n-            scope.addCloseAction(() -> free(addr));\n+            scope.addCloseAction(() -> freeMemory(addr));\n@@ -201,1 +193,1 @@\n-        MemoryAddress addr = allocate(4);\n+        MemoryAddress addr = allocateMemory(4);\n@@ -204,1 +196,1 @@\n-        free(addr);\n+        freeMemory(addr);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -70,6 +70,3 @@\n-                    { MethodHandles.lookup().findStatic(MemoryAddress.class, \"allocateMemory\",\n-                            MethodType.methodType(MemoryAddress.class, long.class)),\n-                            \"MemoryAddress::allocateMemory\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"freeMemory\",\n-                            MethodType.methodType(void.class)),\n-                            \"MemoryAddress::freeMemory\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setUtf8String\",\n+                            MethodType.methodType(void.class, long.class, String.class)),\n+                            \"MemoryAddress::setUtf8String\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        ma.freeMemory();\n+        freeMemory(ma);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,4 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -5,0 +9,2 @@\n+import java.lang.invoke.MethodHandle;\n+\n@@ -42,0 +48,24 @@\n+\n+    private static CLinker LINKER = CLinker.systemCLinker();\n+\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CLayouts.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        address.freeMemory();\n+        freeMemory(address);\n@@ -126,1 +126,1 @@\n-        MemoryAddress address = MemoryAddress.allocateMemory(len + 1);\n+        MemoryAddress address = allocateMemory(len + 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n-    srcAddress = MemoryAddress.allocateMemory(size);\n-    dstAddress = MemoryAddress.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,2 +122,2 @@\n-    srcAddress = MemoryAddress.allocateMemory(size);\n-    dstAddress = MemoryAddress.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n@@ -133,6 +133,0 @@\n-  @TearDown\n-  public void tearDown() {\n-    srcAddress.freeMemory();\n-    dstAddress.freeMemory();\n-  }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"}]}