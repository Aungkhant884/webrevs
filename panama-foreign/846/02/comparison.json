{"files":[{"patch":"@@ -408,9 +408,5 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n- * <ol>\n- * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n- * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n- * <\/ol>\n- * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n- * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n- * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n- * of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n+ * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}.\n+ * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n+ * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n+ * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n@@ -428,2 +424,2 @@\n- * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n- * type.\n+ * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form of a variadic\n+ * function will always have a promoted type.\n@@ -435,2 +431,1 @@\n- * function descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n- * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * function descriptor, are called <em>variadic argument layouts<\/em>.\n@@ -438,5 +433,7 @@\n- * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n- * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n- * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n- * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n- * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n+ * The native linker does not automatically perform default argument promotions. However, since passing an argument of a\n+ * non-promoted type as a variadic argument is not supported in C, the native linker will reject an attempt to link a\n+ * specialized function descriptor with any variadic argument value layouts corresponding to a non-promoted C type.\n+ * Since the size of the C {@code int} type is platform-specific, exactly which layouts will be rejected is\n+ * platform-specific as well. As an example: on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n+ * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others), will be rejected by the linker.\n+ * The {@link #canonicalLayouts()} method can be used to find which layout corresponds to a particular C type.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"}]}