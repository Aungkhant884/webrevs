{"files":[{"patch":"@@ -408,9 +408,5 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n- * <ol>\n- * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n- * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n- * <\/ol>\n- * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n- * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n- * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n- * of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared With a\n+ * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}.\n+ * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n+ * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n+ * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n@@ -428,2 +424,2 @@\n- * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n- * type.\n+ * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form will always\n+ * have a promoted type.\n@@ -435,2 +431,1 @@\n- * function descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n- * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * function descriptor, are called <em>variadic argument layouts<\/em>.\n@@ -438,5 +433,8 @@\n- * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n- * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n- * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n- * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n- * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n+ * The native linker does not automatically perform default argument promotions, since it would be ambiguous whether sign\n+ * extension should take place. However, since passing an argument of a non-promoted type as a variadic argument is not\n+ * supported in C, the native linker will reject an attempt to link a specialized function descriptor with any variadic\n+ * argument layouts corresponding to a non-promoted C type. Since the size of the C {@code int} type is platform-specific,\n+ * exactly which layouts will be rejected is platform-specific as well. As an example: on Linux\/x64 the layouts\n+ * corresponding to the C types {@code _Bool}, {@code (unsigned) char}, {@code (unsigned) short}, and {@code float}\n+ * (among others), will be rejected by the linker. The {@link #canonicalLayouts()} API can be used to find which layout\n+ * corresponds to a particular C type.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"}]}