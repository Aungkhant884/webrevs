{"files":[{"patch":"@@ -0,0 +1,201 @@\n+package jdk.incubator.foreign;\n+\n+import java.util.Arrays;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Memory segments pool, maintaining pools of segments of size equal to power of 2 with ability to\n+ * expose {@link SegmentAllocator}.\n+ *\n+ * <h1>Overview<\/h1>\n+ * <br \/>\n+ * This pool can be used by long running & highly performant code which requires frequent allocations\n+ * of memory segments (typically having small size) to communicate with native API.\n+ * <br \/>\n+ * An example, can be I\/O layer which use temporary buffers for read and write.\n+ *\n+ * <h1>Segment allocators<\/h1>\n+ * This pool can provide segment allocator which can be backed by pool. All allocations\n+ * will be directed to the pool, and on {@link ResourceScope} close, the allocated segments\n+ * will be put back to pool.\n+ * <br \/>\n+ * Please note: depending on resource scope close strategy there can be a daley in putting\n+ * segments back to the pool.\n+ *\n+ * <h1>Fast entry API<\/h1>\n+ * <b>\n+ *   Note: this API is for advanced applications, as incorrect usage can lead to memory leaks,\n+ *   or memory corruption.\n+ * <\/b>\n+ *\n+ * <br \/>\n+ *\n+ * In order to mitigate overhead related to managing segments by the {@link @ResourceScope} high\n+ * performant applications can use fast entry methods.\n+ *\n+ * <h1>Memory allocation strategy<\/h1>\n+ * This pool allocates and manages set of segments of size being power of 2. If the request\n+ * is made for a segment of size S (size calculated with alignment bytes), than smallest segment\n+ * meeting both constraints is returned.\n+ *\n+ * <br \/>\n+ *\n+ * The pool manages segments in LIFO order, to increase page table, cache hits.\n+ *\n+ * <br \/>\n+ *\n+ * Segments are kept in buckets of size log(2^n). For each bucket the maximum number of elements\n+ * can be set.\n+ *\n+ * <br \/>\n+ *\n+ * When the pool can't provide segment from bucket the new segment is created, there's no upper\n+ * bound.\n+ *\n+ * <br \/>\n+ *\n+ * When the segment is returned back to pool, pool checks if the bucket size is less than maximum.\n+ * In such a case segment entry is put back, otherwise it is deallocated. This check is not atomic\n+ * with put (due to performance reasons), however low probable queue finally can contain\n+ * more elements than max.\n+ *\n+ * <br \/>\n+ * Please note: that this pool can allocate segments of larger size than requested\n+ * (almost 2x as requested), if for small it can be ok, than for larger segments it can be\n+ * risky. I. e. request for segment for 1MB (2^20), will result in segment of 1MB, however requesting for\n+ * segment of size 1MB + 1(2^20 + 1), will result in segment of size 2^21). However in case of\n+ * 1GB + 1, pool will allocate 2GB of memory.\n+ *\/\n+public class MemorySegmentPool {\n+  private static final int[] DEFAULT_MAX_SIZES = new int[Long.SIZE];\n+  private static final ResourceScope GLOBAL = ResourceScope.globalScope();\n+\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  private final SpinLockQueue<MemoryPoolSegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE];\n+\n+  private final ResourceScope scope;\n+\n+  static {\n+    int idx = 0;\n+    int cores = Runtime.getRuntime().availableProcessors();\n+\n+    for (; idx <= 10; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = 256;\n+    }\n+\n+    \/\/ Sizes up to 64kb\n+    for (; idx <= 16; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores * 4;\n+    }\n+\n+    \/\/ Sizes up to 1MB {\n+    for (; idx <= 20; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores;\n+    }\n+\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 2); \/\/2mb\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 1); \/\/4mb\n+    \/\/ Rest 0\n+  }\n+\n+  public MemorySegmentPool(ResourceScope scope) {\n+    this(DEFAULT_MAX_SIZES, scope);\n+  }\n+  public MemorySegmentPool(int maxSizes[], ResourceScope scope) {\n+    this.scope = scope;\n+\n+    validateMaxSizes(maxSizes);\n+    for (int i=0; i < segmentsDequeue.length; i++) {\n+      segmentsDequeue[i] = new SpinLockQueue<>(maxSizes[i]);\n+    }\n+  }\n+\n+  public SegmentAllocator allocatorForScope(ResourceScope resourceScope) {\n+    \/\/ Prevent scope managing this pool to go away, when dependant allocator is alive\n+    final var handle = scope.acquire();\n+    resourceScope.addOnClose(handle::close);\n+    return (bytesSize, bytesAlignment) -> getSegmentForScope(resourceScope, bytesSize, bytesAlignment);\n+  }\n+\n+  public MemoryPoolSegment getSegmentEntryByLayout(MemoryLayout layout) {\n+    return getSegmentEntryBySize(layout.byteSize(), layout.byteAlignment());\n+  }\n+\n+  \/**\n+   * Gets segment from pool or allocates new one. Internally segments are cached.\n+   * The size of segment can be larger than requested.\n+   *\n+   * @param size the size of segment.\n+   *\n+   * @return segment of size at least `size`\n+   *\/\n+  @ForceInline\n+  public MemoryPoolSegment getSegmentEntryBySize(long size, long alignment) {\n+    if (!scope.isAlive()) {\n+      throw new IllegalStateException(\"Associated resource scope is closed\");\n+    }\n+\n+    final var alignedSize = (size + alignment - 1) & -alignment;\n+    final var bitBound = bitBound(alignedSize);\n+    final var segmentDequeue = segmentsDequeue[bitBound];\n+\n+    var segment = segmentDequeue.pollEntry();\n+    if (segment == null) {\n+      final var bitBoundedSize = 1L << bitBound;\n+      segment = allocateNewEntry(segmentDequeue, bitBoundedSize);\n+    }\n+\n+    return segment;\n+  }\n+\n+  private MemorySegment getSegmentForScope(ResourceScope resourceScope, long size, long alignment) {\n+    final var segmentEntry = getSegmentEntryBySize(size, alignment);\n+    resourceScope.addOnClose(() -> segmentEntry.close());\n+    return segmentEntry.memorySegment;\n+  }\n+\n+  @ForceInline\n+  private static int bitBound(long alignedSize) {\n+    \/\/ If 100.., than 100... - 1 -> 01111\n+    \/\/ If 101 -> than 101 - 1 -> 1....\n+    return 64- Long.numberOfLeadingZeros(alignedSize - 1);\n+  }\n+\n+  private MemoryPoolSegment allocateNewEntry(SpinLockQueue<MemoryPoolSegment> queue, long allocationSize) {\n+    final var memoryAddress = CLinker.allocateMemory(allocationSize);\n+    return new MemoryPoolSegment(queue,\n+        (NativeMemorySegmentImpl) memoryAddress.asSegment(allocationSize, scope));\n+  }\n+\n+  private static void validateMaxSizes(int maxSizes[]) {\n+    Arrays.stream(maxSizes).filter(i -> i < 0).findAny()\n+        .ifPresent(i -> {\n+          throw new IllegalStateException(\"Invalid max size \" + i);\n+        });\n+  }\n+\n+  public static class MemoryPoolSegment extends SpinLockQueue.Entry<MemoryPoolSegment> implements AutoCloseable {\n+    private final NativeMemorySegmentImpl memorySegment;\n+\n+    @ForceInline\n+    private MemoryPoolSegment(SpinLockQueue<MemoryPoolSegment> queue, NativeMemorySegmentImpl segment) {\n+      super(queue);\n+      this.memorySegment = segment;\n+    }\n+\n+    @ForceInline\n+    public MemorySegment memorySegment() {\n+      return memorySegment;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void close() {\n+      if (!this.owner.putEntry(this)) {\n+        CLinker.freeMemory(this.memorySegment.address());\n+      }\n+    }\n+  }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+package jdk.incubator.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import jdk.incubator.foreign.SpinLockQueue.Entry;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Fast, concurrent LIFO queue (stack), based on operating on entries.\n+ *\n+ * This queue is designed for fast push \/ pop operations. Synchronization is\n+ * provided by spin lock.\n+ *\n+ * @param <T> the type of value used in queue\n+ *\/\n+public final class SpinLockQueue<T extends Entry<T>> {\n+\n+  private int lock = 0;\n+  private final int maxSize;\n+\n+  private volatile int size;\n+\n+  private T head;\n+\n+  private static final VarHandle HEAD;\n+  private static final VarHandle SIZE;\n+  private static final VarHandle LOCK;\n+  private static final VarHandle ENTRY_NEXT;\n+  static {\n+    try {\n+      HEAD = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"head\", Entry.class);\n+      SIZE = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"size\", int.class);\n+      LOCK = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"lock\", int.class);\n+\n+      ENTRY_NEXT = MethodHandles.lookup().findVarHandle(Entry.class, \"next\", Entry.class);\n+    } catch (Exception e) {\n+      throw new ExceptionInInitializerError(e);\n+    }\n+  }\n+\n+  public SpinLockQueue(int maxSize) {\n+    this.maxSize = maxSize;\n+  }\n+\n+  @ForceInline\n+  final public T pollEntry() {\n+\/\/    while ((int) LOCK.compareAndExchange(this, 0, 1) != 1) {};\n+    while (!LOCK.compareAndSet(this, 0, 1)) {}\n+    try {\n+      final var current = (T) HEAD.getAcquire(this);\n+      if (current != null) {\n+        HEAD.setRelease(this, ENTRY_NEXT.getAcquire(current));\n+        SIZE.setRelease(this, (int) SIZE.getAcquire(this) - 1);\n+      }\n+      return current;\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+\n+\/\/  final public void putEntryNoSizeCheck(T entry) {\n+\/\/    while (!lock.compareAndSet(0, 1)) { }\n+\/\/    try {\n+\/\/      entry.next = head;\n+\/\/      head = entry;\n+\/\/      size++;\n+\/\/    } finally {\n+\/\/      lock.set(0);\n+\/\/    }\n+\/\/  }\n+\n+  \/**\n+   * Puts entry only if queue size is less then given size.\n+   *\n+   * @param entry - entry to put\n+   *\n+   * @return {@code true} if elements has been put.\n+   *\/\n+  @ForceInline\n+  final public boolean putEntry(T entry) {\n+\/\/    while ((int) LOCK.compareAndExchange(this, 0, 1) != 1) { }\n+    while (!LOCK.compareAndSet(this, 0, 1)) { }\n+    try {\n+      final var size = (int) SIZE.getAcquire(this);\n+      if (size <= this.maxSize) {\n+        ENTRY_NEXT.setRelease(entry, HEAD.getAcquire(this));\n+        HEAD.setRelease(this, entry);\n+        SIZE.setRelease(this, size + 1);\n+        LOCK.setRelease(this, 0);\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+\n+  \/**\n+   * Checks if entry is associated with this queue.\n+   *\n+   * @param entry entry to check\n+   * @return {@code true} if this entry is associated with this queue if it's not in it\n+   *\/\n+  public boolean isAssociated(Entry<T> entry) {\n+    return entry.owner == this;\n+  }\n+\n+  \/**\n+   * Returns number of elements in the queue. This method is not atomic.\n+   *\n+   * @return number of elements in queue\n+   *\/\n+  public long size() {\n+    return this.size;\n+  }\n+\n+  public static class Entry<T extends Entry<T>> {\n+    \/\/ Should we keep generic\n+    \/\/ If exposing spinlock queue, the entry should be in module internal package, to prevent\n+    \/\/ tampering owner and next with reflect\n+    final SpinLockQueue<T> owner;\n+    volatile T next;\n+\n+    protected Entry(SpinLockQueue<T> owner) {\n+      this.owner = owner;\n+    }\n+  }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -28,0 +28,7 @@\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +41,1 @@\n+import jdk.incubator.foreign.MemorySegmentPool;\n@@ -38,0 +46,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -39,3 +48,0 @@\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.TearDown;\n@@ -45,0 +51,2 @@\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n@@ -46,0 +54,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -48,6 +57,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.CLinker.*;\n-\n@@ -59,1 +62,2 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\",\n+\"--enable-native-access\", \"ALL-UNNAMED\"})\n@@ -67,0 +71,2 @@\n+    MemorySegmentPool memorySegmentPool = new MemorySegmentPool(ResourceScope.globalScope());\n+\n@@ -148,0 +154,21 @@\n+    @Benchmark\n+    public int panama_strlen_memsegmentpool_allocator() throws Throwable {\n+        try(ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            final var allocator = memorySegmentPool.allocatorForScope(scope);\n+            return (int)STRLEN.invokeExact(CLinker.toCString(str, allocator).address());\n+        }\n+    }\n+\n+    @Benchmark\n+\/\/    @CompilerControl(CompilerControl.Mode.PRINT)\n+    public int panama_strlen_memsegmentpool_direct() throws Throwable {\n+        final var memoryPool = memorySegmentPool;\n+        final byte[] bytes = str.getBytes();\n+        final int len = bytes.length;\n+        try (var stringSegmentEntry = memoryPool.getSegmentEntryBySize(len + 1, 1)) {\n+            final var stringSegment = stringSegmentEntry.memorySegment();\n+            stringSegment.copyFrom(MemorySegment.ofArray(bytes));\n+            return (int) STRLEN.invokeExact(stringSegment.address());\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"}]}