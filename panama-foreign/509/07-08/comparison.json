{"files":[{"patch":"@@ -8,0 +8,1 @@\n+import jdk.internal.vm.annotation.DontInline;\n@@ -139,0 +140,1 @@\n+\n@@ -141,0 +143,1 @@\n+  @ForceInline\n@@ -145,1 +148,13 @@\n-    return (bytesSize, bytesAlignment) -> getAsNewSegmentWithScope(resourceScope, bytesSize, bytesAlignment);\n+    return new SegmentAllocator() {\n+\n+      @ForceInline \/\/ strongly recommended\n+      @Override\n+      public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        final var alignedSize = (bytesSize + bytesAlignment - 1) & -bytesAlignment;\n+\n+        final var segmentEntry = getSegmentForAllocator(resourceScope, alignedSize);\n+        \/\/ We want next line to be inlined, and pass aligned size, as VM better optimizes this\n+        \/\/ than 1 << bitBound\n+        return segmentEntry.memoryAddress.asSegment(alignedSize, resourceScope);\n+      }\n+    };\n@@ -161,1 +176,1 @@\n-\/\/  @ForceInline\n+  @DontInline\n@@ -173,0 +188,3 @@\n+  \/**\n+   * Search and maybe allocate segment bounded by given bit bound\n+   *\/\n@@ -181,2 +199,0 @@\n-\/\/      segment.memorySegment = (NativeMemorySegmentImpl) segment.memoryAddress.asSegment(bitBoundedSize, scope);\n-\/\/      segment.size = bitBoundedSize;\n@@ -187,4 +203,7 @@\n-  @ForceInline\n-  private MemorySegment getAsNewSegmentWithScope(ResourceScope resourceScope, long size, long alignment) {\n-    final var bitBound = bitBound(size, alignment);\n-    final var segmentEntry = getMemoryPoolSegment(bitBound);\n+  \/**\n+   * Prepares pooled segment to be returned by allocator from allocatorForScope\n+   *\/\n+  @DontInline\n+  private MemoryPoolSegment getSegmentForAllocator(ResourceScope resourceScope, long alignedSize) {\n+    int bound = bitBound(alignedSize);\n+    final var segmentEntry = getMemoryPoolSegment(bound);\n@@ -194,0 +213,1 @@\n+      @ForceInline\n@@ -199,1 +219,1 @@\n-    return segmentEntry.memoryAddress.asSegment(1L << bitBound, resourceScope);\n+    return segmentEntry;\n@@ -250,0 +270,1 @@\n+\n@@ -251,1 +272,0 @@\n-    long size;\n@@ -281,0 +301,5 @@\n+    @ForceInline\n+    public MemoryAddress memoryAddress() {\n+      return memoryAddress;\n+    }\n+\n@@ -283,0 +308,1 @@\n+    @DontInline\n@@ -289,1 +315,0 @@\n-    @ForceInline\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+  private static final VarHandle ENTRY_IN_POOL;\n+\n@@ -37,0 +39,2 @@\n+      ENTRY_IN_POOL = MethodHandles.lookup().findVarHandle(Entry.class, \"inPool\", boolean.class);\n+\n@@ -55,0 +59,1 @@\n+        ENTRY_IN_POOL.set(current, false);\n@@ -85,0 +90,5 @@\n+\n+      if ((boolean) ENTRY_IN_POOL.get(entry)) {\n+        throw new IllegalStateException(\"Entry already in pool, can't be added twice\");\n+      }\n+\n@@ -86,0 +96,2 @@\n+        ENTRY_IN_POOL.set(entry, true);\n+\n@@ -136,0 +148,13 @@\n+\n+  \/**\n+   * Checks if entry is not in pool (or throw exception) and change flags inPool.\n+   * Prevent double addition.\n+   * To be called after lock\n+   *\/\n+  @ForceInline\n+  private static void checkMarkEntryInPool(Entry<?> entry) {\n+    if (!ENTRY_IN_POOL.weakCompareAndSet(entry, false, true)) {\n+      throw new IllegalStateException(\"Entry \" + entry + \" already in pool, can't be added twice\");\n+    }\n+  }\n+\n@@ -141,1 +166,2 @@\n-    volatile T next;\n+    private volatile T next;\n+    private volatile boolean inPool;\n@@ -166,1 +192,2 @@\n-      next = next.next;\n+      ENTRY_IN_POOL.setVolatile(result, false);\n+      next = (T) ENTRY_NEXT.get(next);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -20,0 +20,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -21,0 +22,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -27,0 +29,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -28,0 +31,1 @@\n+import sun.misc.Unsafe;\n@@ -52,0 +56,3 @@\n+  static final Unsafe unsafe = Utils.unsafe;\n+\n+  private static final byte[] buff = new byte[1028*1024*4];\n@@ -79,1 +86,6 @@\n-  private MemorySegmentPool pool = new MemorySegmentPool(POOL_MAX_SIZE, ResourceScope.globalScope());\n+\/\/  @Param({\"true\", \"false\"})\n+\/\/  private boolean doSegmentWrite = true;\n+\n+  private static final boolean doSegmentWrite = true;\n+\n+  private static final MemorySegmentPool pool = new MemorySegmentPool(POOL_MAX_SIZE, ResourceScope.globalScope());\n@@ -82,0 +94,2 @@\n+  private volatile ResourceScope scope;\n+\n@@ -90,0 +104,10 @@\n+\n+    scope = ResourceScope.globalScope();\n+  }\n+\n+  private ResourceScope iterationScope;\n+  private SegmentAllocator iterationArenaAllocator;\n+\n+  @Setup(Level.Iteration)\n+  public void setupIteration() {\n+    i = 0;\n@@ -92,0 +116,13 @@\n+\/\/  @Setup(Level.Invocation)\n+\/\/  public void setupInvocation() {\n+\/\/    iterationScope = ResourceScope.newConfinedScope();\n+\/\/    iterationArenaAllocator = SegmentAllocator.arenaAllocator(iterationScope);\n+\/\/  }\n+\/\/\n+\/\/  @TearDown(Level.Invocation)\n+\/\/  public void tearDownInvocation() {\n+\/\/    iterationArenaAllocator = null;\n+\/\/    iterationScope.close();\n+\/\/    iterationScope = null;\n+\/\/  }\n+\n@@ -104,0 +141,11 @@\n+\/\/  @Benchmark\n+\/\/  public void iteration_arena_no_dealloc() {\n+\/\/    \/\/ May be OOM, arena is deallocated after iteration\n+\/\/    \/\/ Depends on setup \/ tearDown invocation\n+\/\/    for (int j = 0; j < allocations; j++) {\n+\/\/      final var segment = iterationArenaAllocator.allocate(sizes[i]);\n+\/\/      readSegment(segment);\n+\/\/      next();\n+\/\/    }\n+\/\/  }\n+\n@@ -133,1 +181,2 @@\n-      var s = pool.getSegmentEntryBySize(sizes[i], 1);\n+      var size = sizes[i];\n+      var s = pool.getSegmentEntryBySize(size, 2);\n@@ -135,0 +184,1 @@\n+\n@@ -136,0 +186,1 @@\n+\/\/      readSegment(s.memoryAddress.asSegment(size, scope));\n@@ -158,0 +209,1 @@\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n@@ -159,4 +211,7 @@\n-    final var size = (int) s.byteSize();\n-    for (int idx = 0; idx <  size; idx += 1024) {\n-\/\/      MemoryAccess.setByteAtOffset(s, l, (byte)0);\n-      BYTE.set(s, 0, (byte) 1);\n+    if (doSegmentWrite) {\n+      final var size = (int) s.byteSize();\n+      BYTE.set(s, (long) 0, (byte) 1);\n+      for (int idx = 1024; idx < size; idx += 1024) {\n+        \/\/      MemoryAccess.setByteAtOffset(s, l, (byte)0);\n+        BYTE.set(s, (long) idx, (byte) 1);\n+      }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":61,"deletions":6,"binary":false,"changes":67,"status":"modified"}]}