{"files":[{"patch":"@@ -139,1 +139,1 @@\n-    scope.addOnClose(this::freePool);\n+    scope.addCloseAction(new CleanRunnable(this.segmentsDequeue));\n@@ -174,1 +174,1 @@\n-    resourceScope.addOnClose(handle::close);\n+    resourceScope.addCloseAction(() -> scope.release(handle));\n@@ -270,6 +270,1 @@\n-    \/\/ This method is called from pool's scope close method\n-    for (int i = 0; i < segmentsDequeue.length; i++) {\n-      \/\/ After calling this method maxSize is zero, and no new entries can be put back\n-      \/\/ Entries are released using cleaner attached to pool's scope\n-      segmentsDequeue[i].retrieveAndLock();\n-    }\n+\n@@ -302,3 +297,0 @@\n-    \/** Memory segment provided in request, updated when needed *\/\n-    private MemorySegment clientsSegment;\n-\n@@ -342,10 +334,0 @@\n-    \/**\n-     * The {@link MemorySegment} associated with this item.\n-     *\n-     * @return memory segment assoicated with this item.\n-     *\/\n-    @ForceInline\n-    public MemorySegment memorySegment() {\n-      return clientsSegment;\n-    }\n-\n@@ -355,3 +337,0 @@\n-      \/\/ Segment can have reference to scope, and this can prevent scope from closing\n-      clientsSegment = null;\n-\n@@ -374,0 +353,22 @@\n+  \/**\n+   * Cleaner class has to separate pool class, from objects having strong reference\n+   * to pool's scope, as in case of implicite scope, such scope may not be closed, due\n+   * to strong reference trough cleaner method\n+   *\/\n+  private static class CleanRunnable implements Runnable {\n+    private SpinLockQueue<?>[] queuesToClean;\n+\n+    CleanRunnable(SpinLockQueue<?>[] queuesToClean) {\n+      this.queuesToClean = queuesToClean;\n+    }\n+    @Override\n+    public void run() {\n+      \/\/ This method is called from pool's scope close method\n+      for (int i = 0; i < queuesToClean.length; i++) {\n+        \/\/ After calling this method maxSize is zero, and no new entries can be put back\n+        \/\/ Entries are released using cleaner attached to pool's scope\n+        queuesToClean[i].retrieveAndLock();\n+      }\n+      queuesToClean = null;\n+    }\n+  }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -179,16 +179,0 @@\n-\/\/  @CompilerControl(CompilerControl.Mode.PRINT)\n-  public void pool_direct() {\n-    List<MemoryPoolItem> pooledSegments = new ArrayList<>(allocations);\n-    for (int j = 0; j < allocations; j++) {\n-      var size = sizes[i];\n-      var s = pool.getSegmentEntryBySize(size, 1);\n-      pooledSegments.add(s);\n-\n-      readSegment(s.memorySegment(), size);\n-\/\/      readSegment(s.memoryAddress.asSegment(size, scope));\n-      next();\n-    }\n-    pooledSegments.forEach(MemoryPoolItem::close);\n-  }\n-  @Benchmark\n-\/\/  @CompilerControl(CompilerControl.Mode.PRINT)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    public int panama_strlen_memsegmentpool_allocator() throws Throwable {\n+    public int panama_strlen_memsegmentpool_allocator_copy() throws Throwable {\n@@ -158,0 +158,8 @@\n+\n+            byte[] bytes = str.getBytes();\n+            int len = bytes.length;\n+\n+            final var segment = allocator.allocate(len+1);\n+            segment.copyFrom(MemorySegment.ofArray(bytes));\n+            MemoryAccess.setByteAtOffset(segment, len, (byte)0);\n+\n@@ -163,9 +171,4 @@\n-\/\/    @CompilerControl(CompilerControl.Mode.PRINT)\n-    public int panama_strlen_memsegmentpool_direct() throws Throwable {\n-        final var memoryPool = memorySegmentPool;\n-        final byte[] bytes = str.getBytes();\n-        final int len = bytes.length;\n-        try (var stringSegmentEntry = memoryPool.getSegmentEntryBySize(len + 1, 1)) {\n-            final var stringSegment = stringSegmentEntry.memorySegment();\n-            stringSegment.copyFrom(MemorySegment.ofArray(bytes));\n-            return (int) STRLEN.invokeExact(stringSegment.address());\n+    public int panama_strlen_memsegmentpool_allocator() throws Throwable {\n+        try(ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            final var allocator = memorySegmentPool.allocatorForScope(scope);\n+            return (int)STRLEN.invokeExact(CLinker.toCString(str, allocator).address());\n@@ -175,0 +178,1 @@\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"}]}