{"files":[{"patch":"@@ -89,1 +89,1 @@\n-  private final SpinLockQueue<MemoryPoolSegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE + 1];\n+  private final SpinLockQueue<MemoryPoolItem> segmentsDequeue[] = new SpinLockQueue[Long.SIZE + 1];\n@@ -140,1 +140,0 @@\n-\n@@ -143,0 +142,28 @@\n+  \/**\n+   * Creates new allocator backed by this pool, and bound to given scope.\n+   *\n+   * <br \/>\n+   *\n+   * The returned allocator will allocate segment of requested size, firstly by\n+   * searching for segment in the pool.\n+   *\n+   * <br \/>\n+   *\n+   * If the segment can't be found in the pool, a new one is allocated (so, this is unbounded\n+   * allocator).\n+   *\n+   * <br \/>\n+   *\n+   * When associated scope is closed, all allocated entries are put back into pool. If\n+   * during allocations more entries have been created than configured maximum number of\n+   * elements of given size class, the allocated segment is freed.\n+   *\n+   * <br \/>\n+   *\n+   * There's no guarantee which allocated entries will be put back to pool, and which one\n+   * freed.\n+   *\n+   * @param resourceScope the scope to which allocator should be bounded\n+   *\n+   * @return memory allocator backed by this pool and bound to given scope\n+   *\/\n@@ -148,13 +175,6 @@\n-    return new SegmentAllocator() {\n-\n-      @ForceInline \/\/ strongly recommended\n-      @Override\n-      public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        final var alignedSize = (bytesSize + bytesAlignment - 1) & -bytesAlignment;\n-\n-        final var segmentEntry = getSegmentForAllocator(resourceScope, alignedSize);\n-        \/\/ We want next line to be inlined, and pass aligned size, as VM better optimizes this\n-        \/\/ than 1 << bitBound\n-        return segmentEntry.memoryAddress.asSegment(alignedSize, resourceScope);\n-      }\n-    };\n+    return ((bytesSize, bytesAlignment) -> {\n+      final var alignedSize = alignSize(bytesSize, bytesAlignment);\n+      final var segmentEntry = findOrAllocateItemAndPrepareForAllocator(resourceScope, alignedSize);\n+      \/\/ Slicing source segment can be faster than source Address as segment\n+      return segmentEntry.sourceAddress.asSegment(alignedSize, null, resourceScope);\n+    });\n@@ -164,1 +184,1 @@\n-  public MemoryPoolSegment getSegmentEntryByLayout(MemoryLayout layout) {\n+  public MemoryPoolItem getSegmentEntryByLayout(MemoryLayout layout) {\n@@ -172,1 +192,1 @@\n-   * @param size the size of segment.\n+   * @param bytesSize the size of segment.\n@@ -177,7 +197,4 @@\n-  public MemoryPoolSegment getSegmentEntryBySize(long size, long alignment) {\n-\/\/    if (!scope.isAlive()) {\n-\/\/      throw new IllegalStateException(\"Associated resource scope is closed\");\n-\/\/    }\n-\n-    final var bitBound = bitBound(size, alignment);\n-    MemoryPoolSegment segment = getMemoryPoolSegment(bitBound);\n+  public MemoryPoolItem getSegmentEntryBySize(long bytesSize, long bytesAlignment) {\n+    \/\/ Don't check scope aliveness here.\n+    final var bitBound = calculateBucket(alignSize(bytesSize, bytesAlignment));\n+    MemoryPoolItem segment = findOrAllocateItem(bitBound);\n@@ -188,0 +205,4 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/ Internal methods\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n@@ -189,1 +210,1 @@\n-   * Search and maybe allocate segment bounded by given bit bound\n+   * Search and maybe allocate segment bounded by given bucket\n@@ -192,2 +213,2 @@\n-  private MemoryPoolSegment getMemoryPoolSegment(int bitBound) {\n-    final var segmentDequeue = segmentsDequeue[bitBound];\n+  private MemoryPoolItem findOrAllocateItem(int bucket) {\n+    final var segmentDequeue = segmentsDequeue[bucket];\n@@ -197,2 +218,2 @@\n-      final var bitBoundedSize = 1L << bitBound;\n-      segment = allocateNewEntry(segmentDequeue, bitBoundedSize);\n+      final var bitBoundedSize = 1L << bucket;\n+      segment = allocateNewPoolItem(segmentDequeue, bitBoundedSize);\n@@ -206,4 +227,3 @@\n-  @DontInline\n-  private MemoryPoolSegment getSegmentForAllocator(ResourceScope resourceScope, long alignedSize) {\n-    int bound = bitBound(alignedSize);\n-    final var segmentEntry = getMemoryPoolSegment(bound);\n+  private MemoryPoolItem findOrAllocateItemAndPrepareForAllocator(ResourceScope resourceScope, long alignedSize) {\n+    int bound = calculateBucket(alignedSize);\n+    final var segmentEntry = findOrAllocateItem(bound);\n@@ -222,2 +242,4 @@\n-\n-\n+  \/**\n+   * Calculates bit bound, of size - in other words the bucket which should be used for item.\n+   * @param alignedSize\n+   *\/\n@@ -225,1 +247,1 @@\n-  private static int bitBound(long alignedSize) {\n+  protected int calculateBucket(long alignedSize) {\n@@ -235,0 +257,3 @@\n+  \/**\n+   * Allocates and prepares a new item.\n+   *\/\n@@ -236,8 +261,1 @@\n-  private static int bitBound(long size, long alignment) {\n-    final var alignedSize = (size + alignment - 1) & -alignment;\n-\n-    return bitBound(alignedSize);\n-  }\n-\n-  @ForceInline\n-  private MemoryPoolSegment allocateNewEntry(SpinLockQueue<MemoryPoolSegment> queue, long allocationSize) {\n+  private MemoryPoolItem allocateNewPoolItem(SpinLockQueue<MemoryPoolItem> queue, long allocationSize) {\n@@ -245,1 +263,1 @@\n-    return new MemoryPoolSegment(queue, memoryAddress, allocationSize, scope);\n+    return new MemoryPoolItem(queue, memoryAddress, allocationSize, scope);\n@@ -249,1 +267,1 @@\n-   * Free all elements associated with pool\n+   * Free all elements associated with pool. Called when pool's scope gets closed.\n@@ -267,3 +285,3 @@\n-  public static class MemoryPoolSegment extends SpinLockQueue.Entry<MemoryPoolSegment> implements AutoCloseable {\n-    private final MemoryAddress memoryAddress;\n-    private final MemorySegment memorySegment;\n+  private static long alignSize(long bytesSize, long bytesAlignment) {\n+    return (bytesSize + bytesAlignment - 1) & -bytesAlignment;\n+  }\n@@ -271,0 +289,17 @@\n+  \/**\n+   * Represent single item in the pool with related data.\n+   * <br \/>\n+   * In order to return item back to pool close should be called (depending on context either\n+   * implicite or explicite).\n+   *\/\n+  public static final class MemoryPoolItem extends SpinLockQueue.Entry<MemoryPoolItem> implements AutoCloseable {\n+    \/** The owning queue (bucket) to which this pool item belongs. *\/\n+    private final SpinLockQueue<MemoryPoolItem> owner;\n+\n+    \/** Source memory address, it's the start of sourceSegment. *\/\n+    private final MemoryAddress sourceAddress;\n+\n+    \/** Memory segment provided in request, updated when needed *\/\n+    private MemorySegment clientsSegment;\n+\n+    \/** Flag indicating if item has been released. *\/\n@@ -277,1 +312,1 @@\n-        RELEASED = MethodHandles.lookup().findVarHandle(MemoryPoolSegment.class, \"released\", boolean.class);\n+        RELEASED = MethodHandles.lookup().findVarHandle(MemoryPoolItem.class, \"released\", boolean.class);\n@@ -282,0 +317,1 @@\n+\n@@ -283,4 +319,4 @@\n-    private MemoryPoolSegment(SpinLockQueue<MemoryPoolSegment> queue, MemoryAddress memoryAddress, long size, ResourceScope scope) {\n-      super(queue);\n-      this.memoryAddress = memoryAddress;\n-      this.memorySegment = memoryAddress.asSegment(size, scope);\n+    private MemoryPoolItem(SpinLockQueue<MemoryPoolItem> queue, MemoryAddress sourceAddress, long size, ResourceScope scope) {\n+      super();\n+      this.owner = queue;\n+      this.sourceAddress = sourceAddress;\n@@ -296,0 +332,5 @@\n+    \/**\n+     * The memory address representing beginning of this memory item.\n+     *\n+     * @return memory address representing beginning of this memory item.\n+     *\/\n@@ -297,2 +338,2 @@\n-    public MemorySegment memorySegment() {\n-      return memorySegment;\n+    public MemoryAddress memoryAddress() {\n+      return sourceAddress;\n@@ -301,0 +342,5 @@\n+    \/**\n+     * The {@link MemorySegment} associated with this item.\n+     *\n+     * @return memory segment assoicated with this item.\n+     *\/\n@@ -302,2 +348,2 @@\n-    public MemoryAddress memoryAddress() {\n-      return memoryAddress;\n+    public MemorySegment memorySegment() {\n+      return clientsSegment;\n@@ -307,1 +353,0 @@\n-\/\/    @ForceInline\n@@ -310,0 +355,3 @@\n+      \/\/ Segment can have reference to scope, and this can prevent scope from closing\n+      clientsSegment = null;\n+\n@@ -315,0 +363,3 @@\n+    \/**\n+     * Physically releases entry - free underlying memory.\n+     *\/\n@@ -318,1 +369,1 @@\n-        CLinker.freeMemory(this.memoryAddress);\n+        CLinker.freeMemory(this.sourceAddress);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":111,"deletions":60,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n- * Fast, concurrent LIFO queue (stack), based on operating on entries.\n+ * Fast, concurrent LIFO queue (stack).\n@@ -15,1 +15,1 @@\n- * @param <T> the type of value used in queue\n+ * @param <T> the item type\n@@ -46,0 +46,5 @@\n+  \/**\n+   * Creates new instace with specified maximum capacity.\n+   *\n+   * @param maxSize maximum number of elements in queue.\n+   *\/\n@@ -50,0 +55,7 @@\n+  \/**\n+   * Retrieve element form queue.\n+   * <br \/>\n+   * This operation is atomic.\n+   *\n+   * @return item or {@code null} if queue is empty.\n+   *\/\n@@ -52,1 +64,0 @@\n-\/\/    while ((int) LOCK.compareAndExchange(this, 0, 1) != 1) {};\n@@ -54,0 +65,1 @@\n+    \/\/ After volatile spin lock\n@@ -55,1 +67,1 @@\n-      final var current = (T) HEAD.getAcquire(this);\n+      final var current = (T) HEAD.get(this);\n@@ -57,2 +69,2 @@\n-        HEAD.setRelease(this, ENTRY_NEXT.getAcquire(current));\n-        SIZE.setRelease(this, (int) SIZE.getAcquire(this) - 1);\n+        HEAD.set(this, ENTRY_NEXT.get(current));\n+        SIZE.set(this, (int) SIZE.get(this) - 1);\n@@ -67,11 +79,0 @@\n-\/\/  final public void putEntryNoSizeCheck(T entry) {\n-\/\/    while (!lock.compareAndSet(0, 1)) { }\n-\/\/    try {\n-\/\/      entry.next = head;\n-\/\/      head = entry;\n-\/\/      size++;\n-\/\/    } finally {\n-\/\/      lock.set(0);\n-\/\/    }\n-\/\/  }\n-\n@@ -79,1 +80,3 @@\n-   * Puts entry only if queue size is less then given size.\n+   * Puts entry into the queue, but only if queue has a capacity.\n+   * <br \/>\n+   * This operation is atomic.\n@@ -81,1 +84,1 @@\n-   * @param entry - entry to put\n+   * @param entry entry to put\n@@ -83,1 +86,1 @@\n-   * @return {@code true} if elements has been put.\n+   * @return {@code true} if elements has been successfully put.\n@@ -88,0 +91,1 @@\n+    \/\/ After volatile spin lock\n@@ -89,1 +93,1 @@\n-      final var size = (int) SIZE.getAcquire(this);\n+      final var size = (int) SIZE.get(this);\n@@ -98,3 +102,3 @@\n-        ENTRY_NEXT.setRelease(entry, HEAD.getAcquire(this));\n-        HEAD.setRelease(this, entry);\n-        SIZE.setRelease(this, size + 1);\n+        ENTRY_NEXT.set(entry, HEAD.get(this));\n+        HEAD.set(this, entry);\n+        SIZE.set(this, size + 1);\n@@ -110,10 +114,0 @@\n-  \/**\n-   * Checks if entry is associated with this queue.\n-   *\n-   * @param entry entry to check\n-   * @return {@code true} if this entry is associated with this queue if it's not in it\n-   *\/\n-  public boolean isAssociated(Entry<T> entry) {\n-    return entry.owner == this;\n-  }\n-\n@@ -130,1 +124,2 @@\n-   * Polls all entries and sets max size to 0 so no new entries can be added.\n+   * Polls all entries and sets max size to 0, so no new entries can be added.\n+   * <br \/>\n@@ -133,1 +128,1 @@\n-   * @return iterator will all entries, iterator is not synchronized, nor thread-safe\n+   * @return iterator with all entries, iterator is not synchronized, nor thread-safe\n@@ -150,3 +145,6 @@\n-   * Checks if entry is not in pool (or throw exception) and change flags inPool.\n-   * Prevent double addition.\n-   * To be called after lock\n+   * Represent a single item which can be added to the queue.\n+   * <br \/>\n+   * As the queue is intended for fast puts and gets, users should\n+   * subclass this calls in order to add custom attributes.\n+   *\n+   * @param <T> the final exact type.\n@@ -154,12 +152,1 @@\n-  @ForceInline\n-  private static void checkMarkEntryInPool(Entry<?> entry) {\n-    if (!ENTRY_IN_POOL.weakCompareAndSet(entry, false, true)) {\n-      throw new IllegalStateException(\"Entry \" + entry + \" already in pool, can't be added twice\");\n-    }\n-  }\n-\n-  public static class Entry<T extends Entry<T>> {\n-    \/\/ Should we keep generic\n-    \/\/ If exposing spinlock queue, the entry should be in module internal package, to prevent\n-    \/\/ tampering owner and next with reflect\n-    final SpinLockQueue<T> owner;\n+  public abstract static class Entry<T extends Entry<T>> {\n@@ -169,2 +156,1 @@\n-    protected Entry(SpinLockQueue<T> owner) {\n-      this.owner = owner;\n+    protected Entry() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":39,"deletions":53,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -15,1 +15,1 @@\n-import jdk.incubator.foreign.MemorySegmentPool.MemoryPoolSegment;\n+import jdk.incubator.foreign.MemorySegmentPool.MemoryPoolItem;\n@@ -29,1 +29,0 @@\n-import org.openjdk.jmh.annotations.TearDown;\n@@ -38,1 +37,1 @@\n- * Ofc... thre are some cavets\n+ * Ofc... there are some cavets\n@@ -89,1 +88,1 @@\n-  private static final boolean doSegmentWrite = true;\n+  private static final boolean doSegmentWrite = false;\n@@ -134,2 +133,3 @@\n-        final var segment = allocator.allocate(sizes[i]);\n-        readSegment(segment);\n+        final long sz = sizes[i];\n+        final var segment = allocator.allocate(sz);\n+        readSegment(segment, sz);\n@@ -157,2 +157,3 @@\n-        final var segment = allocator.allocate(sizes[i]);\n-        readSegment(segment);\n+        final long sz = sizes[i];\n+        final var segment = allocator.allocate(sz);\n+        readSegment(segment, sz);\n@@ -169,2 +170,3 @@\n-        final var segment = allocator.allocate(sizes[i]);\n-        readSegment(segment);\n+        final long sz = sizes[i];\n+        final var segment = allocator.allocate(sz);\n+        readSegment(segment, sz );\n@@ -179,1 +181,1 @@\n-    List<MemoryPoolSegment> pooledSegments = new ArrayList<>(allocations);\n+    List<MemoryPoolItem> pooledSegments = new ArrayList<>(allocations);\n@@ -182,1 +184,1 @@\n-      var s = pool.getSegmentEntryBySize(size, 2);\n+      var s = pool.getSegmentEntryBySize(size, 1);\n@@ -185,1 +187,1 @@\n-      readSegment(s.memorySegment());\n+      readSegment(s.memorySegment(), size);\n@@ -189,1 +191,1 @@\n-    pooledSegments.forEach(MemoryPoolSegment::close);\n+    pooledSegments.forEach(MemoryPoolItem::close);\n@@ -200,1 +202,1 @@\n-      readSegment(s);\n+      readSegment(s, size);\n@@ -210,1 +212,1 @@\n-  private void readSegment(MemorySegment s) {\n+  private void readSegment(MemorySegment s, long sz) {\n@@ -212,1 +214,1 @@\n-      final var size = (int) s.byteSize();\n+      final var size = (int) sz;\/\/s.byteSize();\n@@ -214,0 +216,1 @@\n+\n@@ -215,1 +218,0 @@\n-        \/\/      MemoryAccess.setByteAtOffset(s, l, (byte)0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"}]}