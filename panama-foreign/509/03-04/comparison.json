{"files":[{"patch":"@@ -4,1 +4,2 @@\n-import jdk.incubator.foreign.SpinLockQueue.Entry;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -71,0 +72,1 @@\n+  private static final ResourceScope GLOBAL = ResourceScope.globalScope();\n@@ -73,2 +75,1 @@\n-  private final SpinLockQueue<MemorySegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE];\n-  private final int maxSizes[] = new int[Long.SIZE];\n+  private final SpinLockQueue<MemoryPoolSegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE];\n@@ -107,0 +108,1 @@\n+    validateMaxSizes(maxSizes);\n@@ -108,1 +110,1 @@\n-      segmentsDequeue[i] = new SpinLockQueue<>();\n+      segmentsDequeue[i] = new SpinLockQueue<>(maxSizes[i]);\n@@ -110,2 +112,0 @@\n-    System.arraycopy(maxSizes, 0, this.maxSizes, 0, Math.min(maxSizes.length, this.maxSizes.length));\n-    validateMaxSizes();\n@@ -121,1 +121,1 @@\n-  public Entry<MemorySegment> getSegmentEntryByLayout(MemoryLayout layout) {\n+  public MemoryPoolSegment getSegmentEntryByLayout(MemoryLayout layout) {\n@@ -133,1 +133,2 @@\n-  public Entry<MemorySegment> getSegmentEntryBySize(long size, long alignment) {\n+  @ForceInline\n+  public MemoryPoolSegment getSegmentEntryBySize(long size, long alignment) {\n@@ -140,1 +141,0 @@\n-\n@@ -142,0 +142,1 @@\n+\n@@ -144,1 +145,2 @@\n-      segment = allocateNewEntry(segmentDequeue, bitBound);\n+      final var bitBoundedSize = 1L << bitBound;\n+      segment = allocateNewEntry(segmentDequeue, bitBoundedSize);\n@@ -152,24 +154,2 @@\n-    resourceScope.addOnClose(() -> putSegmentEntry(segmentEntry));\n-    return segmentEntry.value;\n-  }\n-\n-  \/**\n-   * Returns entry back to pool. After this operation entry should not be used.\n-   *\n-   * @param entry - the entry to put back\n-   *\/\n-  public void putSegmentEntry(Entry<MemorySegment> entry) {\n-    \/\/ The size already should be aligned, in case of putting wrong entry queue will\n-    \/\/ throw exception\n-    final var bitBound = 64 - Long.numberOfLeadingZeros(entry.value.byteSize()) - 1;\n-\n-    final var segmentsQueue = segmentsDequeue[bitBound];\n-    if (!segmentsQueue.putEntryIfSize(entry, maxSizes[bitBound])) {\n-      if (segmentsQueue.isAssociated(entry)) {\n-        CLinker.freeMemory(entry.value.address());\n-      } else {\n-        \/\/ Queue checks for ownership only during add, someone can accidentally release not intended\n-        \/\/ segment.\n-        throw new IllegalStateException(\"This entry is not associated with given queue and this pool\");\n-      }\n-    }\n+    resourceScope.addOnClose(() -> segmentEntry.close());\n+    return segmentEntry.memorySegment;\n@@ -178,0 +158,1 @@\n+  @ForceInline\n@@ -184,2 +165,1 @@\n-  private Entry<MemorySegment> allocateNewEntry(SpinLockQueue<MemorySegment> queue, int bitBound) {\n-    final var allocationSize = 1 << bitBound;\n+  private MemoryPoolSegment allocateNewEntry(SpinLockQueue<MemoryPoolSegment> queue, long allocationSize) {\n@@ -187,1 +167,2 @@\n-    return queue.allocateEntry(memoryAddress.asSegment(allocationSize, scope));\n+    return new MemoryPoolSegment(queue,\n+        (NativeMemorySegmentImpl) memoryAddress.asSegment(allocationSize, scope));\n@@ -190,2 +171,2 @@\n-  private void validateMaxSizes() {\n-    Arrays.stream(this.maxSizes).filter(i -> i < 0).findAny()\n+  private static void validateMaxSizes(int maxSizes[]) {\n+    Arrays.stream(maxSizes).filter(i -> i < 0).findAny()\n@@ -196,0 +177,24 @@\n+\n+  public static class MemoryPoolSegment extends SpinLockQueue.Entry<MemoryPoolSegment> implements AutoCloseable {\n+    private final NativeMemorySegmentImpl memorySegment;\n+\n+    @ForceInline\n+    private MemoryPoolSegment(SpinLockQueue<MemoryPoolSegment> queue, NativeMemorySegmentImpl segment) {\n+      super(queue);\n+      this.memorySegment = segment;\n+    }\n+\n+    @ForceInline\n+    public MemorySegment memorySegment() {\n+      return memorySegment;\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void close() {\n+      if (!this.owner.putEntry(this)) {\n+        CLinker.freeMemory(this.memorySegment.address());\n+      }\n+    }\n+  }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":44,"deletions":39,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -4,0 +6,2 @@\n+import jdk.incubator.foreign.SpinLockQueue.Entry;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -13,1 +17,4 @@\n-public final class SpinLockQueue<T> {\n+public final class SpinLockQueue<T extends Entry<T>> {\n+\n+  private int lock = 0;\n+  private final int maxSize;\n@@ -15,1 +22,0 @@\n-  private final AtomicInteger lock = new AtomicInteger();\n@@ -18,1 +24,5 @@\n-  private volatile Entry<T> head;\n+  private T head;\n+\n+  private static final VarHandle HEAD;\n+  private static final VarHandle SIZE;\n+  private static final VarHandle LOCK;\n@@ -20,1 +30,9 @@\n-  public SpinLockQueue() {\n+  static {\n+    try {\n+      HEAD = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"head\", Entry.class);\n+      SIZE = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"size\", int.class);\n+      LOCK = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"lock\", int.class);\n+    } catch (Exception e) {\n+      throw new ExceptionInInitializerError(e);\n+    }\n+  }\n@@ -22,0 +40,2 @@\n+  public SpinLockQueue(int maxSize) {\n+    this.maxSize = maxSize;\n@@ -24,2 +44,3 @@\n-  public Entry<T> pollEntry() {\n-    while (!lock.compareAndSet(0, 1)) { }\n+  @ForceInline\n+  final public T pollEntry() {\n+    while ((int) LOCK.compareAndExchange(this, 0, 1) != 1) { }\n@@ -27,1 +48,1 @@\n-      final var current = head;\n+      final var current = (T) HEAD.getAcquire(this);\n@@ -29,2 +50,2 @@\n-        head = current.next;\n-        size--;\n+        HEAD.setRelease(this, current.next);\n+        SIZE.setRelease(this, (int) SIZE.getAcquire(this) - 1);\n@@ -34,1 +55,1 @@\n-      lock.set(0);\n+      LOCK.setRelease(this, 0);\n@@ -38,13 +59,10 @@\n-  public void putEntry(Entry<T> entry) {\n-    if (entry.owner != this) {\n-      throw new IllegalStateException(\"This entry does not belong to this queue\");\n-    }\n-    while (!lock.compareAndSet(0, 1)) { }\n-    try {\n-      entry.next = head;\n-      head = entry;\n-      size++;\n-    } finally {\n-      lock.set(0);\n-    }\n-  }\n+\/\/  final public void putEntryNoSizeCheck(T entry) {\n+\/\/    while (!lock.compareAndSet(0, 1)) { }\n+\/\/    try {\n+\/\/      entry.next = head;\n+\/\/      head = entry;\n+\/\/      size++;\n+\/\/    } finally {\n+\/\/      lock.set(0);\n+\/\/    }\n+\/\/  }\n@@ -56,1 +74,0 @@\n-   * @param size - the maximum expected queue size\n@@ -60,5 +77,3 @@\n-  public boolean putEntryIfSize(Entry<T> entry, long size) {\n-    if (entry.owner != this) {\n-      throw new IllegalStateException(\"This entry does not belong to this queue\");\n-    }\n-    while (!lock.compareAndSet(0, 1)) { }\n+  @ForceInline\n+  final public boolean putEntry(T entry) {\n+    while ((int) LOCK.compareAndExchangeAcquire(this, 0, 1) != 1) { }\n@@ -66,4 +81,5 @@\n-      if (this.size <= size) {\n-        entry.next = head;\n-        head = entry;\n-        size++;\n+      final var size = (int) SIZE.getAcquire(this);\n+      if (size <= this.maxSize) {\n+        entry.next = (T) HEAD.getAcquire(this);\n+        HEAD.setRelease(this, entry);\n+        SIZE.setRelease(this, size + 1);\n@@ -75,1 +91,1 @@\n-      lock.set(0);\n+      LOCK.setRelease(this, 0);\n@@ -98,12 +114,6 @@\n-  \/**\n-   * Allocates, but not adds entry to the queue.\n-   *\/\n-  public Entry<T> allocateEntry(T value) {\n-    return new Entry<T>(this, value);\n-  }\n-\n-  public static class Entry<T> {\n-    public final T value;\n-\n-    private final SpinLockQueue<T> owner;\n-    private volatile Entry<T> next;\n+  public static class Entry<T extends Entry<T>> {\n+    \/\/ Should we keep generic\n+    \/\/ If exposing spinlock queue, the entry should be in module internal package, to prevent\n+    \/\/ tampering owner and next with reflect\n+    final SpinLockQueue<T> owner;\n+    volatile T next;\n@@ -111,1 +121,1 @@\n-    private Entry(SpinLockQueue<T> owner, T value) {\n+    protected Entry(SpinLockQueue<T> owner) {\n@@ -113,1 +123,0 @@\n-      this.value = value;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":57,"deletions":48,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -162,0 +163,1 @@\n+\/\/    @CompilerControl(CompilerControl.Mode.PRINT)\n@@ -163,1 +165,1 @@\n-        final var memoryPool = this.memorySegmentPool;\n+        final var memoryPool = memorySegmentPool;\n@@ -166,7 +168,4 @@\n-        final var stringSegmentEntry = memoryPool.getSegmentEntryBySize(len + 1, 1);\n-        final var stringSegment = stringSegmentEntry.value;\n-        stringSegment.copyFrom(MemorySegment.ofArray(bytes));\n-        try {\n-            return (int) STRLEN.invokeExact(CLinker.toCString(str, segmentAllocator).address());\n-        } finally {\n-            memoryPool.putSegmentEntry(stringSegmentEntry);\n+        try (var stringSegmentEntry = memoryPool.getSegmentEntryBySize(len + 1, 1)) {\n+            final var stringSegment = stringSegmentEntry.memorySegment();\n+            stringSegment.copyFrom(MemorySegment.ofArray(bytes));\n+            return (int) STRLEN.invokeExact(stringSegment.address());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"}]}