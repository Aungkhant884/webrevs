{"files":[{"patch":"@@ -3,2 +3,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -174,1 +172,7 @@\n-    resourceScope.addCloseAction(() -> scope.release(handle));\n+\/\/    resourceScope.addCloseAction(() -> scope.release(handle));\n+    ((ResourceScopeImpl) resourceScope).addOrCleanupIfFail(new ResourceCleanup() {\n+      @Override\n+      public void cleanup() {\n+        scope.release(handle);\n+      }\n+    });\n@@ -183,22 +187,0 @@\n-  @ForceInline\n-  public MemoryPoolItem getSegmentEntryByLayout(MemoryLayout layout) {\n-    return getSegmentEntryBySize(layout.byteSize(), layout.byteAlignment());\n-  }\n-\n-  \/**\n-   * Gets segment from pool or allocates new one. Internally segments are cached.\n-   * The size of segment can be larger than requested.\n-   *\n-   * @param bytesSize the size of segment.\n-   *\n-   * @return segment of size at least `size`\n-   *\/\n-  @DontInline\n-  public MemoryPoolItem getSegmentEntryBySize(long bytesSize, long bytesAlignment) {\n-    \/\/ Don't check scope aliveness here.\n-    final var bitBound = calculateBucket(alignSize(bytesSize, bytesAlignment));\n-    MemoryPoolItem segment = findOrAllocateItem(bitBound);\n-\n-    return segment;\n-  }\n-\n@@ -266,7 +248,0 @@\n-  \/**\n-   * Free all elements associated with pool. Called when pool's scope gets closed.\n-   *\/\n-  private void freePool() {\n-\n-  }\n-\n@@ -297,13 +272,0 @@\n-    \/** Flag indicating if item has been released. *\/\n-    private volatile boolean released;\n-\n-    private final static VarHandle RELEASED;\n-\n-    static {\n-      try {\n-        RELEASED = MethodHandles.lookup().findVarHandle(MemoryPoolItem.class, \"released\", boolean.class);\n-      } catch (Exception e) {\n-        throw new ExceptionInInitializerError(e);\n-      }\n-    }\n-\n@@ -315,7 +277,0 @@\n-\n-      ((ResourceScopeImpl) scope).addOrCleanupIfFail(new ResourceCleanup() {\n-        @Override\n-        public void cleanup() {\n-          release();\n-        }\n-      });\n@@ -346,1 +301,2 @@\n-      if (RELEASED.compareAndSet(this, false, true)) {\n+      \/\/ Can be called only once, from close\n+\/\/      if (RELEASED.compareAndSet(this, false, true)) {\n@@ -349,1 +305,1 @@\n-      }\n+\/\/      }\n@@ -369,2 +325,5 @@\n-        \/\/ Entries are released using cleaner attached to pool's scope\n-        queuesToClean[i].retrieveAndLock();\n+        @SuppressWarnings(\"unchecked\")\n+        final var iterator = ((SpinLockQueue<MemoryPoolItem>) queuesToClean[i]).retrieveAndLock();\n+        while (iterator.hasNext()) {\n+          iterator.next().close();\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":15,"deletions":56,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-  private volatile int size;\n+  private int size;\n@@ -24,1 +24,1 @@\n-  private volatile T head;\n+  private T head;\n@@ -67,1 +67,2 @@\n-      final var current = (T) HEAD.get(this);\n+      final var current = head;\n+      final var currentTyped = (Entry<T>) current; \/\/ Just to get access to private fields\n@@ -69,3 +70,3 @@\n-        HEAD.set(this, ENTRY_NEXT.get(current));\n-        SIZE.set(this, (int) SIZE.get(this) - 1);\n-        ENTRY_IN_POOL.set(current, false);\n+        head = currentTyped.next;\n+        currentTyped.inPool = false;\n+        size--;\n@@ -93,1 +94,2 @@\n-      final var size = (int) SIZE.get(this);\n+      final var entryTyped = (Entry<T>) entry; \/\/ Like in c\n+      final var size = this.size;\n@@ -95,1 +97,1 @@\n-      if ((boolean) ENTRY_IN_POOL.get(entry)) {\n+      if (entryTyped.inPool) {\n@@ -100,5 +102,4 @@\n-        ENTRY_IN_POOL.set(entry, true);\n-\n-        ENTRY_NEXT.set(entry, HEAD.get(this));\n-        HEAD.set(this, entry);\n-        SIZE.set(this, size + 1);\n+        entryTyped.inPool = true;\n+        entryTyped.next = head;\n+        head = entry;\n+        this.size++;\n@@ -153,2 +154,2 @@\n-    private volatile T next;\n-    private volatile boolean inPool;\n+    private T next;\n+    private boolean inPool;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-      pool.getSegmentEntryBySize(1L << j, 1).close();\n+\/\/      pool.getSegmentEntryBySize(1L << j, 1).close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-            return (int)STRLEN.invokeExact(CLinker.toCString(str, allocator).address());\n+            return (int)STRLEN.invokeExact(segment.address());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}