{"files":[{"patch":"@@ -3,0 +3,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -4,1 +6,2 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.ResourceScopeImpl.ResourceList.ResourceCleanup;\n@@ -34,2 +37,10 @@\n- * In order to mitigate overhead related to managing segments by the {@link @ResourceScope} high\n- * performant applications can use fast entry methods.\n+ * In order to mitigate overhead related to managing segments by the {@link @ResourceScope} and\n+ * {@link SegmentAllocator} high performant applications can use fast entry methods. The\n+ * caller can get, directly, entry which contains memory segment bound to pool's scope. Entry should\n+ * be returned to pool witch\n+ * <pre>\n+ *   try (final var entry = memoryPool.getSegmentEntryBySize(len, 8)) {\n+ *     final var segment = entry.memorySegment();\n+ *     \/\/ do something with segment\n+ *   }\n+ * <\/pre>\n@@ -48,1 +59,1 @@\n- * Segments are kept in buckets of size log(2^n). For each bucket the maximum number of elements\n+ * Segments are kept in buckets of size 2^n. For each bucket the maximum number of elements\n@@ -59,3 +70,2 @@\n- * In such a case segment entry is put back, otherwise it is deallocated. This check is not atomic\n- * with put (due to performance reasons), however low probable queue finally can contain\n- * more elements than max.\n+ * In such a case segment entry is put back, otherwise it is deallocated. This check is may not\n+ * be atomic with put.\n@@ -71,1 +81,1 @@\n-  private static final int[] DEFAULT_MAX_SIZES = new int[Long.SIZE];\n+  private static final int[] DEFAULT_MAX_SIZES = new int[Long.SIZE + 1];\n@@ -74,0 +84,3 @@\n+  \/**\n+   * Last element to hold 0 size and negative sizes (fallback)\n+   *\/\n@@ -75,1 +88,1 @@\n-  private final SpinLockQueue<MemoryPoolSegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE];\n+  private final SpinLockQueue<MemoryPoolSegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE + 1];\n@@ -83,0 +96,1 @@\n+    \/\/ Up to 1kb\n@@ -105,0 +119,10 @@\n+\n+  \/**\n+   * Constructs new pool with specified maximum number of elements per bucket.\n+   *\n+   * There's {@link Long#SIZE} + 1 buckets, while last bucket is not used,\n+   * as allocations with size 0 or with highest bit set to 1 goes there.\n+   *\n+   * @param maxSizes the array of maximum sizes per segment bucket\n+   * @param scope the scope to which this allocator should be bound\n+   *\/\n@@ -110,1 +134,2 @@\n-      segmentsDequeue[i] = new SpinLockQueue<>(maxSizes[i]);\n+      var segmentsBucketMaxSize = i < maxSizes.length ? maxSizes[i] : 0;\n+      segmentsDequeue[i] = new SpinLockQueue<>(segmentsBucketMaxSize);\n@@ -112,0 +137,2 @@\n+\n+    scope.addOnClose(this::freePool);\n@@ -118,1 +145,1 @@\n-    return (bytesSize, bytesAlignment) -> getSegmentForScope(resourceScope, bytesSize, bytesAlignment);\n+    return (bytesSize, bytesAlignment) -> getAsNewSegmentWithScope(resourceScope, bytesSize, bytesAlignment);\n@@ -121,0 +148,1 @@\n+  @ForceInline\n@@ -133,1 +161,1 @@\n-  @ForceInline\n+\/\/  @ForceInline\n@@ -135,3 +163,3 @@\n-    if (!scope.isAlive()) {\n-      throw new IllegalStateException(\"Associated resource scope is closed\");\n-    }\n+\/\/    if (!scope.isAlive()) {\n+\/\/      throw new IllegalStateException(\"Associated resource scope is closed\");\n+\/\/    }\n@@ -139,2 +167,8 @@\n-    final var alignedSize = (size + alignment - 1) & -alignment;\n-    final var bitBound = bitBound(alignedSize);\n+    final var bitBound = bitBound(size, alignment);\n+    MemoryPoolSegment segment = getMemoryPoolSegment(bitBound);\n+\n+    return segment;\n+  }\n+\n+  @ForceInline\n+  private MemoryPoolSegment getMemoryPoolSegment(int bitBound) {\n@@ -147,0 +181,2 @@\n+\/\/      segment.memorySegment = (NativeMemorySegmentImpl) segment.memoryAddress.asSegment(bitBoundedSize, scope);\n+\/\/      segment.size = bitBoundedSize;\n@@ -148,1 +184,0 @@\n-\n@@ -152,4 +187,13 @@\n-  private MemorySegment getSegmentForScope(ResourceScope resourceScope, long size, long alignment) {\n-    final var segmentEntry = getSegmentEntryBySize(size, alignment);\n-    resourceScope.addOnClose(() -> segmentEntry.close());\n-    return segmentEntry.memorySegment;\n+  @ForceInline\n+  private MemorySegment getAsNewSegmentWithScope(ResourceScope resourceScope, long size, long alignment) {\n+    final var bitBound = bitBound(size, alignment);\n+    final var segmentEntry = getMemoryPoolSegment(bitBound);\n+\n+    ((ResourceScopeImpl) resourceScope).addOrCleanupIfFail(new ResourceCleanup() {\n+      @Override\n+      public void cleanup() {\n+        segmentEntry.close();\n+      }\n+    });\n+\n+    return segmentEntry.memoryAddress.asSegment(1L << bitBound, resourceScope);\n@@ -158,0 +202,2 @@\n+\n+\n@@ -162,1 +208,5 @@\n-    return 64- Long.numberOfLeadingZeros(alignedSize - 1);\n+\n+    \/\/ 0 -> 64\n+    \/\/ This equation does not allow to allocate more than 2^63, however such memory may require\n+    \/\/ 5 level page cache, so skippable for now\n+    return 64 - Long.numberOfLeadingZeros(alignedSize - 1);\n@@ -165,0 +215,8 @@\n+  @ForceInline\n+  private static int bitBound(long size, long alignment) {\n+    final var alignedSize = (size + alignment - 1) & -alignment;\n+\n+    return bitBound(alignedSize);\n+  }\n+\n+  @ForceInline\n@@ -167,2 +225,13 @@\n-    return new MemoryPoolSegment(queue,\n-        (NativeMemorySegmentImpl) memoryAddress.asSegment(allocationSize, scope));\n+    return new MemoryPoolSegment(queue, memoryAddress, allocationSize, scope);\n+  }\n+\n+  \/**\n+   * Free all elements associated with pool\n+   *\/\n+  private void freePool() {\n+    \/\/ This method is called from pool's scope close method\n+    for (int i = 0; i < segmentsDequeue.length; i++) {\n+      \/\/ After calling this method maxSize is zero, and no new entries can be put back\n+      \/\/ Entries are released using cleaner attached to pool's scope\n+      segmentsDequeue[i].retrieveAndLock();\n+    }\n@@ -179,1 +248,6 @@\n-    private final NativeMemorySegmentImpl memorySegment;\n+    private final MemoryAddress memoryAddress;\n+    private final MemorySegment memorySegment;\n+    private volatile boolean released;\n+    long size;\n+\n+    private final static VarHandle RELEASED;\n@@ -181,0 +255,7 @@\n+    static {\n+      try {\n+        RELEASED = MethodHandles.lookup().findVarHandle(MemoryPoolSegment.class, \"released\", boolean.class);\n+      } catch (Exception e) {\n+        throw new ExceptionInInitializerError(e);\n+      }\n+    }\n@@ -182,1 +263,1 @@\n-    private MemoryPoolSegment(SpinLockQueue<MemoryPoolSegment> queue, NativeMemorySegmentImpl segment) {\n+    private MemoryPoolSegment(SpinLockQueue<MemoryPoolSegment> queue, MemoryAddress memoryAddress, long size, ResourceScope scope) {\n@@ -184,1 +265,9 @@\n-      this.memorySegment = segment;\n+      this.memoryAddress = memoryAddress;\n+      this.memorySegment = memoryAddress.asSegment(size, scope);\n+\n+      ((ResourceScopeImpl) scope).addOrCleanupIfFail(new ResourceCleanup() {\n+        @Override\n+        public void cleanup() {\n+          release();\n+        }\n+      });\n@@ -193,1 +282,1 @@\n-    @ForceInline\n+\/\/    @ForceInline\n@@ -196,1 +285,9 @@\n-        CLinker.freeMemory(this.memorySegment.address());\n+        this.release();\n+      }\n+    }\n+\n+    @ForceInline\n+    private void release() {\n+      if (RELEASED.compareAndSet(this, false, true)) {\n+        \/\/ Don't use segment here, if scope closed will produce exception\n+        CLinker.freeMemory(this.memoryAddress);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":127,"deletions":30,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.Iterator;\n@@ -13,1 +13,1 @@\n- * provided by spin lock.\n+ * provided by classic spin lock.\n@@ -20,1 +20,1 @@\n-  private final int maxSize;\n+  private int maxSize;\n@@ -24,1 +24,1 @@\n-  private T head;\n+  private volatile T head;\n@@ -82,1 +82,0 @@\n-\/\/    while ((int) LOCK.compareAndExchange(this, 0, 1) != 1) { }\n@@ -86,1 +85,1 @@\n-      if (size <= this.maxSize) {\n+      if (size < this.maxSize) {\n@@ -90,1 +89,0 @@\n-        LOCK.setRelease(this, 0);\n@@ -119,0 +117,19 @@\n+  \/**\n+   * Polls all entries and sets max size to 0 so no new entries can be added.\n+   * This operation is atomic.\n+   *\n+   * @return iterator will all entries, iterator is not synchronized, nor thread-safe\n+   *\/\n+  public Iterator<T> retrieveAndLock() {\n+    while (!LOCK.compareAndSet(this, 0, 1)) { }\n+    try {\n+      final var currentHead = (T) HEAD.getAcquire(this);\n+      final var result = new FastEntryIterator<T>(currentHead);\n+      SIZE.set(this, 0);\n+      HEAD.set(this, null);\n+      maxSize = 0;\n+      return result;\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n@@ -130,0 +147,23 @@\n+\n+  \/**\n+   * Goes through entries chain but don't use spinlock.\n+   *\/\n+  private static class FastEntryIterator<T extends Entry<T>> implements Iterator<T> {\n+    private T next;\n+\n+    public FastEntryIterator(T next) {\n+      this.next = next;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+      return next != null;\n+    }\n+\n+    @Override\n+    public T next() {\n+      var result = next;\n+      next = next.next;\n+      return result;\n+    }\n+  }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.LinkedList;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.MemorySegmentPool;\n+import jdk.incubator.foreign.MemorySegmentPool.MemoryPoolSegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Allocators performance tests for long running applications.\n+ *\n+ * Tries to simulate library which has to allocate number of different size elements.\n+ *\n+ * Ofc... thre are some cavets\n+ * - if pool of segments will be exhausted, pooled allocator will slow down\n+ * - arena allocator - for long running has to be freed at some point of time...\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class AllocatorsForLongRun {\n+  private static final long[] sizes;\n+\n+  private static final VarHandle BYTE = MemoryHandles.varHandle(byte.class, 1, ByteOrder.nativeOrder());\n+\n+  static {\n+    final var rand = new Random(0L);\n+    final var passes = 1024;\n+    final var sizeClasses = 3;\n+    \/\/ Generate pseudo random sizes\n+    sizes = new long[passes * sizeClasses];\n+\n+    for (int i = 0; i < passes; i++) {\n+      sizes[sizeClasses * i + 0] = Math.max(1, (long) (rand.nextGaussian() * 24));\n+      sizes[sizeClasses * i + 1] = Math.max(1, (long) (rand.nextGaussian() * 128));\n+      sizes[sizeClasses * i + 2] = Math.max(1, (long) (rand.nextGaussian() * 4096));\n+\/\/      sizes[sizeClasses * i + 3] = Math.max(1, (long) (rand.nextGaussian() * 1024 * 16));\n+\/\/      sizes[sizeClasses * i + 4] = Math.max(1, (long) (rand.nextGaussian() * 1024 * 1024 * 2));\n+    }\n+  }\n+\n+  @Param({\"1\", \"16\", \"200\"})\n+  public int allocations;\n+\n+  private MemorySegmentPool pool = new MemorySegmentPool(ResourceScope.globalScope());\n+  private MemorySegmentPool poolEmpty = new MemorySegmentPool(new int[Long.SIZE], ResourceScope.globalScope());\n+\n+  @Setup\n+  public void setup() {\n+\n+  }\n+\n+  @Benchmark\n+  public void arena() {\n+    int i = 0;\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = SegmentAllocator.arenaAllocator(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final var segment = allocator.allocate(sizes[i]);\n+        readSegment(segment);\n+        i = next(i);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void pool_allocator() {\n+    int i = 0;\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = pool.allocatorForScope(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final var segment = allocator.allocate(sizes[i]);\n+        readSegment(segment);\n+        i = next(i);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void pool_allocator_exhausted() {\n+    int i = 0;\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = poolEmpty.allocatorForScope(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final var segment = allocator.allocate(sizes[i]);\n+        readSegment(segment);\n+        i = next(i);\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void pool_direct() {\n+    int i = 0;\n+    \/\/ If I would develop with direct segments I would do something like this\n+    LinkedList<MemoryPoolSegment> pooledSegments = new LinkedList<>();\n+    for (int j = 0; j < allocations; j++) {\n+      var s = pool.getSegmentEntryBySize(sizes[i], 1);\n+      pooledSegments.add(s);\n+      readSegment(s.memorySegment());\n+      i = next(i);\n+    }\n+    pooledSegments.forEach(MemoryPoolSegment::close);\n+  }\n+\n+  @Benchmark\n+  public void malloc_free() {\n+    int i = 0;\n+    \/\/ If I would develop with direct segments I would do something like this\n+    LinkedList<MemoryAddress> allocatedAddresses = new LinkedList<>();\n+    for (int j = 0; j < allocations; j++) {\n+      var size = sizes[i];\n+      var a = CLinker.allocateMemory(size);\n+      var s = a.asSegment(size, ResourceScope.globalScope());\n+      allocatedAddresses.add(a);\n+      readSegment(s);\n+      i = next(i);\n+    }\n+    allocatedAddresses.forEach(CLinker::freeMemory);\n+  }\n+\n+  \/**\n+   * Do read to avoid situation allocator will allocate not mapped memory.\n+   *\/\n+  private void readSegment(MemorySegment s) {\n+    final var size = s.byteSize();\n+    for (long l = 0; l <  size; l += 256) {\n+      BYTE.set(s, l, (byte) 1);\n+    }\n+  }\n+  private static int next(int i) {\n+    return ++i == sizes.length ? 0 : i;\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}