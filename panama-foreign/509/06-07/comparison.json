{"files":[{"patch":"@@ -5,1 +5,3 @@\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -48,0 +50,2 @@\n+  private static final int[] POOL_MAX_SIZE;\n+\n@@ -51,1 +55,7 @@\n-    final var sizeClasses = 3;\n+    final var sizeClasses = new int[] {\n+        24,\n+        128,\n+        4096,\n+        1024*16,\n+        1024 * 1024 * 2\n+    };\n@@ -53,1 +63,1 @@\n-    sizes = new long[passes * sizeClasses];\n+    sizes = new long[passes * sizeClasses.length];\n@@ -56,5 +66,3 @@\n-      sizes[sizeClasses * i + 0] = Math.max(1, (long) (rand.nextGaussian() * 24));\n-      sizes[sizeClasses * i + 1] = Math.max(1, (long) (rand.nextGaussian() * 128));\n-      sizes[sizeClasses * i + 2] = Math.max(1, (long) (rand.nextGaussian() * 4096));\n-\/\/      sizes[sizeClasses * i + 3] = Math.max(1, (long) (rand.nextGaussian() * 1024 * 16));\n-\/\/      sizes[sizeClasses * i + 4] = Math.max(1, (long) (rand.nextGaussian() * 1024 * 1024 * 2));\n+      for (int j=0; j < sizeClasses.length; j++) {\n+        sizes[sizeClasses.length * i + j] = Math.max(1, (long) ((rand.nextGaussian() + 1.0) * sizeClasses[j]));\n+      }\n@@ -62,0 +70,4 @@\n+\n+    POOL_MAX_SIZE = new int[Long.SIZE + 1];\n+    \/\/ Use larger sizes for pool, so it will not get exhausted\n+    Arrays.fill(POOL_MAX_SIZE, 256);\n@@ -67,1 +79,1 @@\n-  private MemorySegmentPool pool = new MemorySegmentPool(ResourceScope.globalScope());\n+  private MemorySegmentPool pool = new MemorySegmentPool(POOL_MAX_SIZE, ResourceScope.globalScope());\n@@ -70,0 +82,1 @@\n+  private int i;\n@@ -72,1 +85,5 @@\n-\n+    i = 0;\n+    \/\/ Preallocate pool\n+    for (int j = 0; j <= 24; j++) {\n+      pool.getSegmentEntryBySize(1L << j, 1).close();\n+    }\n@@ -77,1 +94,0 @@\n-    int i = 0;\n@@ -83,1 +99,1 @@\n-        i = next(i);\n+        next();\n@@ -90,1 +106,0 @@\n-    int i = 0;\n@@ -96,1 +111,1 @@\n-        i = next(i);\n+        next();\n@@ -103,1 +118,0 @@\n-    int i = 0;\n@@ -109,1 +123,1 @@\n-        i = next(i);\n+        next();\n@@ -115,0 +129,1 @@\n+\/\/  @CompilerControl(CompilerControl.Mode.PRINT)\n@@ -116,3 +131,1 @@\n-    int i = 0;\n-    \/\/ If I would develop with direct segments I would do something like this\n-    LinkedList<MemoryPoolSegment> pooledSegments = new LinkedList<>();\n+    List<MemoryPoolSegment> pooledSegments = new ArrayList<>(allocations);\n@@ -123,1 +136,1 @@\n-      i = next(i);\n+      next();\n@@ -127,1 +140,0 @@\n-\n@@ -129,0 +141,1 @@\n+\/\/  @CompilerControl(CompilerControl.Mode.PRINT)\n@@ -130,3 +143,1 @@\n-    int i = 0;\n-    \/\/ If I would develop with direct segments I would do something like this\n-    LinkedList<MemoryAddress> allocatedAddresses = new LinkedList<>();\n+    List<MemoryAddress> allocatedAddresses = new ArrayList<>(allocations);\n@@ -139,1 +150,1 @@\n-      i = next(i);\n+      next();\n@@ -148,3 +159,4 @@\n-    final var size = s.byteSize();\n-    for (long l = 0; l <  size; l += 256) {\n-      BYTE.set(s, l, (byte) 1);\n+    final var size = (int) s.byteSize();\n+    for (int idx = 0; idx <  size; idx += 1024) {\n+\/\/      MemoryAccess.setByteAtOffset(s, l, (byte)0);\n+      BYTE.set(s, 0, (byte) 1);\n@@ -153,2 +165,3 @@\n-  private static int next(int i) {\n-    return ++i == sizes.length ? 0 : i;\n+\n+  private void next() {\n+    i = (++i == sizes.length ? 0 : i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":43,"deletions":30,"binary":false,"changes":73,"status":"modified"}]}