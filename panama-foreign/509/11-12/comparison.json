{"files":[{"patch":"@@ -91,0 +91,6 @@\n+  \/**\n+   * Indicates if {@link #scope} should be acquired by the pool, with every allocator, or it's\n+   * managed externally.\n+   *\/\n+  private final boolean manageScopeAcquire;\n+\n@@ -115,2 +121,7 @@\n-  public MemorySegmentPool(ResourceScope scope) {\n-    this(DEFAULT_MAX_SIZES, scope);\n+  \/**\n+   *\n+   * @param scope\n+   * @param manageScopeAcquire if the `scope` should be acquired with every allocator\n+   *\/\n+  public MemorySegmentPool(ResourceScope scope, boolean manageScopeAcquire) {\n+    this(DEFAULT_MAX_SIZES, scope, manageScopeAcquire);\n@@ -125,0 +136,8 @@\n+   * <br \/>\n+   * If the parameter manageScopeAcquire is set to true, than the pool will acquire scope\n+   * with every allocator created (@link {@link #allocatorForScope(ResourceScope)}, and preventing\n+   * scope to be closed during.\n+   * <br \/>\n+   * If this value is set to `false`, than it's caller responsibility to manage scope lifetime\n+   * as long as queue is used, however the pool can be slightly more performant.\n+   *\n@@ -127,0 +146,1 @@\n+   * @param manageScopeAcquire if the `scope` should be acquired with every allocator\n@@ -128,1 +148,1 @@\n-  public MemorySegmentPool(int maxSizes[], ResourceScope scope) {\n+  public MemorySegmentPool(int maxSizes[], ResourceScope scope, boolean manageScopeAcquire) {\n@@ -138,0 +158,1 @@\n+    this.manageScopeAcquire = manageScopeAcquire;\n@@ -170,9 +191,12 @@\n-    \/\/ Prevent scope managing this pool to go away, when dependant allocator is alive\n-    final var handle = scope.acquire();\n-\/\/    resourceScope.addCloseAction(() -> scope.release(handle));\n-    ((ResourceScopeImpl) resourceScope).addOrCleanupIfFail(new ResourceCleanup() {\n-      @Override\n-      public void cleanup() {\n-        scope.release(handle);\n-      }\n-    });\n+    if (this.manageScopeAcquire) {\n+      \/\/ Prevent scope managing this pool to go away, when dependant allocator is alive\n+      final var handle = scope.acquire();\n+      \/\/    resourceScope.addCloseAction(() -> scope.release(handle));\n+      ((ResourceScopeImpl) resourceScope).addOrCleanupIfFail(new ResourceCleanup() {\n+        @Override\n+        public void cleanup() {\n+          scope.release(handle);\n+        }\n+      });\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":36,"deletions":12,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-  private static final MemorySegmentPool pool = new MemorySegmentPool(POOL_MAX_SIZE, ResourceScope.globalScope());\n-  private MemorySegmentPool poolEmpty = new MemorySegmentPool(new int[Long.SIZE], ResourceScope.globalScope());\n+  private static MemorySegmentPool pool = new MemorySegmentPool(POOL_MAX_SIZE, ResourceScope.globalScope(), false);\n+  private MemorySegmentPool poolEmpty = new MemorySegmentPool(new int[Long.SIZE], ResourceScope.globalScope(), false);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    MemorySegmentPool memorySegmentPool = new MemorySegmentPool(ResourceScope.globalScope());\n+    MemorySegmentPool memorySegmentPool = new MemorySegmentPool(ResourceScope.globalScope(), false);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}