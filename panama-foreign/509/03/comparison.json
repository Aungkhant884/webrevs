{"files":[{"patch":"@@ -0,0 +1,196 @@\n+package jdk.incubator.foreign;\n+\n+import java.util.Arrays;\n+import jdk.incubator.foreign.SpinLockQueue.Entry;\n+\n+\/**\n+ * Memory segments pool, maintaining pools of segments of size equal to power of 2 with ability to\n+ * expose {@link SegmentAllocator}.\n+ *\n+ * <h1>Overview<\/h1>\n+ * <br \/>\n+ * This pool can be used by long running & highly performant code which requires frequent allocations\n+ * of memory segments (typically having small size) to communicate with native API.\n+ * <br \/>\n+ * An example, can be I\/O layer which use temporary buffers for read and write.\n+ *\n+ * <h1>Segment allocators<\/h1>\n+ * This pool can provide segment allocator which can be backed by pool. All allocations\n+ * will be directed to the pool, and on {@link ResourceScope} close, the allocated segments\n+ * will be put back to pool.\n+ * <br \/>\n+ * Please note: depending on resource scope close strategy there can be a daley in putting\n+ * segments back to the pool.\n+ *\n+ * <h1>Fast entry API<\/h1>\n+ * <b>\n+ *   Note: this API is for advanced applications, as incorrect usage can lead to memory leaks,\n+ *   or memory corruption.\n+ * <\/b>\n+ *\n+ * <br \/>\n+ *\n+ * In order to mitigate overhead related to managing segments by the {@link @ResourceScope} high\n+ * performant applications can use fast entry methods.\n+ *\n+ * <h1>Memory allocation strategy<\/h1>\n+ * This pool allocates and manages set of segments of size being power of 2. If the request\n+ * is made for a segment of size S (size calculated with alignment bytes), than smallest segment\n+ * meeting both constraints is returned.\n+ *\n+ * <br \/>\n+ *\n+ * The pool manages segments in LIFO order, to increase page table, cache hits.\n+ *\n+ * <br \/>\n+ *\n+ * Segments are kept in buckets of size log(2^n). For each bucket the maximum number of elements\n+ * can be set.\n+ *\n+ * <br \/>\n+ *\n+ * When the pool can't provide segment from bucket the new segment is created, there's no upper\n+ * bound.\n+ *\n+ * <br \/>\n+ *\n+ * When the segment is returned back to pool, pool checks if the bucket size is less than maximum.\n+ * In such a case segment entry is put back, otherwise it is deallocated. This check is not atomic\n+ * with put (due to performance reasons), however low probable queue finally can contain\n+ * more elements than max.\n+ *\n+ * <br \/>\n+ * Please note: that this pool can allocate segments of larger size than requested\n+ * (almost 2x as requested), if for small it can be ok, than for larger segments it can be\n+ * risky. I. e. request for segment for 1MB (2^20), will result in segment of 1MB, however requesting for\n+ * segment of size 1MB + 1(2^20 + 1), will result in segment of size 2^21). However in case of\n+ * 1GB + 1, pool will allocate 2GB of memory.\n+ *\/\n+public class MemorySegmentPool {\n+  private static final int[] DEFAULT_MAX_SIZES = new int[Long.SIZE];\n+\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  private final SpinLockQueue<MemorySegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE];\n+  private final int maxSizes[] = new int[Long.SIZE];\n+\n+  private final ResourceScope scope;\n+\n+  static {\n+    int idx = 0;\n+    int cores = Runtime.getRuntime().availableProcessors();\n+\n+    for (; idx <= 10; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = 256;\n+    }\n+\n+    \/\/ Sizes up to 64kb\n+    for (; idx <= 16; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores * 4;\n+    }\n+\n+    \/\/ Sizes up to 1MB {\n+    for (; idx <= 20; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores;\n+    }\n+\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 2); \/\/2mb\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 1); \/\/4mb\n+    \/\/ Rest 0\n+  }\n+\n+  public MemorySegmentPool(ResourceScope scope) {\n+    this(DEFAULT_MAX_SIZES, scope);\n+  }\n+  public MemorySegmentPool(int maxSizes[], ResourceScope scope) {\n+    this.scope = scope;\n+\n+    for (int i=0; i < segmentsDequeue.length; i++) {\n+      segmentsDequeue[i] = new SpinLockQueue<>();\n+    }\n+    System.arraycopy(maxSizes, 0, this.maxSizes, 0, Math.min(maxSizes.length, this.maxSizes.length));\n+    validateMaxSizes();\n+  }\n+\n+  public SegmentAllocator allocatorForScope(ResourceScope resourceScope) {\n+    \/\/ Prevent scope managing this pool to go away, when dependant allocator is alive\n+    final var handle = scope.acquire();\n+    resourceScope.addOnClose(handle::close);\n+    return (bytesSize, bytesAlignment) -> getSegmentForScope(resourceScope, bytesSize, bytesAlignment);\n+  }\n+\n+  public Entry<MemorySegment> getSegmentEntryByLayout(MemoryLayout layout) {\n+    return getSegmentEntryBySize(layout.byteSize(), layout.byteAlignment());\n+  }\n+\n+  \/**\n+   * Gets segment from pool or allocates new one. Internally segments are cached.\n+   * The size of segment can be larger than requested.\n+   *\n+   * @param size the size of segment.\n+   *\n+   * @return segment of size at least `size`\n+   *\/\n+  public Entry<MemorySegment> getSegmentEntryBySize(long size, long alignment) {\n+    if (!scope.isAlive()) {\n+      throw new IllegalStateException(\"Associated resource scope is closed\");\n+    }\n+\n+    final var alignedSize = (size + alignment - 1) & -alignment;\n+    final var bitBound = bitBound(alignedSize);\n+\n+    final var segmentDequeue = segmentsDequeue[bitBound];\n+    var segment = segmentDequeue.pollEntry();\n+    if (segment == null) {\n+      segment = allocateNewEntry(segmentDequeue, bitBound);\n+    }\n+\n+    return segment;\n+  }\n+\n+  private MemorySegment getSegmentForScope(ResourceScope resourceScope, long size, long alignment) {\n+    final var segmentEntry = getSegmentEntryBySize(size, alignment);\n+    resourceScope.addOnClose(() -> putSegmentEntry(segmentEntry));\n+    return segmentEntry.value;\n+  }\n+\n+  \/**\n+   * Returns entry back to pool. After this operation entry should not be used.\n+   *\n+   * @param entry - the entry to put back\n+   *\/\n+  public void putSegmentEntry(Entry<MemorySegment> entry) {\n+    \/\/ The size already should be aligned, in case of putting wrong entry queue will\n+    \/\/ throw exception\n+    final var bitBound = 64 - Long.numberOfLeadingZeros(entry.value.byteSize()) - 1;\n+\n+    final var segmentsQueue = segmentsDequeue[bitBound];\n+    if (!segmentsQueue.putEntryIfSize(entry, maxSizes[bitBound])) {\n+      if (segmentsQueue.isAssociated(entry)) {\n+        CLinker.freeMemory(entry.value.address());\n+      } else {\n+        \/\/ Queue checks for ownership only during add, someone can accidentally release not intended\n+        \/\/ segment.\n+        throw new IllegalStateException(\"This entry is not associated with given queue and this pool\");\n+      }\n+    }\n+  }\n+\n+  private static int bitBound(long alignedSize) {\n+    \/\/ If 100.., than 100... - 1 -> 01111\n+    \/\/ If 101 -> than 101 - 1 -> 1....\n+    return 64- Long.numberOfLeadingZeros(alignedSize - 1);\n+  }\n+\n+  private Entry<MemorySegment> allocateNewEntry(SpinLockQueue<MemorySegment> queue, int bitBound) {\n+    final var allocationSize = 1 << bitBound;\n+    final var memoryAddress = CLinker.allocateMemory(allocationSize);\n+    return queue.allocateEntry(memoryAddress.asSegment(allocationSize, scope));\n+  }\n+\n+  private void validateMaxSizes() {\n+    Arrays.stream(this.maxSizes).filter(i -> i < 0).findAny()\n+        .ifPresent(i -> {\n+          throw new IllegalStateException(\"Invalid max size \" + i);\n+        });\n+  }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+package jdk.incubator.foreign;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/**\n+ * Fast, concurrent LIFO queue (stack), based on operating on entries.\n+ *\n+ * This queue is designed for fast push \/ pop operations. Synchronization is\n+ * provided by spin lock.\n+ *\n+ * @param <T> the type of value used in queue\n+ *\/\n+public final class SpinLockQueue<T> {\n+\n+  private final AtomicInteger lock = new AtomicInteger();\n+  private volatile int size;\n+\n+  private volatile Entry<T> head;\n+\n+  public SpinLockQueue() {\n+\n+  }\n+\n+  public Entry<T> pollEntry() {\n+    while (!lock.compareAndSet(0, 1)) { }\n+    try {\n+      final var current = head;\n+      if (current != null) {\n+        head = current.next;\n+        size--;\n+      }\n+      return current;\n+    } finally {\n+      lock.set(0);\n+    }\n+  }\n+\n+  public void putEntry(Entry<T> entry) {\n+    if (entry.owner != this) {\n+      throw new IllegalStateException(\"This entry does not belong to this queue\");\n+    }\n+    while (!lock.compareAndSet(0, 1)) { }\n+    try {\n+      entry.next = head;\n+      head = entry;\n+      size++;\n+    } finally {\n+      lock.set(0);\n+    }\n+  }\n+\n+  \/**\n+   * Puts entry only if queue size is less then given size.\n+   *\n+   * @param entry - entry to put\n+   * @param size - the maximum expected queue size\n+   *\n+   * @return {@code true} if elements has been put.\n+   *\/\n+  public boolean putEntryIfSize(Entry<T> entry, long size) {\n+    if (entry.owner != this) {\n+      throw new IllegalStateException(\"This entry does not belong to this queue\");\n+    }\n+    while (!lock.compareAndSet(0, 1)) { }\n+    try {\n+      if (this.size <= size) {\n+        entry.next = head;\n+        head = entry;\n+        size++;\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    } finally {\n+      lock.set(0);\n+    }\n+  }\n+\n+  \/**\n+   * Checks if entry is associated with this queue.\n+   *\n+   * @param entry entry to check\n+   * @return {@code true} if this entry is associated with this queue if it's not in it\n+   *\/\n+  public boolean isAssociated(Entry<T> entry) {\n+    return entry.owner == this;\n+  }\n+\n+  \/**\n+   * Returns number of elements in the queue. This method is not atomic.\n+   *\n+   * @return number of elements in queue\n+   *\/\n+  public long size() {\n+    return this.size;\n+  }\n+\n+  \/**\n+   * Allocates, but not adds entry to the queue.\n+   *\/\n+  public Entry<T> allocateEntry(T value) {\n+    return new Entry<T>(this, value);\n+  }\n+\n+  public static class Entry<T> {\n+    public final T value;\n+\n+    private final SpinLockQueue<T> owner;\n+    private volatile Entry<T> next;\n+\n+    private Entry(SpinLockQueue<T> owner, T value) {\n+      this.owner = owner;\n+      this.value = value;\n+    }\n+  }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -28,0 +28,7 @@\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +41,1 @@\n+import jdk.incubator.foreign.MemorySegmentPool;\n@@ -39,3 +47,0 @@\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.TearDown;\n@@ -45,0 +50,2 @@\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n@@ -46,0 +53,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -48,6 +56,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.CLinker.*;\n-\n@@ -59,1 +61,2 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\",\n+\"--enable-native-access\", \"ALL-UNNAMED\"})\n@@ -67,0 +70,2 @@\n+    MemorySegmentPool memorySegmentPool = new MemorySegmentPool(ResourceScope.globalScope());\n+\n@@ -148,0 +153,23 @@\n+    @Benchmark\n+    public int panama_strlen_memsegmentpool_allocator() throws Throwable {\n+        try(ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            final var allocator = memorySegmentPool.allocatorForScope(scope);\n+            return (int)STRLEN.invokeExact(CLinker.toCString(str, allocator).address());\n+        }\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_memsegmentpool_direct() throws Throwable {\n+        final var memoryPool = this.memorySegmentPool;\n+        final byte[] bytes = str.getBytes();\n+        final int len = bytes.length;\n+        final var stringSegmentEntry = memoryPool.getSegmentEntryBySize(len + 1, 1);\n+        final var stringSegment = stringSegmentEntry.value;\n+        stringSegment.copyFrom(MemorySegment.ofArray(bytes));\n+        try {\n+            return (int) STRLEN.invokeExact(CLinker.toCString(str, segmentAllocator).address());\n+        } finally {\n+            memoryPool.putSegmentEntry(stringSegmentEntry);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"}]}