{"files":[{"patch":"@@ -0,0 +1,298 @@\n+package jdk.incubator.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.Arrays;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.ResourceScopeImpl.ResourceList.ResourceCleanup;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Memory segments pool, maintaining pools of segments of size equal to power of 2 with ability to\n+ * expose {@link SegmentAllocator}.\n+ *\n+ * <h1>Overview<\/h1>\n+ * <br \/>\n+ * This pool can be used by long running & highly performant code which requires frequent allocations\n+ * of memory segments (typically having small size) to communicate with native API.\n+ * <br \/>\n+ * An example, can be I\/O layer which use temporary buffers for read and write.\n+ *\n+ * <h1>Segment allocators<\/h1>\n+ * This pool can provide segment allocator which can be backed by pool. All allocations\n+ * will be directed to the pool, and on {@link ResourceScope} close, the allocated segments\n+ * will be put back to pool.\n+ * <br \/>\n+ * Please note: depending on resource scope close strategy there can be a daley in putting\n+ * segments back to the pool.\n+ *\n+ * <h1>Fast entry API<\/h1>\n+ * <b>\n+ *   Note: this API is for advanced applications, as incorrect usage can lead to memory leaks,\n+ *   or memory corruption.\n+ * <\/b>\n+ *\n+ * <br \/>\n+ *\n+ * In order to mitigate overhead related to managing segments by the {@link @ResourceScope} and\n+ * {@link SegmentAllocator} high performant applications can use fast entry methods. The\n+ * caller can get, directly, entry which contains memory segment bound to pool's scope. Entry should\n+ * be returned to pool witch\n+ * <pre>\n+ *   try (final var entry = memoryPool.getSegmentEntryBySize(len, 8)) {\n+ *     final var segment = entry.memorySegment();\n+ *     \/\/ do something with segment\n+ *   }\n+ * <\/pre>\n+ *\n+ * <h1>Memory allocation strategy<\/h1>\n+ * This pool allocates and manages set of segments of size being power of 2. If the request\n+ * is made for a segment of size S (size calculated with alignment bytes), than smallest segment\n+ * meeting both constraints is returned.\n+ *\n+ * <br \/>\n+ *\n+ * The pool manages segments in LIFO order, to increase page table, cache hits.\n+ *\n+ * <br \/>\n+ *\n+ * Segments are kept in buckets of size 2^n. For each bucket the maximum number of elements\n+ * can be set.\n+ *\n+ * <br \/>\n+ *\n+ * When the pool can't provide segment from bucket the new segment is created, there's no upper\n+ * bound.\n+ *\n+ * <br \/>\n+ *\n+ * When the segment is returned back to pool, pool checks if the bucket size is less than maximum.\n+ * In such a case segment entry is put back, otherwise it is deallocated. This check is may not\n+ * be atomic with put.\n+ *\n+ * <br \/>\n+ * Please note: that this pool can allocate segments of larger size than requested\n+ * (almost 2x as requested), if for small it can be ok, than for larger segments it can be\n+ * risky. I. e. request for segment for 1MB (2^20), will result in segment of 1MB, however requesting for\n+ * segment of size 1MB + 1(2^20 + 1), will result in segment of size 2^21). However in case of\n+ * 1GB + 1, pool will allocate 2GB of memory.\n+ *\/\n+public class MemorySegmentPool {\n+  private static final int[] DEFAULT_MAX_SIZES = new int[Long.SIZE + 1];\n+  private static final ResourceScope GLOBAL = ResourceScope.globalScope();\n+\n+  \/**\n+   * Last element to hold 0 size and negative sizes (fallback)\n+   *\/\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  private final SpinLockQueue<MemoryPoolSegment> segmentsDequeue[] = new SpinLockQueue[Long.SIZE + 1];\n+\n+  private final ResourceScope scope;\n+\n+  static {\n+    int idx = 0;\n+    int cores = Runtime.getRuntime().availableProcessors();\n+\n+    \/\/ Up to 1kb\n+    for (; idx <= 10; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = 256;\n+    }\n+\n+    \/\/ Sizes up to 64kb\n+    for (; idx <= 16; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores * 4;\n+    }\n+\n+    \/\/ Sizes up to 1MB {\n+    for (; idx <= 20; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores;\n+    }\n+\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 2); \/\/2mb\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 1); \/\/4mb\n+    \/\/ Rest 0\n+  }\n+\n+  public MemorySegmentPool(ResourceScope scope) {\n+    this(DEFAULT_MAX_SIZES, scope);\n+  }\n+\n+  \/**\n+   * Constructs new pool with specified maximum number of elements per bucket.\n+   *\n+   * There's {@link Long#SIZE} + 1 buckets, while last bucket is not used,\n+   * as allocations with size 0 or with highest bit set to 1 goes there.\n+   *\n+   * @param maxSizes the array of maximum sizes per segment bucket\n+   * @param scope the scope to which this allocator should be bound\n+   *\/\n+  public MemorySegmentPool(int maxSizes[], ResourceScope scope) {\n+    this.scope = scope;\n+\n+    validateMaxSizes(maxSizes);\n+    for (int i=0; i < segmentsDequeue.length; i++) {\n+      var segmentsBucketMaxSize = i < maxSizes.length ? maxSizes[i] : 0;\n+      segmentsDequeue[i] = new SpinLockQueue<>(segmentsBucketMaxSize);\n+    }\n+\n+    scope.addOnClose(this::freePool);\n+  }\n+\n+  public SegmentAllocator allocatorForScope(ResourceScope resourceScope) {\n+    \/\/ Prevent scope managing this pool to go away, when dependant allocator is alive\n+    final var handle = scope.acquire();\n+    resourceScope.addOnClose(handle::close);\n+    return (bytesSize, bytesAlignment) -> getAsNewSegmentWithScope(resourceScope, bytesSize, bytesAlignment);\n+  }\n+\n+  @ForceInline\n+  public MemoryPoolSegment getSegmentEntryByLayout(MemoryLayout layout) {\n+    return getSegmentEntryBySize(layout.byteSize(), layout.byteAlignment());\n+  }\n+\n+  \/**\n+   * Gets segment from pool or allocates new one. Internally segments are cached.\n+   * The size of segment can be larger than requested.\n+   *\n+   * @param size the size of segment.\n+   *\n+   * @return segment of size at least `size`\n+   *\/\n+\/\/  @ForceInline\n+  public MemoryPoolSegment getSegmentEntryBySize(long size, long alignment) {\n+\/\/    if (!scope.isAlive()) {\n+\/\/      throw new IllegalStateException(\"Associated resource scope is closed\");\n+\/\/    }\n+\n+    final var bitBound = bitBound(size, alignment);\n+    MemoryPoolSegment segment = getMemoryPoolSegment(bitBound);\n+\n+    return segment;\n+  }\n+\n+  @ForceInline\n+  private MemoryPoolSegment getMemoryPoolSegment(int bitBound) {\n+    final var segmentDequeue = segmentsDequeue[bitBound];\n+\n+    var segment = segmentDequeue.pollEntry();\n+    if (segment == null) {\n+      final var bitBoundedSize = 1L << bitBound;\n+      segment = allocateNewEntry(segmentDequeue, bitBoundedSize);\n+\/\/      segment.memorySegment = (NativeMemorySegmentImpl) segment.memoryAddress.asSegment(bitBoundedSize, scope);\n+\/\/      segment.size = bitBoundedSize;\n+    }\n+    return segment;\n+  }\n+\n+  @ForceInline\n+  private MemorySegment getAsNewSegmentWithScope(ResourceScope resourceScope, long size, long alignment) {\n+    final var bitBound = bitBound(size, alignment);\n+    final var segmentEntry = getMemoryPoolSegment(bitBound);\n+\n+    ((ResourceScopeImpl) resourceScope).addOrCleanupIfFail(new ResourceCleanup() {\n+      @Override\n+      public void cleanup() {\n+        segmentEntry.close();\n+      }\n+    });\n+\n+    return segmentEntry.memoryAddress.asSegment(1L << bitBound, resourceScope);\n+  }\n+\n+\n+\n+  @ForceInline\n+  private static int bitBound(long alignedSize) {\n+    \/\/ If 100.., than 100... - 1 -> 01111\n+    \/\/ If 101 -> than 101 - 1 -> 1....\n+\n+    \/\/ 0 -> 64\n+    \/\/ This equation does not allow to allocate more than 2^63, however such memory may require\n+    \/\/ 5 level page cache, so skippable for now\n+    return 64 - Long.numberOfLeadingZeros(alignedSize - 1);\n+  }\n+\n+  @ForceInline\n+  private static int bitBound(long size, long alignment) {\n+    final var alignedSize = (size + alignment - 1) & -alignment;\n+\n+    return bitBound(alignedSize);\n+  }\n+\n+  @ForceInline\n+  private MemoryPoolSegment allocateNewEntry(SpinLockQueue<MemoryPoolSegment> queue, long allocationSize) {\n+    final var memoryAddress = CLinker.allocateMemory(allocationSize);\n+    return new MemoryPoolSegment(queue, memoryAddress, allocationSize, scope);\n+  }\n+\n+  \/**\n+   * Free all elements associated with pool\n+   *\/\n+  private void freePool() {\n+    \/\/ This method is called from pool's scope close method\n+    for (int i = 0; i < segmentsDequeue.length; i++) {\n+      \/\/ After calling this method maxSize is zero, and no new entries can be put back\n+      \/\/ Entries are released using cleaner attached to pool's scope\n+      segmentsDequeue[i].retrieveAndLock();\n+    }\n+  }\n+\n+  private static void validateMaxSizes(int maxSizes[]) {\n+    Arrays.stream(maxSizes).filter(i -> i < 0).findAny()\n+        .ifPresent(i -> {\n+          throw new IllegalStateException(\"Invalid max size \" + i);\n+        });\n+  }\n+\n+  public static class MemoryPoolSegment extends SpinLockQueue.Entry<MemoryPoolSegment> implements AutoCloseable {\n+    private final MemoryAddress memoryAddress;\n+    private final MemorySegment memorySegment;\n+    private volatile boolean released;\n+    long size;\n+\n+    private final static VarHandle RELEASED;\n+\n+    static {\n+      try {\n+        RELEASED = MethodHandles.lookup().findVarHandle(MemoryPoolSegment.class, \"released\", boolean.class);\n+      } catch (Exception e) {\n+        throw new ExceptionInInitializerError(e);\n+      }\n+    }\n+    @ForceInline\n+    private MemoryPoolSegment(SpinLockQueue<MemoryPoolSegment> queue, MemoryAddress memoryAddress, long size, ResourceScope scope) {\n+      super(queue);\n+      this.memoryAddress = memoryAddress;\n+      this.memorySegment = memoryAddress.asSegment(size, scope);\n+\n+      ((ResourceScopeImpl) scope).addOrCleanupIfFail(new ResourceCleanup() {\n+        @Override\n+        public void cleanup() {\n+          release();\n+        }\n+      });\n+    }\n+\n+    @ForceInline\n+    public MemorySegment memorySegment() {\n+      return memorySegment;\n+    }\n+\n+    @Override\n+\/\/    @ForceInline\n+    public void close() {\n+      if (!this.owner.putEntry(this)) {\n+        this.release();\n+      }\n+    }\n+\n+    @ForceInline\n+    private void release() {\n+      if (RELEASED.compareAndSet(this, false, true)) {\n+        \/\/ Don't use segment here, if scope closed will produce exception\n+        CLinker.freeMemory(this.memoryAddress);\n+      }\n+    }\n+  }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+package jdk.incubator.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.Iterator;\n+import jdk.incubator.foreign.SpinLockQueue.Entry;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Fast, concurrent LIFO queue (stack), based on operating on entries.\n+ *\n+ * This queue is designed for fast push \/ pop operations. Synchronization is\n+ * provided by classic spin lock.\n+ *\n+ * @param <T> the type of value used in queue\n+ *\/\n+public final class SpinLockQueue<T extends Entry<T>> {\n+\n+  private int lock = 0;\n+  private int maxSize;\n+\n+  private volatile int size;\n+\n+  private volatile T head;\n+\n+  private static final VarHandle HEAD;\n+  private static final VarHandle SIZE;\n+  private static final VarHandle LOCK;\n+  private static final VarHandle ENTRY_NEXT;\n+  static {\n+    try {\n+      HEAD = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"head\", Entry.class);\n+      SIZE = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"size\", int.class);\n+      LOCK = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"lock\", int.class);\n+\n+      ENTRY_NEXT = MethodHandles.lookup().findVarHandle(Entry.class, \"next\", Entry.class);\n+    } catch (Exception e) {\n+      throw new ExceptionInInitializerError(e);\n+    }\n+  }\n+\n+  public SpinLockQueue(int maxSize) {\n+    this.maxSize = maxSize;\n+  }\n+\n+  @ForceInline\n+  final public T pollEntry() {\n+\/\/    while ((int) LOCK.compareAndExchange(this, 0, 1) != 1) {};\n+    while (!LOCK.compareAndSet(this, 0, 1)) {}\n+    try {\n+      final var current = (T) HEAD.getAcquire(this);\n+      if (current != null) {\n+        HEAD.setRelease(this, ENTRY_NEXT.getAcquire(current));\n+        SIZE.setRelease(this, (int) SIZE.getAcquire(this) - 1);\n+      }\n+      return current;\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+\n+\/\/  final public void putEntryNoSizeCheck(T entry) {\n+\/\/    while (!lock.compareAndSet(0, 1)) { }\n+\/\/    try {\n+\/\/      entry.next = head;\n+\/\/      head = entry;\n+\/\/      size++;\n+\/\/    } finally {\n+\/\/      lock.set(0);\n+\/\/    }\n+\/\/  }\n+\n+  \/**\n+   * Puts entry only if queue size is less then given size.\n+   *\n+   * @param entry - entry to put\n+   *\n+   * @return {@code true} if elements has been put.\n+   *\/\n+  @ForceInline\n+  final public boolean putEntry(T entry) {\n+    while (!LOCK.compareAndSet(this, 0, 1)) { }\n+    try {\n+      final var size = (int) SIZE.getAcquire(this);\n+      if (size < this.maxSize) {\n+        ENTRY_NEXT.setRelease(entry, HEAD.getAcquire(this));\n+        HEAD.setRelease(this, entry);\n+        SIZE.setRelease(this, size + 1);\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+\n+  \/**\n+   * Checks if entry is associated with this queue.\n+   *\n+   * @param entry entry to check\n+   * @return {@code true} if this entry is associated with this queue if it's not in it\n+   *\/\n+  public boolean isAssociated(Entry<T> entry) {\n+    return entry.owner == this;\n+  }\n+\n+  \/**\n+   * Returns number of elements in the queue. This method is not atomic.\n+   *\n+   * @return number of elements in queue\n+   *\/\n+  public long size() {\n+    return this.size;\n+  }\n+\n+  \/**\n+   * Polls all entries and sets max size to 0 so no new entries can be added.\n+   * This operation is atomic.\n+   *\n+   * @return iterator will all entries, iterator is not synchronized, nor thread-safe\n+   *\/\n+  public Iterator<T> retrieveAndLock() {\n+    while (!LOCK.compareAndSet(this, 0, 1)) { }\n+    try {\n+      final var currentHead = (T) HEAD.getAcquire(this);\n+      final var result = new FastEntryIterator<T>(currentHead);\n+      SIZE.set(this, 0);\n+      HEAD.set(this, null);\n+      maxSize = 0;\n+      return result;\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+  public static class Entry<T extends Entry<T>> {\n+    \/\/ Should we keep generic\n+    \/\/ If exposing spinlock queue, the entry should be in module internal package, to prevent\n+    \/\/ tampering owner and next with reflect\n+    final SpinLockQueue<T> owner;\n+    volatile T next;\n+\n+    protected Entry(SpinLockQueue<T> owner) {\n+      this.owner = owner;\n+    }\n+  }\n+\n+  \/**\n+   * Goes through entries chain but don't use spinlock.\n+   *\/\n+  private static class FastEntryIterator<T extends Entry<T>> implements Iterator<T> {\n+    private T next;\n+\n+    public FastEntryIterator(T next) {\n+      this.next = next;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+      return next != null;\n+    }\n+\n+    @Override\n+    public T next() {\n+      var result = next;\n+      next = next.next;\n+      return result;\n+    }\n+  }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.MemorySegmentPool;\n+import jdk.incubator.foreign.MemorySegmentPool.MemoryPoolSegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Allocators performance tests for long running applications.\n+ *\n+ * Tries to simulate library which has to allocate number of different size elements.\n+ *\n+ * Ofc... thre are some cavets\n+ * - if pool of segments will be exhausted, pooled allocator will slow down\n+ * - arena allocator - for long running has to be freed at some point of time...\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class AllocatorsForLongRun {\n+  private static final long[] sizes;\n+\n+  private static final VarHandle BYTE = MemoryHandles.varHandle(byte.class, 1, ByteOrder.nativeOrder());\n+\n+  private static final int[] POOL_MAX_SIZE;\n+\n+  static {\n+    final var rand = new Random(0L);\n+    final var passes = 1024;\n+    final var sizeClasses = new int[] {\n+        24,\n+        128,\n+        4096,\n+        1024*16,\n+        1024 * 1024 * 2\n+    };\n+    \/\/ Generate pseudo random sizes\n+    sizes = new long[passes * sizeClasses.length];\n+\n+    for (int i = 0; i < passes; i++) {\n+      for (int j=0; j < sizeClasses.length; j++) {\n+        sizes[sizeClasses.length * i + j] = Math.max(1, (long) ((rand.nextGaussian() + 1.0) * sizeClasses[j]));\n+      }\n+    }\n+\n+    POOL_MAX_SIZE = new int[Long.SIZE + 1];\n+    \/\/ Use larger sizes for pool, so it will not get exhausted\n+    Arrays.fill(POOL_MAX_SIZE, 256);\n+  }\n+\n+  @Param({\"1\", \"16\", \"200\"})\n+  public int allocations;\n+\n+  private MemorySegmentPool pool = new MemorySegmentPool(POOL_MAX_SIZE, ResourceScope.globalScope());\n+  private MemorySegmentPool poolEmpty = new MemorySegmentPool(new int[Long.SIZE], ResourceScope.globalScope());\n+\n+  private int i;\n+  @Setup\n+  public void setup() {\n+    i = 0;\n+    \/\/ Preallocate pool\n+    for (int j = 0; j <= 24; j++) {\n+      pool.getSegmentEntryBySize(1L << j, 1).close();\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arena() {\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = SegmentAllocator.arenaAllocator(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final var segment = allocator.allocate(sizes[i]);\n+        readSegment(segment);\n+        next();\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void pool_allocator() {\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = pool.allocatorForScope(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final var segment = allocator.allocate(sizes[i]);\n+        readSegment(segment);\n+        next();\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void pool_allocator_exhausted() {\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = poolEmpty.allocatorForScope(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final var segment = allocator.allocate(sizes[i]);\n+        readSegment(segment);\n+        next();\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+\/\/  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void pool_direct() {\n+    List<MemoryPoolSegment> pooledSegments = new ArrayList<>(allocations);\n+    for (int j = 0; j < allocations; j++) {\n+      var s = pool.getSegmentEntryBySize(sizes[i], 1);\n+      pooledSegments.add(s);\n+      readSegment(s.memorySegment());\n+      next();\n+    }\n+    pooledSegments.forEach(MemoryPoolSegment::close);\n+  }\n+  @Benchmark\n+\/\/  @CompilerControl(CompilerControl.Mode.PRINT)\n+  public void malloc_free() {\n+    List<MemoryAddress> allocatedAddresses = new ArrayList<>(allocations);\n+    for (int j = 0; j < allocations; j++) {\n+      var size = sizes[i];\n+      var a = CLinker.allocateMemory(size);\n+      var s = a.asSegment(size, ResourceScope.globalScope());\n+      allocatedAddresses.add(a);\n+      readSegment(s);\n+      next();\n+    }\n+    allocatedAddresses.forEach(CLinker::freeMemory);\n+  }\n+\n+  \/**\n+   * Do read to avoid situation allocator will allocate not mapped memory.\n+   *\/\n+  private void readSegment(MemorySegment s) {\n+    final var size = (int) s.byteSize();\n+    for (int idx = 0; idx <  size; idx += 1024) {\n+\/\/      MemoryAccess.setByteAtOffset(s, l, (byte)0);\n+      BYTE.set(s, 0, (byte) 1);\n+    }\n+  }\n+\n+  private void next() {\n+    i = (++i == sizes.length ? 0 : i);\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -28,0 +28,7 @@\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +41,1 @@\n+import jdk.incubator.foreign.MemorySegmentPool;\n@@ -38,0 +46,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -39,3 +48,0 @@\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.TearDown;\n@@ -45,0 +51,2 @@\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n@@ -46,0 +54,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -48,6 +57,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.CLinker.*;\n-\n@@ -59,1 +62,2 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\",\n+\"--enable-native-access\", \"ALL-UNNAMED\"})\n@@ -67,0 +71,2 @@\n+    MemorySegmentPool memorySegmentPool = new MemorySegmentPool(ResourceScope.globalScope());\n+\n@@ -148,0 +154,21 @@\n+    @Benchmark\n+    public int panama_strlen_memsegmentpool_allocator() throws Throwable {\n+        try(ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            final var allocator = memorySegmentPool.allocatorForScope(scope);\n+            return (int)STRLEN.invokeExact(CLinker.toCString(str, allocator).address());\n+        }\n+    }\n+\n+    @Benchmark\n+\/\/    @CompilerControl(CompilerControl.Mode.PRINT)\n+    public int panama_strlen_memsegmentpool_direct() throws Throwable {\n+        final var memoryPool = memorySegmentPool;\n+        final byte[] bytes = str.getBytes();\n+        final int len = bytes.length;\n+        try (var stringSegmentEntry = memoryPool.getSegmentEntryBySize(len + 1, 1)) {\n+            final var stringSegment = stringSegmentEntry.memorySegment();\n+            stringSegment.copyFrom(MemorySegment.ofArray(bytes));\n+            return (int) STRLEN.invokeExact(stringSegment.address());\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"}]}