{"files":[{"patch":"@@ -0,0 +1,334 @@\n+package jdk.incubator.foreign;\n+\n+import java.util.Arrays;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.ResourceScopeImpl.ResourceList.ResourceCleanup;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Memory segments pool, maintaining pools of segments of size equal to power of 2 with ability to\n+ * expose {@link SegmentAllocator}.\n+ *\n+ * <h1>Overview<\/h1>\n+ * <br \/>\n+ * This pool can be used by long running & highly performant code which requires frequent allocations\n+ * of memory segments (typically having small size) to communicate with native API.\n+ * <br \/>\n+ * An example, can be I\/O layer which use temporary buffers for read and write.\n+ *\n+ * <h1>Segment allocators<\/h1>\n+ * This pool can provide segment allocator which can be backed by pool. All allocations\n+ * will be directed to the pool, and on {@link ResourceScope} close, the allocated segments\n+ * will be put back to pool.\n+ * <br \/>\n+ * Please note: depending on resource scope close strategy there can be a daley in putting\n+ * segments back to the pool.\n+ *\n+ * <h1>Fast entry API<\/h1>\n+ * <b>\n+ *   Note: this API is for advanced applications, as incorrect usage can lead to memory leaks,\n+ *   or memory corruption.\n+ * <\/b>\n+ *\n+ * <br \/>\n+ *\n+ * In order to mitigate overhead related to managing segments by the {@link @ResourceScope} and\n+ * {@link SegmentAllocator} high performant applications can use fast entry methods. The\n+ * caller can get, directly, entry which contains memory segment bound to pool's scope. Entry should\n+ * be returned to pool witch\n+ * <pre>\n+ *   try (final var entry = memoryPool.getSegmentEntryBySize(len, 8)) {\n+ *     final var segment = entry.memorySegment();\n+ *     \/\/ do something with segment\n+ *   }\n+ * <\/pre>\n+ *\n+ * <h1>Memory allocation strategy<\/h1>\n+ * This pool allocates and manages set of segments of size being power of 2. If the request\n+ * is made for a segment of size S (size calculated with alignment bytes), than smallest segment\n+ * meeting both constraints is returned.\n+ *\n+ * <br \/>\n+ *\n+ * The pool manages segments in LIFO order, to increase page table, cache hits.\n+ *\n+ * <br \/>\n+ *\n+ * Segments are kept in buckets of size 2^n. For each bucket the maximum number of elements\n+ * can be set.\n+ *\n+ * <br \/>\n+ *\n+ * When the pool can't provide segment from bucket the new segment is created, there's no upper\n+ * bound.\n+ *\n+ * <br \/>\n+ *\n+ * When the segment is returned back to pool, pool checks if the bucket size is less than maximum.\n+ * In such a case segment entry is put back, otherwise it is deallocated. This check is may not\n+ * be atomic with put.\n+ *\n+ * <br \/>\n+ * Please note: that this pool can allocate segments of larger size than requested\n+ * (almost 2x as requested), if for small it can be ok, than for larger segments it can be\n+ * risky. I. e. request for segment for 1MB (2^20), will result in segment of 1MB, however requesting for\n+ * segment of size 1MB + 1(2^20 + 1), will result in segment of size 2^21). However in case of\n+ * 1GB + 1, pool will allocate 2GB of memory.\n+ *\/\n+public class MemorySegmentPool {\n+  private static final int[] DEFAULT_MAX_SIZES = new int[Long.SIZE + 1];\n+  private static final ResourceScope GLOBAL = ResourceScope.globalScope();\n+\n+  \/**\n+   * Last element to hold 0 size and negative sizes (fallback)\n+   *\/\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  private final SpinLockQueue<MemoryPoolItem> segmentsDequeue[] = new SpinLockQueue[Long.SIZE + 1];\n+\n+  private final ResourceScope scope;\n+\n+  static {\n+    int idx = 0;\n+    int cores = Runtime.getRuntime().availableProcessors();\n+\n+    \/\/ Up to 1kb\n+    for (; idx <= 10; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = 256;\n+    }\n+\n+    \/\/ Sizes up to 64kb\n+    for (; idx <= 16; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores * 4;\n+    }\n+\n+    \/\/ Sizes up to 1MB {\n+    for (; idx <= 20; idx++) {\n+      DEFAULT_MAX_SIZES[idx] = cores;\n+    }\n+\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 2); \/\/2mb\n+    DEFAULT_MAX_SIZES[idx++] = Math.min(cores, 1); \/\/4mb\n+    \/\/ Rest 0\n+  }\n+\n+  public MemorySegmentPool(ResourceScope scope) {\n+    this(DEFAULT_MAX_SIZES, scope);\n+  }\n+\n+  \/**\n+   * Constructs new pool with specified maximum number of elements per bucket.\n+   *\n+   * There's {@link Long#SIZE} + 1 buckets, while last bucket is not used,\n+   * as allocations with size 0 or with highest bit set to 1 goes there.\n+   *\n+   * @param maxSizes the array of maximum sizes per segment bucket\n+   * @param scope the scope to which this allocator should be bound\n+   *\/\n+  public MemorySegmentPool(int maxSizes[], ResourceScope scope) {\n+    this.scope = scope;\n+\n+    validateMaxSizes(maxSizes);\n+    for (int i=0; i < segmentsDequeue.length; i++) {\n+      var segmentsBucketMaxSize = i < maxSizes.length ? maxSizes[i] : 0;\n+      segmentsDequeue[i] = new SpinLockQueue<>(segmentsBucketMaxSize);\n+    }\n+\n+    scope.addCloseAction(new CleanRunnable(this.segmentsDequeue));\n+  }\n+\n+  \/**\n+   * Creates new allocator backed by this pool, and bound to given scope.\n+   *\n+   * <br \/>\n+   *\n+   * The returned allocator will allocate segment of requested size, firstly by\n+   * searching for segment in the pool.\n+   *\n+   * <br \/>\n+   *\n+   * If the segment can't be found in the pool, a new one is allocated (so, this is unbounded\n+   * allocator).\n+   *\n+   * <br \/>\n+   *\n+   * When associated scope is closed, all allocated entries are put back into pool. If\n+   * during allocations more entries have been created than configured maximum number of\n+   * elements of given size class, the allocated segment is freed.\n+   *\n+   * <br \/>\n+   *\n+   * There's no guarantee which allocated entries will be put back to pool, and which one\n+   * freed.\n+   *\n+   * @param resourceScope the scope to which allocator should be bounded\n+   *\n+   * @return memory allocator backed by this pool and bound to given scope\n+   *\/\n+  @ForceInline\n+  public SegmentAllocator allocatorForScope(ResourceScope resourceScope) {\n+    \/\/ Prevent scope managing this pool to go away, when dependant allocator is alive\n+    final var handle = scope.acquire();\n+\/\/    resourceScope.addCloseAction(() -> scope.release(handle));\n+    ((ResourceScopeImpl) resourceScope).addOrCleanupIfFail(new ResourceCleanup() {\n+      @Override\n+      public void cleanup() {\n+        scope.release(handle);\n+      }\n+    });\n+    return ((bytesSize, bytesAlignment) -> {\n+      final var alignedSize = alignSize(bytesSize, bytesAlignment);\n+      final var segmentEntry = findOrAllocateItemAndPrepareForAllocator(resourceScope, alignedSize);\n+      \/\/ Slicing source segment can be faster than source Address as segment\n+      return segmentEntry.sourceAddress.asSegment(alignedSize, null, resourceScope);\n+    });\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+  \/\/\/\/ Internal methods\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  \/**\n+   * Search and maybe allocate segment bounded by given bucket\n+   *\/\n+  @ForceInline\n+  private MemoryPoolItem findOrAllocateItem(int bucket) {\n+    final var segmentDequeue = segmentsDequeue[bucket];\n+\n+    var segment = segmentDequeue.pollEntry();\n+    if (segment == null) {\n+      final var bitBoundedSize = 1L << bucket;\n+      segment = allocateNewPoolItem(segmentDequeue, bitBoundedSize);\n+    }\n+    return segment;\n+  }\n+\n+  \/**\n+   * Prepares pooled segment to be returned by allocator from allocatorForScope\n+   *\/\n+  private MemoryPoolItem findOrAllocateItemAndPrepareForAllocator(ResourceScope resourceScope, long alignedSize) {\n+    int bound = calculateBucket(alignedSize);\n+    final var segmentEntry = findOrAllocateItem(bound);\n+\n+    ((ResourceScopeImpl) resourceScope).addOrCleanupIfFail(new ResourceCleanup() {\n+      @Override\n+      @ForceInline\n+      public void cleanup() {\n+        segmentEntry.close();\n+      }\n+    });\n+\n+    return segmentEntry;\n+  }\n+\n+  \/**\n+   * Calculates bit bound, of size - in other words the bucket which should be used for item.\n+   * @param alignedSize\n+   *\/\n+  @ForceInline\n+  protected int calculateBucket(long alignedSize) {\n+    \/\/ If 100.., than 100... - 1 -> 01111\n+    \/\/ If 101 -> than 101 - 1 -> 1....\n+\n+    \/\/ 0 -> 64\n+    \/\/ This equation does not allow to allocate more than 2^63, however such memory may require\n+    \/\/ 5 level page cache, so skippable for now\n+    return 64 - Long.numberOfLeadingZeros(alignedSize - 1);\n+  }\n+\n+  \/**\n+   * Allocates and prepares a new item.\n+   *\/\n+  @ForceInline\n+  private MemoryPoolItem allocateNewPoolItem(SpinLockQueue<MemoryPoolItem> queue, long allocationSize) {\n+    final var memoryAddress = CLinker.allocateMemory(allocationSize);\n+    return new MemoryPoolItem(queue, memoryAddress, allocationSize, scope);\n+  }\n+\n+  private static void validateMaxSizes(int maxSizes[]) {\n+    Arrays.stream(maxSizes).filter(i -> i < 0).findAny()\n+        .ifPresent(i -> {\n+          throw new IllegalStateException(\"Invalid max size \" + i);\n+        });\n+  }\n+\n+  private static long alignSize(long bytesSize, long bytesAlignment) {\n+    return (bytesSize + bytesAlignment - 1) & -bytesAlignment;\n+  }\n+\n+  \/**\n+   * Represent single item in the pool with related data.\n+   * <br \/>\n+   * In order to return item back to pool close should be called (depending on context either\n+   * implicite or explicite).\n+   *\/\n+  public static final class MemoryPoolItem extends SpinLockQueue.Entry<MemoryPoolItem> implements AutoCloseable {\n+    \/** The owning queue (bucket) to which this pool item belongs. *\/\n+    private final SpinLockQueue<MemoryPoolItem> owner;\n+\n+    \/** Source memory address, it's the start of sourceSegment. *\/\n+    private final MemoryAddress sourceAddress;\n+\n+    @ForceInline\n+    private MemoryPoolItem(SpinLockQueue<MemoryPoolItem> queue, MemoryAddress sourceAddress, long size, ResourceScope scope) {\n+      super();\n+      this.owner = queue;\n+      this.sourceAddress = sourceAddress;\n+    }\n+\n+    \/**\n+     * The memory address representing beginning of this memory item.\n+     *\n+     * @return memory address representing beginning of this memory item.\n+     *\/\n+    @ForceInline\n+    public MemoryAddress memoryAddress() {\n+      return sourceAddress;\n+    }\n+\n+    @Override\n+    @DontInline\n+    public void close() {\n+      if (!this.owner.putEntry(this)) {\n+        this.release();\n+      }\n+    }\n+\n+    \/**\n+     * Physically releases entry - free underlying memory.\n+     *\/\n+    private void release() {\n+      \/\/ Can be called only once, from close\n+\/\/      if (RELEASED.compareAndSet(this, false, true)) {\n+        \/\/ Don't use segment here, if scope closed will produce exception\n+        CLinker.freeMemory(this.sourceAddress);\n+\/\/      }\n+    }\n+  }\n+\n+  \/**\n+   * Cleaner class has to separate pool class, from objects having strong reference\n+   * to pool's scope, as in case of implicite scope, such scope may not be closed, due\n+   * to strong reference trough cleaner method\n+   *\/\n+  private static class CleanRunnable implements Runnable {\n+    private SpinLockQueue<?>[] queuesToClean;\n+\n+    CleanRunnable(SpinLockQueue<?>[] queuesToClean) {\n+      this.queuesToClean = queuesToClean;\n+    }\n+    @Override\n+    public void run() {\n+      \/\/ This method is called from pool's scope close method\n+      for (int i = 0; i < queuesToClean.length; i++) {\n+        \/\/ After calling this method maxSize is zero, and no new entries can be put back\n+        @SuppressWarnings(\"unchecked\")\n+        final var iterator = ((SpinLockQueue<MemoryPoolItem>) queuesToClean[i]).retrieveAndLock();\n+        while (iterator.hasNext()) {\n+          iterator.next().close();\n+        }\n+      }\n+      queuesToClean = null;\n+    }\n+  }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java","additions":334,"deletions":0,"binary":false,"changes":334,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+package jdk.incubator.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.Iterator;\n+import jdk.incubator.foreign.SpinLockQueue.Entry;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Fast, concurrent LIFO queue (stack).\n+ *\n+ * This queue is designed for fast push \/ pop operations. Synchronization is\n+ * provided by classic spin lock.\n+ *\n+ * @param <T> the item type\n+ *\/\n+public final class SpinLockQueue<T extends Entry<T>> {\n+\n+  private int lock = 0;\n+  private int maxSize;\n+\n+  private int size;\n+\n+  private T head;\n+\n+  private static final VarHandle HEAD;\n+  private static final VarHandle SIZE;\n+  private static final VarHandle LOCK;\n+  private static final VarHandle ENTRY_NEXT;\n+  private static final VarHandle ENTRY_IN_POOL;\n+\n+  static {\n+    try {\n+      HEAD = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"head\", Entry.class);\n+      SIZE = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"size\", int.class);\n+      LOCK = MethodHandles.lookup().findVarHandle(SpinLockQueue.class, \"lock\", int.class);\n+\n+      ENTRY_NEXT = MethodHandles.lookup().findVarHandle(Entry.class, \"next\", Entry.class);\n+      ENTRY_IN_POOL = MethodHandles.lookup().findVarHandle(Entry.class, \"inPool\", boolean.class);\n+\n+    } catch (Exception e) {\n+      throw new ExceptionInInitializerError(e);\n+    }\n+  }\n+\n+  \/**\n+   * Creates new instace with specified maximum capacity.\n+   *\n+   * @param maxSize maximum number of elements in queue.\n+   *\/\n+  public SpinLockQueue(int maxSize) {\n+    this.maxSize = maxSize;\n+  }\n+\n+  \/**\n+   * Retrieve element form queue.\n+   * <br \/>\n+   * This operation is atomic.\n+   *\n+   * @return item or {@code null} if queue is empty.\n+   *\/\n+  @ForceInline\n+  final public T pollEntry() {\n+    while (!LOCK.compareAndSet(this, 0, 1)) {}\n+    \/\/ After volatile spin lock\n+    try {\n+      final var current = head;\n+      final var currentTyped = (Entry<T>) current; \/\/ Just to get access to private fields\n+      if (current != null) {\n+        head = currentTyped.next;\n+        currentTyped.inPool = false;\n+        size--;\n+      }\n+      return current;\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+\n+  \/**\n+   * Puts entry into the queue, but only if queue has a capacity.\n+   * <br \/>\n+   * This operation is atomic.\n+   *\n+   * @param entry entry to put\n+   *\n+   * @return {@code true} if elements has been successfully put.\n+   *\/\n+  @ForceInline\n+  final public boolean putEntry(T entry) {\n+    while (!LOCK.compareAndSet(this, 0, 1)) { }\n+    \/\/ After volatile spin lock\n+    try {\n+      final var entryTyped = (Entry<T>) entry; \/\/ Like in c\n+      final var size = this.size;\n+\n+      if (entryTyped.inPool) {\n+        throw new IllegalStateException(\"Entry already in pool, can't be added twice\");\n+      }\n+\n+      if (size < this.maxSize) {\n+        entryTyped.inPool = true;\n+        entryTyped.next = head;\n+        head = entry;\n+        this.size++;\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+\n+  \/**\n+   * Returns number of elements in the queue. This method is not atomic.\n+   *\n+   * @return number of elements in queue\n+   *\/\n+  public long size() {\n+    return this.size;\n+  }\n+\n+  \/**\n+   * Polls all entries and sets max size to 0, so no new entries can be added.\n+   * <br \/>\n+   * This operation is atomic.\n+   *\n+   * @return iterator with all entries, iterator is not synchronized, nor thread-safe\n+   *\/\n+  public Iterator<T> retrieveAndLock() {\n+    while (!LOCK.compareAndSet(this, 0, 1)) { }\n+    try {\n+      final var currentHead = (T) HEAD.getAcquire(this);\n+      final var result = new FastEntryIterator<T>(currentHead);\n+      SIZE.set(this, 0);\n+      HEAD.set(this, null);\n+      maxSize = 0;\n+      return result;\n+    } finally {\n+      LOCK.setRelease(this, 0);\n+    }\n+  }\n+\n+  \/**\n+   * Represent a single item which can be added to the queue.\n+   * <br \/>\n+   * As the queue is intended for fast puts and gets, users should\n+   * subclass this calls in order to add custom attributes.\n+   *\n+   * @param <T> the final exact type.\n+   *\/\n+  public abstract static class Entry<T extends Entry<T>> {\n+    private T next;\n+    private boolean inPool;\n+\n+    protected Entry() {\n+    }\n+  }\n+\n+  \/**\n+   * Goes through entries chain but don't use spinlock.\n+   *\/\n+  private static class FastEntryIterator<T extends Entry<T>> implements Iterator<T> {\n+    private T next;\n+\n+    public FastEntryIterator(T next) {\n+      this.next = next;\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+      return next != null;\n+    }\n+\n+    @Override\n+    public T next() {\n+      var result = next;\n+      ENTRY_IN_POOL.setVolatile(result, false);\n+      next = (T) ENTRY_NEXT.get(next);\n+      return result;\n+    }\n+  }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.MemorySegmentPool;\n+import jdk.incubator.foreign.MemorySegmentPool.MemoryPoolItem;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+\/**\n+ * Allocators performance tests for long running applications.\n+ *\n+ * Tries to simulate library which has to allocate number of different size elements.\n+ *\n+ * Ofc... there are some cavets\n+ * - if pool of segments will be exhausted, pooled allocator will slow down\n+ * - arena allocator - for long running has to be freed at some point of time...\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class AllocatorsForLongRun {\n+  private static final long[] sizes;\n+\n+  private static final VarHandle BYTE = MemoryHandles.varHandle(byte.class, 1, ByteOrder.nativeOrder());\n+\n+  private static final int[] POOL_MAX_SIZE;\n+\n+  static final Unsafe unsafe = Utils.unsafe;\n+\n+  private static final byte[] buff = new byte[1028*1024*4];\n+  static {\n+    final var rand = new Random(0L);\n+    final var passes = 1024;\n+    final var sizeClasses = new int[] {\n+        24,\n+        128,\n+        4096,\n+        1024*16,\n+        1024 * 1024 * 2\n+    };\n+    \/\/ Generate pseudo random sizes\n+    sizes = new long[passes * sizeClasses.length];\n+\n+    for (int i = 0; i < passes; i++) {\n+      for (int j=0; j < sizeClasses.length; j++) {\n+        sizes[sizeClasses.length * i + j] = Math.max(1, (long) ((rand.nextGaussian() + 1.0) * sizeClasses[j]));\n+      }\n+    }\n+\n+    POOL_MAX_SIZE = new int[Long.SIZE + 1];\n+    \/\/ Use larger sizes for pool, so it will not get exhausted\n+    Arrays.fill(POOL_MAX_SIZE, 256);\n+  }\n+\n+  @Param({\"1\", \"16\", \"200\"})\n+  public int allocations;\n+\n+\/\/  @Param({\"true\", \"false\"})\n+\/\/  private boolean doSegmentWrite = true;\n+\n+  private static final boolean doSegmentWrite = false;\n+\n+  private static final MemorySegmentPool pool = new MemorySegmentPool(POOL_MAX_SIZE, ResourceScope.globalScope());\n+  private MemorySegmentPool poolEmpty = new MemorySegmentPool(new int[Long.SIZE], ResourceScope.globalScope());\n+\n+  private volatile ResourceScope scope;\n+\n+  private int i;\n+  @Setup\n+  public void setup() {\n+    i = 0;\n+    \/\/ Preallocate pool\n+    for (int j = 0; j <= 24; j++) {\n+\/\/      pool.getSegmentEntryBySize(1L << j, 1).close();\n+    }\n+\n+    scope = ResourceScope.globalScope();\n+  }\n+\n+  private ResourceScope iterationScope;\n+  private SegmentAllocator iterationArenaAllocator;\n+\n+  @Setup(Level.Iteration)\n+  public void setupIteration() {\n+    i = 0;\n+  }\n+\n+\/\/  @Setup(Level.Invocation)\n+\/\/  public void setupInvocation() {\n+\/\/    iterationScope = ResourceScope.newConfinedScope();\n+\/\/    iterationArenaAllocator = SegmentAllocator.arenaAllocator(iterationScope);\n+\/\/  }\n+\/\/\n+\/\/  @TearDown(Level.Invocation)\n+\/\/  public void tearDownInvocation() {\n+\/\/    iterationArenaAllocator = null;\n+\/\/    iterationScope.close();\n+\/\/    iterationScope = null;\n+\/\/  }\n+\n+  @Benchmark\n+  public void arena() {\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = SegmentAllocator.arenaAllocator(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final long sz = sizes[i];\n+        final var segment = allocator.allocate(sz);\n+        readSegment(segment, sz);\n+        next();\n+      }\n+    }\n+  }\n+\n+\/\/  @Benchmark\n+\/\/  public void iteration_arena_no_dealloc() {\n+\/\/    \/\/ May be OOM, arena is deallocated after iteration\n+\/\/    \/\/ Depends on setup \/ tearDown invocation\n+\/\/    for (int j = 0; j < allocations; j++) {\n+\/\/      final var segment = iterationArenaAllocator.allocate(sizes[i]);\n+\/\/      readSegment(segment);\n+\/\/      next();\n+\/\/    }\n+\/\/  }\n+\n+  @Benchmark\n+  public void pool_allocator() {\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = pool.allocatorForScope(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final long sz = sizes[i];\n+        final var segment = allocator.allocate(sz);\n+        readSegment(segment, sz);\n+        next();\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void pool_allocator_exhausted() {\n+    try (var scope = ResourceScope.newConfinedScope()) {\n+      final var allocator = poolEmpty.allocatorForScope(scope);\n+      for (int j = 0; j < allocations; j++) {\n+        final long sz = sizes[i];\n+        final var segment = allocator.allocate(sz);\n+        readSegment(segment, sz );\n+        next();\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void malloc_free() {\n+    List<MemoryAddress> allocatedAddresses = new ArrayList<>(allocations);\n+    for (int j = 0; j < allocations; j++) {\n+      var size = sizes[i];\n+      var a = CLinker.allocateMemory(size);\n+      var s = a.asSegment(size, ResourceScope.globalScope());\n+      allocatedAddresses.add(a);\n+      readSegment(s, size);\n+      next();\n+    }\n+    allocatedAddresses.forEach(CLinker::freeMemory);\n+  }\n+\n+  \/**\n+   * Do read to avoid situation allocator will allocate not mapped memory.\n+   *\/\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n+  private void readSegment(MemorySegment s, long sz) {\n+    if (doSegmentWrite) {\n+      final var size = (int) sz;\/\/s.byteSize();\n+      BYTE.set(s, (long) 0, (byte) 1);\n+\n+      for (int idx = 1024; idx < size; idx += 1024) {\n+        BYTE.set(s, (long) idx, (byte) 1);\n+      }\n+    }\n+  }\n+\n+  private void next() {\n+    i = (++i == sizes.length ? 0 : i);\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -28,0 +28,7 @@\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +41,1 @@\n+import jdk.incubator.foreign.MemorySegmentPool;\n@@ -38,0 +46,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -39,3 +48,0 @@\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.TearDown;\n@@ -45,0 +51,2 @@\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n@@ -46,0 +54,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -48,6 +57,0 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.CLinker.*;\n-\n@@ -59,1 +62,2 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\",\n+\"--enable-native-access\", \"ALL-UNNAMED\"})\n@@ -67,0 +71,2 @@\n+    MemorySegmentPool memorySegmentPool = new MemorySegmentPool(ResourceScope.globalScope());\n+\n@@ -148,0 +154,25 @@\n+    @Benchmark\n+    public int panama_strlen_memsegmentpool_allocator_copy() throws Throwable {\n+        try(ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            final var allocator = memorySegmentPool.allocatorForScope(scope);\n+\n+            byte[] bytes = str.getBytes();\n+            int len = bytes.length;\n+\n+            final var segment = allocator.allocate(len+1);\n+            segment.copyFrom(MemorySegment.ofArray(bytes));\n+            MemoryAccess.setByteAtOffset(segment, len, (byte)0);\n+\n+            return (int)STRLEN.invokeExact(segment.address());\n+        }\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_memsegmentpool_allocator() throws Throwable {\n+        try(ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            final var allocator = memorySegmentPool.allocatorForScope(scope);\n+            return (int)STRLEN.invokeExact(CLinker.toCString(str, allocator).address());\n+        }\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"}]}