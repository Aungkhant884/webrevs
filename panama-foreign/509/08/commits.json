[{"commit":{"message":"Prevent double adding element to queue\n\nDealt with slow write issue - had to create segment with aligned size, not\na bit shift.\n\nForceInline allocatorForScope and allocate method - this is outcome\nfrom performance tests, and probable scalarization of segment.\n\nSome changes to inlining \/ no inlining."},"files":[{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java"},{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java"}],"sha":"536e71aac66b65cd9cbda6e428115f73a183fceb"},{"commit":{"message":"Tests better distribute sizes for pseudo random allocation - now much larger buffers gets allocated and used.\n\nI'm bit puzzled here, as it looks like, that allocatioin is very fast, only\nreading is extreme slow.\n\nFor comparision when processing single allocation:\nUpdate only first byte: direct pool access - 33ns, malloc \/ free: 59ns\nUpdate very 1024th byte: 12980ns, vs malloc: 8400ns\n\nI think simillar results has been spot during test with StringLen."},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java"}],"sha":"cf5c2e02644edae4cd55c9ffba2ab5919e1620b3"},{"commit":{"message":"Better releasing resources on scopes close\nNew benchamarks for bulk allocations"},"files":[{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java"},{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/AllocatorsForLongRun.java"}],"sha":"4faf20989ae35ca40613136037687da837261bdb"},{"commit":{"message":"Minor fixes to SpinLockQueue\nRemove redundant LOCK release (set to 0) in put entry.\nFixed maxSize comparison\nRemoved unused imports\n\nQ: Could we reduce setRelease to just set in few places?\nQ: Should this method be private and moved to Entry.close to prevent accidental adding element from other queue?"},"files":[{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java"}],"sha":"d8bd532201ba1ffffa61d85809b1b2fdedf51422"},{"commit":{"message":"Use VH insted of volatile\n\nReplacee\n\/\/    while ((int) LOCK.compareAndExchange(this, 0, 1) != 1) { }\n    while (!LOCK.compareAndSet(this, 0, 1)) { }\n\nPerformane around 34 ns \/ oop"},"files":[{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java"}],"sha":"ea743bfe1894cb071412311588fc95de41cf5302"},{"commit":{"message":"Fix tests (!)\nMake entries closable, to make API easier to use, and avoid searching for target queue.\nReplace atomics is var handles"},"files":[{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java"},{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java"}],"sha":"c62099d6aef268c0ed5c16dc2fa49415de71ce92"},{"commit":{"message":"Optimize bit bound calculations"},"files":[{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java"}],"sha":"7f5f9ea6d5da8df30233b556d74609e00702bc4c"},{"commit":{"message":"Fix to copy-pasted test"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java"}],"sha":"f513c20e27b0b10251e478fb8c5e9f8d50c5be69"},{"commit":{"message":"Add micro benchmarks"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java"}],"sha":"88ff5cf7c0b4a2570f82e3b06370b336b1056020"},{"commit":{"message":"MemorySegmentPool + Allocator\n\n(Preview)\n\nThe MemorySegmentPool is a pool maintaining memory segments, optionally can expose allocator which can be bound to other scope, and which will return allocated segments back to pool.\n\nHowever the best results has been achieved by using getSegmentEntry & putSegmentEntry methods.\n\nThe pool is intended to be used by long running applications (i.e. like global shared pool), where fast allocation and de-allocation of segments is critical (was designed during implementation of I\/O subsystem with Panama, as a pool for temporary buffers between system I\/O methods and Java byte arrays from InputStreams).\n\nThe pool uses hand-made SpinLockQueue as the Deque from JDK offers too much functionality and overhead."},"files":[{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegmentPool.java"},{"filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SpinLockQueue.java"}],"sha":"b31434cef94045b37811ded33e228eff575d5ae8"}]