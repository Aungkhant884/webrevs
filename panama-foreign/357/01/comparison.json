{"files":[{"patch":"@@ -154,1 +154,1 @@\n-                                      String[] libraryNames, String baseClassName, boolean isFinal) {\n+                                      String[] libraryNames, String baseClassName) {\n@@ -198,1 +198,1 @@\n-        helper.classBegin(qualBaseName, isFinal);\n+        helper.classBegin(qualBaseName);\n@@ -206,1 +206,1 @@\n-    private void classBegin(String baseClassName, boolean isFinal) {\n+    private void classBegin(String baseClassName) {\n@@ -208,2 +208,1 @@\n-        int mods = isFinal? ACC_FINAL : 0;\n-        cw.visit(V15, mods, internalClassName, null, baseName, null);\n+        cw.visit(V15, 0, internalClassName, null, baseName, null);\n@@ -292,1 +291,1 @@\n-    public List<JavaFileObject> getClasses() {\n+    public List<JavaFileObject> build() {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClassConstantHelper.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    List<JavaFileObject> getClasses();\n+    List<JavaFileObject> build();\n@@ -53,2 +53,2 @@\n-                ? SourceConstantHelper.make(packageName, simpleClassName, libraryNames, baseClassName, isFinal)\n-                : ClassConstantHelper.make(packageName, simpleClassName, runtimeHelper, cString, libraryNames, baseClassName, isFinal),\n+                ? SourceConstantHelper.make(packageName, simpleClassName, libraryNames, baseClassName)\n+                : ClassConstantHelper.make(packageName, simpleClassName, runtimeHelper, cString, libraryNames, baseClassName),\n@@ -57,0 +57,4 @@\n+\n+    interface ConstantHelperFactory {\n+        ConstantHelper make(String headerClassName);\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantHelper.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.*;\n+import jdk.incubator.jextract.Type;\n+\n+import java.lang.invoke.MethodType;\n+\n+public class FunctionalInterfaceBuilder extends NestedClassBuilder {\n+\n+    private final String fiAnno;\n+    private final MethodType fiType;\n+    private final FunctionDescriptor fiDesc;\n+\n+    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, String className, MethodType fiType,\n+                               FunctionDescriptor fiDesc, Type funcType) {\n+        super(enclosing, Kind.INTERFACE, className);\n+        this.fiType = fiType;\n+        this.fiDesc = fiDesc;\n+        this.fiAnno = annotationWriter.getCAnnotation(funcType);\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        emitFunctionalInterfaceMethod();\n+        emitFunctionalFactories();\n+        return super.classEnd();\n+    }\n+\n+    void emitFunctionalInterfaceMethod() {\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(fiType.returnType().getName() + \" apply(\");\n+        String delim = \"\";\n+        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+            builder.append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+            delim = \", \";\n+        }\n+        builder.append(\");\\n\");\n+        builder.decrAlign();\n+    }\n+\n+    private void emitFunctionalFactories() {\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + \" \" + fiAnno + \" MemorySegment allocate(\" + className + \" fi) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return RuntimeHelper.upcallStub(\" + className + \".class, fi, \" + functionGetCallString(className, fiDesc) + \", \" +\n+                \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\");\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.indent();\n+        builder.append(PUB_MODS + \" \" + fiAnno + \" MemorySegment allocate(\" + className + \" fi, NativeScope scope) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return scope.register(allocate(fi));\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -1,285 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Type;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * A helper class to generate header interface class in source form.\n- * After aggregating various constituents of a .java source, build\n- * method is called to get overall generated source string.\n- *\/\n-class HeaderBuilder extends JavaSourceBuilder {\n-    private final AnnotationWriter annotationWriter;\n-    protected final StringBuffer sb;\n-\n-    \/\/ current line alignment (number of 4-spaces)\n-    private int align;\n-\n-    HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n-        super(className, pkgName, constantHelper);\n-        this.annotationWriter = annotationWriter;\n-        this.sb = new StringBuffer();\n-    }\n-\n-    @Override\n-    JavaSourceBuilder prev() {\n-        return null;\n-    }\n-\n-    @Override\n-    void append(String s) {\n-        sb.append(s);\n-    }\n-\n-    @Override\n-    void append(char c) {\n-        sb.append(c);\n-    }\n-\n-    @Override\n-    void append(long l) {\n-        sb.append(l);\n-    }\n-\n-    @Override\n-    void indent() {\n-        for (int i = 0; i < align; i++) {\n-            append(\"    \");\n-        }\n-    }\n-\n-    @Override\n-    void incrAlign() {\n-        align++;\n-    }\n-\n-    @Override\n-    void decrAlign() {\n-        align--;\n-    }\n-\n-    void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor fDesc, String anno) {\n-        incrAlign();\n-        indent();\n-        append(\"public interface \" + name + \" {\\n\");\n-        incrAlign();\n-        indent();\n-        append(mtype.returnType().getName() + \" apply(\");\n-        String delim = \"\";\n-        for (int i = 0 ; i < mtype.parameterCount(); i++) {\n-            append(delim + mtype.parameterType(i).getName() + \" x\" + i);\n-            delim = \", \";\n-        }\n-        append(\");\\n\");\n-        addFunctionalFactory(name, mtype, fDesc, anno);\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-    }\n-\n-    void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc,\n-                                  boolean varargs, List<String> paramNames, List<String> annos, String returnAnno) {\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        if (mtype.returnType() != void.class) {\n-            append(returnAnno);\n-            append(' ');\n-        }\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n-        String delim = \"\";\n-        List<String> pExprs = new ArrayList<>();\n-        final int numParams = paramNames.size();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = paramNames.get(i);\n-            if (pName.isEmpty()) {\n-                pName = \"x\" + i;\n-            }\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n-            Class<?> pType = mtype.parameterType(i);\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n-            append(delim + annos.get(i) + \" \" + pType.getSimpleName() + \" \" + pName);\n-            delim = \", \";\n-        }\n-        if (varargs) {\n-            String lastArg = \"x\" + numParams;\n-            if (numParams > 0) {\n-                append(\", \");\n-            }\n-            append(\"Object... \" + lastArg);\n-            pExprs.add(lastArg);\n-        }\n-        append(\") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n-        }\n-        append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + \".invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(ex);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n-    void emitPrimitiveTypedef(Type.Primitive primType, String name, String anno) {\n-        Type.Primitive.Kind kind = primType.kind();\n-        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {\n-            incrAlign();\n-            indent();\n-            append(PUB_MODS);\n-            append(anno + \" ValueLayout \");\n-            append(uniqueNestedClassName(name));\n-            append(\" = \");\n-            append(TypeTranslator.typeToLayoutName(kind));\n-            append(\";\\n\");\n-            decrAlign();\n-        }\n-    }\n-\n-    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n-        return switch(kind) {\n-            case Short, Int, Long, LongLong, Float, Double, LongDouble, Char -> true;\n-            default -> false;\n-        };\n-    }\n-\n-    void emitTypedef(Declaration.Typedef td, String superClassName) {\n-        String className = td.name();\n-        boolean superClassExists = superClassName != null;\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(annotationWriter.getCAnnotation(td.type()));\n-        append(\" class \");\n-        String uniqueName = uniqueNestedClassName(className);\n-        append(uniqueName);\n-        if (superClassExists) {\n-            append(\" extends \");\n-            append(superClassName);\n-        }\n-        append(\" {\\n\");\n-\n-        incrAlign();\n-        indent();\n-        \/\/ private constructor\n-        append(\"private \");\n-        append(uniqueName);\n-        append(\"() {}\\n\");\n-        decrAlign();\n-\n-        \/\/ typedef of incomplete struct\/union\n-        \/\/ generate a class with just allocatePointer methods with right annotation\n-        if (!superClassExists) {\n-            String anno = annotationWriter.getCAnnotation(Type.pointer(td.type()));\n-            \/\/ allocatePointer\n-            incrAlign();\n-            indent();\n-            append(PUB_MODS);\n-            append(anno + \" MemorySegment allocatePointer() {\\n\");\n-            incrAlign();\n-            indent();\n-            append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n-            decrAlign();\n-            indent();\n-            append(\"}\\n\");\n-            decrAlign();\n-\n-            \/\/ allocatePointer (scope version)\n-            incrAlign();\n-            indent();\n-            append(PUB_MODS);\n-            append(anno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n-            incrAlign();\n-            indent();\n-            append(\"return scope.allocate(C_POINTER);\\n\");\n-            decrAlign();\n-            indent();\n-            append(\"}\\n\");\n-            decrAlign();\n-        }\n-\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n-    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc, String anno) {\n-        indent();\n-        append(PUB_MODS + \" \" + anno + \" MemorySegment allocate(\" + className + \" fi) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return RuntimeHelper.upcallStub(\" + className + \".class, fi, \" + functionGetCallString(className, fDesc) + \", \" +\n-                \"\\\"\" + mtype.toMethodDescriptorString() + \"\\\");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-\n-        indent();\n-        append(PUB_MODS + \" \" + anno + \" MemorySegment allocate(\" + className + \" fi, NativeScope scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return scope.register(allocate(fi));\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-    }\n-\n-    JavaFileObject build() {\n-        String res = sb.toString();\n-        this.sb.delete(0, res.length());\n-        return Utils.fileFromString(pkgName, className, res);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderBuilder.java","additions":0,"deletions":285,"binary":false,"changes":285,"status":"deleted"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+class HeaderFileBuilder extends JavaSourceBuilder {\n+\n+    private String superclass;\n+\n+    HeaderFileBuilder(String clsName, String pkgName, String superclass, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n+        super(new StringSourceBuilder(), Kind.CLASS, clsName, pkgName, constantHelper, annotationWriter);\n+        this.superclass = superclass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superclass;\n+    }\n+\n+    @Override\n+    protected String getClassModifiers() {\n+        return \"\";\n+    }\n+\n+    void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc,\n+                                  boolean varargs, List<String> paramNames, List<String> annos, String returnAnno) {\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        if (mtype.returnType() != void.class) {\n+            builder.append(returnAnno);\n+            builder.append(' ');\n+        }\n+        builder.append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        final int numParams = paramNames.size();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = paramNames.get(i);\n+            if (pName.isEmpty()) {\n+                pName = \"x\" + i;\n+            }\n+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = mtype.parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            builder.append(delim + annos.get(i) + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        if (varargs) {\n+            String lastArg = \"x\" + numParams;\n+            if (numParams > 0) {\n+                builder.append(\", \");\n+            }\n+            builder.append(\"Object... \" + lastArg);\n+            pExprs.add(lastArg);\n+        }\n+        builder.append(\") {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"try {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        if (!mtype.returnType().equals(void.class)) {\n+            builder.append(\"return (\" + mtype.returnType().getName() + \")\");\n+        }\n+        builder.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs) + \".invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"} catch (Throwable ex) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"throw new AssertionError(ex);\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n+    }\n+\n+    void emitPrimitiveTypedef(Type.Primitive primType, String name, String anno) {\n+        Type.Primitive.Kind kind = primType.kind();\n+        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {\n+            builder.incrAlign();\n+            builder.indent();\n+            builder.append(PUB_MODS);\n+            builder.append(anno + \" ValueLayout \");\n+            builder.append(uniqueNestedClassName(name));\n+            builder.append(\" = \");\n+            builder.append(TypeTranslator.typeToLayoutName(kind));\n+            builder.append(\";\\n\");\n+            builder.decrAlign();\n+        }\n+    }\n+\n+    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n+        return switch(kind) {\n+            case Short, Int, Long, LongLong, Float, Double, LongDouble, Char -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    List<JavaFileObject> build() {\n+        classEnd();\n+        String res = builder.build();\n+        List<JavaFileObject> files = constantHelper.build();\n+        files.add(Utils.fileFromString(pkgName, className, res));\n+        return files;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.jextract.Type;\n@@ -40,0 +41,12 @@\n+\n+    enum Kind {\n+        CLASS(\"class\"),\n+        INTERFACE(\"interface\");\n+\n+        final String kindName;\n+\n+        Kind(String kindName) {\n+            this.kindName = kindName;\n+        }\n+    }\n+\n@@ -42,0 +55,2 @@\n+    protected final StringSourceBuilder builder;\n+    private final Kind kind;\n@@ -45,0 +60,1 @@\n+    protected final AnnotationWriter annotationWriter;\n@@ -49,1 +65,3 @@\n-    JavaSourceBuilder(String className, String pkgName, ConstantHelper constantHelper, int align) {\n+    JavaSourceBuilder(StringSourceBuilder builder, Kind kind, String className, String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n+        this.builder = builder;\n+        this.kind = kind;\n@@ -53,0 +71,1 @@\n+        this.annotationWriter = annotationWriter;\n@@ -55,13 +74,3 @@\n-    abstract JavaSourceBuilder prev();\n-\n-    abstract void append(String s);\n-\n-    abstract void append(char c);\n-\n-    abstract void append(long l);\n-\n-    abstract void indent();\n-\n-    abstract void incrAlign();\n-\n-    abstract void decrAlign();\n+    String superClass() {\n+        return null;\n+    }\n@@ -69,2 +78,2 @@\n-    JavaSourceBuilder(String className, String pkgName, ConstantHelper constantHelper) {\n-        this(className, pkgName, constantHelper, 0);\n+    Type type() {\n+        return null;\n@@ -81,6 +90,14 @@\n-        indent();\n-        append(getClassModifiers());\n-        append(\"class \");\n-        append(className);\n-        append(\" {\\n\\n\");\n-        emitConstructor();\n+        builder.indent();\n+        if (type() != null) {\n+            builder.append(annotationWriter.getCAnnotation(type()));\n+        }\n+        builder.append(getClassModifiers());\n+        builder.append(kind.kindName + \" \" + className);\n+        if (superClass() != null) {\n+            builder.append(\" extends \");\n+            builder.append(superClass());\n+        }\n+        builder.append(\" {\\n\\n\");\n+        if (kind != Kind.INTERFACE) {\n+            emitConstructor();\n+        }\n@@ -90,7 +107,7 @@\n-        incrAlign();\n-        indent();\n-        append(\"private \");\n-        append(className);\n-        append(\"() {}\");\n-        append('\\n');\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"\/* package-private *\/ \");\n+        builder.append(className);\n+        builder.append(\"() {}\");\n+        builder.append('\\n');\n+        builder.decrAlign();\n@@ -100,3 +117,3 @@\n-        indent();\n-        append(\"}\\n\\n\");\n-        return prev();\n+        builder.indent();\n+        builder.append(\"}\\n\\n\");\n+        return this;\n@@ -126,5 +143,5 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n@@ -132,1 +149,1 @@\n-        append(\"return (\" + type.getName() + \")\"\n+        builder.append(\"return (\" + type.getName() + \")\"\n@@ -134,4 +151,4 @@\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -141,5 +158,5 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS + \"void \" + javaName + \"$set(\" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n@@ -147,5 +164,5 @@\n-        append(globalVarHandleGetCallString(javaName, nativeName, layout, type) + \".set(\" + vhParam + \", x);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.append(globalVarHandleGetCallString(javaName, nativeName, layout, type) + \".set(\" + vhParam + \", x);\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -158,1 +175,1 @@\n-        append(\"\/\/ Generated by jextract\\n\\n\");\n+        builder.append(\"\/\/ Generated by jextract\\n\\n\");\n@@ -160,3 +177,3 @@\n-            append(\"package \");\n-            append(pkgName);\n-            append(\";\\n\\n\");\n+            builder.append(\"package \");\n+            builder.append(pkgName);\n+            builder.append(\";\\n\\n\");\n@@ -167,7 +184,7 @@\n-        append(\"import java.lang.invoke.MethodHandle;\\n\");\n-        append(\"import java.lang.invoke.VarHandle;\\n\");\n-        append(\"import jdk.incubator.foreign.*;\\n\");\n-        append(\"import jdk.incubator.foreign.MemoryLayout.PathElement;\\n\");\n-        append(\"import static \");\n-        append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n-        append(\".*;\\n\");\n+        builder.append(\"import java.lang.invoke.MethodHandle;\\n\");\n+        builder.append(\"import java.lang.invoke.VarHandle;\\n\");\n+        builder.append(\"import jdk.incubator.foreign.*;\\n\");\n+        builder.append(\"import jdk.incubator.foreign.MemoryLayout.PathElement;\\n\");\n+        builder.append(\"import static \");\n+        builder.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n+        builder.append(\".*;\\n\");\n@@ -177,10 +194,10 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS + anno + \" \" + displayName(desc.invocationType().returnType()) + \" \" + desc.methodName() + \"() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return \" + getCallString(desc) + \";\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + anno + \" \" + displayName(desc.invocationType().returnType()) + \" \" + desc.methodName() + \"() {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return \" + getCallString(desc) + \";\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -227,0 +244,3 @@\n+    StructBuilder newStructBuilder(String name, String parentLayoutFieldName, MemoryLayout parentLayout, Type type) {\n+        return new StructBuilder(this, name, parentLayoutFieldName, parentLayout, type);\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":93,"deletions":73,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        finishedClasses.addAll(delegate.getClasses());\n+        finishedClasses.addAll(delegate.build());\n@@ -125,1 +125,1 @@\n-    public List<JavaFileObject> getClasses() {\n+    public List<JavaFileObject> build() {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/MultiFileConstantHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+public abstract class NestedClassBuilder extends JavaSourceBuilder {\n+\n+    private final JavaSourceBuilder enclosing;\n+\n+    public NestedClassBuilder(JavaSourceBuilder enclosing, Kind kind, String className) {\n+        super(enclosing.builder, kind, enclosing.uniqueNestedClassName(className), enclosing.pkgName, enclosing.constantHelper, enclosing.annotationWriter);\n+        this.enclosing = enclosing;\n+    }\n+\n+    @Override\n+    void classBegin() {\n+        builder.incrAlign();\n+        super.classBegin();\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        super.classEnd();\n+        builder.decrAlign();\n+        return enclosing;\n+    }\n+\n+    @Override\n+    protected String getClassModifiers() {\n+        return PUB_MODS;\n+    }\n+\n+    @Override\n+    protected void addPackagePrefix() {\n+        \/\/ nested class. containing class has necessary package declaration\n+    }\n+\n+    @Override\n+    protected void addImportSection() {\n+        \/\/ nested class. containing class has necessary imports\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/NestedClassBuilder.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -63,1 +63,1 @@\n-    protected final HeaderBuilder toplevelBuilder;\n+    protected final ToplevelBuilder toplevelBuilder;\n@@ -65,1 +65,0 @@\n-    protected final ConstantHelper constantHelper;\n@@ -101,2 +100,2 @@\n-        HeaderBuilder headerBuilder = new HeaderBuilder(clsName, pkgName, constantHelper, annotationWriter);\n-        return new OutputFactory(pkgName, headerBuilder, constantHelper, annotationWriter).generate(decl);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(clsName, pkgName, constantHelper, annotationWriter);\n+        return new OutputFactory(pkgName, toplevelBuilder, annotationWriter).generate(decl);\n@@ -105,1 +104,1 @@\n-    private OutputFactory(String pkgName, HeaderBuilder toplevelBuilder, ConstantHelper constantHelper,\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder,\n@@ -110,1 +109,0 @@\n-        this.constantHelper = constantHelper;\n@@ -122,2 +120,3 @@\n-            Declaration.Scoped structDef = ((Type.Declared)td.type()).tree();\n-            toplevelBuilder.emitTypedef(td, structDefinitionSeen(structDef)? structDefinitionName(structDef) : null);\n+            Declaration.Scoped structDef = ((Type.Declared) td.type()).tree();\n+            toplevelBuilder.addTypeDef(td.name(),\n+                    structDefinitionSeen(structDef) ? structDefinitionName(structDef) : null, td.type());\n@@ -128,2 +127,1 @@\n-            files.add(toplevelBuilder.build());\n-            files.addAll(constantHelper.getClasses());\n+            files.addAll(toplevelBuilder.build());\n@@ -182,1 +180,1 @@\n-        toplevelBuilder.addConstantGetter(Utils.javaSafeIdentifier(constant.name()),\n+        header().addConstantGetter(Utils.javaSafeIdentifier(constant.name()),\n@@ -204,2 +202,2 @@\n-                    currentBuilder = new StructBuilder(currentBuilder, className, parentLayoutFieldName, parentLayout,\n-                            pkgName, constantHelper, annotationWriter, Type.declared(d));\n+                    currentBuilder = currentBuilder.newStructBuilder(className, parentLayoutFieldName,\n+                            parentLayout, Type.declared(d));\n@@ -207,1 +205,0 @@\n-                    currentBuilder.incrAlign();\n@@ -217,1 +214,0 @@\n-            currentBuilder.decrAlign();\n@@ -286,1 +282,1 @@\n-        toplevelBuilder.addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());\n+        header().addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());\n@@ -299,1 +295,1 @@\n-        toplevelBuilder.addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,\n+        header().addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,\n@@ -312,2 +308,2 @@\n-                String anno = annotationWriter.getCAnnotation(param.type());\n-                toplevelBuilder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow(), anno);\n+                toplevelBuilder.addFunctionalInterface(name, fitype,\n+                        Type.descriptorFor(f).orElseThrow(), param.type());\n@@ -360,1 +356,1 @@\n-                                toplevelBuilder.emitTypedef(tree, structDefinitionName(s));\n+                                toplevelBuilder.addTypeDef(tree.name(), structDefinitionName(s), tree.type());\n@@ -377,1 +373,1 @@\n-             toplevelBuilder.emitPrimitiveTypedef((Type.Primitive)type, tree.name(), anno);\n+             header().emitPrimitiveTypedef((Type.Primitive)type, tree.name(), anno);\n@@ -440,1 +436,1 @@\n-                    toplevelBuilder.addSegmentGetter(fieldName, tree.name(), treeLayout);\n+                    header().addSegmentGetter(fieldName, tree.name(), treeLayout);\n@@ -442,5 +438,5 @@\n-                    toplevelBuilder.addLayoutGetter(fieldName, layout);\n-                    toplevelBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz);\n-                    toplevelBuilder.addSegmentGetter(fieldName, tree.name(), treeLayout);\n-                    toplevelBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, anno);\n-                    toplevelBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, anno);\n+                    header().addLayoutGetter(fieldName, layout);\n+                    header().addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz);\n+                    header().addSegmentGetter(fieldName, tree.name(), treeLayout);\n+                    header().addGetter(fieldName, tree.name(), treeLayout, clazz, anno);\n+                    header().addSetter(fieldName, tree.name(), treeLayout, clazz, anno);\n@@ -484,0 +480,4 @@\n+\n+    HeaderFileBuilder header() {\n+        return toplevelBuilder.nextHeader();\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-class SourceConstantHelper implements ConstantHelper {\n+class SourceConstantHelper extends JavaSourceBuilder implements ConstantHelper {\n@@ -59,6 +59,1 @@\n-    \/\/ code buffer\n-    private StringBuilder sb = new StringBuilder();\n-    \/\/ current line alignment (number of 4-spaces)\n-    private int align;\n-    private final String pkgName;\n-    private final String constantClassName;\n+\n@@ -66,0 +61,2 @@\n+    private final String[] libraryNames;\n+    private final String baseClassName;\n@@ -67,3 +64,2 @@\n-    private SourceConstantHelper(String packageName, String className, ClassDesc CD_constantsHelper) {\n-        this.pkgName = packageName;\n-        this.constantClassName = className;\n+    private SourceConstantHelper(String packageName, String[] libraryNames, String className, String baseClassName, ClassDesc CD_constantsHelper) {\n+        super(new StringSourceBuilder(), Kind.CLASS, className, packageName, null, null);\n@@ -71,0 +67,7 @@\n+        this.libraryNames = libraryNames;\n+        this.baseClassName = baseClassName;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return baseClassName;\n@@ -74,1 +77,1 @@\n-                                      String baseClassName, boolean isFinal) {\n+                                      String baseClassName) {\n@@ -76,2 +79,2 @@\n-        SourceConstantHelper helper = new SourceConstantHelper(packageName, className, CD_constantsHelper);\n-        helper.classBegin(libraryNames, baseClassName, isFinal);\n+        SourceConstantHelper helper = new SourceConstantHelper(packageName, libraryNames, className, baseClassName, CD_constantsHelper);\n+        helper.classBegin();\n@@ -182,1 +185,1 @@\n-    public List<JavaFileObject> getClasses() {\n+    public List<JavaFileObject> build() {\n@@ -184,2 +187,1 @@\n-        JavaFileObject result = newJavaFileObject(constantClassName, sb.toString());\n-        sb = null;\n+        JavaFileObject result = newJavaFileObject(className, builder.build());\n@@ -189,25 +191,3 @@\n-    \/\/ Internals only below this point\n-    private void emitConstructor() {\n-        \/\/ emit private constructor to prevent construction objects\n-        incrAlign();\n-        indent();\n-        append(constantClassName);\n-        append(\"() {}\\n\");\n-        decrAlign();\n-    }\n-\n-    private void classBegin(String[] libraryNames, String baseClassName, boolean isFinal) {\n-        addPackagePrefix(pkgName);\n-        addImportSection();\n-        if (isFinal) {\n-            append(\"final \");\n-        }\n-        append(\"class \");\n-        append(constantClassName);\n-        if (baseClassName != null) {\n-            append(\" extends \");\n-            append(baseClassName);\n-        }\n-        append(\" {\\n\");\n-        emitConstructor();\n-        if (baseClassName == null) { \/\/ only for the first one\n+    protected void classBegin() {\n+        super.classBegin();\n+        if (superClass() == null) { \/\/ only for the first one\n@@ -218,2 +198,3 @@\n-    private void classEnd() {\n-        append(\"}\\n\");\n+    protected JavaSourceBuilder classEnd() {\n+        builder.append(\"}\\n\");\n+        return null;\n@@ -231,10 +212,10 @@\n-        incrAlign();\n-        indent();\n-        append(PKG_STATIC_FINAL_MODS);\n-        append(type.getName());\n-        append(' ');\n-        append(name);\n-        append(\"() { return \");\n-        append(value);\n-        append(\"; }\\n\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PKG_STATIC_FINAL_MODS);\n+        builder.append(type.getName());\n+        builder.append(' ');\n+        builder.append(name);\n+        builder.append(\"() { return \");\n+        builder.append(value);\n+        builder.append(\"; }\\n\\n\");\n+        builder.decrAlign();\n@@ -244,48 +225,0 @@\n-    private void addPackagePrefix(String pkgName) {\n-        append(\"\/\/ Generated by jextract\\n\\n\");\n-        if (!pkgName.isEmpty()) {\n-            append(\"package \");\n-            append(pkgName);\n-            append(\";\\n\\n\");\n-        }\n-    }\n-\n-    private void addImportSection() {\n-        append(\"import java.lang.invoke.MethodHandle;\\n\");\n-        append(\"import java.lang.invoke.VarHandle;\\n\");\n-        append(\"import jdk.incubator.foreign.*;\\n\");\n-        append(\"import jdk.incubator.foreign.MemoryLayout.PathElement;\\n\");\n-        append(\"import static \");\n-        append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n-        append(\".*;\\n\\n\");\n-    }\n-\n-    private void append(String s) {\n-        sb.append(s);\n-    }\n-\n-    private void append(char c) {\n-        sb.append(c);\n-    }\n-\n-    private void append(long l) {\n-        sb.append(l);\n-    }\n-\n-    private void append(boolean b) {\n-        sb.append(b);\n-    }\n-\n-    private void indent() {\n-        for (int i = 0; i < align; i++) {\n-            append(\"    \");\n-        }\n-    }\n-\n-    private void incrAlign() {\n-        align++;\n-    }\n-    private void decrAlign() {\n-        align--;\n-    }\n-\n@@ -299,1 +232,1 @@\n-        incrAlign();\n+        builder.incrAlign();\n@@ -301,12 +234,12 @@\n-        indent();\n-        append(PKG_STATIC_FINAL_MODS + \"MethodHandle \");\n-        append(fieldName + \" = RuntimeHelper.downcallHandle(\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n-        append(\",\\n\");\n-        indent();\n-        append(\"\\\"\" + mtype.toMethodDescriptorString() + \"\\\",\\n\");\n-        indent();\n-        append(getFunctionDescFieldName(javaName));\n-        append(\", \");\n+        builder.indent();\n+        builder.append(PKG_STATIC_FINAL_MODS + \"MethodHandle \");\n+        builder.append(fieldName + \" = RuntimeHelper.downcallHandle(\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+        builder.append(\",\\n\");\n+        builder.indent();\n+        builder.append(\"\\\"\" + mtype.toMethodDescriptorString() + \"\\\",\\n\");\n+        builder.indent();\n+        builder.append(getFunctionDescFieldName(javaName));\n+        builder.append(\", \");\n@@ -314,6 +247,6 @@\n-        append(varargs);\n-        append(\"\\n\");\n-        decrAlign();\n-        indent();\n-        append(\");\\n\");\n-        decrAlign();\n+        builder.append(varargs);\n+        builder.append(\"\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\");\\n\");\n+        builder.decrAlign();\n@@ -329,1 +262,1 @@\n-        incrAlign();\n+        builder.incrAlign();\n@@ -335,1 +268,1 @@\n-        indent();\n+        builder.indent();\n@@ -337,1 +270,1 @@\n-        append(PKG_STATIC_FINAL_MODS + \"VarHandle \" + fieldName + \" = \");\n+        builder.append(PKG_STATIC_FINAL_MODS + \"VarHandle \" + fieldName + \" = \");\n@@ -339,1 +272,1 @@\n-            append(\"MemoryHandles.asAddressVarHandle(\");\n+            builder.append(\"MemoryHandles.asAddressVarHandle(\");\n@@ -341,2 +274,2 @@\n-        append(getLayoutFieldName(parentJavaName != null ? parentJavaName : javaName));\n-        append(\".varHandle(\" + typeName + \".class\");\n+        builder.append(getLayoutFieldName(parentJavaName != null ? parentJavaName : javaName));\n+        builder.append(\".varHandle(\" + typeName + \".class\");\n@@ -344,1 +277,1 @@\n-            append(\", MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n+            builder.append(\", MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n@@ -346,1 +279,1 @@\n-        append(\")\");\n+        builder.append(\")\");\n@@ -348,1 +281,1 @@\n-            append(\")\");\n+            builder.append(\")\");\n@@ -350,2 +283,2 @@\n-        append(\";\\n\");\n-        decrAlign();\n+        builder.append(\";\\n\");\n+        builder.decrAlign();\n@@ -361,3 +294,3 @@\n-        incrAlign();\n-        indent();\n-        append(PKG_STATIC_FINAL_MODS + \"MemoryLayout \" + fieldName + \" = \");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PKG_STATIC_FINAL_MODS + \"MemoryLayout \" + fieldName + \" = \");\n@@ -365,2 +298,2 @@\n-        append(\";\\n\");\n-        decrAlign();\n+        builder.append(\";\\n\");\n+        builder.decrAlign();\n@@ -372,1 +305,1 @@\n-            append(typeToLayoutName((ValueLayout) l));\n+            builder.append(typeToLayoutName((ValueLayout) l));\n@@ -374,1 +307,1 @@\n-            append(\"MemoryLayout.ofSequence(\");\n+            builder.append(\"MemoryLayout.ofSequence(\");\n@@ -376,1 +309,1 @@\n-                append(((SequenceLayout) l).elementCount().getAsLong() + \", \");\n+                builder.append(((SequenceLayout) l).elementCount().getAsLong() + \", \");\n@@ -379,1 +312,1 @@\n-            append(\")\");\n+            builder.append(\")\");\n@@ -382,1 +315,1 @@\n-                append(\"MemoryLayout.ofStruct(\\n\");\n+                builder.append(\"MemoryLayout.ofStruct(\\n\");\n@@ -384,1 +317,1 @@\n-                append(\"MemoryLayout.ofUnion(\\n\");\n+                builder.append(\"MemoryLayout.ofUnion(\\n\");\n@@ -386,1 +319,1 @@\n-            incrAlign();\n+            builder.incrAlign();\n@@ -389,2 +322,2 @@\n-                append(delim);\n-                indent();\n+                builder.append(delim);\n+                builder.indent();\n@@ -394,4 +327,4 @@\n-            append(\"\\n\");\n-            decrAlign();\n-            indent();\n-            append(\")\");\n+            builder.append(\"\\n\");\n+            builder.decrAlign();\n+            builder.indent();\n+            builder.append(\")\");\n@@ -400,1 +333,1 @@\n-            append(\"MemoryLayout.ofPaddingBits(\" + l.bitSize() + \")\");\n+            builder.append(\"MemoryLayout.ofPaddingBits(\" + l.bitSize() + \")\");\n@@ -403,1 +336,1 @@\n-            append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n+            builder.append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n@@ -412,2 +345,2 @@\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n@@ -416,4 +349,4 @@\n-        append(PKG_STATIC_FINAL_MODS);\n-        append(\"FunctionDescriptor \");\n-        append(fieldName);\n-        append(\" = \");\n+        builder.append(PKG_STATIC_FINAL_MODS);\n+        builder.append(\"FunctionDescriptor \");\n+        builder.append(fieldName);\n+        builder.append(\" = \");\n@@ -421,1 +354,1 @@\n-            append(\"FunctionDescriptor.of(\");\n+            builder.append(\"FunctionDescriptor.of(\");\n@@ -424,1 +357,1 @@\n-                append(\",\");\n+                builder.append(\",\");\n@@ -427,1 +360,1 @@\n-            append(\"FunctionDescriptor.ofVoid(\");\n+            builder.append(\"FunctionDescriptor.ofVoid(\");\n@@ -430,2 +363,2 @@\n-            append(\"\\n\");\n-            incrAlign();\n+            builder.append(\"\\n\");\n+            builder.incrAlign();\n@@ -434,2 +367,2 @@\n-                append(delim);\n-                indent();\n+                builder.append(delim);\n+                builder.indent();\n@@ -439,3 +372,3 @@\n-            append(\"\\n\");\n-            decrAlign();\n-            indent();\n+            builder.append(\"\\n\");\n+            builder.decrAlign();\n+            builder.indent();\n@@ -443,2 +376,2 @@\n-        append(\");\\n\");\n-        decrAlign();\n+        builder.append(\");\\n\");\n+        builder.decrAlign();\n@@ -452,2 +385,2 @@\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n@@ -455,7 +388,7 @@\n-        append(PKG_STATIC_FINAL_MODS);\n-        append(\"MemorySegment \");\n-        append(fieldName);\n-        append(\" = CLinker.toCString(\\\"\");\n-        append(Utils.quote(Objects.toString(value)));\n-        append(\"\\\");\\n\");\n-        decrAlign();\n+        builder.append(PKG_STATIC_FINAL_MODS);\n+        builder.append(\"MemorySegment \");\n+        builder.append(fieldName);\n+        builder.append(\" = CLinker.toCString(\\\"\");\n+        builder.append(Utils.quote(Objects.toString(value)));\n+        builder.append(\"\\\");\\n\");\n+        builder.decrAlign();\n@@ -469,2 +402,2 @@\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n@@ -472,7 +405,7 @@\n-        append(PKG_STATIC_FINAL_MODS);\n-        append(\"MemoryAddress \");\n-        append(fieldName);\n-        append(\" = MemoryAddress.ofLong(\");\n-        append(((Number)value).longValue());\n-        append(\"L);\\n\");\n-        decrAlign();\n+        builder.append(PKG_STATIC_FINAL_MODS);\n+        builder.append(\"MemoryAddress \");\n+        builder.append(fieldName);\n+        builder.append(\" = MemoryAddress.ofLong(\");\n+        builder.append(((Number)value).longValue());\n+        builder.append(\"L);\\n\");\n+        builder.decrAlign();\n@@ -527,2 +460,2 @@\n-         incrAlign();\n-         indent();\n+         builder.incrAlign();\n+         builder.indent();\n@@ -530,11 +463,11 @@\n-         append(PKG_STATIC_FINAL_MODS);\n-         append(\"MemorySegment \");\n-         append(fieldName);\n-         append(\" = \");\n-         append(\"RuntimeHelper.lookupGlobalVariable(\");\n-         append(\"LIBRARIES, \\\"\");\n-         append(nativeName);\n-         append(\"\\\", \");\n-         append(getLayoutFieldName(javaName));\n-         append(\");\\n\");\n-         decrAlign();\n+         builder.append(PKG_STATIC_FINAL_MODS);\n+         builder.append(\"MemorySegment \");\n+         builder.append(fieldName);\n+         builder.append(\" = \");\n+         builder.append(\"RuntimeHelper.lookupGlobalVariable(\");\n+         builder.append(\"LIBRARIES, \\\"\");\n+         builder.append(nativeName);\n+         builder.append(\"\\\", \");\n+         builder.append(getLayoutFieldName(javaName));\n+         builder.append(\");\\n\");\n+         builder.decrAlign();\n@@ -545,5 +478,5 @@\n-        incrAlign();\n-        indent();\n-        append(PKG_STATIC_FINAL_MODS);\n-        append(\"LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\\n\");\n-        incrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PKG_STATIC_FINAL_MODS);\n+        builder.append(\"LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\\n\");\n+        builder.incrAlign();\n@@ -551,4 +484,4 @@\n-            indent();\n-            append('\\\"');\n-            append(quoteLibraryName(lib));\n-            append(\"\\\",\\n\");\n+            builder.indent();\n+            builder.append('\\\"');\n+            builder.append(quoteLibraryName(lib));\n+            builder.append(\"\\\",\\n\");\n@@ -556,4 +489,4 @@\n-        decrAlign();\n-        indent();\n-        append(\"});\\n\\n\");\n-        decrAlign();\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"});\\n\\n\");\n+        builder.decrAlign();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/SourceConstantHelper.java","additions":146,"deletions":213,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+public class StringSourceBuilder {\n+\n+    \/\/ code buffer\n+    private StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    void append(String s) {\n+        sb.append(s);\n+    }\n+\n+    void append(char c) {\n+        sb.append(c);\n+    }\n+\n+    void append(boolean b) {\n+        sb.append(b);\n+    }\n+\n+    void append(long l) {\n+        sb.append(l);\n+    }\n+\n+    void indent() {\n+        for (int i = 0; i < align; i++) {\n+            append(\"    \");\n+        }\n+    }\n+\n+    void incrAlign() {\n+        align++;\n+    }\n+\n+    void decrAlign() {\n+        align--;\n+    }\n+\n+    String build() {\n+        String s = sb.toString();\n+        sb = null;\n+        return s;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StringSourceBuilder.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-class StructBuilder extends JavaSourceBuilder {\n+class StructBuilder extends NestedClassBuilder {\n@@ -37,1 +37,0 @@\n-    private final JavaSourceBuilder prev;\n@@ -43,0 +42,1 @@\n+    private final Type structType;\n@@ -44,4 +44,3 @@\n-    StructBuilder(JavaSourceBuilder prev, String className, String parentLayoutFieldName, MemoryLayout parentLayout,\n-            String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter, Type structType) {\n-        super(prev.uniqueNestedClassName(className), pkgName, constantHelper);\n-        this.prev = prev;\n+    StructBuilder(JavaSourceBuilder enclosing, String className, String parentLayoutFieldName,\n+                  MemoryLayout parentLayout, Type structType) {\n+        super(enclosing, Kind.CLASS, className);\n@@ -53,44 +52,1 @@\n-    }\n-\n-    JavaSourceBuilder prev() {\n-        return prev;\n-    }\n-\n-    @Override\n-    void append(String s) {\n-        prev.append(s);\n-    }\n-\n-    @Override\n-    void append(char c) {\n-        prev.append(c);\n-    }\n-\n-    @Override\n-    void append(long l) {\n-        prev.append(l);\n-    }\n-\n-    @Override\n-    void indent() {\n-        prev.indent();\n-    }\n-\n-    @Override\n-    void incrAlign() {\n-        prev.incrAlign();\n-    }\n-\n-    @Override\n-    void decrAlign() {\n-        prev.decrAlign();\n-    }\n-\n-    @Override\n-    protected String getClassModifiers() {\n-        return PUB_MODS;\n-    }\n-\n-    @Override\n-    protected void addPackagePrefix() {\n-        \/\/ nested class. containing class has necessary package declaration\n+        this.structType = structType;\n@@ -100,2 +56,2 @@\n-    protected void addImportSection() {\n-        \/\/ nested class. containing class has necessary imports\n+    Type type() {\n+        return structType;\n@@ -124,10 +80,10 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS + displayName(desc.invocationType().returnType()) + \" \" + javaName + \"$VH() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return \" + getCallString(desc) + \";\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + displayName(desc.invocationType().returnType()) + \" \" + javaName + \"$VH() {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return \" + getCallString(desc) + \";\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -139,10 +95,10 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS + displayName(desc.invocationType().returnType()) + \" $LAYOUT() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return \" + getCallString(desc) + \";\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + displayName(desc.invocationType().returnType()) + \" $LAYOUT() {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return \" + getCallString(desc) + \";\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -153,6 +109,6 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + this.structAnno + \" MemorySegment seg) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return (\" + type.getName() + \")\"\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + this.structAnno + \" MemorySegment seg) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return (\" + type.getName() + \")\"\n@@ -160,4 +116,4 @@\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -170,2 +126,2 @@\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n@@ -173,8 +129,8 @@\n-        append(PUB_MODS + \"void \" + javaName + \"$set(\" + this.structAnno + \" \" + param + \", \" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) + \".set(seg, x);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + this.structAnno + \" \" + param + \", \" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) + \".set(seg, x);\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -187,14 +143,14 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS + \"MemorySegment \" + javaName + \"$slice(MemorySegment seg) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(\");\n-        append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));\n-        append(\", \");\n-        append(layout.byteSize());\n-        append(\"));\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS + \"MemorySegment \" + javaName + \"$slice(MemorySegment seg) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(\");\n+        builder.append(parentLayout.byteOffset(MemoryLayout.PathElement.groupElement(nativeName)));\n+        builder.append(\", \");\n+        builder.append(layout.byteSize());\n+        builder.append(\"));\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -205,5 +161,5 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(\"long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(\"long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n+        builder.decrAlign();\n@@ -213,5 +169,5 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(structAnno + \" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(structAnno + \" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n+        builder.decrAlign();\n@@ -221,5 +177,5 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(structAnno + \" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(structAnno + \" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n+        builder.decrAlign();\n@@ -229,11 +185,11 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(structArrayAnno + \" MemorySegment allocateArray(int len) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n-        decrAlign();\n-        indent();\n-        append('}');\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(structArrayAnno + \" MemorySegment allocateArray(int len) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append('}');\n+        builder.decrAlign();\n@@ -243,11 +199,11 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(structArrayAnno + \" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(structArrayAnno + \" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -257,11 +213,11 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(structPtrAnno + \" MemorySegment allocatePointer() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(structPtrAnno + \" MemorySegment allocatePointer() {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -271,11 +227,11 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(structPtrAnno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return scope.allocate(C_POINTER);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(structPtrAnno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return scope.allocate(C_POINTER);\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -285,5 +241,5 @@\n-        incrAlign();\n-        indent();\n-        append(PUB_MODS);\n-        append(structAnno + \" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n-        decrAlign();\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(structAnno + \" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n+        builder.decrAlign();\n@@ -293,2 +249,2 @@\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n@@ -296,4 +252,4 @@\n-        append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return (\" + type.getName() + \")\"\n+        builder.append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return (\" + type.getName() + \")\"\n@@ -302,4 +258,4 @@\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n@@ -309,2 +265,2 @@\n-        incrAlign();\n-        indent();\n+        builder.incrAlign();\n+        builder.indent();\n@@ -312,4 +268,4 @@\n-        append(PUB_MODS + \"void \" + javaName + \"$set(\" + params + \") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) +\n+        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + params + \") {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) +\n@@ -317,4 +273,4 @@\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":146,"deletions":190,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.invoke.MethodType;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+class ToplevelBuilder extends HeaderFileBuilder {\n+\n+    private int declCount;\n+\n+    static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n+\n+    ToplevelBuilder(String headerFileName, String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n+        super(headerFileName, pkgName, null, constantHelper, annotationWriter);\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return \"#{SUPER}\";\n+    }\n+\n+    @Override\n+    protected String getClassModifiers() {\n+        return PUB_CLS_MODS;\n+    }\n+\n+    List<JavaFileObject> build() {\n+        String res = builder.build().replace(\"extends #{SUPER}\",\n+                lastHeader().map(h -> \"extends \" + h.className).orElse(\"\"));\n+        List<JavaFileObject> files = new ArrayList<>();\n+        files.add(Utils.fileFromString(pkgName, className, res));\n+        files.addAll(constantHelper.build());\n+        files.addAll(headers.stream()\n+                .flatMap(hf -> hf.build().stream())\n+                .collect(Collectors.toList()));\n+        return files;\n+    }\n+\n+    void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc, Type type) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, mtype, desc, type);\n+        builder.classBegin();\n+        builder.classEnd();\n+    }\n+\n+    void addTypeDef(String name, String superClass, Type type) {\n+        TypedefBuilder builder = new TypedefBuilder(this, name, superClass, type);\n+        builder.classBegin();\n+        builder.classEnd();\n+    }\n+\n+    private List<HeaderFileBuilder> headers = new ArrayList<>();\n+\n+    Optional<HeaderFileBuilder> lastHeader() {\n+        return headers.size() == 0 ?\n+                Optional.empty() :\n+                Optional.of(headers.get(headers.size() - 1));\n+    }\n+\n+    HeaderFileBuilder nextHeader() {\n+        if (declCount > DECLS_PER_HEADER_CLASS) {\n+            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(className + \"$\" + headers.size(), pkgName,\n+                    lastHeader().map(h -> h.className).orElse(null),\n+                    constantHelper, annotationWriter);\n+            headerFileBuilder.classBegin();\n+            headers.add(headerFileBuilder);\n+            declCount = 1;\n+            return headerFileBuilder;\n+        } else {\n+            declCount++;\n+            return lastHeader().orElse(this);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Type;\n+\n+public class TypedefBuilder extends NestedClassBuilder {\n+\n+    private final Type type;\n+    private final String superClass;\n+\n+    public TypedefBuilder(JavaSourceBuilder prev, String className, String superClass, Type type) {\n+        super(prev, Kind.CLASS, className);\n+        this.type = type;\n+        this.superClass = superClass;\n+    }\n+\n+    @Override\n+    Type type() {\n+        return type;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superClass;\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        if (superClass == null) {\n+            emitAllocatePointerMethods();\n+        }\n+        return super.classEnd();\n+    }\n+\n+    void emitAllocatePointerMethods() {\n+        String anno = annotationWriter.getCAnnotation(Type.pointer(type));\n+        \/\/ allocatePointer\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(anno + \" MemorySegment allocatePointer() {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n+\n+        \/\/ allocatePointer (scope version)\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(PUB_MODS);\n+        builder.append(anno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        builder.incrAlign();\n+        builder.indent();\n+        builder.append(\"return scope.allocate(C_POINTER);\\n\");\n+        builder.decrAlign();\n+        builder.indent();\n+        builder.append(\"}\\n\");\n+        builder.decrAlign();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -74,0 +74,1 @@\n+        f.setAccessible(true);\n","filename":"test\/jdk\/tools\/jextract\/ConstantsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}