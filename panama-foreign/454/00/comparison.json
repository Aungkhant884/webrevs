{"files":[{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+public class StrLenTest {\n+\n+    NativeScope scope = NativeScope.unboundedScope();\n+\n+    @Param({\"5\", \"20\", \"100\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"StrLen\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+    static final MethodHandle STRLEN_TRIVIAL;\n+    static final MethodHandle MALLOC_TRIVIAL;\n+    static final MethodHandle FREE_TRIVIAL;\n+\n+    static {\n+        LibraryLookup lookup = LibraryLookup.ofDefault();\n+        CLinker abi = CLinker.getInstance();\n+        STRLEN = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+        STRLEN_TRIVIAL = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+        MALLOC_TRIVIAL = abi.downcallHandle(lookup.lookup(\"malloc\").get(),\n+                MethodType.methodType(MemoryAddress.class, long.class),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+\n+        FREE_TRIVIAL = abi.downcallHandle(lookup.lookup(\"free\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    public int jni_strlen() throws Throwable {\n+        return strlen(str);\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen() throws Throwable {\n+        try (MemorySegment segment = CLinker.toCString(str)) {\n+            return (int)STRLEN.invokeExact(segment.address());\n+        }\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_scope() throws Throwable {\n+        return (int)STRLEN.invokeExact(CLinker.toCString(str, scope).address());\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_unsafe() throws Throwable {\n+        MemoryAddress address = makeStringUnsafe(str);\n+        int res = (int) STRLEN.invokeExact(address);\n+        CLinker.freeMemoryRestricted(address);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_unsafe_trivial() throws Throwable {\n+        MemoryAddress address = makeStringUnsafeTrivial(str);\n+        int res = (int) STRLEN_TRIVIAL.invokeExact(address);\n+        FREE_TRIVIAL.invokeExact(address);\n+        return res;\n+    }\n+\n+    static MemoryAddress makeStringUnsafe(String s) {\n+        byte[] bytes = s.getBytes();\n+        int len = bytes.length;\n+        MemoryAddress address = CLinker.allocateMemoryRestricted(len + 1);\n+        MemorySegment str = address.asSegmentRestricted(len + 1);\n+        str.copyFrom(MemorySegment.ofArray(bytes));\n+        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        return address;\n+    }\n+\n+    static MemoryAddress makeStringUnsafeTrivial(String s) throws Throwable {\n+        byte[] bytes = s.getBytes();\n+        int len = bytes.length;\n+        MemoryAddress address = (MemoryAddress)MALLOC_TRIVIAL.invokeExact((long)len + 1);\n+        MemorySegment str = address.asSegmentRestricted(len + 1);\n+        str.copyFrom(MemorySegment.ofArray(bytes));\n+        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        return address;\n+    }\n+\n+    static native int strlen(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_StrLenTest_strlen(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    int len = strlen(str);\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return len;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libStrLen.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"}]}