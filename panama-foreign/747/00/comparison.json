{"files":[{"patch":"@@ -1710,0 +1710,98 @@\n+    \/**\n+     * Reads a byte from this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a byte value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default byte getAtIndex(ValueLayout.OfByte layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    \/**\n+     * Writes a byte into this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfByte layout, long index, byte value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    \/**\n+     * Reads a boolean from this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a boolean value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default boolean getAtIndex(ValueLayout.OfBoolean layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    \/**\n+     * Writes a boolean into this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @param value the boolean value to be written.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfBoolean layout, long index, boolean value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"}]}