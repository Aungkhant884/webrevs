{"files":[{"patch":"@@ -120,2 +120,2 @@\n-                boolean source, String targetPkg, List<String> libNames) {\n-        return List.of(OutputFactory.generateWrapped(decl, headerName, source, targetPkg, libNames));\n+                                                String targetPkg, List<String> libNames) {\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, libNames));\n@@ -257,1 +257,1 @@\n-                toplevel, header.getFileName().toString(), options.source,\n+                toplevel, header.getFileName().toString(),\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/JextractTool.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,570 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.LibraryLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ConstantDynamic;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Type;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.Constable;\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DirectMethodHandleDesc.Kind;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-import java.net.URI;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.invoke.MethodHandleInfo.*;\n-import static java.lang.invoke.MethodType.methodType;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n-\/\/ generates ConstantHelper as java .class directly\n-class ClassConstantHelper implements ConstantHelper {\n-\n-    private static final String INTR_OBJECT = Type.getInternalName(Object.class);\n-\n-    private static final ClassDesc CD_LIBRARIES = desc(LibraryLookup[].class);\n-\n-    private static final DirectMethodHandleDesc MH_MemoryLayout_varHandle = MethodHandleDesc.ofMethod(\n-            Kind.INTERFACE_VIRTUAL,\n-            desc(MemoryLayout.class),\n-            \"varHandle\",\n-            desc(methodType(\n-                    VarHandle.class,\n-                    Class.class,\n-                    MemoryLayout.PathElement[].class))\n-    );\n-\n-    private static final DirectMethodHandleDesc MH_PathElement_groupElement = MethodHandleDesc.ofMethod(\n-            Kind.INTERFACE_STATIC,\n-            desc(MemoryLayout.PathElement.class),\n-            \"groupElement\",\n-            desc(methodType(MemoryLayout.PathElement.class, String.class))\n-    );\n-\n-    private static final DirectMethodHandleDesc MH_MemoryAddress_ofLong = MethodHandleDesc.ofMethod(\n-            Kind.INTERFACE_STATIC,\n-            desc(MemoryAddress.class),\n-            \"ofLong\",\n-            desc(methodType(MemoryAddress.class, long.class))\n-    );\n-\n-    private static final DirectMethodHandleDesc MH_MemoryHandles_asAddressVarHandle = MethodHandleDesc.ofMethod(\n-            Kind.STATIC,\n-            desc(MemoryHandles.class),\n-            \"asAddressVarHandle\",\n-            desc(methodType(VarHandle.class, VarHandle.class))\n-    );\n-\n-    private static final ClassDesc CD_PathElelemt = desc(MemoryLayout.PathElement.class);\n-    private static final ClassDesc CD_MemoryAddress = desc(MemoryAddress.class);\n-    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);\n-\n-    private final DirectMethodHandleDesc MH_downcallHandle;\n-    private final DirectMethodHandleDesc MH_lookupGlobalVariable;\n-    private final DirectMethodHandleDesc MH_makeCString;\n-\n-    private ClassWriter cw;\n-    private final String internalClassName;\n-    private final ClassDesc CD_constantsHelper;\n-    private final ConstantDesc LIBRARIES;\n-\n-    private final Map<String, DirectMethodHandleDesc> pool = new HashMap<>();\n-\n-    private static final Map<Class<?>, ClassDesc> CARRIERS = Map.ofEntries(\n-            Map.entry(Byte.TYPE,                desc(Byte.TYPE)),\n-            Map.entry(Short.TYPE,               desc(Short.TYPE)),\n-            Map.entry(Character.TYPE,           desc(Character.TYPE)),\n-            Map.entry(Integer.TYPE,             desc(Integer.TYPE)),\n-            Map.entry(Long.TYPE,                desc(Long.TYPE)),\n-            Map.entry(Float.TYPE,               desc(Float.TYPE)),\n-            Map.entry(Double.TYPE,              desc(Double.TYPE)),\n-            Map.entry(MemoryAddress.class,      desc(Long.TYPE))\n-    );\n-\n-    public ClassConstantHelper(ClassWriter cw, ClassDesc CD_constantsHelper, String internalClassName,\n-            DirectMethodHandleDesc MH_downcallHandle, DirectMethodHandleDesc MH_lookupGlobalVariable,\n-            DirectMethodHandleDesc MH_makeCString, ConstantDesc LIBRARIES) {\n-        this.cw = cw;\n-        this.MH_downcallHandle = MH_downcallHandle;\n-        this.MH_lookupGlobalVariable = MH_lookupGlobalVariable;\n-        this.MH_makeCString = MH_makeCString;\n-        this.internalClassName = internalClassName;\n-        this.CD_constantsHelper = CD_constantsHelper;\n-        this.LIBRARIES = LIBRARIES;\n-    }\n-\n-    public static ConstantHelper make(String packageName, String className, ClassDesc runtimeHelper, ClassDesc cString,\n-                                      String[] libraryNames, String baseClassName) {\n-        String qualName = Utils.qualifiedClassName(packageName, className);\n-        String qualBaseName = baseClassName != null ? Utils.qualifiedClassName(packageName, baseClassName) : null;\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        ClassDesc CD_constantsHelper = ClassDesc.of(qualName);\n-        String internalClassName = toInternalName(qualName);\n-\n-        DirectMethodHandleDesc MH_downcallHandle = findRuntimeHelperBootstrap(\n-                runtimeHelper,\n-                \"downcallHandle\",\n-                methodType(\n-                        MethodHandle.class,\n-                        LibraryLookup[].class,\n-                        String.class,\n-                        String.class,\n-                        FunctionDescriptor.class,\n-                        boolean.class)\n-        );\n-        DirectMethodHandleDesc MH_lookupGlobalVariable = findRuntimeHelperBootstrap(\n-                runtimeHelper,\n-                \"lookupGlobalVariable\",\n-                methodType(\n-                        MemorySegment.class,\n-                        LibraryLookup[].class,\n-                        String.class,\n-                        MemoryLayout.class)\n-        );\n-        DirectMethodHandleDesc MH_makeCString = MethodHandleDesc.ofMethod(\n-                Kind.INTERFACE_STATIC,\n-                cString,\n-                \"toCString\",\n-                desc(methodType(MemorySegment.class, String.class))\n-        );\n-\n-        ConstantDesc LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(\n-                runtimeHelper,\n-                \"libraries\",\n-                methodType(\n-                        LibraryLookup[].class,\n-                        String[].class)\n-        ), libraryNames);\n-\n-        ClassConstantHelper helper = new ClassConstantHelper(cw, CD_constantsHelper, internalClassName,\n-                MH_downcallHandle, MH_lookupGlobalVariable, MH_makeCString, LIBRARIES);\n-        helper.classBegin(qualBaseName);\n-        return helper;\n-    }\n-\n-    private static String toInternalName(String className) {\n-        return className.replace('.', '\/');\n-    }\n-\n-    private void classBegin(String baseClassName) {\n-        String baseName = baseClassName != null ? toInternalName(baseClassName) : INTR_OBJECT;\n-        cw.visit(V16, 0, internalClassName, null, baseName, null);\n-    }\n-\n-    private static DirectMethodHandleDesc findRuntimeHelperBootstrap(ClassDesc runtimeHelper, String name, MethodType type) {\n-        return MethodHandleDesc.ofMethod(\n-                Kind.STATIC,\n-                runtimeHelper,\n-                name,\n-                desc(type)\n-        );\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {\n-        return emitCondyGetter(javaName + \"$LAYOUT\", MemoryLayout.class, desc(layout));\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout,\n-                                                    Class<?> type, String ignored, MemoryLayout rootLayout,\n-                                                    List<String> prefixElementNames) {\n-        return addVarHandle(javaName, nativeName, layout, type, rootLayout, prefixElementNames);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        return addVarHandle(javaName, nativeName, layout, type, null, List.of());\n-    }\n-\n-    private DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type,\n-                                                MemoryLayout rootLayout, List<String> prefixElementNames) {\n-        return emitCondyGetter(javaName + \"$VH\", VarHandle.class,\n-                varHandleDesc(javaName, nativeName, layout, type, rootLayout, prefixElementNames));\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n-        return emitCondyGetter(javaName + \"$MH\", MethodHandle.class, methodHandleDesc(nativeName, mtype, desc, varargs));\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {\n-        return emitCondyGetter(javaName + \"$SEGMENT\", MemorySegment.class, globalVarAddressDesc(nativeName, layout));\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {\n-        return emitCondyGetter(javaName + \"$DESC\", FunctionDescriptor.class, desc(fDesc));\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {\n-        if (type == MemoryAddress.class) {\n-            if (value instanceof Long) {\n-                return emitCondyGetter(name, type, addressDesc((Long) value));\n-            } else {\n-                throw new IllegalStateException(\"Unhandled constant value type: \" + value.getClass());\n-            }\n-        } else if (type == MemorySegment.class) {\n-            if (value instanceof String) {\n-                return emitCondyGetter(name, type, cStringDesc((String) value));\n-            } else {\n-                throw new IllegalStateException(\"Unhandled constant value type: \" + value.getClass());\n-            }\n-        } else if (type.isPrimitive()) {\n-            if (type == int.class || type == byte.class || type == short.class || type == char.class) {\n-                return emitConIntGetter(name, type, ((Long) value).intValue());\n-            } else if (type == float.class) {\n-                return emitConFloatGetter(name, type, ((Double) value).floatValue());\n-            } else if (type == long.class) {\n-                return emitConLongGetter(name, type, (Long) value);\n-            } else if (type == double.class) {\n-                return emitConDoubleGetter(name, type, (Double) value);\n-            } else { \/\/ boolean and void\n-                throw new IllegalStateException(\"Unhandled primitive target type: \" + type);\n-            }\n-        } else if (type == value.getClass() && value instanceof Constable) {\n-            \/\/ Constable value that requires no conversion\n-            return emitCondyGetter(name, type, desc((Constable) value));\n-        } else {\n-            System.out.println(\"Warning: Skipping constant generation for: \" + name + \" of type: \" + type.getSimpleName()\n-                + \" with value: \" + value + \" of type: \" + value.getClass());\n-            return null;\n-        }\n-    }\n-\n-    @Override\n-    public List<JavaFileObject> build() {\n-        cw.visitEnd();\n-        byte[] bytes = cw.toByteArray();\n-        cw = null;\n-        return List.of(jfoFromByteArray(internalClassName, bytes));\n-    }\n-\n-    \/\/ Utility\n-\n-    private static JavaFileObject jfoFromByteArray(String name, byte[] bytes) {\n-        return InMemoryJavaCompiler.jfoFromByteArray(URI.create(name + \".class\"), bytes);\n-    }\n-\n-    private static String descriptorToInternalName(String s) {\n-        return s.substring(1, s.length() - 1);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T extends ConstantDesc> T desc(Constable constable) {\n-        return (T) constable.describeConstable().orElseThrow();\n-    }\n-\n-    \/\/ ASM helpers\n-\n-    private static void emitConShort(MethodVisitor mv, short value) {\n-        if (value >= -1 && value <= 5) {\n-            mv.visitInsn(\n-                switch (value) {\n-                    case -1 -> ICONST_M1;\n-                    case 0 -> ICONST_0;\n-                    case 1 -> ICONST_1;\n-                    case 2 -> ICONST_2;\n-                    case 3 -> ICONST_3;\n-                    case 4 -> ICONST_4;\n-                    case 5 -> ICONST_5;\n-                    default -> throw new IllegalStateException(\"Should not reach here\");\n-                });\n-        } else if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE) {\n-            mv.visitIntInsn(BIPUSH, value);\n-        } else {\n-            mv.visitIntInsn(SIPUSH, value);\n-        }\n-    }\n-\n-    private static void emitConInt(MethodVisitor mv, int value) {\n-        if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE) {\n-            emitConShort(mv, (short) value);\n-        } else {\n-            mv.visitLdcInsn(value);\n-        }\n-    }\n-\n-    private static void emitConLong(MethodVisitor mv, long value) {\n-        if (value == 0) {\n-            mv.visitInsn(LCONST_0);\n-        } else if (value == 1) {\n-            mv.visitInsn(LCONST_1);\n-        } else if (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {\n-            \/\/ saves a constant pool slot\n-            emitConInt(mv, (int) value);\n-            mv.visitInsn(I2L);\n-        } else {\n-            mv.visitLdcInsn(value);\n-        }\n-    }\n-\n-    private static void emitConFloat(MethodVisitor mv, float value) {\n-        if (value == 0.0F) {\n-            mv.visitInsn(FCONST_0);\n-        } else if (value == 1.0F) {\n-            mv.visitInsn(FCONST_1);\n-        } else if (value == 2.0F) {\n-            mv.visitInsn(FCONST_2);\n-        } else if (value == (short) value) {\n-            emitConShort(mv, (short) value);\n-            mv.visitInsn(I2F);\n-        } else {\n-            mv.visitLdcInsn(value);\n-        }\n-    }\n-\n-    private static void emitConDouble(MethodVisitor mv, double value) {\n-        if (value == 0.0D) {\n-            mv.visitInsn(DCONST_0);\n-        } else if (value == 1.0D) {\n-            mv.visitInsn(DCONST_1);\n-        } else if (value == (short) value) {\n-            emitConShort(mv, (short) value);\n-            mv.visitInsn(I2D);\n-        } else if (value >= Float.MIN_VALUE && value <= Float.MAX_VALUE) {\n-            \/\/ saves a constant pool slot\n-            mv.visitLdcInsn((float) value);\n-            mv.visitInsn(F2D);\n-        } else {\n-            mv.visitLdcInsn(value);\n-        }\n-    }\n-\n-    private DirectMethodHandleDesc emitGetter(String name, Class<?> type, Consumer<MethodVisitor> action) {\n-        return pool.computeIfAbsent(name, nameKey -> {\n-            MethodType mt = methodType(type);\n-            MethodVisitor mv = cw.visitMethod(ACC_STATIC | ACC_FINAL, nameKey, mt.descriptorString(), null, null);\n-            mv.visitCode();\n-            action.accept(mv);\n-            emitReturn(mv, type);\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n-            return MethodHandleDesc.ofMethod(\n-                    Kind.STATIC,\n-                    CD_constantsHelper,\n-                    nameKey,\n-                    desc(mt)\n-            );\n-        });\n-    }\n-\n-    private DirectMethodHandleDesc emitConDoubleGetter(String name, Class<?> type, double value) {\n-        return emitGetter(name, type, mv -> emitConDouble(mv, value));\n-    }\n-\n-    private DirectMethodHandleDesc emitConLongGetter(String name, Class<?> type, long value) {\n-        return emitGetter(name, type, mv -> emitConLong(mv, value));\n-    }\n-\n-    private DirectMethodHandleDesc emitConFloatGetter(String name, Class<?> type, float value) {\n-        return emitGetter(name, type, mv -> emitConFloat(mv, value));\n-    }\n-\n-    private DirectMethodHandleDesc emitConIntGetter(String name, Class<?> type, int value) {\n-        return emitGetter(name, type, mv -> emitConInt(mv, value));\n-    }\n-\n-    private DirectMethodHandleDesc emitCondyGetter(String name, Class<?> type, ConstantDesc desc) {\n-        return emitGetter(name, type, mv -> mv.visitLdcInsn(asmConstant(desc)));\n-    }\n-\n-    private static void emitReturn(MethodVisitor mv, Class<?> type) {\n-        if (type == int.class\n-                || type == short.class\n-                || type == byte.class\n-                || type == char.class\n-                || type == boolean.class) {\n-            mv.visitInsn(IRETURN);\n-        } else if (type == long.class) {\n-            mv.visitInsn(LRETURN);\n-        } else if (type == float.class) {\n-            mv.visitInsn(FRETURN);\n-        } else if (type == double.class) {\n-            mv.visitInsn(DRETURN);\n-        } else if (type == void.class) {\n-            mv.visitInsn(RETURN);\n-        } else if (Object.class.isAssignableFrom(type)) {\n-            mv.visitInsn(ARETURN);\n-        } else {\n-            throw new IllegalArgumentException(\"Type not handled: \" + type);\n-        }\n-    }\n-\n-    \/\/ Condy factories\n-\n-    private static ConstantDesc librariesDesc(DirectMethodHandleDesc MH_libraries, String[] libraryNames) {\n-        ConstantDesc[] args = new ConstantDesc[libraryNames.length + 1];\n-        args[0] = MH_libraries;\n-        System.arraycopy(libraryNames, 0, args, 1, libraryNames.length);\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"libraries\", CD_LIBRARIES, args);\n-    }\n-\n-    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier, ConstantDesc[] path) {\n-        ConstantDesc[] args = new ConstantDesc[path.length + 3];\n-        args[0] = MH_MemoryLayout_varHandle;\n-        args[1] = memoryLayout;\n-        args[2] = carrier;\n-        System.arraycopy(path, 0, args, 3, path.length);\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"VH_\" + name, CD_VarHandle, args);\n-    }\n-\n-    private static ConstantDesc varHandleDesc(String name, ConstantDesc memoryLayout, ClassDesc carrier) {\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"VH_\" + name, CD_VarHandle, MH_MemoryLayout_varHandle, memoryLayout, carrier);\n-    }\n-\n-    private static ConstantDesc addressVarHandleDesc(String name, ConstantDesc varHandle) {\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"VH_\" + name, CD_VarHandle, MH_MemoryHandles_asAddressVarHandle, varHandle);\n-    }\n-\n-    private static ConstantDesc groupElementDesc(String fieldName) {\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"groupElement_\" + fieldName, CD_PathElelemt, MH_PathElement_groupElement, fieldName);\n-    }\n-\n-    private static ConstantDesc varHandleDesc(String javaName, String nativeName, MemoryLayout layout, Class<?> type,\n-                                              MemoryLayout rootLayout, List<String> prefixElementNames) {\n-        var carrier = CARRIERS.get(type);\n-        if (carrier == null) {\n-            carrier = desc(type);\n-        }\n-\n-        ConstantDesc varHandle;\n-        if (rootLayout != null) {\n-            ConstantDesc[] pathElems = new ConstantDesc[prefixElementNames.size() + 1];\n-            int i = 0;\n-            for (; i < prefixElementNames.size(); i++) {\n-                pathElems[i] = groupElementDesc(prefixElementNames.get(i));\n-            }\n-            pathElems[i] = groupElementDesc(nativeName);\n-            varHandle = varHandleDesc(javaName, desc(rootLayout), carrier, pathElems);\n-        } else {\n-            varHandle = varHandleDesc(javaName, desc(layout), carrier);\n-        }\n-\n-        return type == MemoryAddress.class ? addressVarHandleDesc(javaName, varHandle) : varHandle;\n-    }\n-\n-    private ConstantDesc globalVarAddressDesc(String name, MemoryLayout layout) {\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"ADDR_\" + name, CD_MemorySegment, MH_lookupGlobalVariable, LIBRARIES, name, desc(layout));\n-    }\n-\n-    private ConstantDesc addressDesc(long value) {\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"MA_\" + value, CD_MemoryAddress, MH_MemoryAddress_ofLong, value);\n-    }\n-\n-    private ConstantDesc cStringDesc(String value) {\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"CSTRING\", CD_MemorySegment, MH_makeCString, value);\n-    }\n-\n-    private ConstantDesc methodHandleDesc(String name, MethodType mtype, FunctionDescriptor funcDesc, boolean varargs) {\n-        return DynamicConstantDesc.ofNamed(BSM_INVOKE, \"MH_\" + name, CD_MethodHandle, MH_downcallHandle,\n-            LIBRARIES,\n-            name,\n-            mtype.descriptorString(),\n-            desc(funcDesc),\n-            desc(varargs));\n-    }\n-\n-    \/\/ To ASM constant translation\n-\n-    private static Handle asmHandle(DirectMethodHandleDesc desc) {\n-        int tag = switch(desc.refKind()) {\n-            case REF_getField         -> H_GETFIELD;\n-            case REF_getStatic        -> H_GETSTATIC;\n-            case REF_putField         -> H_PUTFIELD;\n-            case REF_putStatic        -> H_PUTSTATIC;\n-            case REF_invokeVirtual    -> H_INVOKEVIRTUAL;\n-            case REF_invokeStatic     -> H_INVOKESTATIC;\n-            case REF_invokeSpecial    -> H_INVOKESPECIAL;\n-            case REF_newInvokeSpecial -> H_NEWINVOKESPECIAL;\n-            case REF_invokeInterface  -> H_INVOKEINTERFACE;\n-            default -> throw new InternalError(\"Should not reach here\");\n-        };\n-        return new Handle(tag,\n-                descriptorToInternalName(desc.owner().descriptorString()),\n-                desc.methodName(),\n-                desc.lookupDescriptor(),\n-                desc.isOwnerInterface());\n-    }\n-\n-    private static ConstantDynamic asmCondy(DynamicConstantDesc<?> condy) {\n-        return new ConstantDynamic(\n-                condy.constantName(),\n-                condy.constantType().descriptorString(),\n-                asmHandle(condy.bootstrapMethod()),\n-                asmConstantArgs(condy.bootstrapArgs()));\n-    }\n-\n-    private static Object[] asmConstantArgs(ConstantDesc[] descs) {\n-        Object[] objects = new Object[descs.length];\n-        for (int i = 0; i < objects.length; i++) {\n-            objects[i] = asmConstant(descs[i]);\n-        }\n-        return objects;\n-    }\n-\n-    private static Object asmConstant(ConstantDesc desc) {\n-        if (desc instanceof DynamicConstantDesc<?>) {\n-            return asmCondy((DynamicConstantDesc<?>) desc);\n-        } else if (desc instanceof Integer\n-            || desc instanceof Float\n-            || desc instanceof Long\n-            || desc instanceof Double\n-            || desc instanceof String) {\n-            return desc;\n-        } else if (desc instanceof ClassDesc) {\n-            \/\/ Primitives should be caught above\n-            return Type.getType(((ClassDesc) desc).descriptorString());\n-        } else if (desc instanceof MethodTypeDesc) {\n-            return Type.getMethodType(((MethodTypeDesc) desc).descriptorString());\n-        } else if (desc instanceof DirectMethodHandleDesc) {\n-            return asmHandle((DirectMethodHandleDesc) desc);\n-        }\n-        throw new IllegalArgumentException(\"ConstantDesc type not handled: \" + desc);\n-    }\n-\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClassConstantHelper.java","additions":0,"deletions":570,"binary":false,"changes":570,"status":"deleted"},{"patch":"@@ -0,0 +1,399 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public class ConstantBuilder extends NestedClassBuilder {\n+\n+    \/\/ set of names generates already\n+    private final Map<String, Constant> namesGenerated = new HashMap<>();\n+\n+    public ConstantBuilder(JavaSourceBuilder enclosing, Kind kind, String className) {\n+        super(enclosing, kind, className);\n+    }\n+\n+    String memberMods() {\n+        return kind == JavaSourceBuilder.Kind.CLASS ?\n+                \"static final \" : \"\";\n+    }\n+\n+    \/\/ public API\n+\n+    public Constant addLayout(String javaName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.LAYOUT,\n+                () -> emitLayoutField(javaName, layout));\n+    }\n+\n+    public Constant addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout,\n+                                    Class<?> type, String rootJavaName, List<String> prefixElementNames) {\n+        return addVarHandle(javaName, nativeName, layout, type, rootJavaName, prefixElementNames);\n+    }\n+\n+    public Constant addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        return addVarHandle(javaName, nativeName, layout, type, null, List.of());\n+    }\n+\n+    private Constant addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type,\n+                                String rootLayoutName, List<String> prefixElementNames) {\n+        return emitIfAbsent(javaName, Constant.Kind.VAR_HANDLE,\n+                () -> emitVarHandleField(javaName, nativeName, type, layout, rootLayoutName, prefixElementNames));\n+    }\n+\n+    public Constant addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n+        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitMethodHandleField(javaName, nativeName, mtype, desc, varargs));\n+    }\n+\n+    public Constant addSegment(String javaName, String nativeName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                () -> emitSegmentField(javaName, nativeName, layout));\n+    }\n+\n+    public Constant addFunctionDesc(String javaName, FunctionDescriptor desc) {\n+        return emitIfAbsent(javaName, Constant.Kind.FUNCTION_DESCRIPTOR,\n+                () -> emitFunctionDescField(javaName, desc));\n+    }\n+\n+    public Constant addConstantDesc(String javaName, Class<?> type, Object value) {\n+        if (type == MemorySegment.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                    () -> emitConstantSegment(javaName, value));\n+        } else if (type == MemoryAddress.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.ADDRESS,\n+                    () -> emitConstantAddress(javaName, value));\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class Constant {\n+\n+        enum Kind {\n+            LAYOUT(MemoryLayout.class, \"$LAYOUT\"),\n+            METHOD_HANDLE(MethodHandle.class, \"$MH\"),\n+            VAR_HANDLE(VarHandle.class, \"$VH\"),\n+            FUNCTION_DESCRIPTOR(FunctionDescriptor.class, \"$FUNC\"),\n+            ADDRESS(MemoryAddress.class, \"$ADDR\"),\n+            SEGMENT(MemorySegment.class, \"$SEGMENT\");\n+\n+            final Class<?> type;\n+            final String nameSuffix;\n+\n+            Kind(Class<?> type, String nameSuffix) {\n+                this.type = type;\n+                this.nameSuffix = nameSuffix;\n+            }\n+\n+            String fieldName(String javaName) {\n+                return javaName + nameSuffix;\n+            }\n+        }\n+\n+        private final String className;\n+        private final String javaName;\n+        private final Kind kind;\n+\n+        Constant(String className, String javaName, Kind kind) {\n+            this.className = className;\n+            this.javaName = javaName;\n+            this.kind = kind;\n+        }\n+\n+        private List<String> getterNameParts() {\n+            return List.of(className, javaName, kind.nameSuffix);\n+        }\n+\n+        String accessExpression() {\n+            return className + \".\" + kind.fieldName(javaName);\n+        }\n+\n+        Constant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression());\n+            return this;\n+        }\n+\n+        Constant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression(), true, symbolName);\n+            return this;\n+        }\n+\n+        static final Function<List<String>, String> QUALIFIED_NAME =\n+                l -> l.stream().skip(1).collect(Collectors.joining());\n+\n+        static final Function<List<String>, String> JAVA_NAME =\n+                l -> l.get(1);\n+\n+        static final Function<List<String>, String> SUFFIX_ONLY =\n+                l -> l.get(2);\n+    }\n+\n+    \/\/ private generators\n+\n+    public Constant emitIfAbsent(String name, Constant.Kind kind, Supplier<Constant> constantFactory) {\n+        String lookupName = kind.fieldName(name);\n+        Constant constant = namesGenerated.get(lookupName);\n+        if (constant == null) {\n+            constant = constantFactory.get();\n+            if (constant.kind != kind) {\n+                throw new AssertionError(\"Factory return wrong kind of constant; expected: \"\n+                        + kind + \"; found: \" + constant.kind);\n+            }\n+            namesGenerated.put(lookupName, constant);\n+        }\n+        return constant;\n+    }\n+\n+    private Constant emitMethodHandleField(String javaName, String nativeName, MethodType mtype,\n+                                         FunctionDescriptor desc, boolean varargs) {\n+        Constant functionDesc = addFunctionDesc(javaName, desc);\n+        incrAlign();\n+        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n+        indent();\n+        append(memberMods() + \"MethodHandle \");\n+        append(fieldName + \" = RuntimeHelper.downcallHandle(\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+        append(\",\\n\");\n+        indent();\n+        append(\"\\\"\" + mtype.toMethodDescriptorString() + \"\\\",\\n\");\n+        indent();\n+        append(functionDesc.accessExpression());\n+        append(\", \");\n+        \/\/ isVariadic\n+        append(varargs);\n+        append(\"\\n\");\n+        decrAlign();\n+        indent();\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n+    }\n+\n+    private Constant emitVarHandleField(String javaName, String nativeName, Class<?> type, MemoryLayout layout,\n+                                      String rootLayoutName, List<String> prefixElementNames) {\n+        String layoutAccess = rootLayoutName != null ?\n+                Constant.Kind.LAYOUT.fieldName(rootLayoutName) :\n+                addLayout(javaName, layout).accessExpression();\n+        incrAlign();\n+        String typeName = type.getName();\n+        boolean isAddr = typeName.contains(\"MemoryAddress\");\n+        if (isAddr) {\n+            typeName = \"long\";\n+        }\n+        indent();\n+        String fieldName = Constant.Kind.VAR_HANDLE.fieldName(javaName);\n+        append(memberMods() + \"VarHandle \" + fieldName + \" = \");\n+        if (isAddr) {\n+            append(\"MemoryHandles.asAddressVarHandle(\");\n+        }\n+        append(layoutAccess);\n+        append(\".varHandle(\" + typeName + \".class\");\n+        if (rootLayoutName != null) {\n+            for (String prefixElementName : prefixElementNames) {\n+                append(\", MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+            }\n+            append(\", MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n+        }\n+        append(\")\");\n+        if (isAddr) {\n+            append(\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.VAR_HANDLE);\n+    }\n+\n+    private Constant emitLayoutField(String javaName, MemoryLayout layout) {\n+        String fieldName = Constant.Kind.LAYOUT.fieldName(javaName);\n+        incrAlign();\n+        indent();\n+        append(memberMods() + \"MemoryLayout \" + fieldName + \" = \");\n+        emitLayoutString(layout);\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.LAYOUT);\n+    }\n+\n+    private void emitLayoutString(MemoryLayout l) {\n+        if (l instanceof ValueLayout) {\n+            append(typeToLayoutName((ValueLayout) l));\n+        } else if (l instanceof SequenceLayout) {\n+            append(\"MemoryLayout.ofSequence(\");\n+            if (((SequenceLayout) l).elementCount().isPresent()) {\n+                append(((SequenceLayout) l).elementCount().getAsLong() + \", \");\n+            }\n+            emitLayoutString(((SequenceLayout) l).elementLayout());\n+            append(\")\");\n+        } else if (l instanceof GroupLayout group) {\n+            if (group.isStruct()) {\n+                append(\"MemoryLayout.ofStruct(\\n\");\n+            } else {\n+                append(\"MemoryLayout.ofUnion(\\n\");\n+            }\n+            incrAlign();\n+            String delim = \"\";\n+            for (MemoryLayout e : group.memberLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+            append(\")\");\n+        } else {\n+            \/\/ padding\n+            append(\"MemoryLayout.ofPaddingBits(\" + l.bitSize() + \")\");\n+        }\n+        if (l.name().isPresent()) {\n+            append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n+        }\n+    }\n+\n+    private Constant emitFunctionDescField(String javaName, FunctionDescriptor desc) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.FUNCTION_DESCRIPTOR.fieldName(javaName);\n+        final boolean noArgs = desc.argumentLayouts().isEmpty();\n+        append(memberMods());\n+        append(\"FunctionDescriptor \");\n+        append(fieldName);\n+        append(\" = \");\n+        if (desc.returnLayout().isPresent()) {\n+            append(\"FunctionDescriptor.of(\");\n+            emitLayoutString(desc.returnLayout().get());\n+            if (!noArgs) {\n+                append(\",\");\n+            }\n+        } else {\n+            append(\"FunctionDescriptor.ofVoid(\");\n+        }\n+        if (!noArgs) {\n+            append(\"\\n\");\n+            incrAlign();\n+            String delim = \"\";\n+            for (MemoryLayout e : desc.argumentLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.FUNCTION_DESCRIPTOR);\n+    }\n+\n+    private Constant emitConstantSegment(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = CLinker.toCString(\\\"\");\n+        append(Utils.quote(Objects.toString(value)));\n+        append(\"\\\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+\n+    private Constant emitConstantAddress(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.ADDRESS.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemoryAddress \");\n+        append(fieldName);\n+        append(\" = MemoryAddress.ofLong(\");\n+        append(((Number)value).longValue());\n+        append(\"L);\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.ADDRESS);\n+    }\n+\n+    private static String typeToLayoutName(ValueLayout vl) {\n+        if (UnsupportedLayouts.isUnsupported(vl)) {\n+            return \"MemoryLayout.ofPaddingBits(\" + vl.bitSize() + \")\";\n+        }\n+\n+        CLinker.TypeKind kind = (CLinker.TypeKind)vl.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n+                () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+        return switch (kind) {\n+            case CHAR -> \"C_CHAR\";\n+            case SHORT -> \"C_SHORT\";\n+            case INT -> \"C_INT\";\n+            case LONG -> \"C_LONG\";\n+            case LONG_LONG -> \"C_LONG_LONG\";\n+            case FLOAT -> \"C_FLOAT\";\n+            case DOUBLE -> \"C_DOUBLE\";\n+            case POINTER -> \"C_POINTER\";\n+        };\n+    }\n+\n+    private Constant emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {\n+        Constant layoutConstant = addLayout(javaName, layout);\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = \");\n+        append(\"RuntimeHelper.lookupGlobalVariable(\");\n+        append(\"LIBRARIES, \\\"\");\n+        append(nativeName);\n+        append(\"\\\", \");\n+        append(layoutConstant.accessExpression());\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":399,"deletions":0,"binary":false,"changes":399,"status":"added"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.invoke.MethodType;\n-import java.util.List;\n-\n-import static jdk.internal.jextract.impl.MultiFileConstantHelper.CONSTANTS_PER_CLASS_CLASSES;\n-import static jdk.internal.jextract.impl.MultiFileConstantHelper.CONSTANTS_PER_CLASS_SOURCES;\n-\n-interface ConstantHelper {\n-    DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout);\n-    DirectMethodHandleDesc addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type,\n-                                             String rootJavaName, MemoryLayout rootLayout, List<String> elementNames);\n-    DirectMethodHandleDesc addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type);\n-    DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs);\n-    DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout);\n-    DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc);\n-    DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value);\n-    List<JavaFileObject> build();\n-\n-    static ConstantHelper make(boolean source, String packageName, String headerClassName, ClassDesc runtimeHelper,\n-                               ClassDesc cString, String[] libraryNames) {\n-        return new MultiFileConstantHelper(headerClassName,\n-            (simpleClassName, baseClassName, isFinal) -> source\n-                ? SourceConstantHelper.make(packageName, simpleClassName, libraryNames, baseClassName)\n-                : ClassConstantHelper.make(packageName, simpleClassName, runtimeHelper, cString, libraryNames, baseClassName),\n-            source ? CONSTANTS_PER_CLASS_SOURCES : CONSTANTS_PER_CLASS_CLASSES);\n-    }\n-\n-    interface ConstantHelperFactory {\n-        ConstantHelper make(String headerClassName);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantHelper.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -29,1 +29,2 @@\n-import jdk.incubator.jextract.Type;\n+\n+import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n@@ -34,0 +35,3 @@\n+\n+    private static final String MEMBER_MODS = \"static\";\n+\n@@ -38,1 +42,1 @@\n-                               FunctionDescriptor fiDesc, Type funcType) {\n+                               FunctionDescriptor fiDesc) {\n@@ -51,4 +55,6 @@\n-    void emitFunctionalInterfaceMethod() {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(fiType.returnType().getName() + \" apply(\");\n+    \/\/ private generation\n+\n+    private void emitFunctionalInterfaceMethod() {\n+        incrAlign();\n+        indent();\n+        append(fiType.returnType().getName() + \" apply(\");\n@@ -57,1 +63,1 @@\n-            builder.append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+            append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n@@ -60,2 +66,2 @@\n-        builder.append(\");\\n\");\n-        builder.decrAlign();\n+        append(\");\\n\");\n+        decrAlign();\n@@ -65,19 +71,22 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + \" MemorySegment allocate(\" + className + \" fi) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return RuntimeHelper.upcallStub(\" + className + \".class, fi, \" + functionGetCallString(className, fiDesc) + \", \" +\n-                \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\");\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.indent();\n-        builder.append(PUB_MODS + \" MemorySegment allocate(\" + className + \" fi, NativeScope scope) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return allocate(fi).handoff(scope);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        emitWithConstantClass(className(), constantBuilder -> {\n+            Constant functionDesc = constantBuilder.addFunctionDesc(className(), fiDesc);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" + functionDesc.accessExpression() + \", \" +\n+                    \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            indent();\n+            append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi, NativeScope scope) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return allocate(fi).handoff(scope);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -32,1 +34,3 @@\n-import javax.tools.JavaFileObject;\n+import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n+\n+import java.lang.constant.ClassDesc;\n@@ -42,1 +46,3 @@\n-class HeaderFileBuilder extends JavaSourceBuilder {\n+abstract class HeaderFileBuilder extends JavaSourceBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n@@ -44,1 +50,1 @@\n-    private String superclass;\n+    private final String superclass;\n@@ -46,2 +52,2 @@\n-    HeaderFileBuilder(String clsName, String pkgName, String superclass, ConstantHelper constantHelper) {\n-        super(new StringSourceBuilder(), Kind.CLASS, clsName, pkgName, constantHelper);\n+    HeaderFileBuilder(ClassDesc desc, String superclass) {\n+        super(Kind.CLASS, desc);\n@@ -57,2 +63,51 @@\n-    protected String getClassModifiers() {\n-        return \"\";\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        if (type.equals(MemorySegment.class)) {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addSegment(javaName, nativeName, layout)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            });\n+        } else {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addLayout(javaName, layout)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, layout, type)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, layout)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, type);\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, type);\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+        emitWithConstantClass(javaName, constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, varargs)\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, mtype, varargs, paramNames);\n+        });\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        if (type.equals(MemorySegment.class) || type.equals(MemoryAddress.class)) {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addConstantDesc(javaName, type, value)\n+                        .emitGetter(this, MEMBER_MODS, Constant.JAVA_NAME);\n+            });\n+        } else {\n+            emitGetter(MEMBER_MODS, type, javaName, getConstantString(type, value));\n+        }\n+    }\n+\n+    @Override\n+    public void addTypedef(String name, String superClass, Type type) {\n+        if (type instanceof Type.Primitive) {\n+            \/\/ primitive\n+            emitPrimitiveTypedef((Type.Primitive)type, name);\n+        } else {\n+            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n+            builder.classBegin();\n+            builder.classEnd();\n+        }\n@@ -61,1 +116,3 @@\n-    void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc,\n+    \/\/ private generation\n+\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType mtype,\n@@ -63,4 +120,4 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n@@ -84,1 +141,1 @@\n-            builder.append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n@@ -90,1 +147,1 @@\n-                builder.append(\", \");\n+                append(\", \");\n@@ -92,1 +149,1 @@\n-            builder.append(\"Object... \" + lastArg);\n+            append(\"Object... \" + lastArg);\n@@ -95,12 +152,12 @@\n-        builder.append(\") {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n-        builder.append(methodHandleGetCallString(javaName, nativeName, mtype, desc, varargs));\n-        builder.append(\", \\\"unresolved symbol: \");\n-        builder.append(nativeName);\n-        builder.append(\"\\\");\\n\");\n-        builder.indent();\n-        builder.append(\"try {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+        append(mhConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\");\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n@@ -108,1 +165,1 @@\n-            builder.append(\"return (\" + mtype.returnType().getName() + \")\");\n+            append(\"return (\" + mtype.returnType().getName() + \")\");\n@@ -110,14 +167,14 @@\n-        builder.append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"} catch (Throwable ex$) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -126,1 +183,1 @@\n-    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n+    private void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n@@ -129,9 +186,9 @@\n-            builder.incrAlign();\n-            builder.indent();\n-            builder.append(PUB_MODS);\n-            builder.append(\" ValueLayout \");\n-            builder.append(uniqueNestedClassName(name));\n-            builder.append(\" = \");\n-            builder.append(TypeTranslator.typeToLayoutName(kind));\n-            builder.append(\";\\n\");\n-            builder.decrAlign();\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS);\n+            append(\" ValueLayout \");\n+            append(uniqueNestedClassName(name));\n+            append(\" = \");\n+            append(TypeTranslator.typeToLayoutName(kind));\n+            append(\";\\n\");\n+            decrAlign();\n@@ -148,4 +205,67 @@\n-    List<JavaFileObject> build() {\n-        classEnd();\n-        String res = builder.build();\n-        return List.of(Utils.fileFromString(pkgName, className, res));\n+    private String getConstantString(Class<?> type, Object value) {\n+        StringBuilder buf = new StringBuilder();\n+        if (type == float.class) {\n+            float f = ((Number)value).floatValue();\n+            if (Float.isFinite(f)) {\n+                buf.append(value);\n+                buf.append(\"f\");\n+            } else {\n+                buf.append(\"Float.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else if (type == long.class) {\n+            buf.append(value);\n+            buf.append(\"L\");\n+        } else if (type == double.class) {\n+            double d = ((Number)value).doubleValue();\n+            if (Double.isFinite(d)) {\n+                buf.append(value);\n+                buf.append(\"d\");\n+            } else {\n+                buf.append(\"Double.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else {\n+            buf.append(\"(\" + type.getName() + \")\");\n+            buf.append(value + \"L\");\n+        }\n+        return buf.toString();\n+    }\n+\n+    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \") \");\n+        append(vhConstant.accessExpression());\n+        append(\".get(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"), x);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":176,"deletions":56,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.jextract.Declaration;\n@@ -32,0 +33,1 @@\n+import javax.tools.JavaFileObject;\n@@ -33,1 +35,0 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n@@ -36,0 +37,1 @@\n+import java.util.List;\n@@ -37,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -54,7 +57,2 @@\n-    static final String PUB_CLS_MODS = \"public final \";\n-    static final String PUB_MODS = \"public static \";\n-    protected final StringSourceBuilder builder;\n-    private final Kind kind;\n-    protected final String className;\n-    protected final String pkgName;\n-    protected final ConstantHelper constantHelper;\n+    final Kind kind;\n+    final ClassDesc desc;\n@@ -65,2 +63,7 @@\n-    JavaSourceBuilder(StringSourceBuilder builder, Kind kind, String className, String pkgName, ConstantHelper constantHelper) {\n-        this.builder = builder;\n+    \/\/ code buffer\n+    private StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    JavaSourceBuilder(int align, Kind kind, ClassDesc desc) {\n+        this.align = align;\n@@ -68,3 +71,1 @@\n-        this.className = className;\n-        this.pkgName = pkgName;\n-        this.constantHelper = constantHelper;\n+        this.desc = desc;\n@@ -73,2 +74,14 @@\n-    String superClass() {\n-        return null;\n+    JavaSourceBuilder(Kind kind, ClassDesc desc) {\n+        this(0, kind, desc);\n+    }\n+\n+    String className() {\n+        return desc.displayName();\n+    }\n+\n+    String fullName() {\n+        return className();\n+    }\n+\n+    final String packageName() {\n+        return desc.packageName();\n@@ -77,1 +90,1 @@\n-    Type type() {\n+    String superClass() {\n@@ -81,2 +94,2 @@\n-    protected String getClassModifiers() {\n-        return PUB_CLS_MODS;\n+    String mods() {\n+        return \"public \";\n@@ -86,2 +99,2 @@\n-        addPackagePrefix();\n-        addImportSection();\n+        emitPackagePrefix();\n+        emitImportSection();\n@@ -89,3 +102,3 @@\n-        builder.indent();\n-        builder.append(getClassModifiers());\n-        builder.append(kind.kindName + \" \" + className);\n+        indent();\n+        append(mods());\n+        append(kind.kindName + \" \" + className());\n@@ -93,2 +106,2 @@\n-            builder.append(\" extends \");\n-            builder.append(superClass());\n+            append(\" extends \");\n+            append(superClass());\n@@ -96,3 +109,6 @@\n-        builder.append(\" {\\n\\n\");\n-        if (kind != Kind.INTERFACE) {\n-            emitConstructor();\n+        append(\" {\\n\\n\");\n+    }\n+\n+    JavaSourceBuilder classEnd() {\n+        if (constantBuilder != null) {\n+            constantBuilder.classEnd();\n@@ -100,0 +116,3 @@\n+        indent();\n+        append(\"}\\n\\n\");\n+        return this;\n@@ -102,8 +121,4 @@\n-    void emitConstructor() {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"\/* package-private *\/ \");\n-        builder.append(className);\n-        builder.append(\"() {}\");\n-        builder.append('\\n');\n-        builder.decrAlign();\n+    \/\/ public API (used by OutputFactory)\n+\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        throw new UnsupportedOperationException();\n@@ -112,4 +127,2 @@\n-    JavaSourceBuilder classEnd() {\n-        builder.indent();\n-        builder.append(\"}\\n\\n\");\n-        return this;\n+    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+        throw new UnsupportedOperationException();\n@@ -118,71 +131,2 @@\n-    void addLayoutGetter(String javaName, MemoryLayout layout) {\n-        emitForwardGetter(constantHelper.addLayout(javaName, layout));\n-    }\n-\n-    void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        emitForwardGetter(constantHelper.addGlobalVarHandle(javaName, nativeName, layout, type));\n-    }\n-\n-    void addMethodHandleGetter(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n-        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs),\n-            true, \"unresolved symbol: \" + nativeName);\n-    }\n-\n-    void addSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n-        emitForwardGetter(constantHelper.addSegment(javaName, nativeName, layout),\n-            true, \"unresolved symbol: \" + nativeName);\n-    }\n-\n-    void addConstantGetter(String javaName, Class<?> type, Object value) {\n-        emitForwardGetter(constantHelper.addConstant(javaName, type, value));\n-    }\n-\n-    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        String vhParam = addressGetCallString(javaName, nativeName, layout);\n-        builder.append(\"return (\" + type.getName() + \") \");\n-        builder.append(globalVarHandleGetCallString(javaName, nativeName, layout, type));\n-        builder.append(\".get(RuntimeHelper.requireNonNull(\");\n-        builder.append(vhParam);\n-        builder.append(\", \\\"unresolved symbol: \");\n-        builder.append(nativeName);\n-        builder.append(\"\\\"));\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n-    }\n-\n-    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        String vhParam = addressGetCallString(javaName, nativeName, layout);\n-        builder.append(globalVarHandleGetCallString(javaName, nativeName, layout, type));\n-        builder.append(\".set(RuntimeHelper.requireNonNull(\");\n-        builder.append(vhParam);\n-        builder.append(\", \\\"unresolved symbol: \");\n-        builder.append(nativeName);\n-        builder.append(\"\\\"), x);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n-    }\n-\n-    \/\/ Utility\n-\n-    protected void addPackagePrefix() {\n-        assert pkgName.indexOf('\/') == -1 : \"package name invalid: \" + pkgName;\n-        builder.append(\"\/\/ Generated by jextract\\n\\n\");\n-        if (!pkgName.isEmpty()) {\n-            builder.append(\"package \");\n-            builder.append(pkgName);\n-            builder.append(\";\\n\\n\");\n-        }\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        throw new UnsupportedOperationException();\n@@ -191,9 +135,2 @@\n-    protected void addImportSection() {\n-        builder.append(\"import java.lang.invoke.MethodHandle;\\n\");\n-        builder.append(\"import java.lang.invoke.VarHandle;\\n\");\n-        builder.append(\"import java.util.Objects;\\n\");\n-        builder.append(\"import jdk.incubator.foreign.*;\\n\");\n-        builder.append(\"import jdk.incubator.foreign.MemoryLayout.PathElement;\\n\");\n-        builder.append(\"import static \");\n-        builder.append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n-        builder.append(\".*;\\n\");\n+    public void addTypedef(String name, String superClass, Type type) {\n+        throw new UnsupportedOperationException();\n@@ -202,2 +139,2 @@\n-    protected void emitForwardGetter(DirectMethodHandleDesc desc) {\n-        emitForwardGetter(desc, false, \"\");\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        return new StructBuilder(this, name.isEmpty() ? parent.name() : name, layout, type);\n@@ -206,21 +143,10 @@\n-    protected void emitForwardGetter(DirectMethodHandleDesc desc, boolean nullCheck, String errMsg) {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + \" \" + displayName(desc.invocationType().returnType()) + \" \" + desc.methodName() + \"() {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return \");\n-        if (nullCheck) {\n-            builder.append(\"RuntimeHelper.requireNonNull(\");\n-        }\n-        builder.append(getCallString(desc));\n-        if (nullCheck) {\n-            builder.append(\",\\\"\");\n-            builder.append(errMsg);\n-            builder.append(\"\\\")\");\n-        }\n-        builder.append(\";\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+    public void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, mtype, desc);\n+        builder.classBegin();\n+        builder.classEnd();\n+    }\n+\n+    public List<JavaFileObject> toFiles() {\n+        classEnd();\n+        String res = build();\n+        return List.of(Utils.fileFromString(packageName(), className(), res));\n@@ -229,2 +155,16 @@\n-    protected String getCallString(DirectMethodHandleDesc desc) {\n-        return desc.owner().displayName() + \".\" + desc.methodName() + \"()\";\n+    \/\/ Internal generation helpers (used by other builders)\n+\n+    int align() {\n+        return align;\n+    }\n+\n+    void append(String s) {\n+        sb.append(s);\n+    }\n+\n+    void append(char c) {\n+        sb.append(c);\n+    }\n+\n+    void append(boolean b) {\n+        sb.append(b);\n@@ -233,2 +173,2 @@\n-    protected String displayName(ClassDesc returnType) {\n-        return returnType.displayName(); \/\/ TODO shorten based on imports\n+    void append(long l) {\n+        sb.append(l);\n@@ -237,2 +177,4 @@\n-    protected String functionGetCallString(String javaName, FunctionDescriptor fDesc) {\n-        return getCallString(constantHelper.addFunctionDesc(javaName, fDesc));\n+    void indent() {\n+        for (int i = 0; i < align; i++) {\n+            append(\"    \");\n+        }\n@@ -241,2 +183,2 @@\n-    protected String methodHandleGetCallString(String javaName, String nativeName, MethodType mt, FunctionDescriptor fDesc, boolean varargs) {\n-        return getCallString(constantHelper.addMethodHandle(javaName, nativeName, mt, fDesc, varargs));\n+    void incrAlign() {\n+        align++;\n@@ -245,2 +187,2 @@\n-    private String globalVarHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        return getCallString(constantHelper.addGlobalVarHandle(javaName, nativeName, layout, type));\n+    void decrAlign() {\n+        align--;\n@@ -249,2 +191,4 @@\n-    protected String addressGetCallString(String javaName, String nativeName, MemoryLayout layout) {\n-        return getCallString(constantHelper.addSegment(javaName, nativeName, layout));\n+    String build() {\n+        String s = sb.toString();\n+        sb = null;\n+        return s;\n@@ -262,1 +206,1 @@\n-    String uniqueNestedClassName(String name) {\n+    final String uniqueNestedClassName(String name) {\n@@ -267,2 +211,65 @@\n-    StructBuilder newStructBuilder(String name, GroupLayout parentLayout, Type type) {\n-        return new StructBuilder(this, name, parentLayout, type);\n+    protected void emitPackagePrefix() {\n+        assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n+        append(\"\/\/ Generated by jextract\\n\\n\");\n+        if (!packageName().isEmpty()) {\n+            append(\"package \");\n+            append(packageName());\n+            append(\";\\n\\n\");\n+        }\n+    }\n+\n+    protected void emitImportSection() {\n+        append(\"import java.lang.invoke.MethodHandle;\\n\");\n+        append(\"import java.lang.invoke.VarHandle;\\n\");\n+        append(\"import java.util.Objects;\\n\");\n+        append(\"import jdk.incubator.foreign.*;\\n\");\n+        append(\"import jdk.incubator.foreign.MemoryLayout.PathElement;\\n\");\n+        append(\"import static \");\n+        append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n+        append(\".*;\\n\");\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access, boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \" + type.getSimpleName() + \" \" +name + \"() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \");\n+        if (nullCheck) {\n+            append(\"RuntimeHelper.requireNonNull(\");\n+        }\n+        append(access);\n+        if (nullCheck) {\n+            append(\",\\\"\");\n+            append(symbolName);\n+            append(\"\\\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access) {\n+        emitGetter(mods, type, name, access, false, null);\n+    }\n+\n+    int constant_counter = 0;\n+    int constant_class_index = 0;\n+\n+    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n+    ConstantBuilder constantBuilder;\n+\n+    protected void emitWithConstantClass(String javaName, Consumer<ConstantBuilder> constantConsumer) {\n+        if (constant_counter > CONSTANTS_PER_CLASS || constantBuilder == null) {\n+            if (constantBuilder != null) {\n+                constantBuilder.classEnd();\n+            }\n+            constant_counter = 0;\n+            constantBuilder = new ConstantBuilder(this, Kind.CLASS, \"constants$\" + constant_class_index++);\n+            constantBuilder.classBegin();\n+        }\n+        constantConsumer.accept(constantBuilder);\n+        constant_counter++;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":165,"deletions":158,"binary":false,"changes":323,"status":"modified"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class MultiFileConstantHelper implements ConstantHelper {\n-    static final int CONSTANTS_PER_CLASS_SOURCES = Integer.getInteger(\"jextract.constants.per.class.source\", 1000);\n-    static final int CONSTANTS_PER_CLASS_CLASSES = Integer.getInteger(\"jextract.constants.per.class.binary\", 10000);\n-\n-    @FunctionalInterface\n-    interface ConstantHelperFunc {\n-        ConstantHelper make(String simpleClassName, String baseClassName, boolean isFinal);\n-    }\n-\n-    private final ConstantHelperFunc delegateFactory;\n-    private final String headerClassName;\n-    private final int constantsPerClass;\n-\n-    private int constantCount;\n-    private int constantClassCount;\n-    private ConstantHelper delegate;\n-\n-    private final List<JavaFileObject> finishedClasses = new ArrayList<>();\n-\n-    public MultiFileConstantHelper(String headerClassName, ConstantHelperFunc func, int constantsPerClass) {\n-        this.headerClassName = headerClassName;\n-        this.delegateFactory = func;\n-        this.constantsPerClass = constantsPerClass;\n-        this.delegate = delegateFactory.make(getConstantClassName(), null, false);\n-    }\n-\n-    private String getConstantClassName() {\n-        return headerClassName + \"_constants_\" + constantClassCount;\n-    }\n-\n-    private void checkNewConstantsClass() {\n-        if (constantCount > constantsPerClass) {\n-            newConstantsClass(false);\n-        }\n-        constantCount++;\n-    }\n-\n-    private void newConstantsClass(boolean isFinal) {\n-        finishedClasses.addAll(delegate.build());\n-        String currentClassName = getConstantClassName();\n-        constantClassCount++;\n-        String newClassName = getConstantClassName();\n-        delegate = delegateFactory.make(newClassName, currentClassName, isFinal);\n-        this.constantCount = 0;\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {\n-        checkNewConstantsClass();\n-        return delegate.addLayout(javaName, layout);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout,\n-                                                    Class<?> type, String rootJavaName, MemoryLayout rootLayout,\n-                                                    List<String> elementNames) {\n-        checkNewConstantsClass();\n-        return delegate.addFieldVarHandle(javaName, nativeName, layout, type, rootJavaName, rootLayout, elementNames);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        checkNewConstantsClass();\n-        return delegate.addGlobalVarHandle(javaName, nativeName, layout, type);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n-        checkNewConstantsClass();\n-        return delegate.addMethodHandle(javaName, nativeName, mtype, desc, varargs);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {\n-        checkNewConstantsClass();\n-        return delegate.addSegment(javaName, nativeName, layout);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {\n-        checkNewConstantsClass();\n-        return delegate.addFunctionDesc(javaName, fDesc);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {\n-        checkNewConstantsClass();\n-        return delegate.addConstant(name, type, value);\n-    }\n-\n-    @Override\n-    public List<JavaFileObject> build() {\n-        newConstantsClass(true);\n-        return new ArrayList<>(finishedClasses);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/MultiFileConstantHelper.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -28,1 +28,6 @@\n-public abstract class NestedClassBuilder extends JavaSourceBuilder {\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public class NestedClassBuilder extends JavaSourceBuilder {\n@@ -33,1 +38,1 @@\n-        super(enclosing.builder, kind, enclosing.uniqueNestedClassName(className), enclosing.pkgName, enclosing.constantHelper);\n+        super(enclosing.align(), kind, ClassDesc.of(enclosing.packageName(), enclosing.uniqueNestedClassName(className)));\n@@ -37,0 +42,11 @@\n+    @Override\n+    protected String mods() {\n+        return kind == Kind.INTERFACE ?\n+                \"public \" : \"public static \";\n+    }\n+\n+    @Override\n+    String fullName() {\n+        return enclosing.className() + \".\" + className();\n+    }\n+\n@@ -39,1 +55,1 @@\n-        builder.incrAlign();\n+        incrAlign();\n@@ -46,1 +62,2 @@\n-        builder.decrAlign();\n+        decrAlign();\n+        enclosing.append(build());\n@@ -51,2 +68,2 @@\n-    protected String getClassModifiers() {\n-        return PUB_MODS;\n+    protected void emitPackagePrefix() {\n+        \/\/ nested class. containing class has necessary package declaration\n@@ -56,2 +73,2 @@\n-    protected void addPackagePrefix() {\n-        \/\/ nested class. containing class has necessary package declaration\n+    protected void emitImportSection() {\n+        \/\/ nested class. containing class has necessary imports\n@@ -61,2 +78,7 @@\n-    protected void addImportSection() {\n-        \/\/ nested class. containing class has necessary imports\n+    public List<JavaFileObject> toFiles() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(String javaName, Consumer<ConstantBuilder> constantConsumer) {\n+        enclosing.emitWithConstantClass(javaName, constantConsumer);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/NestedClassBuilder.java","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.jextract.Type.Primitive;\n@@ -50,2 +49,0 @@\n-import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n-\n@@ -72,2 +69,2 @@\n-    private String addStructDefinition(Declaration decl, String name) {\n-        return structClassNames.put(decl, name);\n+    private void addStructDefinition(Declaration decl, String name) {\n+        structClassNames.put(decl, name);\n@@ -94,1 +91,1 @@\n-    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName, boolean source,\n+    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName,\n@@ -97,4 +94,1 @@\n-        ConstantHelper constantHelper = ConstantHelper.make(source, pkgName, clsName,\n-                ClassDesc.of(pkgName, \"RuntimeHelper\"), ClassDesc.of(\"jdk.incubator.foreign\", \"CLinker\"),\n-                libraryNames.toArray(String[]::new));\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(clsName, pkgName, constantHelper);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(ClassDesc.of(pkgName, clsName), libraryNames.toArray(new String[0]));\n@@ -113,1 +107,0 @@\n-        toplevelBuilder.classBegin();\n@@ -119,1 +112,1 @@\n-            toplevelBuilder.addTypeDef(td.name(),\n+            toplevelBuilder.addTypedef(td.name(),\n@@ -122,1 +115,0 @@\n-        toplevelBuilder.classEnd();\n@@ -124,2 +116,1 @@\n-            List<JavaFileObject> files = new ArrayList<>();\n-            files.addAll(toplevelBuilder.build());\n+            List<JavaFileObject> files = new ArrayList<>(toplevelBuilder.toFiles());\n@@ -127,1 +118,0 @@\n-            files.add(jfoFromString(pkgName,\"C\", getCAnnotationSource()));\n@@ -143,6 +133,0 @@\n-    private String getCAnnotationSource() throws URISyntaxException, IOException {\n-        URL cAnnotation = OutputFactory.class.getResource(\"resources\/C.java.template\");\n-        return (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n-                String.join(\"\\n\", Files.readAllLines(Paths.get(cAnnotation.toURI())));\n-    }\n-\n@@ -157,8 +141,0 @@\n-    private static Class<?> classForType(Primitive.Kind type, MemoryLayout layout) {\n-        boolean isFloat = switch(type) {\n-            case Float, Double -> true;\n-            default-> false;\n-        };\n-        return TypeTranslator.layoutToClass(isFloat, layout);\n-    }\n-\n@@ -177,1 +153,1 @@\n-        header().addConstantGetter(Utils.javaSafeIdentifier(constant.name()),\n+        toplevelBuilder.addConstant(Utils.javaSafeIdentifier(constant.name()),\n@@ -193,1 +169,0 @@\n-        boolean isAnonNested = d.name().isEmpty() && isRecord(parent);\n@@ -195,13 +170,5 @@\n-            if (!isAnonNested) {\n-                \/\/only add explicit struct layout if the struct is not to be flattened inside another struct\n-                String className = d.name().isEmpty() ? parent.name() : d.name();\n-                GroupLayout parentLayout = (GroupLayout) layoutFor(d);\n-                currentBuilder = currentBuilder.newStructBuilder(className, parentLayout, Type.declared(d));\n-                addStructDefinition(d, currentBuilder.className);\n-                currentBuilder.classBegin();\n-                currentBuilder.addLayoutGetter(((StructBuilder) currentBuilder).layoutField(), d.layout().get());\n-            } else {\n-                \/\/ for anonymous nested structs, add a prefix for field layout lookups\n-                \/\/ but don't generate a separate class\n-                String anonymousStructName = findAnonymousStructName(d, (Declaration.Scoped) parent);\n-                ((StructBuilder) currentBuilder).pushPrefixElement(anonymousStructName);\n+            String className = d.name();\n+            GroupLayout layout = (GroupLayout) layoutFor(d);\n+            currentBuilder = currentBuilder.addStruct(className, parent, layout, Type.declared(d));\n+            if (!className.isEmpty()) {\n+                addStructDefinition(d, currentBuilder.fullName());\n@@ -210,3 +177,4 @@\n-        d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n-        if (isStructKind) {\n-            if (!isAnonNested) {\n+        try {\n+            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n+        } finally {\n+            if (isStructKind) {\n@@ -214,2 +182,0 @@\n-            } else {\n-                ((StructBuilder) currentBuilder).popPrefixElement();\n@@ -221,19 +187,1 @@\n-    private String findAnonymousStructName(Declaration.Scoped d, Declaration.Scoped parent) {\n-        \/\/ nested anonymous struct or union\n-        GroupLayout layout = (GroupLayout) layoutFor(d);\n-        \/\/ look up layout in parent, which will have the right context-dependent name\n-        GroupLayout parentLayout = (GroupLayout) parent.layout().orElseThrow();\n-        for (MemoryLayout ml : parentLayout.memberLayouts()) {\n-            \/\/ look for anonymous structs\n-            if (ml.attribute(JEXTRACT_ANONYMOUS).isPresent()) {\n-                \/\/ it's enough to just compare the member layouts, since the member names\n-                \/\/ have to be unique within the parent layout (in C)\n-                if (((GroupLayout) ml).memberLayouts().equals(layout.memberLayouts())) {\n-                    return ml.name().orElseThrow();\n-                }\n-            }\n-        }\n-        throw new IllegalStateException(\"Could not find layout in parent\");\n-    }\n-\n-    private static final boolean isVaList(FunctionDescriptor desc) {\n+    private static boolean isVaList(FunctionDescriptor desc) {\n@@ -257,1 +205,1 @@\n-            if (UnsupportedLayouts.isUnsupported((ValueLayout)layout)) {\n+            if (UnsupportedLayouts.isUnsupported(layout)) {\n@@ -292,1 +240,1 @@\n-    private boolean generateFunctionalInterface(Type.Function func, Type type, String name) {\n+    private boolean generateFunctionalInterface(Type.Function func, String name) {\n@@ -307,1 +255,1 @@\n-        toplevelBuilder.addFunctionalInterface(name, fitype, fpDesc, type);\n+        currentBuilder.addFunctionalInterface(name, fitype, fpDesc);\n@@ -344,1 +292,0 @@\n-        header().addMethodHandleGetter(mhName, funcTree.name(), mtype, descriptor, funcTree.type().varargs());\n@@ -356,1 +303,1 @@\n-                if (! generateFunctionalInterface(f, param.type(), name)) {\n+                if (! generateFunctionalInterface(f, name)) {\n@@ -363,2 +310,2 @@\n-        header().addStaticFunctionWrapper(Utils.javaSafeIdentifier(funcTree.name()), funcTree.name(), mtype,\n-                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);\n+        toplevelBuilder.addFunction(mhName, funcTree.name(), mtype,\n+                descriptor, funcTree.type().varargs(), paramNames);\n@@ -372,4 +319,2 @@\n-            return switch (delegated.kind()) {\n-                case POINTER -> getAsFunctionPointer(delegated.type());\n-                default -> null;\n-            };\n+            return delegated.kind() == Type.Delegated.Kind.POINTER ?\n+                getAsFunctionPointer(delegated.type()) : null;\n@@ -396,2 +341,1 @@\n-                    case STRUCT:\n-                    case UNION: {\n+                    case STRUCT, UNION -> {\n@@ -413,1 +357,1 @@\n-                                toplevelBuilder.addTypeDef(tree.name(), structDefinitionName(s), tree.type());\n+                                toplevelBuilder.addTypedef(tree.name(), structDefinitionName(s), tree.type());\n@@ -423,3 +367,1 @@\n-                    break;\n-                    default:\n-                        visitScoped(s, tree);\n+                    default -> visitScoped(s, tree);\n@@ -429,1 +371,1 @@\n-             header().emitPrimitiveTypedef((Type.Primitive)type, tree.name());\n+             toplevelBuilder.addTypedef(tree.name(), null, type);\n@@ -433,1 +375,1 @@\n-                generateFunctionalInterface(func, type, tree.name());\n+                generateFunctionalInterface(func, tree.name());\n@@ -474,1 +416,1 @@\n-            generateFunctionalInterface(func, type, fieldName);\n+            generateFunctionalInterface(func, fieldName);\n@@ -484,1 +426,0 @@\n-        boolean isSegment = clazz == MemorySegment.class;\n@@ -493,12 +434,2 @@\n-        if (parent != null) { \/\/struct field\n-            if (isSegment) {\n-                if (sizeAvailable) {\n-                    currentBuilder.addSegmentGetter(fieldName, tree.name(), treeLayout);\n-                } else {\n-                    warn(\"Layout size not available for \" + fieldName);\n-                }\n-            } else {\n-                currentBuilder.addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz);\n-                currentBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz);\n-                currentBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz);\n-            }\n+        if (sizeAvailable) {\n+            currentBuilder.addVar(fieldName, tree.name(), treeLayout, clazz);\n@@ -506,13 +437,1 @@\n-            if (sizeAvailable) {\n-                if (isSegment) {\n-                    header().addSegmentGetter(fieldName, tree.name(), treeLayout);\n-                } else {\n-                    header().addLayoutGetter(fieldName, layout);\n-                    header().addVarHandleGetter(fieldName, tree.name(), treeLayout, clazz);\n-                    header().addSegmentGetter(fieldName, tree.name(), treeLayout);\n-                    header().addGetter(fieldName, tree.name(), treeLayout, clazz);\n-                    header().addSetter(fieldName, tree.name(), treeLayout, clazz);\n-                }\n-            } else {\n-                warn(\"Layout size not available for \" + fieldName);\n-            }\n+            warn(\"Layout size not available for \" + fieldName);\n@@ -524,13 +443,0 @@\n-    private boolean isRecord(Declaration declaration) {\n-        if (declaration == null) {\n-            return false;\n-        } else if (!(declaration instanceof Declaration.Scoped)) {\n-            return false;\n-        } else {\n-            Declaration.Scoped scope = (Declaration.Scoped)declaration;\n-            return scope.kind() == Declaration.Scoped.Kind.CLASS ||\n-                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||\n-                    scope.kind() == Declaration.Scoped.Kind.UNION;\n-        }\n-    }\n-\n@@ -552,4 +458,0 @@\n-\n-    HeaderFileBuilder header() {\n-        return toplevelBuilder.nextHeader();\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":34,"deletions":132,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -1,521 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.incubator.foreign.SequenceLayout;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-import java.net.URI;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-\n-import static java.lang.invoke.MethodType.methodType;\n-\n-\/\/ generates ConstantHelper as java source\n-class SourceConstantHelper extends JavaSourceBuilder implements ConstantHelper {\n-    private static final String PKG_STATIC_FINAL_MODS = \"static final \";\n-\n-    \/\/ set of names generates already\n-    private static final Map<String, DirectMethodHandleDesc> namesGenerated = new HashMap<>();\n-\n-    private final ClassDesc CD_constantsHelper;\n-    private final String[] libraryNames;\n-    private final String baseClassName;\n-\n-    private SourceConstantHelper(String packageName, String[] libraryNames, String className, String baseClassName, ClassDesc CD_constantsHelper) {\n-        super(new StringSourceBuilder(), Kind.CLASS, className, packageName, null);\n-        this.CD_constantsHelper = CD_constantsHelper;\n-        this.libraryNames = libraryNames;\n-        this.baseClassName = baseClassName;\n-    }\n-\n-    @Override\n-    String superClass() {\n-        return baseClassName;\n-    }\n-\n-    public static ConstantHelper make(String packageName, String className, String[] libraryNames,\n-                                      String baseClassName) {\n-        ClassDesc CD_constantsHelper = ClassDesc.of(className);\n-        SourceConstantHelper helper = new SourceConstantHelper(packageName, libraryNames, className, baseClassName, CD_constantsHelper);\n-        helper.classBegin();\n-        return helper;\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {\n-        String layoutName = javaName + \"$LAYOUT\";\n-        if (namesGenerated.containsKey(layoutName)) {\n-            return namesGenerated.get(layoutName);\n-        } else {\n-            String fieldName = emitLayoutField(javaName, layout);\n-            DirectMethodHandleDesc getter = emitGetter(layoutName, MemoryLayout.class, fieldName);\n-            namesGenerated.put(layoutName, getter);\n-            return getter;\n-        }\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout,\n-                                                    Class<?> type, String rootJavaName, MemoryLayout ignored,\n-                                                    List<String> prefixElementNames) {\n-        return addVarHandle(javaName, nativeName, layout, type, rootJavaName, prefixElementNames);\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        return addVarHandle(javaName, nativeName, layout, type, null, List.of());\n-    }\n-\n-    private DirectMethodHandleDesc addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type,\n-                                                String rootLayoutName, List<String> prefixElementNames) {\n-        String varHandleName = javaName + \"$VH\";\n-\n-        if (namesGenerated.containsKey(varHandleName)) {\n-            return namesGenerated.get(varHandleName);\n-        } else {\n-            String fieldName = emitVarHandleField(javaName, nativeName, type, layout, rootLayoutName, prefixElementNames);\n-            DirectMethodHandleDesc getter = emitGetter(varHandleName, VarHandle.class, fieldName);\n-            namesGenerated.put(varHandleName, getter);\n-            return getter;\n-        }\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n-        String mhName = javaName + \"$MH\";\n-        if (namesGenerated.containsKey(mhName)) {\n-            return namesGenerated.get(mhName);\n-        } else {\n-            String fieldName = emitMethodHandleField(javaName, nativeName, mtype, desc, varargs);\n-            DirectMethodHandleDesc getter = emitGetter(mhName, MethodHandle.class, fieldName);\n-            namesGenerated.put(mhName, getter);\n-            return getter;\n-        }\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {\n-        String segmentName = javaName + \"$SEGMENT\";\n-        if (namesGenerated.containsKey(segmentName)) {\n-            return namesGenerated.get(segmentName);\n-        } else {\n-            String fieldName = emitSegmentField(javaName, nativeName, layout);\n-            DirectMethodHandleDesc getter = emitGetter(segmentName, MemorySegment.class, fieldName);\n-            namesGenerated.put(segmentName, getter);\n-            return getter;\n-        }\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor desc) {\n-        String funcDescName = javaName + \"$FUNC\";\n-\n-        if (namesGenerated.containsKey(funcDescName)) {\n-            return namesGenerated.get(funcDescName);\n-        } else {\n-            String fieldName = emitFunctionDescField(javaName, desc);\n-            DirectMethodHandleDesc getter = emitGetter(funcDescName, FunctionDescriptor.class, fieldName);\n-            namesGenerated.put(funcDescName, getter);\n-            return getter;\n-        }\n-    }\n-\n-    @Override\n-    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {\n-        if (namesGenerated.containsKey(name)) {\n-            return namesGenerated.get(name);\n-        } else {\n-            String str;\n-            if (type == MemorySegment.class) {\n-                str = emitConstantSegment(name, value);\n-            } else if (type == MemoryAddress.class) {\n-                str = emitConstantAddress(name, value);\n-            } else {\n-                str = getConstantString(type, value);\n-            }\n-            DirectMethodHandleDesc getter = emitGetter(name, type, str);\n-            namesGenerated.put(name, getter);\n-            return getter;\n-        }\n-    }\n-\n-    private JavaFileObject newJavaFileObject(String className, String src) {\n-        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n-        return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + className + \".java\"), src);\n-    }\n-\n-    @Override\n-    public List<JavaFileObject> build() {\n-        classEnd();\n-        JavaFileObject result = newJavaFileObject(className, builder.build());\n-        return List.of(result);\n-    }\n-\n-    @Override\n-    protected String getClassModifiers() {\n-        return \"\";\n-    }\n-\n-    protected void classBegin() {\n-        super.classBegin();\n-        if (superClass() == null) { \/\/ only for the first one\n-            emitLibraries(libraryNames);\n-        }\n-    }\n-\n-    protected JavaSourceBuilder classEnd() {\n-        builder.append(\"}\\n\");\n-        return null;\n-    }\n-\n-    private DirectMethodHandleDesc getGetterDesc(String name, Class<?> type) {\n-        MethodType mt = methodType(type);\n-        return MethodHandleDesc.ofMethod(\n-                DirectMethodHandleDesc.Kind.STATIC,\n-                CD_constantsHelper, name, mt.describeConstable().orElseThrow()\n-        );\n-    }\n-\n-    private DirectMethodHandleDesc emitGetter(String name, Class<?> type, String value) {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PKG_STATIC_FINAL_MODS);\n-        builder.append(type.getName());\n-        builder.append(' ');\n-        builder.append(name);\n-        builder.append(\"() { return \");\n-        builder.append(value);\n-        builder.append(\"; }\\n\\n\");\n-        builder.decrAlign();\n-        return getGetterDesc(name, type);\n-    }\n-\n-    private String getMethodHandleFieldName(String javaName) {\n-        return javaName + \"$MH_\";\n-    }\n-\n-    private String emitMethodHandleField(String javaName, String nativeName, MethodType mtype,\n-                                         FunctionDescriptor desc, boolean varargs) {\n-        addFunctionDesc(javaName, desc);\n-        builder.incrAlign();\n-        String fieldName = getMethodHandleFieldName(javaName);\n-        builder.indent();\n-        builder.append(PKG_STATIC_FINAL_MODS + \"MethodHandle \");\n-        builder.append(fieldName + \" = RuntimeHelper.downcallHandle(\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n-        builder.append(\",\\n\");\n-        builder.indent();\n-        builder.append(\"\\\"\" + mtype.toMethodDescriptorString() + \"\\\",\\n\");\n-        builder.indent();\n-        builder.append(getFunctionDescFieldName(javaName));\n-        builder.append(\", \");\n-        \/\/ isVariadic\n-        builder.append(varargs);\n-        builder.append(\"\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\");\\n\");\n-        builder.decrAlign();\n-        return fieldName;\n-    }\n-\n-    private String getVarHandleFieldName(String name) {\n-        return name + \"$VH_\";\n-    }\n-\n-    private String emitVarHandleField(String javaName, String nativeName, Class<?> type, MemoryLayout layout,\n-                                      String rootLayoutName, List<String> prefixElementNames) {\n-        addLayout(javaName, layout);\n-        builder.incrAlign();\n-        String typeName = type.getName();\n-        boolean isAddr = typeName.contains(\"MemoryAddress\");\n-        if (isAddr) {\n-            typeName = \"long\";\n-        }\n-        builder.indent();\n-        String fieldName = getVarHandleFieldName(javaName);\n-        builder.append(PKG_STATIC_FINAL_MODS + \"VarHandle \" + fieldName + \" = \");\n-        if (isAddr) {\n-            builder.append(\"MemoryHandles.asAddressVarHandle(\");\n-        }\n-        builder.append(getLayoutFieldName(rootLayoutName != null ? rootLayoutName : javaName));\n-        builder.append(\".varHandle(\" + typeName + \".class\");\n-        if (rootLayoutName != null) {\n-            for (String prefixElementName : prefixElementNames) {\n-                builder.append(\", MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n-            }\n-            builder.append(\", MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n-        }\n-        builder.append(\")\");\n-        if (isAddr) {\n-            builder.append(\")\");\n-        }\n-        builder.append(\";\\n\");\n-        builder.decrAlign();\n-        return fieldName;\n-    }\n-\n-    private String getLayoutFieldName(String javaName) {\n-        return javaName + \"$LAYOUT_\";\n-    }\n-\n-    private String emitLayoutField(String javaName, MemoryLayout layout) {\n-        String fieldName = getLayoutFieldName(javaName);\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PKG_STATIC_FINAL_MODS + \"MemoryLayout \" + fieldName + \" = \");\n-        emitLayoutString(layout);\n-        builder.append(\";\\n\");\n-        builder.decrAlign();\n-        return fieldName;\n-    }\n-\n-    private void emitLayoutString(MemoryLayout l) {\n-        if (l instanceof ValueLayout) {\n-            builder.append(typeToLayoutName((ValueLayout) l));\n-        } else if (l instanceof SequenceLayout) {\n-            builder.append(\"MemoryLayout.ofSequence(\");\n-            if (((SequenceLayout) l).elementCount().isPresent()) {\n-                builder.append(((SequenceLayout) l).elementCount().getAsLong() + \", \");\n-            }\n-            emitLayoutString(((SequenceLayout) l).elementLayout());\n-            builder.append(\")\");\n-        } else if (l instanceof GroupLayout) {\n-            if (((GroupLayout) l).isStruct()) {\n-                builder.append(\"MemoryLayout.ofStruct(\\n\");\n-            } else {\n-                builder.append(\"MemoryLayout.ofUnion(\\n\");\n-            }\n-            builder.incrAlign();\n-            String delim = \"\";\n-            for (MemoryLayout e : ((GroupLayout) l).memberLayouts()) {\n-                builder.append(delim);\n-                builder.indent();\n-                emitLayoutString(e);\n-                delim = \",\\n\";\n-            }\n-            builder.append(\"\\n\");\n-            builder.decrAlign();\n-            builder.indent();\n-            builder.append(\")\");\n-        } else {\n-            \/\/ padding\n-            builder.append(\"MemoryLayout.ofPaddingBits(\" + l.bitSize() + \")\");\n-        }\n-        if (l.name().isPresent()) {\n-            builder.append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n-        }\n-    }\n-\n-    private String getFunctionDescFieldName(String javaName) {\n-        return javaName + \"$FUNC_\";\n-    }\n-\n-    private String emitFunctionDescField(String javaName, FunctionDescriptor desc) {\n-        builder.incrAlign();\n-        builder.indent();\n-        String fieldName = getFunctionDescFieldName(javaName);\n-        final boolean noArgs = desc.argumentLayouts().isEmpty();\n-        builder.append(PKG_STATIC_FINAL_MODS);\n-        builder.append(\"FunctionDescriptor \");\n-        builder.append(fieldName);\n-        builder.append(\" = \");\n-        if (desc.returnLayout().isPresent()) {\n-            builder.append(\"FunctionDescriptor.of(\");\n-            emitLayoutString(desc.returnLayout().get());\n-            if (!noArgs) {\n-                builder.append(\",\");\n-            }\n-        } else {\n-            builder.append(\"FunctionDescriptor.ofVoid(\");\n-        }\n-        if (!noArgs) {\n-            builder.append(\"\\n\");\n-            builder.incrAlign();\n-            String delim = \"\";\n-            for (MemoryLayout e : desc.argumentLayouts()) {\n-                builder.append(delim);\n-                builder.indent();\n-                emitLayoutString(e);\n-                delim = \",\\n\";\n-            }\n-            builder.append(\"\\n\");\n-            builder.decrAlign();\n-            builder.indent();\n-        }\n-        builder.append(\");\\n\");\n-        builder.decrAlign();\n-        return fieldName;\n-    }\n-\n-    private String getConstantSegmentFieldName(String javaName) {\n-        return javaName + \"$SEGMENT_CONSTANT_\";\n-    }\n-    private String emitConstantSegment(String javaName, Object value) {\n-        builder.incrAlign();\n-        builder.indent();\n-        String fieldName = getConstantSegmentFieldName(javaName);\n-        builder.append(PKG_STATIC_FINAL_MODS);\n-        builder.append(\"MemorySegment \");\n-        builder.append(fieldName);\n-        builder.append(\" = CLinker.toCString(\\\"\");\n-        builder.append(Utils.quote(Objects.toString(value)));\n-        builder.append(\"\\\");\\n\");\n-        builder.decrAlign();\n-        return fieldName;\n-    }\n-\n-    private String getConstantAddressFieldName(String javaName) {\n-        return javaName + \"$ADDR_CONSTANT_\";\n-    }\n-    private String emitConstantAddress(String javaName, Object value) {\n-        builder.incrAlign();\n-        builder.indent();\n-        String fieldName = getConstantAddressFieldName(javaName);\n-        builder.append(PKG_STATIC_FINAL_MODS);\n-        builder.append(\"MemoryAddress \");\n-        builder.append(fieldName);\n-        builder.append(\" = MemoryAddress.ofLong(\");\n-        builder.append(((Number)value).longValue());\n-        builder.append(\"L);\\n\");\n-        builder.decrAlign();\n-        return fieldName;\n-    }\n-\n-    private String getConstantString(Class<?> type, Object value) {\n-        StringBuilder buf = new StringBuilder();\n-        if (type == float.class) {\n-            float f = ((Number)value).floatValue();\n-            if (Float.isFinite(f)) {\n-                buf.append(value);\n-                buf.append(\"f\");\n-            } else {\n-                buf.append(\"Float.valueOf(\\\"\");\n-                buf.append(value.toString());\n-                buf.append(\"\\\")\");\n-            }\n-        } else if (type == long.class) {\n-            buf.append(value);\n-            buf.append(\"L\");\n-        } else if (type == double.class) {\n-            double d = ((Number)value).doubleValue();\n-            if (Double.isFinite(d)) {\n-                buf.append(value);\n-                buf.append(\"d\");\n-            } else {\n-                buf.append(\"Double.valueOf(\\\"\");\n-                buf.append(value.toString());\n-                buf.append(\"\\\")\");\n-            }\n-        } else {\n-            buf.append(\"(\" + type.getName() + \")\");\n-            buf.append(value + \"L\");\n-        }\n-        return buf.toString();\n-    }\n-\n-    private static String typeToLayoutName(ValueLayout vl) {\n-        if (UnsupportedLayouts.isUnsupported(vl)) {\n-            return \"MemoryLayout.ofPaddingBits(\" + vl.bitSize() + \")\";\n-        }\n-\n-        CLinker.TypeKind kind = (CLinker.TypeKind)vl.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-                () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n-        return switch (kind) {\n-            case CHAR -> \"C_CHAR\";\n-            case SHORT -> \"C_SHORT\";\n-            case INT -> \"C_INT\";\n-            case LONG -> \"C_LONG\";\n-            case LONG_LONG -> \"C_LONG_LONG\";\n-            case FLOAT -> \"C_FLOAT\";\n-            case DOUBLE -> \"C_DOUBLE\";\n-            case POINTER -> \"C_POINTER\";\n-        };\n-    }\n-\n-    private String getSegmentFieldName(String javaName) {\n-        return javaName + \"$SEGMENT_\";\n-    }\n-\n-    private String emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {\n-         addLayout(javaName, layout);\n-         builder.incrAlign();\n-         builder.indent();\n-         String fieldName = getSegmentFieldName(javaName);\n-         builder.append(PKG_STATIC_FINAL_MODS);\n-         builder.append(\"MemorySegment \");\n-         builder.append(fieldName);\n-         builder.append(\" = \");\n-         builder.append(\"RuntimeHelper.lookupGlobalVariable(\");\n-         builder.append(\"LIBRARIES, \\\"\");\n-         builder.append(nativeName);\n-         builder.append(\"\\\", \");\n-         builder.append(getLayoutFieldName(javaName));\n-         builder.append(\");\\n\");\n-         builder.decrAlign();\n-         return fieldName;\n-    }\n-\n-    private void emitLibraries(String[] libraryNames) {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PKG_STATIC_FINAL_MODS);\n-        builder.append(\"LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\\n\");\n-        builder.incrAlign();\n-        for (String lib : libraryNames) {\n-            builder.indent();\n-            builder.append('\\\"');\n-            builder.append(quoteLibraryName(lib));\n-            builder.append(\"\\\",\\n\");\n-        }\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"});\\n\\n\");\n-        builder.decrAlign();\n-    }\n-\n-    private static String quoteLibraryName(String lib) {\n-        return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/SourceConstantHelper.java","additions":0,"deletions":521,"binary":false,"changes":521,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-public class StringSourceBuilder {\n-\n-    \/\/ code buffer\n-    private StringBuilder sb = new StringBuilder();\n-    \/\/ current line alignment (number of 4-spaces)\n-    private int align;\n-\n-    void append(String s) {\n-        sb.append(s);\n-    }\n-\n-    void append(char c) {\n-        sb.append(c);\n-    }\n-\n-    void append(boolean b) {\n-        sb.append(b);\n-    }\n-\n-    void append(long l) {\n-        sb.append(l);\n-    }\n-\n-    void indent() {\n-        for (int i = 0; i < align; i++) {\n-            append(\"    \");\n-        }\n-    }\n-\n-    void incrAlign() {\n-        align++;\n-    }\n-\n-    void decrAlign() {\n-        align--;\n-    }\n-\n-    String build() {\n-        String s = sb.toString();\n-        sb = null;\n-        return s;\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StringSourceBuilder.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.jextract.Declaration;\n@@ -38,0 +39,2 @@\n+import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n+\n@@ -41,1 +44,3 @@\n-class StructBuilder extends NestedClassBuilder {\n+class StructBuilder extends ConstantBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n@@ -52,0 +57,1 @@\n+        classBegin();\n@@ -54,2 +60,2 @@\n-    public void pushPrefixElement(String prefixElementName) {\n-        this.prefixElementNames.push(prefixElementName);\n+    void pushPrefixElement(String prefixElementName) {\n+        prefixElementNames.push(prefixElementName);\n@@ -58,2 +64,2 @@\n-    public void popPrefixElement() {\n-        this.prefixElementNames.pop();\n+    void popPrefixElement() {\n+        prefixElementNames.pop();\n@@ -63,1 +69,3 @@\n-        return Collections.unmodifiableList(new ArrayList<>(prefixElementNames));\n+        List<String> prefixes = new ArrayList<>(prefixElementNames);\n+        Collections.reverse(prefixes);\n+        return Collections.unmodifiableList(prefixes);\n@@ -67,2 +75,4 @@\n-    Type type() {\n-        return structType;\n+    void classBegin() {\n+        super.classBegin();\n+        addLayout(layoutField(), ((Type.Declared)structType).tree().layout().get())\n+                .emitGetter(this, MEMBER_MODS, Constant.SUFFIX_ONLY);\n@@ -73,13 +83,15 @@\n-        emitSizeof();\n-        emitAllocate();\n-        emitScopeAllocate();\n-        emitAllocateArray();\n-        emitScopeAllocateArray();\n-        emitAllocatePoiner();\n-        emitScopeAllocatePointer();\n-        emitAsRestricted();\n-        return super.classEnd();\n-    }\n-\n-    private String getQualifiedName(String fieldName) {\n-        return qualifiedName(this) + \"$\" + fieldName;\n+        if (prefixElementNames.isEmpty()) {\n+            emitSizeof();\n+            emitAllocate();\n+            emitScopeAllocate();\n+            emitAllocateArray();\n+            emitScopeAllocateArray();\n+            emitAllocatePoiner();\n+            emitScopeAllocatePointer();\n+            emitAsRestricted();\n+            return super.classEnd();\n+        } else {\n+            \/\/ we're in an anonymous struct which got merged into this one, return this very builder and keep it open\n+            popPrefixElement();\n+            return this;\n+        }\n@@ -89,12 +101,10 @@\n-    void addVarHandleGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        var desc = constantHelper.addFieldVarHandle(getQualifiedName(javaName), nativeName, layout, type, layoutField(), structLayout, prefixNamesList());\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + displayName(desc.invocationType().returnType()) + \" \" + javaName + \"$VH() {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return \" + getCallString(desc) + \";\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        if (name.isEmpty() && (parent instanceof Declaration.Scoped)) {\n+            \/\/nested anon struct - merge into this builder!\n+            GroupLayout parentLayout = (GroupLayout)((Declaration.Scoped)parent).layout().get();\n+            String anonName = findAnonymousStructName(parentLayout, layout);\n+            pushPrefixElement(anonName);\n+            return this;\n+        } else {\n+            return super.addStruct(name, parent, layout, type);\n+        }\n@@ -103,13 +113,13 @@\n-    @Override\n-    void addLayoutGetter(String javaName, MemoryLayout layout) {\n-        var desc = constantHelper.addLayout(javaName, layout);\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + displayName(desc.invocationType().returnType()) + \" $LAYOUT() {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return \" + getCallString(desc) + \";\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+    private String findAnonymousStructName(GroupLayout parentLayout, GroupLayout layout) {\n+        \/\/ nested anonymous struct or union\n+        for (MemoryLayout ml : parentLayout.memberLayouts()) {\n+            \/\/ look for anonymous structs\n+            if (ml.attribute(JEXTRACT_ANONYMOUS).isPresent()) {\n+                \/\/ it's enough to just compare the member layouts, since the member names\n+                \/\/ have to be unique within the parent layout (in C)\n+                if (((GroupLayout) ml).memberLayouts().equals(layout.memberLayouts())) {\n+                    return ml.name().orElseThrow();\n+                }\n+            }\n+        }\n+        throw new IllegalStateException(\"Could not find layout in parent\");\n@@ -119,12 +129,12 @@\n-    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(MemorySegment seg) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return (\" + type.getName() + \")\"\n-                + fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) + \".get(seg);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        if (type.equals(MemorySegment.class)) {\n+            emitSegmentGetter(javaName, nativeName, layout);\n+        } else {\n+            Constant vhConstant = addFieldVarHandle(javaName, nativeName, layout, type, layoutField(), prefixNamesList())\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+            emitFieldGetter(vhConstant, javaName, type);\n+            emitFieldSetter(vhConstant, javaName, type);\n+            emitIndexedFieldGetter(vhConstant, javaName, type);\n+            emitIndexedFieldSetter(vhConstant, javaName, type);\n+        }\n+    }\n@@ -132,1 +142,12 @@\n-        addIndexGetter(javaName, nativeName, layout, type);\n+    private void emitFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(MemorySegment seg) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\"\n+                + vhConstant.accessExpression() + \".get(seg);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -135,4 +156,3 @@\n-    @Override\n-    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        builder.incrAlign();\n-        builder.indent();\n+    private void emitFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n@@ -140,10 +160,8 @@\n-        builder.append(PUB_MODS + \"void \" + javaName + \"$set( \" + param + \", \" + type.getSimpleName() + \" x) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) + \".set(seg, x);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n-\n-        addIndexSetter(javaName, nativeName, layout, type);\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set( \" + param + \", \" + type.getSimpleName() + \" x) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression() + \".set(seg, x);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -163,17 +181,15 @@\n-    @Override\n-    void addSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS + \"MemorySegment \" + javaName + \"$slice(MemorySegment seg) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(\");\n-        builder.append(structLayout.byteOffset(elementPaths(nativeName)));\n-        builder.append(\", \");\n-        builder.append(layout.byteSize());\n-        builder.append(\"));\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n-\n+    private void emitSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" MemorySegment \" + javaName + \"$slice(MemorySegment seg) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(\");\n+        append(structLayout.byteOffset(elementPaths(nativeName)));\n+        append(\", \");\n+        append(layout.byteSize());\n+        append(\"));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -183,5 +199,5 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\"long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n+        decrAlign();\n@@ -191,5 +207,5 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n+        decrAlign();\n@@ -199,5 +215,5 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n+        decrAlign();\n@@ -207,11 +223,11 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocateArray(int len) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append('}');\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        decrAlign();\n+        indent();\n+        append('}');\n+        decrAlign();\n@@ -221,11 +237,11 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -235,11 +251,11 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocatePointer() {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -249,11 +265,11 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return scope.allocate(C_POINTER);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return scope.allocate(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -263,5 +279,5 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n+        decrAlign();\n@@ -270,3 +286,3 @@\n-    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        builder.incrAlign();\n-        builder.indent();\n+    private void emitIndexedFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n@@ -274,5 +290,5 @@\n-        builder.append(PUB_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return (\" + type.getName() + \")\"\n-                + fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) +\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\"\n+                + vhConstant.accessExpression() +\n@@ -280,4 +296,4 @@\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -286,3 +302,3 @@\n-    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        builder.incrAlign();\n-        builder.indent();\n+    private void emitIndexedFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n@@ -290,4 +306,4 @@\n-        builder.append(PUB_MODS + \"void \" + javaName + \"$set(\" + params + \") {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) +\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression() +\n@@ -295,8 +311,4 @@\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n-    }\n-\n-    private String fieldVarHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        return getCallString(constantHelper.addFieldVarHandle(javaName, nativeName, layout, type, layoutField(), structLayout, prefixNamesList()));\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -310,2 +322,2 @@\n-                    nestedClassBuilder.className :\n-                    prefix + \"$\" + nestedClassBuilder.className;\n+                    nestedClassBuilder.className() :\n+                    prefix + \"$\" + nestedClassBuilder.className();\n@@ -317,1 +329,1 @@\n-    String layoutField() {\n+    private String layoutField() {\n@@ -321,5 +333,0 @@\n-\n-    @Override\n-    StructBuilder newStructBuilder(String name, GroupLayout structLayout, Type type) {\n-        return new StructBuilder(this, name, structLayout, type);\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":196,"deletions":189,"binary":false,"changes":385,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n@@ -31,0 +34,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -33,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -40,1 +45,1 @@\n-class ToplevelBuilder extends HeaderFileBuilder {\n+class ToplevelBuilder extends JavaSourceBuilder {\n@@ -43,0 +48,2 @@\n+    private final String[] libraryNames;\n+    private final List<SplitHeader> headers = new ArrayList<>();\n@@ -46,2 +53,6 @@\n-    ToplevelBuilder(String headerFileName, String pkgName, ConstantHelper constantHelper) {\n-        super(headerFileName, pkgName, null, constantHelper);\n+    ToplevelBuilder(ClassDesc desc, String[] libraryNames) {\n+        super(Kind.CLASS, desc);\n+        this.libraryNames = libraryNames;\n+        SplitHeader first = new FirstHeader(ClassDesc.of(packageName(), className()));\n+        first.classBegin();\n+        headers.add(first);\n@@ -51,2 +62,2 @@\n-    String superClass() {\n-        return \"#{SUPER}\";\n+    void classBegin() {\n+        throw new UnsupportedOperationException();\n@@ -56,2 +67,2 @@\n-    protected String getClassModifiers() {\n-        return PUB_CLS_MODS;\n+    JavaSourceBuilder classEnd() {\n+        throw new UnsupportedOperationException();\n@@ -60,3 +71,3 @@\n-    List<JavaFileObject> build() {\n-        String res = builder.build().replace(\"extends #{SUPER}\",\n-                lastHeader().map(h -> \"extends \" + h.className).orElse(\"\"));\n+    public List<JavaFileObject> toFiles() {\n+        headers.stream().skip(1).findFirst()\n+                .orElse(lastHeader()).emitLibraries(libraryNames);\n@@ -64,2 +75,0 @@\n-        files.add(Utils.fileFromString(pkgName, className, res));\n-        files.addAll(constantHelper.build());\n@@ -67,1 +76,1 @@\n-                .flatMap(hf -> hf.build().stream())\n+                .flatMap(hf -> hf.toFiles().stream())\n@@ -72,4 +81,3 @@\n-    void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc, Type type) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, mtype, desc, type);\n-        builder.classBegin();\n-        builder.classEnd();\n+    @Override\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        nextHeader().addVar(javaName, nativeName, layout, type);\n@@ -78,4 +86,3 @@\n-    void addTypeDef(String name, String superClass, Type type) {\n-        TypedefBuilder builder = new TypedefBuilder(this, name, superClass, type);\n-        builder.classBegin();\n-        builder.classEnd();\n+    @Override\n+    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+        nextHeader().addFunction(javaName, nativeName, mtype, desc, varargs, paramNames);\n@@ -84,1 +91,4 @@\n-    private List<HeaderFileBuilder> headers = new ArrayList<>();\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        nextHeader().addConstant(javaName, type, value);\n+    }\n@@ -86,4 +96,3 @@\n-    Optional<HeaderFileBuilder> lastHeader() {\n-        return headers.size() == 0 ?\n-                Optional.empty() :\n-                Optional.of(headers.get(headers.size() - 1));\n+    @Override\n+    public void addTypedef(String name, String superClass, Type type) {\n+        nextHeader().addTypedef(name, superClass, type);\n@@ -92,5 +101,19 @@\n-    HeaderFileBuilder nextHeader() {\n-        if (declCount > DECLS_PER_HEADER_CLASS) {\n-            HeaderFileBuilder headerFileBuilder = new HeaderFileBuilder(className + \"_\" + headers.size(), pkgName,\n-                    lastHeader().map(h -> h.className).orElse(null),\n-                    constantHelper);\n+    @Override\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        return nextHeader().addStruct(name, parent, layout, type);\n+    }\n+\n+    @Override\n+    public void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc) {\n+        nextHeader().addFunctionalInterface(name, mtype, desc);\n+    }\n+\n+    private SplitHeader lastHeader() {\n+        return headers.get(headers.size() - 1);\n+    }\n+\n+    private SplitHeader nextHeader() {\n+        if (declCount == DECLS_PER_HEADER_CLASS) {\n+            boolean hasSuper = !(lastHeader() instanceof FirstHeader);\n+            SplitHeader headerFileBuilder = new SplitHeader(ClassDesc.of(packageName(), className() + \"_\" + headers.size()),\n+                    hasSuper ? lastHeader().className() : null);\n@@ -103,1 +126,69 @@\n-            return lastHeader().orElse(this);\n+            return lastHeader();\n+        }\n+    }\n+\n+    static class SplitHeader extends HeaderFileBuilder {\n+        SplitHeader(ClassDesc desc, String superclass) {\n+            super(desc, superclass);\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \" \";\n+        }\n+\n+        private void emitLibraries(String[] libraryNames) {\n+            incrAlign();\n+            indent();\n+            append(\"static final \");\n+            append(\"LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\\n\");\n+            incrAlign();\n+            for (String lib : libraryNames) {\n+                indent();\n+                append('\\\"');\n+                append(quoteLibraryName(lib));\n+                append(\"\\\",\\n\");\n+            }\n+            decrAlign();\n+            indent();\n+            append(\"});\\n\\n\");\n+            decrAlign();\n+        }\n+\n+        private static String quoteLibraryName(String lib) {\n+            return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+        }\n+    }\n+\n+    class FirstHeader extends SplitHeader {\n+\n+        FirstHeader(ClassDesc desc) {\n+            super(desc, \"#{SUPER}\");\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \"public \";\n+        }\n+\n+        @Override\n+        void classBegin() {\n+            super.classBegin();\n+            emitConstructor();\n+        }\n+\n+        void emitConstructor() {\n+            incrAlign();\n+            indent();\n+            append(\"\/* package-private *\/ \");\n+            append(className());\n+            append(\"() {}\");\n+            append('\\n');\n+            decrAlign();\n+        }\n+\n+        @Override\n+        String build() {\n+            HeaderFileBuilder last = lastHeader();\n+            return super.build().replace(\"extends #{SUPER}\",\n+                    last != this ? \"extends \" + last.className() : \"\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":123,"deletions":32,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.jextract.Type;\n-\n@@ -32,1 +30,2 @@\n-    private final Type type;\n+    private static String MEMBER_MODS = \"public static \";\n+\n@@ -35,1 +34,1 @@\n-    public TypedefBuilder(JavaSourceBuilder prev, String className, String superClass, Type type) {\n+    public TypedefBuilder(JavaSourceBuilder prev, String className, String superClass) {\n@@ -37,1 +36,0 @@\n-        this.type = type;\n@@ -41,5 +39,0 @@\n-    @Override\n-    Type type() {\n-        return type;\n-    }\n-\n@@ -61,11 +54,11 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocatePointer() {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n@@ -74,11 +67,11 @@\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(PUB_MODS);\n-        builder.append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n-        builder.incrAlign();\n-        builder.indent();\n-        builder.append(\"return scope.allocate(C_POINTER);\\n\");\n-        builder.decrAlign();\n-        builder.indent();\n-        builder.append(\"}\\n\");\n-        builder.decrAlign();\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return scope.allocate(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-                \"-parameters\", \"-g:lines\",\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Writer.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,21 +0,0 @@\n-\/\/ Generated by jextract\n-\n-import java.lang.annotation.Documented;\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-\/**\n- * Annotation to indicate C types\n- *\/\n-@Target({ ElementType.TYPE_USE })\n-@Retention(RetentionPolicy.RUNTIME)\n-@Documented\n-public @interface C {\n-    \/**\n-     * The C type associated with a given Java type\n-     * @return The C type associated with a given Java type\n-     *\/\n-    String value();\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/C.java.template","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -29,1 +29,1 @@\n-    static <T> T requireNonNull(T obj, String msg) {\n+    static <T> T requireNonNull(T obj, String symbolName) {\n@@ -31,1 +31,1 @@\n-            throw new UnsatisfiedLinkError(msg);\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Parameter;\n-import java.nio.file.Path;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-\n-\/*\n- * @test\n- * @library \/test\/lib\n- * @modules jdk.incubator.jextract\n- * @build JextractToolRunner\n- * @bug 8252302\n- * @summary jextract should compile generated java code with -parameters and -g:lines option\n- * @run testng\/othervm -Dforeign.restricted=permit Test8252302\n- *\/\n-public class Test8252302 extends JextractToolRunner {\n-    @Test\n-    public void test() {\n-        Path outputPath = getOutputFilePath(\"output8252302\");\n-        Path headerFile = getInputFilePath(\"test8252302.h\");\n-        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n-        try(Loader loader = classLoader(outputPath)) {\n-            Class<?> headerClass = loader.loadClass(\"test8252302_h\");\n-            Method m = findMethod(headerClass, \"func\", int.class, int.class);\n-            Parameter[] params = m.getParameters();\n-            assertEquals(params[0].getName(), \"x\");\n-            assertEquals(params[1].getName(), \"y\");\n-        } finally {\n-            deleteDir(outputPath);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/tools\/jextract\/Test8252302.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -45,1 +45,0 @@\n-            checkPresent(loader, \"split_h_0\");\n@@ -49,3 +48,2 @@\n-            checkMissing(loader, \"split_h_4\");\n-            checkPresent(loader, \"split_h_constants_0\");\n-            checkMissing(loader, \"split_h_constants_1\");\n+            checkPresent(loader, \"split_h_4\");\n+            checkMissing(loader, \"split_h_5\");\n","filename":"test\/jdk\/tools\/jextract\/TestSplit.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif \/\/ __cplusplus\n-\n-void func(int x, int y);\n-\n-#ifdef __cplusplus\n-}\n-#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8252302.h","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"}]}