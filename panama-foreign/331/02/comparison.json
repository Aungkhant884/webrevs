{"files":[{"patch":"@@ -20,1 +20,1 @@\n-message=Merge\n+message=Merge \n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,4 @@\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n+\n+import java.util.Objects;\n@@ -86,3 +90,34 @@\n-     * Returns the raw long value associated to this memory address.\n-     * @return The raw long value associated to this memory address.\n-     * @throws UnsupportedOperationException if this memory address is associated with an heap segment.\n+     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n+     * bounds, and can therefore be closed. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from native code\n+     * (often as a plain {@code long} value). The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * <p>\n+     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n+     * memory resources which might implicitly be associated with the segment. If the client wants to specify\n+     * a cleanup action to be executed when the returned segment is closed, the {@link MemorySegment#withCleanupAction(Runnable)}\n+     * method should be used.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param bytesSize the desired size.\n+     * @return a new confined native memory segment with given base address and size.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     *\/\n+    default MemorySegment asSegmentRestricted(long bytesSize) {\n+        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize);\n+    }\n+\n+    \/**\n+     * Returns the raw long value associated with this memory address.\n+     * @return The raw long value associated with this memory address.\n+     * @throws UnsupportedOperationException if this memory address is an heap address.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -260,1 +260,0 @@\n-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n@@ -267,0 +266,21 @@\n+    \/**\n+     * Obtains a new memory segment backed by the same underlying memory region as this segment, and featuring\n+     * the same confinement thread (see {@link #ownerThread()} and access modes (see {@link #accessModes()}),\n+     * but with a different cleanup action. More specifically, the cleanup action associated with the returned segment will\n+     * first call the user-provided action, before delegating back to the original cleanup action associated with\n+     * this segment (if any). Any errors and\/or exceptions thrown by the user-provided action will be discarded, and will not prevent the\n+     * release of any memory resources associated with this segment.\n+     * <p>\n+     * As a side-effect, this segment will be marked as <em>not alive<\/em>,\n+     * and subsequent operations on this segment will result in runtime errors.\n+     *\n+     * @param action the new cleanup action\n+     * @return a new memory segment backed by the same underlying memory region as this segment; the cleanup action\n+     * associated with the new segment is the result of composing this segment's cleanup action with the\n+     * supplied {@code action}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws NullPointerException if {@code action == null}\n+     *\/\n+    MemorySegment withCleanupAction(Runnable action);\n+\n@@ -524,1 +544,1 @@\n-     * Creates a new buffer memory segment that models the memory associated with the given byte\n+     * Creates a new confined buffer memory segment that models the memory associated with the given byte\n@@ -530,1 +550,1 @@\n-     * not feature the {@link #WRITE} access mode.\n+     * not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -536,1 +556,1 @@\n-     * @return a new buffer memory segment.\n+     * @return a new confined buffer memory segment.\n@@ -543,1 +563,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n@@ -547,1 +567,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -550,1 +570,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -557,1 +577,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n@@ -561,1 +581,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -564,1 +584,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -571,1 +591,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n@@ -575,1 +595,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -578,1 +598,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -585,1 +605,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n@@ -588,1 +608,2 @@\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>.\n+     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -591,1 +612,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -598,1 +619,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n@@ -602,1 +623,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -605,1 +626,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -612,1 +633,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n@@ -616,1 +637,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -619,1 +640,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -626,1 +647,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n@@ -633,1 +654,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -640,1 +661,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout.\n@@ -660,1 +681,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n@@ -672,1 +693,1 @@\n-     * @return a new native memory segment.\n+     * @return a new confined native memory segment.\n@@ -680,1 +701,1 @@\n-     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * Creates a new confined mapped memory segment that models a memory-mapped region of a file from a given path.\n@@ -684,1 +705,1 @@\n-     * the segment will not feature the {@link #WRITE} access mode.\n+     * the segment will not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -694,1 +715,1 @@\n-     * @return a new mapped memory segment.\n+     * @return a new confined mapped memory segment.\n@@ -705,1 +726,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size and\n@@ -707,1 +728,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -715,1 +736,1 @@\n-     * @return a new native memory segment.\n+     * @return a new confined native memory segment.\n@@ -733,1 +754,1 @@\n-     * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n+     * Returns a shared native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n@@ -738,1 +759,2 @@\n-    MemorySegment.ofNativeRestricted(MemoryAddress.NULL, Long.MAX_VALUE, null, null, null)\n+    MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE)\n+                 .withOwnerThread(null)\n@@ -755,36 +777,0 @@\n-    \/**\n-     * Returns a new native memory segment with given base address and size; the returned segment has its own temporal\n-     * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup\n-     * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,\n-     * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code\n-     * (often as a plain {@code long} value). The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}).\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr the desired base address\n-     * @param bytesSize the desired size.\n-     * @param owner the desired owner thread. If {@code owner == null}, the returned segment is <em>not<\/em> confined.\n-     * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the\n-     *                returned segment. If {@code cleanup == null}, no cleanup action is executed.\n-     * @param attachment an object that must be kept alive by the returned segment; this can be useful when\n-     *                   the returned segment depends on memory which could be released if a certain object\n-     *                   is determined to be unreacheable. In most cases this will be set to {@code null}.\n-     * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n-     * @throws NullPointerException if {@code addr == null}.\n-     *\/\n-    static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {\n-        Objects.requireNonNull(addr);\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n-        Utils.checkRestrictedAccess(\"MemorySegment.ofNativeRestricted\");\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":57,"deletions":71,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -312,0 +312,6 @@\n+    @Override\n+    public MemorySegment withCleanupAction(Runnable action) {\n+        checkValidState();\n+        return dup(0L, length, mask, scope.wrapAction(action));\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(\n-                MemoryAddress.ofLong(value), byteSize, null, null, null);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize)\n+                .withOwnerThread(null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,11 +66,1 @@\n-        return createConfined(Thread.currentThread(), ref, cleanupAction);\n-    }\n-\n-    \/**\n-     * Creates a confined memory scope with given attachment, cleanup action and owner thread.\n-     * @param ref           an optional reference to an instance that needs to be kept reachable\n-     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n-     * @return a confined memory scope\n-     *\/\n-    static MemoryScope createConfined(Thread owner, Object ref, CleanupAction cleanupAction) {\n-        return new ConfinedScope(owner, ref, cleanupAction);\n+        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction);\n@@ -153,0 +143,11 @@\n+    final MemoryScope wrapAction(Runnable runnable) {\n+        try {\n+            justClose();\n+            return ownerThread() == null ?\n+                    new SharedScope(ref, cleanupAction.wrap(runnable)) :\n+                    new ConfinedScope(ownerThread(), ref, cleanupAction.wrap(runnable));\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n@@ -272,0 +273,1 @@\n+        CleanupAction wrap(Runnable runnable);\n@@ -289,0 +291,5 @@\n+\n+            @Override\n+            public CleanupAction wrap(Runnable runnable) {\n+                return AtMostOnceOnly.of(runnable);\n+            }\n@@ -323,0 +330,14 @@\n+            @Override\n+            public CleanupAction wrap(Runnable runnable) {\n+                disable();\n+                return AtMostOnceOnly.of(() -> {\n+                    try {\n+                        runnable.run();\n+                    } catch (Throwable t) {\n+                        \/\/ ignore\n+                    } finally {\n+                        doCleanup();\n+                    }\n+                });\n+            }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -44,2 +44,3 @@\n-    public static final MemorySegment EVERYTHING = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.NULL,\n-            Long.MAX_VALUE, null, null, null).withAccessModes(READ | WRITE);\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE)\n+            .withOwnerThread(null)\n+            .withAccessModes(READ | WRITE);\n@@ -116,7 +117,3 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {\n-        MemoryScope.CleanupAction cleanupAction = cleanup != null ?\n-                MemoryScope.CleanupAction.AtMostOnceOnly.of(cleanup) : MemoryScope.CleanupAction.DUMMY;\n-        MemoryScope scope = owner == null ?\n-                MemoryScope.createShared(attachment, cleanupAction) :\n-                MemoryScope.createConfined(owner, attachment, cleanupAction);\n-        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), scope);\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize) {\n+        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize),\n+                MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,2 +36,3 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress),\n-                0, null, () -> freeUpcallStub(stubAddress), null)\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0)\n+                .withOwnerThread(null)\n+                .withCleanupAction(() -> freeUpcallStub(stubAddress))\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,3 +117,2 @@\n-        MemorySegment gpRegsArea = MemorySegment.ofNativeRestricted(\n-            grTop(segment).addOffset(-MAX_GP_OFFSET), MAX_GP_OFFSET,\n-            segment.ownerThread(), null, null);\n+        MemorySegment gpRegsArea = handoffIfNeeded(grTop(segment).addOffset(-MAX_GP_OFFSET)\n+                .asSegmentRestricted(MAX_GP_OFFSET), segment.ownerThread());\n@@ -121,3 +120,2 @@\n-        MemorySegment fpRegsArea = MemorySegment.ofNativeRestricted(\n-            vrTop(segment).addOffset(-MAX_FP_OFFSET), MAX_FP_OFFSET,\n-            segment.ownerThread(), null, null);\n+        MemorySegment fpRegsArea = handoffIfNeeded(vrTop(segment).addOffset(-MAX_FP_OFFSET)\n+                .asSegmentRestricted(MAX_FP_OFFSET), segment.ownerThread());\n@@ -130,2 +128,3 @@\n-                MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null,\n-                () -> U.freeMemory(ptr), null);\n+                MemoryAddress.ofLong(ptr), LAYOUT.byteSize())\n+                .withOwnerThread(null)\n+                .withCleanupAction(() -> U.freeMemory(ptr));\n@@ -259,3 +258,2 @@\n-                    try (MemorySegment slice = MemorySegment.ofNativeRestricted(\n-                             stackPtr(), layout.byteSize(),\n-                             segment.ownerThread(), null, null)) {\n+                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n+                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n@@ -270,3 +268,2 @@\n-                    try (MemorySegment slice = MemorySegment.ofNativeRestricted(\n-                             stackPtr(), layout.byteSize(),\n-                             segment.ownerThread(), null, null)) {\n+                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n+                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n@@ -318,2 +315,2 @@\n-                    try (MemorySegment slice = MemorySegment.ofNativeRestricted(\n-                             ptr, layout.byteSize(), segment.ownerThread(), null, null)) {\n+                    try (MemorySegment slice = handoffIfNeeded(ptr\n+                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n@@ -363,2 +360,1 @@\n-        return readFromSegment(MemorySegment.ofNativeRestricted(\n-                ma, LAYOUT.byteSize(), Thread.currentThread(), null, null));\n+        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize()));\n@@ -565,0 +561,5 @@\n+\n+    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n+        return segment.ownerThread() == thread ?\n+                segment : segment.withOwnerThread(thread);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -135,1 +135,3 @@\n-                MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null, () -> U.freeMemory(ptr), null);\n+                MemoryAddress.ofLong(ptr), LAYOUT.byteSize())\n+                .withOwnerThread(null)\n+                .withCleanupAction(() -> U.freeMemory(ptr));\n@@ -177,2 +179,2 @@\n-        return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment),\n-            LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);\n+        return handoffIfNeeded(((MemoryAddress)VH_reg_save_area.get(segment))\n+                .asSegmentRestricted(LAYOUT_REG_SAVE_AREA.byteSize()), segment.ownerThread());\n@@ -233,2 +235,2 @@\n-                    try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),\n-                                                                                segment.ownerThread(), null, null)) {\n+                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n+                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n@@ -243,2 +245,2 @@\n-                    try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),\n-                                                                                segment.ownerThread(), null, null)) {\n+                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n+                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n@@ -307,3 +309,1 @@\n-        MemorySegment vaListSegment\n-            = MemorySegment.ofNativeRestricted(ma, LAYOUT.byteSize(), Thread.currentThread(), null, null);\n-        return readFromSegment(vaListSegment);\n+        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize()));\n@@ -478,0 +478,5 @@\n+\n+    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n+        return segment.ownerThread() == thread ?\n+            segment : segment.withOwnerThread(thread);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-                    try (MemorySegment struct = MemorySegment.ofNativeRestricted(structAddr, layout.byteSize(),\n-                                                                            segment.ownerThread(), null, null)) {\n+                    try (MemorySegment struct = handoffIfNeeded(structAddr.asSegmentRestricted(layout.byteSize()),\n+                         segment.ownerThread())) {\n@@ -146,1 +146,1 @@\n-        MemorySegment segment = MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(), null, null);\n+        MemorySegment segment = addr.asSegmentRestricted(Long.MAX_VALUE);\n@@ -163,2 +163,2 @@\n-        MemorySegment liveness = MemorySegment.ofNativeRestricted(\n-                MemoryAddress.NULL, 1, segment.ownerThread(), null, null);\n+        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n+                segment.ownerThread());\n@@ -170,2 +170,2 @@\n-        MemorySegment liveness = MemorySegment.ofNativeRestricted(\n-                MemoryAddress.NULL, 1, segment.ownerThread(), null, null);\n+        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n+                segment.ownerThread());\n@@ -264,0 +264,5 @@\n+\n+    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n+        return segment.ownerThread() == thread ?\n+                segment : segment.withOwnerThread(thread);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-                this.base = MemorySegment.ofNativeRestricted(addr, SIZE, Thread.currentThread(),\n-                        null, null);\n+                this.base = addr.asSegmentRestricted(SIZE);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.function.ToIntFunction;\n@@ -116,1 +115,1 @@\n-        try (MemorySegment segment = MemorySegment.ofNativeRestricted(MemoryAddress.NULL, seq.byteSize(), null, null, null)) {\n+        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize())) {\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n+ * @run testng TestCleaner\n@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -64,1 +63,2 @@\n-        MemorySegment segment = makeSegment(segmentState);\n+        MemorySegment segment = MemorySegment.allocateNative(10)\n+                .withCleanupAction(segmentState::cleanup);\n@@ -91,4 +91,0 @@\n-    MemorySegment makeSegment(SegmentState segmentState) {\n-        return MemorySegment.ofNativeRestricted(MemoryAddress.NULL, 10, Thread.currentThread(), segmentState::cleanup, null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-        return MemorySegment.ofNativeRestricted(addr, numElements * layout.byteSize(),\n-               Thread.currentThread(), null, null);\n+        return addr.asSegmentRestricted(numElements * layout.byteSize());\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,2 +175,2 @@\n-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,\n-                () -> free(addr), null);\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n+                .withCleanupAction(() -> free(addr));\n@@ -193,2 +193,2 @@\n-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,\n-                () -> free(addr), null);\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n+                .withCleanupAction(() -> free(addr));\n@@ -212,1 +212,1 @@\n-            MemorySegment.ofNativeRestricted(segment.address(), 0, null, null, null);\n+            segment.address().asSegmentRestricted(0);\n@@ -216,5 +216,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullUnsafeSegment() {\n-        MemorySegment.ofNativeRestricted(null, 10, null, null, null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -41,1 +41,1 @@\n-        MemorySegment.ofNativeRestricted(MemoryAddress.ofLong(42), 10, null, null, null);\n+        MemorySegment.ofNativeRestricted();\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -339,1 +339,2 @@\n-                \"registerCleaner\"\n+                \"registerCleaner\",\n+                \"withCleanupAction\"\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.*;\n@@ -130,2 +127,2 @@\n-            MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(\n-                    s.address(), s.byteSize(), null, null, null);\n+            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize())\n+                    .withOwnerThread(null);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -725,2 +725,1 @@\n-                    MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),\n-                            Thread.currentThread(), null, null);\n+                    MemorySegment ms = intPtr.asSegmentRestricted(C_INT.byteSize());\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n@@ -81,1 +82,1 @@\n-        try (VaList vaList = VaList.make(b ->\n+        try (CLinker.VaList vaList = CLinker.VaList.make(b ->\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}