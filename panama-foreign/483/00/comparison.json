{"files":[{"patch":"@@ -123,2 +123,0 @@\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n@@ -149,4 +147,2 @@\n-    default MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n-        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-    }\n+    @NativeAccess\n+    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n@@ -170,10 +166,2 @@\n-    default MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n-        Objects.requireNonNull(allocator);\n-        MethodHandle downcall = MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-        if (type.returnType().equals(MemorySegment.class)) {\n-            downcall = MethodHandles.insertArguments(downcall, 0, allocator);\n-        }\n-        return downcall;\n-    }\n-\n+    @NativeAccess\n+    MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function);\n@@ -198,0 +186,1 @@\n+    @NativeAccess\n@@ -213,0 +202,1 @@\n+    @NativeAccess\n@@ -228,3 +218,2 @@\n-    default MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n-        return upcallStub(target, function, MemoryScope.createDefault());\n-    }\n+    @NativeAccess\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);\n@@ -411,1 +400,1 @@\n-    static String toJavaStringRestricted(MemoryAddress addr) {\n+    static String toJavaString(MemoryAddress addr) {\n@@ -435,1 +424,1 @@\n-    static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {\n+    static String toJavaString(MemoryAddress addr, Charset charset) {\n@@ -511,1 +500,1 @@\n-    static MemoryAddress allocateMemoryRestricted(long size) {\n+    static MemoryAddress allocateMemory(long size) {\n@@ -532,1 +521,1 @@\n-    static void freeMemoryRestricted(MemoryAddress addr) {\n+    static void freeMemory(MemoryAddress addr) {\n@@ -701,1 +690,1 @@\n-        static VaList ofAddressRestricted(MemoryAddress address) {\n+        static VaList ofAddress(MemoryAddress address) {\n@@ -720,1 +709,1 @@\n-        static VaList ofAddressRestricted(MemoryAddress address, ResourceScope scope) {\n+        static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    @NativeAccess\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegmentRestricted(long, Runnable, ResourceScope)}.\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegment(long, Runnable, ResourceScope)}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n@@ -105,1 +103,1 @@\n-    asSegmentRestricted(byteSize, null, ResourceScope.globalScope());\n+    asSegment(byteSize, null, ResourceScope.globalScope());\n@@ -115,2 +113,0 @@\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n@@ -118,1 +114,0 @@\n-    @CallerSensitive\n@@ -120,4 +115,1 @@\n-    default MemorySegment asSegmentRestricted(long bytesSize) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return asSegmentRestricted(bytesSize, null, ResourceScope.globalScope());\n-    }\n+    MemorySegment asSegment(long bytesSize);\n@@ -138,1 +130,1 @@\n-    asSegmentRestricted(byteSize, null, scope);\n+    asSegment(byteSize, null, scope);\n@@ -149,2 +141,0 @@\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n@@ -153,3 +143,1 @@\n-    default MemorySegment asSegmentRestricted(long bytesSize, ResourceScope scope) {\n-        return asSegmentRestricted(bytesSize, null, scope);\n-    }\n+    MemorySegment asSegment(long bytesSize, ResourceScope scope);\n@@ -180,2 +168,0 @@\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n@@ -184,1 +170,1 @@\n-    MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, ResourceScope scope);\n+    MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -155,2 +155,0 @@\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n@@ -772,1 +770,1 @@\n-    MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE)\n+    MemoryAddress.NULL.asSegment(Long.MAX_VALUE)\n@@ -780,2 +778,0 @@\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n@@ -785,1 +781,1 @@\n-    static MemorySegment ofNativeRestricted() {\n+    static MemorySegment ofNative() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n- * using the {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)} factory. This allows the client to\n+ * using the {@link jdk.incubator.foreign.MemoryAddress#asSegment(long)} factory. This allows the client to\n@@ -162,1 +162,1 @@\n-MemorySegment segment = addr.asSegmentRestricted(4); \/\/ segment is 4 bytes long\n+MemorySegment segment = addr.asSegment(4); \/\/ segment is 4 bytes long\n@@ -167,1 +167,1 @@\n- * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#ofNativeRestricted()}\n+ * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#ofNative()}\n@@ -172,1 +172,1 @@\n-int x = MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr.toRawLongValue());\n+int x = MemoryAccess.getIntAtOffset(MemorySegment.ofNative(), addr.toRawLongValue());\n@@ -184,2 +184,2 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr1.toRawLongValue()) -\n-               MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr2.toRawLongValue());\n+        return MemoryAccess.getIntAtOffset(MemorySegment.ofNative(), addr1.toRawLongValue()) -\n+               MemoryAccess.getIntAtOffset(MemorySegment.ofNative(), addr2.toRawLongValue());\n@@ -217,1 +217,1 @@\n- * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)} can be used to create\n+ * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegment(long)} can be used to create\n@@ -221,1 +221,1 @@\n- * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)}, if the provided\n+ * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegment(long)}, if the provided\n@@ -226,8 +226,2 @@\n- * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the JDK property\n- * {@code foreign.restricted} must be set to a value other than {@code deny}. The possible values for this property are:\n- * <ul>\n- * <li>{@code deny}: issues a runtime exception on each restricted call. This is the default value;<\/li>\n- * <li>{@code permit}: allows restricted calls;<\/li>\n- * <li>{@code warn}: like permit, but also prints a one-line warning on each restricted call;<\/li>\n- * <li>{@code debug}: like permit, but also dumps the stack corresponding to any given restricted call.<\/li>\n- * <\/ul>\n+ * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the JVM command line option\n+ * {@code --enable-native-access} must mention the name of the caller's module.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.internal.foreign.MemoryScope;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+\n+public abstract class AbstractCLinker implements CLinker {\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(symbol);\n+        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+    }\n+\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(allocator);\n+        MethodHandle downcall = MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+        if (type.returnType().equals(MemorySegment.class)) {\n+            downcall = MethodHandles.insertArguments(downcall, 0, allocator);\n+        }\n+        return downcall;\n+    }\n+\n+    @CallerSensitive\n+    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return upcallStub(target, function, MemoryScope.createDefault());\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -108,1 +108,1 @@\n-    static class LibraryLookupImpl implements LibraryLookup {\n+    static final class LibraryLookupImpl implements LibraryLookup {\n@@ -114,1 +114,1 @@\n-            this.librarySegment = MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE, scope);\n+            this.librarySegment = MemoryAddress.NULL.asSegment(Long.MAX_VALUE, scope);\n@@ -118,1 +118,3 @@\n-        public Optional<MemoryAddress> lookup(String name) {\n+        @CallerSensitive\n+        public final Optional<MemoryAddress> lookup(String name) {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -130,1 +132,1 @@\n-        public Optional<MemorySegment> lookup(String name, MemoryLayout layout) {\n+        public final Optional<MemorySegment> lookup(String name, MemoryLayout layout) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -110,1 +110,15 @@\n-    public MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, ResourceScope scope) {\n+    public final MemorySegment asSegment(long bytesSize) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return asSegment(bytesSize, null, ResourceScope.globalScope());\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public final MemorySegment asSegment(long bytesSize, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return asSegment(bytesSize, null, scope);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public final MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,3 +51,0 @@\n-    private static final String foreignRestrictedAccess = Optional.ofNullable(VM.getSavedProperty(\"foreign.restricted\"))\n-            .orElse(\"deny\");\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -33,0 +32,1 @@\n+import jdk.internal.foreign.AbstractCLinker;\n@@ -37,0 +37,3 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -48,1 +51,1 @@\n-public class AArch64Linker implements CLinker {\n+public final class AArch64Linker extends AbstractCLinker {\n@@ -76,1 +79,3 @@\n-    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -90,1 +95,3 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    @CallerSensitive\n+    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        MemorySegment gpRegsArea = grTop(segment).addOffset(-MAX_GP_OFFSET).asSegmentRestricted(\n+        MemorySegment gpRegsArea = grTop(segment).addOffset(-MAX_GP_OFFSET).asSegment(\n@@ -117,1 +117,1 @@\n-        MemorySegment fpRegsArea = vrTop(segment).addOffset(-MAX_FP_OFFSET).asSegmentRestricted(\n+        MemorySegment fpRegsArea = vrTop(segment).addOffset(-MAX_FP_OFFSET).asSegment(\n@@ -124,1 +124,1 @@\n-        MemorySegment ms = MemoryAddress.ofLong(ptr).asSegmentRestricted(\n+        MemorySegment ms = MemoryAddress.ofLong(ptr).asSegment(\n@@ -260,1 +260,1 @@\n-                    MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n@@ -268,1 +268,1 @@\n-                    MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n@@ -313,1 +313,1 @@\n-                    MemorySegment slice = ptr.asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment slice = ptr.asSegment(layout.byteSize(), scope());\n@@ -358,1 +358,1 @@\n-        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize(), scope));\n+        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        MemorySegment base = MemoryAddress.ofLong(ptr).asSegmentRestricted(\n+        MemorySegment base = MemoryAddress.ofLong(ptr).asSegment(\n@@ -175,1 +175,1 @@\n-        return ((MemoryAddress)VH_reg_save_area.get(segment)).asSegmentRestricted(\n+        return ((MemoryAddress)VH_reg_save_area.get(segment)).asSegment(\n@@ -238,1 +238,1 @@\n-                    MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n@@ -247,1 +247,1 @@\n-                        MemorySegment slice = stackPtr().asSegmentRestricted(layout.byteSize(), localScope);\n+                        MemorySegment slice = stackPtr().asSegment(layout.byteSize(), localScope);\n@@ -312,1 +312,1 @@\n-        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize(), scope));\n+        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.AbstractCLinker;\n@@ -36,0 +37,3 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -46,1 +50,1 @@\n-public class SysVx64Linker implements CLinker {\n+public final class SysVx64Linker extends AbstractCLinker {\n@@ -86,1 +90,3 @@\n-    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -100,1 +106,3 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    @CallerSensitive\n+    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                    MemorySegment struct = structAddr.asSegmentRestricted(layout.byteSize(), scope());\n+                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n@@ -154,1 +154,1 @@\n-        MemorySegment segment = addr.asSegmentRestricted(Long.MAX_VALUE, scope);\n+        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,0 +31,1 @@\n+import jdk.internal.foreign.AbstractCLinker;\n@@ -36,0 +36,3 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.vm.annotation.NativeAccess;\n@@ -46,1 +49,1 @@\n-public class Windowsx64Linker implements CLinker {\n+public final class Windowsx64Linker extends AbstractCLinker {\n@@ -88,1 +91,3 @@\n-    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+    @CallerSensitive\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -102,1 +107,3 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    @CallerSensitive\n+    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-                return toJavaStringRestricted(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));\n+                return toJavaString(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));\n@@ -260,1 +260,1 @@\n-                this.base = addr.asSegmentRestricted(SIZE);\n+                this.base = addr.asSegment(SIZE);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize());\n+        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(Integer.MAX_VALUE + 10L);\n+        MemorySegment segment = MemoryAddress.NULL.asSegment(Integer.MAX_VALUE + 10L);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-    private static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {\n-        return addr.asSegmentRestricted(numElements * layout.byteSize());\n+    private static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements) {\n+        return addr.asSegment(numElements * layout.byteSize());\n@@ -46,2 +46,2 @@\n-        MemoryAddress addr = allocateMemoryRestricted(str.length() + 1);\n-        MemorySegment seg = asArrayRestricted(addr, C_CHAR, str.length() + 1);\n+        MemoryAddress addr = allocateMemory(str.length() + 1);\n+        MemorySegment seg = asArray(addr, C_CHAR, str.length() + 1);\n@@ -51,1 +51,1 @@\n-        freeMemoryRestricted(addr);\n+        freeMemory(addr);\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-        return CLinker.allocateMemoryRestricted(size);\n+        return CLinker.allocateMemory(size);\n@@ -152,1 +152,1 @@\n-        CLinker.freeMemoryRestricted(addr);\n+        CLinker.freeMemory(addr);\n@@ -181,1 +181,1 @@\n-            MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), scope);\n+            MemorySegment mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n@@ -188,1 +188,1 @@\n-        MemorySegment everything = MemorySegment.ofNativeRestricted();\n+        MemorySegment everything = MemorySegment.ofNative();\n@@ -197,1 +197,1 @@\n-            mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), scope);\n+            mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n@@ -207,1 +207,1 @@\n-        MemorySegment everything = MemorySegment.ofNativeRestricted();\n+        MemorySegment everything = MemorySegment.ofNative();\n@@ -217,1 +217,1 @@\n-            segment.address().asSegmentRestricted(0);\n+            segment.address().asSegment(0);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -102,3 +102,3 @@\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)\/1\/0\",\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofNativeRestricted\");\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofNative\");\n@@ -47,1 +47,1 @@\n-            \"ofNativeRestricted\", MethodType.methodType(MemorySegment.class));\n+            \"ofNative\", MethodType.methodType(MemorySegment.class));\n@@ -53,1 +53,1 @@\n-        MemorySegment.ofNativeRestricted();\n+        MemorySegment.ofNative();\n@@ -58,1 +58,1 @@\n-        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegmentRestricted\", long.class);\n+        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegment\", long.class);\n@@ -64,1 +64,1 @@\n-        var mh = MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegmentRestricted\",\n+        var mh = MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n@@ -71,1 +71,1 @@\n-        MemoryAddress.NULL.asSegmentRestricted(4000L);\n+        MemoryAddress.NULL.asSegment(4000L);\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestScopedOperations\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestScopedOperations\n@@ -198,1 +198,1 @@\n-            UNSAFE(scope -> MemoryAddress.NULL.asSegmentRestricted(10, scope));\n+            UNSAFE(scope -> MemoryAddress.NULL.asSegment(10, scope));\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize(), scope);\n+            MemorySegment sharedSegment = s.address().asSegment(s.byteSize(), scope);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), ma.toRawLongValue());\n+                    return MemoryAccess.getIntAtOffset(MemorySegment.ofNative(), ma.toRawLongValue());\n@@ -696,1 +696,1 @@\n-                    MemorySegment ms = intPtr.asSegmentRestricted(C_INT.byteSize());\n+                    MemorySegment ms = intPtr.asSegment(C_INT.byteSize());\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}