{"files":[{"patch":"@@ -207,1 +207,1 @@\n-            handle = Utils.makeMemoryAccessVarHandle(this, false);\n+            handle = Utils.makeMemoryAccessVarHandle(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,4 +42,1 @@\n-    \/** if true, only the base part of the address will be checked for alignment **\/\n-    final boolean skipAlignmentMaskCheck;\n-\n-    MemoryAccessVarHandleBase(VarForm form, boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask, boolean exact) {\n+    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long alignmentMask, boolean exact) {\n@@ -47,1 +44,0 @@\n-        this.skipAlignmentMaskCheck = skipAlignmentMaskCheck;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1584,3 +1584,2 @@\n-            public VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,\n-                                                   ByteOrder order) {\n-                return VarHandles.makeMemoryAddressViewHandle(carrier, skipAlignmentMaskCheck, alignmentMask, order);\n+            public VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask, ByteOrder order) {\n+                return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7930,1 +7930,1 @@\n-        return Utils.makeMemoryAccessVarHandle(layout, false);\n+        return Utils.makeMemoryAccessVarHandle(layout);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,1 +313,0 @@\n-     * @param skipAlignmentMaskCheck if true, only the base part of the address will be checked for alignment.\n@@ -318,1 +317,1 @@\n-    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,\n+    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, long alignmentMask,\n@@ -328,1 +327,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleByteHelper(skipAlignmentMaskCheck, be, size, alignmentMask, exact));\n+            return maybeAdapt(new MemoryAccessVarHandleByteHelper(be, size, alignmentMask, exact));\n@@ -330,1 +329,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleCharHelper(skipAlignmentMaskCheck, be, size, alignmentMask, exact));\n+            return maybeAdapt(new MemoryAccessVarHandleCharHelper(be, size, alignmentMask, exact));\n@@ -332,1 +331,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleShortHelper(skipAlignmentMaskCheck, be, size, alignmentMask, exact));\n+            return maybeAdapt(new MemoryAccessVarHandleShortHelper(be, size, alignmentMask, exact));\n@@ -334,1 +333,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleIntHelper(skipAlignmentMaskCheck, be, size, alignmentMask, exact));\n+            return maybeAdapt(new MemoryAccessVarHandleIntHelper(be, size, alignmentMask, exact));\n@@ -336,1 +335,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleFloatHelper(skipAlignmentMaskCheck, be, size, alignmentMask, exact));\n+            return maybeAdapt(new MemoryAccessVarHandleFloatHelper(be, size, alignmentMask, exact));\n@@ -338,1 +337,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleLongHelper(skipAlignmentMaskCheck, be, size, alignmentMask, exact));\n+            return maybeAdapt(new MemoryAccessVarHandleLongHelper(be, size, alignmentMask, exact));\n@@ -340,1 +339,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleDoubleHelper(skipAlignmentMaskCheck, be, size, alignmentMask, exact));\n+            return maybeAdapt(new MemoryAccessVarHandleDoubleHelper(be, size, alignmentMask, exact));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-    MemoryAccessVarHandle$Type$Helper(boolean skipAlignmentMaskCheck, boolean be, long length, long alignmentMask, boolean exact) {\n-        super(FORM, skipAlignmentMaskCheck, be, length, alignmentMask, exact);\n+    MemoryAccessVarHandle$Type$Helper(boolean be, long length, long alignmentMask, boolean exact) {\n+        super(FORM, be, length, alignmentMask, exact);\n@@ -63,1 +63,1 @@\n-                new MemoryAccessVarHandle$Type$Helper(skipAlignmentMaskCheck, be, length, alignmentMask, true);\n+                new MemoryAccessVarHandle$Type$Helper(be, length, alignmentMask, true);\n@@ -70,1 +70,1 @@\n-                new MemoryAccessVarHandle$Type$Helper(skipAlignmentMaskCheck, be, length, alignmentMask, false);\n+                new MemoryAccessVarHandle$Type$Helper(be, length, alignmentMask, false);\n@@ -107,2 +107,2 @@\n-    static long offset(boolean skipAlignmentMaskCheck, AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long address = offsetNoVMAlignCheck(skipAlignmentMaskCheck, bb, offset, alignmentMask);\n+    static long offset(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n@@ -116,1 +116,1 @@\n-    static long offsetNoVMAlignCheck(boolean skipAlignmentMaskCheck, AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n@@ -120,9 +120,2 @@\n-        if (skipAlignmentMaskCheck) {\n-            \/\/note: the offset portion has already been aligned-checked, by construction\n-            if (((base | maxAlignMask) & alignmentMask) != 0) {\n-                throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-            }\n-        } else {\n-            if (((address | maxAlignMask) & alignmentMask) != 0) {\n-                throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-            }\n+        if (((address | maxAlignMask) & alignmentMask) != 0) {\n+            throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n@@ -140,1 +133,1 @@\n-                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n@@ -147,1 +140,1 @@\n-                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask));\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n@@ -151,1 +144,1 @@\n-                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n@@ -164,1 +157,1 @@\n-                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n@@ -171,1 +164,1 @@\n-                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n@@ -176,1 +169,1 @@\n-                offsetNoVMAlignCheck(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n@@ -190,1 +183,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));\n+                                  offset(bb, base, handle.alignmentMask)));\n@@ -199,1 +192,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -210,1 +203,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));\n+                                  offset(bb, base, handle.alignmentMask)));\n@@ -219,1 +212,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -230,1 +223,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask)));\n+                                  offset(bb, base, handle.alignmentMask)));\n@@ -239,1 +232,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -250,1 +243,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -261,1 +254,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                                  offset(bb, base, handle.alignmentMask),\n@@ -272,1 +265,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                                  offset(bb, base, handle.alignmentMask),\n@@ -283,1 +276,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                                  offset(bb, base, handle.alignmentMask),\n@@ -293,1 +286,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -303,1 +296,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -313,1 +306,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -323,1 +316,1 @@\n-                offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                offset(bb, base, handle.alignmentMask),\n@@ -334,1 +327,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                                  offset(bb, base, handle.alignmentMask),\n@@ -345,1 +338,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                                  offset(bb, base, handle.alignmentMask),\n@@ -356,1 +349,1 @@\n-                                  offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                                  offset(bb, base, handle.alignmentMask),\n@@ -369,1 +362,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -372,1 +365,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n@@ -383,1 +376,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -386,1 +379,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n@@ -397,1 +390,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -400,1 +393,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n@@ -425,1 +418,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -428,1 +421,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -439,1 +432,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -442,1 +435,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -453,1 +446,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -456,1 +449,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -479,1 +472,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -482,1 +475,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -493,1 +486,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -496,1 +489,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -507,1 +500,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -510,1 +503,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -534,1 +527,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -537,1 +530,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -548,1 +541,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -551,1 +544,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n@@ -562,1 +555,1 @@\n-                    offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask),\n+                    offset(bb, base, handle.alignmentMask),\n@@ -565,1 +558,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(handle.skipAlignmentMaskCheck, bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":56,"deletions":63,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -89,2 +89,1 @@\n-    VarHandle memoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentMaskCheck, long alignmentMask,\n-                                    ByteOrder order);\n+    VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask, ByteOrder order);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,3 +63,0 @@\n-    private static final boolean enableSmallSegments =\n-            Boolean.parseBoolean(GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.SmallSegments\", \"true\"));\n-\n@@ -67,1 +64,0 @@\n-    static final int SMALL = READ_ONLY << 1;\n@@ -70,0 +66,2 @@\n+    static final int DEFAULT_MODES = 0;\n+\n@@ -91,5 +89,0 @@\n-    static int defaultAccessModes(long size) {\n-        return (enableSmallSegments && size < Integer.MAX_VALUE) ?\n-                SMALL : 0;\n-    }\n-\n@@ -354,4 +347,0 @@\n-    public boolean isSmall() {\n-        return isSet(SMALL);\n-    }\n-\n@@ -401,12 +390,8 @@\n-    private void checkBounds(long offset, long length) {\n-        if (isSmall() &&\n-                offset <= Integer.MAX_VALUE && length <= Integer.MAX_VALUE &&\n-                offset >= Integer.MIN_VALUE && length >= Integer.MIN_VALUE) {\n-            checkBoundsSmall((int)offset, (int)length);\n-        } else if (this != NativeMemorySegmentImpl.EVERYTHING) { \/\/ oob not possible for everything segment\n-            if (\n-                    length < 0 ||\n-                    offset < 0 ||\n-                    offset > this.length - length) { \/\/ careful of overflow\n-                throw outOfBoundException(offset, length);\n-            }\n+    @ForceInline\n+    void checkBounds(long offset, long length) {\n+        if (length > 0) {\n+            long checkedOffset = Objects.checkIndex(offset, this.length);\n+            Objects.checkIndex(checkedOffset, this.length - length + 1);\n+        } else if (length < 0 || offset < 0 ||\n+                offset > this.length - length) {\n+            throw outOfBoundException(offset, length);\n@@ -421,8 +406,0 @@\n-    private void checkBoundsSmall(int offset, int length) {\n-        if (length < 0 ||\n-                offset < 0 ||\n-                offset > (int)this.length - length) { \/\/ careful of overflow\n-            throw outOfBoundException(offset, length);\n-        }\n-    }\n-\n@@ -492,11 +469,2 @@\n-                    if (acquired.isSmall()) {\n-                        int index = (int) currentIndex;\n-                        int limit = (int) elemCount;\n-                        int elemSize = (int) elementSize;\n-                        for (; index < limit; index++) {\n-                            action.accept(acquired.asSliceNoCheck(index * elemSize, elemSize));\n-                        }\n-                    } else {\n-                        for (long i = currentIndex ; i < elemCount ; i++) {\n-                            action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));\n-                        }\n+                    for (long i = currentIndex ; i < elemCount ; i++) {\n+                        action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));\n@@ -547,1 +515,1 @@\n-            modes = defaultAccessModes(size);\n+            modes = DEFAULT_MODES;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":13,"deletions":45,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n@@ -137,1 +137,1 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n@@ -165,1 +165,1 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n@@ -193,1 +193,1 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n@@ -221,1 +221,1 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n@@ -249,1 +249,1 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n@@ -277,1 +277,1 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, DEFAULT_MODES);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-        VarHandle handle = Utils.makeMemoryAccessVarHandle(valueLayout, true);\n+        VarHandle handle = Utils.makeMemoryAccessVarHandle(valueLayout);\n@@ -349,1 +349,1 @@\n-        return Utils.addOffsets(base, Utils.multiplyOffset(segment, index, stride), segment);\n+        return base + (stride * index);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-            int modes = defaultAccessModes(bytesSize);\n+            int modes = DEFAULT_MODES;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,11 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, ResourceScopeImpl.GLOBAL);\n+    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, 0, ResourceScopeImpl.GLOBAL) {\n+        @Override\n+        void checkBounds(long offset, long length) {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        NativeMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            throw new IllegalStateException();\n+        }\n+    };\n@@ -118,1 +128,1 @@\n-                defaultAccessModes(alignedSize), scope);\n+                DEFAULT_MODES, scope);\n@@ -135,1 +145,1 @@\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), scope);\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, DEFAULT_MODES, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout, boolean skipAlignmentCheck) {\n+    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout) {\n@@ -104,1 +104,0 @@\n-            private static final Map<ValueLayout, VarHandle> handleMapNoAlignCheck = new ConcurrentHashMap<>();\n@@ -106,2 +105,2 @@\n-            static VarHandle put(ValueLayout layout, VarHandle handle, boolean skipAlignmentCheck) {\n-                VarHandle prev = (skipAlignmentCheck ? handleMapNoAlignCheck : handleMap).putIfAbsent(layout, handle);\n+            static VarHandle put(ValueLayout layout, VarHandle handle) {\n+                VarHandle prev = handleMap.putIfAbsent(layout, handle);\n@@ -122,1 +121,1 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck,\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier,\n@@ -132,1 +131,1 @@\n-        return VarHandleCache.put(layout, handle, skipAlignmentCheck);\n+        return VarHandleCache.put(layout, handle);\n@@ -155,6 +154,0 @@\n-    \/* Helper functions for offset computations. These are required so that we can avoid issuing long opcodes\n-     * (e.g. LMUL, LADD) when we're operating on 'small' segments (segments whose length can be expressed with an int).\n-     * C2 BCE code is very sensitive to the kind of opcode being emitted, and this workaround allows us to rescue\n-     * BCE when working with small segments. This workaround should be dropped when JDK-8259609 is resolved.\n-     *\/\n-\n@@ -164,53 +157,1 @@\n-        return multiplyOffset(segment, index, (int)size);\n-    }\n-\n-    @ForceInline\n-    public static long multiplyOffset(MemorySegment segment, long op1, long op2) {\n-        if (((AbstractMemorySegmentImpl)segment).isSmall()) {\n-            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n-                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-            \/\/ force ints for BCE\n-            int i1 = (int)op1;\n-            int i2 = (int)op2;\n-            try {\n-                return Math.multiplyExact(i1, i2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-        } else {\n-            try {\n-                return Math.multiplyExact(op1, op2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n-            }\n-        }\n-    }\n-\n-    @ForceInline\n-    public static long addOffsets(long op1, long op2, MemorySegment segment) {\n-        if (((AbstractMemorySegmentImpl)segment).isSmall()) {\n-            \/\/ force ints for BCE\n-            if (op1 > Integer.MAX_VALUE || op2 > Integer.MAX_VALUE\n-                    || op1 < Integer.MIN_VALUE || op2 < Integer.MIN_VALUE) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-            int i1 = (int)op1;\n-            int i2 = (int)op2;\n-            try {\n-                return Math.addExact(i1, i2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            }\n-        } else {\n-            try {\n-                return Math.addExact(op1, op2);\n-            } catch (ArithmeticException ex) {\n-                throw overflowException(Long.MIN_VALUE, Long.MAX_VALUE);\n-            }\n-        }\n-    }\n-\n-    private static IndexOutOfBoundsException overflowException(long min, long max) {\n-        return new IndexOutOfBoundsException(String.format(\"Overflow occurred during offset computation ; offset exceeded range { %d .. %d }\", min, max));\n+        return index * size;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":6,"deletions":65,"binary":false,"changes":71,"status":"modified"}]}