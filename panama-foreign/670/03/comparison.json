{"files":[{"patch":"@@ -34,2 +34,2 @@\n- * The {@link Addressable} type is used by the {@link CLinker C linker} to model the types of\n- * {@link CLinker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n+ * The {@link Addressable} type is used by the {@linkplain CLinker C linker} to model the types of\n+ * {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Addressable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown.<\/p>\n+ * elements to a method in this class causes a {@link NullPointerException} to be thrown.<\/p>\n@@ -106,1 +106,1 @@\n- * when no longer required, they can be {@link MemorySession#close() released}, via their associated {@linkplain MemorySession session}.\n+ * when no longer required, they can be {@linkplain MemorySession#close() released}, via their associated {@linkplain MemorySession session}.\n@@ -120,1 +120,1 @@\n- *     <li>The invocation occurs in same thread as the one {@link MemorySession#ownerThread() owning} the memory session of {@code R},\n+ *     <li>The invocation occurs in same thread as the one {@linkplain MemorySession#ownerThread() owning} the memory session of {@code R},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * This class is immutable and thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -50,0 +50,1 @@\n+ * @see MemoryLayout\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,7 +45,0 @@\n- * <p>\n- * This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n- * class; programmers should treat instances that are\n- * {@linkplain #equals(Object) equal} as interchangeable and should not\n- * use instances for synchronization, or unpredictable behavior may\n- * occur. For example, in a future release, synchronization may fail.\n- * The {@code equals} method should be used for comparisons.\n@@ -54,1 +47,1 @@\n- * This class is immutable and thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * For instance, to read an int from a segment, using {@linkplain ByteOrder#nativeOrder() default endianness}, the following code can be used:\n@@ -68,5 +68,0 @@\n- * <p>\n- * All implementations of this interface must be <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>;\n- * programmers should treat instances that are {@linkplain #equals(Object) equal} as interchangeable and should not\n- * use instances for synchronization, or unpredictable behavior may occur. For example, in a future release,\n- * synchronization may fail. The {@code equals} method should be used for comparisons.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown.<\/p>\n+     * elements to a method in this class causes a {@link NullPointerException} to be thrown.<\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,7 +56,0 @@\n- * <p>\n- * All implementations of this interface must be <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>;\n- * programmers should treat instances that are {@linkplain Object#equals(Object) equal} as interchangeable and should not\n- * use instances for synchronization, or unpredictable behavior may occur. For example, in a future release,\n- * synchronization may fail. The {@code equals} method should be used for comparisons.\n- * <p>\n- * Non-platform classes should not implement {@linkplain MemorySegment} directly.\n@@ -64,1 +57,12 @@\n- * <h2>Constructing memory segments<\/h2>\n+ * There are many kinds of memory segments:\n+ * <ul>\n+ *     <li>{@linkplain MemorySegment#allocateNative(long, long, MemorySession) native memory segments}, backed by off-heap memory;<\/li>\n+ *     <li>{@linkplain FileChannel#map(FileChannel.MapMode, long, long, MemorySession) mapped memory segments}, obtained by mapping\n+ * a file into main memory ({@code mmap}); tha contents of a mapped memory segments can be {@linkplain #force() persisted} and\n+ * {@linkplain #load() loaded} to and from the underlying memory-mapped file;<\/li>\n+ *     <li>{@linkplain MemorySegment#ofArray(int[]) array segments}, wrapping an existing, heap-allocated Java array; and<\/li>\n+ *     <li>{@linkplain MemorySegment#ofByteBuffer(ByteBuffer) buffer segments}, wrapping an existing {@link ByteBuffer} instance;\n+ * buffer memory segments might be backed by either off-heap memory or on-heap memory, depending on the characteristics of the\n+ * wrapped byte buffer instance. For instance, a buffer memory segment obtained from a byte buffer created with the\n+ * {@link ByteBuffer#allocateDirect(int)} method will be backed by off-heap memory.<\/li>\n+ * <\/ul>\n@@ -66,18 +70,1 @@\n- * There are multiple ways to obtain a memory segment. First, memory segments backed by off-heap memory can\n- * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout, MemorySession)},\n- * {@link MemorySegment#allocateNative(long, MemorySession)} and {@link MemorySegment#allocateNative(long, long, MemorySession)}). Memory segments obtained\n- * in this way are called <em>native memory segments<\/em>.\n- * <p>\n- * It is also possible to obtain a memory segment backed by an existing heap-allocated Java array,\n- * using one of the provided factory methods (e.g. {@link MemorySegment#ofArray(int[])}). Memory segments obtained\n- * in this way are called <em>array memory segments<\/em>.\n- * <p>\n- * It is possible to obtain a memory segment backed by an existing Java byte buffer (see {@link ByteBuffer}),\n- * using the factory method {@link MemorySegment#ofByteBuffer(ByteBuffer)}.\n- * Memory segments obtained in this way are called <em>buffer memory segments<\/em>. Note that buffer memory segments might\n- * be backed by native memory (as in the case of native memory segments) or heap memory (as in the case of array memory segments),\n- * depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory\n- * segment obtained from a byte buffer created with the {@link ByteBuffer#allocateDirect(int)} method will be backed\n- * by native memory.\n- *\n- * <h2>Mapping memory segments from files<\/h2>\n+ * <h2>Lifecycle and confinement<\/h2>\n@@ -85,9 +72,13 @@\n- * It is also possible to obtain a native memory segment backed by a memory-mapped file using the factory method\n- * {@link FileChannel#map(FileChannel.MapMode, long, long, MemorySession)}. Such native memory segments are called\n- * <em>mapped memory segments<\/em>; mapped memory segments are associated with an underlying file descriptor.\n- * <p>\n- * Contents of mapped memory segments can be {@linkplain #force() persisted} and {@linkplain #load() loaded} to and from the underlying file;\n- * these capabilities are suitable replacements for some capabilities in the {@link java.nio.MappedByteBuffer} class.\n- * Note that, while it is possible to map a segment into a byte buffer (see {@link MemorySegment#asByteBuffer()}),\n- * and then call e.g. {@link java.nio.MappedByteBuffer#force()} that way, this can only be done when the source segment\n- * is small enough, due to the size limitation inherent to the ByteBuffer API.\n+ * Memory segments are associated with a {@linkplain MemorySegment#session() memory session}. As for all resources associated\n+ * with a memory session, a segment cannot be accessed after its underlying session has been closed. For instance,\n+ * the following code will result in an exception:\n+ * {@snippet lang=java :\n+ * MemorySegment segment = null;\n+ * try (MemorySession session = MemorySession.openConfined()) {\n+ *     segment = MemorySegment.allocateNative(8, session);\n+ * }\n+ * segment.get(ValueLayout.JAVA_LONG, 0); \/\/ already closed!\n+ * }\n+ * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning memory\n+ * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads;\n+ * if it is associated with a confined session, it can only be accessed by the thread which owns the memory session.\n@@ -95,13 +86,2 @@\n- * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n- * custom mapped memory segment factories; using {@link CLinker}, e.g. on Linux, it is possible to call {@code mmap}\n- * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n- * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}.\n- *\n- * <h2>Restricted native segments<\/h2>\n- *\n- * Sometimes it is necessary to turn a memory address obtained from native code into a memory segment with\n- * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddress(MemoryAddress, long, MemorySession) obtain}\n- * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain MemorySession session}.\n- * This is a <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> operation and should be used with\n- * caution: for instance, an incorrect segment size could result in a VM crash when attempting to dereference\n- * the memory segment.\n+ * Heap and buffer segments are always associated with a <em>global<\/em>, shared memory session. This session cannot be closed,\n+ * and segments associated with it can be considered as <em>always alive<\/em>.\n@@ -114,1 +94,1 @@\n- * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * For instance, to read an int from a segment, using {@linkplain ByteOrder#nativeOrder() default endianness}, the following code can be used:\n@@ -120,1 +100,1 @@\n- * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * If the value to be read is stored in memory using {@linkplain ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n@@ -154,0 +134,34 @@\n+ * <h2>Slicing memory segments<\/h2>\n+ *\n+ * Memory segments support <em>slicing<\/em>. A memory segment can be used to {@linkplain MemorySegment#asSlice(long, long) obtain}\n+ * other segments backed by the same underlying memory region, but with <em>stricter<\/em> spatial bounds than the ones\n+ * of the original segment:\n+ * {@snippet lang=java :\n+ * MemorySession session = ...\n+ * MemorySegment segment = MemorySegment.allocateNative(100, session);\n+ * MemorySegment slice = segment.asSlice(50, 10);\n+ * slice.get(ValueLayout.JAVA_INT, 20); \/\/ Out of bounds!\n+ * session.close();\n+ * slice.get(ValueLayout.JAVA_INT, 0); \/\/ Already closed!\n+ * }\n+ * The above code creates a native segment that is 100 bytes long; then, it creates a slice that starts at offset 50\n+ * of {@code segment}, and is 10 bytes long. As a result, attempting to read an int value at offset 20 of the\n+ * {@code slice} segment will result in an exception. The {@linkplain MemorySession temporal bounds} of the original segment\n+ * are inherited by its slices; that is, when the memory session associated with {@code segment} is closed, {@code slice}\n+ * will also be become inaccessible.\n+ * <p>\n+ * A client might obtain a {@link Stream} from a segment, which can then be used to slice the segment (according to a given\n+ * element layout) and even allow multiple threads to work in parallel on disjoint segment slices\n+ * (to do this, the segment has to be associated with a shared memory session). The following code can be used to sum all int\n+ * values in a memory segment in parallel:\n+ *\n+ * {@snippet lang=java :\n+ * try (MemorySession session = MemorySession.openShared()) {\n+ *     SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n+ *     MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, session);\n+ *     int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+ *                      .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n+ *                      .sum();\n+ * }\n+ * }\n+ *\n@@ -161,5 +175,5 @@\n- * <blockquote><pre>{@code\n-boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {\n-   return ((segment.address().toRawLongValue() + offset) % layout.byteAlignment()) == 0\n-}\n- * }<\/pre><\/blockquote>\n+ * {@snippet lang=java :\n+ * boolean isAligned(MemorySegment segment, long offset, MemoryLayout layout) {\n+ *   return ((segment.address().toRawLongValue() + offset) % layout.byteAlignment()) == 0\n+ * }\n+ * }\n@@ -204,31 +218,7 @@\n- * <h2>Lifecycle and confinement<\/h2>\n- *\n- * Memory segments are associated with a {@link MemorySegment#session() memory session}. As for all resources associated\n- * with a memory session, a segment cannot be accessed after its underlying session has been closed. For instance,\n- * the following code will result in an exception:\n- * {@snippet lang=java :\n- * MemorySegment segment = null;\n- * try (MemorySession session = MemorySession.openConfined()) {\n- *     segment = MemorySegment.allocateNative(8, session);\n- * }\n- * segment.get(ValueLayout.JAVA_LONG, 0); \/\/ already closed!\n- * }\n- * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning memory\n- * session; that is, if the segment is associated with a shared session, it can be accessed by multiple threads;\n- * if it is associated with a confined session, it can only be accessed by the thread which owns the memory session.\n- * <p>\n- * Heap and buffer segments are always associated with a <em>global<\/em>, shared memory session. This session cannot be closed,\n- * and segments associated with it can be considered as <em>always alive<\/em>.\n- *\n- * <h2>Memory segment views<\/h2>\n- *\n- * Memory segments support <em>views<\/em>. For instance, it is possible to create an <em>immutable<\/em> view of a memory segment, as follows:\n- * {@snippet lang=java :\n- * MemorySegment segment = ...\n- * MemorySegment roSegment = segment.asReadOnly();\n- * }\n- * It is also possible to create views whose spatial bounds are stricter than the ones of the original segment\n- * (see {@link MemorySegment#asSlice(long, long)}).\n- * <p>\n- * Temporal bounds of the original segment are inherited by the views; that is, when the memory session associated with a segment\n- * is closed, all the views associated with that segment will also be rendered inaccessible.\n+ * <h2>Restricted memory segments<\/h2>\n+ * Sometimes it is necessary to turn a memory address obtained from native code into a memory segment with\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@linkplain #ofAddress(MemoryAddress, long, MemorySession) obtain}\n+ * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain MemorySession session}.\n+ * This is a <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> operation and should be used with\n+ * caution: for instance, an incorrect segment size could result in a VM crash when attempting to dereference\n+ * the memory segment.\n@@ -236,21 +226,4 @@\n- * To allow for interoperability with existing code, a byte buffer view can be obtained from a memory segment\n- * (see {@link #asByteBuffer()}). This can be useful, for instance, for those clients that want to keep using the\n- * {@link ByteBuffer} API, but need to operate on large memory segments. Byte buffers obtained in such a way support\n- * the same spatial and temporal access restrictions associated with the memory segment from which they originated.\n- *\n- * <h2>Stream support<\/h2>\n- *\n- * A client might obtain a {@link Stream} from a segment, which can then be used to slice the segment (according to a given\n- * element layout) and even allow multiple threads to work in parallel on disjoint segment slices\n- * (to do this, the segment has to be associated with a shared memory session). The following code can be used to sum all int\n- * values in a memory segment in parallel:\n- *\n- * {@snippet lang=java :\n- * try (MemorySession session = MemorySession.openShared()) {\n- *     SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n- *     MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, session);\n- *     int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n- *                      .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n- *                      .sum();\n- * }\n- * }\n+ * Clients requiring sophisticated, low-level control over mapped memory segments, might consider writing\n+ * custom mapped memory segment factories; using {@link CLinker}, e.g. on Linux, it is possible to call {@code mmap}\n+ * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}.\n@@ -373,1 +346,1 @@\n-     * derived from a direct {@link java.nio.ByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory,\n+     * derived from a {@linkplain ByteBuffer#allocateDirect(int) direct byte buffer} using the {@link #ofByteBuffer(ByteBuffer)} factory,\n@@ -394,1 +367,1 @@\n-     * {@link #isNative() native} segment to overlap with a heap segment; in\n+     * {@linkplain #isNative() native} segment to overlap with a heap segment; in\n@@ -740,2 +713,2 @@\n-     * If the buffer is {@link ByteBuffer#isReadOnly() read-only}, the resulting segment will also be\n-     * {@link ByteBuffer#isReadOnly() read-only}. The memory session associated with this segment can either be the\n+     * If the buffer is {@linkplain ByteBuffer#isReadOnly() read-only}, the resulting segment will also be\n+     * {@linkplain ByteBuffer#isReadOnly() read-only}. The memory session associated with this segment can either be the\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":84,"deletions":111,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Consumer;\n@@ -43,1 +44,1 @@\n- * When a memory session is closed, it is no longer {@link #isAlive() alive}, and subsequent operations on resources\n+ * When a memory session is closed, it is no longer {@linkplain #isAlive() alive}, and subsequent operations on resources\n@@ -46,12 +47,10 @@\n- * When a memory session is closed (either explicitly, or implicitly), all the {@linkplain #addCloseAction(Runnable) close actions} associated with that session will be called.\n- * and underlying memory resources associated with said session might be released; for instance:\n- * <ul>\n- *     <li>closing the memory session associated with a {@linkplain MemorySegment#allocateNative(long, long, MemorySession) native memory segment}\n- *     results in <em>freeing<\/em> the native memory associated with it;<\/li>\n- *     <li>closing the memory session associated with a {@linkplain FileChannel#map(FileChannel.MapMode, long, long, MemorySession) mapped memory segment}\n- *     results in the backing memory-mapped file to be unmapped;<\/li>\n- *     <li>closing the memory session associated with an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}\n- *     results in releasing the stub;<\/li>\n- *     <li>closing the memory session associated with a {@linkplain VaList variable arity list} results in releasing the memory\n- *     associated with that variable arity list instance.<\/li>\n- * <\/ul>\n+ * A memory session is associated with one or more {@linkplain #addCloseAction(Runnable) close actions}. Close actions\n+ * can be used to specify the cleanup code that must run when a given resource (or set of resources) is no longer in use.\n+ * When a memory session is closed (either explicitly, or implicitly), the {@linkplain #addCloseAction(Runnable) close actions}\n+ * associated with that session are executed (in unspecified order). For instance, closing the memory session associated with\n+ * one or more {@linkplain MemorySegment#allocateNative(long, long, MemorySession) native memory segments} results in releasing\n+ * the off-heap memory associated with said segments.\n+ * <p>\n+ * The {@linkplain #global() global session} is a memory session that cannot be closed, either explicitly or implicitly.\n+ * As a result, resources associated with the global session are never released. Examples of resources associated with\n+ * the global memory session are {@linkplain MemorySegment#ofArray(int[]) heap segments}.\n@@ -79,1 +78,1 @@\n- * Closeable memory sessions are memory sessions that can be {@link MemorySession#close() closed} explicitly, as demonstrated\n+ * Closeable memory sessions are memory sessions that can be {@linkplain MemorySession#close() closed} explicitly, as demonstrated\n@@ -104,7 +103,0 @@\n- * <h2>Global session<\/h2>\n- *\n- * An important memory session is the so called {@linkplain #global() global session}; the global session is\n- * a memory session that cannot be closed, either explicitly or implicitly. As a result, the global session will never\n- * attempt to release resources associated with it. Examples of resources associated with the global memory session are\n- * {@linkplain MemorySegment#ofArray(int[]) heap segments}.\n- *\n@@ -134,0 +126,5 @@\n+ * @see MemorySegment\n+ * @see SymbolLookup\n+ * @see CLinker\n+ * @see VaList\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -36,7 +36,0 @@\n- * <p>\n- * This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n- * class; programmers should treat instances that are\n- * {@linkplain #equals(Object) equal} as interchangeable and should not\n- * use instances for synchronization, or unpredictable behavior may\n- * occur. For example, in a future release, synchronization may fail.\n- * The {@code equals} method should be used for comparisons.\n@@ -45,1 +38,1 @@\n- * This class is immutable and thread-safe.\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-     * Allocates a memory segment with the given layout and initializes it with the given byte array.\n+     * Allocates a memory segment with the given layout and initializes it with the given byte elements.\n@@ -218,1 +218,1 @@\n-     * Allocates a memory segment with the given layout and initializes it with the given short array.\n+     * Allocates a memory segment with the given layout and initializes it with the given short elements.\n@@ -229,1 +229,1 @@\n-     * Allocates a memory segment with the given layout and initializes it with the given char array.\n+     * Allocates a memory segment with the given layout and initializes it with the given char elements.\n@@ -240,1 +240,1 @@\n-     * Allocates a memory segment with the given layout and initializes it with the given int array.\n+     * Allocates a memory segment with the given layout and initializes it with the given int elements.\n@@ -251,1 +251,1 @@\n-     * Allocates a memory segment with the given layout and initializes it with the given float array.\n+     * Allocates a memory segment with the given layout and initializes it with the given float elements.\n@@ -262,1 +262,1 @@\n-     * Allocates a memory segment with the given layout and initializes it with the given long array.\n+     * Allocates a memory segment with the given layout and initializes it with the given long elements.\n@@ -273,1 +273,1 @@\n-     * Allocates a memory segment with the given layout and initializes it with the given double array.\n+     * Allocates a memory segment with the given layout and initializes it with the given double elements.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,8 +54,0 @@\n- * <p>\n- * This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n- * class; programmers should treat instances that are\n- * {@linkplain #equals(Object) equal} as interchangeable and should not\n- * use instances for synchronization, or unpredictable behavior may\n- * occur. For example, in a future release, synchronization may fail.\n- * The {@code equals} method should be used for comparisons.\n- *\n@@ -63,1 +55,1 @@\n- * This class is immutable and thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,7 +52,0 @@\n- * <p>\n- * This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n- * class; programmers should treat instances that are\n- * {@linkplain #equals(Object) equal} as interchangeable and should not\n- * use instances for synchronization, or unpredictable behavior may\n- * occur. For example, in a future release, synchronization may fail.\n- * The {@code equals} method should be used for comparisons.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}