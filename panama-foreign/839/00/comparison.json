{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -38,0 +37,1 @@\n+import java.util.Map;\n@@ -39,1 +39,0 @@\n-import java.util.Optional;\n@@ -62,0 +61,6 @@\n+ * A linker provides a way to lookup up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * ABI type names to canonical layouts.\n+ * <p>\n@@ -106,5 +111,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -125,1 +127,26 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 (all the examples provided\n+ * here will assume these platform-dependent mappings):\n@@ -140,1 +167,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -143,1 +170,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -146,1 +173,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -149,1 +176,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -152,1 +179,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -203,14 +230,1 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n- * to one of the following layout constants:\n- * <ul>\n- * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n- * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n- * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n- * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n- * <li>{@link ValueLayout#JAVA_INT}<\/li>\n- * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n- * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n- * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n- * <\/ul><\/li>\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n- * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n@@ -495,0 +509,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -638,0 +654,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":59,"deletions":27,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.CABI;\n@@ -55,0 +56,1 @@\n+import java.util.HashSet;\n@@ -57,0 +59,1 @@\n+import java.util.Map;\n@@ -137,0 +140,5 @@\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS_MAP;\n+    }\n+\n@@ -236,1 +244,1 @@\n-        if (!SUPPORTED_LAYOUTS.contains(valueLayout.withoutName())) {\n+        if (!CANONICAL_LAYOUTS.contains(valueLayout.withoutName())) {\n@@ -273,10 +281,26 @@\n-    private static final Set<MemoryLayout> SUPPORTED_LAYOUTS = Set.of(\n-            ValueLayout.JAVA_BOOLEAN,\n-            ValueLayout.JAVA_BYTE,\n-            ValueLayout.JAVA_CHAR,\n-            ValueLayout.JAVA_SHORT,\n-            ValueLayout.JAVA_INT,\n-            ValueLayout.JAVA_FLOAT,\n-            ValueLayout.JAVA_LONG,\n-            ValueLayout.JAVA_DOUBLE,\n-            ValueLayout.ADDRESS\n+    private static final Map<String, MemoryLayout> CANONICAL_LAYOUTS_MAP = Map.ofEntries(\n+            \/\/ specified canonical layouts\n+            Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+            Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+            Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+            Map.entry(\"int\", ValueLayout.JAVA_INT),\n+            Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+            Map.entry(\"long\", CABI.current() == CABI.WIN_64 ? ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG),\n+            Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+            Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+            Map.entry(\"void*\", ValueLayout.ADDRESS),\n+            Map.entry(\"size_t\", ValueLayout.ADDRESS.byteSize() == Integer.BYTES ? ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG),\n+            \/\/ unspecified size-dependent layouts\n+            Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n+            Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n+            Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n+            Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n+            \/\/ unspecified JNI layouts\n+            Map.entry(\"jboolean\", ValueLayout.JAVA_BOOLEAN),\n+            Map.entry(\"jchar\", ValueLayout.JAVA_CHAR),\n+            Map.entry(\"jbyte\", ValueLayout.JAVA_BYTE),\n+            Map.entry(\"jshort\", ValueLayout.JAVA_SHORT),\n+            Map.entry(\"jint\", ValueLayout.JAVA_INT),\n+            Map.entry(\"jlong\", ValueLayout.JAVA_LONG),\n+            Map.entry(\"jfloat\", ValueLayout.JAVA_FLOAT),\n+            Map.entry(\"jdouble\", ValueLayout.JAVA_DOUBLE)\n@@ -284,0 +308,2 @@\n+\n+    private static final Set<MemoryLayout> CANONICAL_LAYOUTS = new HashSet<>(CANONICAL_LAYOUTS_MAP.values());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"}]}