{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -38,0 +37,1 @@\n+import java.util.Map;\n@@ -39,1 +39,0 @@\n-import java.util.Optional;\n@@ -62,0 +61,6 @@\n+ * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * type names to canonical layouts.\n+ * <p>\n@@ -106,5 +111,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -125,1 +127,27 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code wchar_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 (all the examples provided\n+ * here will assume these platform-dependent mappings):\n@@ -140,1 +168,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -143,1 +171,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -146,1 +174,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -149,1 +177,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -152,1 +180,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -203,14 +231,1 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n- * to one of the following layout constants:\n- * <ul>\n- * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n- * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n- * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n- * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n- * <li>{@link ValueLayout#JAVA_INT}<\/li>\n- * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n- * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n- * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n- * <\/ul><\/li>\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n- * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n@@ -495,0 +510,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -638,0 +655,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":60,"deletions":27,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.HashSet;\n@@ -72,0 +73,1 @@\n+    private final Set<MemoryLayout> CANONICAL_LAYOUTS_CACHE = new HashSet<>(canonicalLayouts().values());\n@@ -212,1 +214,1 @@\n-    private static void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+    private void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n@@ -222,1 +224,1 @@\n-    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+    private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n@@ -231,1 +233,1 @@\n-    private static void checkSupported(ValueLayout valueLayout) {\n+    private void checkSupported(ValueLayout valueLayout) {\n@@ -236,1 +238,1 @@\n-        if (!SUPPORTED_LAYOUTS.contains(valueLayout.withoutName())) {\n+        if (!CANONICAL_LAYOUTS_CACHE.contains(valueLayout.withoutName())) {\n@@ -241,1 +243,1 @@\n-    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+    private void checkHasNaturalAlignment(MemoryLayout layout) {\n@@ -272,12 +274,0 @@\n-\n-    private static final Set<MemoryLayout> SUPPORTED_LAYOUTS = Set.of(\n-            ValueLayout.JAVA_BOOLEAN,\n-            ValueLayout.JAVA_BYTE,\n-            ValueLayout.JAVA_CHAR,\n-            ValueLayout.JAVA_SHORT,\n-            ValueLayout.JAVA_INT,\n-            ValueLayout.JAVA_FLOAT,\n-            ValueLayout.JAVA_LONG,\n-            ValueLayout.JAVA_DOUBLE,\n-            ValueLayout.ADDRESS\n-    );\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -496,0 +496,31 @@\n+\n+    public static Map<String, MemoryLayout> canonicalLayouts(ValueLayout longLayout, ValueLayout sizetLayout, ValueLayout wchartLayout) {\n+        return Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int\", ValueLayout.JAVA_INT),\n+                Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"long\", longLayout),\n+                Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+                Map.entry(\"void*\", ValueLayout.ADDRESS),\n+                Map.entry(\"size_t\", sizetLayout),\n+                Map.entry(\"wchar_t\", wchartLayout),\n+                \/\/ unspecified size-dependent layouts\n+                Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n+                Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n+                \/\/ unspecified JNI layouts\n+                Map.entry(\"jboolean\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", ValueLayout.JAVA_CHAR),\n+                Map.entry(\"jbyte\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"jshort\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"jint\", ValueLayout.JAVA_INT),\n+                Map.entry(\"jlong\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"jfloat\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"jdouble\", ValueLayout.JAVA_DOUBLE)\n+        );\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -34,0 +35,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -37,0 +40,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -61,5 +62,1 @@\n-    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.byteSize()) {\n-            case 8 -> JAVA_LONG;\n-            case 4 -> JAVA_INT;\n-            default -> throw new IllegalStateException(\"Address size not supported: \" + ADDRESS.byteSize());\n-        };\n+    static final ValueLayout SIZE_T = layoutFor((int)ADDRESS.byteSize());\n@@ -146,0 +143,10 @@\n+\n+    static ValueLayout layoutFor(int byteSize) {\n+        return switch (byteSize) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new IllegalStateException(\"Unsupported size: \" + byteSize);\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.HashMap;\n@@ -49,0 +50,1 @@\n+import java.util.Map;\n@@ -52,0 +54,8 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -286,0 +296,37 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS = new HashMap<>();\n+\n+    static {\n+        CANONICAL_LAYOUTS.put(\"bool\", JAVA_BOOLEAN);\n+        CANONICAL_LAYOUTS.put(\"char\", JAVA_BYTE);\n+        CANONICAL_LAYOUTS.put(\"float\", JAVA_FLOAT);\n+        CANONICAL_LAYOUTS.put(\"double\", JAVA_DOUBLE);\n+        CANONICAL_LAYOUTS.put(\"long long\", JAVA_LONG);\n+        CANONICAL_LAYOUTS.put(\"void*\", ADDRESS);\n+        \/\/ platform-dependent sizes\n+        CANONICAL_LAYOUTS.put(\"size_t\", FFIType.SIZE_T);\n+        CANONICAL_LAYOUTS.put(\"short\", FFIType.layoutFor(LibFallback.shortSize()));\n+        CANONICAL_LAYOUTS.put(\"int\", FFIType.layoutFor(LibFallback.intSize()));\n+        CANONICAL_LAYOUTS.put(\"long\", FFIType.layoutFor(LibFallback.longSize()));\n+        int wchar_size = LibFallback.wcharSize();\n+        if (wchar_size == 2) {\n+            \/\/ prefer JAVA_CHAR\n+            CANONICAL_LAYOUTS.put(\"wchar_t\", JAVA_CHAR);\n+        } else {\n+            CANONICAL_LAYOUTS.put(\"wchar_t\", FFIType.layoutFor(wchar_size));\n+        }\n+        \/\/ JNI types\n+        CANONICAL_LAYOUTS.put(\"jboolean\", JAVA_BOOLEAN);\n+        CANONICAL_LAYOUTS.put(\"jchar\", JAVA_CHAR);\n+        CANONICAL_LAYOUTS.put(\"jbyte\", JAVA_BYTE);\n+        CANONICAL_LAYOUTS.put(\"jshort\", JAVA_SHORT);\n+        CANONICAL_LAYOUTS.put(\"jint\", JAVA_INT);\n+        CANONICAL_LAYOUTS.put(\"jlong\", JAVA_LONG);\n+        CANONICAL_LAYOUTS.put(\"jfloat\", JAVA_FLOAT);\n+        CANONICAL_LAYOUTS.put(\"jdouble\", JAVA_DOUBLE);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -62,0 +62,6 @@\n+    \/\/ platform-dependent types\n+    static int shortSize() { return NativeConstants.SIZEOF_SHORT; }\n+    static int intSize() { return NativeConstants.SIZEOF_INT; }\n+    static int longSize() {return NativeConstants.SIZEOF_LONG; }\n+    static int wcharSize() {return NativeConstants.SIZEOF_WCHAR; }\n+\n@@ -219,0 +225,4 @@\n+    private static native int ffi_sizeof_short();\n+    private static native int ffi_sizeof_int();\n+    private static native int ffi_sizeof_long();\n+    private static native int ffi_sizeof_wchar();\n@@ -236,0 +246,5 @@\n+        static final int SIZEOF_SHORT = ffi_sizeof_short();\n+        static final int SIZEOF_INT = ffi_sizeof_int();\n+        static final int SIZEOF_LONG = ffi_sizeof_long();\n+        static final int SIZEOF_WCHAR = ffi_sizeof_wchar();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -31,0 +32,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -34,0 +37,1 @@\n+import java.util.Map;\n@@ -40,0 +44,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n+\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <wchar.h>\n@@ -209,0 +210,20 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1short(JNIEnv* env, jclass cls) {\n+  return sizeof(short);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1int(JNIEnv* env, jclass cls) {\n+  return sizeof(int);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1long(JNIEnv* env, jclass cls) {\n+  return sizeof(long);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1wchar(JNIEnv* env, jclass cls) {\n+  return sizeof(wchar_t);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -46,0 +48,1 @@\n+import static org.testng.Assert.assertNotNull;\n@@ -48,0 +51,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -141,0 +145,23 @@\n+    @Test(dataProvider = \"canonicalTypeNames\")\n+    public void testCanonicalLayouts(String typeName) {\n+        MemoryLayout layout = LINKER.canonicalLayouts().get(typeName);\n+        assertNotNull(layout);\n+        assertTrue(layout instanceof ValueLayout);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] canonicalTypeNames() {\n+        return new Object[][]{\n+                { \"bool\" },\n+                { \"char\" },\n+                { \"short\" },\n+                { \"int\" },\n+                { \"long\" },\n+                { \"long long\" },\n+                { \"float\" },\n+                { \"double\" },\n+                { \"void*\" },\n+                { \"size_t\" },\n+                { \"wchar_t\" },\n+        };\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"}]}