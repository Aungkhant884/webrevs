{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.file.Path;\n@@ -33,0 +34,1 @@\n+import java.util.Optional;\n@@ -92,1 +94,0 @@\n-     * @throws NoSuchMethodException if no symbol with given name could be found.\n@@ -94,1 +95,1 @@\n-    Symbol lookup(String name) throws NoSuchMethodException;\n+    Optional<Symbol> lookup(String name);\n@@ -110,1 +111,1 @@\n-     * @param path the library path.\n+     * @param path the library absolute path.\n@@ -112,0 +113,2 @@\n+     * @throws IllegalArgumentException if the specified path does not correspond to an absolute path,\n+     * e.g. if {@code !path.isAbsolute()}.\n@@ -113,1 +116,1 @@\n-    static LibraryLookup ofPath(String path) {\n+    static LibraryLookup ofPath(Path path) {\n@@ -115,0 +118,4 @@\n+        if (!path.isAbsolute()) {\n+            throw new IllegalArgumentException(\"Not an absolute path: \" + path.toString());\n+        }\n+        String absolutePath = path.toString();\n@@ -117,5 +124,1 @@\n-            security.checkLink(path);\n-        }\n-        if (!(new File(path).isAbsolute())) {\n-            throw new UnsatisfiedLinkError(\n-                    \"Expecting an absolute path of the library: \" + path);\n+            security.checkLink(absolutePath);\n@@ -123,1 +126,1 @@\n-        return LibrariesHelper.load(path);\n+        return LibrariesHelper.load(absolutePath);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -118,13 +118,17 @@\n-        public Symbol lookup(String name) throws NoSuchMethodException {\n-            MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n-            return new Symbol() { \/\/ inner class - retains a link to enclosing lookup\n-                @Override\n-                public String name() {\n-                    return name;\n-                }\n-\n-                @Override\n-                public MemoryAddress address() {\n-                    return addr;\n-                }\n-            };\n+        public Optional<Symbol> lookup(String name) {\n+            try {\n+                MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n+                return Optional.of(new Symbol() { \/\/ inner class - retains a link to enclosing lookup\n+                    @Override\n+                    public String name() {\n+                        return name;\n+                    }\n+\n+                    @Override\n+                    public MemoryAddress address() {\n+                        return addr;\n+                    }\n+                });\n+            } catch (NoSuchMethodException ex) {\n+                return Optional.empty();\n+            }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -267,2 +267,0 @@\n-        static final MethodHandle MH_MALLOC;\n-        static final MethodHandle MH_FREE;\n@@ -270,4 +268,3 @@\n-        static {\n-            LibraryLookup lookup = LibraryLookup.ofDefault();\n-            try {\n-                MH_MALLOC = getSystemLinker().downcallHandle(lookup.lookup(\"malloc\"),\n+        final static LibraryLookup LOOKUP = LibraryLookup.ofDefault();\n+\n+        final static MethodHandle MH_MALLOC = getSystemLinker().downcallHandle(LOOKUP.lookup(\"malloc\").get(),\n@@ -275,1 +272,1 @@\n-                        FunctionDescriptor.of(C_POINTER, C_LONGLONG));\n+                FunctionDescriptor.of(C_POINTER, C_LONGLONG));\n@@ -277,1 +274,1 @@\n-                MH_FREE = getSystemLinker().downcallHandle(lookup.lookup(\"free\"),\n+        final static MethodHandle MH_FREE = getSystemLinker().downcallHandle(LOOKUP.lookup(\"free\").get(),\n@@ -279,5 +276,1 @@\n-                        FunctionDescriptor.ofVoid(C_POINTER));\n-            } catch (NoSuchMethodException nsme) {\n-                throw new BootstrapMethodError(nsme);\n-            }\n-        }\n+                FunctionDescriptor.ofVoid(C_POINTER));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -155,12 +155,1 @@\n-        final static MethodHandle strcat;\n-        final static MethodHandle strcmp;\n-        final static MethodHandle puts;\n-        final static MethodHandle strlen;\n-        final static MethodHandle gmtime;\n-        final static MethodHandle qsort;\n-        final static MethodHandle qsortCompar;\n-        final static FunctionDescriptor qsortComparFunction;\n-        final static MethodHandle rand;\n-        final static MethodHandle vprintf;\n-        final static LibraryLookup.Symbol printfAddr;\n-        final static FunctionDescriptor printfBase;\n+        static final LibraryLookup lookup = LibraryLookup.ofDefault();\n@@ -168,3 +157,3 @@\n-        static {\n-            try {\n-                LibraryLookup lookup = LibraryLookup.ofDefault();\n+        final static MethodHandle strcat = abi.downcallHandle(lookup.lookup(\"strcat\").get(),\n+                MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));\n@@ -172,3 +161,3 @@\n-                strcat = abi.downcallHandle(lookup.lookup(\"strcat\"),\n-                        MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),\n-                        FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));\n+        final static MethodHandle strcmp = abi.downcallHandle(lookup.lookup(\"strcmp\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));\n@@ -176,3 +165,3 @@\n-                strcmp = abi.downcallHandle(lookup.lookup(\"strcmp\"),\n-                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),\n-                        FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));\n+        final static MethodHandle puts = abi.downcallHandle(lookup.lookup(\"puts\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n@@ -180,3 +169,3 @@\n-                puts = abi.downcallHandle(lookup.lookup(\"puts\"),\n-                        MethodType.methodType(int.class, MemoryAddress.class),\n-                        FunctionDescriptor.of(C_INT, C_POINTER));\n+        final static MethodHandle strlen = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n@@ -184,3 +173,3 @@\n-                strlen = abi.downcallHandle(lookup.lookup(\"strlen\"),\n-                        MethodType.methodType(int.class, MemoryAddress.class),\n-                        FunctionDescriptor.of(C_INT, C_POINTER));\n+        final static MethodHandle gmtime = abi.downcallHandle(lookup.lookup(\"gmtime\").get(),\n+                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER));\n@@ -188,3 +177,3 @@\n-                gmtime = abi.downcallHandle(lookup.lookup(\"gmtime\"),\n-                        MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n-                        FunctionDescriptor.of(C_POINTER, C_POINTER));\n+        final static MethodHandle qsort = abi.downcallHandle(lookup.lookup(\"qsort\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_LONGLONG, C_LONGLONG, C_POINTER));\n@@ -192,1 +181,1 @@\n-                qsortComparFunction = FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER);\n+        final static FunctionDescriptor qsortComparFunction = FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER);\n@@ -194,3 +183,1 @@\n-                qsort = abi.downcallHandle(lookup.lookup(\"qsort\"),\n-                        MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n-                        FunctionDescriptor.ofVoid(C_POINTER, C_LONGLONG, C_LONGLONG, C_POINTER));\n+        final static MethodHandle qsortCompar;\n@@ -198,3 +185,3 @@\n-                \/\/qsort upcall handle\n-                qsortCompar = MethodHandles.lookup().findStatic(StdLibTest.StdLibHelper.class, \"qsortCompare\",\n-                        MethodType.methodType(int.class, MemorySegment.class, MemoryAddress.class, MemoryAddress.class));\n+        final static MethodHandle rand = abi.downcallHandle(lookup.lookup(\"rand\").get(),\n+                MethodType.methodType(int.class),\n+                FunctionDescriptor.of(C_INT));\n@@ -202,3 +189,3 @@\n-                rand = abi.downcallHandle(lookup.lookup(\"rand\"),\n-                        MethodType.methodType(int.class),\n-                        FunctionDescriptor.of(C_INT));\n+        final static MethodHandle vprintf = abi.downcallHandle(lookup.lookup(\"vprintf\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n@@ -206,3 +193,1 @@\n-                vprintf = abi.downcallHandle(lookup.lookup(\"vprintf\"),\n-                        MethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n-                        FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+        final static LibraryLookup.Symbol printfAddr = lookup.lookup(\"printf\").get();\n@@ -210,1 +195,1 @@\n-                printfAddr = lookup.lookup(\"printf\");\n+        final static FunctionDescriptor printfBase = FunctionDescriptor.of(C_INT, C_POINTER);\n@@ -212,2 +197,6 @@\n-                printfBase = FunctionDescriptor.of(C_INT, C_POINTER);\n-            } catch (Throwable ex) {\n+        static {\n+            try {\n+                \/\/qsort upcall handle\n+                qsortCompar = MethodHandles.lookup().findStatic(StdLibTest.StdLibHelper.class, \"qsortCompare\",\n+                        MethodType.methodType(int.class, MemorySegment.class, MemoryAddress.class, MemoryAddress.class));\n+            } catch (ReflectiveOperationException ex) {\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":35,"deletions":46,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        LibraryLookup.Symbol addr = lib.lookup(fName);\n+        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        LibraryLookup.Symbol ma = lookup.lookup(name);\n+        LibraryLookup.Symbol ma = lookup.lookup(name).get();\n@@ -75,1 +75,1 @@\n-                LibraryLookup.Symbol ma = lookup.lookup(\"empty\");\n+                LibraryLookup.Symbol ma = lookup.lookup(\"empty\").get();\n@@ -87,1 +87,1 @@\n-                LibraryLookup.Symbol ma = lookup.lookup(\"identity_va\");\n+                LibraryLookup.Symbol ma = lookup.lookup(\"identity_va\").get();\n@@ -94,1 +94,1 @@\n-                LibraryLookup.Symbol ma = lookup.lookup(\"invoke_consumer\");\n+                LibraryLookup.Symbol ma = lookup.lookup(\"invoke_consumer\").get();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Library not found.*\")\n@@ -51,1 +51,6 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Not an absolute path.*\")\n+    public void testNoAbsoluteLookupPath() {\n+        LibraryLookup.ofPath(Path.of(\"NonExistent\"));\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Library not found.*\")\n@@ -53,1 +58,1 @@\n-        LibraryLookup.ofPath(Path.of(\"NonExistent\").toAbsolutePath().toString());\n+        LibraryLookup.ofPath(Path.of(\"NonExistent\").toAbsolutePath());\n@@ -60,1 +65,1 @@\n-        symbol = lookup.lookup(\"f\");\n+        symbol = lookup.lookup(\"f\").get();\n@@ -68,0 +73,11 @@\n+    @Test\n+    public void testInvalidSymbolLookup() throws Throwable {\n+        LibraryLookup.Symbol symbol = null;\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n+        assertTrue(lookup.lookup(\"nonExistent\").isEmpty());\n+        assertEquals(LibrariesHelper.numLoadedLibraries(), 1);\n+        lookup = null;\n+        symbol = null;\n+        waitUnload();\n+    }\n+\n@@ -74,1 +90,1 @@\n-            LibraryLookup.Symbol symbol = lookup.lookup(\"f\");\n+            LibraryLookup.Symbol symbol = lookup.lookup(\"f\").get();\n@@ -137,1 +153,1 @@\n-                symbol = lookup.lookup(\"f\");\n+                symbol = lookup.lookup(\"f\").get();\n","filename":"test\/jdk\/java\/foreign\/TestLibraryLookup.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        LibraryLookup.Symbol addr = lib.lookup(fName);\n+        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                lookup.lookup(\"do_upcall\"),\n+                lookup.lookup(\"do_upcall\").get(),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,9 +62,2 @@\n-    static final LibraryLookup.Symbol varargsAddr;\n-\n-    static {\n-        try {\n-            varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\").lookup(\"varargs\");\n-        } catch (NoSuchMethodException e) {\n-            throw new BootstrapMethodError(e);\n-        }\n-    }\n+    static final LibraryLookup.Symbol varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\")\n+            .lookup(\"varargs\").get();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-                    lookup.lookup(\"foo\"),\n+                    lookup.lookup(\"foo\").get(),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,5 +99,1 @@\n-        try {\n-            return abi.downcallHandle(lookup.lookup(symbol), mt, fd);\n-        } catch (NoSuchMethodException e) {\n-            throw new NoSuchMethodError(e.getMessage());\n-        }\n+        return abi.downcallHandle(lookup.lookup(symbol).get(), mt, fd);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+\n@@ -76,32 +77,14 @@\n-        try {\n-            LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n-            {\n-                LibraryLookup.Symbol addr = ll.lookup(\"func\");\n-                MethodType mt = MethodType.methodType(void.class);\n-                FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n-                func = abi.downcallHandle(addr, mt, fd);\n-                func_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            }\n-            {\n-                LibraryLookup.Symbol addr = ll.lookup(\"identity\");\n-                MethodType mt = MethodType.methodType(int.class, int.class);\n-                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n-                identity = abi.downcallHandle(addr, mt, fd);\n-                identity_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            }\n-            identity_struct = abi.downcallHandle(ll.lookup(\"identity_struct\"),\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class),\n-                    FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n-            identity_memory_address = abi.downcallHandle(ll.lookup(\"identity_memory_address\"),\n-                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n-                    FunctionDescriptor.of(C_POINTER, C_POINTER));\n-            args5 = abi.downcallHandle(ll.lookup(\"args5\"),\n-                    MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n-                    FunctionDescriptor.ofVoid(C_LONGLONG, C_DOUBLE, C_LONGLONG, C_DOUBLE, C_LONGLONG));\n-            args10 = abi.downcallHandle(ll.lookup(\"args10\"),\n-                    MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n-                                                      double.class, long.class, double.class, long.class, double.class),\n-                    FunctionDescriptor.ofVoid(C_LONGLONG, C_DOUBLE, C_LONGLONG, C_DOUBLE, C_LONGLONG,\n-                                              C_DOUBLE, C_LONGLONG, C_DOUBLE, C_LONGLONG, C_DOUBLE));\n-        } catch (NoSuchMethodException e) {\n-            throw new BootstrapMethodError(e);\n+        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n+        {\n+            LibraryLookup.Symbol addr = ll.lookup(\"func\").get();\n+            MethodType mt = MethodType.methodType(void.class);\n+            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+            func = abi.downcallHandle(addr, mt, fd);\n+            func_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+        }\n+        {\n+            LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n+            MethodType mt = MethodType.methodType(int.class, int.class);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+            identity = abi.downcallHandle(addr, mt, fd);\n+            identity_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n@@ -109,0 +92,14 @@\n+        identity_struct = abi.downcallHandle(ll.lookup(\"identity_struct\").get(),\n+                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n+        identity_memory_address = abi.downcallHandle(ll.lookup(\"identity_memory_address\").get(),\n+                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER));\n+        args5 = abi.downcallHandle(ll.lookup(\"args5\").get(),\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONGLONG, C_DOUBLE, C_LONGLONG, C_DOUBLE, C_LONGLONG));\n+        args10 = abi.downcallHandle(ll.lookup(\"args10\").get(),\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n+                                                  double.class, long.class, double.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONGLONG, C_DOUBLE, C_LONGLONG, C_DOUBLE, C_LONGLONG,\n+                                          C_DOUBLE, C_LONGLONG, C_DOUBLE, C_LONGLONG, C_DOUBLE));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverhead.java","additions":29,"deletions":32,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"blank\");\n+                LibraryLookup.Symbol addr = ll.lookup(\"blank\").get();\n@@ -85,1 +85,1 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"identity\");\n+                LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,10 +62,6 @@\n-        try {\n-            MH_ellipsis = linker.downcallHandle(lookup.lookup(\"ellipsis\"),\n-                    MethodType.methodType(void.class, int.class, int.class, double.class, long.class),\n-                    FunctionDescriptor.ofVoid(C_INT, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_LONGLONG)));\n-            MH_vaList = linker.downcallHandle(lookup.lookup(\"vaList\"),\n-                    MethodType.methodType(void.class, int.class, VaList.class),\n-                    FunctionDescriptor.ofVoid(C_INT, C_VA_LIST));\n-        } catch (NoSuchMethodException e) {\n-            throw new InternalError(e);\n-        }\n+        MH_ellipsis = linker.downcallHandle(lookup.lookup(\"ellipsis\").get(),\n+                MethodType.methodType(void.class, int.class, int.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_INT, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_LONGLONG)));\n+        MH_vaList = linker.downcallHandle(lookup.lookup(\"vaList\").get(),\n+                MethodType.methodType(void.class, int.class, VaList.class),\n+                FunctionDescriptor.ofVoid(C_INT, C_VA_LIST));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,16 +52,12 @@\n-        try {\n-            CLinker abi = CLinker.getInstance();\n-            LibraryLookup lookup = LibraryLookup.ofLibrary(\"Point\");\n-            MH_distance = abi.downcallHandle(\n-                lookup.lookup(\"distance\"),\n-                methodType(double.class, MemorySegment.class, MemorySegment.class),\n-                FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n-            );\n-            MH_distance_ptrs = abi.downcallHandle(\n-                lookup.lookup(\"distance_ptrs\"),\n-                methodType(double.class, MemoryAddress.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n-            );\n-        } catch (NoSuchMethodException e) {\n-            throw new BootstrapMethodError(e);\n-        }\n+        CLinker abi = CLinker.getInstance();\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"Point\");\n+        MH_distance = abi.downcallHandle(\n+            lookup.lookup(\"distance\").get(),\n+            methodType(double.class, MemorySegment.class, MemorySegment.class),\n+            FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n+        );\n+        MH_distance_ptrs = abi.downcallHandle(\n+            lookup.lookup(\"distance_ptrs\").get(),\n+            methodType(double.class, MemoryAddress.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n+        );\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"}]}