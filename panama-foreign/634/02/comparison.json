{"files":[{"patch":"@@ -46,2 +46,2 @@\n-#define INTEGER_TYPE 0\n-#define VECTOR_TYPE 1\n+static constexpr int INTEGER_TYPE = 0;\n+static constexpr int VECTOR_TYPE = 1;\n@@ -49,1 +49,1 @@\n-const ABIDescriptor ForeignGlobals::parse_abi_descriptor_impl(jobject jabi) const {\n+const ABIDescriptor ForeignGlobals::parse_abi_descriptor(jobject jabi) {\n@@ -54,1 +54,1 @@\n-  objArrayOop inputStorage = oop_cast<objArrayOop>(abi_oop->obj_field(ABI.inputStorage_offset));\n+  objArrayOop inputStorage = jdk_internal_foreign_abi_ABIDescriptor::inputStorage(abi_oop);\n@@ -58,1 +58,1 @@\n-  objArrayOop outputStorage = oop_cast<objArrayOop>(abi_oop->obj_field(ABI.outputStorage_offset));\n+  objArrayOop outputStorage = jdk_internal_foreign_abi_ABIDescriptor::outputStorage(abi_oop);\n@@ -62,1 +62,1 @@\n-  objArrayOop volatileStorage = oop_cast<objArrayOop>(abi_oop->obj_field(ABI.volatileStorage_offset));\n+  objArrayOop volatileStorage = jdk_internal_foreign_abi_ABIDescriptor::volatileStorage(abi_oop);\n@@ -66,2 +66,2 @@\n-  abi._stack_alignment_bytes = abi_oop->int_field(ABI.stackAlignment_offset);\n-  abi._shadow_space_bytes = abi_oop->int_field(ABI.shadowSpace_offset);\n+  abi._stack_alignment_bytes = jdk_internal_foreign_abi_ABIDescriptor::stackAlignment(abi_oop);\n+  abi._shadow_space_bytes = jdk_internal_foreign_abi_ABIDescriptor::shadowSpace(abi_oop);\n@@ -69,2 +69,2 @@\n-  abi._target_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.targetAddrStorage_offset))->as_Register();\n-  abi._ret_buf_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.retBufAddrStorage_offset))->as_Register();\n+  abi._target_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop))->as_Register();\n+  abi._ret_buf_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop))->as_Register();\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-                    Address(nep_reg, NONZERO(jdk_internal_invoke_NativeEntryPoint::invoker_offset_in_bytes())),\n+                    Address(nep_reg, NONZERO(jdk_internal_foreign_abi_NativeEntryPoint::invoker_offset_in_bytes())),\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-const ABIDescriptor ForeignGlobals::parse_abi_descriptor_impl(jobject jabi) const {\n-  Unimplemented();\n-  return {};\n-}\n-\n-const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+const ABIDescriptor ForeignGlobals::parse_abi_descriptor(jobject jabi) {\n","filename":"src\/hotspot\/cpu\/arm\/foreign_globals_arm.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,6 +30,1 @@\n-const ABIDescriptor ForeignGlobals::parse_abi_descriptor_impl(jobject jabi) const {\n-  Unimplemented();\n-  return {};\n-}\n-\n-const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+const ABIDescriptor ForeignGlobals::parse_abi_descriptor(jobject jabi) {\n","filename":"src\/hotspot\/cpu\/ppc\/foreign_globals_ppc.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-const ABIDescriptor ForeignGlobals::parse_abi_descriptor_impl(jobject jabi) const {\n-  Unimplemented();\n-  return {};\n-}\n-\n-const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+const ABIDescriptor ForeignGlobals::parse_abi_descriptor(jobject jabi) {\n","filename":"src\/hotspot\/cpu\/s390\/foreign_globals_s390.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,3 +42,3 @@\n-#define INTEGER_TYPE 0\n-#define VECTOR_TYPE 1\n-#define X87_TYPE 2\n+static constexpr int INTEGER_TYPE = 0;\n+static constexpr int VECTOR_TYPE = 1;\n+static constexpr int X87_TYPE = 2;\n@@ -46,1 +46,1 @@\n-const ABIDescriptor ForeignGlobals::parse_abi_descriptor_impl(jobject jabi) const {\n+const ABIDescriptor ForeignGlobals::parse_abi_descriptor(jobject jabi) {\n@@ -50,1 +50,1 @@\n-  objArrayOop inputStorage = oop_cast<objArrayOop>(abi_oop->obj_field(ABI.inputStorage_offset));\n+  objArrayOop inputStorage = jdk_internal_foreign_abi_ABIDescriptor::inputStorage(abi_oop);\n@@ -54,1 +54,1 @@\n-  objArrayOop outputStorage = oop_cast<objArrayOop>(abi_oop->obj_field(ABI.outputStorage_offset));\n+  objArrayOop outputStorage = jdk_internal_foreign_abi_ABIDescriptor::outputStorage(abi_oop);\n@@ -60,1 +60,1 @@\n-  objArrayOop volatileStorage = oop_cast<objArrayOop>(abi_oop->obj_field(ABI.volatileStorage_offset));\n+  objArrayOop volatileStorage = jdk_internal_foreign_abi_ABIDescriptor::volatileStorage(abi_oop);\n@@ -64,2 +64,2 @@\n-  abi._stack_alignment_bytes = abi_oop->int_field(ABI.stackAlignment_offset);\n-  abi._shadow_space_bytes = abi_oop->int_field(ABI.shadowSpace_offset);\n+  abi._stack_alignment_bytes = jdk_internal_foreign_abi_ABIDescriptor::stackAlignment(abi_oop);\n+  abi._shadow_space_bytes = jdk_internal_foreign_abi_ABIDescriptor::shadowSpace(abi_oop);\n@@ -67,2 +67,2 @@\n-  abi._target_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.targetAddrStorage_offset))->as_Register();\n-  abi._ret_buf_addr_reg = parse_vmstorage(abi_oop->obj_field(ABI.retBufAddrStorage_offset))->as_Register();\n+  abi._target_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop))->as_Register();\n+  abi._ret_buf_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop))->as_Register();\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-                    Address(nep_reg, NONZERO(jdk_internal_invoke_NativeEntryPoint::invoker_offset_in_bytes())),\n+                    Address(nep_reg, NONZERO(jdk_internal_foreign_abi_NativeEntryPoint::invoker_offset_in_bytes())),\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-const ABIDescriptor ForeignGlobals::parse_abi_descriptor_impl(jobject jabi) const {\n-  ShouldNotCallThis();\n-  return {};\n-}\n-\n-const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+const ABIDescriptor ForeignGlobals::parse_abi_descriptor(jobject jabi) {\n","filename":"src\/hotspot\/cpu\/zero\/foreign_globals_zero.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"oops\/oopCast.inline.hpp\"\n@@ -3861,2 +3862,2 @@\n-int jdk_internal_invoke_NativeEntryPoint::_method_type_offset;\n-int jdk_internal_invoke_NativeEntryPoint::_invoker_offset;\n+int jdk_internal_foreign_abi_NativeEntryPoint::_method_type_offset;\n+int jdk_internal_foreign_abi_NativeEntryPoint::_invoker_offset;\n@@ -3868,1 +3869,1 @@\n-bool jdk_internal_invoke_NativeEntryPoint::is_instance(oop obj) {\n+bool jdk_internal_foreign_abi_NativeEntryPoint::is_instance(oop obj) {\n@@ -3872,1 +3873,1 @@\n-void jdk_internal_invoke_NativeEntryPoint::compute_offsets() {\n+void jdk_internal_foreign_abi_NativeEntryPoint::compute_offsets() {\n@@ -3878,1 +3879,1 @@\n-void jdk_internal_invoke_NativeEntryPoint::serialize_offsets(SerializeClosure* f) {\n+void jdk_internal_foreign_abi_NativeEntryPoint::serialize_offsets(SerializeClosure* f) {\n@@ -3883,1 +3884,1 @@\n-oop jdk_internal_invoke_NativeEntryPoint::method_type(oop entry) {\n+oop jdk_internal_foreign_abi_NativeEntryPoint::method_type(oop entry) {\n@@ -3887,1 +3888,1 @@\n-jlong jdk_internal_invoke_NativeEntryPoint::invoker(oop entry) {\n+jlong jdk_internal_foreign_abi_NativeEntryPoint::invoker(oop entry) {\n@@ -3891,0 +3892,126 @@\n+int jdk_internal_foreign_abi_ABIDescriptor::_inputStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_outputStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_volatileStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_stackAlignment_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_shadowSpace_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_targetAddrStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_retBufAddrStorage_offset;\n+\n+#define ABIDescriptor_FIELDS_DO(macro) \\\n+  macro(_inputStorage_offset,      k, \"inputStorage\",      jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_outputStorage_offset,     k, \"outputStorage\",     jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_volatileStorage_offset,   k, \"volatileStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_stackAlignment_offset,    k, \"stackAlignment\",    int_signature, false); \\\n+  macro(_shadowSpace_offset,       k, \"shadowSpace\",       int_signature, false); \\\n+  macro(_targetAddrStorage_offset, k, \"targetAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false); \\\n+  macro(_retBufAddrStorage_offset, k, \"retBufAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false);\n+\n+bool jdk_internal_foreign_abi_ABIDescriptor::is_instance(oop obj) {\n+  return obj != NULL && is_subclass(obj->klass());\n+}\n+\n+void jdk_internal_foreign_abi_ABIDescriptor::compute_offsets() {\n+  InstanceKlass* k = vmClasses::ABIDescriptor_klass();\n+  ABIDescriptor_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void jdk_internal_foreign_abi_ABIDescriptor::serialize_offsets(SerializeClosure* f) {\n+  ABIDescriptor_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+objArrayOop jdk_internal_foreign_abi_ABIDescriptor::inputStorage(oop entry) {\n+  return oop_cast<objArrayOop>(entry->obj_field(_inputStorage_offset));\n+}\n+\n+objArrayOop jdk_internal_foreign_abi_ABIDescriptor::outputStorage(oop entry) {\n+  return oop_cast<objArrayOop>(entry->obj_field(_outputStorage_offset));\n+}\n+\n+objArrayOop jdk_internal_foreign_abi_ABIDescriptor::volatileStorage(oop entry) {\n+  return oop_cast<objArrayOop>(entry->obj_field(_volatileStorage_offset));\n+}\n+\n+jint jdk_internal_foreign_abi_ABIDescriptor::stackAlignment(oop entry) {\n+  return entry->int_field(_stackAlignment_offset);\n+}\n+\n+jint jdk_internal_foreign_abi_ABIDescriptor::shadowSpace(oop entry) {\n+  return entry->int_field(_shadowSpace_offset);\n+}\n+\n+oop jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(oop entry) {\n+  return entry->obj_field(_targetAddrStorage_offset);\n+}\n+\n+oop jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(oop entry) {\n+  return entry->obj_field(_retBufAddrStorage_offset);\n+}\n+\n+int jdk_internal_foreign_abi_VMStorage::_type_offset;\n+int jdk_internal_foreign_abi_VMStorage::_index_offset;\n+int jdk_internal_foreign_abi_VMStorage::_debugName_offset;\n+\n+#define VMStorage_FIELDS_DO(macro) \\\n+  macro(_type_offset,      k, \"type\",      int_signature, false); \\\n+  macro(_index_offset,     k, \"index\",     int_signature, false); \\\n+  macro(_debugName_offset, k, \"debugName\", string_signature, false); \\\n+\n+bool jdk_internal_foreign_abi_VMStorage::is_instance(oop obj) {\n+  return obj != NULL && is_subclass(obj->klass());\n+}\n+\n+void jdk_internal_foreign_abi_VMStorage::compute_offsets() {\n+  InstanceKlass* k = vmClasses::VMStorage_klass();\n+  VMStorage_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void jdk_internal_foreign_abi_VMStorage::serialize_offsets(SerializeClosure* f) {\n+  VMStorage_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+jint jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n+  return entry->int_field(_type_offset);\n+}\n+\n+jint jdk_internal_foreign_abi_VMStorage::index(oop entry) {\n+  return entry->int_field(_index_offset);\n+}\n+\n+oop jdk_internal_foreign_abi_VMStorage::debugName(oop entry) {\n+  return entry->obj_field(_debugName_offset);\n+}\n+\n+int jdk_internal_foreign_abi_CallConv::_argRegs_offset;\n+int jdk_internal_foreign_abi_CallConv::_retRegs_offset;\n+\n+#define CallConv_FIELDS_DO(macro) \\\n+  macro(_argRegs_offset, k, \"argRegs\", jdk_internal_foreign_abi_VMStorage_array_signature, false); \\\n+  macro(_retRegs_offset, k, \"retRegs\", jdk_internal_foreign_abi_VMStorage_array_signature, false); \\\n+\n+bool jdk_internal_foreign_abi_CallConv::is_instance(oop obj) {\n+  return obj != NULL && is_subclass(obj->klass());\n+}\n+\n+void jdk_internal_foreign_abi_CallConv::compute_offsets() {\n+  InstanceKlass* k = vmClasses::CallConv_klass();\n+  CallConv_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void jdk_internal_foreign_abi_CallConv::serialize_offsets(SerializeClosure* f) {\n+  CallConv_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+objArrayOop jdk_internal_foreign_abi_CallConv::argRegs(oop entry) {\n+  return oop_cast<objArrayOop>(entry->obj_field(_argRegs_offset));\n+}\n+\n+objArrayOop jdk_internal_foreign_abi_CallConv::retRegs(oop entry) {\n+  return oop_cast<objArrayOop>(entry->obj_field(_retRegs_offset));\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":134,"deletions":7,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -77,1 +77,4 @@\n-  f(jdk_internal_invoke_NativeEntryPoint) \\\n+  f(jdk_internal_foreign_abi_NativeEntryPoint) \\\n+  f(jdk_internal_foreign_abi_ABIDescriptor) \\\n+  f(jdk_internal_foreign_abi_VMStorage) \\\n+  f(jdk_internal_foreign_abi_CallConv) \\\n@@ -1041,1 +1044,1 @@\n-class jdk_internal_invoke_NativeEntryPoint: AllStatic {\n+class jdk_internal_foreign_abi_NativeEntryPoint: AllStatic {\n@@ -1069,0 +1072,84 @@\n+class jdk_internal_foreign_abi_ABIDescriptor: AllStatic {\n+  friend class JavaClasses;\n+\n+ private:\n+  static int _inputStorage_offset;\n+  static int _outputStorage_offset;\n+  static int _volatileStorage_offset;\n+  static int _stackAlignment_offset;\n+  static int _shadowSpace_offset;\n+  static int _targetAddrStorage_offset;\n+  static int _retBufAddrStorage_offset;\n+\n+  static void compute_offsets();\n+\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Accessors\n+  static objArrayOop inputStorage(oop entry);\n+  static objArrayOop outputStorage(oop entry);\n+  static objArrayOop volatileStorage(oop entry);\n+  static jint        stackAlignment(oop entry);\n+  static jint        shadowSpace(oop entry);\n+  static oop         targetAddrStorage(oop entry);\n+  static oop         retBufAddrStorage(oop entry);\n+\n+  \/\/ Testers\n+  static bool is_subclass(Klass* klass) {\n+    return vmClasses::ABIDescriptor_klass() != NULL &&\n+      klass->is_subclass_of(vmClasses::ABIDescriptor_klass());\n+  }\n+  static bool is_instance(oop obj);\n+};\n+\n+class jdk_internal_foreign_abi_VMStorage: AllStatic {\n+  friend class JavaClasses;\n+\n+ private:\n+  static int _type_offset;\n+  static int _index_offset;\n+  static int _debugName_offset;\n+\n+  static void compute_offsets();\n+\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Accessors\n+  static jint        type(oop entry);\n+  static jint        index(oop entry);\n+  static oop         debugName(oop entry);\n+\n+  \/\/ Testers\n+  static bool is_subclass(Klass* klass) {\n+    return vmClasses::VMStorage_klass() != NULL &&\n+      klass->is_subclass_of(vmClasses::VMStorage_klass());\n+  }\n+  static bool is_instance(oop obj);\n+};\n+\n+class jdk_internal_foreign_abi_CallConv: AllStatic {\n+  friend class JavaClasses;\n+\n+ private:\n+  static int _argRegs_offset;\n+  static int _retRegs_offset;\n+\n+  static void compute_offsets();\n+\n+ public:\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Accessors\n+  static objArrayOop argRegs(oop entry);\n+  static objArrayOop retRegs(oop entry);\n+\n+  \/\/ Testers\n+  static bool is_subclass(Klass* klass) {\n+    return vmClasses::CallConv_klass() != NULL &&\n+      klass->is_subclass_of(vmClasses::CallConv_klass());\n+  }\n+  static bool is_instance(oop obj);\n+};\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":89,"deletions":2,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -121,1 +121,4 @@\n-  do_klass(NativeEntryPoint_klass,                      jdk_internal_invoke_NativeEntryPoint                  ) \\\n+  do_klass(NativeEntryPoint_klass,                      jdk_internal_foreign_abi_NativeEntryPoint             ) \\\n+  do_klass(ABIDescriptor_klass,                         jdk_internal_foreign_abi_ABIDescriptor                ) \\\n+  do_klass(VMStorage_klass,                             jdk_internal_foreign_abi_VMStorage                    ) \\\n+  do_klass(CallConv_klass,                              jdk_internal_foreign_abi_CallConv                     ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -352,3 +352,8 @@\n-  \/* Foreign API Support *\/                                                                                          \\\n-  template(jdk_internal_invoke_NativeEntryPoint,                 \"jdk\/internal\/invoke\/NativeEntryPoint\")           \\\n-  template(jdk_internal_invoke_NativeEntryPoint_signature,       \"Ljdk\/internal\/invoke\/NativeEntryPoint;\")         \\\n+  \/* Foreign API Support *\/                                                                       \\\n+  template(jdk_internal_foreign_abi_NativeEntryPoint,                \"jdk\/internal\/foreign\/abi\/NativeEntryPoint\") \\\n+  template(jdk_internal_foreign_abi_ABIDescriptor,                   \"jdk\/internal\/foreign\/abi\/ABIDescriptor\") \\\n+  template(jdk_internal_foreign_abi_VMStorage,                       \"jdk\/internal\/foreign\/abi\/VMStorage\") \\\n+  template(jdk_internal_foreign_abi_VMStorage_signature,             \"Ljdk\/internal\/foreign\/abi\/VMStorage;\") \\\n+  template(jdk_internal_foreign_abi_VMStorage_array_signature,       \"[Ljdk\/internal\/foreign\/abi\/VMStorage;\") \\\n+  template(jdk_internal_foreign_abi_VMStorage_array_array_signature, \"[[Ljdk\/internal\/foreign\/abi\/VMStorage;\") \\\n+  template(jdk_internal_foreign_abi_CallConv,                        \"jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler$CallRegs\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -51,9 +52,0 @@\n-const ForeignGlobals& ForeignGlobals::instance() {\n-  static ForeignGlobals globals; \/\/ thread-safe lazy init-once (since C++11)\n-  return globals;\n-}\n-\n-const ABIDescriptor ForeignGlobals::parse_abi_descriptor(jobject jabi) {\n-  return instance().parse_abi_descriptor_impl(jabi);\n-}\n-\n@@ -61,39 +53,0 @@\n-  return instance().parse_call_regs_impl(jconv);\n-}\n-\n-VMReg ForeignGlobals::parse_vmstorage(oop storage) {\n-  return instance().parse_vmstorage_impl(storage);\n-}\n-\n-ForeignGlobals::ForeignGlobals() {\n-  JavaThread* current_thread = JavaThread::current();\n-  ResourceMark rm(current_thread);\n-\n-  \/\/ ABIDescriptor\n-  InstanceKlass* k_ABI = find_InstanceKlass(FOREIGN_ABI \"ABIDescriptor\", current_thread);\n-  const char* strVMSArrayArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n-  Symbol* symVMSArrayArray = SymbolTable::new_symbol(strVMSArrayArray);\n-  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArrayArray);\n-  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArrayArray);\n-  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArrayArray);\n-  ABI.stackAlignment_offset = field_offset(k_ABI, \"stackAlignment\", vmSymbols::int_signature());\n-  ABI.shadowSpace_offset = field_offset(k_ABI, \"shadowSpace\", vmSymbols::int_signature());\n-  const char* strVMS = \"L\" FOREIGN_ABI \"VMStorage;\";\n-  Symbol* symVMS = SymbolTable::new_symbol(strVMS);\n-  ABI.targetAddrStorage_offset = field_offset(k_ABI, \"targetAddrStorage\", symVMS);\n-  ABI.retBufAddrStorage_offset = field_offset(k_ABI, \"retBufAddrStorage\", symVMS);\n-\n-  \/\/ VMStorage\n-  InstanceKlass* k_VMS = find_InstanceKlass(FOREIGN_ABI \"VMStorage\", current_thread);\n-  VMS.index_offset = field_offset(k_VMS, \"index\", vmSymbols::int_signature());\n-  VMS.type_offset = field_offset(k_VMS, \"type\", vmSymbols::int_signature());\n-\n-  \/\/ CallRegs\n-  const char* strVMSArray = \"[L\" FOREIGN_ABI \"VMStorage;\";\n-  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray);\n-  InstanceKlass* k_CC = find_InstanceKlass(FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs\", current_thread);\n-  CallConvOffsets.arg_regs_offset = field_offset(k_CC, \"argRegs\", symVMSArray);\n-  CallConvOffsets.ret_regs_offset = field_offset(k_CC, \"retRegs\", symVMSArray);\n-}\n-\n-const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n@@ -101,3 +54,2 @@\n-  objArrayOop arg_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.arg_regs_offset));\n-  objArrayOop ret_regs_oop = oop_cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.ret_regs_offset));\n-\n+  objArrayOop arg_regs_oop = jdk_internal_foreign_abi_CallConv::argRegs(conv_oop);\n+  objArrayOop ret_regs_oop = jdk_internal_foreign_abi_CallConv::retRegs(conv_oop);\n@@ -122,3 +74,3 @@\n-VMReg ForeignGlobals::parse_vmstorage_impl(oop storage) const {\n-  jint index = storage->int_field(VMS.index_offset);\n-  jint type = storage->int_field(VMS.type_offset);\n+VMReg ForeignGlobals::parse_vmstorage(oop storage) {\n+  jint index = jdk_internal_foreign_abi_VMStorage::index(storage);\n+  jint type = jdk_internal_foreign_abi_VMStorage::type(storage);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":6,"deletions":54,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -50,24 +50,0 @@\n-  struct {\n-    int inputStorage_offset;\n-    int outputStorage_offset;\n-    int volatileStorage_offset;\n-    int stackAlignment_offset;\n-    int shadowSpace_offset;\n-    int targetAddrStorage_offset;\n-    int retBufAddrStorage_offset;\n-  } ABI;\n-\n-  struct {\n-    int index_offset;\n-    int type_offset;\n-  } VMS;\n-\n-  struct {\n-    int arg_regs_offset;\n-    int ret_regs_offset;\n-  } CallConvOffsets;\n-\n-  ForeignGlobals();\n-\n-  static const ForeignGlobals& instance();\n-\n@@ -75,1 +51,1 @@\n-  void loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) const;\n+  static void loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter);\n@@ -77,3 +53,0 @@\n-  const ABIDescriptor parse_abi_descriptor_impl(jobject jabi) const;\n-  const CallRegs parse_call_regs_impl(jobject jconv) const;\n-  VMReg parse_vmstorage_impl(oop storage) const;\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-void ForeignGlobals::loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) const {\n+void ForeignGlobals::loadArray(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) {\n@@ -39,1 +39,1 @@\n-    jint index = storage->int_field(VMS.index_offset);\n+    jint index = jdk_internal_foreign_abi_VMStorage::index(storage);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,0 +110,3 @@\n+#define METHOD_TYPE \"Ljava\/lang\/invoke\/MethodType;\"\n+#define ABI_DESC \"Ljdk\/internal\/foreign\/abi\/ABIDescriptor;\"\n+#define VM_STORAGE_ARR \"[Ljdk\/internal\/foreign\/abi\/VMStorage;\"\n@@ -112,1 +115,1 @@\n-  {CC \"makeInvoker\", CC \"(Ljava\/lang\/invoke\/MethodType;Ljdk\/internal\/invoke\/ABIDescriptorProxy;[Ljdk\/internal\/invoke\/VMStorageProxy;[Ljdk\/internal\/invoke\/VMStorageProxy;Z)J\", FN_PTR(NEP_makeInvoker)},\n+  {CC \"makeInvoker\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"Z)J\", FN_PTR(NEP_makeInvoker)},\n@@ -115,0 +118,4 @@\n+#undef METHOD_TYPE\n+#undef ABI_DESC\n+#undef VM_STORAGE_ARR\n+\n@@ -119,1 +126,1 @@\n-            \"register jdk.internal.invoke.NativeEntryPoint natives\");\n+            \"register jdk.internal.foreign.abi.NativeEntryPoint natives\");\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  { CC\"Java_jdk_internal_invoke_NativeEntryPoint_registerNatives\",      NULL, FN_PTR(JVM_RegisterNativeEntryPointMethods) },\n+  { CC\"Java_jdk_internal_foreign_abi_NativeEntryPoint_registerNatives\",      NULL, FN_PTR(JVM_RegisterNativeEntryPointMethods) },\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.internal.invoke.NativeEntryPoint;\n+import jdk.internal.foreign.abi.NativeEntryPoint;\n@@ -32,1 +32,0 @@\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.invoke.NativeEntryPoint;\n+import jdk.internal.foreign.abi.NativeEntryPoint;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.invoke.NativeEntryPoint;\n+import jdk.internal.foreign.abi.NativeEntryPoint;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,3 +27,6 @@\n-import jdk.internal.invoke.ABIDescriptorProxy;\n-\n-public class ABIDescriptor implements ABIDescriptorProxy {\n+\/**\n+ * Carrier class used to communicate with the VM\n+ *\n+ * It is particularly low-level since the VM will be accessing these fields directly\n+ *\/\n+public class ABIDescriptor {\n@@ -56,5 +59,0 @@\n-    @Override\n-    public int shadowSpaceBytes() {\n-        return shadowSpace;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+\/**\n+ * This class describes a 'native invoker', which is used as an appendix argument to linkToNative calls.\n+ *\/\n+public class NativeEntryPoint {\n+    static {\n+        registerNatives();\n+    }\n+\n+    private final MethodType methodType;\n+    private final long invoker; \/\/ read by VM\n+\n+    private static final Map<CacheKey, Long> INVOKER_CACHE = new ConcurrentHashMap<>();\n+    private record CacheKey(MethodType methodType, ABIDescriptor abi,\n+                            List<VMStorage> argMoves, List<VMStorage> retMoves,\n+                            boolean needsReturnBuffer) {}\n+\n+    private NativeEntryPoint(MethodType methodType, long invoker) {\n+        this.methodType = methodType;\n+        this.invoker = invoker;\n+    }\n+\n+    public static NativeEntryPoint make(ABIDescriptor abi,\n+                                        VMStorage[] argMoves, VMStorage[] returnMoves,\n+                                        MethodType methodType, boolean needsReturnBuffer) {\n+        if (returnMoves.length > 1 != needsReturnBuffer) {\n+            throw new IllegalArgumentException(\"Multiple register return, but needsReturnBuffer was false\");\n+        }\n+\n+        assert (methodType.parameterType(0) == long.class) : \"Address expected\";\n+        assert (!needsReturnBuffer || methodType.parameterType(1) == long.class) : \"return buffer address expected\";\n+\n+        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer);\n+        long invoker = INVOKER_CACHE.computeIfAbsent(key, k ->\n+            makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer));\n+\n+        return new NativeEntryPoint(methodType, invoker);\n+    }\n+\n+    private static native long makeInvoker(MethodType methodType, ABIDescriptor abi,\n+                                           VMStorage[] encArgMoves, VMStorage[] encRetMoves,\n+                                           boolean needsReturnBuffer);\n+\n+    public MethodType type() {\n+        return methodType;\n+    }\n+\n+    private static native void registerNatives();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.invoke.NativeEntryPoint;\n-import jdk.internal.invoke.VMStorageProxy;\n@@ -154,1 +152,1 @@\n-    private VMStorageProxy[] toStorageArray(Binding.Move[] moves) {\n+    private VMStorage[] toStorageArray(Binding.Move[] moves) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.invoke.VMStorageProxy;\n@@ -30,1 +29,1 @@\n-public class VMStorage implements VMStorageProxy {\n+public class VMStorage {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.invoke;\n-\n-public interface ABIDescriptorProxy {\n-    int shadowSpaceBytes();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/ABIDescriptorProxy.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.invoke;\n-\n-import java.lang.invoke.MethodType;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-\/**\n- * This class describes a 'native invoker', which is used as an appendix argument to linkToNative calls.\n- *\/\n-public class NativeEntryPoint {\n-    static {\n-        registerNatives();\n-    }\n-\n-    private final MethodType methodType;\n-    private final long invoker;\n-\n-    private static final Map<CacheKey, Long> INVOKER_CACHE = new ConcurrentHashMap<>();\n-    private record CacheKey(MethodType methodType, ABIDescriptorProxy abi,\n-                            List<VMStorageProxy> argMoves, List<VMStorageProxy> retMoves,\n-                            boolean needsReturnBuffer) {}\n-\n-    private NativeEntryPoint(MethodType methodType, long invoker) {\n-        this.methodType = methodType;\n-        this.invoker = invoker;\n-    }\n-\n-    public static NativeEntryPoint make(ABIDescriptorProxy abi,\n-                                        VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,\n-                                        MethodType methodType, boolean needsReturnBuffer) {\n-        if (returnMoves.length > 1 != needsReturnBuffer) {\n-            throw new IllegalArgumentException(\"Multiple register return, but needsReturnBuffer was false\");\n-        }\n-\n-        assert (methodType.parameterType(0) == long.class) : \"Address expected\";\n-        assert (!needsReturnBuffer || methodType.parameterType(1) == long.class) : \"return buffer address expected\";\n-\n-        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer);\n-        long invoker = INVOKER_CACHE.computeIfAbsent(key, k ->\n-            makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer));\n-\n-        return new NativeEntryPoint(methodType, invoker);\n-    }\n-\n-    private static native long makeInvoker(MethodType methodType, ABIDescriptorProxy abi,\n-                                           VMStorageProxy[] encArgMoves, VMStorageProxy[] encRetMoves,\n-                                           boolean needsReturnBuffer);\n-\n-    public MethodType type() {\n-        return methodType;\n-    }\n-\n-    private static native void registerNatives();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/NativeEntryPoint.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.invoke;\n-\n-public interface VMStorageProxy {\n-    int type();\n-    int index();\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/VMStorageProxy.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"}]}