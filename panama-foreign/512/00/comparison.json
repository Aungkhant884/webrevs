{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -824,0 +824,12 @@\n+                @Override\n+                public Object acquireScope(Buffer targetBuffer, boolean async) {\n+                    var targetScope = targetBuffer.scope();\n+                    if (targetScope == null || targetScope.isImplicit()) {\n+                        return null;\n+                    }\n+                    if (async && targetScope.ownerThread() != null) {\n+                        throw new IllegalStateException(\"Confined scope not supported\");\n+                    }\n+                    return targetScope.acquire();\n+                }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,8 @@\n+    \/**\n+     * Used by I\/O operations to make a buffer's resource scope non-closeable\n+     * (for the duration of the I\/O operation) by acquiring a new resource\n+     * scope handle. Null is returned if the buffer has no scope, or\n+     * acquiring is not required to guarantee safety.\n+     *\/\n+    Object acquireScope(Buffer targetBuffer, boolean async);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+\n@@ -104,0 +105,4 @@\n+        boolean isImplicit();\n+\n+        Object acquire();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-\n+import java.util.Objects;\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -50,1 +52,8 @@\n-        return write(fd, src, position, false, -1, nd);\n+        return write(fd, src, position, false, false, -1, nd);\n+    }\n+\n+    static int write(FileDescriptor fd, ByteBuffer src, long position,\n+                     boolean async, NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return write(fd, src, position, false, async, -1, nd);\n@@ -56,0 +65,8 @@\n+    {\n+        return write(fd, src, position, directIO, false, alignment, nd);\n+    }\n+\n+    static int write(FileDescriptor fd, ByteBuffer src, long position,\n+                     boolean directIO, boolean async, int alignment,\n+                     NativeDispatcher nd)\n+        throws IOException\n@@ -58,1 +75,1 @@\n-            return writeFromNativeBuffer(fd, src, position, directIO, alignment, nd);\n+            return writeFromNativeBuffer(fd, src, position, directIO, async, alignment, nd);\n@@ -79,1 +96,1 @@\n-            int n = writeFromNativeBuffer(fd, bb, position, directIO, alignment, nd);\n+            int n = writeFromNativeBuffer(fd, bb, position, directIO, async, alignment, nd);\n@@ -92,1 +109,2 @@\n-                                             int alignment, NativeDispatcher nd)\n+                                             boolean async, int alignment,\n+                                             NativeDispatcher nd)\n@@ -108,6 +126,9 @@\n-        if (position != -1) {\n-            written = nd.pwrite(fd,\n-                                ((DirectBuffer)bb).address() + pos,\n-                                rem, position);\n-        } else {\n-            written = nd.write(fd, ((DirectBuffer)bb).address() + pos, rem);\n+        var handle = acquireScope(bb, async);\n+        try {\n+            if (position != -1) {\n+                written = nd.pwrite(fd, bufferAddress(bb) + pos, rem, position);\n+            } else {\n+                written = nd.write(fd, bufferAddress(bb) + pos, rem);\n+            }\n+        } finally {\n+            releaseScope(handle);\n@@ -120,1 +141,2 @@\n-    static long write(FileDescriptor fd, ByteBuffer[] bufs, NativeDispatcher nd)\n+    static long write(FileDescriptor fd, ByteBuffer[] bufs, boolean async,\n+                      NativeDispatcher nd)\n@@ -123,1 +145,1 @@\n-        return write(fd, bufs, 0, bufs.length, false, -1, nd);\n+        return write(fd, bufs, 0, bufs.length, false, async, -1, nd);\n@@ -130,1 +152,1 @@\n-        return write(fd, bufs, offset, length, false, -1, nd);\n+        return write(fd, bufs, offset, length, false, false, -1, nd);\n@@ -134,1 +156,9 @@\n-                      boolean directIO, int alignment, NativeDispatcher nd)\n+                      boolean direct, int alignment, NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return write(fd, bufs, offset, length, direct, false, alignment, nd);\n+    }\n+\n+    static long write(FileDescriptor fd, ByteBuffer[] bufs, int offset, int length,\n+                      boolean directIO, boolean async,\n+                      int alignment, NativeDispatcher nd)\n@@ -141,0 +171,1 @@\n+        Runnable handleReleasers = null;\n@@ -142,1 +173,0 @@\n-\n@@ -148,0 +178,4 @@\n+                var h = acquireScope(buf, async);\n+                if (h != null) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                }\n@@ -173,1 +207,1 @@\n-                    vec.putBase(iov_len, ((DirectBuffer)buf).address() + pos);\n+                    vec.putBase(iov_len, bufferAddress(buf) + pos);\n@@ -206,0 +240,1 @@\n+            releaseScopes(handleReleasers);\n@@ -223,1 +258,8 @@\n-        return read(fd, dst, position, false, -1, nd);\n+        return read(fd, dst, position, false, false, -1, nd);\n+    }\n+\n+    static int read(FileDescriptor fd, ByteBuffer dst, long position,\n+                    boolean async, NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return read(fd, dst, position, false, async, -1, nd);\n@@ -229,0 +271,8 @@\n+    {\n+        return read(fd, dst, position, directIO, false, alignment, nd);\n+    }\n+\n+    static int read(FileDescriptor fd, ByteBuffer dst, long position,\n+                    boolean directIO, boolean async,\n+                    int alignment, NativeDispatcher nd)\n+        throws IOException\n@@ -233,1 +283,1 @@\n-            return readIntoNativeBuffer(fd, dst, position, directIO, alignment, nd);\n+            return readIntoNativeBuffer(fd, dst, position, directIO, async, alignment, nd);\n@@ -245,1 +295,1 @@\n-            int n = readIntoNativeBuffer(fd, bb, position, directIO, alignment,nd);\n+            int n = readIntoNativeBuffer(fd, bb, position, directIO, async, alignment, nd);\n@@ -257,1 +307,2 @@\n-                                            int alignment, NativeDispatcher nd)\n+                                            boolean async, int alignment,\n+                                            NativeDispatcher nd)\n@@ -273,4 +324,9 @@\n-        if (position != -1) {\n-            n = nd.pread(fd, ((DirectBuffer)bb).address() + pos, rem, position);\n-        } else {\n-            n = nd.read(fd, ((DirectBuffer)bb).address() + pos, rem);\n+        var handle = acquireScope(bb, async);\n+        try {\n+            if (position != -1) {\n+                n = nd.pread(fd, bufferAddress(bb) + pos, rem, position);\n+            } else {\n+                n = nd.read(fd, bufferAddress(bb) + pos, rem);\n+            }\n+        } finally {\n+            releaseScope(handle);\n@@ -286,1 +342,8 @@\n-        return read(fd, bufs, 0, bufs.length, false, -1, nd);\n+        return read(fd, bufs, 0, bufs.length, false, false, -1, nd);\n+    }\n+\n+    static long read(FileDescriptor fd, ByteBuffer[] bufs, boolean async,\n+                     NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return read(fd, bufs, 0, bufs.length, false, async, -1, nd);\n@@ -293,1 +356,1 @@\n-        return read(fd, bufs, offset, length, false, -1, nd);\n+        return read(fd, bufs, offset, length, false, false, -1, nd);\n@@ -298,0 +361,10 @@\n+\n+        throws IOException\n+    {\n+        return read(fd, bufs, offset, length, directIO, false, alignment, nd);\n+    }\n+\n+    static long read(FileDescriptor fd, ByteBuffer[] bufs, int offset, int length,\n+                     boolean directIO, boolean async,\n+                     int alignment, NativeDispatcher nd)\n+\n@@ -304,0 +377,1 @@\n+        Runnable handleReleasers = null;\n@@ -305,1 +379,0 @@\n-\n@@ -313,0 +386,4 @@\n+                var h = acquireScope(buf, async);\n+                if (h != null) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                }\n@@ -337,1 +414,1 @@\n-                    vec.putBase(iov_len, ((DirectBuffer)buf).address() + pos);\n+                    vec.putBase(iov_len, bufferAddress(buf) + pos);\n@@ -374,0 +451,1 @@\n+            releaseScopes(handleReleasers);\n@@ -387,0 +465,77 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n+    static Object acquireScope(ByteBuffer bb, boolean async) {\n+        return NIO_ACCESS.acquireScope(bb, async);\n+    }\n+\n+    private static void releaseScope(Object handle) {\n+        if (handle == null)\n+            return;\n+        try {\n+            ((AutoCloseable)handle).close();\n+        } catch (Exception e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    static Runnable acquireScopes(ByteBuffer[] buffers) {\n+        return acquireScopes(null, buffers);\n+    }\n+\n+    static Runnable acquireScopes(ByteBuffer buf, ByteBuffer[] buffers) {\n+        if (buffers == null) {\n+            assert buf != null;\n+            return IOUtil.Releaser.ofNullable(IOUtil.acquireScope(buf, true));\n+        } else {\n+            assert buf == null;\n+            Runnable handleReleasers = null;\n+            for (var b : buffers) {\n+                var h = IOUtil.acquireScope(b, true);\n+                if (h != null) {\n+                    handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(h), handleReleasers);\n+                }\n+            }\n+            return handleReleasers;\n+        }\n+    }\n+\n+    static void releaseScopes(Runnable releasers) {\n+        if (releasers != null)\n+            releasers.run();\n+    }\n+\n+    static record LinkedRunnable(Runnable node, Runnable next)\n+        implements Runnable\n+    {\n+        LinkedRunnable {\n+            Objects.requireNonNull(node);\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                node.run();\n+            } finally {\n+                if (next != null)\n+                    next.run();\n+            }\n+        }\n+        static LinkedRunnable of(Runnable first, Runnable second) {\n+            return new LinkedRunnable(first, second);\n+        }\n+    }\n+\n+    static record Releaser(Object handle) implements Runnable {\n+        Releaser { Objects.requireNonNull(handle) ; }\n+        @Override public void run() { releaseScope(handle); }\n+        static Runnable of(Object handle) { return new Releaser(handle); }\n+        static Runnable ofNullable(Object handle) {\n+            if (handle == null)\n+                return () -> { };\n+            return new Releaser(handle);\n+        }\n+    }\n+\n+    private static long bufferAddress(ByteBuffer buf) {\n+        return NIO_ACCESS.getBufferAddress(buf);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":185,"deletions":30,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,1 @@\n+    private Runnable readScopeHandleReleasers;\n@@ -89,0 +90,1 @@\n+    private Runnable writeScopeHandleReleasers;\n@@ -395,1 +397,1 @@\n-                n = (int)IOUtil.read(fd, readBuffers, nd);\n+                n = (int)IOUtil.read(fd, readBuffers, true, nd);\n@@ -397,1 +399,1 @@\n-                n = IOUtil.read(fd, readBuffer, -1, nd);\n+                n = IOUtil.read(fd, readBuffer, -1, true, nd);\n@@ -412,0 +414,1 @@\n+            IOUtil.releaseScopes(readScopeHandleReleasers);\n@@ -519,1 +522,1 @@\n-                    n = (int)IOUtil.read(fd, dsts, nd);\n+                    n = (int)IOUtil.read(fd, dsts, true, nd);\n@@ -521,1 +524,1 @@\n-                    n = IOUtil.read(fd, dst, -1, nd);\n+                    n = IOUtil.read(fd, dst, -1, true, nd);\n@@ -529,0 +532,1 @@\n+                    this.readScopeHandleReleasers = IOUtil.acquireScopes(dst, dsts);\n@@ -595,1 +599,1 @@\n-                n = (int)IOUtil.write(fd, writeBuffers, nd);\n+                n = (int)IOUtil.write(fd, writeBuffers, true, nd);\n@@ -597,1 +601,1 @@\n-                n = IOUtil.write(fd, writeBuffer, -1, nd);\n+                n = IOUtil.write(fd, writeBuffer, -1, true, nd);\n@@ -612,0 +616,1 @@\n+            IOUtil.releaseScopes(writeScopeHandleReleasers);\n@@ -705,1 +710,1 @@\n-                    n = (int)IOUtil.write(fd, srcs, nd);\n+                    n = (int)IOUtil.write(fd, srcs, true, nd);\n@@ -707,1 +712,1 @@\n-                    n = IOUtil.write(fd, src, -1, nd);\n+                    n = IOUtil.write(fd, src, -1, true, nd);\n@@ -715,0 +720,1 @@\n+                    this.writeScopeHandleReleasers = IOUtil.acquireScopes(src, srcs);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixAsynchronousSocketChannelImpl.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -403,0 +403,1 @@\n+        private Runnable scopeHandleReleasers;\n@@ -419,0 +420,1 @@\n+            scopeHandleReleasers = IOUtil.acquireScopes(bufs);\n@@ -493,0 +495,1 @@\n+            IOUtil.releaseScopes(scopeHandleReleasers);\n@@ -674,0 +677,1 @@\n+        private Runnable scopeHandleReleasers;\n@@ -690,0 +694,1 @@\n+            scopeHandleReleasers = IOUtil.acquireScopes(bufs);\n@@ -757,0 +762,1 @@\n+            IOUtil.releaseScopes(scopeHandleReleasers);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousSocketChannelImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-     * {@link java.nio.channels.SocketChannel#write(ByteBuffer)}.\n+     * {@link java.nio.channels.SocketChannel#write(ByteBuffer)}.  TODO HERE Fix this comment\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.lang.ref.Cleaner;\n@@ -66,0 +67,1 @@\n+import java.util.Arrays;\n@@ -623,2 +625,2 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testIOOnSharedSegmentBuffer() throws IOException {\n+    @Test(dataProvider = \"allScopes\")\n+    public void testIOOnSegmentBuffer(Supplier<ResourceScope> scopeSupplier) throws IOException {\n@@ -627,2 +629,3 @@\n-        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE) ;\n-             ResourceScope scope = ResourceScope.newSharedScope()) {\n+        ResourceScope scope;\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE) ;\n+             ResourceScope scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n@@ -634,2 +637,5 @@\n-            segment.scope().close();\n-            channel.write(bb);\n+            assertEquals(channel.write(bb), 10);\n+            segment.fill((byte)0x00);\n+            assertEquals(bb.clear(), ByteBuffer.wrap(new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}));\n+            assertEquals(channel.position(0).read(bb.clear()), 10);\n+            assertEquals(bb.flip(), ByteBuffer.wrap(new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n@@ -639,14 +645,1 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testIOOnClosedConfinedSegmentBuffer() throws IOException {\n-        File tmp = File.createTempFile(\"tmp\", \"txt\");\n-        tmp.deleteOnExit();\n-        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n-            MemorySegment segment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n-            for (int i = 0; i < 10; i++) {\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n-            }\n-            ByteBuffer bb = segment.asByteBuffer();\n-            segment.scope().close();\n-            channel.write(bb);\n-        }\n-    }\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n@@ -654,2 +647,2 @@\n-    @Test\n-    public void testIOOnConfinedSegment() throws IOException {\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testIOOnClosedSegmentBuffer(Supplier<ResourceScope> scopeSupplier) throws IOException {\n@@ -658,2 +651,2 @@\n-        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n-            MemorySegment segment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, scopeSupplier.get());\n@@ -664,1 +657,7 @@\n-            channel.write(bb);\n+            segment.scope().close();\n+            assertThrows(ISE, () -> channel.read(bb));\n+            assertThrows(ISE, () -> channel.read(new ByteBuffer[] {bb}));\n+            assertThrows(ISE, () -> channel.read(new ByteBuffer[] {bb}, 0, 1));\n+            assertThrows(ISE, () -> channel.write(bb));\n+            assertThrows(ISE, () -> channel.write(new ByteBuffer[] {bb}));\n+            assertThrows(ISE, () -> channel.write(new ByteBuffer[] {bb}, 0 ,1));\n@@ -704,0 +703,31 @@\n+    @DataProvider(name = \"closeableScopes\")\n+    public static Object[][] closeableScopes() {\n+        return new Object[][] {\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope()   },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope() },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope(Cleaner.create())   },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) }\n+        };\n+    }\n+\n+    @DataProvider(name = \"implicitScopes\")\n+    public static Object[][] implicitScopes() {\n+        return new Object[][] {\n+                { (Supplier<ResourceScope>) ResourceScope::newImplicitScope },\n+                { (Supplier<ResourceScope>) ResourceScope::globalScope      },\n+        };\n+    }\n+\n+    @DataProvider(name = \"allScopes\")\n+    public static Object[][] allScopes() {\n+        return Stream.of(implicitScopes(), closeableScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    static ResourceScope closeableScopeOrNull(ResourceScope scope) {\n+        if (scope.isImplicit())\n+            return null;\n+        return scope;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":55,"deletions":25,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.ref.Cleaner;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.test.lib.RandomFactory;\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Not a test, but infra for channel tests.\n+ *\/\n+public class AbstractChannelsTest {\n+\n+    static final Class<IOException> IOE = IOException.class;\n+    static final Class<ExecutionException> EE = ExecutionException.class;\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n+\n+    @FunctionalInterface\n+    interface ThrowingConsumer<T, X extends Throwable> {\n+        void accept(T action) throws X;\n+    }\n+\n+    static ResourceScope closeableScopeOrNull(ResourceScope scope) {\n+        if (scope.isImplicit())\n+            return null;\n+        return scope;\n+    }\n+\n+    static long remaining(ByteBuffer[] buffers) {\n+        return Arrays.stream(buffers).mapToLong(ByteBuffer::remaining).sum();\n+    }\n+\n+    static ByteBuffer[] flip(ByteBuffer[] buffers) {\n+        Arrays.stream(buffers).forEach(ByteBuffer::flip);\n+        return buffers;\n+    }\n+\n+    static ByteBuffer[] clear(ByteBuffer[] buffers) {\n+        Arrays.stream(buffers).forEach(ByteBuffer::clear);\n+        return buffers;\n+    }\n+\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    static ByteBuffer segmentBufferOfSize(ResourceScope scope, int size) {\n+        var segment = MemorySegment.allocateNative(size, 1, scope);\n+        for (int i = 0; i < size; i++) {\n+            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+        }\n+        return segment.asByteBuffer();\n+    }\n+\n+    static ByteBuffer[] segmentBuffersOfSize(int len, ResourceScope scope, int size) {\n+        ByteBuffer[] bufs = new ByteBuffer[len];\n+        for (int i = 0; i < len; i++)\n+            bufs[i] = segmentBufferOfSize(scope, size);\n+        return bufs;\n+    }\n+\n+    \/**\n+     * Returns an array of mixed source byte buffers; both heap and direct,\n+     * where heap can be from the global scope or scope-less, and direct are\n+     * associated with the given scope.\n+     *\/\n+    static ByteBuffer[] mixedBuffersOfSize(int len, ResourceScope scope, int size) {\n+        ByteBuffer[] bufs;\n+        boolean atLeastOneScopeBuffer = false;\n+        do {\n+            bufs = new ByteBuffer[len];\n+            for (int i = 0; i < len; i++) {\n+                bufs[i] = switch (RANDOM.nextInt(3)) {\n+                    case 0 -> { byte[] b = new byte[size];\n+                                RANDOM.nextBytes(b);\n+                                yield ByteBuffer.wrap(b); }\n+                    case 1 -> { byte[] b = new byte[size];\n+                                RANDOM.nextBytes(b);\n+                                yield MemorySegment.ofArray(b).asByteBuffer(); }\n+                    case 2 -> { atLeastOneScopeBuffer = true;\n+                                yield segmentBufferOfSize(scope, size); }\n+                    default -> throw new AssertionError(\"cannot happen\");\n+                };\n+            }\n+        } while (!atLeastOneScopeBuffer);\n+        return bufs;\n+    }\n+\n+    static void assertMessage(Exception ex, String msg) {\n+        assertTrue(ex.getMessage().contains(msg), \"Expected [%s], in: [%s]\".formatted(msg, ex.getMessage()));\n+    }\n+\n+    static void assertCauses(Throwable ex, Class<? extends Exception>... exceptions) {\n+        for (var expectedClass : exceptions) {\n+            ex = ex.getCause();\n+            assertTrue(expectedClass.isInstance(ex), \"Expected %s, got: %s\".formatted(expectedClass, ex));\n+        }\n+    }\n+\n+    @DataProvider(name = \"confinedScopes\")\n+    public static Object[][] confinedScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_CONFINED          },\n+                { ScopeSupplier.NEW_CONFINED_EXPLICIT },\n+        };\n+    }\n+\n+    @DataProvider(name = \"sharedScopes\")\n+    public static Object[][] sharedScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_SHARED          },\n+                { ScopeSupplier.NEW_SHARED_EXPLICIT },\n+        };\n+    }\n+\n+    @DataProvider(name = \"closeableScopes\")\n+    public static Object[][] closeableScopes() {\n+        return Stream.of(sharedScopes(), confinedScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"implicitScopes\")\n+    public static Object[][] implicitScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_IMPLICIT },\n+                { ScopeSupplier.GLOBAL       },\n+        };\n+    }\n+\n+    @DataProvider(name = \"sharedAndImplicitScopes\")\n+    public static Object[][] sharedAndImplicitScopes() {\n+        return Stream.of(sharedScopes(), implicitScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"allScopes\")\n+    public static Object[][] allScopes() {\n+        return Stream.of(implicitScopes(), closeableScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"sharedScopesAndTimeouts\")\n+    public static Object[][] sharedScopesAndTimeouts() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_SHARED          ,  0 },\n+                { ScopeSupplier.NEW_SHARED_EXPLICIT ,  0 },\n+                { ScopeSupplier.NEW_SHARED          , 30 },\n+                { ScopeSupplier.NEW_SHARED_EXPLICIT , 30 },\n+        };\n+    }\n+\n+    static class ScopeSupplier implements Supplier<ResourceScope> {\n+\n+        static final Supplier<ResourceScope> NEW_CONFINED =\n+                new ScopeSupplier(() -> ResourceScope.newConfinedScope(), \"newConfinedScope()\");\n+        static final Supplier<ResourceScope> NEW_CONFINED_EXPLICIT =\n+                new ScopeSupplier(() -> ResourceScope.newConfinedScope(Cleaner.create()), \"newConfinedScope(Cleaner)\");\n+        static final Supplier<ResourceScope> NEW_SHARED =\n+                new ScopeSupplier(() -> ResourceScope.newSharedScope(), \"newSharedScope()\");\n+        static final Supplier<ResourceScope> NEW_SHARED_EXPLICIT =\n+                new ScopeSupplier(() -> ResourceScope.newSharedScope(Cleaner.create()), \"newSharedScope(Cleaner)\");\n+        static final Supplier<ResourceScope> NEW_IMPLICIT =\n+                new ScopeSupplier(() -> ResourceScope.newImplicitScope(), \"newImplicitScope()\");\n+        static final Supplier<ResourceScope> GLOBAL =\n+                new ScopeSupplier(() -> ResourceScope.globalScope(), \"globalScope()\");\n+\n+        private final Supplier<ResourceScope> supplier;\n+        private final String str;\n+        private ScopeSupplier(Supplier<ResourceScope> supplier, String str) {\n+            this.supplier = supplier;\n+            this.str = str;\n+        }\n+        @Override public String toString() { return str; }\n+        @Override public ResourceScope get() { return supplier.get(); }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.nio.ch\n+ *          jdk.incubator.foreign\/jdk.internal.foreign\n+ * @key randomness\n+ * @run testng\/othervm -Dforeign.restricted=permit TestAsyncSocketChannels\n+ * @run testng\/othervm -Dforeign.restricted=permit -Dsun.nio.ch.disableSynchronousRead=true TestAsyncSocketChannels\n+ * @run testng\/othervm -Dforeign.restricted=permit -Dsun.nio.ch.disableSynchronousRead=false TestAsyncSocketChannels\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousServerSocketChannel;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.CompletionHandler;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.*;\n+import static java.lang.System.out;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Tests consisting of buffer views with asynchronous NIO network channels.\n+ *\/\n+public class TestAsyncSocketChannels extends AbstractChannelsTest {\n+\n+    static final Class<IOException> IOE = IOException.class;\n+    static final Class<ExecutionException> EE = ExecutionException.class;\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n+\n+    \/** Tests that confined scopes are not supported. *\/\n+    @Test(dataProvider = \"confinedScopes\")\n+    public void testWithConfined(Supplier<ResourceScope> scopeSupplier)\n+        throws Throwable\n+    {\n+        try (var channel = AsynchronousSocketChannel.open();\n+             var server = AsynchronousServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel);\n+             var scope = scopeSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, scope);\n+            var bb = segment.asByteBuffer();\n+            var bba = new ByteBuffer[] { bb };\n+            List<ThrowingConsumer<TestHandler,?>> ioOps = List.of(\n+                    handler -> handler.propagateHandlerFromFuture(channel.write(bb)),\n+                    handler -> handler.propagateHandlerFromFuture(channel.read(bb)),\n+                    handler -> channel.write(bb, null, handler),\n+                    handler -> channel.read( bb, null, handler),\n+                    handler -> channel.write(bb , 0L, SECONDS, null, handler),\n+                    handler -> channel.read( bb,  0L, SECONDS, null, handler),\n+                    handler -> channel.write(bba, 0, bba.length, 0L, SECONDS, null, handler),\n+                    handler -> channel.read( bba, 0, bba.length, 0L, SECONDS, null, handler)\n+            );\n+            for (var ioOp : ioOps) {\n+                out.println(\"testAsyncWithConfined - op\");\n+                var handler = new TestHandler();\n+                ioOp.accept(handler);\n+                handler.await()\n+                        .assertFailedWith(ISE)\n+                        .assertExceptionMessage(\"Confined scope not supported\");\n+            }\n+        }\n+    }\n+\n+    \/** Tests that I\/O with a closed scope throws a suitable exception. *\/\n+    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n+    public void testIOWithClosedSharedScope(Supplier<ResourceScope> scopeSupplier, int timeout)\n+        throws Exception\n+    {\n+        try (var channel = AsynchronousSocketChannel.open();\n+             var server = AsynchronousServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel)) {\n+            ResourceScope scope = scopeSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(scope, 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, scope, 32);\n+            scope.close();\n+            {\n+                assertCauses(expectThrows(EE, () -> connectedChannel.read(bb).get()), IOE, ISE);\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.read(bb, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.read(bb, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Long>();\n+                connectedChannel.read(buffers, 0, buffers.length, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                assertCauses(expectThrows(EE, () -> connectedChannel.write(bb).get()), IOE, ISE);\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.write(bb, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.write(bb, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Long>();\n+                connectedChannel.write(buffers, 0, buffers.length, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+        }\n+    }\n+\n+    \/** Tests basic I\/O operations work with views over implicit and shared scopes. *\/\n+    @Test(dataProvider = \"sharedAndImplicitScopes\")\n+    public void testBasicIOWithSupportedScope(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        ResourceScope scope;\n+        try (var asc1 = AsynchronousSocketChannel.open();\n+             var assc = AsynchronousServerSocketChannel.open();\n+             var asc2 = connectChannels(assc, asc1);\n+             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, scope);\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, scope);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+            }\n+            {   \/\/ Future variants\n+                ByteBuffer bb1 = segment1.asByteBuffer();\n+                ByteBuffer bb2 = segment2.asByteBuffer();\n+                assertEquals((int)asc1.write(bb1).get(), 10);\n+                assertEquals((int)asc2.read(bb2).get(), 10);\n+                assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+            }\n+            {   \/\/ CompletionHandler variants\n+                ByteBuffer bb1 = segment1.asByteBuffer();\n+                ByteBuffer bb2 = segment2.asByteBuffer();\n+                var writeHandler = new TestHandler();\n+                asc1.write(new ByteBuffer[]{bb1}, 0, 1, 30L, SECONDS, null, writeHandler);\n+                writeHandler.await().assertCompleteWith(10L);\n+                var readHandler = new TestHandler();\n+                asc2.read(new ByteBuffer[]{bb2}, 0, 1, 30L, SECONDS, null, readHandler);\n+                readHandler.await().assertCompleteWith(10L);\n+                assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+            }\n+            {   \/\/ Gathering\/Scattering variants\n+                var writeBuffers = mixedBuffersOfSize(16, scope, 32);\n+                var readBuffers = mixedBuffersOfSize(16, scope, 32);\n+                long expectedCount = remaining(writeBuffers);\n+                var writeHandler = new TestHandler();\n+                asc1.write(writeBuffers, 0, 16, 30L, SECONDS, null, writeHandler);\n+                writeHandler.await().assertCompleteWith(expectedCount);\n+                var readHandler = new TestHandler();\n+                asc2.read(readBuffers, 0, 16, 30L, SECONDS, null, readHandler);\n+                readHandler.await().assertCompleteWith(expectedCount);\n+                assertEquals(flip(readBuffers), clear(writeBuffers));\n+            }\n+        }\n+    }\n+\n+    \/** Tests that a scope is not closeable when there is an outstanding read operation. *\/\n+    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n+    public void testCloseWithOutstandingRead(Supplier<ResourceScope> scopeSupplier, int timeout)\n+        throws Throwable\n+    {\n+        try (var asc1 = AsynchronousSocketChannel.open();\n+             var assc = AsynchronousServerSocketChannel.open();\n+             var asc2 = connectChannels(assc, asc1);\n+             var scope = scopeSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, scope);\n+            var bb = segment.asByteBuffer();\n+            var bba = new ByteBuffer[] { bb };\n+            List<ThrowingConsumer<TestHandler,?>> readOps = List.of(\n+                    handler -> handler.propagateHandlerFromFuture(asc1.read(bb)),\n+                    handler -> asc1.read(bb, null, handler),\n+                    handler -> asc1.read(bb,  timeout, SECONDS, null, handler),\n+                    handler -> asc1.read(bba, 0, bba.length, timeout, SECONDS, null, handler)\n+            );\n+            for (var ioOp : readOps) {\n+                out.println(\"testCloseWithOutstandingRead - op\");\n+                var handler = new TestHandler<Long>();\n+                ioOp.accept(handler);\n+                assertFalse(handler.isDone());\n+                assertTrue(scope.isAlive());\n+                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+\n+                \/\/ write to allow the blocking read complete, which will\n+                \/\/ in turn unlock the scope and allow it to be closed.\n+                asc2.write(ByteBuffer.wrap(new byte[] { 0x01 })).get();\n+                handler.await().assertCompleteWith(1L);\n+                assertTrue(scope.isAlive());\n+            }\n+        }\n+    }\n+\n+    \/** Tests that a scope is not closeable when there is an outstanding write operation. *\/\n+    \/\/ Note: limited scenarios are checked, given the 5 sec sleep!\n+    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n+    public void testCloseWithOutstandingWrite(Supplier<ResourceScope> scopeSupplier, int timeout)\n+         throws Throwable\n+    {\n+        try (var asc1 = AsynchronousSocketChannel.open();\n+             var assc = AsynchronousServerSocketChannel.open();\n+             var asc2 = connectChannels(assc, asc1);\n+             var scope = scopeSupplier.get()) {\n+\n+            \/\/ number of bytes written\n+            final AtomicLong bytesWritten = new AtomicLong(0);\n+            \/\/ set to true to signal that no more buffers should be written\n+            final AtomicBoolean continueWriting = new AtomicBoolean(true);\n+            final AtomicInteger outstandingWriteOps = new AtomicInteger(0);\n+\n+            \/\/ write until socket buffer is full so as to create the conditions\n+            \/\/ for when a write does not complete immediately\n+            var bba = segmentBuffersOfSize(32, scope, 128);\n+            TestHandler<Long> handler;\n+            outstandingWriteOps.getAndIncrement();\n+            asc1.write(bba, 0, bba.length, timeout, SECONDS, null,\n+                    (handler = new TestHandler<>() {\n+                        public void completed(Long result, Void att) {\n+                            super.completed(result, att);\n+                            bytesWritten.addAndGet(result);\n+                            if (continueWriting.get()) {\n+                                var bba = segmentBuffersOfSize(32, scope, 128);\n+                                outstandingWriteOps.getAndIncrement();\n+                                asc1.write(bba, 0, bba.length, timeout, SECONDS, null, this);\n+                            }\n+                            outstandingWriteOps.getAndDecrement();\n+                        }\n+                    }));\n+            \/\/ give time for socket buffer to fill up.\n+            Thread.sleep(5*1000);\n+\n+            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+            assertTrue(scope.isAlive());\n+\n+            \/\/ signal handler to stop further writing\n+            continueWriting.set(false);\n+\n+            \/\/ read to allow the outstanding write complete, which will\n+            \/\/ in turn unlock the scope and allow it to be closed.\n+            readNBytes(asc2, bytesWritten.get());\n+            assertTrue(scope.isAlive());\n+            out.println(\"outstanding writes: \" + outstandingWriteOps.get());\n+            while (outstandingWriteOps.get() > 0 )  {\n+                out.println(\"spinning\");\n+                Thread.onSpinWait();\n+            }\n+            handler.await();\n+        }\n+    }\n+\n+    \/** Completion handler that exposes conveniences to assert results. *\/\n+    static class TestHandler<V extends Number> implements CompletionHandler<V, Void> {\n+        volatile V result;\n+        volatile Throwable throwable;\n+        final CountDownLatch latch = new CountDownLatch(1);\n+\n+        \/** Starts a thread that complete the handled with the Future result. *\/\n+        TestHandler propagateHandlerFromFuture(Future<Integer> future) {\n+            Runnable runnable = () -> {\n+                try {\n+                    this.completed((V)future.get(), null);\n+                } catch (Throwable t) {\n+                    \/\/ assert and unwrap exception added by Future\n+                    assertTrue(ExecutionException.class.isInstance(t));\n+                    t = t.getCause();\n+                    assertTrue(IOException.class.isInstance(t));\n+                    t = t.getCause();\n+                    this.failed(t, null);\n+                }\n+            };\n+            Thread t = new Thread(runnable);\n+            t.start();\n+            return this;\n+        }\n+\n+        @Override\n+        public void completed(V result, Void att) {\n+            assert result.longValue() >= 0;\n+            this.result = result;\n+            latch.countDown();\n+        }\n+        @Override\n+        public void failed(Throwable exc, Void att){\n+            this.throwable = exc;\n+            latch.countDown();\n+        }\n+\n+        TestHandler await() throws InterruptedException{\n+            latch.await();\n+            return this;\n+        }\n+\n+        TestHandler assertCompleteWith(V value) {\n+            assertEquals(result.longValue(), value.longValue());\n+            assertEquals(throwable, null);\n+            return this;\n+        }\n+\n+        TestHandler assertFailedWith(Class<? extends Exception> expectedException) {\n+            assertTrue(expectedException.isInstance(throwable),\n+                       \"Expected type:%s, got:%s\".formatted(expectedException, throwable) );\n+            assertEquals(result, null, \"Unexpected result: \" + result);\n+            return this;\n+        }\n+\n+        TestHandler assertExceptionMessage(String expectedMessage) {\n+            assertEquals(throwable.getMessage(), expectedMessage);\n+            return this;\n+        }\n+\n+        boolean isDone() {\n+            return latch.getCount() == 0;\n+        }\n+    }\n+\n+    static AsynchronousSocketChannel connectChannels(AsynchronousServerSocketChannel assc,\n+                                                     AsynchronousSocketChannel asc)\n+        throws Exception\n+    {\n+        assc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        asc.connect(assc.getLocalAddress()).get();\n+        return assc.accept().get();\n+    }\n+\n+    static void readNBytes(AsynchronousSocketChannel channel, long len)\n+        throws Exception\n+    {\n+        var buf = ByteBuffer.allocateDirect(4096);\n+        long total = 0L;\n+        do {\n+            int n = channel.read(buf).get();\n+            assertTrue(n > 0, \"got:\" + n);\n+            buf.clear();\n+            total += n;\n+        } while (total < len);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.nio.ch\n+ *          jdk.incubator.foreign\/jdk.internal.foreign\n+ * @key randomness\n+ * @run testng\/othervm -Dforeign.restricted=permit TestSocketChannels\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Tests consisting of buffer views with synchronous NIO network channels.\n+ *\/\n+public class TestSocketChannels extends AbstractChannelsTest {\n+\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n+\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testBasicIOWithClosedSegment(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        try (var channel = SocketChannel.open();\n+             var server = ServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel)) {\n+            ResourceScope scope = scopeSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(scope, 16);\n+            scope.close();\n+            assertMessage(expectThrows(ISE, () -> channel.read(bb)),                           \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(new ByteBuffer[] {bb})),        \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(new ByteBuffer[] {bb}, 0, 1)),  \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(bb)),                          \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(new ByteBuffer[] {bb})),       \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(new ByteBuffer[] {bb}, 0 ,1)), \"Already closed\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testScatterGatherWithClosedSegment(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        try (var channel = SocketChannel.open();\n+             var server = ServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel)) {\n+            ResourceScope scope = scopeSupplier.get();\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, scope, 16);\n+            scope.close();\n+            assertMessage(expectThrows(ISE, () -> channel.write(buffers)),       \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(buffers)),        \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(buffers, 0 ,8)), \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(buffers, 0, 8)),  \"Already closed\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"allScopes\")\n+    public void testBasicIO(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        ResourceScope scope;\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1);\n+             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, scope);\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, scope);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+            }\n+            ByteBuffer bb1 = segment1.asByteBuffer();\n+            ByteBuffer bb2 = segment2.asByteBuffer();\n+            assertEquals(sc1.write(bb1), 10);\n+            assertEquals(sc2.read(bb2), 10);\n+            assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+        }\n+    }\n+\n+    @Test\n+    public void testBasicHeapIOWithGlobalScope() throws Exception {\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1)) {\n+            var segment1 = MemorySegment.ofArray(new byte[10]);\n+            var segment2 = MemorySegment.ofArray(new byte[10]);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+            }\n+            ByteBuffer bb1 = segment1.asByteBuffer();\n+            ByteBuffer bb2 = segment2.asByteBuffer();\n+            assertEquals(sc1.write(bb1), 10);\n+            assertEquals(sc2.read(bb2), 10);\n+            assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"confinedScopes\")\n+    public void testIOOnConfinedFromAnotherThread(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        try (var channel = SocketChannel.open();\n+             var server = ServerSocketChannel.open();\n+             var connected = connectChannels(server, channel);\n+             var scope = scopeSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, scope);\n+            ByteBuffer bb = segment.asByteBuffer();\n+            List<ThrowingRunnable> ioOps = List.of(\n+                    () -> channel.write(bb),\n+                    () -> channel.read(bb),\n+                    () -> channel.write(new ByteBuffer[] {bb}),\n+                    () -> channel.read(new ByteBuffer[] {bb}),\n+                    () -> channel.write(new ByteBuffer[] {bb}, 0, 1),\n+                    () -> channel.read(new ByteBuffer[] {bb}, 0, 1)\n+            );\n+            for (var ioOp : ioOps) {\n+                AtomicReference<Exception> exception = new AtomicReference<>();\n+                Runnable task = () -> exception.set(expectThrows(ISE, ioOp));\n+                var t = new Thread(task);\n+                t.start();\n+                t.join();\n+                assertMessage(exception.get(), \"Attempted access outside owning thread\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"allScopes\")\n+    public void testScatterGatherIO(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        ResourceScope scope;\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1);\n+             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n+            var writeBuffers = mixedBuffersOfSize(32, scope, 64);\n+            var readBuffers = mixedBuffersOfSize(32, scope, 64);\n+            long expectedCount = remaining(writeBuffers);\n+            assertEquals(sc1.write(writeBuffers, 0, 32), expectedCount);\n+            assertEquals(readNBytes(sc2, readBuffers, 0, 32, expectedCount), expectedCount);\n+            assertEquals(flip(readBuffers), clear(writeBuffers));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testBasicIOWithDifferentScopes(Supplier<ResourceScope> scopeSupplier)\n+         throws Exception\n+    {\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1);\n+             var scope1 = scopeSupplier.get();\n+             var scope2 = scopeSupplier.get()) {\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, scope1, 64), mixedBuffersOfSize(16, scope2, 64))\n+                                     .flatMap(Arrays::stream)\n+                                     .toArray(ByteBuffer[]::new);\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, scope1, 64), mixedBuffersOfSize(16, scope2, 64))\n+                                    .flatMap(Arrays::stream)\n+                                    .toArray(ByteBuffer[]::new);\n+\n+            long expectedCount = remaining(writeBuffers);\n+            assertEquals(sc1.write(writeBuffers, 0, 32), expectedCount);\n+            assertEquals(readNBytes(sc2, readBuffers, 0, 32, expectedCount), expectedCount);\n+            assertEquals(flip(readBuffers), clear(writeBuffers));\n+        }\n+    }\n+\n+    static SocketChannel connectChannels(ServerSocketChannel ssc, SocketChannel sc)\n+        throws Exception\n+    {\n+        ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        sc.connect(ssc.getLocalAddress());\n+        return ssc.accept();\n+    }\n+\n+    static long readNBytes(SocketChannel channel,\n+                           ByteBuffer[] buffers, int offset, int len,\n+                           long bytes)\n+        throws Exception\n+    {\n+        long total = 0L;\n+        do {\n+            long n = channel.read(buffers, offset, len);\n+            assertTrue(n > 0, \"got:\" + n);\n+            total += n;\n+        } while (total < bytes);\n+        return total;\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"}]}