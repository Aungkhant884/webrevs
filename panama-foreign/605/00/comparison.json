{"files":[{"patch":"@@ -42,0 +42,1 @@\n+    private final MethodType downcallType;\n@@ -45,1 +46,1 @@\n-                               MethodType fiType, FunctionDescriptor fiDesc) {\n+                               FunctionInfo functionInfo) {\n@@ -47,2 +48,3 @@\n-        this.fiType = fiType;\n-        this.fiDesc = fiDesc;\n+        this.fiType = functionInfo.methodType();\n+        this.downcallType = functionInfo.reverseMethodType();\n+        this.fiDesc = functionInfo.descriptor();\n@@ -93,1 +95,1 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(), FunctionInfo.ofFunctionPointer(fiType, fiDesc), true);\n+            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(), FunctionInfo.ofFunctionPointer(downcallType, fiType, fiDesc), true);\n@@ -100,1 +102,1 @@\n-            append(\"\\\"\" + className() + \"::\\\" + Long.toHexString(addr.toRawLongValue()), addr, scope);\");\n+            append(\"\\\"\" + className() + \"::\\\" + Long.toHexString(addr.toRawLongValue()), addr, scope);\\n\");\n@@ -115,0 +117,4 @@\n+                if (fiType.returnType() != downcallType.returnType()) {\n+                    \/\/ add cast for invokeExact\n+                    append(\"(\" + downcallType.returnType().getName() + \")\");\n+                }\n@@ -119,1 +125,9 @@\n-                        .mapToObj(i -> \"x\" + i)\n+                        .mapToObj(i -> {\n+                            String paramExpr = \"x\" + i;\n+                            if (fiType.parameterType(i) != downcallType.parameterType(i)) {\n+                                \/\/ add cast for invokeExact\n+                                return \"(\" + downcallType.parameterType(i).getName() + \")\" + paramExpr;\n+                            } else {\n+                                return paramExpr;\n+                            }\n+                        })\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -195,3 +195,0 @@\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+            MethodType reverseMethodType,\n@@ -55,1 +56,1 @@\n-            return new FunctionInfo(methodType, functionDescriptor, isVarargs, Optional.of(parameterNames));\n+            return new FunctionInfo(methodType, null, functionDescriptor, isVarargs, Optional.of(parameterNames));\n@@ -58,2 +59,2 @@\n-        static FunctionInfo ofFunctionPointer(MethodType methodType, FunctionDescriptor functionDescriptor) {\n-            return new FunctionInfo(methodType, functionDescriptor, false, Optional.empty());\n+        static FunctionInfo ofFunctionPointer(MethodType upcallType, MethodType downcallType, FunctionDescriptor functionDescriptor) {\n+            return new FunctionInfo(upcallType, downcallType, functionDescriptor, false, Optional.empty());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-                typeTranslator.getJavaType(constant.type()), constant.value());\n+                getJavaType(constant.type()), constant.value());\n@@ -231,1 +231,1 @@\n-        return functionInfo(func, name, false, FunctionInfo::ofFunctionPointer)\n+        return functionInfo(func, name, false, (mtype, desc) -> FunctionInfo.ofFunctionPointer(mtype, getMethodType(func, true), desc))\n@@ -435,1 +435,1 @@\n-    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean allowVarargs,\n+    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean downcall,\n@@ -444,1 +444,1 @@\n-        if (!allowVarargs && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n+        if (!downcall && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n@@ -456,1 +456,1 @@\n-        MethodType mtype = getMethodType(funcPtr, allowVarargs);\n+        MethodType mtype = getMethodType(funcPtr, downcall);\n@@ -480,1 +480,1 @@\n-            return typeTranslator.getJavaType(type);\n+            return typeTranslator.getJavaType(type, false);\n@@ -490,1 +490,1 @@\n-    private MethodType getMethodType(Type.Function type) {\n+    private MethodType getMethodType(Type.Function type, boolean downcall) {\n@@ -492,13 +492,1 @@\n-            return typeTranslator.getMethodType(type);\n-        } catch (UnsupportedOperationException uoe) {\n-            warn(uoe.toString());\n-            if (JextractTool.DEBUG) {\n-                uoe.printStackTrace();\n-            }\n-            return null;\n-        }\n-    }\n-\n-    private MethodType getMethodType(Type.Function type, boolean varargsCheck) {\n-        try {\n-            return typeTranslator.getMethodType(type, varargsCheck);\n+            return typeTranslator.getMethodType(type, downcall);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo.methodType(), functionInfo.descriptor());\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,2 +128,1 @@\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this,\n-                name, functionInfo.methodType(), functionInfo.descriptor());\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -37,1 +38,1 @@\n-public class TypeTranslator implements Type.Visitor<Class<?>, Void> {\n+public class TypeTranslator implements Type.Visitor<Class<?>, Boolean> {\n@@ -39,1 +40,1 @@\n-    public Class<?> visitPrimitive(Type.Primitive t, Void aVoid) {\n+    public Class<?> visitPrimitive(Type.Primitive t, Boolean isArg) {\n@@ -77,1 +78,1 @@\n-    public Class<?> visitDelegated(Type.Delegated t, Void aVoid) {\n+    public Class<?> visitDelegated(Type.Delegated t, Boolean isArg) {\n@@ -79,2 +80,2 @@\n-                MemoryAddress.class :\n-                t.type().accept(this, null);\n+                (isArg ? Addressable.class : MemoryAddress.class) :\n+                t.type().accept(this, isArg);\n@@ -84,2 +85,2 @@\n-    public Class<?> visitFunction(Type.Function t, Void aVoid) {\n-        return MemoryAddress.class; \/\/ function pointer\n+    public Class<?> visitFunction(Type.Function t, Boolean isArg) {\n+        return isArg ? Addressable.class : MemoryAddress.class; \/\/ function pointer\n@@ -89,10 +90,6 @@\n-    public Class<?> visitDeclared(Type.Declared t, Void aVoid) {\n-        switch (t.tree().kind()) {\n-            case UNION:\n-            case STRUCT:\n-                return MemorySegment.class;\n-            case ENUM:\n-                return layoutToClass(false, t.tree().layout().orElseThrow(UnsupportedOperationException::new));\n-            default:\n-                throw new UnsupportedOperationException(\"declaration kind: \" + t.tree().kind());\n-        }\n+    public Class<?> visitDeclared(Type.Declared t, Boolean isArg) {\n+        return switch (t.tree().kind()) {\n+            case UNION, STRUCT -> MemorySegment.class;\n+            case ENUM -> layoutToClass(false, t.tree().layout().orElseThrow(UnsupportedOperationException::new));\n+            default -> throw new UnsupportedOperationException(\"declaration kind: \" + t.tree().kind());\n+        };\n@@ -102,1 +99,1 @@\n-    public Class<?> visitArray(Type.Array t, Void aVoid) {\n+    public Class<?> visitArray(Type.Array t, Boolean isArg) {\n@@ -111,1 +108,1 @@\n-    public Class<?> visitType(Type t, Void aVoid) {\n+    public Class<?> visitType(Type t, Boolean isArg) {\n@@ -115,6 +112,2 @@\n-    Class<?> getJavaType(Type t) {\n-        return t.accept(this, null);\n-    }\n-\n-    MethodType getMethodType(Type.Function type) {\n-        return getMethodType(type, true);\n+    Class<?> getJavaType(Type t, boolean isArg) {\n+        return t.accept(this, isArg);\n@@ -123,2 +116,2 @@\n-    MethodType getMethodType(Type.Function type, boolean varargsCheck) {\n-        MethodType mtype = MethodType.methodType(getJavaType(type.returnType()));\n+    MethodType getMethodType(Type.Function type, boolean downcall) {\n+        MethodType mtype = MethodType.methodType(getJavaType(type.returnType(), !downcall));\n@@ -126,1 +119,1 @@\n-            mtype = mtype.appendParameterTypes(getJavaType(arg));\n+            mtype = mtype.appendParameterTypes(getJavaType(arg, downcall));\n@@ -128,1 +121,1 @@\n-        if (varargsCheck && type.varargs()) {\n+        if (downcall && type.varargs()) {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeTranslator.java","additions":22,"deletions":29,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -133,0 +134,8 @@\n+\n+    @Test\n+    public void testGlobalFIFunctionPointerAddress() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            fp_addr$set(fp_addr.allocate((addr) -> MemoryAddress.ofLong(addr.toRawLongValue() + 1), scope).address());\n+            assertEquals(fp_addr.ofAddress(fp_addr$get(), scope).apply(MemoryAddress.ofLong(42)), MemoryAddress.ofLong(43));\n+        }\n+    }\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+EXPORT int* (*fp_addr)(int *arg);\n+\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/func.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}