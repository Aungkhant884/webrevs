{"files":[{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.jextract.impl.Filter;\n+import jdk.internal.jextract.impl.IncludeHelper;\n@@ -49,1 +49,0 @@\n-import java.util.Optional;\n@@ -115,4 +114,0 @@\n-    public static Declaration.Scoped filter(Declaration.Scoped decl, String... includedNames) {\n-        return Filter.filter(decl, includedNames);\n-    }\n-\n@@ -121,1 +116,6 @@\n-        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, libNames));\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, new IncludeHelper(), libNames));\n+    }\n+\n+    private static List<JavaFileObject> generateInternal(Declaration.Scoped decl, String headerName,\n+                                                String targetPkg, IncludeHelper includeHelper, List<String> libNames) {\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, includeHelper, libNames));\n@@ -165,1 +165,4 @@\n-        parser.accepts(\"filter\", format(\"help.filter\")).withRequiredArg();\n+        parser.accepts(\"dump-includes\", format(\"help.dump-includes\")).withRequiredArg();\n+        for (IncludeHelper.IncludeKind includeKind : IncludeHelper.IncludeKind.values()) {\n+            parser.accepts(includeKind.optionName(), format(\"help.\" + includeKind.optionName())).withRequiredArg();\n+        }\n@@ -203,0 +206,10 @@\n+        for (IncludeHelper.IncludeKind includeKind : IncludeHelper.IncludeKind.values()) {\n+            if (optionSet.has(includeKind.optionName())) {\n+                optionSet.valuesOf(includeKind.optionName()).forEach(p -> builder.addIncludeSymbol(includeKind, (String)p));\n+            }\n+        }\n+\n+        if (optionSet.has(\"dump-includes\")) {\n+            builder.setDumpIncludeFile(optionSet.valueOf(\"dump-includes\").toString());\n+        }\n+\n@@ -247,5 +260,0 @@\n-            \/\/filter\n-            if (!options.filters.isEmpty()) {\n-                toplevel = filter(toplevel, options.filters.toArray(new String[0]));\n-            }\n-\n@@ -256,1 +264,1 @@\n-            files = generate(\n+            files = generateInternal(\n@@ -258,1 +266,1 @@\n-                options.targetPackage, options.libraryNames);\n+                options.targetPackage, options.includeHelper, options.libraryNames);\n@@ -274,2 +282,6 @@\n-            Path output = Path.of(options.outputDir);\n-            write(output, !options.source, files);\n+            if (options.includeHelper.dumpIncludesFile != null) {\n+                options.includeHelper.dumpIncludes();\n+            } else {\n+                Path output = Path.of(options.outputDir);\n+                write(output, !options.source, files);\n+            }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/JextractTool.java","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Position;\n-\n-public final class Filter {\n-    private Filter() {}\n-\n-    public static Declaration.Scoped filter(Declaration.Scoped decl, String... validNames) {\n-        Declaration[] newMembers = decl.members().stream()\n-                .filter(d -> filterDecl(d, validNames))\n-                .toArray(Declaration[]::new);\n-        return Declaration.toplevel(decl.pos(), newMembers);\n-    }\n-\n-    private static boolean filterDecl(Declaration d, String... validNames) {\n-        if (d.pos() == Position.NO_POSITION) {\n-            return false;\n-        } else {\n-            for (String s : validNames) {\n-                String pathName = d.pos().path().toString();\n-                if (pathName.contains(s)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Filter.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Comparator;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+\n+public class IncludeHelper {\n+\n+    public enum IncludeKind {\n+        MACRO,\n+        VAR,\n+        FUNCTION,\n+        TYPEDEF,\n+        STRUCT,\n+        UNION;\n+\n+        public String optionName() {\n+            return \"include-\" + name().toLowerCase();\n+        }\n+\n+        static IncludeKind fromDeclaration(Declaration d) {\n+            if (d instanceof Declaration.Constant) {\n+                return MACRO;\n+            } else if (d instanceof Declaration.Variable) {\n+                return VAR;\n+            } else if (d instanceof Declaration.Function) {\n+                return FUNCTION;\n+            } else if (d instanceof Declaration.Typedef) {\n+                return TYPEDEF;\n+            } else if (d instanceof Declaration.Scoped scoped) {\n+                return fromScoped(scoped);\n+            } else {\n+                throw new IllegalStateException(\"Cannot get here!\");\n+            }\n+        }\n+\n+        static IncludeKind fromScoped(Declaration.Scoped scoped) {\n+            return switch (scoped.kind()) {\n+                case STRUCT -> IncludeKind.STRUCT;\n+                case UNION ->  IncludeKind.UNION;\n+                default -> throw new IllegalStateException(\"Cannot get here!\");\n+            };\n+        }\n+    }\n+\n+    private final EnumMap<IncludeKind, Set<String>> includesSymbolNamesByKind = new EnumMap<>(IncludeKind.class);\n+    private final Set<Declaration> usedDeclarations = new HashSet<>();\n+    public String dumpIncludesFile;\n+\n+    public void addSymbol(IncludeKind kind, String symbolName) {\n+        Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+        names.add(symbolName);\n+    }\n+\n+    public boolean isIncluded(Declaration.Variable variable) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.VAR, variable);\n+    }\n+\n+    public boolean isIncluded(Declaration.Function function) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.FUNCTION, function);\n+    }\n+\n+    public boolean isIncluded(Declaration.Constant constant) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.MACRO, constant);\n+    }\n+\n+    public boolean isIncluded(Declaration.Typedef typedef) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.TYPEDEF, typedef);\n+    }\n+\n+    public boolean isIncluded(Declaration.Scoped scoped) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.fromScoped(scoped), scoped);\n+    }\n+\n+    private boolean checkIncludedAndAddIfNeeded(IncludeKind kind, Declaration declaration) {\n+        boolean included = isIncludedInternal(kind, declaration);\n+        if (included && dumpIncludesFile != null) {\n+            usedDeclarations.add(declaration);\n+        }\n+        return included;\n+    }\n+\n+    private boolean isIncludedInternal(IncludeKind kind, Declaration declaration) {\n+        if (!isEnabled()) {\n+            return true;\n+        } else {\n+            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+            return names.contains(declaration.name());\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return includesSymbolNamesByKind.size() > 0;\n+    }\n+\n+    public void dumpIncludes() {\n+        try (var writer = Files.newBufferedWriter(Path.of(dumpIncludesFile), StandardOpenOption.CREATE)) {\n+            Map<Path, Set<Declaration>> declsByPath = usedDeclarations.stream()\n+                    .collect(Collectors.groupingBy(d -> d.pos().path(),\n+                            () -> new TreeMap<>(Path::compareTo),\n+                            Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(Declaration::name)))));\n+            String lineSep = \"\";\n+            for (Map.Entry<Path, Set<Declaration>> pathEntries : declsByPath.entrySet()) {\n+                writer.append(lineSep);\n+                writer.append(\"#### Extracted from: \" + pathEntries.getKey().toString() + \"\\n\\n\");\n+                Map<IncludeKind, List<Declaration>> declsByKind = pathEntries.getValue().stream()\n+                        .collect(Collectors.groupingBy(IncludeKind::fromDeclaration));\n+                int maxLengthOptionCol = pathEntries.getValue().stream().mapToInt(d -> d.name().length()).max().getAsInt();\n+                maxLengthOptionCol += 2; \/\/ --\n+                maxLengthOptionCol += IncludeKind.FUNCTION.optionName().length(); \/\/ max option name\n+                maxLengthOptionCol += 1; \/\/ space\n+                int maxLengthHeaderCol = pathEntries.getKey().toString().length();\n+                maxLengthHeaderCol += \"# header:\".length();\n+                for (Map.Entry<IncludeKind, List<Declaration>> kindEntries : declsByKind.entrySet()) {\n+                    for (Declaration d : kindEntries.getValue()) {\n+                        writer.append(String.format(\"%-\" + maxLengthOptionCol + \"s %-\" + maxLengthHeaderCol + \"s\",\n+                                \"--\" + kindEntries.getKey().optionName() + \" \" + d.name(),\n+                                       \"# header: \" + pathEntries.getKey() + \"\\n\"));\n+                    }\n+                }\n+                lineSep = \"\\n\";\n+            }\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/IncludeHelper.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+\n@@ -40,0 +41,1 @@\n+    public final IncludeHelper includeHelper;\n@@ -43,1 +45,1 @@\n-            String outputDir, boolean source) {\n+            String outputDir, boolean source, IncludeHelper includeHelper) {\n@@ -50,0 +52,1 @@\n+        this.includeHelper = includeHelper;\n@@ -67,0 +70,1 @@\n+        private IncludeHelper includeHelper = new IncludeHelper();\n@@ -82,1 +86,1 @@\n-                    targetPackage, outputDir, source\n+                    targetPackage, outputDir, source, includeHelper\n@@ -109,0 +113,8 @@\n+\n+        public void setDumpIncludeFile(String dumpIncludesFile) {\n+            includeHelper.dumpIncludesFile = dumpIncludesFile;\n+        }\n+\n+        public void addIncludeSymbol(IncludeHelper.IncludeKind kind, String symbolName) {\n+            includeHelper.addSymbol(kind, symbolName);\n+        }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Options.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+    private final IncludeHelper includeHelper;\n@@ -111,1 +112,1 @@\n-                String pkgName, List<String> libraryNames) {\n+                String pkgName, IncludeHelper includeHelper, List<String> libraryNames) {\n@@ -114,1 +115,1 @@\n-        return new OutputFactory(pkgName, toplevelBuilder).generate(decl);\n+        return new OutputFactory(pkgName, toplevelBuilder, includeHelper).generate(decl);\n@@ -117,1 +118,1 @@\n-    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder) {\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, IncludeHelper includeHelper) {\n@@ -121,0 +122,1 @@\n+        this.includeHelper = includeHelper;\n@@ -167,1 +169,1 @@\n-        if (!constants.add(constant.name())) {\n+        if (!constants.add(constant.name()) || !includeHelper.isIncluded(constant)) {\n@@ -193,0 +195,1 @@\n+\n@@ -195,0 +198,3 @@\n+            if (!className.isEmpty() && !includeHelper.isIncluded(d)) {\n+                return null;\n+            }\n@@ -257,1 +263,2 @@\n-        if (functionSeen(funcTree)) {\n+        if (functionSeen(funcTree) ||\n+                !includeHelper.isIncluded(funcTree)) {\n@@ -321,0 +328,3 @@\n+        if (!includeHelper.isIncluded(tree)) {\n+            return null;\n+        }\n@@ -371,1 +381,1 @@\n-        if (parent == null && variableSeen(tree)) {\n+        if (parent == null && (variableSeen(tree) || !includeHelper.isIncluded(tree))) {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,1 +33,7 @@\n-help.filter=header files to filter\n+help.include-macro=name of constant macro to include\n+help.include-var=name of global variable to include\n+help.include-function=name of function to include\n+help.include-typedef=name of type definition to include\n+help.include-struct=name of struct definition to include\n+help.include-union=name of union definition to include\n+help.dump-includes=dump included symbols into specified file\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/Messages.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm -Dforeign.restricted=permit -Duser.language=en --add-modules jdk.incubator.jextract TestFilters\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.fail;\n+\n+public class TestFilters extends JextractToolRunner {\n+    @Test\n+    public void testFilter() {\n+        for (FilterKind expectedKind : FilterKind.values()) {\n+            Path filterOutput = getOutputFilePath(\"filters_\" + expectedKind);\n+            Path filterH = getInputFilePath(\"filters.h\");\n+            run(\"-d\", filterOutput.toString(), expectedKind.filterOption, expectedKind.symbolName, filterH.toString()).checkSuccess();\n+            try (Loader loader = classLoader(filterOutput)) {\n+                Class<?> cls = loader.loadClass(\"filters_h\");\n+                for (FilterKind kind : FilterKind.values()) {\n+                    Object res = kind.get(cls);\n+                    if (kind == expectedKind) {\n+                        assertNotNull(res);\n+                    } else {\n+                        assertNull(res);\n+                    }\n+                }\n+            } finally {\n+                deleteDir(filterOutput);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDumpIncludes() throws IOException {\n+        Path filterOutput = getOutputFilePath(\"filters_dump\");\n+        try {\n+            Files.createDirectory(filterOutput);\n+            Path includes = filterOutput.resolve(\"test.conf\");\n+            Path filterH = getInputFilePath(\"filters.h\");\n+            run(\"--dump-includes\", includes.toString(), filterH.toString()).checkSuccess();\n+            List<String> includeLines = Files.readAllLines(includes);\n+            outer: for (FilterKind kind : FilterKind.values()) {\n+                String filterLine = kind.filterOption + \" \" + kind.symbolName;\n+                Iterator<String> linesIt = includeLines.iterator();\n+                while (linesIt.hasNext()) {\n+                    String line = linesIt.next();\n+                    if (line.startsWith(filterLine)) {\n+                        linesIt.remove();\n+                        continue outer;\n+                    }\n+                }\n+                fail(\"Filter line not found: \" + filterLine);\n+            }\n+        } finally {\n+            deleteDir(filterOutput);\n+        }\n+    }\n+\n+    enum FilterKind {\n+        VAR(\"_global\", \"--include-var\"),\n+        FUNCTION(\"_function\", \"--include-function\"),\n+        CONSTANT(\"_constant\", \"--include-macro\"),\n+        TYPEDEF(\"_typedef\", \"--include-typedef\"),\n+        STRUCT(\"_struct\", \"--include-struct\"),\n+        UNION(\"_union\", \"--include-union\");\n+\n+        final String symbolName;\n+        final String filterOption;\n+\n+        FilterKind(String symbolName, String filterOption) {\n+            this.symbolName = symbolName;\n+            this.filterOption = filterOption;\n+        }\n+\n+        Object get(Class<?> clazz) {\n+            return switch (this) {\n+                case FUNCTION, CONSTANT -> findMethod(clazz, symbolName);\n+                case VAR -> findMethod(clazz, symbolName + \"$get\");\n+                case TYPEDEF -> findField(clazz, symbolName);\n+                case STRUCT, UNION -> findNestedClass(clazz, symbolName);\n+            };\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/TestFilters.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int _global;\n+\n+EXPORT int _function(void);\n+\n+#define _constant 10\n+\n+typedef int _typedef;\n+\n+struct _struct { int x; };\n+\n+union _union { int y; };\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/filters.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"}]}