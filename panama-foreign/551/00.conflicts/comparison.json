{"files":[{"patch":"@@ -30,0 +30,1 @@\n+<<<<<<< HEAD\n@@ -47,0 +48,19 @@\n+=======\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCSTDLIB, \\\n+    NAME := syslookup, \\\n+    CFLAGS := $(CFLAGS_JDKLIB), \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+    LDFLAGS := -Wl$(COMMA)--no-as-needed -lc -lm -ldl $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS := $(LIBCXX), \\\n+))\n+\n+else ifeq ($(call isTargetOs, windows), false)\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCSTDLIB, \\\n+    NAME := syslookup, \\\n+    CFLAGS := $(CFLAGS_JDKLIB), \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS := $(LIBCXX), \\\n+))\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -51,0 +71,1 @@\n+<<<<<<< HEAD\n@@ -52,0 +73,3 @@\n+=======\n+TARGETS += $(BUILD_LIBCSTDLIB)\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"make\/modules\/jdk.incubator.foreign\/Lib.gmk","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2401,0 +2401,8 @@\n+<<<<<<< HEAD\n+=======\n+\n+            @Override\n+            public void exit(int statusCode) {\n+                Shutdown.exit(statusCode);\n+            }\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -398,0 +398,9 @@\n+<<<<<<< HEAD\n+=======\n+\n+    \/**\n+     * Direct access to Shutdown.exit to avoid security manager checks\n+     * @param statusCode the status code\n+     *\/\n+    void exit(int statusCode);\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+<<<<<<< HEAD\n@@ -145,0 +146,6 @@\n+=======\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -160,0 +167,5 @@\n+<<<<<<< HEAD\n+=======\n+     * @see SymbolLookup\n+     *\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -178,0 +190,5 @@\n+<<<<<<< HEAD\n+=======\n+     * @see SymbolLookup\n+     *\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -185,0 +202,1 @@\n+<<<<<<< HEAD\n@@ -187,0 +205,2 @@\n+=======\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -202,0 +222,5 @@\n+<<<<<<< HEAD\n+=======\n+     *\n+     * @see SymbolLookup\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -218,0 +243,3 @@\n+     * <p>\n+     * The target method handle should not throw any exceptions. If the target method handle does throw an exception,\n+     * the VM will exit with a non-zero exit code.\n@@ -223,1 +251,2 @@\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch, or\n+     *         if it is determined that the target method handle can throw an exception.\n@@ -646,2 +675,1 @@\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n-         * backed by the {@linkplain ResourceScope#globalScope() global} resource scope.\n+         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+<<<<<<< HEAD\n@@ -42,0 +43,3 @@\n+=======\n+ * A symbol lookup. Exposes a lookup operation for searching symbols, see {@link SymbolLookup#lookup(String)}.\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -61,0 +65,1 @@\n+<<<<<<< HEAD\n@@ -62,0 +67,3 @@\n+=======\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -53,0 +56,1 @@\n+import java.util.Arrays;\n@@ -75,0 +79,3 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n@@ -82,0 +89,1 @@\n+    private static final MethodHandle MH_HANDLE_UNCAUGHT_EXCEPTION;\n@@ -100,0 +108,2 @@\n+            MH_HANDLE_UNCAUGHT_EXCEPTION = lookup.findStatic(SharedUtils.class, \"handleUncaughtException\",\n+                    methodType(void.class, Throwable.class));\n@@ -362,0 +372,7 @@\n+    static void handleUncaughtException(Throwable t) {\n+        if (t != null) {\n+            t.printStackTrace();\n+            JLA.exit(1);\n+        }\n+    }\n+\n@@ -369,1 +386,5 @@\n-            closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            if (!upcall) {\n+                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            } else {\n+                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n+            }\n@@ -415,0 +436,7 @@\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n@@ -418,0 +446,1 @@\n+<<<<<<< HEAD\n@@ -425,0 +454,9 @@\n+=======\n+        private static final CLinker linker = getSystemLinker();\n+\n+        static final MethodHandle MH_MALLOC = linker.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n+                        MethodType.methodType(MemoryAddress.class, long.class),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+\n+        static final MethodHandle MH_FREE = linker.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+<<<<<<< HEAD\n@@ -54,0 +55,3 @@\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+<<<<<<< HEAD\n@@ -159,0 +160,3 @@\n+=======\n+        final static SymbolLookup LOOKUP;\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +62,3 @@\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -65,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -66,0 +71,3 @@\n+=======\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -92,0 +100,1 @@\n+<<<<<<< HEAD\n@@ -93,0 +102,3 @@\n+=======\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+<<<<<<< HEAD\n@@ -49,0 +50,3 @@\n+=======\n+    private static final MemoryAddress dummyTarget = MemoryAddress.ofLong(1);\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+<<<<<<< HEAD\n@@ -61,0 +62,3 @@\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -91,0 +95,1 @@\n+<<<<<<< HEAD\n@@ -92,0 +97,3 @@\n+=======\n+            MemoryAddress ma = lookup.lookup(name).get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -101,0 +109,1 @@\n+<<<<<<< HEAD\n@@ -102,0 +111,3 @@\n+=======\n+            MemoryAddress ma = lookup.lookup(\"empty\").get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -116,0 +128,1 @@\n+<<<<<<< HEAD\n@@ -117,0 +130,3 @@\n+=======\n+            MemoryAddress ma = lookup.lookup(\"identity_va\").get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -131,0 +147,1 @@\n+<<<<<<< HEAD\n@@ -132,0 +149,3 @@\n+=======\n+                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+<<<<<<< HEAD\n@@ -55,0 +56,7 @@\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    @Test\n+    public void testSimpleLookup() {\n+        assertFalse(lookup.lookup(\"f\").isEmpty());\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -59,0 +67,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +69,3 @@\n+=======\n+        assertTrue(lookup.lookup(\"nonExistent\").isEmpty());\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -64,0 +76,1 @@\n+<<<<<<< HEAD\n@@ -65,0 +78,3 @@\n+=======\n+        MemorySegment segment = lookup.lookup(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+<<<<<<< HEAD\n@@ -70,0 +71,3 @@\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -95,0 +99,1 @@\n+<<<<<<< HEAD\n@@ -96,0 +101,3 @@\n+=======\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n@@ -113,0 +121,1 @@\n+<<<<<<< HEAD\n@@ -114,0 +123,3 @@\n+=======\n+        MemoryAddress addr = lookup.lookup(fName).get();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+<<<<<<< HEAD\n@@ -69,0 +70,3 @@\n+=======\n+    static final MemoryAddress varargsAddr =\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+<<<<<<< HEAD\n@@ -75,0 +76,3 @@\n+=======\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+>>>>>>> 3caff916e7aeef7d3888be00b17d9b7e4c38cefb\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}