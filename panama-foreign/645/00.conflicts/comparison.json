{"files":[{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+<<<<<<< HEAD:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.loader.NativeLibrary;\n+import jdk.internal.loader.RawNativeLibraries;\n+\n+import java.lang.invoke.MethodHandles;\n+=======\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+>>>>>>> 4c7b0da2a31e1de6a93c6df93a730db056670c37:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import jdk.internal.loader.NativeLibraries;\n+import jdk.internal.loader.NativeLibrary;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+\n+<<<<<<< HEAD:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+import sun.security.action.GetPropertyAction;\n+\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+\n+public class SystemLookup implements SymbolLookup {\n+=======\n+public class SystemLookup {\n+>>>>>>> 4c7b0da2a31e1de6a93c6df93a730db056670c37:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+\n+    private SystemLookup() { }\n+\n+    static final SystemLookup INSTANCE = new SystemLookup();\n+\n+    \/*\n+     * On POSIX systems, dlsym will allow us to lookup symbol in library dependencies; the same trick doesn't work\n+     * on Windows. For this reason, on Windows we do not generate any side-library, and load msvcrt.dll directly instead.\n+     *\/\n+<<<<<<< HEAD:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+    private static final SymbolLookup syslookup = switch (CABI.current()) {\n+        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+=======\n+    private static final Function<String, Optional<NativeSymbol>> syslookup = switch (CABI.current()) {\n+        case SysV, LinuxAArch64, MacOsAArch64 -> libLookup(libs -> libs.loadLibrary(\"syslookup\"));\n+>>>>>>> 4c7b0da2a31e1de6a93c6df93a730db056670c37:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+        case Win64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n+    };\n+\n+    private static Function<String, Optional<NativeSymbol>> makeWindowsLookup() {\n+        Path system32 = Path.of(System.getenv(\"SystemRoot\"), \"System32\");\n+        Path ucrtbase = system32.resolve(\"ucrtbase.dll\");\n+        Path msvcrt = system32.resolve(\"msvcrt.dll\");\n+\n+        boolean useUCRT = Files.exists(ucrtbase);\n+        Path stdLib = useUCRT ? ucrtbase : msvcrt;\n+<<<<<<< HEAD:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+        SymbolLookup lookup = libLookup(libs -> libs.load(stdLib));\n+\n+        if (useUCRT) {\n+            \/\/ use a fallback lookup to look up inline functions from fallback lib\n+            SymbolLookup fallbackLibLookup = libLookup(libs -> libs.load(jdkLibraryPath(\"WinFallbackLookup\")));\n+=======\n+        Function<String, Optional<NativeSymbol>> lookup = libLookup(libs -> libs.loadLibrary(null, stdLib.toFile()));\n+\n+        if (useUCRT) {\n+            \/\/ use a fallback lookup to look up inline functions from fallback lib\n+\n+            Function<String, Optional<NativeSymbol>> fallbackLibLookup = libLookup(libs -> libs.loadLibrary(\"WinFallbackLookup\"));\n+>>>>>>> 4c7b0da2a31e1de6a93c6df93a730db056670c37:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+\n+            int numSymbols = WindowsFallbackSymbols.values().length;\n+            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.apply(\"funcs\").orElseThrow().address(),\n+                ADDRESS.byteSize() * numSymbols, ResourceScope.globalScope());\n+\n+            Function<String, Optional<NativeSymbol>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n+                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n+\n+            final Function<String, Optional<NativeSymbol>> finalLookup = lookup;\n+            lookup = name -> finalLookup.apply(name).or(() -> fallbackLookup.apply(name));\n+        }\n+\n+        return lookup;\n+    }\n+\n+<<<<<<< HEAD:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+    private static SymbolLookup libLookup(Function<RawNativeLibraries, NativeLibrary> loader) {\n+        NativeLibrary lib = loader.apply(RawNativeLibraries.newInstance(MethodHandles.lookup()));\n+=======\n+    private static Function<String, Optional<NativeSymbol>> libLookup(Function<NativeLibraries, NativeLibrary> loader) {\n+        NativeLibrary lib = loader.apply(NativeLibraries.rawNativeLibraries(SystemLookup.class, false));\n+>>>>>>> 4c7b0da2a31e1de6a93c6df93a730db056670c37:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+        return name -> {\n+            Objects.requireNonNull(name);\n+            try {\n+                long addr = lib.lookup(name);\n+                return addr == 0 ?\n+                        Optional.empty() :\n+                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n+            } catch (NoSuchMethodException e) {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+<<<<<<< HEAD:src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+    \/*\n+     * Returns the path of the given library name from JDK\n+     *\/\n+    private static Path jdkLibraryPath(String name) {\n+        Path javahome = Path.of(GetPropertyAction.privilegedGetProperty(\"java.home\"));\n+        String lib = switch (CABI.current()) {\n+            case SysV, LinuxAArch64, MacOsAArch64 -> \"lib\";\n+            case Win64 -> \"bin\";\n+        };\n+        String libname = System.mapLibraryName(name);\n+        return javahome.resolve(lib).resolve(libname);\n+    }\n+\n+    @Override\n+    public Optional<NativeSymbol> lookup(String name) {\n+        return syslookup.lookup(name);\n+    }\n+\n+=======\n+>>>>>>> 4c7b0da2a31e1de6a93c6df93a730db056670c37:src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java\n+    public static SystemLookup getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    public Optional<NativeSymbol> lookup(String name) {\n+        return syslookup.apply(name);\n+    }\n+\n+    \/\/ fallback symbols missing from ucrtbase.dll\n+    \/\/ this list has to be kept in sync with the table in the companion native library\n+    private enum WindowsFallbackSymbols {\n+        \/\/ stdio\n+        fprintf,\n+        fprintf_s,\n+        fscanf,\n+        fscanf_s,\n+        fwprintf,\n+        fwprintf_s,\n+        fwscanf,\n+        fwscanf_s,\n+        printf,\n+        printf_s,\n+        scanf,\n+        scanf_s,\n+        snprintf,\n+        sprintf,\n+        sprintf_s,\n+        sscanf,\n+        sscanf_s,\n+        swprintf,\n+        swprintf_s,\n+        swscanf,\n+        swscanf_s,\n+        vfprintf,\n+        vfprintf_s,\n+        vfscanf,\n+        vfscanf_s,\n+        vfwprintf,\n+        vfwprintf_s,\n+        vfwscanf,\n+        vfwscanf_s,\n+        vprintf,\n+        vprintf_s,\n+        vscanf,\n+        vscanf_s,\n+        vsnprintf,\n+        vsnprintf_s,\n+        vsprintf,\n+        vsprintf_s,\n+        vsscanf,\n+        vsscanf_s,\n+        vswprintf,\n+        vswprintf_s,\n+        vswscanf,\n+        vswscanf_s,\n+        vwprintf,\n+        vwprintf_s,\n+        vwscanf,\n+        vwscanf_s,\n+        wprintf,\n+        wprintf_s,\n+        wscanf,\n+        wscanf_s,\n+\n+        \/\/ time\n+        gmtime\n+        ;\n+\n+        static WindowsFallbackSymbols valueOfOrNull(String name) {\n+            try {\n+                return valueOf(name);\n+            } catch (IllegalArgumentException e) {\n+                return null;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"}]}