{"files":[{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.foreign;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * An object that may be projected down to a {@linkplain #address() memory address}.\n- * Examples of addressable types are {@link MemorySegment}, {@link MemoryAddress} and {@link VaList}.\n- * <p>\n- * The {@link Addressable} type is used by a {@linkplain Linker linker} to model the types of\n- * {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n- * (e.g. memory addresses, variable argument lists and upcall stubs).\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface Addressable permits MemorySegment, MemoryAddress, VaList {\n-\n-    \/**\n-     * {@return the {@linkplain MemoryAddress memory address} associated with this addressable}\n-     *\/\n-    MemoryAddress address();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Addressable.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -42,1 +42,1 @@\n- * {@linkplain Linker#downcallHandle(Addressable, FunctionDescriptor) downcall method handles} or\n+ * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor) downcall method handles} or\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * {@linkplain #downcallHandle(Addressable, FunctionDescriptor) downcall method handles}; and<\/li>\n+ * {@linkplain #downcallHandle(MemorySegment, FunctionDescriptor) downcall method handles}; and<\/li>\n@@ -70,1 +70,1 @@\n- * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n+ * {@linkplain #methodType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n@@ -74,7 +74,2 @@\n- * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n- *     <ul>\n- *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n- *         then {@code C = Addressable.class};<\/li>\n- *         <li>otherwise, {@code C = E};\n- *     <\/ul><\/li>\n- * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n+ * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n@@ -87,1 +82,1 @@\n- * the downcall method handle type features a leading parameter of type {@link Addressable}, from which the\n+ * the downcall method handle type features a leading parameter of type {@link MemorySegment}, from which the\n@@ -100,1 +95,1 @@\n- * The type of the provided method handle has to {@linkplain #upcallType(FunctionDescriptor) match} the Java\n+ * The type of the provided method handle has to {@linkplain #methodType(FunctionDescriptor) match} the Java\n@@ -105,7 +100,2 @@\n- * <li>If {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n- *     <ul>\n- *         <li>If {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n- *         then {@code C = Addressable.class};<\/li>\n- *         <li>Otherwise, {@code C = E};\n- *     <\/ul><\/li>\n- * <li>Or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then {@code C = E}; or<\/li>\n+ * <li>if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n@@ -114,2 +104,2 @@\n- * downcall method handles (as {@link MemorySegment} implements the {@link Addressable} interface) and,\n- * when no longer required, they can be {@linkplain MemorySession#close() released}, via their associated {@linkplain MemorySession session}.\n+ * downcall method handles and, when no longer required, they can be {@linkplain MemorySession#close() released},\n+ * via their associated {@linkplain MemorySession memory session}.\n@@ -124,2 +114,2 @@\n- * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment}\n- * or {@link VaList}):\n+ * the linker runtime guarantees the following for any argument {@code A} of type {@link MemorySegment} whose corresponding\n+ * layout is {@link ValueLayout#ADDRESS}:\n@@ -127,1 +117,1 @@\n- *     <li>The memory session of {@code R} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n+ *     <li>The memory session of {@code A} is {@linkplain MemorySession#isAlive() alive}. Otherwise, the invocation throws\n@@ -131,1 +121,1 @@\n- *     <li>The memory session of {@code R} is {@linkplain MemorySession#whileAlive(Runnable) kept alive} (and cannot be closed) during the invocation.<\/li>\n+ *     <li>The memory session of {@code R} is <em>kept alive<\/em> (and cannot be closed) during the invocation.<\/li>\n@@ -133,0 +123,5 @@\n+ * A downcall method handle created from a function descriptor whose return layout is an\n+ * {@linkplain ValueLayout.OfAddress address layout} returns a native memory segment associated with\n+ * the {@linkplain MemorySession#global() global session}. Under normal conditions, the size of the returned segment is {@code 0}.\n+ * However, if the return layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n+ * then the size of the returned segment is {@code Long.MAX_VALUE}.\n@@ -138,1 +133,1 @@\n- * handle associated with an upcall stub returns a {@linkplain MemoryAddress memory address}, clients must ensure\n+ * handle associated with an upcall stub returns a {@linkplain MemorySegment memory segment}, clients must ensure\n@@ -141,0 +136,6 @@\n+ * <p>\n+ * An upcall stub argument whose corresponding layout is an {@linkplain ValueLayout.OfAddress address layout}\n+ * is a native memory segment associated with the {@linkplain MemorySession#global() global session}.\n+ * Under normal conditions, the size of this segment argument is {@code 0}. However, if the layout associated with\n+ * the upcall stub argument is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n+ * then the size of the segment argument is {@code Long.MAX_VALUE}.\n@@ -163,1 +164,1 @@\n-     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemoryAddress}.\n+     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemorySegment}.\n@@ -169,1 +170,1 @@\n-     * {@link #downcallHandle(Addressable, FunctionDescriptor) downcall method handle} or an\n+     * {@link #downcallHandle(MemorySegment, FunctionDescriptor) downcall method handle} or an\n@@ -217,1 +218,1 @@\n-     * or if the symbol is {@link MemoryAddress#NULL}\n+     * or if the symbol is {@link MemorySegment#NULL}\n@@ -219,1 +220,1 @@\n-    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n+    default MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function) {\n@@ -227,1 +228,1 @@\n-     * entry point, of type {@link Addressable}, which is used to specify the address of the target function\n+     * entry point, of type {@link MemorySegment}, which is used to specify the address of the target function\n@@ -234,2 +235,2 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link Addressable} parameter passed to it is\n-     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link MemorySegment} parameter passed to it is\n+     * associated with the {@link MemorySegment#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n@@ -287,11 +288,1 @@\n-     * {@return the downcall method handle {@linkplain MethodType type} associated with the given function descriptor}\n-     * @param functionDescriptor a function descriptor.\n-     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n-     * (e.g. if they are sequence layouts or padding layouts).\n-     *\/\n-    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n-        return SharedUtils.inferMethodType(functionDescriptor, false);\n-    }\n-\n-    \/**\n-     * {@return the method handle {@linkplain MethodType type} associated with an upcall stub with the given function descriptor}\n+     * {@return the linker method handle {@linkplain MethodType type} associated with the given function descriptor}\n@@ -302,2 +293,2 @@\n-    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n-        return SharedUtils.inferMethodType(functionDescriptor, true);\n+    static MethodType methodType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":36,"deletions":45,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1,854 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package java.lang.foreign;\n-\n-import java.nio.ByteOrder;\n-\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.reflect.CallerSensitive;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * A memory address models a reference into a memory location. Memory addresses are typically obtained in one of the following ways:\n- * <ul>\n- *     <li>By calling {@link Addressable#address()} on an instance of type {@link Addressable} (e.g. a memory segment);<\/li>\n- *     <li>By invoking a {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle} which returns a pointer;<\/li>\n- *     <li>By reading an address from memory, e.g. via {@link MemorySegment#get(ValueLayout.OfAddress, long)}; and<\/li>\n- *     <li>By the invocation of an {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub} which accepts a pointer.<\/li>\n- * <\/ul>\n- * A memory address is backed by a raw machine pointer, expressed as a {@linkplain #toRawLongValue() long value}.\n- *\n- * <h2 id=\"dereferencing\">Dereferencing memory addresses<\/h2>\n- *\n- * A memory address can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n- * Each dereference method takes a {@linkplain ValueLayout value layout}, which specifies the size,\n- * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n- * For instance, to read an int from a segment, using {@linkplain ByteOrder#nativeOrder() default endianness}, the following code can be used:\n- * {@snippet lang=java :\n- * MemoryAddress address = ...\n- * int value = address.get(ValueLayout.JAVA_INT, 0);\n- * }\n- *\n- * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n- * can be expressed as follows:\n- * {@snippet lang=java :\n- * MemoryAddress address = ...\n- * int value = address.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n- * }\n- *\n- * All the dereference methods in this class are <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>: since\n- * a memory address does not feature temporal nor spatial bounds, the runtime has no way to check the correctness\n- * of the memory dereference operation.\n- *\n- * @implSpec\n- * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface MemoryAddress extends Addressable permits MemoryAddressImpl {\n-\n-    \/**\n-     * {@return the raw long value associated with this memory address}\n-     *\/\n-    long toRawLongValue();\n-\n-    \/**\n-     * Returns a memory address at given offset from this address.\n-     * @param offset specified offset (in bytes), relative to this address, which should be used to create the new address.\n-     *               Might be negative.\n-     * @return a memory address with the given offset from current one.\n-     *\/\n-    MemoryAddress addOffset(long offset);\n-\n-    \/**\n-     * Reads a UTF-8 encoded, null-terminated string from this address at the given offset.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a Java string constructed from the bytes read from the given starting address ({@code toRawLongValue() + offset})\n-     * up to (but not including) the first {@code '\\0'} terminator character (assuming one is found).\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    String getUtf8String(long offset);\n-\n-    \/**\n-     * Writes the given string to this address at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param str the Java string to be written at this address.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setUtf8String(long offset, String str);\n-\n-    \/**\n-     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n-     * object is also an address, and it refers to the same memory location as this address.\n-     *\n-     * @param that the object to be compared for equality with this address.\n-     * @return {@code true} if the specified object is equal to this address.\n-     *\/\n-    @Override\n-    boolean equals(Object that);\n-\n-    \/**\n-     * {@return the hash code value for this address}\n-     *\/\n-    @Override\n-    int hashCode();\n-\n-    \/**\n-     * The memory address instance modelling the {@code NULL} address.\n-     *\/\n-    MemoryAddress NULL = new MemoryAddressImpl(0L);\n-\n-    \/**\n-     * Creates a memory address from the given long value.\n-     * @param value the long value representing a raw address.\n-     * @return a memory address with the given raw long value.\n-     *\/\n-    static MemoryAddress ofLong(long value) {\n-        return value == 0 ?\n-                NULL :\n-                new MemoryAddressImpl(value);\n-    }\n-\n-    \/**\n-     * Reads a byte from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a byte value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    byte get(ValueLayout.OfByte layout, long offset);\n-\n-    \/**\n-     * Writes a byte into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the byte value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfByte layout, long offset, byte value);\n-\n-    \/**\n-     * Reads a boolean from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a boolean value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    boolean get(ValueLayout.OfBoolean layout, long offset);\n-\n-    \/**\n-     * Writes a boolean into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the boolean value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfBoolean layout, long offset, boolean value);\n-\n-    \/**\n-     * Reads a char from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a char value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    char get(ValueLayout.OfChar layout, long offset);\n-\n-    \/**\n-     * Writes a char into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the char value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfChar layout, long offset, char value);\n-\n-    \/**\n-     * Reads a short from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a short value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    short get(ValueLayout.OfShort layout, long offset);\n-\n-    \/**\n-     * Writes a short into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the short value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfShort layout, long offset, short value);\n-\n-    \/**\n-     * Reads an int from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return an int value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    int get(ValueLayout.OfInt layout, long offset);\n-\n-    \/**\n-     * Writes an int into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the int value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfInt layout, long offset, int value);\n-\n-    \/**\n-     * Reads a float from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a float value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    float get(ValueLayout.OfFloat layout, long offset);\n-\n-    \/**\n-     * Writes a float into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the float value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfFloat layout, long offset, float value);\n-\n-    \/**\n-     * Reads a long from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a long value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    long get(ValueLayout.OfLong layout, long offset);\n-\n-    \/**\n-     * Writes a long into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the long value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfLong layout, long offset, long value);\n-\n-    \/**\n-     * Reads a double from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return a double value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    double get(ValueLayout.OfDouble layout, long offset);\n-\n-    \/**\n-     * Writes a double into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the double value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfDouble layout, long offset, double value);\n-\n-    \/**\n-     * Reads an address from this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this read operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @return an address value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    MemoryAddress get(ValueLayout.OfAddress layout, long offset);\n-\n-    \/**\n-     * Writes an address into this address at the given offset, with the given layout.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this address). Might be negative.\n-     *               The final address of this write operation can be expressed as {@code toRawLongValue() + offset}.\n-     * @param value the address value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void set(ValueLayout.OfAddress layout, long offset, Addressable value);\n-\n-    \/**\n-     * Reads a char from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a char value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    char getAtIndex(ValueLayout.OfChar layout, long index);\n-\n-    \/**\n-     * Writes a char into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the char value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfChar layout, long index, char value);\n-\n-    \/**\n-     * Reads a short from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a short value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    short getAtIndex(ValueLayout.OfShort layout, long index);\n-\n-    \/**\n-     * Writes a short into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the short value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfShort layout, long index, short value);\n-\n-    \/**\n-     * Reads an int from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an int value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    int getAtIndex(ValueLayout.OfInt layout, long index);\n-\n-    \/**\n-     * Writes an int into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the int value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfInt layout, long index, int value);\n-\n-    \/**\n-     * Reads a float from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a float value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    float getAtIndex(ValueLayout.OfFloat layout, long index);\n-\n-    \/**\n-     * Writes a float into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the float value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfFloat layout, long index, float value);\n-\n-    \/**\n-     * Reads a long from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a long value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    long getAtIndex(ValueLayout.OfLong layout, long index);\n-\n-    \/**\n-     * Writes a long into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the long value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfLong layout, long index, long value);\n-\n-    \/**\n-     * Reads a double from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a double value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    double getAtIndex(ValueLayout.OfDouble layout, long index);\n-\n-    \/**\n-     * Writes a double into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the double value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfDouble layout, long index, double value);\n-\n-    \/**\n-     * Reads an address from this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this read operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an address value read from this address.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index);\n-\n-    \/**\n-     * Writes an address into this address at the given index, scaled by the given layout size.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index in bytes (relative to this address). Might be negative.\n-     *              The final address of this write operation can be expressed as {@code toRawLongValue() + (index * layout.byteSize())}.\n-     * @param value the address value to be written.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value);\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":0,"deletions":854,"binary":false,"changes":854,"status":"deleted"},{"patch":"@@ -360,3 +360,2 @@\n-     * where {@code base} denotes the base address expressed by the {@link MemorySegment} access coordinate\n-     * (see {@link MemorySegment#address()} and {@link MemoryAddress#toRawLongValue()}) and {@code offset}\n-     * can be expressed in the following form:\n+     * where {@code base} denotes the base address associated with the {@link MemorySegment} access coordinate\n+     * (see {@link MemorySegment#address()} and {@code offset} can be expressed in the following form:\n@@ -635,1 +634,1 @@\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemoryAddress.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n@@ -661,1 +660,1 @@\n-        } else if (carrier == MemoryAddress.class) {\n+        } else if (carrier == MemorySegment.class) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.internal.foreign.MemorySessionImpl;\n@@ -53,1 +52,0 @@\n-import jdk.internal.util.ArraysSupport;\n@@ -187,1 +185,1 @@\n- *   return ((segment.address().toRawLongValue() + offset) % layout.byteAlignment()) == 0\n+ *   return ((segment.address().address() + offset) % layout.byteAlignment()) == 0;\n@@ -192,3 +190,3 @@\n- * segment's base address is <em>virtualized<\/em> and, as such, cannot be used to construct an alignment check. Instead,\n- * heap segments are assumed to produce addresses which are never more aligned than the element size of the Java array from which\n- * they have originated from, as shown in the following table:\n+ * segment's {@linkplain #address() base address} is <em>virtualized<\/em> and, as such, cannot be used to construct an\n+ * alignment check. Instead, heap segments are assumed to produce addresses which are never more aligned than the element\n+ * size of the Java array from which they have originated from, as shown in the following table:\n@@ -229,3 +227,3 @@\n- * Sometimes it is necessary to turn a memory address obtained from native code into a memory segment with\n- * full spatial, temporal and confinement bounds. To do this, clients can {@linkplain #ofAddress(MemoryAddress, long, MemorySession) obtain}\n- * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain MemorySession session}.\n+ * Sometimes it is necessary to turn a raw address (e.g. obtained from native code) into a memory segment with\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@linkplain #ofAddress(long, long, MemorySession)}\n+ * a native segment <em>unsafely<\/em>, by providing a new size, as well as a new {@linkplain MemorySession memory session}.\n@@ -236,1 +234,1 @@\n- * Clients requiring sophisticated, low-level control over mapped memory segments, might consider writing\n+ * For example, clients requiring sophisticated, low-level control over mapped memory segments, might consider writing\n@@ -239,1 +237,1 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}.\n+ * {@link #ofAddress(long, long, MemorySession)}.\n@@ -247,1 +245,1 @@\n-public sealed interface MemorySegment extends Addressable permits AbstractMemorySegmentImpl {\n+public sealed interface MemorySegment permits AbstractMemorySegmentImpl {\n@@ -250,6 +248,7 @@\n-     * {@return the base memory address associated with this native memory segment}\n-     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n+     * Returns the base address of the memory region associated with this segment. If this memory segment is\n+     * a {@linkplain #isNative() native} memory segment, then the returned address is the off-heap address\n+     * at which the native memory region associated with this segment starts. If this memory segment is an array\n+     * memory segment, the returned address is the byte offset into the {@linkplain #array()} object associated\n+     * with this segment. In other words, the base address of an array segment is always <em>virtualized<\/em>.\n+     *\n+     * @return the base address of the memory region associated with this segment.\n@@ -257,2 +256,6 @@\n-    @Override\n-    MemoryAddress address();\n+    long address();\n+\n+    \/**\n+     * {@return the Java array associated with this memory segment, if any}\n+     *\/\n+    Optional<Object> array();\n@@ -393,1 +396,2 @@\n-     * segments, the resulting offset can be computed as follows:\n+     * segments, or heap segments backed by the same array, the resulting offset\n+     * can be computed as follows:\n@@ -396,1 +400,1 @@\n-     * other.baseAddress().toRawLongValue() - segment.baseAddress().toRawLongValue()\n+     * other.address() - segment.baseAddress()\n@@ -399,1 +403,1 @@\n-     * If the segments share the same base address, {@code 0} is returned. If\n+     * If the segments share the same address, {@code 0} is returned. If\n@@ -404,0 +408,2 @@\n+     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n+     * a different kind, or because they are backed by different Java arrays.\n@@ -478,6 +484,0 @@\n-     * <p>\n-     * This method is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * return MemorySegment.mismatch(this, 0, this.byteSize(),\n-     *                               other, 0, other.byteSize());\n-     * }\n@@ -496,2 +496,0 @@\n-     *\n-     * @see MemorySegment#mismatch(MemorySegment, long, long, MemorySegment, long, long)\n@@ -731,1 +729,1 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n@@ -760,1 +758,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -868,0 +866,45 @@\n+    \/**\n+     * A zero-length native memory segment modelling the {@code NULL} address.\n+     *\/\n+    MemorySegment NULL = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(0L, 0);\n+\n+    \/**\n+     * Creates a zero-length native memory segment from the given {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, 0);\n+     *}\n+     * @param address the address of the returned native segment.\n+     * @return a zero-length native memory segment with the given address.\n+     *\/\n+    static MemorySegment ofAddress(long address) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+    }\n+\n+    \/**\n+     * Creates a native memory segment with the given size and {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, bytesSize, MemorySession.global());\n+     *}\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param address the address of the returned native segment.\n+     * @param bytesSize the size (in bytes) of the returned native segment.\n+     * @return a zero-length native memory segment with the given address and size.\n+     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static MemorySegment ofAddress(long address, long bytesSize) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n+        return MemorySegment.ofAddress(address, bytesSize, MemorySession.global());\n+    }\n@@ -901,1 +944,1 @@\n-    static MemorySegment ofAddress(MemoryAddress address, long bytesSize, MemorySession session) {\n+    static MemorySegment ofAddress(long address, long bytesSize, MemorySession session) {\n@@ -903,1 +946,0 @@\n-        Objects.requireNonNull(address);\n@@ -1103,2 +1145,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a byte value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a byte value read from this segment.\n@@ -1124,1 +1166,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1146,2 +1188,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a boolean value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a boolean value read from this segment.\n@@ -1167,1 +1209,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1189,2 +1231,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a char value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a char value read from this segment.\n@@ -1210,1 +1252,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1232,2 +1274,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a short value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a short value read from this segment.\n@@ -1253,1 +1295,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1275,2 +1317,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return an int value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return an int value read from this segment.\n@@ -1296,1 +1338,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1318,2 +1360,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a float value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a float value read from this segment.\n@@ -1339,1 +1381,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1361,2 +1403,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a long value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a long value read from this segment.\n@@ -1382,1 +1424,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1404,2 +1446,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return a double value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a double value read from this segment.\n@@ -1425,1 +1467,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1443,2 +1485,5 @@\n-     * Reads an address from this segment at the given offset, with the given layout.\n-     *\n+     * Reads an address from this segment at the given offset, with the given layout. The read address is wrapped in\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n+     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n+     * segment is {@code Long.MAX_VALUE}.\n@@ -1447,2 +1492,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + offset}.\n-     * @return an address value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a native segment wrapping an address read from this segment.\n@@ -1459,2 +1504,2 @@\n-    default MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n-        return (MemoryAddress)layout.accessHandle().get(this, offset);\n+    default MemorySegment get(ValueLayout.OfAddress layout, long offset) {\n+        return (MemorySegment)layout.accessHandle().get(this, offset);\n@@ -1468,1 +1513,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + offset}.\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n@@ -1481,2 +1526,2 @@\n-    default void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n-        layout.accessHandle().set(this, offset, value.address());\n+    default void set(ValueLayout.OfAddress layout, long offset, MemorySegment value) {\n+        layout.accessHandle().set(this, offset, value);\n@@ -1490,2 +1535,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a char value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a char value read from this segment.\n@@ -1514,1 +1559,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n@@ -1539,2 +1584,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a short value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a short value read from this segment.\n@@ -1563,1 +1608,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n@@ -1588,2 +1633,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an int value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return an int value read from this segment.\n@@ -1612,1 +1657,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n@@ -1637,2 +1682,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a float value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a float value read from this segment.\n@@ -1661,1 +1706,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n@@ -1686,2 +1731,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a long value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a long value read from this segment.\n@@ -1710,1 +1755,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n@@ -1735,2 +1780,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return a double value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a double value read from this segment.\n@@ -1759,1 +1804,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n@@ -1780,1 +1825,5 @@\n-     * Reads an address from this segment at the given index, scaled by the given layout size.\n+     * Reads an address from this segment at the given at the given index, scaled by the given layout size. The read address is wrapped in\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n+     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n+     * segment is {@code Long.MAX_VALUE}.\n@@ -1784,2 +1833,2 @@\n-     *               the final address of this read operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n-     * @return an address value read from this address.\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a native segment wrapping an address read from this segment.\n@@ -1797,1 +1846,1 @@\n-    default MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+    default MemorySegment getAtIndex(ValueLayout.OfAddress layout, long index) {\n@@ -1800,1 +1849,1 @@\n-        return (MemoryAddress)layout.accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment)layout.accessHandle().get(this, index * layout.byteSize());\n@@ -1808,1 +1857,1 @@\n-     *               the final address of this write operation can be expressed as {@code address().toRawLongValue() + (index * layout.byteSize())}.\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n@@ -1822,1 +1871,1 @@\n-    default void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+    default void setAtIndex(ValueLayout.OfAddress layout, long index, MemorySegment value) {\n@@ -1825,1 +1874,1 @@\n-        layout.accessHandle().set(this, index * layout.byteSize(), value.address());\n+        layout.accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1830,2 +1879,2 @@\n-     * object is also a memory segment, and if that segment refers to the same memory region as this segment. More specifically,\n-     * for two segments to be considered equals, all the following must be true:\n+     * object is also a memory segment, and if that segment refers to the same memory location as this segment. More specifically,\n+     * for two segments {@code s1} and {@code s2} to be considered equals, all the following must be true:\n@@ -1833,7 +1882,6 @@\n-     *     <li>the two segments must be of the same kind; either both are {@linkplain #isNative() native segments},\n-     *     backed by off-heap memory, or both are backed by on-heap memory;\n-     *     <li>if the two segments are {@linkplain #isNative() native segments}, their {@link #address() base address}\n-     *     must be {@linkplain MemoryAddress#equals(Object) equal}. Otherwise, the two segments must wrap the\n-     *     same Java array instance, at the same starting offset;<\/li>\n-     *     <li>the two segments must have the same {@linkplain #byteSize() size}; and<\/li>\n-     *     <li>the two segments must have the {@linkplain MemorySession#equals(Object) same} {@linkplain #session() temporal bounds}.\n+     *     <li>{@code s1.array().equals(s2.array())}, that is, the two segments must be of the same kind;\n+     *     either both are {@linkplain #isNative() native segments}, backed by off-heap memory, or both are backed by\n+     *     the same on-heap Java array;\n+     *     <li>{@code s1.address() == s2.address()}, that is, the base address of the two segments should be the same.\n+     *     This means that the two segments either refer at the same off-heap memory location, or they refer\n+     *     to the same position inside their associated Java array instance.<\/li>\n@@ -1842,1 +1890,3 @@\n-     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead.\n+     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead. Note that this\n+     * method does <em>not<\/em> compare the temporal and spatial bounds of two segments. As such it is suitable\n+     * to perform address checks, such as checking if a native memory segment has the {@code NULL} address.\n@@ -1847,1 +1897,0 @@\n-     * @see #asOverlappingSlice(MemorySegment)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":154,"deletions":105,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-    default MemorySegment allocate(ValueLayout.OfAddress layout, Addressable value) {\n+    default MemorySegment allocate(ValueLayout.OfAddress layout, MemorySegment value) {\n@@ -207,1 +207,1 @@\n-        layout.varHandle().set(segment, value.address());\n+        layout.varHandle().set(segment, value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- *     <li>It can be {@linkplain MemorySegment#set(ValueLayout.OfAddress, long, Addressable) stored} inside another memory segment.<\/li>\n+ *     <li>It can be {@linkplain MemorySegment#set(ValueLayout.OfAddress, long, MemorySegment) stored} inside another memory segment.<\/li>\n@@ -57,1 +57,1 @@\n- *     {@link MemorySegment#ofAddress(MemoryAddress, long, MemorySession) resizing} the segment first).<\/li>\n+ *     {@link MemorySegment#ofAddress(long, long, MemorySession) resizing} the segment first).<\/li>\n@@ -168,2 +168,2 @@\n-            MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n-            return addr == MemoryAddress.NULL ?\n+            long addr = javaLangAccess.findNative(loader, name);\n+            return addr == 0L ?\n@@ -246,4 +246,4 @@\n-            MemoryAddress addr = MemoryAddress.ofLong(library.find(name));\n-            return addr == MemoryAddress.NULL\n-                    ? Optional.empty() :\n-                    Optional.of(MemorySegment.ofAddress(addr, 0L, session));\n+            long addr = library.find(name);\n+            return addr == 0L ?\n+                    Optional.empty() :\n+                    Optional.of(MemorySegment.ofAddress(addr, 0, session));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * A variable argument list, similar in functionality to a C {@code va_list}.\n+ * Helper class to create and manipulate variable argument lists, similar in functionality to a C {@code va_list}.\n@@ -44,2 +44,32 @@\n- * A variable argument list is a stateful cursor used to iterate over a set of arguments. A variable argument list\n- * can be passed by reference e.g. to a {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle}.\n+ * A variable argument list segment can be created using the {@link #make(Consumer, MemorySession)} factory, as follows:\n+ * {@snippet lang = java:\n+ * VaList vaList = VaList.make(builder ->\n+ *                                    builder.addVarg(C_INT, 42)\n+ *                                           .addVarg(C_DOUBLE, 3.8d));\n+ *}\n+ * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated a variable\n+ * argument list, which can then be passed to {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handles}\n+ * targeting native functions using the C {@code va_list} type.\n+ * <p>\n+ * The contents of a foreign memory segment modelling a variable argument list can be accessed by <em>unsafely<\/em> creating\n+ * a variable argument list, as follows:\n+ * {@snippet lang = java:\n+ * void upcall(int n, MemorySegment vaListSegment) {\n+ *    try (MemorySession session = MemorySession.openConfined()) {\n+ *        VaList vaList = VaList.ofAddress(vaListSegment.address(), session);\n+ *        VaList copy = vaList.copy();\n+ *        int i = vaList.nextVarg(C_INT);\n+ *        double d = vaList.nextVarg(C_DOUBLE);\n+ *        \/\/ and again\n+ *        int i = copy.nextVarg(C_INT);\n+ *        double d = copy.nextVarg(C_DOUBLE);\n+ *     }\n+ * }\n+ *}\n+ * The above method receives a foreign segment modelling a variable argument list; the contents of the segment are accessed by creating\n+ * a new variable argument list, from the segment address. Note that the variable argument list is first copied into\n+ * a second list before any element is accessed: this will allow us to iterate through the elements twice. Elements in\n+ * the variable argument list are accessed using {@link #nextVarg(ValueLayout.OfInt)} and\n+ * {@link #nextVarg(ValueLayout.OfDouble)}. These methods (as well as other access methods in the {@link VaList} class)\n+ * take the layout of the element that needs to be accessed and perform all the necessary alignment checks as well\n+ * as endianness conversions.\n@@ -61,1 +91,1 @@\n- *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(MemoryAddress, MemorySession)} are not capable of detecting out-of-bounds reads<\/li>\n+ *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, MemorySession)} are not capable of detecting out-of-bounds reads<\/li>\n@@ -65,1 +95,1 @@\n- * (regardless of the memory session associated with the variable arity list).\n+ * (regardless of the session associated with the variable arity list).\n@@ -70,6 +100,1 @@\n-sealed public interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n-\n-    \/**\n-     * {@return the memory session associated with this variable argument list}\n-     *\/\n-    MemorySession session();\n+sealed public interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n@@ -83,1 +108,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -86,1 +111,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -97,1 +122,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -100,1 +125,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -111,1 +136,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -114,1 +139,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -120,2 +145,6 @@\n-     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n+     * Reads the next address value, wraps it into a native memory segment, and advances this variable argument list's position.\n+     * The behavior of this method is equivalent to the C {@code va_arg} function. The returned segment's base\n+     * {@linkplain MemorySegment#address()} is set to the value read from the variable argument list, and the segment\n+     * is associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions, the size of the returned\n+     * segment is {@code 0}. However, if the provided layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded}\n+     * address layout, then the size of the returned segment is {@code Long.MAX_VALUE}.\n@@ -124,2 +153,3 @@\n-     * @return the {@code MemoryAddress} value read from this variable argument list.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @return a native memory segment whose {@linkplain MemorySegment#address() address} is the value read from\n+     * this variable argument list.\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -128,1 +158,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -131,1 +161,1 @@\n-    MemoryAddress nextVarg(ValueLayout.OfAddress layout);\n+    MemorySegment nextVarg(ValueLayout.OfAddress layout);\n@@ -134,3 +164,3 @@\n-     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function. The provided group layout must correspond to a C struct or union\n-     * type.\n+     * Reads the next composite value into a new {@code MemorySegment}, allocated with the provided allocator,\n+     * and advances this variable argument list's position. The behavior of this method is equivalent to the C\n+     * {@code va_arg} function. The provided group layout must correspond to a C struct or union type.\n@@ -148,1 +178,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -151,1 +181,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -160,1 +190,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -163,1 +193,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -178,1 +208,1 @@\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n+     * @throws IllegalStateException if the session associated with this variable argument list is not\n@@ -181,1 +211,1 @@\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * the session associated with this variable argument list.\n@@ -186,5 +216,6 @@\n-     * {@return the {@linkplain MemoryAddress memory address} associated with this variable argument list}\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this variable argument list is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this variable argument list.\n+     * Returns a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n+     * The contents of the returned memory segment are platform-dependent. Whether and how the contents of\n+     * the returned segment are updated when iterating the contents of a variable argument list is also\n+     * platform-dependent. The returned segment's memory session is the session which manages the lifecycle of this\n+     * variable argument list.\n+     * @return a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n@@ -192,2 +223,1 @@\n-    @Override\n-    MemoryAddress address();\n+    MemorySegment segment();\n@@ -196,2 +226,4 @@\n-     * Creates a variable argument list from a memory address pointing to an existing variable argument list,\n-     * with the given memory session.\n+     * Creates a variable argument list from the give address value and memory session. The address is typically obtained\n+     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided session determines\n+     * the lifecycle of the returned variable argument list: when the session is {@linkplain MemorySession#close() closed},\n+     * the returned variable argument list will no longer be accessible.\n@@ -204,3 +236,1 @@\n-     * @implNote variable argument lists created using this method can not detect <a href=VaList.html#safety>out-of-bounds<\/a> reads.\n-     *\n-     * @param address a memory address pointing to an existing variable argument list.\n+     * @param address the address of the variable argument list.\n@@ -208,4 +238,4 @@\n-     * @return a new variable argument list backed by the memory region at {@code address}.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * @return a new variable argument list backed by a native memory region starting at the given address value.\n+     * @throws IllegalStateException         if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread other than the thread\n+     *                                       {@linkplain MemorySession#ownerThread() owning} {@code session}.\n@@ -218,1 +248,1 @@\n-    static VaList ofAddress(MemoryAddress address, MemorySession session) {\n+    static VaList ofAddress(long address, MemorySession session) {\n@@ -220,1 +250,0 @@\n-        Objects.requireNonNull(address);\n@@ -230,1 +259,1 @@\n-     * memory session, and will be released when the memory session is {@linkplain MemorySession#close closed}.\n+     * session, and will be released when the session is {@linkplain MemorySession#close closed}.\n@@ -255,1 +284,1 @@\n-     * on all operations, except for {@link VaList#address()}, {@link VaList#copy()} and {@link VaList#session()}.\n+     * on all operations, except for {@link VaList#segment()}, {@link VaList#copy()}.\n@@ -299,1 +328,2 @@\n-         * Writes an {@code Addressable} value to the variable argument list being constructed.\n+         * Writes the {@linkplain MemorySegment#address() address} of the provided native memory segment\n+         * to the variable argument list being constructed.\n@@ -302,1 +332,1 @@\n-         * @param value the {@code Addressable} value to be written.\n+         * @param segment the segment whose {@linkplain MemorySegment#address() address} is to be written.\n@@ -305,1 +335,1 @@\n-        Builder addVarg(ValueLayout.OfAddress layout, Addressable value);\n+        Builder addVarg(ValueLayout.OfAddress layout, MemorySegment segment);\n@@ -308,1 +338,1 @@\n-         * Writes a {@code MemorySegment} value, with the given layout, to the variable argument list being constructed.\n+         * Writes a {@code MemorySegment}, with the given layout, to the variable argument list being constructed.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":86,"deletions":56,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -101,1 +103,9 @@\n-        char descriptor = carrier == MemoryAddress.class ? 'A' : carrier.descriptorString().charAt(0);\n+        String descriptor;\n+        if (this instanceof ValueLayout.OfAddress addressLayout) {\n+            descriptor = \"A\";\n+            if (addressLayout.isUnbounded) {\n+                descriptor += \"!\";\n+            }\n+        } else {\n+            descriptor = carrier.descriptorString().substring(0, 1);\n+        }\n@@ -103,1 +113,1 @@\n-            descriptor = Character.toLowerCase(descriptor);\n+            descriptor = descriptor.toLowerCase();\n@@ -239,1 +249,1 @@\n-        if (carrier == MemoryAddress.class && size != ADDRESS_SIZE_BITS) {\n+        if (carrier == MemorySegment.class && size != ADDRESS_SIZE_BITS) {\n@@ -259,1 +269,1 @@\n-                || carrier == MemoryAddress.class;\n+                || carrier == MemorySegment.class;\n@@ -571,1 +581,1 @@\n-     * A value layout whose carrier is {@code MemoryAddress.class}.\n+     * A value layout whose carrier is {@code MemorySegment.class}.\n@@ -577,0 +587,3 @@\n+\n+        private final boolean isUnbounded;\n+\n@@ -578,1 +591,2 @@\n-            super(MemoryAddress.class, order, ADDRESS_SIZE_BITS);\n+            super(MemorySegment.class, order, ADDRESS_SIZE_BITS);\n+            this.isUnbounded = false; \/\/ safe\n@@ -581,2 +595,3 @@\n-        OfAddress(ByteOrder order, long size, long alignment, Optional<String> name) {\n-            super(MemoryAddress.class, order, size, alignment, name);\n+        OfAddress(ByteOrder order, long size, long alignment, boolean isUnbounded, Optional<String> name) {\n+            super(MemorySegment.class, order, size, alignment, name);\n+            this.isUnbounded = isUnbounded;\n@@ -587,1 +602,1 @@\n-            return new OfAddress(order(), bitSize(), alignment, name);\n+            return new OfAddress(order(), bitSize(), alignment, isUnbounded, name);\n@@ -603,1 +618,39 @@\n-            return new OfAddress(order, bitSize(), alignment, name());\n+            return new OfAddress(order, bitSize(), alignment, isUnbounded, name());\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            return super.equals(other) &&\n+                    ((OfAddress)other).isUnbounded == this.isUnbounded;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), isUnbounded);\n+        }\n+\n+        \/**\n+         * Returns an <em>unbounded<\/em> address layout with the same carrier, alignment constraints, name and order as this address layout,\n+         * but with the specified pointee layout. An unbounded address layouts allow raw addresses to be dereferenced\n+         * as {@linkplain MemorySegment memory segments} whose size is set to {@link Long#MAX_VALUE}. As such,\n+         * these segments be used in subsequent dereference operations.\n+         * <p>\n+         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+         * restricted methods, and use safe and supported functionalities, where possible.\n+         *\n+         * @return an unbounded address layout with same characteristics as this layout.\n+         * @see #isUnbounded()\n+         *\/\n+        @CallerSensitive\n+        public OfAddress asUnbounded() {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), ValueLayout.OfAddress.class, \"asUnbounded\");\n+            return new OfAddress(order(), bitSize(), alignment, true, name());\n+        }\n+\n+        \/**\n+         * {@return {@code true}, if this address layout is an {@linkplain #asUnbounded() unbounded address layout}}.\n+         *\/\n+        public boolean isUnbounded() {\n+            return isUnbounded;\n@@ -609,1 +662,1 @@\n-     * bit alignment set to {@code sizeof(size_t) * 8}, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * bit alignment set to {@code sizeof(size_t) * 8}, byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -612,1 +665,1 @@\n-     * MemoryLayout.valueLayout(MemoryAddress.class, ByteOrder.nativeOrder())\n+     * MemoryLayout.valueLayout(MemorySegment.class, ByteOrder.nativeOrder())\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":65,"deletions":12,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -53,0 +53,5 @@\n+ * The off-heap memory associated with the native memory segment will be released when the segment becomes\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>; this is similar to what happens\n+ * with direct buffers created via {@link java.nio.ByteBuffer#allocateDirect(int)}. It is also possible to manage\n+ * the lifecycle of allocated native segments more directly, as shown in a later section.\n+ * <p>\n@@ -137,1 +142,1 @@\n- * <h3 id=\"addresses\">Foreign addresses<\/h3>\n+ * <h3 id=\"foreign-segments\">Foreign memory segments<\/h3>\n@@ -140,3 +145,2 @@\n- * are fully known at segment creation. But when interacting with foreign functions, clients will often receive <em>raw<\/em> pointers.\n- * Such pointers have no spatial bounds. For example, the C type {@code char*} can refer to a single {@code char} value,\n- * or an array of {@code char} values, of given size. Nor do said pointers have any notion of temporal bounds or thread-confinement.\n+ * are fully known at segment creation. But when interacting with foreign functions, clients will often receive memory segments\n+ * that wrap <em>raw<\/em> foreign addresses. We call these segments <em>foreign<\/em> memory segments.\n@@ -144,23 +148,35 @@\n- * Raw pointers are modelled using the {@link java.lang.foreign.MemoryAddress} class. When clients receive a\n- * memory address instance from a foreign function call, they can perform memory dereference on it directly,\n- * using one of the many <em>unsafe<\/em>\n- * {@linkplain java.lang.foreign.MemoryAddress#get(java.lang.foreign.ValueLayout.OfInt, long) dereference methods}\n- * provided:\n- *\n- * {@snippet lang=java :\n- * MemoryAddress addr = ... \/\/ obtain address from foreign function call\n- * int x = addr.get(ValueLayout.JAVA_INT, 0);\n- * }\n- *\n- * Alternatively, the client can\n- * {@linkplain java.lang.foreign.MemorySegment#ofAddress(java.lang.foreign.MemoryAddress, long, java.lang.foreign.MemorySession) create}\n- * a memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial bounds which might,\n- * for instance, be available in the documentation of the foreign function which produced the native address.\n- * Here is how an unsafe segment can be created from a memory address:\n- *\n- * {@snippet lang=java :\n- * MemorySession session = ... \/\/ initialize a memory session object\n- * MemoryAddress addr = ... \/\/ obtain address from foreign function call\n- * MemorySegment segment = MemorySegment.ofAddress(addr, 4, session); \/\/ segment is 4 bytes long\n- * int x = segment.get(ValueLayout.JAVA_INT, 0);\n- * }\n+ * Foreign memory segments are typically modelled using zero-length memory segments backed by the\n+ * {@linkplain java.lang.foreign.MemorySession#global() global} memory session. As such, attempts to dereference\n+ * foreign memory segments will fail with {@link java.lang.IndexOutOfBoundsException}. This is a crucial safety feature:\n+ * raw foreign addresses are not associated with spatial bounds. For example, the C type {@code char*} can refer to a single {@code char} value,\n+ * or an array of {@code char} values, of given size. Nor do said addresses have any notion of temporal bounds or thread-confinement.\n+ * <p>\n+ * To dereference foreign memory segments, clients have two options. First, they can\n+ * {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession) create}\n+ * a new native memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial and temporal bounds\n+ * which might, for instance, be available in the documentation of the foreign function which produced the memory segment.\n+ * Here is how a foreign segment can be dereferenced:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySession session = ... \/\/ initialize a memory session\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ obtain foreign segment (size = 0)\n+ * MemorySegment segment = MemorySegment.ofAddress(raw.address(), 4, session); \/\/ new segment (size = 4)\n+ * int x = segment.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Alternatively, clients can obtain, <em>unsafely<\/em>, an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n+ * address value layout. Unbounded address value layouts allow the API to view foreign segments as segments with maximal size\n+ * (e.g. {@linkplain java.lang.Long#MAX_VALUE}), meaning that clients can always perform dereference operations on a foreign\n+ * segment obtained using an unbounded address layout:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ obtain foreign segment (size = Long.MAX_VALUE)\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ *}\n+ *\n+ * Note that there is no <em>correct<\/em> choice here. Which approach is taken largely depends on the information\n+ * that a client has available when obtaining a foreign memory segment. For instance, if such segment points to\n+ * a C struct, the client might prefer to resize the foreign segment, to match the size of the struct (so that\n+ * out-of-bounds access will be detected by the API). In other instances, however, there will be no, or little\n+ * information as to what spatial and\/or temporal bounds should be associated with a given foreign segment. In these\n+ * cases the second approach is preferrable.\n@@ -170,1 +186,1 @@\n- * to a Java method) into a memory address, so that Java code can effectively be passed to other foreign functions.\n+ * to a Java method) into a memory segment, so that Java code can effectively be passed to other foreign functions.\n@@ -175,2 +191,4 @@\n- *     static int intCompare(MemoryAddress addr1, MemoryAddress addr2) {\n- *         return addr1.get(ValueLayout.JAVA_INT, 0) - addr2.get(ValueLayout.JAVA_INT, 0);\n+ *     static int intCompare(MemorySegment addr1, MemorySegment addr2) {\n+ *         return addr1.get(ValueLayout.JAVA_INT, 0) -\n+ *                addr2.get(ValueLayout.JAVA_INT, 0);\n+ *\n@@ -181,1 +199,1 @@\n- * The above method dereferences two memory addresses containing an integer value, and performs a simple comparison\n+ * The above method dereferences two foreign memory segments containing an integer value, and performs a simple comparison\n@@ -185,2 +203,4 @@\n- * {@snippet lang=java :\n- * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);\n+ * {@snippet lang = java:\n+ * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT,\n+ *                                                                 ValueLayout.ADDRESS.asUnbounded(),\n+ *                                                                 ValueLayout.ADDRESS.asUnbounded());\n@@ -190,1 +210,1 @@\n- * }\n+ *}\n@@ -194,1 +214,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallType(java.lang.foreign.FunctionDescriptor) derive} a method type\n+ * {@linkplain java.lang.foreign.Linker#methodType(java.lang.foreign.FunctionDescriptor) derive} a method type\n@@ -200,1 +220,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -202,1 +222,1 @@\n- * Addressable comparFunc = Linker.nativeLinker().upcallStub(\n+ * MemorySegment comparFunc = Linker.nativeLinker().upcallStub(\n@@ -205,1 +225,1 @@\n- * }\n+ *}\n@@ -219,1 +239,1 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, MemorySession)}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)}\n@@ -223,1 +243,1 @@\n- * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(MemoryAddress, long, MemorySession)},\n+ * For instance, in the case of {@link java.lang.foreign.MemorySegment#ofAddress(long, long, MemorySession)},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":60,"deletions":40,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -50,0 +49,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -7913,1 +7913,1 @@\n-     *     {@code float}, {@code double} or {@link MemoryAddress}.\n+     *     {@code float}, {@code double} or {@link MemorySegment}.\n@@ -7916,1 +7916,1 @@\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n@@ -7919,1 +7919,1 @@\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n+     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n@@ -7924,1 +7924,1 @@\n-     * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n+     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n@@ -7927,1 +7927,1 @@\n-     * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n+     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySession;\n@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -73,2 +72,0 @@\n-    static final long NONCE = new Random().nextLong();\n-\n@@ -191,5 +188,0 @@\n-    @Override\n-    public MemoryAddress address() {\n-        throw new UnsupportedOperationException(\"Cannot obtain address of on-heap segment\");\n-    }\n-\n@@ -375,5 +367,0 @@\n-    protected int id() {\n-        \/\/compute a stable and random id for this memory segment\n-        return Math.abs(Objects.hash(unsafeGetBase(), unsafeGetOffset(), NONCE));\n-    }\n-\n@@ -458,1 +445,1 @@\n-        return \"MemorySegment{ id=0x\" + Long.toHexString(id()) + \" limit: \" + length + \" }\";\n+        return \"MemorySegment{ array: \" + array() + \" address:\" + address() + \" limit: \" + length + \" }\";\n@@ -464,5 +451,2 @@\n-                isNative() == that.isNative() &&\n-                unsafeGetOffset() == that.unsafeGetOffset() &&\n-                unsafeGetBase() == that.unsafeGetBase() &&\n-                length == that.length &&\n-                session.equals(that.session);\n+                array().equals(that.array()) &&\n+                address() == that.address();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        long min = segment.address().toRawLongValue();\n+        long min = segment.address();\n@@ -75,0 +75,1 @@\n+        MemorySessionImpl.toSessionImpl(session).checkValidState();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.Optional;\n+\n@@ -47,1 +49,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, int, MemorySession)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySession)}.\n@@ -62,0 +64,5 @@\n+    @Override\n+    public Optional<Object> array() {\n+        return Optional.of(base);\n+    }\n+\n@@ -64,1 +71,1 @@\n-        super(length, readOnly, MemorySessionImpl.GLOBAL);\n+        super(length, readOnly, MemorySession.global());\n@@ -114,0 +121,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+        }\n@@ -142,0 +154,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+        }\n@@ -170,0 +187,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+        }\n@@ -198,0 +220,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_INT_BASE_OFFSET;\n+        }\n@@ -226,0 +253,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_LONG_BASE_OFFSET;\n+        }\n@@ -254,0 +286,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+        }\n@@ -282,0 +319,5 @@\n+\n+        @Override\n+        public long address() {\n+            return offset - Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.ValueLayout;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * This class provides an immutable implementation for the {@code MemoryAddress} interface. This class contains information\n- * about the segment this address is associated with, as well as an offset into such segment.\n- *\/\n-public final class MemoryAddressImpl implements MemoryAddress, Scoped {\n-\n-    private final long offset;\n-\n-    public MemoryAddressImpl(long offset) {\n-        this.offset = offset;\n-    }\n-\n-    \/\/ MemoryAddress methods\n-\n-    @Override\n-    public MemoryAddress addOffset(long offset) {\n-        return new MemoryAddressImpl(this.offset + offset);\n-    }\n-\n-    @Override\n-    public long toRawLongValue() {\n-        return offset;\n-    }\n-\n-    @Override\n-    public final MemoryAddress address() {\n-        return this;\n-    }\n-\n-    \/\/ Object methods\n-\n-    @Override\n-    public int hashCode() {\n-        return (int) toRawLongValue();\n-    }\n-\n-    @Override\n-    public boolean equals(Object that) {\n-        return (that instanceof MemoryAddressImpl addressImpl &&\n-            offset == addressImpl.offset);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"MemoryAddress{ offset=0x\" + Long.toHexString(offset) + \" }\";\n-    }\n-\n-    public static MemorySegment ofLongUnchecked(long value) {\n-        return ofLongUnchecked(value, Long.MAX_VALUE);\n-    }\n-\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize, MemorySession session) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, session);\n-    }\n-\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, MemorySessionImpl.GLOBAL);\n-    }\n-\n-    @Override\n-    public MemorySessionImpl session() {\n-        return MemorySessionImpl.GLOBAL;\n-    }\n-\n-    @Override\n-    @CallerSensitive\n-    @ForceInline\n-    public String getUtf8String(long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getUtf8String\");\n-        SharedUtils.checkAddress(this);\n-        return NativeMemorySegmentImpl.EVERYTHING.getUtf8String(toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @CallerSensitive\n-    @ForceInline\n-    public void setUtf8String(long offset, String str) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setUtf8String\");\n-        SharedUtils.checkAddress(this);\n-        NativeMemorySegmentImpl.EVERYTHING.setUtf8String(toRawLongValue() + offset, str);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public byte get(ValueLayout.OfByte layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfByte layout, long offset, byte value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public boolean get(ValueLayout.OfBoolean layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public char get(ValueLayout.OfChar layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfChar layout, long offset, char value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public short get(ValueLayout.OfShort layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfShort layout, long offset, short value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public int get(ValueLayout.OfInt layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfInt layout, long offset, int value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public float get(ValueLayout.OfFloat layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfFloat layout, long offset, float value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public long get(ValueLayout.OfLong layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfLong layout, long offset, long value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public double get(ValueLayout.OfDouble layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfDouble layout, long offset, double value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"get\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"set\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value.address());\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public char getAtIndex(ValueLayout.OfChar layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public short getAtIndex(ValueLayout.OfShort layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public int getAtIndex(ValueLayout.OfInt layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public float getAtIndex(ValueLayout.OfFloat layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public long getAtIndex(ValueLayout.OfLong layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public double getAtIndex(ValueLayout.OfDouble layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"getAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n-    }\n-\n-    @Override\n-    @ForceInline\n-    @CallerSensitive\n-    public void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemoryAddress.class, \"setAtIndex\");\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value.address());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -29,2 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemorySegment;\n@@ -32,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -33,0 +32,2 @@\n+import java.util.Optional;\n+\n@@ -44,5 +45,1 @@\n-    public static final MemorySegment EVERYTHING = new NativeMemorySegmentImpl(0, Long.MAX_VALUE, false, MemorySessionImpl.GLOBAL) {\n-        @Override\n-        void checkBounds(long offset, long length) {\n-            \/\/ do nothing\n-        }\n+    private static final Unsafe unsafe = Unsafe.getUnsafe();\n@@ -50,5 +47,4 @@\n-        @Override\n-        NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n-            throw new IllegalStateException();\n-        }\n-    };\n+    @Override\n+    public long address() {\n+        return min;\n+    }\n@@ -56,1 +52,4 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    @Override\n+    public Optional<Object> array() {\n+        return Optional.empty();\n+    }\n@@ -73,6 +72,0 @@\n-    @Override\n-    public MemoryAddress address() {\n-        checkValidState();\n-        return MemoryAddress.ofLong(unsafeGetOffset());\n-    }\n-\n@@ -145,4 +138,13 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, MemorySession session) {\n-        MemorySessionImpl.toSessionImpl(session).checkValidState();\n-        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, false, session);\n-        return segment;\n+    \/\/ Unsafe native segment factories. These are used by the implementation code, to skip the sanity checks\n+    \/\/ associated with MemorySegment::ofAddress.\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize, MemorySession session) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toSessionImpl(session);\n+        sessionImpl.checkValidState();\n+        return new NativeMemorySegmentImpl(min, bytesSize, false, session);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize) {\n+        return new NativeMemorySegmentImpl(min, bytesSize, false, MemorySession.global());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n@@ -150,1 +150,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n@@ -210,1 +210,1 @@\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -93,1 +92,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()), 0L, MemorySession.global()));\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, MemorySession.global()));\n@@ -110,1 +109,1 @@\n-                        Optional.of(MemorySegment.ofAddress(MemoryAddress.ofLong(addr), 0, MemorySession.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr, 0, MemorySession.global()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -52,1 +51,1 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n+    private static final MethodHandle LONG_TO_ADDRESS_SAFE, LONG_TO_ADDRESS_UNSAFE;\n@@ -56,1 +55,1 @@\n-        = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n+            = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n@@ -65,1 +64,1 @@\n-            ADDRESS_TO_LONG = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+            ADDRESS_TO_LONG = lookup.findVirtual(MemorySegment.class, \"address\",\n@@ -67,2 +66,4 @@\n-            LONG_TO_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n-                    MethodType.methodType(MemoryAddress.class, long.class));\n+            LONG_TO_ADDRESS_SAFE = lookup.findStatic(Utils.class, \"longToAddressSafe\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n+            LONG_TO_ADDRESS_UNSAFE = lookup.findStatic(Utils.class, \"longToAddressUnsafe\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n@@ -70,4 +71,4 @@\n-                lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n-                    MethodType.methodType(long.class, long.class, Supplier.class)),\n-                1,\n-                bitsToBytesThrowOffset);\n+                    lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n+                            MethodType.methodType(long.class, long.class, Supplier.class)),\n+                    1,\n+                    bitsToBytesThrowOffset);\n@@ -83,5 +84,0 @@\n-    public static MemoryAddress alignUp(MemoryAddress ma, long alignment) {\n-        long offset = ma.toRawLongValue();\n-        return ma.addOffset(alignUp(offset, alignment) - offset);\n-    }\n-\n@@ -89,1 +85,1 @@\n-        long offset = ms.address().toRawLongValue();\n+        long offset = ms.address();\n@@ -111,1 +107,1 @@\n-        if (layout.carrier() == MemoryAddress.class) {\n+        if (layout.carrier() == MemorySegment.class) {\n@@ -126,1 +122,1 @@\n-        } else if (layout.carrier() == MemoryAddress.class) {\n+        } else if (layout instanceof ValueLayout.OfAddress addressLayout) {\n@@ -128,2 +124,3 @@\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n-                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n+                    MethodHandles.explicitCastArguments(addressLayout.isUnbounded() ?\n+                            LONG_TO_ADDRESS_UNSAFE : LONG_TO_ADDRESS_SAFE, MethodType.methodType(MemorySegment.class, baseCarrier)));\n@@ -142,0 +139,10 @@\n+    @ForceInline\n+    private static MemorySegment longToAddressSafe(long addr) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, 0);\n+    }\n+\n+    @ForceInline\n+    private static MemorySegment longToAddressUnsafe(long addr) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, Long.MAX_VALUE);\n+    }\n+\n@@ -166,0 +173,8 @@\n+    public static long pointeeSize(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n+            return addressLayout.isUnbounded() ? Long.MAX_VALUE : 0L;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":35,"deletions":20,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -36,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -51,1 +51,1 @@\n-            MethodType type = SharedUtils.inferMethodType(fd, false);\n+            MethodType type = SharedUtils.inferMethodType(fd);\n@@ -53,1 +53,1 @@\n-            handle = SharedUtils.maybeInsertAllocator(handle);\n+            handle = SharedUtils.maybeInsertAllocator(fd, handle);\n@@ -66,1 +66,1 @@\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n+        MethodType type = SharedUtils.inferMethodType(function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -29,2 +29,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -197,1 +195,1 @@\n-     * the allocation operation, or {@link ToSegment} bindings, by providing the {@link MemorySession} that\n+     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link MemorySession} that\n@@ -286,1 +284,0 @@\n-        TO_SEGMENT,\n@@ -337,2 +334,2 @@\n-    static BoxAddress boxAddress() {\n-        return BoxAddress.INSTANCE;\n+    static BoxAddress boxAddressRaw(long size) {\n+        return new BoxAddress(size, false);\n@@ -341,2 +338,2 @@\n-    static UnboxAddress unboxAddress() {\n-        return UnboxAddress.INSTANCE;\n+    static BoxAddress boxAddress(MemoryLayout layout) {\n+        return new BoxAddress(layout.byteSize(), true);\n@@ -345,2 +342,2 @@\n-    static ToSegment toSegment(MemoryLayout layout) {\n-        return new ToSegment(layout.byteSize());\n+    static BoxAddress boxAddress(long byteSize) {\n+        return new BoxAddress(byteSize, true);\n@@ -349,2 +346,2 @@\n-    static ToSegment toSegment(long byteSize) {\n-        return new ToSegment(byteSize);\n+    static UnboxAddress unboxAddress() {\n+        return UnboxAddress.INSTANCE;\n@@ -398,2 +395,2 @@\n-        public Binding.Builder boxAddress() {\n-            bindings.add(Binding.boxAddress());\n+        public Binding.Builder boxAddressRaw(long size) {\n+            bindings.add(Binding.boxAddressRaw(size));\n@@ -403,2 +400,2 @@\n-        public Binding.Builder unboxAddress() {\n-            bindings.add(Binding.unboxAddress());\n+        public Binding.Builder boxAddress(MemoryLayout layout) {\n+            bindings.add(Binding.boxAddress(layout));\n@@ -408,2 +405,2 @@\n-        public Binding.Builder toSegment(MemoryLayout layout) {\n-            bindings.add(Binding.toSegment(layout));\n+        public Binding.Builder unboxAddress() {\n+            bindings.add(Binding.unboxAddress());\n@@ -602,1 +599,1 @@\n-     *     and pushes that onto the operand stack.\n+     * with the given size, and pushes that onto the operand stack\n@@ -615,1 +612,1 @@\n-            SharedUtils.checkType(actualType, Addressable.class);\n+            SharedUtils.checkType(actualType, MemorySegment.class);\n@@ -622,1 +619,1 @@\n-            stack.push(((Addressable)stack.pop()).address().toRawLongValue());\n+            stack.push(((MemorySegment)stack.pop()).address());\n@@ -628,2 +625,2 @@\n-     * Pops a 'long' from the operand stack, converts it to a 'MemoryAddress',\n-     *     and pushes that onto the operand stack.\n+     * Pops a 'long' from the operand stack, converts it to a 'MemorySegment', with the given size and memory session\n+     * (either the context session, or the global session), and pushes that onto the operand stack.\n@@ -631,2 +628,1 @@\n-    record BoxAddress() implements Binding {\n-        static final BoxAddress INSTANCE = new BoxAddress();\n+    record BoxAddress(long size, boolean needsSession) implements Binding {\n@@ -643,29 +639,0 @@\n-            stack.push(MemoryAddress.class);\n-        }\n-\n-        @Override\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(MemoryAddress.ofLong((long) stack.pop()));\n-        }\n-    }\n-\n-    \/**\n-     * TO_SEGMENT([size])\n-     *   Pops a MemoryAddress from the operand stack, and converts it to a MemorySegment\n-     *   with the given size, and pushes that onto the operand stack\n-     *\/\n-    record ToSegment(long size) implements Binding {\n-        private static MemorySegment toSegment(MemoryAddress operand, long size, Context context) {\n-            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size, context.session);\n-        }\n-\n-        @Override\n-        public Tag tag() {\n-            return Tag.TO_SEGMENT;\n-        }\n-\n-        @Override\n-        public void verify(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemoryAddress.class);\n@@ -678,3 +645,3 @@\n-            MemoryAddress operand = (MemoryAddress) stack.pop();\n-            MemorySegment segment = toSegment(operand, size, context);\n-            stack.push(segment);\n+            MemorySession session = needsSession ?\n+                    context.session() : MemorySession.global();\n+            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, session));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":25,"deletions":58,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -29,0 +28,1 @@\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -46,1 +46,0 @@\n-import java.lang.foreign.Addressable;\n@@ -48,1 +47,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n@@ -90,1 +89,1 @@\n-    private static final String ADDRESS_DESC = methodType(MemoryAddress.class).descriptorString();\n+    private static final String ADDRESS_DESC = methodType(long.class).descriptorString();\n@@ -92,2 +91,1 @@\n-    private static final String TO_RAW_LONG_VALUE_DESC = methodType(long.class).descriptorString();\n-    private static final String OF_LONG_DESC = methodType(MemoryAddress.class, long.class).descriptorString();\n+    private static final String OF_LONG_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n@@ -251,6 +249,2 @@\n-        return popType(expected, ASSERT_EQUALS);\n-    }\n-\n-    private Class<?> popType(Class<?> expected, BiPredicate<Class<?>, Class<?>> typePredicate) {\n-        Class<?> found;\n-        if (!typePredicate.test(expected, found = typeStack.pop())) {\n+        Class<?> found = typeStack.pop();\n+        if (!expected.equals(found)) {\n@@ -264,3 +258,0 @@\n-    private static final BiPredicate<Class<?>, Class<?>> ASSERT_EQUALS = Class::equals;\n-    private static final BiPredicate<Class<?>, Class<?>> ASSERT_ASSIGNABLE = Class::isAssignableFrom;\n-\n@@ -291,1 +282,1 @@\n-                if (shouldAcquire(callerMethodType.parameterType(i))) {\n+                if (shouldAcquire(i)) {\n@@ -446,1 +437,4 @@\n-        return callingSequence.argumentBindings().anyMatch(Binding.ToSegment.class::isInstance);\n+        return callingSequence.argumentBindings()\n+                .filter(Binding.BoxAddress.class::isInstance)\n+                .map(Binding.BoxAddress.class::cast)\n+                .anyMatch(Binding.BoxAddress::needsSession);\n@@ -449,2 +443,14 @@\n-    private static boolean shouldAcquire(Class<?> type) {\n-        return type == Addressable.class;\n+    private boolean shouldAcquire(int paramIndex) {\n+        if (!callingSequence.forDowncall() || \/\/ we only acquire in downcalls\n+                paramIndex == 0) { \/\/ the first parameter in a downcall is SegmentAllocator\n+            return false;\n+        }\n+\n+        \/\/ if call needs return buffer, the descriptor has an extra leading layout\n+        int offset = callingSequence.needsReturnBuffer() ? 0 : 1;\n+        MemoryLayout paramLayout =  callingSequence.functionDesc()\n+                                              .argumentLayouts()\n+                                              .get(paramIndex - offset);\n+\n+        \/\/ is this an address layout?\n+        return paramLayout instanceof ValueLayout.OfAddress;\n@@ -469,1 +475,1 @@\n-                case BOX_ADDRESS -> emitBoxAddress();\n+                case BOX_ADDRESS -> emitBoxAddress((Binding.BoxAddress) binding);\n@@ -471,1 +477,0 @@\n-                case TO_SEGMENT -> emitToSegment((Binding.ToSegment) binding);\n@@ -486,1 +491,1 @@\n-        if (shouldAcquire(highLevelType)) {\n+        if (shouldAcquire(paramIndex)) {\n@@ -573,14 +578,2 @@\n-    private void emitToSegment(Binding.ToSegment binding) {\n-        long size = binding.size();\n-        popType(MemoryAddress.class);\n-\n-        emitToRawLongValue();\n-        emitConst(size);\n-        emitLoadInternalSession();\n-        emitInvokeStatic(MemoryAddressImpl.class, \"ofLongUnchecked\", OF_LONG_UNCHECKED_DESC);\n-\n-        pushType(MemorySegment.class);\n-    }\n-\n-    private void emitToRawLongValue() {\n-        emitInvokeInterface(MemoryAddress.class, \"toRawLongValue\", TO_RAW_LONG_VALUE_DESC);\n+    private void emitAddress() {\n+        emitInvokeInterface(MemorySegment.class, \"address\", ADDRESS_DESC);\n@@ -589,1 +582,1 @@\n-    private void emitBoxAddress() {\n+    private void emitBoxAddress(Binding.BoxAddress boxAddress) {\n@@ -591,2 +584,8 @@\n-        emitInvokeStatic(MemoryAddress.class, \"ofLong\", OF_LONG_DESC);\n-        pushType(MemoryAddress.class);\n+        emitConst(boxAddress.size());\n+        if (needsSession()) {\n+            emitLoadInternalSession();\n+            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_UNCHECKED_DESC);\n+        } else {\n+            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_DESC);\n+        }\n+        pushType(MemorySegment.class);\n@@ -680,3 +679,2 @@\n-        popType(Addressable.class, ASSERT_ASSIGNABLE);\n-        emitInvokeInterface(Addressable.class, \"address\", ADDRESS_DESC);\n-        emitToRawLongValue();\n+        popType(MemorySegment.class);\n+        emitAddress();\n@@ -754,1 +752,1 @@\n-        } else if (type == MemoryAddress.class) {\n+        } else if (type == MemorySegment.class) {\n@@ -778,1 +776,1 @@\n-        } else if (type == MemoryAddress.class) {\n+        } else if (type == MemorySegment.class) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":42,"deletions":44,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.Addressable;\n@@ -99,1 +98,1 @@\n-            addArgumentBinding(0, Addressable.class, ValueLayout.ADDRESS, List.of(\n+            addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n@@ -114,2 +113,1 @@\n-                        Binding.boxAddress(),\n-                        Binding.toSegment(returnBufferSize)));\n+                        Binding.boxAddress(returnBufferSize)));\n@@ -198,1 +196,0 @@\n-        \/\/TO_SEGMENT,\n@@ -226,1 +223,0 @@\n-        TO_SEGMENT,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.Addressable;\n@@ -63,1 +62,1 @@\n-                    methodType(void.class, Addressable.class));\n+                    methodType(void.class, MemorySegment.class));\n@@ -113,1 +112,1 @@\n-        assert handle.type().parameterType(1) == Addressable.class;\n+        assert handle.type().parameterType(1) == MemorySegment.class;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,3 +31,1 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -38,0 +36,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -39,1 +38,0 @@\n-import java.lang.foreign.Addressable;\n@@ -43,1 +41,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -75,1 +72,0 @@\n-    private static final MethodHandle MH_BASEADDRESS;\n@@ -84,2 +80,0 @@\n-            MH_BASEADDRESS = lookup.findVirtual(MemorySegment.class, \"address\",\n-                    methodType(MemoryAddress.class));\n@@ -87,1 +81,1 @@\n-                    methodType(MemoryAddress.class, MemoryAddress.class, MemorySegment.class));\n+                    methodType(MemorySegment.class, MemorySegment.class, MemorySegment.class));\n@@ -155,1 +149,1 @@\n-     * Takes a MethodHandle that takes an input buffer as a first argument (a MemoryAddress), and returns nothing,\n+     * Takes a MethodHandle that takes an input buffer as a first argument (a MemorySegment), and returns nothing,\n@@ -169,2 +163,2 @@\n-        if (handle.type().parameterType(2) != MemoryAddress.class)\n-            throw new IllegalArgumentException(\"MemoryAddress expected as third param: \" + handle.type());\n+        if (handle.type().parameterType(2) != MemorySegment.class)\n+            throw new IllegalArgumentException(\"MemorySegment expected as third param: \" + handle.type());\n@@ -175,6 +169,5 @@\n-        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemoryAddress, ...) MemorySegment\n-        handle = collectArguments(handle, 3, MH_BASEADDRESS); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemorySegment, ...) MemorySegment\n-        handle = mergeArguments(handle, 0, 3);  \/\/ (MemorySegment, Addressable, SegmentAllocator, ...) MemorySegment\n-        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator, Addressable, SegmentAllocator, ...) MemoryAddress\n-        handle = mergeArguments(handle, 0, 2);  \/\/ (SegmentAllocator, Addressable, ...) MemoryAddress\n-        handle = swapArguments(handle, 0, 1); \/\/ (Addressable, SegmentAllocator, ...) MemoryAddress\n+        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, MemorySegment, SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 3);  \/\/ (MemorySegment, MemorySegment, SegmentAllocator, ...) MemorySegment\n+        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator, MemorySegment, SegmentAllocator, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 2);  \/\/ (SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = swapArguments(handle, 0, 1); \/\/ (MemorySegment, SegmentAllocator, ...) MemorySegment\n@@ -186,1 +179,1 @@\n-     * (a MemoryAddress), and upon invocation, copies the contents of the returned MemorySegment into the input buffer\n+     * (a MemorySegment), and upon invocation, copies the contents of the returned MemorySegment into the input buffer\n@@ -196,1 +189,1 @@\n-        target = collectArguments(MH_BUFFER_COPY, 1, target); \/\/ (MemoryAddress, ...) MemoryAddress\n+        target = collectArguments(MH_BUFFER_COPY, 1, target); \/\/ (MemorySegment, ...) MemorySegment\n@@ -203,1 +196,1 @@\n-            target = target.asType(target.type().changeReturnType(Addressable.class));\n+            target = target.asType(target.type().changeReturnType(MemorySegment.class));\n@@ -209,3 +202,2 @@\n-    private static MemoryAddress bufferCopy(MemoryAddress dest, MemorySegment buffer) {\n-        MemoryAddressImpl.ofLongUnchecked(dest.toRawLongValue(), buffer.byteSize()).copyFrom(buffer);\n-        return dest;\n+    private static MemorySegment bufferCopy(MemorySegment dest, MemorySegment buffer) {\n+        return dest.copyFrom(buffer);\n@@ -325,2 +317,2 @@\n-    public static MethodHandle maybeInsertAllocator(MethodHandle handle) {\n-        if (!handle.type().returnType().equals(MemorySegment.class)) {\n+    public static MethodHandle maybeInsertAllocator(FunctionDescriptor descriptor, MethodHandle handle) {\n+        if (descriptor.returnLayout().isEmpty() || !(descriptor.returnLayout().get() instanceof GroupLayout)) {\n@@ -333,9 +325,2 @@\n-    public static void checkSymbol(Addressable symbol) {\n-        checkAddressable(symbol, \"Symbol is NULL\");\n-    }\n-\n-    public static void checkAddress(MemoryAddress address) {\n-        checkAddressable(address, \"Address is NULL\");\n-    }\n-\n-    private static void checkAddressable(Addressable symbol, String msg) {\n+    @ForceInline\n+    public static void checkSymbol(MemorySegment symbol) {\n@@ -343,1 +328,1 @@\n-        if (symbol.address().toRawLongValue() == 0)\n+        if (symbol.equals(MemorySegment.NULL))\n@@ -356,1 +341,1 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n@@ -358,4 +343,4 @@\n-            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma, session);\n-            case SysV -> SysVx64Linker.newVaListOfAddress(ma, session);\n-            case LinuxAArch64 -> LinuxAArch64Linker.newVaListOfAddress(ma, session);\n-            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(ma, session);\n+            case Win64 -> Windowsx64Linker.newVaListOfAddress(address, session);\n+            case SysV -> SysVx64Linker.newVaListOfAddress(address, session);\n+            case LinuxAArch64 -> LinuxAArch64Linker.newVaListOfAddress(address, session);\n+            case MacOsAArch64 -> MacOsAArch64Linker.newVaListOfAddress(address, session);\n@@ -375,1 +360,1 @@\n-        if (!expectedType.isAssignableFrom(actualType)) {\n+        if (expectedType != actualType) {\n@@ -404,1 +389,1 @@\n-    public static non-sealed class EmptyVaList implements VaList, Scoped {\n+    public static non-sealed class EmptyVaList implements VaList {\n@@ -406,1 +391,1 @@\n-        private final MemoryAddress address;\n+        private final MemorySegment address;\n@@ -408,1 +393,1 @@\n-        public EmptyVaList(MemoryAddress address) {\n+        public EmptyVaList(MemorySegment address) {\n@@ -432,1 +417,1 @@\n-        public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n+        public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n@@ -446,5 +431,0 @@\n-        @Override\n-        public MemorySession session() {\n-            return MemorySessionImpl.GLOBAL;\n-        }\n-\n@@ -457,1 +437,1 @@\n-        public MemoryAddress address() {\n+        public MemorySegment segment() {\n@@ -538,1 +518,1 @@\n-    public static MethodType inferMethodType(FunctionDescriptor descriptor, boolean upcall) {\n+    public static MethodType inferMethodType(FunctionDescriptor descriptor) {\n@@ -540,1 +520,1 @@\n-                carrierFor(descriptor.returnLayout().get(), upcall) : void.class);\n+                carrierFor(descriptor.returnLayout().get()) : void.class);\n@@ -542,1 +522,1 @@\n-            type = type.appendParameterTypes(carrierFor(argLayout, !upcall));\n+            type = type.appendParameterTypes(carrierFor(argLayout));\n@@ -547,1 +527,1 @@\n-    static Class<?> carrierFor(MemoryLayout layout, boolean forArg) {\n+    static Class<?> carrierFor(MemoryLayout layout) {\n@@ -549,2 +529,1 @@\n-            return (forArg && valueLayout.carrier().equals(MemoryAddress.class)) ?\n-                    Addressable.class : valueLayout.carrier();\n+            return valueLayout.carrier();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":37,"deletions":58,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -58,1 +57,1 @@\n-        return MemorySegment.ofAddress(MemoryAddress.ofLong(entry), 0, session);\n+        return MemorySegment.ofAddress(entry, 0, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -132,1 +131,1 @@\n-            csb.addArgumentBindings(MemoryAddress.class, AArch64.C_POINTER,\n+            csb.addArgumentBindings(MemorySegment.class, AArch64.C_POINTER,\n@@ -421,1 +420,1 @@\n-                .boxAddress()\n+                .boxAddressRaw(Long.MAX_VALUE)\n@@ -458,2 +457,1 @@\n-                            .boxAddress()\n-                            .toSegment(layout);\n+                            .boxAddress(layout);\n@@ -489,1 +487,1 @@\n-                            .boxAddress();\n+                            .boxAddressRaw(Utils.pointeeSize(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -31,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -51,1 +51,1 @@\n-        } else if (carrier == MemoryAddress.class) {\n+        } else if (carrier == MemorySegment.class) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -70,2 +69,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return LinuxAArch64VaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return LinuxAArch64VaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -52,1 +51,1 @@\n-public non-sealed class LinuxAArch64VaList implements VaList, Scoped {\n+public non-sealed class LinuxAArch64VaList implements VaList {\n@@ -120,9 +119,5 @@\n-    private static LinuxAArch64VaList readFromSegment(MemorySegment segment) {\n-        MemorySegment stack = MemorySegment.ofAddress(stackPtr(segment),\n-                Long.MAX_VALUE, segment.session()); \/\/ size unknown\n-\n-        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).addOffset(-MAX_GP_OFFSET),\n-                MAX_GP_OFFSET, segment.session());\n-\n-        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n-                MAX_FP_OFFSET, segment.session());\n+    private static LinuxAArch64VaList readFromAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n+        MemorySegment stack = stackPtr(segment); \/\/ size unknown\n+        MemorySegment gpRegsArea = grTop(segment).asSlice(-MAX_GP_OFFSET, MAX_GP_OFFSET);\n+        MemorySegment fpRegsArea = vrTop(segment).asSlice(-MAX_FP_OFFSET, MAX_FP_OFFSET);\n@@ -132,1 +127,1 @@\n-    private static MemoryAddress emptyListAddress() {\n+    private static MemorySegment emptyListAddress() {\n@@ -134,7 +129,5 @@\n-        MemorySession session = MemorySession.openImplicit();\n-        session.addCloseAction(() -> U.freeMemory(ptr));\n-        MemorySegment ms = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n-                LAYOUT.byteSize(), session);\n-        VH_stack.set(ms, MemoryAddress.NULL);\n-        VH_gr_top.set(ms, MemoryAddress.NULL);\n-        VH_vr_top.set(ms, MemoryAddress.NULL);\n+        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n+        ms.session().addCloseAction(() -> U.freeMemory(ptr));\n+        VH_stack.set(ms, MemorySegment.NULL);\n+        VH_gr_top.set(ms, MemorySegment.NULL);\n+        VH_vr_top.set(ms, MemorySegment.NULL);\n@@ -143,1 +136,1 @@\n-        return ms.address();\n+        return ms;\n@@ -150,1 +143,1 @@\n-    private MemoryAddress grTop() {\n+    private MemorySegment grTop() {\n@@ -154,2 +147,2 @@\n-    private static MemoryAddress grTop(MemorySegment segment) {\n-        return (MemoryAddress) VH_gr_top.get(segment);\n+    private static MemorySegment grTop(MemorySegment segment) {\n+        return (MemorySegment) VH_gr_top.get(segment);\n@@ -158,1 +151,1 @@\n-    private MemoryAddress vrTop() {\n+    private MemorySegment vrTop() {\n@@ -162,2 +155,2 @@\n-    private static MemoryAddress vrTop(MemorySegment segment) {\n-        return (MemoryAddress) VH_vr_top.get(segment);\n+    private static MemorySegment vrTop(MemorySegment segment) {\n+        return (MemorySegment) VH_vr_top.get(segment);\n@@ -178,2 +171,2 @@\n-    private static MemoryAddress stackPtr(MemorySegment segment) {\n-        return (MemoryAddress) VH_stack.get(segment);\n+    private static MemorySegment stackPtr(MemorySegment segment) {\n+        return (MemorySegment) VH_stack.get(segment);\n@@ -182,1 +175,1 @@\n-    private MemoryAddress stackPtr() {\n+    private MemorySegment stackPtr() {\n@@ -188,1 +181,1 @@\n-        VH_stack.set(segment, stack.address());\n+        VH_stack.set(segment, stack);\n@@ -220,1 +213,1 @@\n-            long addr = stack.address().toRawLongValue();\n+            long addr = stack.address();\n@@ -250,2 +243,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -321,1 +314,1 @@\n-                    MemoryAddress ptr = (MemoryAddress) ptrReader.get(\n+                    MemorySegment ptr = (MemorySegment) ptrReader.get(\n@@ -325,1 +318,1 @@\n-                    MemorySegment slice = MemorySegment.ofAddress(ptr, layout.byteSize(), session());\n+                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.session());\n@@ -369,1 +362,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -396,7 +389,2 @@\n-    public static VaList ofAddress(MemoryAddress ma, MemorySession session) {\n-        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), session));\n-    }\n-\n-    @Override\n-    public MemorySession session() {\n-        return segment.session();\n+    public static VaList ofAddress(long address, MemorySession session) {\n+        return readFromAddress(address, session);\n@@ -407,1 +395,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = segment.session().allocate(LAYOUT);\n@@ -413,2 +401,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -454,2 +442,2 @@\n-            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, session);\n-            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, session);\n+            this.gpRegs = session.allocate(LAYOUT_GP_REGS);\n+            this.fpRegs = session.allocate(LAYOUT_FP_REGS);\n@@ -474,2 +462,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -521,1 +509,1 @@\n-                                   valueSegment.address());\n+                                   valueSegment);\n@@ -548,2 +536,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MemorySegment vaListSegment = allocator.allocate(LAYOUT);\n+            MemorySegment vaListSegment = session.allocate(LAYOUT);\n@@ -554,1 +541,1 @@\n-                stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n+                stackArgsSegment = session.allocate(stackArgsSize, 16);\n@@ -564,1 +551,1 @@\n-                stackArgsSegment = MemorySegment.ofAddress(MemoryAddress.NULL, 0, session);\n+                stackArgsSegment = MemorySegment.NULL;\n@@ -567,3 +554,3 @@\n-            VH_gr_top.set(vaListSegment, gpRegs.asSlice(gpRegs.byteSize()).address());\n-            VH_vr_top.set(vaListSegment, fpRegs.asSlice(fpRegs.byteSize()).address());\n-            VH_stack.set(vaListSegment, stackArgsSegment.address());\n+            VH_gr_top.set(vaListSegment, gpRegs.asSlice(gpRegs.byteSize()));\n+            VH_vr_top.set(vaListSegment, fpRegs.asSlice(fpRegs.byteSize()));\n+            VH_stack.set(vaListSegment, stackArgsSegment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":45,"deletions":58,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -70,2 +69,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return MacOsAArch64VaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return MacOsAArch64VaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -48,1 +47,1 @@\n-public non-sealed class MacOsAArch64VaList implements VaList, Scoped {\n+public non-sealed class MacOsAArch64VaList implements VaList {\n@@ -52,1 +51,1 @@\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n@@ -55,1 +54,0 @@\n-    private final MemorySession session;\n@@ -57,1 +55,1 @@\n-    private MacOsAArch64VaList(MemorySegment segment, MemorySession session) {\n+    private MacOsAArch64VaList(MemorySegment segment) {\n@@ -59,1 +57,0 @@\n-        this.session = session;\n@@ -82,2 +79,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -104,2 +101,2 @@\n-                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), session());\n+                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n@@ -140,1 +137,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -156,3 +153,3 @@\n-    static MacOsAArch64VaList ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, session);\n-        return new MacOsAArch64VaList(segment, session);\n+    static MacOsAArch64VaList ofAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n+        return new MacOsAArch64VaList(segment);\n@@ -165,5 +162,0 @@\n-    @Override\n-    public MemorySession session() {\n-        return session;\n-    }\n-\n@@ -172,2 +164,2 @@\n-        sessionImpl().checkValidState();\n-        return new MacOsAArch64VaList(segment, session);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        return new MacOsAArch64VaList(segment);\n@@ -177,2 +169,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -214,2 +206,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -228,2 +220,0 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-\n@@ -231,1 +221,1 @@\n-            MemorySegment segment = allocator.allocate(allocationSize);\n+            MemorySegment segment = session.allocate(allocationSize);\n@@ -240,1 +230,1 @@\n-                            MemorySegment copy = allocator.allocate(arg.layout);\n+                            MemorySegment copy = session.allocate(arg.layout);\n@@ -242,1 +232,1 @@\n-                            VH_address.set(cursor, copy.address());\n+                            VH_address.set(cursor, copy);\n@@ -257,1 +247,1 @@\n-            return new MacOsAArch64VaList(segment, session);\n+            return new MacOsAArch64VaList(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":21,"deletions":31,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -37,0 +38,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -39,1 +41,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -42,1 +43,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -97,1 +97,1 @@\n-            Class<?> carrier = MemoryAddress.class;\n+            Class<?> carrier = MemorySegment.class;\n@@ -334,1 +334,1 @@\n-                            .boxAddress();\n+                            .boxAddressRaw(Utils.pointeeSize(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -48,1 +47,1 @@\n-public non-sealed class SysVVaList implements VaList, Scoped {\n+public non-sealed class SysVVaList implements VaList {\n@@ -130,1 +129,2 @@\n-    private static SysVVaList readFromSegment(MemorySegment segment) {\n+    private static SysVVaList readFromAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n@@ -136,1 +136,1 @@\n-    private static MemoryAddress emptyListAddress() {\n+    private static MemorySegment emptyListAddress() {\n@@ -138,4 +138,2 @@\n-        MemorySession session = MemorySession.openImplicit();\n-        session.addCloseAction(() -> U.freeMemory(ptr));\n-        MemorySegment base = MemorySegment.ofAddress(MemoryAddress.ofLong(ptr),\n-                LAYOUT.byteSize(), session);\n+        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n+        base.session().addCloseAction(() -> U.freeMemory(ptr));\n@@ -144,3 +142,3 @@\n-        VH_overflow_arg_area.set(base, MemoryAddress.NULL);\n-        VH_reg_save_area.set(base, MemoryAddress.NULL);\n-        return base.address();\n+        VH_overflow_arg_area.set(base, MemorySegment.NULL);\n+        VH_reg_save_area.set(base, MemorySegment.NULL);\n+        return base;\n@@ -170,2 +168,2 @@\n-        return MemorySegment.ofAddress(((MemoryAddress)VH_reg_save_area.get(segment)),\n-                LAYOUT_REG_SAVE_AREA.byteSize(), segment.session());\n+        return ((MemorySegment)VH_reg_save_area.get(segment))\n+                .asSlice(0, LAYOUT_REG_SAVE_AREA.byteSize());\n@@ -175,2 +173,1 @@\n-        return MemorySegment.ofAddress(((MemoryAddress)VH_overflow_arg_area.get(segment)),\n-                Long.MAX_VALUE, segment.session()); \/\/ size unknown\n+        return (MemorySegment)VH_overflow_arg_area.get(segment); \/\/ size unknown\n@@ -182,1 +179,1 @@\n-            long addr = overflowArgArea.address().toRawLongValue();\n+            long addr = overflowArgArea.address();\n@@ -190,1 +187,1 @@\n-        VH_overflow_arg_area.set(segment, overflowArgArea.address());\n+        VH_overflow_arg_area.set(segment, overflowArgArea);\n@@ -217,2 +214,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -310,1 +307,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -330,7 +327,2 @@\n-    public static VaList ofAddress(MemoryAddress ma, MemorySession session) {\n-        return readFromSegment(MemorySegment.ofAddress(ma, LAYOUT.byteSize(), session));\n-    }\n-\n-    @Override\n-    public MemorySession session() {\n-        return segment.session();\n+    public static VaList ofAddress(long address, MemorySession session) {\n+        return readFromAddress(address, session);\n@@ -341,1 +333,1 @@\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.session());\n+        MemorySegment copy = segment.session().allocate(LAYOUT);\n@@ -347,2 +339,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -375,1 +367,1 @@\n-            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, session);\n+            this.reg_save_area = session.allocate(LAYOUT_REG_SAVE_AREA);\n@@ -394,2 +386,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -454,2 +446,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MemorySegment vaListSegment = allocator.allocate(LAYOUT);\n+            MemorySegment vaListSegment = session.allocate(LAYOUT);\n@@ -460,1 +451,1 @@\n-                stackArgsSegment = allocator.allocate(stackArgsSize, 16);\n+                stackArgsSegment = session.allocate(stackArgsSize, 16);\n@@ -466,1 +457,1 @@\n-                    if (arg.value instanceof MemorySegment) {\n+                    if (arg.layout instanceof GroupLayout) {\n@@ -475,1 +466,1 @@\n-                stackArgsSegment = MemorySegment.ofAddress(MemoryAddress.NULL, 0, session);\n+                stackArgsSegment = MemorySegment.NULL;\n@@ -479,2 +470,2 @@\n-            VH_overflow_arg_area.set(vaListSegment, stackArgsSegment.address());\n-            VH_reg_save_area.set(vaListSegment, reg_save_area.address());\n+            VH_overflow_arg_area.set(vaListSegment, stackArgsSegment);\n+            VH_reg_save_area.set(vaListSegment, reg_save_area);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":31,"deletions":40,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -31,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -33,1 +33,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -68,2 +67,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return SysVVaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return SysVVaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -30,0 +29,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -116,1 +116,1 @@\n-        } else if (carrier == MemoryAddress.class) {\n+        } else if (carrier == MemorySegment.class) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -40,1 +41,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -43,1 +43,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -107,1 +106,1 @@\n-            Class<?> carrier = MemoryAddress.class;\n+            Class<?> carrier = MemorySegment.class;\n@@ -278,2 +277,1 @@\n-                            .boxAddress()\n-                            .toSegment(layout);\n+                            .boxAddress(layout);\n@@ -285,1 +283,1 @@\n-                            .boxAddress();\n+                            .boxAddressRaw(Utils.pointeeSize(layout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -30,0 +29,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -60,1 +60,1 @@\n-        } else if (carrier == MemoryAddress.class) {\n+        } else if (carrier == MemorySegment.class) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.foreign.Scoped;\n@@ -39,1 +38,0 @@\n-import java.util.stream.Stream;\n@@ -59,1 +57,1 @@\n-public non-sealed class WinVaList implements VaList, Scoped {\n+public non-sealed class WinVaList implements VaList {\n@@ -63,1 +61,1 @@\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemoryAddress.NULL);\n+    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n@@ -66,1 +64,0 @@\n-    private final MemorySession session;\n@@ -68,1 +65,1 @@\n-    private WinVaList(MemorySegment segment, MemorySession session) {\n+    private WinVaList(MemorySegment segment) {\n@@ -70,1 +67,0 @@\n-        this.session = session;\n@@ -93,2 +89,2 @@\n-    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemoryAddress) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n+        return (MemorySegment) read(layout);\n@@ -115,2 +111,2 @@\n-                    MemoryAddress structAddr = (MemoryAddress) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr, layout.byteSize(), session());\n+                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n+                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.session());\n@@ -142,1 +138,1 @@\n-        sessionImpl().checkValidState();\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n@@ -150,3 +146,2 @@\n-    static WinVaList ofAddress(MemoryAddress addr, MemorySession session) {\n-        MemorySegment segment = MemorySegment.ofAddress(addr, Long.MAX_VALUE, session);\n-        return new WinVaList(segment, session);\n+    static WinVaList ofAddress(long address, MemorySession session) {\n+        return new WinVaList(MemorySegment.ofAddress(address, Long.MAX_VALUE, session));\n@@ -159,5 +154,0 @@\n-    @Override\n-    public MemorySession session() {\n-        return session;\n-    }\n-\n@@ -166,2 +156,2 @@\n-        sessionImpl().checkValidState();\n-        return new WinVaList(segment, session);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        return new WinVaList(segment);\n@@ -171,2 +161,2 @@\n-    public MemoryAddress address() {\n-        return segment.address();\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -208,2 +198,2 @@\n-        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n-            return arg(layout, value.address());\n+        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n+            return arg(layout, value);\n@@ -221,2 +211,2 @@\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-            MemorySegment segment = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size());\n+\n+            MemorySegment segment = session.allocate(VA_SLOT_SIZE_BYTES * args.size());\n@@ -231,1 +221,1 @@\n-                            MemorySegment copy = allocator.allocate(arg.layout);\n+                            MemorySegment copy = session.allocate(arg.layout);\n@@ -233,1 +223,1 @@\n-                            VH_address.set(cursor, copy.address());\n+                            VH_address.set(cursor, copy);\n@@ -246,1 +236,1 @@\n-            return new WinVaList(segment, session);\n+            return new WinVaList(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":21,"deletions":31,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -67,2 +66,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma, MemorySession session) {\n-        return WinVaList.ofAddress(ma, session);\n+    public static VaList newVaListOfAddress(long address, MemorySession session) {\n+        return WinVaList.ofAddress(address, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -29,1 +28,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -398,1 +396,1 @@\n-                        assertEquals(o, segment.address());\n+                        assertEquals(o, segment);\n@@ -404,1 +402,1 @@\n-            return segment.address();\n+            return segment;\n@@ -450,1 +448,1 @@\n-    static Class<?> carrier(MemoryLayout layout, boolean param) {\n+    static Class<?> carrier(MemoryLayout layout) {\n@@ -453,3 +451,1 @@\n-        } if (isPointer(layout)) {\n-            return param ? Addressable.class : MemoryAddress.class;\n-        } else if (layout instanceof ValueLayout valueLayout) {\n+        } if (layout instanceof ValueLayout valueLayout) {\n@@ -462,1 +458,1 @@\n-    MethodHandle downcallHandle(Linker abi, Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+    MethodHandle downcallHandle(Linker abi, MemorySegment symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -67,1 +66,1 @@\n-        Addressable addr;\n+        MemorySegment addr;\n@@ -74,1 +73,1 @@\n-    private static Addressable loadLibrary(MemorySession session) {\n+    private static MemorySegment loadLibrary(MemorySession session) {\n@@ -81,1 +80,1 @@\n-    private static void callFunc(Addressable addr) {\n+    private static void callFunc(MemorySegment addr) {\n@@ -129,1 +128,1 @@\n-        Addressable addr = loadLibrary(session);\n+        MemorySegment addr = loadLibrary(session);\n@@ -149,1 +148,1 @@\n-        final Addressable addr;\n+        final MemorySegment addr;\n@@ -151,1 +150,1 @@\n-        LibraryAccess(Addressable addr) {\n+        LibraryAccess(MemorySegment addr) {\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -30,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n@@ -47,1 +47,1 @@\n-        return layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemoryAddress.class;\n+        return layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemorySegment.class;\n@@ -84,1 +84,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n@@ -89,1 +89,1 @@\n-            LINKER.defaultLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.defaultLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(C_POINTER));\n@@ -92,1 +92,1 @@\n-            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n@@ -94,1 +94,1 @@\n-    public static void freeMemory(Addressable address) {\n+    public static void freeMemory(MemorySegment address) {\n@@ -102,1 +102,1 @@\n-    public static MemoryAddress allocateMemory(long size) {\n+    public static MemorySegment allocateMemory(long size) {\n@@ -104,1 +104,1 @@\n-            return (MemoryAddress)MALLOC.invokeExact(size);\n+            return (MemorySegment) MALLOC.invokeExact(size);\n@@ -110,1 +110,1 @@\n-    public static Addressable findNativeOrThrow(String name) {\n+    public static MemorySegment findNativeOrThrow(String name) {\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -36,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemoryLayout;\n@@ -113,1 +112,1 @@\n-        assertFalse(list.session().isAlive());\n+        assertFalse(list.segment().session().isAlive());\n@@ -118,1 +117,1 @@\n-        handle.invokeExact((Addressable)list);\n+        handle.invokeExact(list.segment());\n@@ -133,1 +132,1 @@\n-        handle.invokeExact((Addressable)upcall);\n+        handle.invokeExact(upcall);\n@@ -146,1 +145,1 @@\n-            handle.invoke(list, sessionChecker(session));\n+            handle.invokeExact(list.segment(), sessionChecker(session));\n@@ -158,1 +157,1 @@\n-            handle.invoke(segment, sessionChecker(session));\n+            handle.invokeExact(segment, sessionChecker(session));\n@@ -171,1 +170,1 @@\n-            handle.invoke(upcall, sessionChecker(session));\n+            handle.invokeExact(upcall, sessionChecker(session));\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -156,3 +156,1 @@\n-                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER))\n-                .asType(MethodType.methodType(MemoryAddress.class, MemorySegment.class, MemorySegment.class)); \/\/ exact signature match\n-\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));\n@@ -185,1 +183,1 @@\n-        final static Addressable printfAddr = abi.defaultLookup().lookup(\"printf\").get();\n+        final static MemorySegment printfAddr = abi.defaultLookup().lookup(\"printf\").get();\n@@ -193,1 +191,1 @@\n-                        Linker.upcallType(qsortComparFunction));\n+                        Linker.methodType(qsortComparFunction));\n@@ -200,1 +198,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -204,1 +202,1 @@\n-                return ((MemoryAddress)strcat.invokeExact(buf, other)).getUtf8String(0);\n+                return ((MemorySegment)strcat.invokeExact(buf, other)).getUtf8String(0);\n@@ -209,1 +207,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -212,1 +210,1 @@\n-                return (int)strcmp.invoke(ns1, ns2);\n+                return (int)strcmp.invokeExact(ns1, ns2);\n@@ -217,1 +215,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -219,1 +217,1 @@\n-                return (int)puts.invoke(s);\n+                return (int)puts.invokeExact(s);\n@@ -224,1 +222,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -226,1 +224,1 @@\n-                return (int)strlen.invoke(s);\n+                return (int)strlen.invokeExact(s);\n@@ -234,1 +232,1 @@\n-                return new Tm((MemoryAddress)gmtime.invoke(time));\n+                return new Tm((MemorySegment)gmtime.invokeExact(time));\n@@ -245,2 +243,2 @@\n-            Tm(MemoryAddress addr) {\n-                this.base = MemorySegment.ofAddress(addr, SIZE, MemorySession.global());\n+            Tm(MemorySegment addr) {\n+                this.base = addr.asSlice(0, SIZE);\n@@ -280,1 +278,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -284,1 +282,1 @@\n-                Addressable qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n@@ -286,1 +284,1 @@\n-                qsort.invoke(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                qsort.invokeExact(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n@@ -293,1 +291,1 @@\n-        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+        static int qsortCompare(MemorySegment addr1, MemorySegment addr2) {\n@@ -303,1 +301,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -305,1 +303,1 @@\n-                return (int)specializedPrintf(args).invoke(formatStr,\n+                return (int)specializedPrintf(args).invokeExact(formatStr,\n@@ -311,1 +309,1 @@\n-            try (MemorySession session = MemorySession.openConfined()) {\n+            try (var session = MemorySession.openConfined()) {\n@@ -314,1 +312,1 @@\n-                return (int)vprintf.invoke(formatStr, vaList);\n+                return (int)vprintf.invokeExact(formatStr, vaList.segment());\n@@ -320,1 +318,1 @@\n-            MethodType mt = MethodType.methodType(int.class, MemoryAddress.class);\n+            MethodType mt = MethodType.methodType(int.class, MemorySegment.class);\n@@ -390,4 +388,2 @@\n-        STRING(MemoryAddress.class, C_POINTER, \"%s\", session -> {\n-            var segment = MemorySegment.allocateNative(4, session);\n-            segment.setUtf8String(0, \"str\");\n-            return segment.address();\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", session -> {\n+            return session.allocateUtf8String(\"str\");\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":25,"deletions":29,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -122,1 +121,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, seq.byteSize(), MemorySession.global());\n+        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -429,1 +428,1 @@\n-            assertEquals(directBuffer.address(), segment.address().toRawLongValue());\n+            assertEquals(directBuffer.address(), segment.address());\n@@ -495,1 +494,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, MemorySession.openImplicit());\n+        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, MemorySession.openImplicit());\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -28,0 +27,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -39,1 +39,1 @@\n-    Object doCall(Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+    Object doCall(MemorySegment symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/TestDowncallBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.foreign.Addressable;\n@@ -64,1 +63,1 @@\n-        Addressable addr = findNativeOrThrow(fName);\n+        MemorySegment addr = findNativeOrThrow(fName);\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.Addressable;\n@@ -60,1 +59,1 @@\n-        Addressable addr = findNativeOrThrow(\"s\" + fName);\n+        MemorySegment addr = findNativeOrThrow(\"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemoryLayout;\n@@ -36,1 +34,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -41,4 +38,0 @@\n-    private static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements) {\n-        return MemorySegment.ofAddress(addr, numElements * layout.byteSize(), MemorySession.global());\n-    }\n-\n@@ -47,5 +40,4 @@\n-        MemoryAddress addr = allocateMemory(str.length() + 1);\n-        MemorySegment seg = asArray(addr, C_CHAR, str.length() + 1);\n-        seg.copyFrom(MemorySegment.ofArray(str.getBytes()));\n-        seg.set(C_CHAR, str.length(), (byte)0);\n-        assertEquals(str, seg.getUtf8String(0));\n+        MemorySegment addr = allocateMemory(str.length() + 1);\n+        addr.copyFrom(MemorySegment.ofArray(str.getBytes()));\n+        addr.set(C_CHAR, str.length(), (byte)0);\n+        assertEquals(str, addr.getUtf8String(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -127,1 +126,1 @@\n-            layouts.add(new Object[] { testCase.segment, testCase.align, MemoryAddress.ofLong(42), null, ADDRESS_ALIGNED, null });\n+            layouts.add(new Object[] { testCase.segment, testCase.align, MemorySegment.ofAddress(42), null, ADDRESS_ALIGNED, null });\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.Addressable;\n@@ -35,1 +34,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -45,1 +44,1 @@\n-    private static final Addressable DUMMY_TARGET = MemoryAddress.ofLong(1);\n+    private static final MemorySegment DUMMY_TARGET = MemorySegment.ofAddress(1);\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -39,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -40,1 +40,0 @@\n-import java.lang.invoke.MethodType;\n@@ -87,2 +86,1 @@\n-            Addressable ma = findNativeOrThrow(name);\n-            MethodType mt = methodType(carrier, carrier);\n+            MemorySegment ma = findNativeOrThrow(name);\n@@ -96,2 +94,1 @@\n-            Addressable ma = findNativeOrThrow(\"empty\");\n-            MethodType mt = methodType(void.class);\n+            MemorySegment ma = findNativeOrThrow(\"empty\");\n@@ -111,2 +108,1 @@\n-            Addressable ma = findNativeOrThrow(\"identity_va\");\n-            MethodType mt = methodType(int.class, int.class, double.class, int.class, float.class, long.class);\n+            MemorySegment ma = findNativeOrThrow(\"identity_va\");\n@@ -118,2 +114,0 @@\n-            MethodType baseMT = methodType(void.class, int.class, double.class, long.class, float.class, byte.class,\n-                    short.class, char.class);\n@@ -124,2 +118,1 @@\n-                Addressable ma = findNativeOrThrow(\"invoke_high_arity\" + i);\n-                MethodType mt = baseMT.changeReturnType(baseMT.parameterType(i));\n+                MemorySegment ma = findNativeOrThrow(\"invoke_high_arity\" + i);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n@@ -42,9 +42,0 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -57,1 +48,1 @@\n-        ValueLayout newLayout = valueLayoutForCarrier(layout.carrier());\n+        ValueLayout newLayout = MemoryLayout.valueLayout(layout.carrier(), layout.order());\n@@ -59,1 +50,3 @@\n-        newLayout = newLayout.withOrder(layout.order());\n+        if (layout instanceof ValueLayout.OfAddress addressLayout && addressLayout.isUnbounded()) {\n+            newLayout = ((ValueLayout.OfAddress)newLayout).asUnbounded();\n+        }\n@@ -87,24 +80,0 @@\n-\n-    static ValueLayout valueLayoutForCarrier(Class<?> carrier) {\n-        if (carrier == boolean.class) {\n-            return JAVA_BOOLEAN;\n-        } else if (carrier == char.class) {\n-            return JAVA_CHAR;\n-        } else if (carrier == byte.class) {\n-            return JAVA_BYTE;\n-        } else if (carrier == short.class) {\n-            return JAVA_SHORT;\n-        } else if (carrier == int.class) {\n-            return JAVA_INT;\n-        } else if (carrier == long.class) {\n-            return JAVA_LONG;\n-        } else if (carrier == float.class) {\n-            return JAVA_FLOAT;\n-        } else if (carrier == double.class) {\n-            return JAVA_DOUBLE;\n-        } else if (carrier == MemoryAddress.class) {\n-            return ADDRESS;\n-        } else {\n-            throw new UnsupportedOperationException();\n-        }\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-            assertEquals(slice.address().toRawLongValue() - segment.address().toRawLongValue(), expectedBitOffset \/ 8);\n+            assertEquals(slice.address() - segment.address(), expectedBitOffset \/ 8);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -468,2 +467,2 @@\n-            handle.set(segment, r, c, MemoryAddress.ofLong(r + c));\n-            assertEquals(MemoryAddress.ofLong(r + c), (MemoryAddress)handle.get(segment, r, c));\n+            handle.set(segment, r, c, MemorySegment.ofAddress(r + c));\n+            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -120,6 +119,0 @@\n-\n-        static <L extends ValueLayout, X> Accessor<MemoryAddress, X, L> ofAddress(L layout, X value,\n-                                                              SegmentGetter<MemoryAddress, X, L> segmentGetter, SegmentSetter<MemoryAddress, X, L> segmentSetter,\n-                                                              BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n-            return new Accessor<>(MemorySegment::address, layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n-        }\n@@ -133,5 +126,0 @@\n-    @Test(dataProvider = \"addressAccessors\")\n-    public void testAddressAccess(String testName, Accessor<?, ?, ?> accessor) {\n-        accessor.test();\n-    }\n-\n@@ -147,9 +135,0 @@\n-    @Test(dataProvider = \"addressAccessors\")\n-    public void testAddressAccessHyper(String testName, Accessor<?, ?, ?> accessor) {\n-        if (testName.contains(\"index\")) {\n-            accessor.testHyperAligned();\n-        } else {\n-            throw new SkipException(\"Skipping\");\n-        }\n-    }\n-\n@@ -190,1 +169,1 @@\n-                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n@@ -196,1 +175,1 @@\n-                            return MemoryAddress.ofLong(addr);\n+                            return MemorySegment.ofAddress(addr);\n@@ -201,1 +180,1 @@\n-                                nb.putLong(pos, v.toRawLongValue());\n+                                nb.putLong(pos, v.address());\n@@ -203,1 +182,1 @@\n-                                nb.putInt(pos, (int)v.toRawLongValue());\n+                                nb.putInt(pos, (int)v.address());\n@@ -228,1 +207,1 @@\n-                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemorySegment.ofAddress(42),\n@@ -234,1 +213,1 @@\n-                            return MemoryAddress.ofLong(addr);\n+                            return MemorySegment.ofAddress(addr);\n@@ -239,1 +218,1 @@\n-                                nb.putLong(pos * 8, v.toRawLongValue());\n+                                nb.putLong(pos * 8, v.address());\n@@ -241,1 +220,1 @@\n-                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                                nb.putInt(pos * 4, (int)v.address());\n@@ -247,89 +226,0 @@\n-\n-    @DataProvider(name = \"addressAccessors\")\n-    static Object[][] addressAccessors() {\n-        return new Object[][]{\n-\n-                {\"byte\", Accessor.ofAddress(ValueLayout.JAVA_BYTE, (byte) 42,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        ByteBuffer::get, ByteBuffer::put)\n-                },\n-                {\"bool\", Accessor.ofAddress(ValueLayout.JAVA_BOOLEAN, false,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n-                },\n-                {\"char\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n-                },\n-                {\"int\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n-                },\n-                {\"float\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n-                },\n-                {\"long\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n-                },\n-                {\"double\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n-                },\n-                { \"address\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n-                        MemoryAddress::get, MemoryAddress::set,\n-                        (bb, pos) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(pos) : nb.getInt(pos);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, pos, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(pos, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(pos, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                {\"char\/index\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n-                },\n-                {\"int\/index\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n-                },\n-                {\"float\/index\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n-                },\n-                {\"long\/index\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n-                },\n-                {\"double\/index\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n-                },\n-                { \"address\/index\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n-                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n-                        (bb, pos) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, pos, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(pos * 8, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                }\n-        };\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":8,"deletions":118,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -207,1 +206,1 @@\n-                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                { \"address\/offset\", new Accessor<>(MemorySegment.ofAddress(42),\n@@ -213,1 +212,1 @@\n-                            return MemoryAddress.ofLong(addr);\n+                            return MemorySegment.ofAddress(addr);\n@@ -218,1 +217,1 @@\n-                                nb.putLong(8, v.toRawLongValue());\n+                                nb.putLong(8, v.address());\n@@ -220,1 +219,1 @@\n-                                nb.putInt(8, (int)v.toRawLongValue());\n+                                nb.putInt(8, (int)v.address());\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -38,1 +37,3 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n@@ -41,0 +42,2 @@\n+import static org.testng.Assert.*;\n+\n@@ -43,0 +46,4 @@\n+    static {\n+        System.loadLibrary(\"Null\");\n+    }\n+\n@@ -48,1 +55,1 @@\n-                MemoryAddress.NULL,\n+                MemorySegment.NULL,\n@@ -56,1 +63,1 @@\n-        mh.invokeExact((Addressable)MemoryAddress.NULL);\n+        mh.invokeExact(MemorySegment.NULL);\n@@ -59,3 +66,6 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testNULLgetString() {\n-        MemoryAddress.NULL.getUtf8String(0);\n+    @Test\n+    public void testNULLReturn_unbounded() throws Throwable {\n+        MethodHandle mh = LINKER.downcallHandle(SymbolLookup.loaderLookup().lookup(\"get_null\").get(),\n+                FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded()));\n+        MemorySegment ret = (MemorySegment)mh.invokeExact();\n+        assertTrue(ret.equals(MemorySegment.NULL));\n@@ -64,3 +74,6 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testNULLsetString() {\n-        MemoryAddress.NULL.setUtf8String(0, \"hello\");\n+    @Test\n+    public void testNULLReturn_plain() throws Throwable {\n+        MethodHandle mh = LINKER.downcallHandle(SymbolLookup.loaderLookup().lookup(\"get_null\").get(),\n+                FunctionDescriptor.of(ValueLayout.ADDRESS));\n+        MemorySegment ret = (MemorySegment)mh.invokeExact();\n+        assertTrue(ret.equals(MemorySegment.NULL));\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -35,2 +36,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n@@ -115,1 +114,1 @@\n-            Object rawValue = nativeRawExtractor.apply(base.address().toRawLongValue(), (int)i);\n+            Object rawValue = nativeRawExtractor.apply(base.address(), (int)i);\n@@ -170,1 +169,1 @@\n-        MemoryAddress addr = allocateMemory(12);\n+        MemorySegment addr = allocateMemory(12);\n@@ -173,1 +172,1 @@\n-            MemorySegment mallocSegment = MemorySegment.ofAddress(addr, 12, session);\n+            MemorySegment mallocSegment = MemorySegment.ofAddress(addr.address(), 12, session);\n@@ -180,1 +179,1 @@\n-        MemoryAddress addr = allocateMemory(12);\n+        MemorySegment addr = allocateMemory(12);\n@@ -184,1 +183,1 @@\n-            mallocSegment = MemorySegment.ofAddress(addr, 12, session);\n+            mallocSegment = MemorySegment.ofAddress(addr.address(), 12, session);\n@@ -193,1 +192,1 @@\n-        MemoryAddress addr = allocateMemory(4);\n+        MemorySegment addr = allocateMemory(4);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-            MemoryAddress.class,\n@@ -98,1 +97,0 @@\n-            Addressable.class,\n@@ -165,2 +163,0 @@\n-        addDefaultMapping(MemoryAddress.class, MemoryAddress.ofLong(1));\n-        addDefaultMapping(Addressable.class, MemoryAddress.ofLong(1));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -124,1 +123,1 @@\n-        ScopedOperation.ofScope(session -> VaList.ofAddress(MemoryAddress.ofLong(42), session), \"VaList::make\");\n+        ScopedOperation.ofScope(session -> VaList.ofAddress(42, session), \"VaList::make\");\n@@ -128,1 +127,0 @@\n-        ScopedOperation.ofSegment(MemorySegment::address, \"MemorySegment::address\");\n@@ -133,1 +131,0 @@\n-        ScopedOperation.ofVaList(VaList::address, \"VaList::address\");\n@@ -231,1 +228,1 @@\n-            UNSAFE(session -> MemorySegment.ofAddress(MemoryAddress.NULL, 10, session));\n+            UNSAFE(session -> MemorySegment.ofAddress(0, 10, session));\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-                assertEquals(address.address().toRawLongValue() % i, 0);\n+                assertEquals(address.address() % i, 0);\n@@ -262,1 +262,1 @@\n-            scalarAllocations.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { MemorySegment.ofAddress(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -285,1 +285,1 @@\n-            scalarAllocations.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+            scalarAllocations.add(new Object[] { MemorySegment.ofAddress(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n@@ -353,1 +353,1 @@\n-        interface OfAddress extends AllocationFunction<MemoryAddress, ValueLayout.OfAddress> { }\n+        interface OfAddress extends AllocationFunction<MemorySegment, ValueLayout.OfAddress> { }\n@@ -495,28 +495,0 @@\n-\n-        ToArrayHelper<MemoryAddress[]> toAddressArray = new ToArrayHelper<>() {\n-            @Override\n-            public MemoryAddress[] array() {\n-                return switch ((int) ValueLayout.ADDRESS.byteSize()) {\n-                    case 4 -> wrap(toIntArray.array());\n-                    case 8 -> wrap(toLongArray.array());\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            @Override\n-            public MemoryAddress[] toArray(MemorySegment segment, ValueLayout layout) {\n-                return switch ((int)layout.byteSize()) {\n-                    case 4 -> wrap(toIntArray.toArray(segment, layout));\n-                    case 8 -> wrap(toLongArray.toArray(segment, layout));\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            private MemoryAddress[] wrap(int[] ints) {\n-                return IntStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-\n-            private MemoryAddress[] wrap(long[] ints) {\n-                return LongStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-        };\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":4,"deletions":32,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                assertEquals(s1.asOverlappingSlice(slice).get().address(), s1.address().addOffset(offset));\n+                assertEquals(s1.asOverlappingSlice(slice).get().address(), s1.address() + offset);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            assertEquals(segment.address().toRawLongValue() % seq.byteAlignment(), 0);\n+            assertEquals(segment.address() % seq.byteAlignment(), 0);\n@@ -67,4 +67,4 @@\n-            assertEquals(segment.address().toRawLongValue() % 4, 0);\n-            segment = MemorySegment.ofAddress(segment.address(), 0, session);\n-            assertEquals(segment.byteSize(), 0);\n-            assertEquals(segment.address().toRawLongValue() % 4, 0);\n+            assertEquals(segment.address() % 4, 0);\n+            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address(), 0, session);\n+            assertEquals(rawAddress.byteSize(), 0);\n+            assertEquals(rawAddress.address() % 4, 0);\n@@ -124,3 +124,2 @@\n-            assertNotEquals(segment, segment.asSlice(0, 90));\n-            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, session.asNonCloseable()));\n-            assertNotEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n+            assertEquals(segment, segment.asSlice(0, 90));\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, MemorySession.global()));\n@@ -138,1 +137,1 @@\n-        assertNotEquals(segment, segment.asSlice(0, 90));\n+        assertEquals(segment, segment.asSlice(0, 90));\n@@ -274,6 +273,1 @@\n-        try {\n-            segment.address();\n-            assertTrue(segment.isNative());\n-        } catch (UnsupportedOperationException exception) {\n-            assertFalse(segment.isNative());\n-        }\n+        assertEquals(segment.isNative(), !segment.array().isPresent());\n@@ -324,4 +318,5 @@\n-    public void testBigHeapSegments(IntFunction<MemorySegment> heapSegmentFactory, int factor) {\n-        int bigSize = (Integer.MAX_VALUE \/ factor) + 1;\n-        MemorySegment segment = heapSegmentFactory.apply(bigSize);\n-        assertTrue(segment.byteSize() > 0);\n+    public void testVirtualizedBaseAddress(IntFunction<MemorySegment> heapSegmentFactory, int factor) {\n+        MemorySegment segment = heapSegmentFactory.apply(10);\n+        assertEquals(segment.address(), 0); \/\/ base address should be zero (no leaking of impl details)\n+        MemorySegment end = segment.asSlice(segment.byteSize(), 0);\n+        assertEquals(end.address(), segment.byteSize()); \/\/ end address should be equal to segment byte size\n@@ -354,0 +349,1 @@\n+                { (IntFunction<MemorySegment>) size -> MemorySegment.ofArray(new byte[size]), 1 },\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-            String address = (String)ADDR_HANDLE.get(s.address());\n+            String address = (String)ADDR_HANDLE.get(s);\n@@ -66,1 +66,1 @@\n-            ADDR_HANDLE.set(s.address(), \"string\");\n+            ADDR_HANDLE.set(s, \"string\");\n@@ -74,1 +74,1 @@\n-            int address = (int)ADDR_HANDLE.get(s.address());\n+            int address = (int)ADDR_HANDLE.get(s);\n@@ -82,1 +82,1 @@\n-            ADDR_HANDLE.set(s.address(), 1);\n+            ADDR_HANDLE.set(s, 1);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.Linker;\n@@ -39,0 +37,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -64,1 +63,1 @@\n-        Addressable addr = findNativeOrThrow(fName);\n+        MemorySegment addr = findNativeOrThrow(fName);\n@@ -76,1 +75,1 @@\n-            Addressable callback = ABI.upcallStub(mh.asType(Linker.upcallType(callbackDesc)), callbackDesc, session);\n+            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, session);\n@@ -80,2 +79,3 @@\n-            Object res = invoker.type().returnType() == MemorySegment.class\n-                    ? invoker.invoke(allocator, callback)\n+            Object res = (descriptor.returnLayout().isPresent() &&\n+                         descriptor.returnLayout().get() instanceof GroupLayout)\n+                    ? invoker.invoke(session, callback)\n@@ -105,1 +105,1 @@\n-            Addressable invokerSymbol = findNativeOrThrow(symbol);\n+            MemorySegment invokerSymbol = findNativeOrThrow(symbol);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.GroupLayout;\n@@ -37,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -57,1 +58,1 @@\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class, List.class));\n@@ -63,1 +64,1 @@\n-    private static Addressable DUMMY_STUB;\n+    private static MemorySegment DUMMY_STUB;\n@@ -100,1 +101,1 @@\n-    static Addressable makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static MemorySegment makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -106,1 +107,6 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        layouts.addAll(prefix);\n+        for (int i = 0 ; i < params.size() ; i++) {\n+            layouts.add(params.get(i).layout(fields));\n+        }\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size(), layouts);\n@@ -110,1 +116,1 @@\n-            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n+            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i))));\n@@ -116,1 +122,1 @@\n-            Class<?> carrier = carrier(layout, false);\n+            Class<?> carrier = carrier(layout);\n@@ -120,1 +126,1 @@\n-            if (carrier == MemorySegment.class) {\n+            if (layout instanceof GroupLayout) {\n@@ -129,3 +135,2 @@\n-        Class<?> firstCarrier = carrier(firstlayout, true);\n-\n-        if (firstCarrier == MemorySegment.class) {\n+        Class<?> firstCarrier = carrier(firstlayout);\n+        if (firstlayout instanceof GroupLayout) {\n@@ -146,1 +151,1 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg, List<MemoryLayout> layouts) {\n@@ -148,1 +153,1 @@\n-            if (o[i] instanceof MemorySegment) {\n+            if (layouts.get(i) instanceof GroupLayout) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.Linker;\n@@ -39,1 +37,2 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.Linker;\n@@ -43,0 +42,1 @@\n+\n@@ -79,1 +79,1 @@\n-                    MethodType.methodType(void.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(void.class, Object[].class, AtomicReference.class, List.class));\n@@ -85,1 +85,1 @@\n-    static void passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static void passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemoryLayout> layouts) {\n@@ -87,1 +87,1 @@\n-            if (o[i] instanceof MemorySegment) {\n+            if (layouts.get(i) instanceof GroupLayout) {\n@@ -101,1 +101,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs)\n+        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs, upcallDescriptor.argumentLayouts())\n@@ -105,1 +105,1 @@\n-            Addressable upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n@@ -117,1 +117,1 @@\n-                if (upcallType.parameterType(i) == MemorySegment.class) {\n+                if (upcallDescriptor.argumentLayouts().get(i) instanceof GroupLayout) {\n@@ -131,4 +131,4 @@\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class),\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class,\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class,\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class,\n+                    MemorySegment.class, int.class, double.class, MemorySegment.class),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -55,1 +55,1 @@\n-        Addressable addr = findNativeOrThrow(fName);\n+        MemorySegment addr = findNativeOrThrow(fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -37,0 +36,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -56,1 +56,1 @@\n-        Addressable addr = findNativeOrThrow(\"s\" + fName);\n+        MemorySegment addr = findNativeOrThrow(\"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -45,1 +45,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -93,1 +93,1 @@\n-            Addressable upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -35,1 +35,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -38,1 +37,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -62,1 +60,1 @@\n-                    MethodType.methodType(void.class, int.class, MemoryAddress.class, List.class));\n+                    MethodType.methodType(void.class, int.class, MemorySegment.class, List.class));\n@@ -68,1 +66,1 @@\n-    static final Addressable VARARGS_ADDR = findNativeOrThrow(\"varargs\");\n+    static final MemorySegment VARARGS_ADDR = findNativeOrThrow(\"varargs\");\n@@ -81,1 +79,1 @@\n-            MemoryAddress callInfoPtr = callInfo.address();\n+            MemorySegment callInfoPtr = callInfo;\n@@ -124,1 +122,1 @@\n-    private static void check(int index, MemoryAddress ptr, List<Arg> args) {\n+    private static void check(int index, MemorySegment ptr, List<Arg> args) {\n@@ -130,1 +128,1 @@\n-            MemorySegment seg = MemorySegment.ofAddress(ptr, layout.byteSize(), session);\n+            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), session);\n@@ -146,2 +144,2 @@\n-        static void writeback(MemorySegment seg, Addressable addr) {\n-            VH_writeback.set(seg, addr.address());\n+        static void writeback(MemorySegment seg, MemorySegment addr) {\n+            VH_writeback.set(seg, addr);\n@@ -149,2 +147,2 @@\n-        static void argIDs(MemorySegment seg, Addressable addr) {\n-            VH_argIDs.set(seg, addr.address());\n+        static void argIDs(MemorySegment seg, MemorySegment addr) {\n+            VH_argIDs.set(seg, addr);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -27,1 +27,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -76,1 +76,1 @@\n-            Addressable stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n@@ -89,1 +89,1 @@\n-            Addressable stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n+            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.Addressable;\n@@ -37,1 +36,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -66,1 +64,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -90,1 +88,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -120,1 +118,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -142,1 +140,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -202,1 +200,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -233,1 +231,1 @@\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -257,1 +255,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n@@ -286,1 +284,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n@@ -324,1 +322,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -378,1 +376,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -407,1 +405,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -430,1 +428,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -46,1 +45,0 @@\n-import java.lang.foreign.Addressable;\n@@ -67,1 +65,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -95,1 +93,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -126,1 +124,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -156,1 +154,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -186,1 +184,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -211,1 +209,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -242,1 +240,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -277,1 +275,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -334,1 +332,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -371,1 +369,1 @@\n-        MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n@@ -377,1 +375,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -399,1 +397,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class));\n@@ -458,1 +456,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n@@ -490,1 +488,1 @@\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class, long.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, long.class));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -40,1 +39,0 @@\n-import java.lang.foreign.Addressable;\n@@ -65,1 +63,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -82,1 +80,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -104,1 +102,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -128,1 +126,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -159,1 +157,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -196,1 +194,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -230,1 +228,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -260,1 +258,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -285,1 +283,1 @@\n-        MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n@@ -291,1 +289,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -312,1 +310,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n@@ -336,1 +334,1 @@\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -352,4 +350,4 @@\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-            MemorySegment.class, int.class, double.class, MemoryAddress.class);\n+            MemorySegment.class, int.class, double.class, MemorySegment.class,\n+            MemorySegment.class, int.class, double.class, MemorySegment.class,\n+            MemorySegment.class, int.class, double.class, MemorySegment.class,\n+            MemorySegment.class, int.class, double.class, MemorySegment.class);\n@@ -365,1 +363,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        MemorySegment.ofAddress(MemoryAddress.NULL, 4000, MemorySession.global());\n+        MemorySegment.ofAddress(0, 4000, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-                MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, MemorySession.class));\n-        var seg = (MemorySegment)mh.invokeExact(MemoryAddress.NULL, 4000L, MemorySession.global());\n+                MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class));\n+        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", MemoryAddress.class, long.class, MemorySession.class);\n-        method.invoke(null, MemoryAddress.NULL, 4000L, MemorySession.global());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, MemorySession.class);\n+        method.invoke(null, 0L, 4000L, MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -29,1 +29,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -32,1 +31,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -74,2 +72,1 @@\n-        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n-        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemorySegment.class, MemorySegment.NULL);\n@@ -78,1 +75,1 @@\n-        addDefaultMapping(MemorySession.class, MemorySession.openImplicit());\n+        addDefaultMapping(MemorySession.class, MemorySession.openShared());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -32,2 +33,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -35,1 +34,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -37,2 +35,0 @@\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n@@ -57,3 +53,0 @@\n-                    { MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\",\n-                            MethodType.methodType(VaList.class, MemoryAddress.class, MemorySession.class)),\n-                            \"VaList::ofAddress\/1\" },\n@@ -61,2 +54,2 @@\n-                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, MemorySession.class)),\n-                            \"MemorySegment::ofAddress\" },\n+                            MethodType.methodType(MemorySegment.class, long.class, long.class, MemorySession.class)),\n+                            \"MemorySegment::ofAddressNative\" },\n@@ -69,102 +62,0 @@\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getUtf8String\",\n-                            MethodType.methodType(String.class, long.class)),\n-                            \"MemoryAddress::getUtf8String\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setUtf8String\",\n-                            MethodType.methodType(void.class, long.class, String.class)),\n-                            \"MemoryAddress::setUtf8String\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(byte.class, ValueLayout.OfByte.class, long.class)),\n-                            \"MemoryAddress::get\/byte\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(boolean.class, ValueLayout.OfBoolean.class, long.class)),\n-                            \"MemoryAddress::get\/boolean\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n-                            \"MemoryAddress::get\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n-                            \"MemoryAddress::get\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n-                            \"MemoryAddress::get\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n-                            \"MemoryAddress::get\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n-                            \"MemoryAddress::get\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n-                            \"MemoryAddress::get\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n-                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n-                            \"MemoryAddress::get\/address\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfByte.class, long.class, byte.class)),\n-                            \"MemoryAddress::set\/byte\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfBoolean.class, long.class, boolean.class)),\n-                            \"MemoryAddress::set\/boolean\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n-                            \"MemoryAddress::set\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n-                            \"MemoryAddress::set\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n-                            \"MemoryAddress::set\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n-                            \"MemoryAddress::set\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n-                            \"MemoryAddress::set\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n-                            \"MemoryAddress::set\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n-                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n-                            \"MemoryAddress::set\/address\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n-                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n-                            \"MemoryAddress::getAtIndex\/address\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n-                            \"MemoryAddress::setAtIndex\/char\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n-                            \"MemoryAddress::setAtIndex\/short\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n-                            \"MemoryAddress::setAtIndex\/int\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n-                            \"MemoryAddress::setAtIndex\/float\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n-                            \"MemoryAddress::set\/long\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n-                            \"MemoryAddress::set\/double\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n-                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n-                            \"MemoryAddress::set\/address\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":3,"deletions":112,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#include <stddef.h>\n+\n+EXPORT void* get_null() { return NULL; }\n","filename":"test\/jdk\/java\/foreign\/libNull.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n-        Addressable foo = (Addressable)fooSymbol.invoke(null);\n+        MemorySegment foo = (MemorySegment) fooSymbol.invoke(null);\n@@ -49,1 +49,1 @@\n-        Method invoke = invoker.getDeclaredMethod(\"invoke\", Addressable.class);\n+        Method invoke = invoker.getDeclaredMethod(\"invoke\", MemorySegment.class);\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    public static void invoke(Addressable symbol) throws Throwable {\n+    public static void invoke(MemorySegment symbol) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -34,1 +34,1 @@\n-    public static Addressable fooSymbol() {\n+    public static MemorySegment fooSymbol() {\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -36,1 +35,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -57,2 +56,1 @@\n-        MemoryAddress ma = (MemoryAddress) MH_my_malloc.invokeExact(4L);\n-        MemorySegment seg = MemorySegment.ofAddress(ma, 4L, MemorySession.openImplicit());\n+        MemorySegment seg = (MemorySegment) MH_my_malloc.invokeExact(4L);\n@@ -63,1 +61,1 @@\n-        freeMemory(ma);\n+        freeMemory(seg);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-import java.lang.foreign.Addressable;\n@@ -84,1 +83,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -86,0 +85,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -89,1 +89,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -120,2 +119,1 @@\n-            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n-            MemoryAddress stubAddress = stub.address();\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n@@ -124,1 +122,1 @@\n-            payload(stubAddress);\n+            payload(stub);\n@@ -129,1 +127,1 @@\n-    static void payload(MemoryAddress cb) throws Throwable {\n+    static void payload(MemorySegment cb) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-import java.lang.foreign.Addressable;\n@@ -84,1 +83,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -119,2 +118,1 @@\n-            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n-            MemoryAddress stubAddress = stub.address();\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n@@ -123,1 +121,1 @@\n-                payload(stubAddress); \/\/ warmup\n+                payload(stub); \/\/ warmup\n@@ -127,1 +125,1 @@\n-            payload(stubAddress); \/\/ test\n+            payload(stub); \/\/ test\n@@ -131,1 +129,1 @@\n-    static void payload(MemoryAddress cb) throws Throwable {\n+    static void payload(MemorySegment cb) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -46,1 +46,1 @@\n-import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -83,1 +83,1 @@\n-            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n@@ -94,2 +94,2 @@\n-    static void payload(Addressable cb) throws Throwable {\n-        MH_foo.invokeExact((Addressable) cb, 0, 1, 2, 3);\n+    static void payload(MemorySegment cb) throws Throwable {\n+        MH_foo.invokeExact(cb, 0, 1, 2, 3);\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -83,1 +83,2 @@\n-    private static final MethodHandle ADDRESS_TO_VALIST;\n+    private static final MethodHandle VALIST_TO_ADDRESS;\n+    private static final MethodHandle SEGMENT_TO_VALIST;\n@@ -87,1 +88,2 @@\n-            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class, MemorySession.class));\n+            VALIST_TO_ADDRESS = MethodHandles.lookup().findVirtual(VaList.class, \"segment\", MethodType.methodType(MemorySegment.class));\n+            SEGMENT_TO_VALIST = MethodHandles.lookup().findStatic(VaListTest.class, \"segmentToValist\", MethodType.methodType(VaList.class, MemorySegment.class));\n@@ -116,1 +118,1 @@\n-        return linkInternal(symbol, fd);\n+        return MethodHandles.filterArguments(linkInternal(symbol, fd), fd.argumentLayouts().size() - 1, VALIST_TO_ADDRESS);\n@@ -173,3 +175,3 @@\n-            b.addVarg(intLayout, 10)\n-                    .addVarg(intLayout, 15)\n-                    .addVarg(intLayout, 20));\n+                b.addVarg(intLayout, 10)\n+                        .addVarg(intLayout, 15)\n+                        .addVarg(intLayout, 20));\n@@ -201,3 +203,3 @@\n-            b.addVarg(doubleLayout, 3.0D)\n-                    .addVarg(doubleLayout, 4.0D)\n-                    .addVarg(doubleLayout, 5.0D));\n+                b.addVarg(doubleLayout, 3.0D)\n+                        .addVarg(doubleLayout, 4.0D)\n+                        .addVarg(doubleLayout, 5.0D));\n@@ -213,1 +215,1 @@\n-                    MemoryAddress ma = list.nextVarg(layout);\n+                    MemorySegment ma = list.nextVarg(layout);\n@@ -227,1 +229,1 @@\n-    public void testVaListMemoryAddress(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n+    public void testVaListMemorySegment(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n@@ -231,1 +233,1 @@\n-            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, session);\n+            MemorySegment msInt = session.allocate(JAVA_INT);\n@@ -233,1 +235,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt.address()));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt));\n@@ -249,1 +251,1 @@\n-                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, MemorySession.openImplicit());\n+                    MemorySegment struct = MemorySession.openImplicit().allocate(pointLayout);\n@@ -286,1 +288,1 @@\n-            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, session);\n+            MemorySegment struct = session.allocate(Point_LAYOUT);\n@@ -489,1 +491,1 @@\n-                MH_sumStack.invoke(longSum, doubleSum, list);\n+                MH_sumStack.invokeExact(longSum, doubleSum, list);\n@@ -537,2 +539,2 @@\n-            Addressable stub = abi.upcallStub(callback, desc, session);\n-            target.invoke(stub);\n+            MemorySegment stub = abi.upcallStub(callback, desc, session);\n+            target.invokeExact(stub);\n@@ -579,1 +581,1 @@\n-                            .addVarg(intLayout, 8), session);\n+                    .addVarg(intLayout, 8), session);\n@@ -584,1 +586,1 @@\n-        assertFalse(listLeaked.session().isAlive());\n+        assertFalse(listLeaked.segment().session().isAlive());\n@@ -737,3 +739,2 @@\n-                    MemoryAddress intPtr = vaList.nextVarg(C_POINTER);\n-                    MemorySegment ms = MemorySegment.ofAddress(intPtr, C_INT.byteSize(), MemorySession.global());\n-                    int x = ms.get(JAVA_INT, 0);\n+                    MemorySegment intPtr = vaList.nextVarg(C_POINTER);\n+                    int x = intPtr.get(JAVA_INT, 0);\n@@ -819,1 +820,1 @@\n-                        MethodHandles.insertArguments(ADDRESS_TO_VALIST, 1, MemorySession.openConfined()));\n+                        SEGMENT_TO_VALIST);\n@@ -826,0 +827,4 @@\n+    static VaList segmentToValist(MemorySegment segment) {\n+        return VaList.ofAddress(segment.address(), MemorySession.openImplicit());\n+    }\n+\n@@ -871,1 +876,1 @@\n-                 builder.addVarg(ofAddress, MemoryAddress.ofLong(1));\n+                 builder.addVarg(ofAddress, MemorySegment.ofAddress(1));\n@@ -893,1 +898,1 @@\n-            assertEquals(vaList.nextVarg(ofAddress), MemoryAddress.ofLong(1));\n+            assertEquals(vaList.nextVarg(ofAddress), MemorySegment.ofAddress(1));\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.Addressable;\n@@ -38,0 +37,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -49,3 +49,3 @@\n-    static final Addressable funcA;\n-    static final Addressable funcB;\n-    static final Addressable funcC;\n+    static final MemorySegment funcA;\n+    static final MemorySegment funcB;\n+    static final MemorySegment funcC;\n@@ -72,1 +72,1 @@\n-        int x = (int) func.invokeExact((Addressable) null);\n+        int x = (int) func.invokeExact((MemorySegment)null);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.foreign.Addressable;\n@@ -29,1 +28,1 @@\n-import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n@@ -70,1 +69,1 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.asUnbounded();\n@@ -78,1 +77,1 @@\n-            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded(), ValueLayout.JAVA_LONG));\n@@ -80,1 +79,1 @@\n-    public static void freeMemory(Addressable address) {\n+    public static void freeMemory(MemorySegment address) {\n@@ -88,1 +87,1 @@\n-    public static MemoryAddress allocateMemory(long size) {\n+    public static MemorySegment allocateMemory(long size) {\n@@ -90,1 +89,1 @@\n-            return (MemoryAddress)MALLOC.invokeExact(size);\n+            return (MemorySegment)MALLOC.invokeExact(size);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -90,2 +88,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invokeExact(sharedPoint);\n@@ -95,2 +93,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint.address());\n+    public MemorySegment panama_identity_memory_address_confined() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invokeExact(confinedPoint);\n@@ -100,2 +98,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3.invokeExact(sharedPoint, sharedPoint, sharedPoint);\n@@ -105,2 +103,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    public MemorySegment panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3.invokeExact(confinedPoint, confinedPoint, confinedPoint);\n@@ -110,2 +108,2 @@\n-    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint);\n+    public MemorySegment panama_identity_memory_address_null() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invokeExact(MemorySegment.NULL);\n@@ -115,2 +113,2 @@\n-    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint);\n+    public MemorySegment panama_identity_memory_address_null_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3.invokeExact(MemorySegment.NULL, MemorySegment.NULL, MemorySegment.NULL);\n@@ -120,17 +118,2 @@\n-    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)MemoryAddress.NULL);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_memory_address_null_non_exact() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invoke(MemoryAddress.NULL);\n+    public MemorySegment panama_identity_memory_address_null_non_exact() throws Throwable {\n+        return (MemorySegment) identity_memory_address.invoke(MemorySegment.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":14,"deletions":31,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.MemorySegment;\n@@ -29,2 +30,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n@@ -45,1 +44,1 @@\n-    static Addressable func_addr;\n+    static MemorySegment func_addr;\n@@ -48,1 +47,1 @@\n-    static Addressable identity_addr;\n+    static MemorySegment identity_addr;\n@@ -51,1 +50,1 @@\n-    static Addressable identity_struct_addr;\n+    static MemorySegment identity_struct_addr;\n@@ -54,1 +53,1 @@\n-    static Addressable identity_struct_3_addr;\n+    static MemorySegment identity_struct_3_addr;\n@@ -57,1 +56,1 @@\n-    static Addressable identity_memory_address_addr;\n+    static MemorySegment identity_memory_address_addr;\n@@ -60,1 +59,1 @@\n-    static Addressable identity_memory_address_3_addr;\n+    static MemorySegment identity_memory_address_3_addr;\n@@ -63,1 +62,1 @@\n-    static Addressable args1_addr;\n+    static MemorySegment args1_addr;\n@@ -66,1 +65,1 @@\n-    static Addressable args2_addr;\n+    static MemorySegment args2_addr;\n@@ -69,1 +68,1 @@\n-    static Addressable args3_addr;\n+    static MemorySegment args3_addr;\n@@ -72,1 +71,1 @@\n-    static Addressable args4_addr;\n+    static MemorySegment args4_addr;\n@@ -75,1 +74,1 @@\n-    static Addressable args5_addr;\n+    static MemorySegment args5_addr;\n@@ -78,1 +77,1 @@\n-    static Addressable args10_addr;\n+    static MemorySegment args10_addr;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n@@ -84,2 +82,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared() throws Throwable {\n+        return (MemorySegment) identity_memory_address_v.invokeExact(identity_memory_address_addr, sharedPoint);\n@@ -89,2 +87,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)confinedPoint.address());\n+    public MemorySegment panama_identity_memory_address_confined() throws Throwable {\n+        return (MemorySegment) identity_memory_address_v.invokeExact(identity_memory_address_addr, confinedPoint);\n@@ -94,2 +92,2 @@\n-    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    public MemorySegment panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, sharedPoint, sharedPoint, sharedPoint);\n@@ -99,22 +97,2 @@\n-    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)sharedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)confinedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n+    public MemorySegment panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemorySegment) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, confinedPoint, confinedPoint, confinedPoint);\n@@ -134,2 +112,2 @@\n-    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)MemoryAddress.NULL);\n+    public MemorySegment panama_identity_memory_address_null() throws Throwable {\n+        return (MemorySegment) identity_memory_address_v.invokeExact(identity_memory_address_addr, MemorySegment.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":10,"deletions":32,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -160,18 +160,0 @@\n-    @Benchmark\n-    public int segment_loop_instance_address() {\n-        int sum = 0;\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            sum += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n-        }\n-        return sum;\n-    }\n-\n-    @Benchmark\n-    public int segment_loop_instance_address_index() {\n-        int sum = 0;\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            sum += segment.address().getAtIndex(JAVA_INT, i);\n-        }\n-        return sum;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -97,1 +98,1 @@\n-        unsafe_addr = segment.address().toRawLongValue();\n+        unsafe_addr = segment.address();\n@@ -152,9 +153,0 @@\n-    @Benchmark\n-    public int segment_loop_instance_address() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i ++) {\n-            res += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n-        }\n-        return res;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.Addressable;\n@@ -32,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -45,0 +44,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -82,1 +82,1 @@\n-        return (int)F_LONG.invokeExact(segment.address().toRawLongValue());\n+        return (int)F_LONG.invokeExact(segment.address());\n@@ -87,6 +87,1 @@\n-        return (int)F_PTR.invokeExact((Addressable)segment.address());\n-    }\n-\n-    @Benchmark\n-    public int panama_call_as_segment() throws Throwable {\n-        return (int)F_PTR.invokeExact((Addressable)segment);\n+        return (int)F_PTR.invokeExact(segment);\n@@ -98,1 +93,1 @@\n-        return (int)F_PTR.invokeExact((Addressable)newSegment);\n+        return (int)F_PTR.invokeExact(newSegment);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -59,2 +57,2 @@\n-    static final Addressable native_compar;\n-    static final Addressable panama_upcall_compar;\n+    static final MemorySegment native_compar;\n+    static final MemorySegment panama_upcall_compar;\n@@ -66,1 +64,1 @@\n-    static Addressable qsort_addr = abi.defaultLookup().lookup(\"qsort\").get();\n+    static MemorySegment qsort_addr = abi.defaultLookup().lookup(\"qsort\").get();\n@@ -85,1 +83,1 @@\n-                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n+                            MethodType.methodType(int.class, MemorySegment.class, MemorySegment.class)),\n@@ -106,1 +104,1 @@\n-         clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)native_compar);\n+         clib_qsort.invokeExact(INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), native_compar);\n@@ -121,1 +119,1 @@\n-        clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)panama_upcall_compar);\n+        clib_qsort.invokeExact(INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), panama_upcall_compar);\n@@ -124,6 +122,2 @@\n-    private static int getIntAbsolute(MemoryAddress addr) {\n-        return addr.get(JAVA_INT, 0);\n-    }\n-\n-    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n-        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n+    static int panama_upcall_compar(MemorySegment e0, MemorySegment e1) {\n+        return Integer.compare(e0.get(JAVA_INT, 0), e1.get(JAVA_INT, 0));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.Addressable;\n@@ -31,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -35,0 +33,1 @@\n+\n@@ -102,1 +101,1 @@\n-            return (int)STRLEN.invokeExact((Addressable)segment);\n+            return (int)STRLEN.invokeExact(segment);\n@@ -108,1 +107,1 @@\n-        return (int)STRLEN.invokeExact((Addressable)arenaAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(arenaAllocator.allocateUtf8String(str));\n@@ -113,1 +112,1 @@\n-        return (int)STRLEN.invokeExact((Addressable)segmentAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(segmentAllocator.allocateUtf8String(str));\n@@ -118,2 +117,2 @@\n-        MemoryAddress address = makeStringUnsafe(str);\n-        int res = (int) STRLEN.invokeExact((Addressable)address);\n+        MemorySegment address = makeStringUnsafe(str);\n+        int res = (int) STRLEN.invokeExact(address);\n@@ -124,1 +123,1 @@\n-    static MemoryAddress makeStringUnsafe(String s) {\n+    static MemorySegment makeStringUnsafe(String s) {\n@@ -127,2 +126,2 @@\n-        MemoryAddress address = allocateMemory(len + 1);\n-        MemorySegment str = MemorySegment.ofAddress(address, len + 1, MemorySession.global());\n+        MemorySegment address = allocateMemory(len + 1);\n+        MemorySegment str = address.asSlice(0, len + 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-            this.inputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(inputAddress), 8*SIZE, MemorySession.global());\n-            this.outputSegment = MemorySegment.ofAddress(MemoryAddress.ofLong(outputAddress), 8*SIZE, MemorySession.global());\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, MemorySession.global());\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, MemorySession.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySegment;\n@@ -59,4 +59,4 @@\n-    static final Addressable cb_blank;\n-    static final Addressable cb_identity;\n-    static final Addressable cb_args5;\n-    static final Addressable cb_args10;\n+    static final MemorySegment cb_blank;\n+    static final MemorySegment cb_identity;\n+    static final MemorySegment cb_args5;\n+    static final MemorySegment cb_args10;\n@@ -130,1 +130,1 @@\n-    static Addressable makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static MemorySegment makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n@@ -150,1 +150,1 @@\n-        blank.invokeExact((Addressable)cb_blank);\n+        blank.invokeExact(cb_blank);\n@@ -170,1 +170,1 @@\n-        return (int) identity.invokeExact(10, (Addressable)cb_identity);\n+        return (int) identity.invokeExact(10, cb_identity);\n@@ -175,1 +175,1 @@\n-        args5.invokeExact(1L, 2D, 3L, 4D, 5L, (Addressable)cb_args5);\n+        args5.invokeExact(1L, 2D, 3L, 4D, 5L, cb_args5);\n@@ -180,1 +180,1 @@\n-        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, (Addressable)cb_args10);\n+        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemorySession;\n@@ -28,1 +28,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -80,1 +80,1 @@\n-                    (Addressable)vaList);\n+                    vaList.segment());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+public sealed abstract class NativeType<X> {\n+\n+    public abstract MemoryLayout layout();\n+\n+    public non-sealed static abstract class OfInt<X> extends NativeType<X> {\n+        public abstract ValueLayout.OfInt layout();\n+    }\n+    public non-sealed static abstract class OfDouble<X> extends NativeType<X> {\n+        public abstract ValueLayout.OfDouble layout();\n+    }\n+\n+    private static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+\n+    public final static class OfPointer<X> extends NativeType<X> {\n+        public ValueLayout.OfAddress layout() {\n+            return UNSAFE_ADDRESS;\n+        }\n+    }\n+\n+    public non-sealed static abstract class OfStruct<X> extends NativeType<X> {\n+        public abstract GroupLayout layout();\n+        public abstract X make(Pointer<X> ptr);\n+    }\n+\n+    public static final OfInt<Integer> C_INT = new OfInt<>() {\n+        @Override\n+        public ValueLayout.OfInt layout() {\n+            return ValueLayout.JAVA_INT;\n+        }\n+    };\n+\n+    public static final OfDouble<Double> C_DOUBLE = new OfDouble<>() {\n+        @Override\n+        public ValueLayout.OfDouble layout() {\n+            return ValueLayout.JAVA_DOUBLE;\n+        }\n+    };\n+\n+    @SuppressWarnings(\"unchecked\")\n+    final static OfPointer C_VOID_PTR = new OfPointer();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static final OfPointer<Pointer<Integer>> C_INT_PTR = NativeType.C_VOID_PTR;\n+    @SuppressWarnings(\"unchecked\")\n+    public static final OfPointer<Pointer<Double>> C_DOUBLE_PTR = NativeType.C_VOID_PTR;\n+\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <Z> OfPointer<Pointer<Z>> ptr(NativeType<Z> type) {\n+        return NativeType.C_VOID_PTR;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+public class Point extends Struct<Point> {\n+\n+    Point(Pointer<Point> ptr) {\n+        super(ptr);\n+    }\n+\n+    int x() {\n+        return ptr.segment.get(NativeType.C_INT.layout(),  0);\n+    }\n+    int y() {\n+        return ptr.segment.get(NativeType.C_INT.layout(),  4);\n+    }\n+\n+    static Point wrap(MemorySegment segment) {\n+        return new Point(Pointer.wrap(TYPE, segment));\n+    }\n+\n+    static final NativeType.OfStruct<Point> TYPE = new NativeType.OfStruct<Point>() {\n+        static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"));\n+\n+        @Override\n+        public GroupLayout layout() {\n+            return LAYOUT;\n+        }\n+\n+        @Override\n+        public Point make(Pointer<Point> pointer) {\n+            return new Point(pointer);\n+        }\n+    };\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Point.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+\n+public class Pointer<X> {\n+\n+    final MemorySegment segment;\n+\n+    Pointer(MemorySegment segment) {\n+        this.segment = segment;\n+    }\n+\n+    public <Z extends NativeType.OfInt<X>> int get(Z type, long index) {\n+        return segment.getAtIndex(type.layout(), index);\n+    }\n+\n+    public <Z extends NativeType.OfDouble<X>> double get(Z type, long index) {\n+        return segment.getAtIndex(type.layout(), index);\n+    }\n+\n+    public <Z extends NativeType.OfStruct<X>> X get(Z type, long index) {\n+        return type.make(addOffset(index * type.layout().byteSize()));\n+    }\n+\n+    public Pointer<X> addOffset(long offset) {\n+        return new Pointer<>(segment.asSlice(offset));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <Z extends NativeType.OfPointer<X>> X get(Z type, long index) {\n+        MemorySegment address = segment.getAtIndex(type.layout(), index);\n+        return (X)new Pointer<>(address);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public X get(NativeType<X> type, long offset) {\n+        if (type instanceof NativeType.OfInt intType) {\n+            return (X) (Object) get(intType, offset);\n+        } else if (type instanceof NativeType.OfDouble doubleType) {\n+            return (X) (Object) get(doubleType, offset);\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public MemorySegment segment() {\n+        return segment;\n+    }\n+\n+    public static <X> Pointer<X> allocate(NativeType<X> type, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocate(type.layout());\n+        return new Pointer<>(segment);\n+    }\n+\n+    public static <X> Pointer<X> allocate(NativeType<X> type, long size, SegmentAllocator allocator) {\n+        MemorySegment segment = allocator.allocateArray(type.layout(), size);\n+        return new Pointer<>(segment);\n+    }\n+\n+    public static <X> Pointer<X> wrap(NativeType<X> type, MemorySegment segment) {\n+        return new Pointer<>(segment);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Pointer.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@State(Scope.Benchmark)\n+public class PointerBench {\n+\n+    final MemorySession session = MemorySession.openConfined();\n+    static final int ELEM_SIZE = 1_000_000;\n+    Pointer<Integer> intPointer = Pointer.allocate(NativeType.C_INT, ELEM_SIZE, session);\n+    Pointer<Pointer<Integer>> intPointerPointer = Pointer.allocate(NativeType.C_INT_PTR, ELEM_SIZE, session);\n+    Pointer<Point> pointPointer = Pointer.allocate(Point.TYPE, ELEM_SIZE, session);\n+    MemorySegment intSegment = intPointer.segment();\n+    MemorySegment intPointerSegment = intPointerPointer.segment();\n+    MemorySegment pointSegment = pointPointer.segment();\n+\n+    public static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+\n+    @Setup\n+    public void setup() {\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            intSegment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n+            intPointerSegment.setAtIndex(ValueLayout.ADDRESS, i, intSegment.asSlice(4 * i));\n+            pointSegment.setAtIndex(ValueLayout.JAVA_INT, (i * 2), i);\n+            pointSegment.setAtIndex(ValueLayout.JAVA_INT, (i * 2) + 1, i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        session.close();\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerInt_ptr() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += intPointer.get(NativeType.C_INT, i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPointerInt_ptr() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += intPointerPointer.get(NativeType.C_INT_PTR, i)\n+                                    .get(NativeType.C_INT, 0);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPoint_ptr() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += pointPointer.get(Point.TYPE, i).x();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerInt_ptr_generic() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += genericGet(intPointer, NativeType.C_INT, i);\n+        }\n+        return sum;\n+    }\n+\n+    static <Z> Z genericGet(Pointer<Z> pz, NativeType<Z> type, long offset) {\n+        return pz.get(type, offset);\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerInt_segment() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += intSegment.getAtIndex(ValueLayout.JAVA_INT, i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPointerInt_segment() {\n+        int sum = 0;\n+        for (long i = 0 ; i < ELEM_SIZE ; i++) {\n+            var segment = intPointerSegment.getAtIndex(UNSAFE_ADDRESS, i);\n+            sum += segment.get(ValueLayout.JAVA_INT, 0);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testLoopPointerPoint_segment() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += pointSegment.getAtIndex(ValueLayout.JAVA_INT, i * 2);\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign.pointers;\n+\n+public abstract class Struct<X extends Struct<X>> {\n+    protected final Pointer<X> ptr;\n+\n+    public Struct(Pointer<X> ptr) {\n+        this.ptr = ptr;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Struct.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Addressable;\n@@ -99,1 +98,1 @@\n-            return (double) MH_distance_ptrs.invokeExact((Addressable)segment, (Addressable)other.segment);\n+            return (double) MH_distance_ptrs.invokeExact(segment, other.segment);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -46,2 +45,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n@@ -73,3 +70,0 @@\n-\n-  private MemorySession implicitScope;\n-\n@@ -80,5 +74,0 @@\n-\n-  private MemoryAddress srcAddress;\n-\n-  private MemoryAddress dstAddress;\n-\n@@ -98,6 +87,2 @@\n-    implicitScope = MemorySession.openImplicit();\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-\n-    srcAddress = srcSegment.address();\n-    dstAddress = dstSegment.address();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n@@ -181,2 +166,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, session);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, session);\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, session);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, session);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.MemorySession;\n@@ -29,1 +30,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -31,1 +31,1 @@\n-import java.lang.foreign.MemorySession;\n+\n@@ -74,3 +74,0 @@\n-\n-  private MemorySession implicitScope;\n-\n@@ -81,5 +78,0 @@\n-\n-  private MemoryAddress srcAddress;\n-\n-  private MemoryAddress dstAddress;\n-\n@@ -100,6 +92,2 @@\n-    implicitScope = MemorySession.openImplicit();\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-\n-    srcAddress = srcSegment.address();\n-    dstAddress = dstSegment.address();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), MemorySession.openImplicit());\n@@ -176,2 +164,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, session);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, session);\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, session);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, session);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"}]}