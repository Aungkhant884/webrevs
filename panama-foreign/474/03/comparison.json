{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -36,0 +35,1 @@\n+import jdk.internal.clang.libclang.NativeScope;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Index.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-            CLinker.toCString(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY)\n-                .withAccessModes(MemorySegment.READ);\n+            CLinker.toCString(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/LibClang.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -55,4 +56,5 @@\n-        try (MemorySegment file = MemorySegment.allocateNative(CLinker.C_POINTER);\n-             MemorySegment line = MemorySegment.allocateNative(CLinker.C_INT);\n-             MemorySegment col = MemorySegment.allocateNative(CLinker.C_INT);\n-             MemorySegment offset = MemorySegment.allocateNative(CLinker.C_INT)) {\n+        try (var scope = ResourceScope.ofConfined()) {\n+             MemorySegment file = MemorySegment.allocateNative(CLinker.C_POINTER, scope);\n+             MemorySegment line = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+             MemorySegment col = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+             MemorySegment offset = MemorySegment.allocateNative(CLinker.C_INT, scope);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceLocation.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -36,0 +37,1 @@\n+import jdk.internal.clang.libclang.NativeScope;\n@@ -66,1 +68,2 @@\n-        try (MemorySegment pathStr = CLinker.toCString(path.toAbsolutePath().toString())) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment pathStr = CLinker.toCString(path.toAbsolutePath().toString(), scope);\n@@ -161,2 +164,1 @@\n-            return p.asSegmentRestricted(Index_h.CXToken.$LAYOUT().byteSize())\n-                    .share();\n+            return p.asSegmentRestricted(Index_h.CXToken.$LAYOUT().byteSize());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TranslationUnit.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -112,1 +114,2 @@\n-        try (MemorySegment cfname = CLinker.toCString(fieldName)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment cfname = CLinker.toCString(fieldName, scope);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Type.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6863,1 +6863,1 @@\n-            return allocate(fi).handoff(scope);\n+            return RuntimeHelper.upcallStub(CXCursorVisitor.class, fi, constants$31.CXCursorVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\", scope);\n@@ -6907,1 +6907,1 @@\n-            return allocate(fi).handoff(scope);\n+            return RuntimeHelper.upcallStub(CXCursorVisitorBlock.class, fi, constants$31.CXCursorVisitorBlock$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\", scope);\n@@ -9029,1 +9029,1 @@\n-            return allocate(fi).handoff(scope);\n+            return RuntimeHelper.upcallStub(clang_executeOnThread$fn.class, fi, constants$44.clang_executeOnThread$fn$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\", scope);\n@@ -9840,1 +9840,1 @@\n-            return allocate(fi).handoff(scope);\n+            return RuntimeHelper.upcallStub(CXInclusionVisitor.class, fi, constants$48.CXInclusionVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;)V\", scope);\n@@ -10239,1 +10239,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(visit.class, fi, constants$51.visit$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\", scope);\n@@ -10314,1 +10314,1 @@\n-            return allocate(fi).handoff(scope);\n+            return RuntimeHelper.upcallStub(CXCursorAndRangeVisitorBlock.class, fi, constants$51.CXCursorAndRangeVisitorBlock$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\", scope);\n@@ -12061,1 +12061,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(abortQuery.class, fi, constants$52.abortQuery$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\", scope);\n@@ -12088,1 +12088,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(diagnostic.class, fi, constants$52.diagnostic$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\", scope);\n@@ -12115,1 +12115,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(enteredMainFile.class, fi, constants$52.enteredMainFile$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\", scope);\n@@ -12142,1 +12142,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(ppIncludedFile.class, fi, constants$52.ppIncludedFile$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\", scope);\n@@ -12169,1 +12169,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(importedASTFile.class, fi, constants$53.importedASTFile$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\", scope);\n@@ -12196,1 +12196,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(startedTranslationUnit.class, fi, constants$53.startedTranslationUnit$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\", scope);\n@@ -12223,1 +12223,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(indexDeclaration.class, fi, constants$53.indexDeclaration$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\", scope);\n@@ -12250,1 +12250,1 @@\n-                return allocate(fi).handoff(scope);\n+                return RuntimeHelper.upcallStub(indexEntityReference.class, fi, constants$53.indexEntityReference$FUNC, \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\", scope);\n@@ -12294,1 +12294,1 @@\n-            return allocate(fi).handoff(scope);\n+            return RuntimeHelper.upcallStub(CXFieldVisitor.class, fi, constants$53.CXFieldVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.clang.libclang;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+public class NativeScope implements SegmentAllocator, AutoCloseable {\n+    final ResourceScope resourceScope;\n+    final ResourceScope.Handle scopeHandle;\n+    final SegmentAllocator allocator;\n+\n+    long allocatedBytes = 0;\n+\n+    private NativeScope() {\n+        this.resourceScope = ResourceScope.ofConfined();\n+        this.scopeHandle = resourceScope.acquire();\n+        this.allocator = SegmentAllocator.arenaUnbounded(resourceScope);\n+    }\n+\n+    private NativeScope(long size) {\n+        this.resourceScope = ResourceScope.ofConfined();\n+        this.scopeHandle = resourceScope.acquire();\n+        this.allocator = SegmentAllocator.arenaBounded(size, resourceScope);\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        allocatedBytes += bytesSize;\n+        return allocator.allocate(bytesSize, bytesAlignment);\n+    }\n+\n+    public ResourceScope scope() {\n+        return resourceScope;\n+    }\n+\n+    public long allocatedBytes() {\n+        return allocatedBytes;\n+    }\n+\n+    @Override\n+    public void close() {\n+        scopeHandle.close();\n+        resourceScope.close();\n+    }\n+\n+    public static NativeScope unboundedScope() {\n+        return new NativeScope();\n+    }\n+\n+    public static NativeScope boundedScope(long size) {\n+        return new NativeScope(size);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/NativeScope.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -81,2 +82,1 @@\n-            nonCloseableNonTransferableSegment(s.address().asSegmentRestricted(layout.byteSize())\n-                    .share())).orElse(null);\n+            nonCloseableNonTransferableSegment(s.address().asSegmentRestricted(layout.byteSize()))).orElse(null);\n@@ -85,0 +85,20 @@\n+    final static SegmentAllocator DEFAULT_ALLOCATOR = MemorySegment::allocateNative;\n+\n+    \/\/ This class can be used to debug usages of functions requiring allocation - disabled by default\n+    final static class DumpAllocator implements SegmentAllocator {\n+\n+        boolean reported = false;\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            if (!reported) {\n+                new AssertionError(\"allocator required?\").printStackTrace();\n+            }\n+            reported = true;\n+            return SegmentAllocator.ofDefault().allocate(bytesSize, bytesAlignment);\n+        }\n+    }\n+\n+    \/\/ switch this to \"true\" to enable verbose analysis of function requiring allocation\n+    static boolean DEBUG_ALLOCATOR = false;\n+\n@@ -89,0 +109,2 @@\n+                    SegmentAllocator allocator = mt.returnType().equals(MemorySegment.class) && DEBUG_ALLOCATOR ?\n+                            new DumpAllocator() : DEFAULT_ALLOCATOR;\n@@ -91,1 +113,11 @@\n-                        LINKER.downcallHandle(addr, mt, fdesc);\n+                        LINKER.downcallHandle(addr, allocator, mt, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic, SegmentAllocator allocator) {\n+        return lookup(LIBRARIES, name).map(\n+                addr -> {\n+                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+                    return variadic ?\n+                            VarargsInvoker.make(addr, mt, fdesc) :\n+                            LINKER.downcallHandle(addr, allocator, mt, fdesc);\n@@ -106,0 +138,11 @@\n+    static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, NativeScope scope) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc, scope.scope());\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n@@ -107,1 +150,1 @@\n-        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE & ~MemorySegment.HANDOFF);\n+        return seg;\n@@ -116,1 +159,1 @@\n-        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE);\n+        return seg;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/RuntimeHelper.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi, NativeScope scope) {\\n\");\n+            append(MEMBER_MODS + \" MemorySegment allocate(\" + className() + \" fi, ResourceScope scope) {\\n\");\n@@ -90,1 +90,2 @@\n-            append(\"return allocate(fi).handoff(scope);\\n\");\n+            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" + functionDesc.accessExpression() + \", \" +\n+                    \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\", scope);\\n\");\n@@ -106,4 +107,1 @@\n-            append(\"return new \" + className() + \"() {\\n\");\n-            incrAlign();\n-            indent();\n-            append(\"public \" + fiType.returnType().getName() + \" apply(\");\n+            append(\"return (\");\n@@ -115,1 +113,1 @@\n-            append(\") {\\n\");\n+            append(\") -> {\\n\");\n@@ -143,3 +141,0 @@\n-            append(\"}\\n\");\n-            decrAlign();\n-            indent();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -40,0 +42,1 @@\n+import java.util.Optional;\n@@ -92,0 +95,5 @@\n+            if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+                \/\/ emit scoped overload\n+                emitFunctionWrapperNoAllocatorOverload(javaName, functionInfo);\n+                emitFunctionWrapperScopedOverload(javaName, functionInfo);\n+            }\n@@ -125,1 +133,42 @@\n-        append(functionInfo.methodType().returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        MethodType declType = functionInfo.methodType();\n+        List<String> paramNames = functionInfo.parameterNames().get();\n+        if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+            \/\/ needs allocator parameter\n+            declType = declType.insertParameterTypes(0, SegmentAllocator.class);\n+            paramNames = new ArrayList<>(paramNames);\n+            paramNames.add(0, \"allocator\");\n+        }\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName, declType, functionInfo.isVarargs(), paramNames);\n+        append(\" {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+        append(mhConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\");\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private List<String> emitFunctionWrapperDecl(String javaName, MethodType methodType, boolean isVarargs, List<String> paramNames) {\n+        append(methodType.returnType().getSimpleName() + \" \" + javaName + \" (\");\n@@ -128,1 +177,0 @@\n-        List<String> paramNames = functionInfo.parameterNames().get();\n@@ -135,1 +183,1 @@\n-            if (functionInfo.methodType().parameterType(i).equals(MemoryAddress.class)) {\n+            if (methodType.parameterType(i).equals(MemoryAddress.class)) {\n@@ -140,1 +188,1 @@\n-            Class<?> pType = functionInfo.methodType().parameterType(i);\n+            Class<?> pType = methodType.parameterType(i);\n@@ -147,1 +195,1 @@\n-        if (functionInfo.isVarargs()) {\n+        if (isVarargs) {\n@@ -149,4 +197,1 @@\n-            if (numParams > 0) {\n-                append(\", \");\n-            }\n-            append(\"Object... \" + lastArg);\n+            append(delim + \"Object... \" + lastArg);\n@@ -155,1 +200,5 @@\n-        append(\") {\\n\");\n+        append(\")\");\n+        return pExprs;\n+    }\n+\n+    private void emitFunctionWrapperNoAllocatorOverload(String javaName, FunctionInfo functionInfo) {\n@@ -158,7 +207,4 @@\n-        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n-        append(mhConstant.accessExpression());\n-        append(\", \\\"\");\n-        append(nativeName);\n-        append(\"\\\");\\n\");\n-        indent();\n-        append(\"try {\\n\");\n+        append(MEMBER_MODS + \" \");\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName, functionInfo.methodType(), functionInfo.isVarargs(), functionInfo.parameterNames().get());\n+        pExprs.add(0, \"RuntimeHelper.DEFAULT_ALLOCATOR\");\n+        append(\" {\\n\");\n@@ -170,1 +216,1 @@\n-        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        append(javaName + \"(\" + String.join(\", \", pExprs) + \");\\n\");\n@@ -173,1 +219,5 @@\n-        append(\"} catch (Throwable ex$) {\\n\");\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFunctionWrapperScopedOverload(String javaName, FunctionInfo functionInfo) {\n@@ -176,2 +226,11 @@\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n+        append(MEMBER_MODS + \" \");\n+        List<String> paramNames = new ArrayList<>(functionInfo.parameterNames().get());\n+        paramNames.add(0, \"scope\");\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName,\n+                functionInfo.methodType().insertParameterTypes(0, ResourceScope.class),\n+                functionInfo.isVarargs(),\n+                paramNames);\n+        String param = pExprs.remove(0);\n+        pExprs.add(0, \"SegmentAllocator.scoped(\" + param + \")\");\n+        append(\" {\\n\");\n+        incrAlign();\n@@ -179,1 +238,4 @@\n-        append(\"}\\n\");\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n+        }\n+        append(javaName + \"(\" + String.join(\", \", pExprs) + \");\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":84,"deletions":22,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+            files.add(jfoFromString(pkgName,\"NativeScope\", getNativeScopeSource()));\n@@ -152,0 +153,7 @@\n+    private String getNativeScopeSource() throws URISyntaxException, IOException {\n+        URL runtimeHelper = OutputFactory.class.getResource(\"resources\/NativeScope.java.template\");\n+        return (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n+                String.join(\"\\n\", Files.readAllLines(Paths.get(runtimeHelper.toURI())))\n+                        .replace(\"${C_LANG}\", C_LANG_CONSTANTS_HOLDER);\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -30,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -36,1 +33,0 @@\n-import java.lang.invoke.MethodType;\n@@ -94,0 +90,1 @@\n+            emitAllocatorAllocate();\n@@ -96,0 +93,1 @@\n+            emitAllocatorAllocateArray();\n@@ -98,2 +96,0 @@\n-            emitAllocatePoiner();\n-            emitScopeAllocatePointer();\n@@ -101,0 +97,1 @@\n+            emitAsRestrictedScoped();\n@@ -228,3 +225,1 @@\n-        append(\"return RuntimeHelper.nonCloseableNonTransferableSegment(\");\n-        append(seg);\n-        append(\".asSlice(\");\n+        append(\"return \" + seg + \".asSlice(\");\n@@ -234,1 +229,1 @@\n-        append(\"));\\n\");\n+        append(\");\\n\");\n@@ -253,1 +248,1 @@\n-        append(\" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n+        append(\" MemorySegment allocate() { return allocate(RuntimeHelper.DEFAULT_ALLOCATOR); }\\n\");\n@@ -261,1 +256,9 @@\n-        append(\" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n+        append(\" MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.scoped(scope)); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocatorAllocate() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\\n\");\n@@ -272,1 +275,1 @@\n-        append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        append(\"return allocateArray(len, RuntimeHelper.DEFAULT_ALLOCATOR);\\n\");\n@@ -283,1 +286,1 @@\n-        append(\" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n+        append(\" MemorySegment allocateArray(int len, ResourceScope scope) {\\n\");\n@@ -286,1 +289,1 @@\n-        append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        append(\"return allocateArray(len, SegmentAllocator.scoped(scope));\\n\");\n@@ -293,1 +296,1 @@\n-    private void emitAllocatePoiner() {\n+    private void emitAllocatorAllocateArray() {\n@@ -297,1 +300,1 @@\n-        append(\" MemorySegment allocatePointer() {\\n\");\n+        append(\" MemorySegment allocateArray(int len, SegmentAllocator allocator) {\\n\");\n@@ -300,1 +303,1 @@\n-        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        append(\"return allocator.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n@@ -307,1 +310,1 @@\n-    private void emitScopeAllocatePointer() {\n+    private void emitAsRestricted() {\n@@ -311,7 +314,1 @@\n-        append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return scope.allocate(C_POINTER);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n+        append(\" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n@@ -321,1 +318,1 @@\n-    private void emitAsRestricted() {\n+    private void emitAsRestrictedScoped() {\n@@ -325,1 +322,1 @@\n-        append(\" MemorySegment ofAddressRestricted(MemoryAddress addr) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1); }\\n\");\n+        append(\" MemorySegment ofAddressRestricted(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArrayRestricted(addr, $LAYOUT(), 1, scope); }\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-    private static String MEMBER_MODS = \"public static \";\n-\n@@ -46,3 +44,0 @@\n-        if (superClass == null) {\n-            emitAllocatePointerMethods();\n-        }\n@@ -51,28 +46,0 @@\n-\n-    void emitAllocatePointerMethods() {\n-        \/\/ allocatePointer\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" MemorySegment allocatePointer() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-\n-        \/\/ allocatePointer (scope version)\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS);\n-        append(\" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return scope.allocate(C_POINTER);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+public class NativeScope implements SegmentAllocator, AutoCloseable {\n+    final ResourceScope resourceScope;\n+    final ResourceScope.Handle scopeHandle;\n+    final SegmentAllocator allocator;\n+\n+    long allocatedBytes = 0;\n+\n+    private NativeScope() {\n+        this.resourceScope = ResourceScope.ofConfined();\n+        this.scopeHandle = resourceScope.acquire();\n+        this.allocator = SegmentAllocator.arenaUnbounded(resourceScope);\n+    }\n+\n+    private NativeScope(long size) {\n+        this.resourceScope = ResourceScope.ofConfined();\n+        this.scopeHandle = resourceScope.acquire();\n+        this.allocator = SegmentAllocator.arenaBounded(size, resourceScope);\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        allocatedBytes += bytesSize;\n+        return allocator.allocate(bytesSize, bytesAlignment);\n+    }\n+\n+    public ResourceScope scope() {\n+        return resourceScope;\n+    }\n+\n+    public long allocatedBytes() {\n+        return allocatedBytes;\n+    }\n+\n+    @Override\n+    public void close() {\n+        scopeHandle.close();\n+        resourceScope.close();\n+    }\n+\n+    public static NativeScope unboundedScope() {\n+        return new NativeScope();\n+    }\n+\n+    public static NativeScope boundedScope(long size) {\n+        return new NativeScope(size);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/NativeScope.java.template","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -10,1 +10,2 @@\n-\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -36,0 +37,2 @@\n+    static SegmentAllocator DEFAULT_ALLOCATOR = MemorySegment::allocateNative;\n+\n@@ -53,3 +56,1 @@\n-        return lookup(LIBRARIES, name).map(s ->\n-            nonCloseableNonTransferableSegment(s.address().asSegmentRestricted(layout.byteSize())\n-                    .share())).orElse(null);\n+        return lookup(LIBRARIES, name).map(s -> s.address().asSegmentRestricted(layout.byteSize())).orElse(null);\n@@ -87,3 +88,10 @@\n-    static final MemorySegment nonCloseableNonTransferableSegment(MemorySegment seg) {\n-        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE & ~MemorySegment.HANDOFF);\n-    }\n+    static final <Z> MemorySegment upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+            try {\n+                MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                        MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+                handle = handle.bindTo(z);\n+                return LINKER.upcallStub(handle, fdesc, scope);\n+            } catch (Throwable ex) {\n+                throw new AssertionError(ex);\n+            }\n+        }\n@@ -92,1 +100,1 @@\n-        return nonCloseableSegment(addr.asSegmentRestricted(numElements * layout.byteSize()));\n+        return addr.asSegmentRestricted(numElements * layout.byteSize());\n@@ -95,3 +103,2 @@\n-    \/\/ Internals only below this point\n-    private static final MemorySegment nonCloseableSegment(MemorySegment seg) {\n-        return seg.withAccessModes(seg.accessModes() &  ~MemorySegment.CLOSE);\n+    static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {\n+         return addr.asSegmentRestricted(numElements * layout.byteSize(), scope);\n@@ -100,0 +107,1 @@\n+    \/\/ Internals only below this point\n@@ -120,1 +128,1 @@\n-                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, Object[].class));\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n@@ -128,2 +136,7 @@\n-            return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())\n-                    .asType(type);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount());\n+            if (type.returnType().equals(MemorySegment.class)) {\n+                type = type.insertParameterTypes(0, SegmentAllocator.class);\n+            } else {\n+                handle = MethodHandles.insertArguments(handle, 0, DEFAULT_ALLOCATOR);\n+            }\n+            return handle.asType(type);\n@@ -132,1 +145,1 @@\n-        private Object invoke(Object[] args) throws Throwable {\n+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n@@ -161,1 +174,1 @@\n-            MethodHandle mh = LINKER.downcallHandle(symbol, mt, f);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, allocator, mt, f);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":29,"deletions":16,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -54,4 +53,0 @@\n-            Method alloc = findMethod(fooCls, \"allocatePointer\");\n-            assertNotNull(alloc);\n-            alloc = findMethod(fooCls, \"allocatePointer\", NativeScope.class);\n-            assertNotNull(alloc);\n","filename":"test\/jdk\/tools\/jextract\/Test8245767.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.NativeScope;\n","filename":"test\/jdk\/tools\/jextract\/Test8262117.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -162,4 +162,3 @@\n-                try (MemorySegment struct = MemorySegment.allocateNative(layout)) {\n-                    MemorySegment slice = (MemorySegment) slicer.invoke(null, struct);\n-                    assertEquals(slice.byteSize(), fieldLayout.byteSize());\n-                }\n+                MemorySegment struct = MemorySegment.allocateNative(layout);\n+                MemorySegment slice = (MemorySegment) slicer.invoke(null, struct);\n+                assertEquals(slice.byteSize(), fieldLayout.byteSize());\n@@ -173,5 +172,4 @@\n-                try (MemorySegment struct = MemorySegment.allocateNative(layout)) {\n-                    setter.invoke(null, struct, zero);\n-                    Object actual = getter.invoke(null, struct);\n-                    assertEquals(actual, zero);\n-                }\n+                MemorySegment struct = MemorySegment.allocateNative(layout);\n+                setter.invoke(null, struct, zero);\n+                Object actual = getter.invoke(null, struct);\n+                assertEquals(actual, zero);\n","filename":"test\/jdk\/tools\/jextract\/TestNested.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -31,0 +31,2 @@\n+\n+import test.jextract.funcpointers.NativeScope;\n@@ -50,1 +52,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -61,1 +63,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -72,1 +74,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -82,1 +84,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -92,1 +94,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -103,1 +105,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -114,1 +116,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -124,1 +126,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.NativeScope;\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/LibTest8241925Test.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -32,0 +31,2 @@\n+\n+import test.jextract.test8244412.*;\n","filename":"test\/jdk\/tools\/jextract\/test8244412\/LibTest8244412Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -53,1 +54,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(1024)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(1024, scope);\n@@ -55,2 +57,2 @@\n-                toCString(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\"), 12,\n-                (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');\n+                    toCString(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\", scope), 12,\n+                    (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/Test8244959.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,4 +51,0 @@\n-    private void checkAccess(MemorySegment seg) {\n-        assertFalse(seg.hasAccessModes(MemorySegment.CLOSE | MemorySegment.HANDOFF));\n-    }\n-\n@@ -58,1 +54,0 @@\n-        checkAccess(seg);\n@@ -64,1 +59,0 @@\n-        checkAccess(seg);\n@@ -71,1 +65,0 @@\n-        checkAccess(pointSeg);\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/Test8245003.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -56,9 +56,10 @@\n-        try (var callback = func$callback.allocate((argc, argv) -> {\n-            callbackCalled[0] = true;\n-            var addr = argv.asSegmentRestricted(C_POINTER.byteSize() * argc);\n-            assertEquals(argc, 4);\n-            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 0)), \"java\");\n-            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 1)), \"python\");\n-            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 2)), \"javascript\");\n-            assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 3)), \"c++\");\n-        })) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            var callback = func$callback.allocate((argc, argv) -> {\n+                callbackCalled[0] = true;\n+                var addr = argv.asSegmentRestricted(C_POINTER.byteSize() * argc, scope);\n+                assertEquals(argc, 4);\n+                assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 0)), \"java\");\n+                assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 1)), \"python\");\n+                assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 2)), \"javascript\");\n+                assertEquals(toJavaStringRestricted(MemoryAccess.getAddressAtIndex(addr, 3)), \"c++\");\n+            }, scope);\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/LibTest8246341Test.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -56,1 +56,1 @@\n-        try (var scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -65,2 +65,1 @@\n-            sum = add(v1, v2);\n-            sum = sum.handoff(scope);\n+            sum = add(scope, v1, v2);\n@@ -82,2 +81,2 @@\n-        assertTrue(!sum.isAlive());\n-        assertTrue(!callback.isAlive());\n+        assertTrue(!sum.scope().isAlive());\n+        assertTrue(!callback.scope().isAlive());\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/LibTest8246400Test.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -53,2 +54,3 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(1024)) {\n-            try (VaList vaList = VaList.make(b -> {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment s = MemorySegment.allocateNative(1024, scope);\n+            VaList vaList = VaList.make(b -> {\n@@ -59,5 +61,4 @@\n-            })) {\n-                my_vsprintf(s, toCString(\"%hhd %.2f %lld %lld\"), vaList);\n-                String str = toJavaString(s);\n-                assertEquals(str, \"12 5.50 -200 \" + Long.MAX_VALUE);\n-            }\n+            }, scope);\n+            my_vsprintf(s, toCString(\"%hhd %.2f %lld %lld\"), vaList);\n+            String str = toJavaString(s);\n+            assertEquals(str, \"12 5.50 -200 \" + Long.MAX_VALUE);\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/Test8252016.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -31,0 +30,2 @@\n+\n+import test.jextract.arrayparam.*;\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/Test8252121.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -27,0 +26,2 @@\n+\n+import test.jextract.test8252465.*;\n","filename":"test\/jdk\/tools\/jextract\/test8252465\/LibTest8252465Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            seg.close();\n+            seg.scope().close();\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/LibTest8253102Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,6 +56,5 @@\n-        try (var seg = Foo.allocate()) {\n-            Foo.i$set(seg, 32);\n-            Foo.c$set(seg, (byte)'z');\n-            assertEquals(Foo.i$get(seg), 32);\n-            assertEquals(Foo.c$get(seg), (byte)'z');\n-        }\n+        var seg = Foo.allocate();\n+        Foo.i$set(seg, 32);\n+        Foo.c$set(seg, (byte)'z');\n+        assertEquals(Foo.i$get(seg), 32);\n+        assertEquals(Foo.c$get(seg), (byte)'z');\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/LibUnsupportedTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -53,1 +53,1 @@\n-        try (var scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n@@ -65,1 +65,1 @@\n-        try (var scope = NativeScope.unboundedScope()) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n","filename":"test\/jdk\/tools\/jextract\/test8258605\/LibTest8258605Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.NativeScope;\n","filename":"test\/jdk\/tools\/jextract\/test8259473\/LibTest8259473Test.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -200,1 +201,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(structLayout)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment struct = MemorySegment.allocateNative(structLayout, scope);\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/TestClassGeneration.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -46,1 +47,2 @@\n-        try (var handle = func$f.allocate(x -> x*x)) {\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            var handle = func$f.allocate(x -> x * x, scope);\n@@ -48,1 +50,1 @@\n-        } \/\/deallocate\n+        }\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/LibFuncPtrTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,4 +53,3 @@\n-        try (var seg = makePoint(42, -39)) {\n-            assertEquals(Point.x$get(seg), 42);\n-            assertEquals(Point.y$get(seg), -39);\n-        }\n+        var seg = makePoint(42, -39);\n+        assertEquals(Point.x$get(seg), 42);\n+        assertEquals(Point.y$get(seg), -39);\n@@ -61,6 +60,5 @@\n-        try (var seg = Point.allocate()) {\n-            Point.x$set(seg, 56);\n-            Point.y$set(seg, 65);\n-            assertEquals(Point.x$get(seg), 56);\n-            assertEquals(Point.y$get(seg), 65);\n-        }\n+        var seg = Point.allocate();\n+        Point.x$set(seg, 56);\n+        Point.y$set(seg, 65);\n+        assertEquals(Point.x$get(seg), 56);\n+        assertEquals(Point.y$get(seg), 65);\n@@ -71,9 +69,8 @@\n-        try (var seg = Point.allocateArray(3)) {\n-            for (int i = 0; i < 3; i++) {\n-                Point.x$set(seg, i, 56 + i);\n-                Point.y$set(seg, i, 65 + i);\n-            }\n-            for (int i = 0; i < 3; i++) {\n-                assertEquals(Point.x$get(seg, i), 56 + i);\n-                assertEquals(Point.y$get(seg, i), 65 + i);\n-            }\n+        var seg = Point.allocateArray(3);\n+        for (int i = 0; i < 3; i++) {\n+            Point.x$set(seg, i, 56 + i);\n+            Point.y$set(seg, i, 65 + i);\n+        }\n+        for (int i = 0; i < 3; i++) {\n+            assertEquals(Point.x$get(seg, i), 56 + i);\n+            assertEquals(Point.y$get(seg, i), 65 + i);\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/LibStructTest.java","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"}]}