{"files":[{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n-\n-import java.io.UncheckedIOException;\n-import java.nio.MappedByteBuffer;\n-import java.util.Objects;\n-\n-\/**\n- * This class provides capabilities to manipulate mapped memory segments, such as {@link #force(MemorySegment)},\n- * and {@link #load(MemorySegment)}. The methods in these class are suitable replacements for some of the\n- * functionality in the {@link java.nio.MappedByteBuffer} class. Note that, while it is possible to map a segment\n- * into a byte buffer (see {@link MemorySegment#asByteBuffer()}), and call e.g. {@link MappedByteBuffer#force()} that way,\n- * this can only be done when the source segment is small enough, due to the size limitation inherent to the\n- * ByteBuffer API.\n- * <p>\n- * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n- * custom mapped memory segment factories; using JNI, e.g. on Linux, it is possible to call {@code mmap}\n- * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n- * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegment(long, Runnable, ResourceScope)}.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\n- * @implNote\n- * The behavior of some the methods in this class (see {@link #load(MemorySegment)}, {@link #unload(MemorySegment)} and\n- * {@link #isLoaded(MemorySegment)}) is highly platform-dependent; as a result, calling these methods might\n- * be a no-op on certain platforms.\n- *\/\n-public final class MappedMemorySegments {\n-    private MappedMemorySegments() {\n-        \/\/ no thanks\n-    }\n-\n-    \/**\n-     * Tells whether or not the contents of the given segment is resident in physical\n-     * memory.\n-     *\n-     * <p> A return value of {@code true} implies that it is highly likely\n-     * that all of the data in the given segment is resident in physical memory and\n-     * may therefore be accessed without incurring any virtual-memory page\n-     * faults or I\/O operations.  A return value of {@code false} does not\n-     * necessarily imply that the segment's content is not resident in physical\n-     * memory.\n-     *\n-     * <p> The returned value is a hint, rather than a guarantee, because the\n-     * underlying operating system may have paged out some of the segment's data\n-     * by the time that an invocation of this method returns.  <\/p>\n-     *\n-     * @param segment the segment whose contents are to be tested.\n-     * @return  {@code true} if it is likely that the contents of the given segment\n-     *          is resident in physical memory\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     *\/\n-    public static boolean isLoaded(MemorySegment segment) {\n-        return toMappedSegment(segment).isLoaded();\n-    }\n-\n-    \/**\n-     * Loads the contents of the given segment into physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that, when it returns,\n-     * this contents of the given segment is resident in physical memory.  Invoking this\n-     * method may cause some number of page faults and I\/O operations to\n-     * occur. <\/p>\n-     *\n-     * @param segment the segment whose contents are to be loaded.\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     *\/\n-    public static void load(MemorySegment segment) {\n-        toMappedSegment(segment).load();\n-    }\n-\n-    \/**\n-     * Unloads the contents of the given segment from physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that the contents of the given segment are\n-     * are no longer resident in physical memory. Accessing this segment's contents\n-     * after invoking this method may cause some number of page faults and I\/O operations to\n-     * occur (as this segment's contents might need to be paged back in). <\/p>\n-     *\n-     * @param segment the segment whose contents are to be unloaded.\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     *\/\n-    public static void unload(MemorySegment segment) {\n-        toMappedSegment(segment).unload();\n-    }\n-\n-    \/**\n-     * Forces any changes made to the contents of the given segment to be written to the\n-     * storage device described by the mapped segment's file descriptor.\n-     *\n-     * <p> If this mapping's file descriptor resides on a local storage\n-     * device then when this method returns it is guaranteed that all changes\n-     * made to the segment since it was created, or since this method was last\n-     * invoked, will have been written to that device.\n-     *\n-     * <p> If this mapping's file descriptor does not reside on a local device then no such guarantee\n-     * is made.\n-     *\n-     * <p> If the given segment was not mapped in read\/write mode ({@link\n-     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n-     * invoking this method may have no effect. In particular, the\n-     * method has no effect for segments mapped in read-only or private\n-     * mapping modes. This method may or may not have an effect for\n-     * implementation-specific mapping modes.\n-     * <\/p>\n-     *\n-     * @param segment the segment whose contents are to be written to the storage device described by the\n-     *                segment's file descriptor.\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     * @throws UncheckedIOException if there is an I\/O error writing the contents of the segment to the associated storage device\n-     *\/\n-    public static void force(MemorySegment segment) {\n-        toMappedSegment(segment).force();\n-    }\n-\n-    static MappedMemorySegmentImpl toMappedSegment(MemorySegment segment) {\n-        Objects.requireNonNull(segment);\n-        if (segment instanceof MappedMemorySegmentImpl) {\n-            return (MappedMemorySegmentImpl)segment;\n-        } else {\n-            throw new UnsupportedOperationException(\"Not a mapped memory segment\");\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -35,1 +35,5 @@\n- * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory.\n+ * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory. Off-heap memory\n+ * addresses are referred to as <em>native<\/em> memory addresses (see {@link #isNative()}). Native memory addresses\n+ * allow clients to obtain a raw memory address (expressed as a long value) which can then be used e.g. when interacting\n+ * with native code.\n+ * <p>\n@@ -72,1 +76,1 @@\n-     * base address and this address are off-heap addresses, the result is computed as\n+     * base address and this address are native addresses, the result is computed as\n@@ -115,1 +119,1 @@\n-     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws UnsupportedOperationException if this address is not a {@link #isNative() native} address.\n@@ -142,1 +146,1 @@\n-     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws UnsupportedOperationException if this address is not a {@link #isNative() native} address.\n@@ -147,3 +151,9 @@\n-     * Returns the raw long value associated with this memory address.\n-     * @return The raw long value associated with this memory address.\n-     * @throws UnsupportedOperationException if this memory address is an heap address.\n+     * Is this an off-heap memory address?\n+     * @return true, if this is an off-heap memory address.\n+     *\/\n+    boolean isNative();\n+\n+    \/**\n+     * Returns the raw long value associated with this native memory address.\n+     * @return The raw long value associated with this native memory address.\n+     * @throws UnsupportedOperationException if this memory address is not a {@link #isNative() native} address.\n@@ -177,1 +187,1 @@\n-     * The off-heap memory address instance modelling the {@code NULL} address.\n+     * The native memory address instance modelling the {@code NULL} address.\n@@ -182,1 +192,1 @@\n-     * Obtain an off-heap memory address instance from given long address.\n+     * Obtain a native memory address instance from given long address.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.UncheckedIOException;\n@@ -79,0 +80,6 @@\n+ *\n+ * <h2>Mapping memory segments from files<\/h2>\n+ *\n+ * It is also possible to obtain a native memory segment backed by a memory-mapped file using the factory method\n+ * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)}. Such native memory segments are\n+ * called <em>mapped memory segments<\/em>; mapped memory segments are associated with an underlying file descriptor.\n@@ -80,4 +87,10 @@\n- * Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method\n- * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)}. Such memory segments are called <em>mapped memory segments<\/em>;\n- * mapped memory segments are associated with an underlying file descriptor. For more operations on mapped memory segments, please refer to the\n- * {@link MappedMemorySegments} class.\n+ * Contents of mapped memory segments can be {@link #force() persisted} and {@link #load() loaded} to and from the underlying file;\n+ * these capabilities are suitable replacements for some of the functionality in the {@link java.nio.MappedByteBuffer} class.\n+ * Note that, while it is possible to map a segment into a byte buffer (see {@link MemorySegment#asByteBuffer()}),\n+ * and then call e.g. {@link java.nio.MappedByteBuffer#force()} that way, this can only be done when the source segment\n+ * is small enough, due to the size limitation inherent to the ByteBuffer API.\n+ * <p>\n+ * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n+ * custom mapped memory segment factories; using {@link CLinker}, e.g. on Linux, it is possible to call {@code mmap}\n+ * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegment(long, Runnable, ResourceScope)}.\n@@ -286,0 +299,9 @@\n+    \/**\n+     * Is this a native segment? Returns true if this segment is a native memory segment,\n+     * created using the {@link #allocateNative(long, ResourceScope)} (and related) factory, or a buffer segment\n+     * derived from a direct {@link java.nio.ByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory,\n+     * or if this is a {@link #isMapped() mapped} segment.\n+     * @return {@code true} if this segment is native segment.\n+     *\/\n+    boolean isNative();\n+\n@@ -366,0 +388,83 @@\n+    \/**\n+     * Tells whether or not the contents of this mapped segment is resident in physical\n+     * memory.\n+     *\n+     * <p> A return value of {@code true} implies that it is highly likely\n+     * that all of the data in this segment is resident in physical memory and\n+     * may therefore be accessed without incurring any virtual-memory page\n+     * faults or I\/O operations.  A return value of {@code false} does not\n+     * necessarily imply that this segment's content is not resident in physical\n+     * memory.\n+     *\n+     * <p> The returned value is a hint, rather than a guarantee, because the\n+     * underlying operating system may have paged out some of this segment's data\n+     * by the time that an invocation of this method returns.  <\/p>\n+     *\n+     * @return  {@code true} if it is likely that the contents of this segment\n+     *          is resident in physical memory\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     *\/\n+    boolean isLoaded();\n+\n+    \/**\n+     * Loads the contents of this mapped segment into physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that, when it returns,\n+     * this contents of this segment is resident in physical memory.  Invoking this\n+     * method may cause some number of page faults and I\/O operations to\n+     * occur. <\/p>\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     *\/\n+    void load();\n+\n+    \/**\n+     * Unloads the contents of this mapped segment from physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that the contents of this segment are\n+     * are no longer resident in physical memory. Accessing this segment's contents\n+     * after invoking this method may cause some number of page faults and I\/O operations to\n+     * occur (as this segment's contents might need to be paged back in). <\/p>\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     *\/\n+    void unload();\n+\n+    \/**\n+     * Forces any changes made to the contents of this mapped segment to be written to the\n+     * storage device described by the mapped segment's file descriptor.\n+     *\n+     * <p> If the file descriptor associated with this mapped segment resides on a local storage\n+     * device then when this method returns it is guaranteed that all changes\n+     * made to this segment since it was created, or since this method was last\n+     * invoked, will have been written to that device.\n+     *\n+     * <p> If the file descriptor associated with this mapped segment does not reside on a local device then\n+     * no such guarantee is made.\n+     *\n+     * <p> If this segment was not mapped in read\/write mode ({@link\n+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n+     * invoking this method may have no effect. In particular, the\n+     * method has no effect for segments mapped in read-only or private\n+     * mapping modes. This method may or may not have an effect for\n+     * implementation-specific mapping modes.\n+     * <\/p>\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     * @throws UncheckedIOException if there is an I\/O error writing the contents of this segment to the associated storage device\n+     *\/\n+    void force();\n+\n@@ -655,1 +760,1 @@\n-     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegments#force(MemorySegment)}).\n+     *                might affect the behavior of the returned memory mapped segment (see {@link #force()}).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":110,"deletions":5,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+     * @param handle the resource scope handle to be released.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -259,0 +259,25 @@\n+    @Override\n+    public boolean isNative() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void load() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+    }\n+\n+    @Override\n+    public void unload() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+    }\n+\n+    @Override\n+    public boolean isLoaded() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+    }\n+\n+    @Override\n+    public void force() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -77,0 +77,5 @@\n+    @Override\n+    public boolean isNative() {\n+        return base() == null;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,0 +77,5 @@\n+    @Override\n+    public boolean isNative() {\n+        return true;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MappedMemorySegments;\n@@ -255,1 +254,1 @@\n-            MappedMemorySegments.force(segment);\n+            segment.force();\n@@ -291,1 +290,1 @@\n-                MappedMemorySegments.force(segment);\n+                segment.force();\n@@ -491,1 +490,1 @@\n-            MappedMemorySegments.force(segment);\n+            segment.force();\n@@ -513,4 +512,4 @@\n-            MappedMemorySegments.force(segment);\n-            MappedMemorySegments.load(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.unload(segment);\n+            segment.force();\n+            segment.load();\n+            segment.isLoaded();\n+            segment.unload();\n@@ -524,4 +523,4 @@\n-            MappedMemorySegments.force(segment);\n-            MappedMemorySegments.load(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.unload(segment);\n+            segment.force();\n+            segment.load();\n+            segment.isLoaded();\n+            segment.unload();\n@@ -888,4 +887,4 @@\n-        LOAD(MappedMemorySegments::load),\n-        UNLOAD(MappedMemorySegments::unload),\n-        IS_LOADED(MappedMemorySegments::isLoaded),\n-        FORCE(MappedMemorySegments::force),\n+        LOAD(MemorySegment::load),\n+        UNLOAD(MemorySegment::unload),\n+        IS_LOADED(MemorySegment::isLoaded),\n+        FORCE(MemorySegment::force),\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -180,0 +180,14 @@\n+    @Test(dataProvider = \"segmentFactories\")\n+    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        try {\n+            segment.address().toRawLongValue();\n+            assertTrue(segment.isNative());\n+            assertTrue(segment.address().isNative());\n+        } catch (UnsupportedOperationException exception) {\n+            assertFalse(segment.isNative());\n+            assertFalse(segment.address().isNative());\n+        }\n+        tryClose(segment);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}