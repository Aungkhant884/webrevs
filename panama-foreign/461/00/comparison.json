{"files":[{"patch":"@@ -1,1 +1,1 @@\n-Files in jdk.internal.clang.libclang package are jextract generated and then modified.\n+Files in jdk.internal.jextract.clang.libclang package are jextract generated and then modified.\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/README","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.internal.jextract.impl.DeclarationImpl;\n+import jdk.internal.jextract.parser.DeclarationImpl;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Declaration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,6 +28,6 @@\n-import jdk.internal.jextract.impl.ClangException;\n-import jdk.internal.jextract.impl.Filter;\n-import jdk.internal.jextract.impl.OutputFactory;\n-import jdk.internal.jextract.impl.Parser;\n-import jdk.internal.jextract.impl.Options;\n-import jdk.internal.jextract.impl.Writer;\n+import jdk.internal.jextract.parser.ClangException;\n+import jdk.internal.jextract.util.Filter;\n+import jdk.internal.jextract.gen.OutputFactory;\n+import jdk.internal.jextract.parser.Parser;\n+import jdk.internal.jextract.util.Options;\n+import jdk.internal.jextract.gen.Writer;\n@@ -49,1 +49,0 @@\n-import java.util.Optional;\n@@ -62,1 +61,1 @@\n-    private static final String MESSAGES_RESOURCE = \"jdk.internal.jextract.impl.resources.Messages\";\n+    private static final String MESSAGES_RESOURCE = \"jdk.internal.jextract.resources.Messages\";\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/JextractTool.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,3 +32,3 @@\n-import jdk.internal.jextract.impl.LayoutUtils;\n-import jdk.internal.jextract.impl.TypeImpl;\n-import jdk.internal.jextract.impl.UnsupportedLayouts;\n+import jdk.internal.jextract.layout.Layouts;\n+import jdk.internal.jextract.parser.TypeImpl;\n+import jdk.internal.jextract.layout.Layouts;\n@@ -107,1 +107,1 @@\n-            Char16(\"char16\", UnsupportedLayouts.CHAR16),\n+            Char16(\"char16\", Layouts.CHAR16),\n@@ -127,1 +127,1 @@\n-            Int128(\"__int128\", UnsupportedLayouts.__INT128),\n+            Int128(\"__int128\", Layouts.__INT128),\n@@ -139,1 +139,1 @@\n-            LongDouble(\"long double\", UnsupportedLayouts.LONG_DOUBLE),\n+            LongDouble(\"long double\", Layouts.LONG_DOUBLE),\n@@ -143,1 +143,1 @@\n-            Float128(\"float128\", UnsupportedLayouts._FLOAT128),\n+            Float128(\"float128\", Layouts._FLOAT128),\n@@ -147,1 +147,1 @@\n-            HalfFloat(\"__fp16\", UnsupportedLayouts.__FP16),\n+            HalfFloat(\"__fp16\", Layouts.__FP16),\n@@ -151,1 +151,1 @@\n-            WChar(\"wchar_t\", UnsupportedLayouts.WCHAR_T);\n+            WChar(\"wchar_t\", Layouts.WCHAR_T);\n@@ -383,1 +383,1 @@\n-        return LayoutUtils.getLayout(t);\n+        return Layouts.getLayout(t);\n@@ -392,1 +392,1 @@\n-        return LayoutUtils.getDescriptor(function);\n+        return Layouts.getDescriptor(function);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Type.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.clang;\n-\n-import java.util.Arrays;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.function.Function;\n-\n-import static java.util.stream.Collectors.toMap;\n-import static jdk.internal.clang.libclang.Index_h.CXError_ASTReadError;\n-import static jdk.internal.clang.libclang.Index_h.CXError_Crashed;\n-import static jdk.internal.clang.libclang.Index_h.CXError_Failure;\n-import static jdk.internal.clang.libclang.Index_h.CXError_InvalidArguments;\n-import static jdk.internal.clang.libclang.Index_h.CXError_Success;\n-\n-public enum ErrorCode {\n-    Success(CXError_Success()),\n-    Failure(CXError_Failure()),\n-    Crashed(CXError_Crashed()),\n-    InvalidArguments(CXError_InvalidArguments()),\n-    ASTReadError(CXError_ASTReadError());\n-\n-    private final int code;\n-\n-    ErrorCode(int code) {\n-        this.code = code;\n-    }\n-\n-    public int code() {\n-        return code;\n-    }\n-\n-    private static final Map<Integer, ErrorCode> lookup = Arrays.stream(values())\n-            .collect(toMap(ErrorCode::code, Function.identity()));\n-\n-    public static ErrorCode valueOf(int code) {\n-        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No ErrorCode with code: \" + k); });\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/ErrorCode.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.clang;\n-\n-import java.util.Arrays;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.function.Function;\n-\n-import static java.util.stream.Collectors.toMap;\n-import static jdk.internal.clang.libclang.Index_h.CXSaveError_InvalidTU;\n-import static jdk.internal.clang.libclang.Index_h.CXSaveError_None;\n-import static jdk.internal.clang.libclang.Index_h.CXSaveError_TranslationErrors;\n-import static jdk.internal.clang.libclang.Index_h.CXSaveError_Unknown;\n-\n-public enum SaveError {\n-    None(CXSaveError_None()),\n-    Unknown(CXSaveError_Unknown()),\n-    TranslationErrors(CXSaveError_TranslationErrors()),\n-    InvalidTU(CXSaveError_InvalidTU());\n-\n-    private final int code;\n-\n-    SaveError(int code) {\n-        this.code = code;\n-    }\n-\n-    public int code() {\n-        return code;\n-    }\n-\n-    private static final Map<Integer, SaveError> lookup = Arrays.stream(values())\n-            .collect(toMap(SaveError::code, Function.identity()));\n-\n-    public static SaveError valueOf(int code) {\n-        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No SaveError with code: \" + k); });\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SaveError.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/AccessSpecifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/AccessSpecifier.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/CallingConvention.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/CallingConvention.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -31,1 +31,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/Cursor.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Cursor.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/CursorKind.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/CursorKind.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -29,1 +29,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/Diagnostic.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Diagnostic.java","status":"renamed"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXError_ASTReadError;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXError_Crashed;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXError_Failure;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXError_InvalidArguments;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXError_Success;\n+\n+public enum ErrorCode {\n+    Success(CXError_Success()),\n+    Failure(CXError_Failure()),\n+    Crashed(CXError_Crashed()),\n+    InvalidArguments(CXError_InvalidArguments()),\n+    ASTReadError(CXError_ASTReadError());\n+\n+    private final int code;\n+\n+    ErrorCode(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, ErrorCode> lookup = Arrays.stream(values())\n+            .collect(toMap(ErrorCode::code, Function.identity()));\n+\n+    public static ErrorCode valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No ErrorCode with code: \" + k); });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/ErrorCode.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -31,1 +31,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/EvalResult.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/EvalResult.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -35,1 +35,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n@@ -42,1 +42,0 @@\n-import java.util.stream.Stream;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/Index.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Index.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -33,1 +33,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/LibClang.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/LibClang.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -30,1 +30,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/PrintingPolicy.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/PrintingPolicy.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/PrintingPolicyProperty.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/PrintingPolicyProperty.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/RefQualifierKind.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/RefQualifierKind.java","status":"renamed"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXSaveError_InvalidTU;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXSaveError_None;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXSaveError_TranslationErrors;\n+import static jdk.internal.jextract.clang.libclang.Index_h.CXSaveError_Unknown;\n+\n+public enum SaveError {\n+    None(CXSaveError_None()),\n+    Unknown(CXSaveError_Unknown()),\n+    TranslationErrors(CXSaveError_TranslationErrors()),\n+    InvalidTU(CXSaveError_InvalidTU());\n+\n+    private final int code;\n+\n+    SaveError(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, SaveError> lookup = Arrays.stream(values())\n+            .collect(toMap(SaveError::code, Function.identity()));\n+\n+    public static SaveError valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No SaveError with code: \" + k); });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/SaveError.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -33,1 +33,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/SourceLocation.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceLocation.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -29,1 +29,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/SourceRange.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceRange.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/TemplateArgumentKind.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TemplateArgumentKind.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -35,1 +35,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/TranslationUnit.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TranslationUnit.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n@@ -31,1 +31,1 @@\n-import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.jextract.clang.libclang.Index_h;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/Type.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Type.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/TypeKind.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TypeKind.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang;\n+package jdk.internal.jextract.clang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/TypeLayoutError.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TypeLayoutError.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang.libclang;\n+package jdk.internal.jextract.clang.libclang;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/libclang\/C.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/C.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package jdk.internal.clang.libclang;\n+package jdk.internal.jextract.clang.libclang;\n@@ -34,1 +34,1 @@\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/libclang\/Index_h$constants_0.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h$constants_0.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package jdk.internal.clang.libclang;\n+package jdk.internal.jextract.clang.libclang;\n@@ -34,1 +34,1 @@\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/libclang\/Index_h$constants_1.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h$constants_1.java","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-package jdk.internal.clang.libclang;\n+package jdk.internal.jextract.clang.libclang;\n@@ -34,1 +34,1 @@\n-import jdk.incubator.foreign.MemoryLayout.PathElement;\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/libclang\/Index_h.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-package jdk.internal.clang.libclang;\n+package jdk.internal.jextract.clang.libclang;\n@@ -43,1 +43,0 @@\n-import java.nio.charset.StandardCharsets;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/clang\/libclang\/RuntimeHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/RuntimeHelper.java","status":"renamed"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.gen;\n+\n+public class CompilationFailedException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+\n+    public CompilationFailedException(String msg) {\n+        super(msg);\n+    }\n+\n+    public CompilationFailedException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/CompilationFailedException.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n@@ -36,0 +36,1 @@\n+import jdk.internal.jextract.layout.Layouts;\n@@ -278,1 +279,1 @@\n-            boolean isBitfield = LayoutUtils.isBitfields(group);\n+            boolean isBitfield = Layouts.isBitfields(group);\n@@ -364,1 +365,1 @@\n-        if (UnsupportedLayouts.isUnsupported(vl)) {\n+        if (Layouts.isUnsupported(vl)) {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/ConstantBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n@@ -30,1 +30,1 @@\n-import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n+import jdk.internal.jextract.gen.ConstantBuilder.Constant;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/FunctionalInterfaceBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/FunctionalInterfaceScanner.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceScanner.java","status":"renamed"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.gen;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.jextract.Type;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+abstract class HeaderFileBuilder extends JavaSourceBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n+\n+    private final String superclass;\n+\n+    HeaderFileBuilder(ClassDesc desc, String superclass) {\n+        super(Kind.CLASS, desc);\n+        this.superclass = superclass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superclass;\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        if (type.equals(MemorySegment.class)) {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addSegment(javaName, nativeName, layout)\n+                        .emitGetter(this, MEMBER_MODS, ConstantBuilder.Constant.QUALIFIED_NAME, nativeName);\n+            });\n+        } else {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addLayout(javaName, layout)\n+                        .emitGetter(this, MEMBER_MODS, ConstantBuilder.Constant.QUALIFIED_NAME);\n+                ConstantBuilder.Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, layout, type)\n+                        .emitGetter(this, MEMBER_MODS, ConstantBuilder.Constant.QUALIFIED_NAME);\n+                ConstantBuilder.Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, layout)\n+                        .emitGetter(this, MEMBER_MODS, ConstantBuilder.Constant.QUALIFIED_NAME, nativeName);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, type);\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, type);\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+        emitWithConstantClass(javaName, constantBuilder -> {\n+            ConstantBuilder.Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, varargs)\n+                    .emitGetter(this, MEMBER_MODS, ConstantBuilder.Constant.QUALIFIED_NAME, nativeName);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, mtype, varargs, paramNames);\n+        });\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        if (type.equals(MemorySegment.class) || type.equals(MemoryAddress.class)) {\n+            emitWithConstantClass(javaName, constantBuilder -> {\n+                constantBuilder.addConstantDesc(javaName, type, value)\n+                        .emitGetter(this, MEMBER_MODS, ConstantBuilder.Constant.JAVA_NAME);\n+            });\n+        } else {\n+            emitGetter(MEMBER_MODS, type, javaName, getConstantString(type, value));\n+        }\n+    }\n+\n+    @Override\n+    public void addTypedef(String name, String superClass, Type type) {\n+        if (type instanceof Type.Primitive) {\n+            \/\/ primitive\n+            emitPrimitiveTypedef((Type.Primitive)type, name);\n+        } else {\n+            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n+            builder.classBegin();\n+            builder.classEnd();\n+        }\n+    }\n+\n+    \/\/ private generation\n+\n+    private void emitFunctionWrapper(ConstantBuilder.Constant mhConstant, String javaName, String nativeName, MethodType mtype,\n+                                     boolean varargs, List<String> paramNames) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        final int numParams = paramNames.size();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = paramNames.get(i);\n+            if (pName.isEmpty()) {\n+                pName = \"x\" + i;\n+            }\n+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = mtype.parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        if (varargs) {\n+            String lastArg = \"x\" + numParams;\n+            if (numParams > 0) {\n+                append(\", \");\n+            }\n+            append(\"Object... \" + lastArg);\n+            pExprs.add(lastArg);\n+        }\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+        append(mhConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\");\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!mtype.returnType().equals(void.class)) {\n+            append(\"return (\" + mtype.returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n+        Type.Primitive.Kind kind = primType.kind();\n+        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS);\n+            append(\" ValueLayout \");\n+            append(uniqueNestedClassName(name));\n+            append(\" = \");\n+            append(TypeTranslator.typeToLayoutName(kind));\n+            append(\";\\n\");\n+            decrAlign();\n+        }\n+    }\n+\n+    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n+        return switch(kind) {\n+            case Short, Int, Long, LongLong, Float, Double, Char -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private String getConstantString(Class<?> type, Object value) {\n+        StringBuilder buf = new StringBuilder();\n+        if (type == float.class) {\n+            float f = ((Number)value).floatValue();\n+            if (Float.isFinite(f)) {\n+                buf.append(value);\n+                buf.append(\"f\");\n+            } else {\n+                buf.append(\"Float.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else if (type == long.class) {\n+            buf.append(value);\n+            buf.append(\"L\");\n+        } else if (type == double.class) {\n+            double d = ((Number)value).doubleValue();\n+            if (Double.isFinite(d)) {\n+                buf.append(value);\n+                buf.append(\"d\");\n+            } else {\n+                buf.append(\"Double.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else {\n+            buf.append(\"(\" + type.getName() + \")\");\n+            buf.append(value + \"L\");\n+        }\n+        return buf.toString();\n+    }\n+\n+    private void emitGlobalGetter(ConstantBuilder.Constant segmentConstant, ConstantBuilder.Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \") \");\n+        append(vhConstant.accessExpression());\n+        append(\".get(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalSetter(ConstantBuilder.Constant segmentConstant, ConstantBuilder.Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"), x);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/HeaderFileBuilder.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.gen;\n+\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import java.io.*;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+final class InMemoryJavaCompiler {\n+    private InMemoryJavaCompiler() {}\n+\n+    static List<JavaFileObject> compile(List<JavaFileObject> files,\n+                                        String... options) {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        FileManager fileManager = new FileManager(compiler.getStandardFileManager(null, null, null));\n+\n+        Writer writer = new StringWriter();\n+        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, files).call();\n+        if (!exitCode) {\n+            throw new CompilationFailedException(\"In memory compilation failed: \" + writer.toString());\n+        }\n+        return fileManager.getCompiledFiles();\n+    }\n+\n+    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n+            @Override\n+            public InputStream openInputStream() {\n+                return new ByteArrayInputStream(bytes);\n+            }\n+        };\n+    }\n+\n+    static JavaFileObject jfoFromString(URI uri, String contents) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    \/\/ Wraper for class byte array\n+    private static class ClassFile extends SimpleJavaFileObject {\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        protected ClassFile(String name) {\n+            super(URI.create(name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n+        }\n+\n+        @Override\n+        public ByteArrayOutputStream openOutputStream() {\n+            return this.baos;\n+        }\n+\n+        @Override\n+        public InputStream openInputStream() {\n+            return new ByteArrayInputStream(baos.toByteArray());\n+        }\n+    }\n+\n+    \/\/ File manager which spawns ClassFile instances on demand\n+    private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private final List<JavaFileObject> compiled = new ArrayList<>();\n+\n+        protected FileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+\n+        @Override\n+        public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {\n+            JavaFileObject out = new ClassFile(name);\n+            compiled.add(out);\n+            return out;\n+        }\n+\n+        public List<JavaFileObject> getCompiledFiles() {\n+            return compiled;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/InMemoryJavaCompiler.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/JavaSourceBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n+\n+import jdk.internal.jextract.gen.ConstantBuilder;\n+import jdk.internal.jextract.gen.JavaSourceBuilder;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/NestedClassBuilder.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/NestedClassBuilder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n@@ -31,0 +31,1 @@\n+import jdk.internal.jextract.layout.Layouts;\n@@ -128,1 +129,1 @@\n-        URL runtimeHelper = OutputFactory.class.getResource(\"resources\/RuntimeHelper.java.template\");\n+        URL runtimeHelper = OutputFactory.class.getResource(\"\/jdk\/internal\/jextract\/resources\/RuntimeHelper.java.template\");\n@@ -212,1 +213,1 @@\n-            if (UnsupportedLayouts.isUnsupported(layout)) {\n+            if (Layouts.isUnsupported(layout)) {\n@@ -263,1 +264,1 @@\n-                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n+                    Layouts.getUnsupportedTypeName(unsupportedLayout));\n@@ -286,1 +287,1 @@\n-                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n+                    Layouts.getUnsupportedTypeName(unsupportedLayout));\n@@ -426,1 +427,1 @@\n-                    UnsupportedLayouts.getUnsupportedTypeName(ul));\n+                    Layouts.getUnsupportedTypeName(ul));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/OutputFactory.java","additions":8,"deletions":7,"binary":false,"changes":15,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n@@ -32,0 +32,1 @@\n+import jdk.internal.jextract.layout.Layouts;\n@@ -39,2 +40,0 @@\n-import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n-\n@@ -122,1 +121,1 @@\n-            if (ml.attribute(JEXTRACT_ANONYMOUS).isPresent()) {\n+            if (ml.attribute(Layouts.JEXTRACT_ANONYMOUS).isPresent()) {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/StructBuilder.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n@@ -37,1 +37,0 @@\n-import java.util.function.Consumer;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/ToplevelBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/TypeTranslator.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeTranslator.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.gen;\n+\n+import jdk.internal.jextract.gen.JavaSourceBuilder;\n+import jdk.internal.jextract.gen.NestedClassBuilder;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/TypedefBuilder.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","status":"renamed"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.gen;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import java.io.IOException;\n+import java.net.URI;\n+\n+\/**\n+ * General utility functions\n+ *\/\n+class Utils {\n+    private static URI fileName(String pkgName, String clsName, String extension) {\n+        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+        return URI.create(pkgPrefix + clsName + extension);\n+    }\n+\n+    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {\n+        return new SimpleJavaFileObject(fileName(pkgName, clsName, \".java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    static String javaSafeIdentifier(String name) {\n+        return javaSafeIdentifier(name, false);\n+    }\n+\n+    static String javaSafeIdentifier(String name, boolean checkAllChars) {\n+        if (checkAllChars) {\n+            StringBuilder buf = new StringBuilder();\n+            char[] chars = name.toCharArray();\n+            if (Character.isJavaIdentifierStart(chars[0])) {\n+                buf.append(chars[0]);\n+            } else {\n+                buf.append('_');\n+            }\n+            if (chars.length > 1) {\n+                for (int i = 1; i < chars.length; i++) {\n+                    char ch = chars[i];\n+                    if (Character.isJavaIdentifierPart(ch)) {\n+                        buf.append(ch);\n+                    } else {\n+                        buf.append('_');\n+                    }\n+                }\n+            }\n+            return buf.toString();\n+        } else {\n+            \/\/ We never get the problem of Java non-identifiers (like 123, ab-xy) as\n+            \/\/ C identifiers. But we may have a java keyword used as a C identifier.\n+            assert SourceVersion.isIdentifier(name);\n+\n+            return SourceVersion.isKeyword(name) || isRestrictedTypeName(name) ? (name + \"_\") : name;\n+        }\n+    }\n+\n+    private static boolean isRestrictedTypeName(String name) {\n+        return switch (name) {\n+            case \"var\", \"yield\", \"record\",\n+                \"sealed\", \"permits\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    \/*\n+     * FIXME: when we add jdk.compiler dependency from jdk.jextract module, revisit\n+     * the following. The following methods 'quote', 'quote' and 'isPrintableAscii'\n+     * are from javac source. See also com.sun.tools.javac.util.Convert.java.\n+     *\/\n+\n+    \/**\n+     * Escapes each character in a string that has an escape sequence or\n+     * is non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        switch (ch) {\n+        case '\\b':  return \"\\\\b\";\n+        case '\\f':  return \"\\\\f\";\n+        case '\\n':  return \"\\\\n\";\n+        case '\\r':  return \"\\\\r\";\n+        case '\\t':  return \"\\\\t\";\n+        case '\\'':  return \"\\\\'\";\n+        case '\\\"':  return \"\\\\\\\"\";\n+        case '\\\\':  return \"\\\\\\\\\";\n+        default:\n+            return (isPrintableAscii(ch))\n+                ? String.valueOf(ch)\n+                : String.format(\"\\\\u%04x\", (int) ch);\n+        }\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    private static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/Utils.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.gen;\n+\n+import jdk.internal.jextract.gen.InMemoryJavaCompiler;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public final class Writer {\n+    private final List<? extends JavaFileObject> files;\n+    private final Path dest;\n+\n+    public Writer(Path dest, List<? extends JavaFileObject> files) {\n+        this.files = files;\n+        this.dest = dest;\n+    }\n+\n+    private List<JavaFileObject> ensureSourcesCompiled() {\n+        List<JavaFileObject> sources = sources();\n+        if (sources.isEmpty()) {\n+            return List.of();\n+        } else {\n+            return InMemoryJavaCompiler.compile(sources,\n+                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \"--release\", \"16\",\n+                \"-d\", dest.toAbsolutePath().toString(),\n+                \"-cp\", dest.toAbsolutePath().toString());\n+        }\n+    }\n+\n+    public void writeAll(boolean compileSources) throws IOException {\n+        writeClassFiles(resources());\n+        writeClassFiles(classes());\n+        if (compileSources) {\n+            writeClassFiles(ensureSourcesCompiled());\n+        } else {\n+            writeSourceFiles();\n+        }\n+    }\n+\n+    void writeClassFiles(List<JavaFileObject> files) throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : files) {\n+            String path = entry.getName();\n+            Path fullPath = destDir.resolve(path).normalize();\n+            Files.createDirectories(fullPath.getParent());\n+            try (InputStream is = entry.openInputStream()) {\n+                Files.write(fullPath, is.readAllBytes());\n+            }\n+        }\n+    }\n+\n+    void writeSourceFiles() throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : sources()) {\n+            String srcPath = entry.getName();\n+            Path fullPath = destDir.resolve(srcPath).normalize();\n+            Path dir = fullPath.getParent();\n+            \/\/ In case the folder exist and is a link to a folder, this should be OK\n+            \/\/ Case in point, \/tmp on MacOS link to \/private\/tmp\n+            if (Files.exists(dir)) {\n+                if (!Files.isDirectory(dir)) {\n+                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());\n+                }\n+            } else {\n+                Files.createDirectories(fullPath.getParent());\n+            }\n+            Files.write(fullPath, List.of(entry.getCharContent(false)));\n+        }\n+    }\n+\n+    private List<JavaFileObject> sources() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.SOURCE)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> classes() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.CLASS)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> resources() {\n+        return files.stream()\n+                .filter(jfo -> (jfo.getKind() == JavaFileObject.Kind.HTML || jfo.getKind() == JavaFileObject.Kind.OTHER))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Path createOutputDir() throws IOException {\n+        Path absDest = dest.toAbsolutePath();\n+        if (!Files.exists(absDest)) {\n+            Files.createDirectories(absDest);\n+        }\n+        if (!Files.isDirectory(absDest)) {\n+            throw new IOException(\"Not a directory: \" + dest);\n+        }\n+        return absDest;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/gen\/Writer.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-public class ClangException extends RuntimeException {\n-    private static final long serialVersionUID = 0L;\n-\n-    public ClangException(String message) {\n-        super(message);\n-    }\n-\n-    public ClangException(String message, Throwable cause) {\n-        super(message, cause);\n-    }\n-\n-    public ClangException(Throwable cause) {\n-        super(cause);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClangException.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-public class CompilationFailedException extends RuntimeException {\n-    private static final long serialVersionUID = 1L;\n-\n-    public CompilationFailedException(String msg) {\n-        super(msg);\n-    }\n-\n-    public CompilationFailedException(String msg, Throwable cause) {\n-        super(msg, cause);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/CompilationFailedException.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,393 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import java.lang.constant.Constable;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Position;\n-import jdk.incubator.jextract.Type;\n-\n-public abstract class DeclarationImpl implements Declaration {\n-\n-    private final String name;\n-    private final Position pos;\n-    private final Optional<Map<String, List<Constable>>> attributes;\n-\n-    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {\n-        this.name = name;\n-        this.pos = pos;\n-        this.attributes = Optional.ofNullable(attrs);\n-    }\n-\n-    public String toString() {\n-        return new PrettyPrinter().print(this);\n-    }\n-\n-    public String name() {\n-        return name;\n-    }\n-\n-    @Override\n-    public Position pos() {\n-        return pos;\n-    }\n-\n-    @Override\n-    public Optional<List<Constable>> getAttribute(String name) {\n-        return attributes.map(attrs -> attrs.get(name));\n-    }\n-\n-    @Override\n-    public Set<String> attributeNames() { return Collections.unmodifiableSet(\n-            attributes.map(Map::keySet).orElse(Collections.emptySet()));\n-    }\n-\n-    @Override\n-    public Declaration withAttribute(String name, Constable... values) {\n-        if (values == null || values.length == 0) {\n-            return withAttributes(null);\n-        }\n-        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);\n-        attrs.put(name, List.of(values));\n-        return withAttributes(attrs);\n-    }\n-\n-    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (!(o instanceof Declaration)) return false;\n-        Declaration decl = (Declaration) o;\n-        return name().equals(decl.name());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(name);\n-    }\n-\n-    public static final class TypedefImpl extends DeclarationImpl implements Declaration.Typedef {\n-        final Type type;\n-\n-        public TypedefImpl(Type type, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n-            this.type = Objects.requireNonNull(type);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitTypedef(this, data);\n-        }\n-\n-        @Override\n-        public Type type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public Typedef withAttributes(Map<String, List<Constable>> attrs) {\n-            return new TypedefImpl(type, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Typedef stripAttributes() {\n-            return new TypedefImpl(type, name(), pos(), null);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Declaration.Typedef)) return false;\n-\n-            Declaration.Typedef other = (Declaration.Typedef) o;\n-            return name().equals(other.name()) &&\n-                    type.equals(other.type());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), type);\n-        }\n-    }\n-\n-    public static final class VariableImpl extends DeclarationImpl implements Declaration.Variable {\n-\n-        final Variable.Kind kind;\n-        final Type type;\n-        final Optional<MemoryLayout> layout;\n-\n-        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n-            this.kind = Objects.requireNonNull(kind);\n-            this.type = Objects.requireNonNull(type);\n-            this.layout = Objects.requireNonNull(layout);\n-        }\n-\n-        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n-            this(type, LayoutUtils.getLayout(type), kind, name, pos, null);\n-        }\n-\n-        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {\n-            this(type, Optional.of(layout), kind, name, pos, null);\n-        }\n-\n-        @Override\n-        public Kind kind() {\n-            return kind;\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitVariable(this, data);\n-        }\n-\n-        @Override\n-        public Type type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public Optional<MemoryLayout> layout() {\n-            return layout;\n-        }\n-\n-        @Override\n-        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n-            return new VariableImpl(type, layout, kind, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Variable stripAttributes() {\n-            return new VariableImpl(type, layout, kind, name(), pos(), null);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Declaration.Variable)) return false;\n-\n-            Declaration.Variable variable = (Declaration.Variable) o;\n-            if (!super.equals(o)) return false;\n-            return kind == variable.kind() &&\n-                    type.equals(variable.type());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), kind, type);\n-        }\n-    }\n-\n-    public static final class FunctionImpl extends DeclarationImpl implements Declaration.Function {\n-\n-        final List<Variable> params;\n-        final Type.Function type;\n-\n-        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos) {\n-            this(type, params, name, pos, null);\n-        }\n-\n-        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n-            this.params = Objects.requireNonNull(params);\n-            this.type = Objects.requireNonNull(type);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitFunction(this, data);\n-        }\n-\n-        @Override\n-        public List<Variable> parameters() {\n-            return params;\n-        }\n-\n-        @Override\n-        public Type.Function type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public Function withAttributes(Map<String, List<Constable>> attrs) {\n-            return new FunctionImpl(type, params, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Function stripAttributes() {\n-            return new FunctionImpl(type, params, name(), pos(), null);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Declaration.Function)) return false;\n-            if (!super.equals(o)) return false;\n-\n-            Declaration.Function function = (Declaration.Function) o;\n-            return type.equals(function.type());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), type);\n-        }\n-    }\n-\n-    public static class ScopedImpl extends DeclarationImpl implements Declaration.Scoped {\n-\n-        private final Scoped.Kind kind;\n-        private final List<Declaration> declarations;\n-        private final Optional<MemoryLayout> optLayout;\n-\n-        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {\n-            this(kind, Optional.of(layout), declarations, name, pos, null);\n-        }\n-\n-        public ScopedImpl(Kind kind, List<Declaration> declarations, String name, Position pos) {\n-            this(kind, Optional.empty(), declarations, name, pos, null);\n-        }\n-\n-        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,\n-                String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n-            this.kind = Objects.requireNonNull(kind);\n-            this.declarations = Objects.requireNonNull(declarations);\n-            this.optLayout = Objects.requireNonNull(optLayout);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitScoped(this, data);\n-        }\n-\n-        @Override\n-        public List<Declaration> members() {\n-            return declarations;\n-        }\n-\n-        @Override\n-        public Optional<MemoryLayout> layout() {\n-            return optLayout;\n-        }\n-\n-        @Override\n-        public Kind kind() {\n-            return kind;\n-        }\n-\n-        @Override\n-        public Scoped withAttributes(Map<String, List<Constable>> attrs) {\n-            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Scoped stripAttributes() {\n-            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Declaration.Scoped)) return false;\n-            if (!super.equals(o)) return false;\n-            Declaration.Scoped scoped = (Declaration.Scoped) o;\n-            return kind == scoped.kind() &&\n-                    declarations.equals(scoped.members());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), kind, declarations);\n-        }\n-    }\n-\n-    public static final class ConstantImpl extends DeclarationImpl implements Declaration.Constant {\n-\n-        final Object value;\n-        final Type type;\n-\n-        public ConstantImpl(Type type, Object value, String name, Position pos) {\n-            this(type, value, name, pos, null);\n-        }\n-\n-        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {\n-            super(name, pos, attrs);\n-            this.value = Objects.requireNonNull(value);\n-            this.type = Objects.requireNonNull(type);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitConstant(this, data);\n-        }\n-\n-        @Override\n-        public Object value() {\n-            return value;\n-        }\n-\n-        @Override\n-        public Type type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public Constant withAttributes(Map<String, List<Constable>> attrs) {\n-            return new ConstantImpl(type, value, name(), pos(), attrs);\n-        }\n-\n-        @Override\n-        public Constant stripAttributes() {\n-            return new ConstantImpl(type, value, name(), pos(), null);\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Declaration.Constant)) return false;\n-            if (!super.equals(o)) return false;\n-            Declaration.Constant constant = (Declaration.Constant) o;\n-            return value.equals(constant.value()) &&\n-                    type.equals(constant.type());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), value, type);\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/DeclarationImpl.java","additions":0,"deletions":393,"binary":false,"changes":393,"status":"deleted"},{"patch":"@@ -1,273 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.jextract.Type;\n-\n-import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * A helper class to generate header interface class in source form.\n- * After aggregating various constituents of a .java source, build\n- * method is called to get overall generated source string.\n- *\/\n-abstract class HeaderFileBuilder extends JavaSourceBuilder {\n-\n-    private static final String MEMBER_MODS = \"public static\";\n-\n-    private final String superclass;\n-\n-    HeaderFileBuilder(ClassDesc desc, String superclass) {\n-        super(Kind.CLASS, desc);\n-        this.superclass = superclass;\n-    }\n-\n-    @Override\n-    String superClass() {\n-        return superclass;\n-    }\n-\n-    @Override\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        if (type.equals(MemorySegment.class)) {\n-            emitWithConstantClass(javaName, constantBuilder -> {\n-                constantBuilder.addSegment(javaName, nativeName, layout)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-            });\n-        } else {\n-            emitWithConstantClass(javaName, constantBuilder -> {\n-                constantBuilder.addLayout(javaName, layout)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n-                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, layout, type)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n-                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, layout)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, type);\n-                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, type);\n-            });\n-        }\n-    }\n-\n-    @Override\n-    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n-        emitWithConstantClass(javaName, constantBuilder -> {\n-            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, varargs)\n-                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-            emitFunctionWrapper(mhConstant, javaName, nativeName, mtype, varargs, paramNames);\n-        });\n-    }\n-\n-    @Override\n-    public void addConstant(String javaName, Class<?> type, Object value) {\n-        if (type.equals(MemorySegment.class) || type.equals(MemoryAddress.class)) {\n-            emitWithConstantClass(javaName, constantBuilder -> {\n-                constantBuilder.addConstantDesc(javaName, type, value)\n-                        .emitGetter(this, MEMBER_MODS, Constant.JAVA_NAME);\n-            });\n-        } else {\n-            emitGetter(MEMBER_MODS, type, javaName, getConstantString(type, value));\n-        }\n-    }\n-\n-    @Override\n-    public void addTypedef(String name, String superClass, Type type) {\n-        if (type instanceof Type.Primitive) {\n-            \/\/ primitive\n-            emitPrimitiveTypedef((Type.Primitive)type, name);\n-        } else {\n-            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n-            builder.classBegin();\n-            builder.classEnd();\n-        }\n-    }\n-\n-    \/\/ private generation\n-\n-    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType mtype,\n-                                  boolean varargs, List<String> paramNames) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \");\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n-        String delim = \"\";\n-        List<String> pExprs = new ArrayList<>();\n-        final int numParams = paramNames.size();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = paramNames.get(i);\n-            if (pName.isEmpty()) {\n-                pName = \"x\" + i;\n-            }\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n-            Class<?> pType = mtype.parameterType(i);\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n-            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n-            delim = \", \";\n-        }\n-        if (varargs) {\n-            String lastArg = \"x\" + numParams;\n-            if (numParams > 0) {\n-                append(\", \");\n-            }\n-            append(\"Object... \" + lastArg);\n-            pExprs.add(lastArg);\n-        }\n-        append(\") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n-        append(mhConstant.accessExpression());\n-        append(\", \\\"\");\n-        append(nativeName);\n-        append(\"\\\");\\n\");\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n-        }\n-        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n-    private void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n-        Type.Primitive.Kind kind = primType.kind();\n-        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {\n-            incrAlign();\n-            indent();\n-            append(MEMBER_MODS);\n-            append(\" ValueLayout \");\n-            append(uniqueNestedClassName(name));\n-            append(\" = \");\n-            append(TypeTranslator.typeToLayoutName(kind));\n-            append(\";\\n\");\n-            decrAlign();\n-        }\n-    }\n-\n-    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n-        return switch(kind) {\n-            case Short, Int, Long, LongLong, Float, Double, Char -> true;\n-            default -> false;\n-        };\n-    }\n-\n-    private String getConstantString(Class<?> type, Object value) {\n-        StringBuilder buf = new StringBuilder();\n-        if (type == float.class) {\n-            float f = ((Number)value).floatValue();\n-            if (Float.isFinite(f)) {\n-                buf.append(value);\n-                buf.append(\"f\");\n-            } else {\n-                buf.append(\"Float.valueOf(\\\"\");\n-                buf.append(value.toString());\n-                buf.append(\"\\\")\");\n-            }\n-        } else if (type == long.class) {\n-            buf.append(value);\n-            buf.append(\"L\");\n-        } else if (type == double.class) {\n-            double d = ((Number)value).doubleValue();\n-            if (Double.isFinite(d)) {\n-                buf.append(value);\n-                buf.append(\"d\");\n-            } else {\n-                buf.append(\"Double.valueOf(\\\"\");\n-                buf.append(value.toString());\n-                buf.append(\"\\\")\");\n-            }\n-        } else {\n-            buf.append(\"(\" + type.getName() + \")\");\n-            buf.append(value + \"L\");\n-        }\n-        return buf.toString();\n-    }\n-\n-    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return (\" + type.getName() + \") \");\n-        append(vhConstant.accessExpression());\n-        append(\".get(RuntimeHelper.requireNonNull(\");\n-        append(segmentConstant.accessExpression());\n-        append(\", \\\"\");\n-        append(nativeName);\n-        append(\"\\\"));\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n-    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(vhConstant.accessExpression());\n-        append(\".set(RuntimeHelper.requireNonNull(\");\n-        append(segmentConstant.accessExpression());\n-        append(\", \\\"\");\n-        append(nativeName);\n-        append(\"\\\"), x);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":0,"deletions":273,"binary":false,"changes":273,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-import java.io.*;\n-import java.io.Writer;\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-final class InMemoryJavaCompiler {\n-    private InMemoryJavaCompiler() {}\n-\n-    static List<JavaFileObject> compile(List<JavaFileObject> files,\n-                                        String... options) {\n-        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n-        FileManager fileManager = new FileManager(compiler.getStandardFileManager(null, null, null));\n-\n-        Writer writer = new StringWriter();\n-        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, files).call();\n-        if (!exitCode) {\n-            throw new CompilationFailedException(\"In memory compilation failed: \" + writer.toString());\n-        }\n-        return fileManager.getCompiledFiles();\n-    }\n-\n-    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {\n-        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n-            @Override\n-            public InputStream openInputStream() {\n-                return new ByteArrayInputStream(bytes);\n-            }\n-        };\n-    }\n-\n-    static JavaFileObject jfoFromString(URI uri, String contents) {\n-        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return contents;\n-            }\n-        };\n-    }\n-\n-    \/\/ Wraper for class byte array\n-    private static class ClassFile extends SimpleJavaFileObject {\n-        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\n-        protected ClassFile(String name) {\n-            super(URI.create(name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n-        }\n-\n-        @Override\n-        public ByteArrayOutputStream openOutputStream() {\n-            return this.baos;\n-        }\n-\n-        @Override\n-        public InputStream openInputStream() {\n-            return new ByteArrayInputStream(baos.toByteArray());\n-        }\n-    }\n-\n-    \/\/ File manager which spawns ClassFile instances on demand\n-    private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n-        private final List<JavaFileObject> compiled = new ArrayList<>();\n-\n-        protected FileManager(JavaFileManager fileManager) {\n-            super(fileManager);\n-        }\n-\n-        @Override\n-        public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {\n-            JavaFileObject out = new ClassFile(name);\n-            compiled.add(out);\n-            return out;\n-        }\n-\n-        public List<JavaFileObject> getCompiledFiles() {\n-            return compiled;\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/InMemoryJavaCompiler.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,230 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.jextract.Type.Primitive;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.Type;\n-\n-import java.util.Optional;\n-import java.util.function.Supplier;\n-\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-\n-\/**\n- * General Layout utility functions\n- *\/\n-public final class LayoutUtils {\n-\n-    public static final String JEXTRACT_ANONYMOUS = \"jextract\/anonymous\";\n-    public static final String JEXTRACT_BITFIELDS = \"jextract\/bitfields\";\n-\n-    private LayoutUtils() {}\n-\n-    public static String getName(Type type) {\n-        Cursor c = type.getDeclarationCursor();\n-        if (c.isInvalid()) {\n-            return type.spelling();\n-        }\n-        return getName(c);\n-    }\n-\n-    public static String getName(Cursor cursor) {\n-        return cursor.spelling();\n-    }\n-\n-    public static MemoryLayout getLayout(Type t) {\n-        Supplier<UnsupportedOperationException> unsupported = () ->\n-                new UnsupportedOperationException(\"unsupported: \" + t.kind());\n-        switch(t.kind()) {\n-            case UChar, Char_U:\n-            case SChar, Char_S:\n-                return Primitive.Kind.Char.layout().orElseThrow(unsupported);\n-            case Short:\n-            case UShort:\n-                return Primitive.Kind.Short.layout().orElseThrow(unsupported);\n-            case Int:\n-            case UInt:\n-                return Primitive.Kind.Int.layout().orElseThrow(unsupported);\n-            case ULong:\n-            case Long:\n-                return Primitive.Kind.Long.layout().orElseThrow(unsupported);\n-            case ULongLong:\n-            case LongLong:\n-                return Primitive.Kind.LongLong.layout().orElseThrow(unsupported);\n-            case UInt128:\n-            case Int128:\n-                return Primitive.Kind.Int128.layout().orElseThrow(unsupported);\n-            case Enum:\n-                return valueLayoutForSize(t.size() * 8).layout().orElseThrow(unsupported);\n-            case Bool:\n-                return Primitive.Kind.Bool.layout().orElseThrow(unsupported);\n-            case Float:\n-                return Primitive.Kind.Float.layout().orElseThrow(unsupported);\n-            case Double:\n-                return Primitive.Kind.Double.layout().orElseThrow(unsupported);\n-            case LongDouble:\n-                return Primitive.Kind.LongDouble.layout().orElseThrow(unsupported);\n-            case Complex:\n-                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n-            case Record:\n-                return getRecordLayout(t);\n-            case Vector:\n-                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));\n-            case ConstantArray:\n-                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));\n-            case IncompleteArray:\n-                return MemoryLayout.ofSequence(getLayout(t.getElementType()));\n-            case Unexposed:\n-                Type canonical = t.canonicalType();\n-                if (canonical.equalType(t)) {\n-                    throw new TypeMaker.TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n-                }\n-                return getLayout(canonical);\n-            case Typedef:\n-            case Elaborated:\n-                return getLayout(t.canonicalType());\n-            case Pointer:\n-            case BlockPointer:\n-                return C_POINTER;\n-            default:\n-                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n-        }\n-    }\n-\n-    public static Optional<MemoryLayout> getLayout(jdk.incubator.jextract.Type t) {\n-        try {\n-            return Optional.of(getLayoutInternal(t));\n-        } catch (Throwable ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    public static MemoryLayout getLayoutInternal(jdk.incubator.jextract.Type t) {\n-        return t.accept(layoutMaker, null);\n-    }\n-\n-    private static jdk.incubator.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new jdk.incubator.jextract.Type.Visitor<>() {\n-        @Override\n-        public MemoryLayout visitPrimitive(jdk.incubator.jextract.Type.Primitive t, Void _ignored) {\n-            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDelegated(jdk.incubator.jextract.Type.Delegated t, Void _ignored) {\n-            if (t.kind() == jdk.incubator.jextract.Type.Delegated.Kind.POINTER) {\n-                return C_POINTER;\n-            } else {\n-                return t.type().accept(this, null);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitFunction(jdk.incubator.jextract.Type.Function t, Void _ignored) {\n-            \/*\n-             * \/\/ pointer to function declared as function like this\n-             *\n-             * typedef void CB(int);\n-             * void func(CB cb);\n-             *\/\n-            return C_POINTER;\n-        }\n-\n-        @Override\n-        public MemoryLayout visitDeclared(jdk.incubator.jextract.Type.Declared t, Void _ignored) {\n-            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n-        }\n-\n-        @Override\n-        public MemoryLayout visitArray(jdk.incubator.jextract.Type.Array t, Void _ignored) {\n-            MemoryLayout elem = t.elementType().accept(this, null);\n-            if (t.elementCount().isPresent()) {\n-                return MemoryLayout.ofSequence(t.elementCount().getAsLong(), elem);\n-            } else {\n-                return MemoryLayout.ofSequence(elem);\n-            }\n-        }\n-\n-        @Override\n-        public MemoryLayout visitType(jdk.incubator.jextract.Type t, Void _ignored) {\n-            throw new UnsupportedOperationException();\n-        }\n-    };\n-\n-    static MemoryLayout getRecordLayout(Type type) {\n-        return RecordLayoutComputer.compute(0, type, type);\n-    }\n-\n-    private static boolean isVoidType(jdk.incubator.jextract.Type type) {\n-        if (type instanceof jdk.incubator.jextract.Type.Primitive) {\n-            jdk.incubator.jextract.Type.Primitive pt = (jdk.incubator.jextract.Type.Primitive)type;\n-            return pt.kind() == jdk.incubator.jextract.Type.Primitive.Kind.Void;\n-        } else if (type instanceof jdk.incubator.jextract.Type.Delegated) {\n-            jdk.incubator.jextract.Type.Delegated dt = (jdk.incubator.jextract.Type.Delegated)type;\n-            return dt.kind() == jdk.incubator.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n-        }\n-        return false;\n-    }\n-\n-    public static Optional<FunctionDescriptor> getDescriptor(jdk.incubator.jextract.Type.Function t) {\n-        try {\n-            MemoryLayout[] args = t.argumentTypes().stream()\n-                    .map(LayoutUtils::getLayoutInternal)\n-                    .toArray(MemoryLayout[]::new);\n-            jdk.incubator.jextract.Type retType = t.returnType();\n-            if (isVoidType(retType)) {\n-                return Optional.of(FunctionDescriptor.ofVoid(args));\n-            } else {\n-                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n-            }\n-        } catch (Throwable ex) {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    public static Primitive.Kind valueLayoutForSize(long size) {\n-        return switch ((int) size) {\n-            case 8 -> Primitive.Kind.Char;\n-            case 16 -> Primitive.Kind.Short;\n-            case 32 -> Primitive.Kind.Int;\n-            case 64 -> Primitive.Kind.LongLong;\n-            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n-        };\n-    }\n-\n-    static boolean isBitfields(GroupLayout layout) {\n-        return layout.attribute(JEXTRACT_BITFIELDS).isPresent();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static <Z extends MemoryLayout> Z setBitfields(Z layout) {\n-        return (Z) layout.withAttribute(JEXTRACT_BITFIELDS, true);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/LayoutUtils.java","additions":0,"deletions":230,"binary":false,"changes":230,"status":"deleted"},{"patch":"@@ -1,379 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Position;\n-import jdk.incubator.jextract.Type;\n-import jdk.incubator.jextract.JextractTool;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.CursorKind;\n-import jdk.internal.clang.Diagnostic;\n-import jdk.internal.clang.EvalResult;\n-import jdk.internal.clang.Index;\n-import jdk.internal.clang.LibClang;\n-import jdk.internal.clang.TranslationUnit;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Collection;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-class MacroParserImpl {\n-\n-    private final ClangReparser reparser;\n-    private final TreeMaker treeMaker;\n-    final MacroTable macroTable;\n-\n-    private MacroParserImpl(ClangReparser reparser, TreeMaker treeMaker) {\n-        this.reparser = reparser;\n-        this.treeMaker = treeMaker;\n-        this.macroTable = new MacroTable();\n-    }\n-\n-    static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {\n-        ClangReparser reparser;\n-        try {\n-            reparser = new ClangReparser(tu, args);\n-        } catch (IOException | Index.ParsingFailedException ex) {\n-            throw new RuntimeException(ex);\n-        }\n-\n-        return new MacroParserImpl(reparser, treeMaker);\n-    }\n-\n-    \/**\n-     * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made\n-     * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.\n-     * If that is not possible (e.g. because the macro refers to other macro, or has a more complex grammar), fall\n-     * back to use clang evaluation support.\n-     *\/\n-    Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {\n-        if (!(pos instanceof TreeMaker.CursorPosition)) {\n-            return Optional.empty();\n-        } else {\n-            Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();\n-            if (cursor.isMacroFunctionLike()) {\n-                return Optional.empty();\n-            } else if (tokens.length == 2) {\n-                \/\/check for fast path\n-                Integer num = toNumber(tokens[1]);\n-                if (num != null) {\n-                    return Optional.of(treeMaker.createMacro(cursor, name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n-                }\n-            }\n-            macroTable.enterMacro(name, tokens, cursor);\n-            return Optional.empty();\n-        }\n-    }\n-\n-    private Integer toNumber(String str) {\n-        try {\n-            \/\/ Integer.decode supports '#' hex literals which is not valid in C.\n-            return str.length() > 0 && str.charAt(0) != '#'? Integer.decode(str) : null;\n-        } catch (NumberFormatException nfe) {\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * This class allows client to reparse a snippet of code against a given set of include files.\n-     * For performance reasons, the set of includes (which comes from the jextract parser) is compiled\n-     * into a precompiled header, so as to speed to incremental recompilation of the generated snippets.\n-     *\/\n-    static class ClangReparser {\n-        final Path macro;\n-        final Index macroIndex = LibClang.createIndex(true);\n-        final TranslationUnit macroUnit;\n-\n-        public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {\n-            Path precompiled = Files.createTempFile(\"jextract$\", \".pch\");\n-            precompiled.toFile().deleteOnExit();\n-            tu.save(precompiled);\n-            this.macro = Files.createTempFile(\"jextract$\", \".h\");\n-            this.macro.toFile().deleteOnExit();\n-            String[] patchedArgs = Stream.concat(\n-                Stream.of(\n-                    \/\/ Avoid system search path, use bundled instead\n-                    \"-nostdinc\",\n-                    \"-ferror-limit=0\",\n-                    \/\/ precompiled header\n-                    \"-include-pch\", precompiled.toAbsolutePath().toString()),\n-                args.stream()).toArray(String[]::new);\n-            this.macroUnit = macroIndex.parse(macro.toAbsolutePath().toString(),\n-                    this::processDiagnostics,\n-                    false, \/\/add serialization support (needed for macros)\n-                    patchedArgs);\n-        }\n-\n-        void processDiagnostics(Diagnostic diag) {\n-            if (JextractTool.DEBUG) {\n-                System.err.println(\"Error while processing macro: \" + diag.spelling());\n-            }\n-        }\n-\n-        public Stream<Cursor> reparse(String snippet) {\n-            macroUnit.reparse(this::processDiagnostics,\n-                    Index.UnsavedFile.of(macro, snippet));\n-            return macroUnit.getCursor().children();\n-        }\n-    }\n-\n-    \/**\n-     * This abstraction is used to collect all macros which could not be interpreted during {@link #parseConstant(Position, String, String[])}.\n-     * All unparsed macros in the table can have three different states: UNPARSED (which means the macro has not been parsed yet),\n-     * SUCCESS (which means the macro has been parsed and has a type and a value) and FAILURE, which means the macro has been\n-     * parsed with some errors, but for which we were at least able to infer a type.\n-     *\n-     * The reparsing process goes as follows:\n-     * 1. all unparsed macros are added to the table in the UNPARSED state.\n-     * 2. a snippet for all macros in the UNPARSED state is compiled and the table state is updated\n-     * 3. a recovery snippet for all macros in the FAILURE state is compiled and the table state is updated again\n-     * 4. we repeat from (2) until no further progress is made.\n-     * 5. we return a list of macro which are in the SUCCESS state.\n-     *\n-     * State transitions in the table are as follows:\n-     * - an UNPARSED macro can go to either SUCCESS, to FAILURE or be removed (if not even a type can be inferred)\n-     * - a FAILURE macro can go to either SUCCESS (if recovery step succeds) or be removed\n-     * - a SUCCESS macro cannot go in any other state\n-     *\/\n-    class MacroTable {\n-\n-        final Map<String, Entry> macrosByMangledName = new LinkedHashMap<>();\n-\n-        abstract class Entry {\n-            final String name;\n-            final String[] tokens;\n-            final Cursor cursor;\n-\n-            Entry(String name, String[] tokens, Cursor cursor) {\n-                this.name = name;\n-                this.tokens = tokens;\n-                this.cursor = cursor;\n-            }\n-\n-            String mangledName() {\n-                return \"jextract$macro$\" + name;\n-            }\n-\n-            Entry success(Type type, Object value) {\n-                throw new IllegalStateException();\n-            }\n-\n-            Entry failure(Type type) {\n-                throw new IllegalStateException();\n-            }\n-\n-            boolean isSuccess() {\n-                return false;\n-            }\n-            boolean isRecoverableFailure() {\n-                return false;\n-            }\n-            boolean isUnparsed() {\n-                return false;\n-            }\n-\n-            void update() {\n-                macrosByMangledName.put(mangledName(), this);\n-            }\n-        }\n-\n-        class Unparsed extends Entry {\n-            Unparsed(String name, String[] tokens, Cursor cursor) {\n-                super(name, tokens, cursor);\n-            }\n-\n-            @Override\n-            Entry success(Type type, Object value) {\n-                return new Success(name, tokens, cursor, type, value);\n-            }\n-\n-            @Override\n-            Entry failure(Type type) {\n-                return type != null ?\n-                        new RecoverableFailure(name, tokens, cursor, type) :\n-                        new UnparseableMacro(name, tokens, cursor);\n-            }\n-\n-            @Override\n-            boolean isUnparsed() {\n-                return true;\n-            }\n-\n-            @Override\n-            void update() {\n-                throw new IllegalStateException();\n-            }\n-        }\n-\n-        class RecoverableFailure extends Entry {\n-\n-            final Type type;\n-\n-            public RecoverableFailure(String name, String[] tokens, Cursor cursor, Type type) {\n-                super(name, tokens, cursor);\n-                this.type = type;\n-            }\n-\n-            @Override\n-            Entry success(Type type, Object value) {\n-                return new Success(name, tokens, cursor, this.type, value);\n-            }\n-\n-            @Override\n-            Entry failure(Type type) {\n-                return new UnparseableMacro(name, tokens, cursor);\n-            }\n-\n-            @Override\n-            boolean isRecoverableFailure() {\n-                return true;\n-            }\n-        }\n-\n-        class Success extends Entry {\n-            final Type type;\n-            final Object value;\n-\n-            public Success(String name, String[] tokens, Cursor cursor, Type type, Object value) {\n-                super(name, tokens, cursor);\n-                this.type = type;\n-                this.value = value;\n-            }\n-\n-            @Override\n-            boolean isSuccess() {\n-                return true;\n-            }\n-\n-            public Object value() {\n-                return value;\n-            }\n-        }\n-\n-        class UnparseableMacro extends Entry {\n-\n-            UnparseableMacro(String name, String[] tokens, Cursor cursor) {\n-                super(name, tokens, cursor);\n-            }\n-\n-            @Override\n-            void update() {\n-                macrosByMangledName.remove(mangledName());\n-            }\n-        };\n-\n-        void enterMacro(String name, String[] tokens, Cursor cursor) {\n-            Unparsed unparsed = new Unparsed(name, tokens, cursor);\n-            macrosByMangledName.put(unparsed.mangledName(), unparsed);\n-        }\n-\n-        public List<Declaration.Constant> reparseConstants() {\n-            int last = -1;\n-            while (macrosByMangledName.size() > 0 && last != macrosByMangledName.size()) {\n-                last = macrosByMangledName.size();\n-                \/\/ step 1 - try parsing macros as var declarations\n-                reparseMacros(false);\n-                \/\/ step 2 - retry failed parsed macros as pointers\n-                reparseMacros(true);\n-            }\n-            treeMaker.typeMaker.resolveTypeReferences();\n-            return macrosByMangledName.values().stream()\n-                    .filter(Entry::isSuccess)\n-                    .map(e -> treeMaker.createMacro(e.cursor, e.name, ((Success)e).type, ((Success)e).value))\n-                    .collect(Collectors.toList());\n-        }\n-\n-        void updateTable(TypeMaker typeMaker, Cursor decl) {\n-            String mangledName = decl.spelling();\n-            Entry entry = macrosByMangledName.get(mangledName);\n-            try (EvalResult result = decl.eval()) {\n-                Entry newEntry = switch (result.getKind()) {\n-                    case Integral -> {\n-                        long value = result.getAsInt();\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n-                    }\n-                    case FloatingPoint -> {\n-                        double value = result.getAsFloat();\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n-                    }\n-                    case StrLiteral -> {\n-                        String value = result.getAsString();\n-                        yield entry.success(typeMaker.makeType(decl.type()), value);\n-                    }\n-                    default -> {\n-                        Type type = decl.type().equals(decl.type().canonicalType()) ?\n-                                null : typeMaker.makeType(decl.type());\n-                        yield entry.failure(type);\n-                    }\n-                };\n-                newEntry.update();\n-            }\n-        }\n-\n-        void reparseMacros(boolean recovery) {\n-            String snippet = macroDecl(recovery);\n-            TreeMaker treeMaker = new TreeMaker();\n-            try {\n-                reparser.reparse(snippet)\n-                        .filter(c -> c.kind() == CursorKind.VarDecl &&\n-                                c.spelling().contains(\"jextract$\"))\n-                        .forEach(c -> updateTable(treeMaker.typeMaker, c));\n-            } finally {\n-                treeMaker.typeMaker.resolveTypeReferences();\n-            }\n-        }\n-\n-        String macroDecl(boolean recovery) {\n-            StringBuilder buf = new StringBuilder();\n-            if (recovery) {\n-                buf.append(\"#include <stdint.h>\\n\");\n-            }\n-            macrosByMangledName.values().stream()\n-                    .filter(e -> !e.isSuccess()) \/\/ skip macros that already have passed\n-                    .filter(recovery ? Entry::isRecoverableFailure : Entry::isUnparsed)\n-                    .forEach(e -> {\n-                        buf.append(\"__auto_type \")\n-                                .append(e.mangledName())\n-                                .append(\" = \");\n-                        if (recovery) {\n-                            buf.append(\"(uintptr_t)\");\n-                        }\n-                        buf.append(e.name)\n-                                .append(\";\\n\");\n-                    });\n-            return buf.toString();\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/MacroParserImpl.java","additions":0,"deletions":379,"binary":false,"changes":379,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.jextract.Declaration;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.CursorKind;\n-import jdk.internal.clang.Diagnostic;\n-import jdk.internal.clang.Index;\n-import jdk.internal.clang.LibClang;\n-import jdk.internal.clang.SourceLocation;\n-import jdk.internal.clang.SourceRange;\n-import jdk.internal.clang.TranslationUnit;\n-\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Optional;\n-\n-public class Parser {\n-    private final TreeMaker treeMaker;\n-\n-    public Parser() {\n-        this.treeMaker = new TreeMaker();\n-    }\n-\n-    public Declaration.Scoped parse(Path path, Collection<String> args) {\n-        final Index index = LibClang.createIndex(false);\n-\n-        TranslationUnit tu = index.parse(path.toString(),\n-            d -> {\n-                if (d.severity() > Diagnostic.CXDiagnostic_Warning) {\n-                    throw new ClangException(d.toString());\n-                }\n-            },\n-            true, args.toArray(new String[0]));\n-\n-        MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args);\n-\n-        List<Declaration> decls = new ArrayList<>();\n-        Cursor tuCursor = tu.getCursor();\n-        tuCursor.children().\n-            forEach(c -> {\n-                SourceLocation loc = c.getSourceLocation();\n-                if (loc == null) {\n-                    return;\n-                }\n-\n-                SourceLocation.Location src = loc.getFileLocation();\n-                if (src == null) {\n-                    return;\n-                }\n-\n-\n-                if (c.isDeclaration()) {\n-                    if (c.kind() == CursorKind.UnexposedDecl ||\n-                        c.kind() == CursorKind.Namespace) {\n-                        c.children().map(treeMaker::createTree)\n-                                .filter(t -> t != null)\n-                                .forEach(decls::add);\n-                    } else {\n-                        Declaration decl = treeMaker.createTree(c);\n-                        if (decl != null) {\n-                            decls.add(decl);\n-                        }\n-                    }\n-                } else if (isMacro(c) && src.path() != null) {\n-                    SourceRange range = c.getExtent();\n-                    String[] tokens = c.getTranslationUnit().tokens(range);\n-                    Optional<Declaration.Constant> constant = macroParser.parseConstant(treeMaker.toPos(c), c.spelling(), tokens);\n-                    if (constant.isPresent()) {\n-                        decls.add(constant.get());\n-                    }\n-                }\n-            });\n-\n-        decls.addAll(macroParser.macroTable.reparseConstants());\n-        Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);\n-        treeMaker.freeze();\n-        index.close();\n-        return rv;\n-    }\n-\n-    private boolean isMacro(Cursor c) {\n-        return c.isPreprocessing() && c.kind() == CursorKind.MacroDefinition;\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Parser.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import java.lang.constant.Constable;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Position;\n-import jdk.incubator.jextract.Type;\n-\n-public class PrettyPrinter implements Declaration.Visitor<Void, Void> {\n-\n-    int align = 0;\n-\n-    void incr() {\n-        align += 4;\n-    }\n-\n-    void decr() {\n-        align -= 4;\n-    }\n-\n-    void indent() {\n-        builder.append(\"                                                                                           \".substring(0, align));\n-    }\n-\n-    StringBuilder builder = new StringBuilder();\n-\n-    private void getAttributes(Declaration decl) {\n-        Set<String> attrs = decl.attributeNames();\n-        if (attrs.isEmpty()) {\n-            return;\n-        }\n-        incr();\n-        indent();\n-        for (String k: attrs) {\n-            builder.append(\"Attr: \");\n-            builder.append(k);\n-            builder.append(\" -> [\");\n-            builder.append(decl.getAttribute(k).get().stream()\n-                .map(Constable::toString)\n-                .collect(Collectors.joining(\", \")));\n-            builder.append(\"]\\n\");\n-        }\n-        decr();\n-    }\n-\n-    public String print(Declaration decl) {\n-        decl.accept(this, null);\n-        return builder.toString();\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped d, Void aVoid) {\n-        indent();\n-        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + d.layout().map(l -> \" layout = \" + l).orElse(\"\"));\n-        builder.append(\"\\n\");\n-        getAttributes(d);\n-        incr();\n-        d.members().forEach(m -> m.accept(this, null));\n-        decr();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFunction(Declaration.Function d, Void aVoid) {\n-        indent();\n-        builder.append(\"Function: \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null));\n-        builder.append(\"\\n\");\n-        getAttributes(d);\n-        incr();\n-        d.parameters().forEach(m -> m.accept(this, null));\n-        decr();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitVariable(Declaration.Variable d, Void aVoid) {\n-        indent();\n-        builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null) + \", layout = \" + d.layout());\n-        builder.append(\"\\n\");\n-        getAttributes(d);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitConstant(Declaration.Constant d, Void aVoid) {\n-        indent();\n-        builder.append(\"Constant: \" + d.name() + \" \" + d.value() + \" type = \" + d.type().accept(typeVisitor, null));\n-        builder.append(\"\\n\");\n-        getAttributes(d);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitTypedef(Declaration.Typedef d, Void aVoid) {\n-        indent();\n-        builder.append(\"Typedef: \").append(d.name()).append(\" = \")\n-               .append(d.type().accept(typeVisitor, null)).append(\"\\n\");\n-        getAttributes(d);\n-        return null;\n-    }\n-\n-    private static Type.Visitor<String, Void> typeVisitor = new Type.Visitor<>() {\n-        @Override\n-        public String visitPrimitive(Type.Primitive t, Void aVoid) {\n-            return t.kind().toString() + t.kind().layout().map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n-        }\n-\n-        @Override\n-        public String visitDelegated(Type.Delegated t, Void aVoid) {\n-            switch (t.kind()) {\n-                case TYPEDEF:\n-                    return \"typedef \" + t.name() + \" = \" + t.type().accept(this, null);\n-                case POINTER:\n-                    return \"(\" + t.type().accept(this, null) + \")*\";\n-                default:\n-                    return t.kind() + \" = \" + t.type().accept(this, null);\n-            }\n-        }\n-\n-        @Override\n-        public String visitFunction(Type.Function t, Void aVoid) {\n-            String res = t.returnType().accept(this, null);\n-            String args = t.argumentTypes().stream()\n-                    .map(a -> a.accept(this, null))\n-                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n-            return res + args;\n-        }\n-\n-        @Override\n-        public String visitDeclared(Type.Declared t, Void aVoid) {\n-            return \"Declared(\" + t.tree().layout().map(MemoryLayout::toString).orElse(\"\") + \")\";\n-        }\n-\n-        @Override\n-        public String visitArray(Type.Array t, Void aVoid) {\n-            String brackets = String.format(\"%s[%s]\", t.kind() == Type.Array.Kind.VECTOR ? \"v\" : \"\",\n-                    t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n-            return t.elementType().accept(this, null) + brackets;\n-        }\n-\n-        @Override\n-        public String visitType(Type t, Void aVoid) {\n-            return \"Unknown type: \" + t.getClass().getName();\n-        }\n-    };\n-\n-    public static String type(Type type) {\n-        return type.accept(typeVisitor, null);\n-    }\n-\n-    public static String position(Position pos) {\n-        return String.format(\"%s:%d:%d\",\n-                pos.path() == null ? \"N\/A\" : pos.path().toString(),\n-                pos.line(), pos.col());\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/PrettyPrinter.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.CursorKind;\n-import jdk.internal.clang.Type;\n-import jdk.internal.clang.TypeKind;\n-\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n-\n-\/**\n- * Base class for C struct, union MemoryLayout computer helper classes.\n- *\/\n-abstract class RecordLayoutComputer {\n-    \/\/ enclosing struct type (or this struct type for top level structs)\n-    final Type parent;\n-    \/\/ this struct type\n-    final Type type;\n-    \/\/ cursor of this struct\n-    final Cursor cursor;\n-    final List<MemoryLayout> fieldLayouts;\n-\n-    private int anonCount = 0;\n-\n-    RecordLayoutComputer(Type parent, Type type) {\n-        this.parent = parent;\n-        this.type = type;\n-        this.cursor = type.getDeclarationCursor().getDefinition();\n-        this.fieldLayouts = new ArrayList<>();\n-    }\n-\n-    static MemoryLayout compute(long offsetInParent, Type parent, Type type) {\n-        Cursor cursor = type.getDeclarationCursor().getDefinition();\n-        if (cursor.isInvalid()) {\n-            return MemoryLayout.ofPaddingBits(64);\n-        }\n-\n-        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;\n-        return isUnion? new UnionLayoutComputer(offsetInParent, parent, type).compute() :\n-                new StructLayoutComputer(offsetInParent, parent, type).compute();\n-    }\n-\n-    final MemoryLayout compute() {\n-        Stream<Cursor> fieldCursors = Utils.flattenableChildren(cursor);\n-        for (Cursor fc : fieldCursors.collect(Collectors.toList())) {\n-            \/*\n-             * Ignore bitfields of zero width.\n-             *\n-             * struct Foo {\n-             *     int i:0;\n-             * }\n-             *\n-             * And bitfields without a name.\n-             * (padding is computed automatically)\n-             *\/\n-            if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n-                startBitfield();\n-                continue;\n-            }\n-\n-            processField(fc);\n-        }\n-\n-        return finishLayout();\n-    }\n-\n-    abstract void startBitfield();\n-    abstract void processField(Cursor c);\n-    abstract MemoryLayout finishLayout();\n-\n-    void addFieldLayout(MemoryLayout MemoryLayout) {\n-        fieldLayouts.add(MemoryLayout);\n-    }\n-\n-    void addFieldLayout(long offset, Type parent, Cursor c) {\n-        MemoryLayout memoryLayout = c.isAnonymousStruct()\n-            ? compute(offset, parent, c.type())\n-                .withName(nextAnonymousName())\n-                .withAttribute(JEXTRACT_ANONYMOUS, true)\n-            : fieldLayout(c);\n-        addFieldLayout(memoryLayout);\n-    }\n-\n-    private String nextAnonymousName() {\n-        return \"$anon$\" + anonCount++;\n-    }\n-\n-    MemoryLayout fieldLayout(Cursor c) {\n-        MemoryLayout l = LayoutUtils.getLayout(c.type());\n-        String name = LayoutUtils.getName(c);\n-        if (c.isBitField()) {\n-            MemoryLayout sublayout = MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder());\n-            return sublayout.withName(name);\n-        } else {\n-            return l.withName(name);\n-        }\n-    }\n-\n-    long fieldSize(Cursor c) {\n-        if (c.type().kind() == TypeKind.IncompleteArray) {\n-            return 0;\n-        }\n-        return c.isBitField() ? c.getBitFieldWidth() : c.type().size() * 8;\n-    }\n-\n-    MemoryLayout bitfield(List<MemoryLayout> sublayouts) {\n-        return LayoutUtils.setBitfields(MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));\n-    }\n-\n-    long offsetOf(Type parent, Cursor c) {\n-        if (c.kind() == CursorKind.FieldDecl) {\n-            return parent.getOffsetOf(c.spelling());\n-        } else {\n-            return Utils.flattenableChildren(c)\n-                    .mapToLong(child -> offsetOf(parent, child))\n-                    .findFirst()\n-                    .orElseThrow(() -> new IllegalStateException(\n-                            \"Can not find offset of: \" + c + \", in: \" + parent));\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/RecordLayoutComputer.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.Type;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * MemoryLayout computer for C structs.\n- *\/\n-final class StructLayoutComputer extends RecordLayoutComputer {\n-    private long offset;\n-    private long actualSize = 0L;\n-    \/\/ List to collect bitfield fields to process later, may be null\n-    private List<MemoryLayout> bitfieldLayouts;\n-\n-    StructLayoutComputer(long offsetInParent, Type parent, Type type) {\n-        super(parent, type);\n-        this.offset = offsetInParent;\n-    }\n-\n-    @Override\n-    void addFieldLayout(MemoryLayout MemoryLayout) {\n-        if (bitfieldLayouts != null) {\n-            bitfieldLayouts.add(MemoryLayout);\n-        } else {\n-            fieldLayouts.add(MemoryLayout);\n-        }\n-    }\n-\n-    @Override\n-    void startBitfield() {\n-        \/*\n-         * In a struct, a bitfield field is seen after a non-bitfield.\n-         * Initialize bitfieldLayouts list to collect this and subsequent\n-         * bitfield layouts.\n-         *\/\n-        if (bitfieldLayouts == null) {\n-            bitfieldLayouts = new ArrayList<>();\n-        }\n-    }\n-\n-    @Override\n-    void processField(Cursor c) {\n-        boolean isBitfield = c.isBitField();\n-        long expectedOffset = offsetOf(parent, c);\n-        if (expectedOffset > offset) {\n-            addFieldLayout(MemoryLayout.ofPaddingBits(expectedOffset - offset));\n-            actualSize += (expectedOffset - offset);\n-            offset = expectedOffset;\n-        }\n-\n-        if (isBitfield) {\n-            startBitfield();\n-        } else { \/\/ !isBitfield\n-            \/*\n-             * We may be crossing from bit fields to non-bitfield field.\n-             *\n-             * struct Foo {\n-             *     int i:12;\n-             *     int j:20;\n-             *     int k; \/\/ <-- processing this\n-             *     int m;\n-             * }\n-             *\/\n-            handleBitfields();\n-        }\n-\n-        addFieldLayout(offset, parent, c);\n-        long size = fieldSize(c);\n-        offset += size;\n-        actualSize += size;\n-    }\n-\n-    @Override\n-    MemoryLayout finishLayout() {\n-        \/\/ pad at the end, if any\n-        long expectedSize = type.size() * 8;\n-        if (actualSize < expectedSize) {\n-            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize - actualSize));\n-        }\n-\n-        \/*\n-         * Handle bitfields at the end, if any.\n-         *\n-         * struct Foo {\n-         *     int i,j, k;\n-         *     int f:10;\n-         *     int pad:12;\n-         * }\n-         *\/\n-        handleBitfields();\n-\n-        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n-        GroupLayout g = MemoryLayout.ofStruct(fields);\n-        String name = LayoutUtils.getName(cursor);\n-        return name.isEmpty() ?\n-                g : g.withName(name);\n-    }\n-\n-    \/\/ process bitfields if any and clear bitfield layouts\n-    private void handleBitfields() {\n-        if (bitfieldLayouts != null) {\n-            fieldLayouts.add(bitfield(bitfieldLayouts));\n-            bitfieldLayouts = null;\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructLayoutComputer.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,345 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import java.lang.constant.Constable;\n-import java.nio.ByteOrder;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Position;\n-import jdk.incubator.jextract.Type;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.CursorKind;\n-import jdk.internal.clang.SourceLocation;\n-\n-class TreeMaker {\n-    public TreeMaker() {}\n-\n-    TypeMaker typeMaker = new TypeMaker(this);\n-\n-    public void freeze() {\n-        typeMaker.resolveTypeReferences();\n-    }\n-\n-    interface ScopedFactoryLayout {\n-        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);\n-    }\n-\n-    interface ScopedFactoryNoLayout {\n-        Declaration.Scoped make(Position pos, String name, Declaration... decls);\n-    }\n-\n-    interface VarFactoryNoLayout {\n-        Declaration.Variable make(Position pos, String name, Type type);\n-    }\n-\n-    Map<String, List<Constable>> collectAttributes(Cursor c) {\n-        return c.children().filter(Cursor::isAttribute)\n-                .collect(Collectors.groupingBy(\n-                        attr -> attr.kind().name(),\n-                        Collectors.mapping(Cursor::spelling, Collectors.toList())\n-                ));\n-    }\n-\n-    public Declaration createTree(Cursor c) {\n-        Objects.requireNonNull(c);\n-        var rv = (DeclarationImpl) createTreeInternal(c);\n-        return (rv == null) ? null : rv.withAttributes(collectAttributes(c));\n-    }\n-\n-    private Declaration createTreeInternal(Cursor c) {\n-        switch (c.kind()) {\n-            case EnumDecl:\n-                return createScoped(c, Declaration.Scoped.Kind.ENUM, Declaration::enum_, Declaration::enum_);\n-            case EnumConstantDecl:\n-                return createEnumConstant(c);\n-            case FieldDecl:\n-                return createVar(c.isBitField() ?\n-                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);\n-            case ParmDecl:\n-                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);\n-            case FunctionDecl:\n-                return createFunction(c);\n-            case StructDecl:\n-                return createScoped(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n-            case UnionDecl:\n-                return createScoped(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n-            case TypedefDecl: {\n-                return createTypedef(c);\n-            }\n-            case VarDecl:\n-                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    Position toPos(Cursor cursor) {\n-        SourceLocation loc = cursor.getSourceLocation();\n-        if (loc == null) {\n-            return Position.NO_POSITION;\n-        }\n-        SourceLocation.Location sloc = loc.getFileLocation();\n-        if (sloc == null) {\n-            return Position.NO_POSITION;\n-        }\n-        return new CursorPosition(cursor);\n-    }\n-\n-    static class CursorPosition implements Position {\n-        private final Cursor cursor;\n-        private final Path path;\n-        private final int line;\n-        private final int column;\n-\n-        CursorPosition(Cursor cursor) {\n-            this.cursor = cursor;\n-            SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();\n-            this.path = loc.path();\n-            this.line = loc.line();\n-            this.column = loc.column();\n-        }\n-\n-        @Override\n-        public Path path() {\n-            return path;\n-        }\n-\n-        @Override\n-        public int line() {\n-            return line;\n-        }\n-\n-        @Override\n-        public int col() {\n-            return column;\n-        }\n-\n-        public Cursor cursor() {\n-            return cursor;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return PrettyPrinter.position(this);\n-        }\n-    }\n-\n-    public Declaration.Function createFunction(Cursor c) {\n-        checkCursor(c, CursorKind.FunctionDecl);\n-        List<Declaration.Variable> params = new ArrayList<>();\n-        for (int i = 0 ; i < c.numberOfArgs() ; i++) {\n-            params.add((Declaration.Variable)createTree(c.getArgument(i)));\n-        }\n-        Type type = toType(c);\n-        Type funcType = type instanceof Type.Delegated? ((Type.Delegated)type).type() : type;\n-        return Declaration.function(toPos(c), c.spelling(), (Type.Function)funcType,\n-                params.toArray(new Declaration.Variable[0]));\n-    }\n-\n-    public Declaration.Constant createMacro(Cursor c, String name, Type type, Object value) {\n-        checkCursorAny(c, CursorKind.MacroDefinition);\n-        return Declaration.constant(toPos(c), name, value, type);\n-    }\n-\n-    public Declaration.Constant createEnumConstant(Cursor c) {\n-        return Declaration.constant(toPos(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));\n-    }\n-\n-    public Declaration.Scoped createHeader(Cursor c, List<Declaration> decls) {\n-        return Declaration.toplevel(toPos(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));\n-    }\n-\n-    public Declaration.Scoped createScoped(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n-        List<Declaration> decls = filterNestedDeclarations(c.children()\n-                .filter(fc -> {\n-                    if (fc.isBitField()) {\n-                        \/\/ only non-empty and named bit fields are generated\n-                        return fc.getBitFieldWidth() != 0 && !fc.spelling().isEmpty();\n-                    }\n-                    return true;\n-                })\n-                .map(this::createTree).collect(Collectors.toList()));\n-        if (c.isDefinition()) {\n-            \/\/just a declaration AND definition, we have a layout\n-            MemoryLayout layout = null;\n-            try {\n-                layout = LayoutUtils.getLayout(c.type());\n-            } catch (TypeMaker.TypeException ex) {\n-                System.err.println(ex);\n-                System.err.println(\"WARNING: generating empty struct: \" + c.spelling());\n-                return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n-            }\n-            List<Declaration> adaptedDecls = layout instanceof GroupLayout ?\n-                    collectBitfields(layout, decls) :\n-                    decls;\n-            return factoryLayout.make(toPos(c), c.spelling(), layout, adaptedDecls.toArray(new Declaration[0]));\n-        } else {\n-            \/\/just a declaration\n-            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n-                    scopeKind == Declaration.Scoped.Kind.UNION ||\n-                    scopeKind == Declaration.Scoped.Kind.ENUM ||\n-                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n-                \/\/if there's a real definition somewhere else, skip this redundant declaration\n-                if (!c.getDefinition().isInvalid()) {\n-                    return null;\n-                }\n-            }\n-            return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n-        }\n-    }\n-\n-    private static boolean isEnum(Declaration d) {\n-        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.ENUM;\n-    }\n-\n-    private static boolean isAnonymousStruct(Declaration declaration) {\n-        return ((CursorPosition)declaration.pos()).cursor.isAnonymousStruct();\n-    }\n-\n-    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {\n-        return declarations.stream()\n-                .filter(Objects::nonNull)\n-                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d))\n-                .collect(Collectors.toList());\n-    }\n-\n-    private Declaration.Typedef createTypedef(Cursor c) {\n-        Type cursorType = toType(c);\n-        Type canonicalType = cursorType instanceof Type.Function\n-            ? cursorType\n-            : ((Type.Delegated) cursorType).type(); \/\/ normal typedef\n-        if (canonicalType instanceof Type.Declared) {\n-            Declaration.Scoped s = ((Type.Declared) canonicalType).tree();\n-            if (s.name().equals(c.spelling())) {\n-                \/\/ typedef record with the same name, no need to present twice\n-                return null;\n-            }\n-        }\n-        return Declaration.typedef(toPos(c), c.spelling(), canonicalType);\n-    }\n-\n-    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {\n-        checkCursorAny(c, CursorKind.VarDecl, CursorKind.FieldDecl, CursorKind.ParmDecl);\n-        if (c.isBitField()) {\n-            return Declaration.bitfield(toPos(c), c.spelling(), toType(c),\n-                    MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder()));\n-        } else {\n-            Type type = null;\n-            try {\n-                type = toType(c);\n-            } catch (TypeMaker.TypeException ex) {\n-                System.err.println(ex);\n-                System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n-                return null;\n-            }\n-            return varFactory.make(toPos(c), c.spelling(), type);\n-        }\n-    }\n-\n-    private static void collectNestedBitFields(Set<Declaration> out, Declaration.Scoped anonymousStruct) {\n-        for  (Declaration field : anonymousStruct.members()) {\n-            if (isAnonymousStruct(field)) {\n-                collectNestedBitFields(out, (Declaration.Scoped) field);\n-            } else if (field instanceof Declaration.Scoped\n-                       && ((Declaration.Scoped) field).kind() == Declaration.Scoped.Kind.BITFIELDS) {\n-                out.addAll(((Declaration.Scoped) field).members());\n-            }\n-        }\n-    }\n-\n-    private static Set<Declaration> nestedBitFields(List<Declaration> members) {\n-        Set<Declaration> res = new HashSet<>();\n-        for (Declaration member : members) {\n-            if (isAnonymousStruct(member)) {\n-                collectNestedBitFields(res, (Declaration.Scoped) member);\n-            }\n-        }\n-        return res;\n-    }\n-\n-    private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {\n-        Set<String> nestedBitfieldNames = nestedBitFields(declarations).stream()\n-                                                                       .map(Declaration::name)\n-                                                                       .collect(Collectors.toSet());\n-        List<Declaration> newDecls = new ArrayList<>();\n-        for (MemoryLayout e : ((GroupLayout)layout).memberLayouts()) {\n-            if (e instanceof GroupLayout contents && LayoutUtils.isBitfields(contents)) {\n-                List<Declaration.Variable> bfDecls = new ArrayList<>();\n-                outer: for (MemoryLayout bitfield : contents.memberLayouts()) {\n-                    if (bitfield.name().isPresent() && !nestedBitfieldNames.contains(bitfield.name().get())) {\n-                        Iterator<Declaration> declIt = declarations.iterator();\n-                        while (declIt.hasNext()) {\n-                            Declaration d = declIt.next();\n-                            if (d.name().equals(bitfield.name().get())) {\n-                                bfDecls.add((Declaration.Variable)d);\n-                                declIt.remove();\n-                                continue outer;\n-                            }\n-                        }\n-                        throw new IllegalStateException(\"No matching declaration found for bitfield: \" + bitfield);\n-                    }\n-                }\n-                if (!bfDecls.isEmpty()) {\n-                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), \"\", contents, bfDecls.toArray(new Declaration.Variable[0])));\n-                }\n-            }\n-        }\n-        newDecls.addAll(declarations);\n-        return newDecls;\n-    }\n-\n-    private Type toType(Cursor c) {\n-        return typeMaker.makeType(c.type());\n-    }\n-\n-    private void checkCursor(Cursor c, CursorKind k) {\n-        if (c.kind() != k) {\n-            throw new IllegalArgumentException(\"Invalid cursor kind\");\n-        }\n-    }\n-\n-    private void checkCursorAny(Cursor c, CursorKind... kinds) {\n-        CursorKind expected = Objects.requireNonNull(c.kind());\n-        for (CursorKind k : kinds) {\n-            if (k == expected) {\n-                return;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"Invalid cursor kind\");\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TreeMaker.java","additions":0,"deletions":345,"binary":false,"changes":345,"status":"deleted"},{"patch":"@@ -1,343 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.OptionalLong;\n-import java.util.function.Supplier;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Type;\n-\n-public abstract class TypeImpl implements Type {\n-\n-    @Override\n-    public boolean isErroneous() {\n-        return false;\n-    }\n-\n-    static boolean equals(Type t1, Type.Delegated t2) {\n-        assert t1 != null;\n-        assert t2 != null;\n-\n-        return (t2.kind() == Delegated.Kind.TYPEDEF) && t1.equals(t2.type());\n-    }\n-\n-    public static final TypeImpl ERROR = new TypeImpl() {\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitType(this, data);\n-        }\n-\n-        @Override\n-        public boolean isErroneous() {\n-            return true;\n-        }\n-    };\n-\n-    public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {\n-\n-        private final Primitive.Kind kind;\n-\n-        public PrimitiveImpl(Kind kind) {\n-            this.kind = Objects.requireNonNull(kind);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitPrimitive(this, data);\n-        }\n-\n-        @Override\n-        public Kind kind() {\n-            return kind;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Type.Primitive)) {\n-                return (o instanceof Delegated) && equals(this, (Delegated)o);\n-            }\n-            Type.Primitive primitive = (Type.Primitive) o;\n-            return kind == primitive.kind();\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(kind);\n-        }\n-    }\n-\n-    static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {\n-        Delegated.Kind kind;\n-        Optional<String> name;\n-\n-        DelegatedBase(Kind kind, Optional<String> name) {\n-            this.kind = Objects.requireNonNull(kind);\n-            this.name = Objects.requireNonNull(name);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitDelegated(this, data);\n-        }\n-\n-        @Override\n-        public final Delegated.Kind kind() {\n-            return kind;\n-        }\n-\n-        @Override\n-        public final Optional<String> name() {\n-            return name;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Type.Delegated)) {\n-                return (o instanceof Type) && equals((Type)o, this);\n-            }\n-            Type.Delegated that = (Type.Delegated) o;\n-            return kind == that.kind() &&\n-                    name.equals(that.name());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(kind, name);\n-        }\n-    }\n-\n-    public static final class QualifiedImpl extends DelegatedBase {\n-        private final Type type;\n-\n-        public QualifiedImpl(Kind kind, Type type) {\n-            this(kind, Optional.empty(), type);\n-        }\n-\n-        public QualifiedImpl(Kind kind, String name, Type type) {\n-            this(kind, Optional.of(name), type);\n-        }\n-\n-        private QualifiedImpl(Kind kind, Optional<String> name, Type type) {\n-            super(kind, name);\n-            this.type = type;\n-        }\n-\n-        @Override\n-        public Type type() {\n-            return type;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Type.Delegated)) return false;\n-            if (!super.equals(o)) {\n-                return (o instanceof Delegated) && equals(this, (Delegated) o);\n-            }\n-            Type.Delegated qualified = (Type.Delegated) o;\n-            return Objects.equals(type, qualified.type());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);\n-        }\n-    }\n-\n-    public static final class PointerImpl extends DelegatedBase {\n-        private final Supplier<Type> pointeeFactory;\n-\n-        public PointerImpl(Supplier<Type> pointeeFactory) {\n-            super(Kind.POINTER, Optional.empty());\n-            this.pointeeFactory = Objects.requireNonNull(pointeeFactory);\n-        }\n-\n-        public PointerImpl(Type pointee) {\n-            this(() -> pointee);\n-        }\n-\n-        @Override\n-        public Type type() {\n-            return pointeeFactory.get();\n-        }\n-    }\n-\n-    public static final class DeclaredImpl extends TypeImpl implements Type.Declared {\n-\n-        private final Declaration.Scoped declaration;\n-\n-        public DeclaredImpl(Declaration.Scoped declaration) {\n-            super();\n-            this.declaration = Objects.requireNonNull(declaration);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitDeclared(this, data);\n-        }\n-\n-        @Override\n-        public Declaration.Scoped tree() {\n-            return declaration;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Type.Declared)) {\n-                return (o instanceof Delegated) && equals(this, (Delegated) o);\n-            }\n-            Type.Declared declared = (Type.Declared) o;\n-            return declaration.equals(declared.tree());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(declaration);\n-        }\n-    }\n-\n-    public static final class FunctionImpl extends TypeImpl implements Type.Function {\n-\n-        private final boolean varargs;\n-        private final List<Type> argtypes;\n-        private final Type restype;\n-\n-        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype) {\n-            super();\n-            this.varargs = varargs;\n-            this.argtypes = Objects.requireNonNull(argtypes);\n-            this.restype = Objects.requireNonNull(restype);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitFunction(this, data);\n-        }\n-\n-        @Override\n-        public boolean varargs() {\n-            return varargs;\n-        }\n-\n-        @Override\n-        public List<Type> argumentTypes() {\n-            return argtypes;\n-        }\n-\n-        @Override\n-        public Type returnType() {\n-            return restype;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Type.Function)) {\n-                return (o instanceof Delegated) && equals(this, (Delegated) o);\n-            }\n-            Type.Function function = (Type.Function) o;\n-            return varargs == function.varargs() &&\n-                    argtypes.equals(function.argumentTypes()) &&\n-                    restype.equals(function.returnType());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(varargs, argtypes, restype);\n-        }\n-    }\n-\n-    public static final class ArrayImpl extends TypeImpl implements Type.Array {\n-\n-        private final Kind kind;\n-        private final OptionalLong elemCount;\n-        private final Type elemType;\n-\n-        public ArrayImpl(Kind kind, long count, Type elemType) {\n-            this(kind, elemType, OptionalLong.of(count));\n-        }\n-\n-        public ArrayImpl(Kind kind, Type elemType) {\n-            this(kind, elemType, OptionalLong.empty());\n-        }\n-\n-        private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {\n-            super();\n-            this.kind = Objects.requireNonNull(kind);\n-            this.elemCount = Objects.requireNonNull(elemCount);\n-            this.elemType = Objects.requireNonNull(elemType);\n-        }\n-\n-        @Override\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitArray(this, data);\n-        }\n-\n-        @Override\n-        public OptionalLong elementCount() {\n-            return elemCount;\n-        }\n-\n-        @Override\n-        public Type elementType() {\n-            return elemType;\n-        }\n-\n-        @Override\n-        public Kind kind() {\n-            return kind;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (!(o instanceof Type.Array)) {\n-                return (o instanceof Delegated) && equals(this, (Delegated) o);\n-            }\n-            Type.Array array = (Type.Array) o;\n-            return kind == array.kind() &&\n-                    elemType.equals(array.elementType());\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(kind, elemType);\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return PrettyPrinter.type(this);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeImpl.java","additions":0,"deletions":343,"binary":false,"changes":343,"status":"deleted"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-\n-import java.util.ArrayList;\n-import java.util.ConcurrentModificationException;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.function.Supplier;\n-import jdk.incubator.jextract.Declaration;\n-import jdk.incubator.jextract.Type;\n-import jdk.incubator.jextract.Type.Delegated;\n-import jdk.incubator.jextract.Type.Primitive;\n-\n-class TypeMaker {\n-\n-    TreeMaker treeMaker;\n-    private final Map<jdk.internal.clang.Type, Type> typeCache = new HashMap<>();\n-    private List<ClangTypeReference> unresolved = new ArrayList<>();\n-\n-    private class ClangTypeReference implements Supplier<Type> {\n-        jdk.internal.clang.Type origin;\n-        Type derived;\n-\n-        private ClangTypeReference(jdk.internal.clang.Type origin) {\n-            this.origin = origin;\n-            derived = typeCache.get(origin);\n-        }\n-\n-        public boolean isUnresolved() {\n-            return null == derived;\n-        }\n-\n-        public void resolve() {\n-            derived = makeType(origin);\n-            Objects.requireNonNull(derived, \"Clang type cannot be resolved: \" + origin.spelling());\n-        }\n-\n-        public Type get() {\n-            Objects.requireNonNull(derived, \"Type is not yet resolved.\");\n-            return derived;\n-        }\n-    }\n-\n-    private ClangTypeReference reference(jdk.internal.clang.Type type) {\n-        ClangTypeReference ref = new ClangTypeReference(type);\n-        if (ref.isUnresolved()) {\n-            unresolved.add(ref);\n-        }\n-        return ref;\n-    }\n-\n-    public TypeMaker(TreeMaker treeMaker) {\n-        this.treeMaker = treeMaker;\n-    }\n-\n-    \/**\n-     * Resolve all type references. This method should be called before discard clang cursors\/types\n-     *\/\n-    void resolveTypeReferences() {\n-        List<ClangTypeReference> resolving = unresolved;\n-        unresolved = new ArrayList<>();\n-        while (! resolving.isEmpty()) {\n-            resolving.forEach(ClangTypeReference::resolve);\n-            resolving = unresolved;\n-            unresolved = new ArrayList<>();\n-        }\n-    }\n-\n-    Type makeType(jdk.internal.clang.Type t) {\n-        Type rv = typeCache.get(t);\n-        if (rv != null) {\n-            return rv;\n-        }\n-        rv = makeTypeInternal(t);\n-        if (null != rv && typeCache.put(t, rv) != null) {\n-            throw new ConcurrentModificationException();\n-        }\n-        return rv;\n-    }\n-\n-    static class TypeException extends RuntimeException {\n-        static final long serialVersionUID = 1L;\n-\n-        TypeException(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    Type makeTypeInternal(jdk.internal.clang.Type t) {\n-        switch(t.kind()) {\n-            case Auto:\n-                return makeType(t.canonicalType());\n-            case Void:\n-                return Type.void_();\n-            case Char_S:\n-            case Char_U:\n-                return Type.primitive(Primitive.Kind.Char);\n-            case Short:\n-                return Type.primitive(Primitive.Kind.Short);\n-            case Int:\n-                return Type.primitive(Primitive.Kind.Int);\n-            case Long:\n-                return Type.primitive(Primitive.Kind.Long);\n-            case LongLong:\n-                return Type.primitive(Primitive.Kind.LongLong);\n-            case SChar: {\n-                Type chType = Type.primitive(Primitive.Kind.Char);\n-                return Type.qualified(Delegated.Kind.SIGNED, chType);\n-            }\n-            case UShort: {\n-                Type chType = Type.primitive(Primitive.Kind.Short);\n-                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n-            }\n-            case UInt: {\n-                Type chType = Type.primitive(Primitive.Kind.Int);\n-                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n-            }\n-            case ULong: {\n-                Type chType = Type.primitive(Primitive.Kind.Long);\n-                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n-            }\n-            case ULongLong: {\n-                Type chType = Type.primitive(Primitive.Kind.LongLong);\n-                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n-            }\n-            case UChar: {\n-                Type chType = Type.primitive(Primitive.Kind.Char);\n-                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n-            }\n-\n-            case Bool:\n-                return Type.primitive(Primitive.Kind.Bool);\n-            case Double:\n-                return Type.primitive(Primitive.Kind.Double);\n-            case Float:\n-                return Type.primitive(Primitive.Kind.Float);\n-            case Unexposed:\n-            case Elaborated:\n-                jdk.internal.clang.Type canonical = t.canonicalType();\n-                if (canonical.equalType(t)) {\n-                    throw new TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n-                }\n-                return makeType(canonical);\n-            case ConstantArray: {\n-                Type elem = makeType(t.getElementType());\n-                return Type.array(t.getNumberOfElements(), elem);\n-            }\n-            case IncompleteArray: {\n-                Type elem = makeType(t.getElementType());\n-                return Type.array(elem);\n-            }\n-            case FunctionProto:\n-            case FunctionNoProto: {\n-                List<Type> args = new ArrayList<>();\n-                for (int i = 0; i < t.numberOfArgs(); i++) {\n-                    \/\/ argument could be function pointer declared locally\n-                    args.add(lowerFunctionType(t.argType(i)));\n-                }\n-                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n-            }\n-            case Enum:\n-            case Record: {\n-                if (treeMaker == null) {\n-                    \/\/ Macro evaluation, type is meaningless as this can only be pointer and we only care value\n-                    return Type.void_();\n-                }\n-                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));\n-            }\n-            case BlockPointer:\n-            case Pointer: {\n-                \/\/ TODO: We can always erase type for macro evaluation, should we?\n-                return new TypeImpl.PointerImpl(reference(t.getPointeeType()));\n-            }\n-            case Typedef: {\n-                Type __type = makeType(t.canonicalType());\n-                return Type.typedef(t.spelling(), __type);\n-            }\n-            case Complex: {\n-                Type __type = makeType(t.getElementType());\n-                return Type.qualified(Delegated.Kind.COMPLEX, __type);\n-            }\n-            case Vector: {\n-                Type __type = makeType(t.getElementType());\n-                return Type.vector(t.getNumberOfElements(), __type);\n-            }\n-            case WChar: \/\/unsupported\n-                return Type.primitive(Primitive.Kind.WChar);\n-            case Char16: \/\/unsupported\n-                return Type.primitive(Primitive.Kind.Char16);\n-            case Half: \/\/unsupported\n-                return Type.primitive(Primitive.Kind.HalfFloat);\n-            case Int128: \/\/unsupported\n-                return Type.primitive(Primitive.Kind.Int128);\n-            case LongDouble: \/\/unsupported\n-                return Type.primitive(Primitive.Kind.LongDouble);\n-            case UInt128: { \/\/unsupported\n-                Type iType = Type.primitive(Primitive.Kind.Int128);\n-                return Type.qualified(Delegated.Kind.UNSIGNED, iType);\n-            }\n-            default:\n-                return TypeImpl.ERROR;\n-        }\n-    }\n-\n-    private Type lowerFunctionType(jdk.internal.clang.Type t) {\n-        Type t2 = makeType(t);\n-        return t2.accept(lowerFunctionType, null);\n-    }\n-\n-    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n-        @Override\n-        public Type visitArray(Type.Array t, Void aVoid) {\n-            return Type.pointer(t.elementType());\n-        }\n-\n-        @Override\n-        public Type visitDelegated(Type.Delegated t, Void aVoid) {\n-            if (t.kind() == Delegated.Kind.TYPEDEF && t.type() instanceof Type.Array) {\n-                return visitArray((Type.Array)t.type(), aVoid);\n-            }\n-            return visitType(t, aVoid);\n-        }\n-\n-        @Override\n-        public Type visitType(Type t, Void aVoid) {\n-            return t;\n-        }\n-    };\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeMaker.java","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.jextract.Declaration;\n-import jdk.internal.clang.Cursor;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-\/**\n- * This visitor handles certain typedef declarations.\n- *\n- * 1. Remove redundant typedefs.\n- * 2. Rename typedef'ed anonymous type definitions like\n- *        typedef struct { int x; int y; } Point;\n- *\/\n-final class TypedefHandler implements Declaration.Visitor<Void, Void> {\n-\n-    TreeMaker maker;\n-\n-    public TypedefHandler(TreeMaker maker) {\n-        this.maker = maker;\n-    }\n-\n-    \/\/ Potential Tree instances that will go into transformed HeaderTree\n-    \/\/ are collected in this list.\n-    private List<Declaration> decls = new ArrayList<>();\n-\n-    \/\/ Tree instances that are to be replaced from \"decls\" list are\n-    \/\/ saved in the following Map. One or more Trees can replace a Tree.\n-    private final Map<Cursor, List<Declaration>> replacements = new HashMap<>();\n-\n-    public Declaration.Scoped transform(Declaration.Scoped ht) {\n-        \/\/ Process all header declarations are collect potential\n-        \/\/ declarations that will go into transformed HeaderTree\n-        \/\/ into the this.decls field.\n-        ht.accept(this, null);\n-\n-\/\/        \/\/ Replace trees from this.decls with Trees found in this.replacements.\n-\/\/        \/\/ We need this two step process so that named StructTree instances\n-\/\/        \/\/ will replace with original unnamed StructTree instances.\n-\/\/        List<Declaration> newDecls = decls.stream().flatMap(tx -> {\n-\/\/            if (replacements.containsKey(tx.cursor())) {\n-\/\/                return replacements.get(tx.cursor()).stream();\n-\/\/            } else {\n-\/\/                return Stream.of(tx);\n-\/\/            }\n-\/\/        }).collect(Collectors.toList());\n-\/\/\n-\/\/        return treeMaker.createHeader(ht.cursor(), ht.path(), newDecls);\n-        return ht;\n-    }\n-\n-    @Override\n-    public Void visitDeclaration(Declaration d, Void aVoid) {\n-        decls.add(d);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitScoped(Declaration.Scoped ht, Void v) {\n-        ht.members().forEach(decl -> decl.accept(this, null));\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefHandler.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.ValueLayout;\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.Type;\n-import jdk.internal.clang.TypeKind;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * MemoryLayout computer for C unions.\n- *\/\n-final class UnionLayoutComputer extends RecordLayoutComputer {\n-    private final long offset;\n-    private long actualSize = 0L;\n-\n-    UnionLayoutComputer(long offsetInParent, Type parent, Type type) {\n-        super(parent, type);\n-        this.offset = offsetInParent;\n-    }\n-\n-    @Override\n-    void processField(Cursor c) {\n-        long expectedOffset = offsetOf(parent, c);\n-        if (expectedOffset > offset) {\n-            throw new IllegalStateException(\"No padding in union elements!\");\n-        }\n-\n-        addFieldLayout(offset, parent, c);\n-        actualSize = Math.max(actualSize, fieldSize(c));\n-    }\n-\n-    @Override\n-    void startBitfield() {\n-        \/\/ do nothing\n-    }\n-\n-    @Override\n-    MemoryLayout fieldLayout(Cursor c) {\n-        if (c.isBitField()) {\n-            return bitfield(List.of(super.fieldLayout(c)));\n-        } else {\n-            return super.fieldLayout(c);\n-        }\n-    }\n-\n-    @Override\n-    long fieldSize(Cursor c) {\n-        if (c.type().kind() == TypeKind.IncompleteArray) {\n-            return 0;\n-        } else if (c.isBitField()) {\n-            return c.getBitFieldWidth();\n-        } else {\n-            return c.type().size() * 8;\n-        }\n-    }\n-\n-    @Override\n-    MemoryLayout finishLayout() {\n-        \/\/ size mismatch indicates use of bitfields in union\n-        long expectedSize = type.size() * 8;\n-        if (actualSize < expectedSize) {\n-            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n-            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize));\n-        } else if (actualSize > expectedSize) {\n-            throw new AssertionError(\"Invalid union size - expected: \" + expectedSize + \"; found: \" + actualSize);\n-        }\n-\n-        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n-        GroupLayout g = MemoryLayout.ofUnion(fields);\n-        String name = LayoutUtils.getName(cursor);\n-        return name.isEmpty() ?\n-                g : g.withName(name);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnionLayoutComputer.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.jextract.impl;\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.ValueLayout;\n-import java.nio.ByteOrder;\n-\n-\/*\n- * Layouts for the primitive types not supported by ABI implementations.\n- *\/\n-public final class UnsupportedLayouts {\n-    private UnsupportedLayouts() {}\n-\n-    private static final String ATTR_LAYOUT_KIND = \"jextract.abi.unsupported.layout.kind\";\n-\n-    public static final ValueLayout __INT128 = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"__int128\");\n-\n-    public static final ValueLayout LONG_DOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"long double\");\n-\n-    public static final ValueLayout _FLOAT128 = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"_float128\");\n-\n-    public static final ValueLayout __FP16 = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"__fp16\");\n-\n-    public static final ValueLayout CHAR16 = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"char16\");\n-\n-    public static final ValueLayout WCHAR_T = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n-            withAttribute(ATTR_LAYOUT_KIND, \"wchar_t\");\n-\n-    static boolean isUnsupported(MemoryLayout vl) {\n-        return vl.attribute(ATTR_LAYOUT_KIND).isPresent();\n-    }\n-\n-    static String getUnsupportedTypeName(MemoryLayout vl) {\n-        return (String)\n-                vl.attribute(ATTR_LAYOUT_KIND).orElseThrow(IllegalArgumentException::new);\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnsupportedLayouts.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,319 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import jdk.internal.clang.Cursor;\n-import jdk.internal.clang.CursorKind;\n-import jdk.internal.clang.SourceLocation;\n-import jdk.internal.clang.Type;\n-\n-import javax.lang.model.SourceVersion;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-\/**\n- * General utility functions\n- *\/\n-class Utils {\n-    public static String qualifiedClassName(String packageName, String simpleName) {\n-        return (packageName.isEmpty() ? \"\" : packageName + \".\") + simpleName;\n-    }\n-\n-    private static URI fileName(String pkgName, String clsName, String extension) {\n-        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n-        return URI.create(pkgPrefix + clsName + extension);\n-    }\n-\n-    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {\n-        return new SimpleJavaFileObject(fileName(pkgName, clsName, \".java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return contents;\n-            }\n-        };\n-    }\n-\n-    static String javaSafeIdentifier(String name) {\n-        return javaSafeIdentifier(name, false);\n-    }\n-\n-    static String javaSafeIdentifier(String name, boolean checkAllChars) {\n-        if (checkAllChars) {\n-            StringBuilder buf = new StringBuilder();\n-            char[] chars = name.toCharArray();\n-            if (Character.isJavaIdentifierStart(chars[0])) {\n-                buf.append(chars[0]);\n-            } else {\n-                buf.append('_');\n-            }\n-            if (chars.length > 1) {\n-                for (int i = 1; i < chars.length; i++) {\n-                    char ch = chars[i];\n-                    if (Character.isJavaIdentifierPart(ch)) {\n-                        buf.append(ch);\n-                    } else {\n-                        buf.append('_');\n-                    }\n-                }\n-            }\n-            return buf.toString();\n-        } else {\n-            \/\/ We never get the problem of Java non-identifiers (like 123, ab-xy) as\n-            \/\/ C identifiers. But we may have a java keyword used as a C identifier.\n-            assert SourceVersion.isIdentifier(name);\n-\n-            return SourceVersion.isKeyword(name) || isRestrictedTypeName(name) ? (name + \"_\") : name;\n-        }\n-    }\n-\n-    private static boolean isRestrictedTypeName(String name) {\n-        return switch (name) {\n-            case \"var\", \"yield\", \"record\",\n-                \"sealed\", \"permits\" -> true;\n-            default -> false;\n-        };\n-    }\n-\n-    static void validSimpleIdentifier(String name) {\n-        int length = name.length();\n-        if (length == 0) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        int ch = name.codePointAt(0);\n-        if (length == 1 && ch == '_') {\n-            throw new IllegalArgumentException(\"'_' is no longer valid identifier.\");\n-        }\n-\n-        if (!Character.isJavaIdentifierStart(ch)) {\n-            throw new IllegalArgumentException(\"Invalid start character for an identifier: \" + ch);\n-        }\n-\n-        for (int i = 1; i < length; i++) {\n-            ch = name.codePointAt(i);\n-            if (!Character.isJavaIdentifierPart(ch)) {\n-                throw new IllegalArgumentException(\"Invalid character for an identifier: \" + ch);\n-            }\n-        }\n-    }\n-\n-    static void validPackageName(String name) {\n-        if (name.isEmpty()) {\n-            throw new IllegalArgumentException();\n-        }\n-        int idx = name.lastIndexOf('.');\n-        if (idx == -1) {\n-           validSimpleIdentifier(name);\n-        } else {\n-            validSimpleIdentifier(name.substring(idx + 1));\n-            validPackageName(name.substring(0, idx));\n-        }\n-    }\n-\n-    static String toJavaIdentifier(String str) {\n-        final int size = str.length();\n-        StringBuilder sb = new StringBuilder(size);\n-        if (! Character.isJavaIdentifierStart(str.charAt(0))) {\n-            sb.append('_');\n-        }\n-        for (int i = 0; i < size; i++) {\n-            char ch = str.charAt(i);\n-            if (Character.isJavaIdentifierPart(ch)) {\n-                sb.append(ch);\n-            } else {\n-                sb.append('_');\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    static String toSafeName(String name) {\n-        StringBuilder sb = new StringBuilder(name.length());\n-        name = toJavaIdentifier(name);\n-        sb.append(name);\n-        if (SourceVersion.isKeyword(name)) {\n-            sb.append(\"$\");\n-        }\n-        return sb.toString();\n-    }\n-\n-    static String toClassName(String cname) {\n-        return toSafeName(cname);\n-    }\n-\n-    static String toMacroName(String mname) {\n-        return toSafeName(mname);\n-    }\n-\n-    static String toInternalName(String pkg, String name, String... nested) {\n-        if ((pkg == null || pkg.isEmpty()) && nested == null) {\n-            return name;\n-        }\n-\n-        StringBuilder sb = new StringBuilder();\n-        if (pkg != null && ! pkg.isEmpty()) {\n-            sb.append(pkg.replace('.', '\/'));\n-            if (sb.charAt(sb.length() - 1) != '\/') {\n-                sb.append('\/');\n-            }\n-        }\n-        sb.append(name);\n-        for (String n: nested) {\n-            sb.append('$');\n-            sb.append(n);\n-        }\n-        return sb.toString();\n-    }\n-\n-    static String getName(Type type) {\n-        return LayoutUtils.getName(type);\n-    }\n-\n-    static Stream<Cursor> flattenableChildren(Cursor c) {\n-        return c.children()\n-                .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);\n-    }\n-\n-    \/\/ return builtin Record types accessible from the given Type\n-    static Stream<Cursor> getBuiltinRecordTypes(Type type) {\n-        List<Cursor> recordTypes = new ArrayList<>();\n-        fillBuiltinRecordTypes(type, recordTypes);\n-        return recordTypes.stream().distinct();\n-    }\n-\n-    private static void fillBuiltinRecordTypes(Type type, List<Cursor> recordTypes) {\n-        Type canonicalType = type.canonicalType();\n-        switch (canonicalType.kind()) {\n-            case ConstantArray:\n-            case IncompleteArray:\n-                fillBuiltinRecordTypes(canonicalType.getElementType(), recordTypes);\n-                break;\n-\n-            case FunctionProto:\n-            case FunctionNoProto: {\n-                final int numArgs = canonicalType.numberOfArgs();\n-                for (int i = 0; i < numArgs; i++) {\n-                    fillBuiltinRecordTypes(canonicalType.argType(i), recordTypes);\n-                }\n-                fillBuiltinRecordTypes(canonicalType.resultType(), recordTypes);\n-            }\n-            break;\n-\n-            case Record: {\n-                Cursor c = canonicalType.getDeclarationCursor();\n-                if (c.isDefinition()) {\n-                    SourceLocation sloc = c.getSourceLocation();\n-                    if (sloc != null && sloc.getFileLocation().path() == null) {\n-                        recordTypes.add(c);\n-                    }\n-                }\n-            }\n-            break;\n-\n-            case BlockPointer:\n-            case Pointer:\n-                fillBuiltinRecordTypes(canonicalType.getPointeeType(), recordTypes);\n-                break;\n-\n-            case Unexposed:\n-                if (! canonicalType.equalType(type)) {\n-                    fillBuiltinRecordTypes(canonicalType, recordTypes);\n-                }\n-                break;\n-\n-            case Elaborated:\n-            case Typedef:\n-                fillBuiltinRecordTypes(canonicalType, recordTypes);\n-                break;\n-\n-            default: \/\/ nothing to do\n-        }\n-    }\n-\n-    \/\/ return the absolute path of the library of given name by searching\n-    \/\/ in the given array of paths.\n-    static Optional<Path> findLibraryPath(Path[] paths, String libName) {\n-        return Arrays.stream(paths).\n-                map(p -> p.resolve(System.mapLibraryName(libName))).\n-                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();\n-    }\n-\n-    \/*\n-     * FIXME: when we add jdk.compiler dependency from jdk.jextract module, revisit\n-     * the following. The following methods 'quote', 'quote' and 'isPrintableAscii'\n-     * are from javac source. See also com.sun.tools.javac.util.Convert.java.\n-     *\/\n-\n-    \/**\n-     * Escapes each character in a string that has an escape sequence or\n-     * is non-printable ASCII.  Leaves non-ASCII characters alone.\n-     *\/\n-    static String quote(String s) {\n-        StringBuilder buf = new StringBuilder();\n-        for (int i = 0; i < s.length(); i++) {\n-            buf.append(quote(s.charAt(i)));\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Escapes a character if it has an escape sequence or is\n-     * non-printable ASCII.  Leaves non-ASCII characters alone.\n-     *\/\n-    static String quote(char ch) {\n-        switch (ch) {\n-        case '\\b':  return \"\\\\b\";\n-        case '\\f':  return \"\\\\f\";\n-        case '\\n':  return \"\\\\n\";\n-        case '\\r':  return \"\\\\r\";\n-        case '\\t':  return \"\\\\t\";\n-        case '\\'':  return \"\\\\'\";\n-        case '\\\"':  return \"\\\\\\\"\";\n-        case '\\\\':  return \"\\\\\\\\\";\n-        default:\n-            return (isPrintableAscii(ch))\n-                ? String.valueOf(ch)\n-                : String.format(\"\\\\u%04x\", (int) ch);\n-        }\n-    }\n-\n-    \/**\n-     * Is a character printable ASCII?\n-     *\/\n-    private static boolean isPrintableAscii(char ch) {\n-        return ch >= ' ' && ch <= '~';\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Utils.java","additions":0,"deletions":319,"binary":false,"changes":319,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import javax.tools.JavaFileObject;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.FileAlreadyExistsException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public final class Writer {\n-    private final List<? extends JavaFileObject> files;\n-    private final Path dest;\n-\n-    public Writer(Path dest, List<? extends JavaFileObject> files) {\n-        this.files = files;\n-        this.dest = dest;\n-    }\n-\n-    private List<JavaFileObject> ensureSourcesCompiled() {\n-        List<JavaFileObject> sources = sources();\n-        if (sources.isEmpty()) {\n-            return List.of();\n-        } else {\n-            return InMemoryJavaCompiler.compile(sources,\n-                \"--add-modules\", \"jdk.incubator.foreign\",\n-                \"--release\", \"16\",\n-                \"-d\", dest.toAbsolutePath().toString(),\n-                \"-cp\", dest.toAbsolutePath().toString());\n-        }\n-    }\n-\n-    public void writeAll(boolean compileSources) throws IOException {\n-        writeClassFiles(resources());\n-        writeClassFiles(classes());\n-        if (compileSources) {\n-            writeClassFiles(ensureSourcesCompiled());\n-        } else {\n-            writeSourceFiles();\n-        }\n-    }\n-\n-    void writeClassFiles(List<JavaFileObject> files) throws IOException {\n-        Path destDir = createOutputDir();\n-        for (var entry : files) {\n-            String path = entry.getName();\n-            Path fullPath = destDir.resolve(path).normalize();\n-            Files.createDirectories(fullPath.getParent());\n-            try (InputStream is = entry.openInputStream()) {\n-                Files.write(fullPath, is.readAllBytes());\n-            }\n-        }\n-    }\n-\n-    void writeSourceFiles() throws IOException {\n-        Path destDir = createOutputDir();\n-        for (var entry : sources()) {\n-            String srcPath = entry.getName();\n-            Path fullPath = destDir.resolve(srcPath).normalize();\n-            Path dir = fullPath.getParent();\n-            \/\/ In case the folder exist and is a link to a folder, this should be OK\n-            \/\/ Case in point, \/tmp on MacOS link to \/private\/tmp\n-            if (Files.exists(dir)) {\n-                if (!Files.isDirectory(dir)) {\n-                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());\n-                }\n-            } else {\n-                Files.createDirectories(fullPath.getParent());\n-            }\n-            Files.write(fullPath, List.of(entry.getCharContent(false)));\n-        }\n-    }\n-\n-    private List<JavaFileObject> sources() {\n-        return files.stream()\n-                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.SOURCE)\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<JavaFileObject> classes() {\n-        return files.stream()\n-                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.CLASS)\n-                .collect(Collectors.toList());\n-    }\n-\n-    private List<JavaFileObject> resources() {\n-        return files.stream()\n-                .filter(jfo -> (jfo.getKind() == JavaFileObject.Kind.HTML || jfo.getKind() == JavaFileObject.Kind.OTHER))\n-                .collect(Collectors.toList());\n-    }\n-\n-    private Path createOutputDir() throws IOException {\n-        Path absDest = dest.toAbsolutePath();\n-        if (!Files.exists(absDest)) {\n-            Files.createDirectories(absDest);\n-        }\n-        if (!Files.isDirectory(absDest)) {\n-            throw new IOException(\"Not a directory: \" + dest);\n-        }\n-        return absDest;\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Writer.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.layout;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.incubator.jextract.Type.Primitive;\n+import jdk.internal.jextract.clang.Cursor;\n+import jdk.internal.jextract.clang.Type;\n+import jdk.internal.jextract.parser.TypeMaker;\n+\n+import java.nio.ByteOrder;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+\/**\n+ * General Layout utility functions\n+ *\/\n+public final class Layouts {\n+\n+    public static final String JEXTRACT_ANONYMOUS = \"jextract\/anonymous\";\n+    public static final String JEXTRACT_BITFIELDS = \"jextract\/bitfields\";\n+\n+    private static final String ATTR_LAYOUT_KIND = \"jextract.abi.unsupported.layout.kind\";\n+\n+    public static final ValueLayout __INT128 = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"__int128\");\n+\n+    public static final ValueLayout _FLOAT128 = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"_float128\");\n+\n+    public static final ValueLayout __FP16 = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"__fp16\");\n+\n+    public static final ValueLayout CHAR16 = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"char16\");\n+\n+    public static final ValueLayout WCHAR_T = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"wchar_t\");\n+\n+    public static final ValueLayout LONG_DOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"long double\");\n+\n+    private Layouts() {}\n+\n+    public static String getName(Type type) {\n+        Cursor c = type.getDeclarationCursor();\n+        if (c.isInvalid()) {\n+            return type.spelling();\n+        }\n+        return getName(c);\n+    }\n+\n+    public static String getName(Cursor cursor) {\n+        return cursor.spelling();\n+    }\n+\n+    public static MemoryLayout getLayout(Type t) {\n+        Supplier<UnsupportedOperationException> unsupported = () ->\n+                new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+        switch(t.kind()) {\n+            case UChar, Char_U:\n+            case SChar, Char_S:\n+                return Primitive.Kind.Char.layout().orElseThrow(unsupported);\n+            case Short:\n+            case UShort:\n+                return Primitive.Kind.Short.layout().orElseThrow(unsupported);\n+            case Int:\n+            case UInt:\n+                return Primitive.Kind.Int.layout().orElseThrow(unsupported);\n+            case ULong:\n+            case Long:\n+                return Primitive.Kind.Long.layout().orElseThrow(unsupported);\n+            case ULongLong:\n+            case LongLong:\n+                return Primitive.Kind.LongLong.layout().orElseThrow(unsupported);\n+            case UInt128:\n+            case Int128:\n+                return Primitive.Kind.Int128.layout().orElseThrow(unsupported);\n+            case Enum:\n+                return valueLayoutForSize(t.size() * 8).layout().orElseThrow(unsupported);\n+            case Bool:\n+                return Primitive.Kind.Bool.layout().orElseThrow(unsupported);\n+            case Float:\n+                return Primitive.Kind.Float.layout().orElseThrow(unsupported);\n+            case Double:\n+                return Primitive.Kind.Double.layout().orElseThrow(unsupported);\n+            case LongDouble:\n+                return Primitive.Kind.LongDouble.layout().orElseThrow(unsupported);\n+            case Complex:\n+                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+            case Record:\n+                return getRecordLayout(t);\n+            case Vector:\n+                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));\n+            case ConstantArray:\n+                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));\n+            case IncompleteArray:\n+                return MemoryLayout.ofSequence(getLayout(t.getElementType()));\n+            case Unexposed:\n+                Type canonical = t.canonicalType();\n+                if (canonical.equalType(t)) {\n+                    throw new TypeMaker.TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                }\n+                return getLayout(canonical);\n+            case Typedef:\n+            case Elaborated:\n+                return getLayout(t.canonicalType());\n+            case Pointer:\n+            case BlockPointer:\n+                return C_POINTER;\n+            default:\n+                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+        }\n+    }\n+\n+    public static Optional<MemoryLayout> getLayout(jdk.incubator.jextract.Type t) {\n+        try {\n+            return Optional.of(getLayoutInternal(t));\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static MemoryLayout getLayoutInternal(jdk.incubator.jextract.Type t) {\n+        return t.accept(layoutMaker, null);\n+    }\n+\n+    private static jdk.incubator.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new jdk.incubator.jextract.Type.Visitor<>() {\n+        @Override\n+        public MemoryLayout visitPrimitive(jdk.incubator.jextract.Type.Primitive t, Void _ignored) {\n+            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDelegated(jdk.incubator.jextract.Type.Delegated t, Void _ignored) {\n+            if (t.kind() == jdk.incubator.jextract.Type.Delegated.Kind.POINTER) {\n+                return C_POINTER;\n+            } else {\n+                return t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitFunction(jdk.incubator.jextract.Type.Function t, Void _ignored) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return C_POINTER;\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDeclared(jdk.incubator.jextract.Type.Declared t, Void _ignored) {\n+            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitArray(jdk.incubator.jextract.Type.Array t, Void _ignored) {\n+            MemoryLayout elem = t.elementType().accept(this, null);\n+            if (t.elementCount().isPresent()) {\n+                return MemoryLayout.ofSequence(t.elementCount().getAsLong(), elem);\n+            } else {\n+                return MemoryLayout.ofSequence(elem);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitType(jdk.incubator.jextract.Type t, Void _ignored) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+\n+    static MemoryLayout getRecordLayout(Type type) {\n+        return RecordLayoutComputer.compute(0, type, type);\n+    }\n+\n+    private static boolean isVoidType(jdk.incubator.jextract.Type type) {\n+        if (type instanceof jdk.incubator.jextract.Type.Primitive) {\n+            jdk.incubator.jextract.Type.Primitive pt = (jdk.incubator.jextract.Type.Primitive)type;\n+            return pt.kind() == jdk.incubator.jextract.Type.Primitive.Kind.Void;\n+        } else if (type instanceof jdk.incubator.jextract.Type.Delegated) {\n+            jdk.incubator.jextract.Type.Delegated dt = (jdk.incubator.jextract.Type.Delegated)type;\n+            return dt.kind() == jdk.incubator.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n+        }\n+        return false;\n+    }\n+\n+    public static Optional<FunctionDescriptor> getDescriptor(jdk.incubator.jextract.Type.Function t) {\n+        try {\n+            MemoryLayout[] args = t.argumentTypes().stream()\n+                    .map(Layouts::getLayoutInternal)\n+                    .toArray(MemoryLayout[]::new);\n+            jdk.incubator.jextract.Type retType = t.returnType();\n+            if (isVoidType(retType)) {\n+                return Optional.of(FunctionDescriptor.ofVoid(args));\n+            } else {\n+                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n+            }\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static Primitive.Kind valueLayoutForSize(long size) {\n+        return switch ((int) size) {\n+            case 8 -> Primitive.Kind.Char;\n+            case 16 -> Primitive.Kind.Short;\n+            case 32 -> Primitive.Kind.Int;\n+            case 64 -> Primitive.Kind.LongLong;\n+            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n+        };\n+    }\n+\n+    public static boolean isBitfields(GroupLayout layout) {\n+        return layout.attribute(JEXTRACT_BITFIELDS).isPresent();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <Z extends MemoryLayout> Z setBitfields(Z layout) {\n+        return (Z) layout.withAttribute(JEXTRACT_BITFIELDS, true);\n+    }\n+\n+    public static boolean isUnsupported(MemoryLayout vl) {\n+        return vl.attribute(ATTR_LAYOUT_KIND).isPresent();\n+    }\n+\n+    public static String getUnsupportedTypeName(MemoryLayout vl) {\n+        return (String)\n+                vl.attribute(ATTR_LAYOUT_KIND).orElseThrow(IllegalArgumentException::new);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/layout\/Layouts.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.layout;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.jextract.clang.Cursor;\n+import jdk.internal.jextract.clang.CursorKind;\n+import jdk.internal.jextract.clang.Type;\n+import jdk.internal.jextract.clang.TypeKind;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.jextract.layout.Layouts.JEXTRACT_ANONYMOUS;\n+\n+\/**\n+ * Base class for C struct, union MemoryLayout computer helper classes.\n+ *\/\n+abstract class RecordLayoutComputer {\n+    \/\/ enclosing struct type (or this struct type for top level structs)\n+    final Type parent;\n+    \/\/ this struct type\n+    final Type type;\n+    \/\/ cursor of this struct\n+    final Cursor cursor;\n+    final List<MemoryLayout> fieldLayouts;\n+\n+    private int anonCount = 0;\n+\n+    RecordLayoutComputer(Type parent, Type type) {\n+        this.parent = parent;\n+        this.type = type;\n+        this.cursor = type.getDeclarationCursor().getDefinition();\n+        this.fieldLayouts = new ArrayList<>();\n+    }\n+\n+    static MemoryLayout compute(long offsetInParent, Type parent, Type type) {\n+        Cursor cursor = type.getDeclarationCursor().getDefinition();\n+        if (cursor.isInvalid()) {\n+            return MemoryLayout.ofPaddingBits(64);\n+        }\n+\n+        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;\n+        return isUnion? new UnionLayoutComputer(offsetInParent, parent, type).compute() :\n+                new StructLayoutComputer(offsetInParent, parent, type).compute();\n+    }\n+\n+    final MemoryLayout compute() {\n+        Stream<Cursor> fieldCursors = flattenableChildren(cursor);\n+        for (Cursor fc : fieldCursors.collect(Collectors.toList())) {\n+            \/*\n+             * Ignore bitfields of zero width.\n+             *\n+             * struct Foo {\n+             *     int i:0;\n+             * }\n+             *\n+             * And bitfields without a name.\n+             * (padding is computed automatically)\n+             *\/\n+            if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n+                startBitfield();\n+                continue;\n+            }\n+\n+            processField(fc);\n+        }\n+\n+        return finishLayout();\n+    }\n+\n+    abstract void startBitfield();\n+    abstract void processField(Cursor c);\n+    abstract MemoryLayout finishLayout();\n+\n+    void addFieldLayout(MemoryLayout MemoryLayout) {\n+        fieldLayouts.add(MemoryLayout);\n+    }\n+\n+    void addFieldLayout(long offset, Type parent, Cursor c) {\n+        MemoryLayout memoryLayout = c.isAnonymousStruct()\n+            ? compute(offset, parent, c.type())\n+                .withName(nextAnonymousName())\n+                .withAttribute(JEXTRACT_ANONYMOUS, true)\n+            : fieldLayout(c);\n+        addFieldLayout(memoryLayout);\n+    }\n+\n+    private String nextAnonymousName() {\n+        return \"$anon$\" + anonCount++;\n+    }\n+\n+    MemoryLayout fieldLayout(Cursor c) {\n+        MemoryLayout l = Layouts.getLayout(c.type());\n+        String name = Layouts.getName(c);\n+        if (c.isBitField()) {\n+            MemoryLayout sublayout = MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder());\n+            return sublayout.withName(name);\n+        } else {\n+            return l.withName(name);\n+        }\n+    }\n+\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        }\n+        return c.isBitField() ? c.getBitFieldWidth() : c.type().size() * 8;\n+    }\n+\n+    MemoryLayout bitfield(List<MemoryLayout> sublayouts) {\n+        return Layouts.setBitfields(MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));\n+    }\n+\n+    long offsetOf(Type parent, Cursor c) {\n+        if (c.kind() == CursorKind.FieldDecl) {\n+            return parent.getOffsetOf(c.spelling());\n+        } else {\n+            return flattenableChildren(c)\n+                    .mapToLong(child -> offsetOf(parent, child))\n+                    .findFirst()\n+                    .orElseThrow(() -> new IllegalStateException(\n+                            \"Can not find offset of: \" + c + \", in: \" + parent));\n+        }\n+    }\n+\n+    static Stream<Cursor> flattenableChildren(Cursor c) {\n+        return c.children()\n+                .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/layout\/RecordLayoutComputer.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.layout;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.jextract.clang.Cursor;\n+import jdk.internal.jextract.clang.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C structs.\n+ *\/\n+final class StructLayoutComputer extends RecordLayoutComputer {\n+    private long offset;\n+    private long actualSize = 0L;\n+    \/\/ List to collect bitfield fields to process later, may be null\n+    private List<MemoryLayout> bitfieldLayouts;\n+\n+    StructLayoutComputer(long offsetInParent, Type parent, Type type) {\n+        super(parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void addFieldLayout(MemoryLayout MemoryLayout) {\n+        if (bitfieldLayouts != null) {\n+            bitfieldLayouts.add(MemoryLayout);\n+        } else {\n+            fieldLayouts.add(MemoryLayout);\n+        }\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/*\n+         * In a struct, a bitfield field is seen after a non-bitfield.\n+         * Initialize bitfieldLayouts list to collect this and subsequent\n+         * bitfield layouts.\n+         *\/\n+        if (bitfieldLayouts == null) {\n+            bitfieldLayouts = new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        boolean isBitfield = c.isBitField();\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedOffset - offset));\n+            actualSize += (expectedOffset - offset);\n+            offset = expectedOffset;\n+        }\n+\n+        if (isBitfield) {\n+            startBitfield();\n+        } else { \/\/ !isBitfield\n+            \/*\n+             * We may be crossing from bit fields to non-bitfield field.\n+             *\n+             * struct Foo {\n+             *     int i:12;\n+             *     int j:20;\n+             *     int k; \/\/ <-- processing this\n+             *     int m;\n+             * }\n+             *\/\n+            handleBitfields();\n+        }\n+\n+        addFieldLayout(offset, parent, c);\n+        long size = fieldSize(c);\n+        offset += size;\n+        actualSize += size;\n+    }\n+\n+    @Override\n+    MemoryLayout finishLayout() {\n+        \/\/ pad at the end, if any\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize - actualSize));\n+        }\n+\n+        \/*\n+         * Handle bitfields at the end, if any.\n+         *\n+         * struct Foo {\n+         *     int i,j, k;\n+         *     int f:10;\n+         *     int pad:12;\n+         * }\n+         *\/\n+        handleBitfields();\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.ofStruct(fields);\n+        String name = Layouts.getName(cursor);\n+        return name.isEmpty() ?\n+                g : g.withName(name);\n+    }\n+\n+    \/\/ process bitfields if any and clear bitfield layouts\n+    private void handleBitfields() {\n+        if (bitfieldLayouts != null) {\n+            fieldLayouts.add(bitfield(bitfieldLayouts));\n+            bitfieldLayouts = null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/layout\/StructLayoutComputer.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.layout;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.jextract.clang.Cursor;\n+import jdk.internal.jextract.clang.Type;\n+import jdk.internal.jextract.clang.TypeKind;\n+\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C unions.\n+ *\/\n+final class UnionLayoutComputer extends RecordLayoutComputer {\n+    private final long offset;\n+    private long actualSize = 0L;\n+\n+    UnionLayoutComputer(long offsetInParent, Type parent, Type type) {\n+        super(parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            throw new IllegalStateException(\"No padding in union elements!\");\n+        }\n+\n+        addFieldLayout(offset, parent, c);\n+        actualSize = Math.max(actualSize, fieldSize(c));\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    MemoryLayout fieldLayout(Cursor c) {\n+        if (c.isBitField()) {\n+            return bitfield(List.of(super.fieldLayout(c)));\n+        } else {\n+            return super.fieldLayout(c);\n+        }\n+    }\n+\n+    @Override\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        } else if (c.isBitField()) {\n+            return c.getBitFieldWidth();\n+        } else {\n+            return c.type().size() * 8;\n+        }\n+    }\n+\n+    @Override\n+    MemoryLayout finishLayout() {\n+        \/\/ size mismatch indicates use of bitfields in union\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize));\n+        } else if (actualSize > expectedSize) {\n+            throw new AssertionError(\"Invalid union size - expected: \" + expectedSize + \"; found: \" + actualSize);\n+        }\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.ofUnion(fields);\n+        String name = Layouts.getName(cursor);\n+        return name.isEmpty() ?\n+                g : g.withName(name);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/layout\/UnionLayoutComputer.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.parser;\n+\n+public class ClangException extends RuntimeException {\n+    private static final long serialVersionUID = 0L;\n+\n+    public ClangException(String message) {\n+        super(message);\n+    }\n+\n+    public ClangException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public ClangException(Throwable cause) {\n+        super(cause);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/parser\/ClangException.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.parser;\n+\n+import java.lang.constant.Constable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+import jdk.internal.jextract.layout.Layouts;\n+import jdk.internal.jextract.util.PrettyPrinter;\n+\n+public abstract class DeclarationImpl implements Declaration {\n+\n+    private final String name;\n+    private final Position pos;\n+    private final Optional<Map<String, List<Constable>>> attributes;\n+\n+    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {\n+        this.name = name;\n+        this.pos = pos;\n+        this.attributes = Optional.ofNullable(attrs);\n+    }\n+\n+    public String toString() {\n+        return new PrettyPrinter().print(this);\n+    }\n+\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Position pos() {\n+        return pos;\n+    }\n+\n+    @Override\n+    public Optional<List<Constable>> getAttribute(String name) {\n+        return attributes.map(attrs -> attrs.get(name));\n+    }\n+\n+    @Override\n+    public Set<String> attributeNames() { return Collections.unmodifiableSet(\n+            attributes.map(Map::keySet).orElse(Collections.emptySet()));\n+    }\n+\n+    @Override\n+    public Declaration withAttribute(String name, Constable... values) {\n+        if (values == null || values.length == 0) {\n+            return withAttributes(null);\n+        }\n+        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);\n+        attrs.put(name, List.of(values));\n+        return withAttributes(attrs);\n+    }\n+\n+    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof Declaration)) return false;\n+        Declaration decl = (Declaration) o;\n+        return name().equals(decl.name());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name);\n+    }\n+\n+    public static final class TypedefImpl extends DeclarationImpl implements Declaration.Typedef {\n+        final Type type;\n+\n+        public TypedefImpl(Type type, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitTypedef(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Typedef withAttributes(Map<String, List<Constable>> attrs) {\n+            return new TypedefImpl(type, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Typedef stripAttributes() {\n+            return new TypedefImpl(type, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Typedef)) return false;\n+\n+            Declaration.Typedef other = (Declaration.Typedef) o;\n+            return name().equals(other.name()) &&\n+                    type.equals(other.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class VariableImpl extends DeclarationImpl implements Declaration.Variable {\n+\n+        final Variable.Kind kind;\n+        final Type type;\n+        final Optional<MemoryLayout> layout;\n+\n+        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.type = Objects.requireNonNull(type);\n+            this.layout = Objects.requireNonNull(layout);\n+        }\n+\n+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n+            this(type, Layouts.getLayout(type), kind, name, pos, null);\n+        }\n+\n+        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {\n+            this(type, Optional.of(layout), kind, name, pos, null);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitVariable(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n+            return new VariableImpl(type, layout, kind, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Variable stripAttributes() {\n+            return new VariableImpl(type, layout, kind, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Variable)) return false;\n+\n+            Declaration.Variable variable = (Declaration.Variable) o;\n+            if (!super.equals(o)) return false;\n+            return kind == variable.kind() &&\n+                    type.equals(variable.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, type);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends DeclarationImpl implements Declaration.Function {\n+\n+        final List<Variable> params;\n+        final Type.Function type;\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos) {\n+            this(type, params, name, pos, null);\n+        }\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.params = Objects.requireNonNull(params);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public List<Variable> parameters() {\n+            return params;\n+        }\n+\n+        @Override\n+        public Type.Function type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Function withAttributes(Map<String, List<Constable>> attrs) {\n+            return new FunctionImpl(type, params, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Function stripAttributes() {\n+            return new FunctionImpl(type, params, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Function)) return false;\n+            if (!super.equals(o)) return false;\n+\n+            Declaration.Function function = (Declaration.Function) o;\n+            return type.equals(function.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static class ScopedImpl extends DeclarationImpl implements Declaration.Scoped {\n+\n+        private final Scoped.Kind kind;\n+        private final List<Declaration> declarations;\n+        private final Optional<MemoryLayout> optLayout;\n+\n+        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.of(layout), declarations, name, pos, null);\n+        }\n+\n+        public ScopedImpl(Kind kind, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.empty(), declarations, name, pos, null);\n+        }\n+\n+        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,\n+                String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.declarations = Objects.requireNonNull(declarations);\n+            this.optLayout = Objects.requireNonNull(optLayout);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitScoped(this, data);\n+        }\n+\n+        @Override\n+        public List<Declaration> members() {\n+            return declarations;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return optLayout;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public Scoped withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Scoped stripAttributes() {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Scoped)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Scoped scoped = (Declaration.Scoped) o;\n+            return kind == scoped.kind() &&\n+                    declarations.equals(scoped.members());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, declarations);\n+        }\n+    }\n+\n+    public static final class ConstantImpl extends DeclarationImpl implements Declaration.Constant {\n+\n+        final Object value;\n+        final Type type;\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos) {\n+            this(type, value, name, pos, null);\n+        }\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.value = Objects.requireNonNull(value);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitConstant(this, data);\n+        }\n+\n+        @Override\n+        public Object value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Constant withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ConstantImpl(type, value, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Constant stripAttributes() {\n+            return new ConstantImpl(type, value, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Constant)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Constant constant = (Declaration.Constant) o;\n+            return value.equals(constant.value()) &&\n+                    type.equals(constant.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), value, type);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/parser\/DeclarationImpl.java","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -0,0 +1,378 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.parser;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.jextract.JextractTool;\n+import jdk.internal.jextract.clang.Cursor;\n+import jdk.internal.jextract.clang.CursorKind;\n+import jdk.internal.jextract.clang.Diagnostic;\n+import jdk.internal.jextract.clang.EvalResult;\n+import jdk.internal.jextract.clang.Index;\n+import jdk.internal.jextract.clang.LibClang;\n+import jdk.internal.jextract.clang.TranslationUnit;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+class MacroParser {\n+\n+    private final ClangReparser reparser;\n+    private final TreeMaker treeMaker;\n+    final MacroTable macroTable;\n+\n+    private MacroParser(ClangReparser reparser, TreeMaker treeMaker) {\n+        this.reparser = reparser;\n+        this.treeMaker = treeMaker;\n+        this.macroTable = new MacroTable();\n+    }\n+\n+    static MacroParser make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {\n+        ClangReparser reparser;\n+        try {\n+            reparser = new ClangReparser(tu, args);\n+        } catch (IOException | Index.ParsingFailedException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        return new MacroParser(reparser, treeMaker);\n+    }\n+\n+    \/**\n+     * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made\n+     * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.\n+     * If that is not possible (e.g. because the macro refers to other macro, or has a more complex grammar), fall\n+     * back to use clang evaluation support.\n+     *\/\n+    Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {\n+        if (!(pos instanceof TreeMaker.CursorPosition)) {\n+            return Optional.empty();\n+        } else {\n+            Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();\n+            if (cursor.isMacroFunctionLike()) {\n+                return Optional.empty();\n+            } else if (tokens.length == 2) {\n+                \/\/check for fast path\n+                Integer num = toNumber(tokens[1]);\n+                if (num != null) {\n+                    return Optional.of(treeMaker.createMacro(cursor, name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n+                }\n+            }\n+            macroTable.enterMacro(name, tokens, cursor);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Integer toNumber(String str) {\n+        try {\n+            \/\/ Integer.decode supports '#' hex literals which is not valid in C.\n+            return str.length() > 0 && str.charAt(0) != '#'? Integer.decode(str) : null;\n+        } catch (NumberFormatException nfe) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * This class allows client to reparse a snippet of code against a given set of include files.\n+     * For performance reasons, the set of includes (which comes from the jextract parser) is compiled\n+     * into a precompiled header, so as to speed to incremental recompilation of the generated snippets.\n+     *\/\n+    static class ClangReparser {\n+        final Path macro;\n+        final Index macroIndex = LibClang.createIndex(true);\n+        final TranslationUnit macroUnit;\n+\n+        public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {\n+            Path precompiled = Files.createTempFile(\"jextract$\", \".pch\");\n+            precompiled.toFile().deleteOnExit();\n+            tu.save(precompiled);\n+            this.macro = Files.createTempFile(\"jextract$\", \".h\");\n+            this.macro.toFile().deleteOnExit();\n+            String[] patchedArgs = Stream.concat(\n+                Stream.of(\n+                    \/\/ Avoid system search path, use bundled instead\n+                    \"-nostdinc\",\n+                    \"-ferror-limit=0\",\n+                    \/\/ precompiled header\n+                    \"-include-pch\", precompiled.toAbsolutePath().toString()),\n+                args.stream()).toArray(String[]::new);\n+            this.macroUnit = macroIndex.parse(macro.toAbsolutePath().toString(),\n+                    this::processDiagnostics,\n+                    false, \/\/add serialization support (needed for macros)\n+                    patchedArgs);\n+        }\n+\n+        void processDiagnostics(Diagnostic diag) {\n+            if (JextractTool.DEBUG) {\n+                System.err.println(\"Error while processing macro: \" + diag.spelling());\n+            }\n+        }\n+\n+        public Stream<Cursor> reparse(String snippet) {\n+            macroUnit.reparse(this::processDiagnostics,\n+                    Index.UnsavedFile.of(macro, snippet));\n+            return macroUnit.getCursor().children();\n+        }\n+    }\n+\n+    \/**\n+     * This abstraction is used to collect all macros which could not be interpreted during {@link #parseConstant(Position, String, String[])}.\n+     * All unparsed macros in the table can have three different states: UNPARSED (which means the macro has not been parsed yet),\n+     * SUCCESS (which means the macro has been parsed and has a type and a value) and FAILURE, which means the macro has been\n+     * parsed with some errors, but for which we were at least able to infer a type.\n+     *\n+     * The reparsing process goes as follows:\n+     * 1. all unparsed macros are added to the table in the UNPARSED state.\n+     * 2. a snippet for all macros in the UNPARSED state is compiled and the table state is updated\n+     * 3. a recovery snippet for all macros in the FAILURE state is compiled and the table state is updated again\n+     * 4. we repeat from (2) until no further progress is made.\n+     * 5. we return a list of macro which are in the SUCCESS state.\n+     *\n+     * State transitions in the table are as follows:\n+     * - an UNPARSED macro can go to either SUCCESS, to FAILURE or be removed (if not even a type can be inferred)\n+     * - a FAILURE macro can go to either SUCCESS (if recovery step succeds) or be removed\n+     * - a SUCCESS macro cannot go in any other state\n+     *\/\n+    class MacroTable {\n+\n+        final Map<String, Entry> macrosByMangledName = new LinkedHashMap<>();\n+\n+        abstract class Entry {\n+            final String name;\n+            final String[] tokens;\n+            final Cursor cursor;\n+\n+            Entry(String name, String[] tokens, Cursor cursor) {\n+                this.name = name;\n+                this.tokens = tokens;\n+                this.cursor = cursor;\n+            }\n+\n+            String mangledName() {\n+                return \"jextract$macro$\" + name;\n+            }\n+\n+            Entry success(Type type, Object value) {\n+                throw new IllegalStateException();\n+            }\n+\n+            Entry failure(Type type) {\n+                throw new IllegalStateException();\n+            }\n+\n+            boolean isSuccess() {\n+                return false;\n+            }\n+            boolean isRecoverableFailure() {\n+                return false;\n+            }\n+            boolean isUnparsed() {\n+                return false;\n+            }\n+\n+            void update() {\n+                macrosByMangledName.put(mangledName(), this);\n+            }\n+        }\n+\n+        class Unparsed extends Entry {\n+            Unparsed(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return type != null ?\n+                        new RecoverableFailure(name, tokens, cursor, type) :\n+                        new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isUnparsed() {\n+                return true;\n+            }\n+\n+            @Override\n+            void update() {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        class RecoverableFailure extends Entry {\n+\n+            final Type type;\n+\n+            public RecoverableFailure(String name, String[] tokens, Cursor cursor, Type type) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, this.type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isRecoverableFailure() {\n+                return true;\n+            }\n+        }\n+\n+        class Success extends Entry {\n+            final Type type;\n+            final Object value;\n+\n+            public Success(String name, String[] tokens, Cursor cursor, Type type, Object value) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+                this.value = value;\n+            }\n+\n+            @Override\n+            boolean isSuccess() {\n+                return true;\n+            }\n+\n+            public Object value() {\n+                return value;\n+            }\n+        }\n+\n+        class UnparseableMacro extends Entry {\n+\n+            UnparseableMacro(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            void update() {\n+                macrosByMangledName.remove(mangledName());\n+            }\n+        };\n+\n+        void enterMacro(String name, String[] tokens, Cursor cursor) {\n+            Unparsed unparsed = new Unparsed(name, tokens, cursor);\n+            macrosByMangledName.put(unparsed.mangledName(), unparsed);\n+        }\n+\n+        public List<Declaration.Constant> reparseConstants() {\n+            int last = -1;\n+            while (macrosByMangledName.size() > 0 && last != macrosByMangledName.size()) {\n+                last = macrosByMangledName.size();\n+                \/\/ step 1 - try parsing macros as var declarations\n+                reparseMacros(false);\n+                \/\/ step 2 - retry failed parsed macros as pointers\n+                reparseMacros(true);\n+            }\n+            treeMaker.typeMaker.resolveTypeReferences();\n+            return macrosByMangledName.values().stream()\n+                    .filter(Entry::isSuccess)\n+                    .map(e -> treeMaker.createMacro(e.cursor, e.name, ((Success)e).type, ((Success)e).value))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        void updateTable(TypeMaker typeMaker, Cursor decl) {\n+            String mangledName = decl.spelling();\n+            Entry entry = macrosByMangledName.get(mangledName);\n+            try (EvalResult result = decl.eval()) {\n+                Entry newEntry = switch (result.getKind()) {\n+                    case Integral -> {\n+                        long value = result.getAsInt();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case FloatingPoint -> {\n+                        double value = result.getAsFloat();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case StrLiteral -> {\n+                        String value = result.getAsString();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    default -> {\n+                        Type type = decl.type().equals(decl.type().canonicalType()) ?\n+                                null : typeMaker.makeType(decl.type());\n+                        yield entry.failure(type);\n+                    }\n+                };\n+                newEntry.update();\n+            }\n+        }\n+\n+        void reparseMacros(boolean recovery) {\n+            String snippet = macroDecl(recovery);\n+            TreeMaker treeMaker = new TreeMaker();\n+            try {\n+                reparser.reparse(snippet)\n+                        .filter(c -> c.kind() == CursorKind.VarDecl &&\n+                                c.spelling().contains(\"jextract$\"))\n+                        .forEach(c -> updateTable(treeMaker.typeMaker, c));\n+            } finally {\n+                treeMaker.typeMaker.resolveTypeReferences();\n+            }\n+        }\n+\n+        String macroDecl(boolean recovery) {\n+            StringBuilder buf = new StringBuilder();\n+            if (recovery) {\n+                buf.append(\"#include <stdint.h>\\n\");\n+            }\n+            macrosByMangledName.values().stream()\n+                    .filter(e -> !e.isSuccess()) \/\/ skip macros that already have passed\n+                    .filter(recovery ? Entry::isRecoverableFailure : Entry::isUnparsed)\n+                    .forEach(e -> {\n+                        buf.append(\"__auto_type \")\n+                                .append(e.mangledName())\n+                                .append(\" = \");\n+                        if (recovery) {\n+                            buf.append(\"(uintptr_t)\");\n+                        }\n+                        buf.append(e.name)\n+                                .append(\";\\n\");\n+                    });\n+            return buf.toString();\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/parser\/MacroParser.java","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.parser;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.internal.jextract.clang.Cursor;\n+import jdk.internal.jextract.clang.CursorKind;\n+import jdk.internal.jextract.clang.Diagnostic;\n+import jdk.internal.jextract.clang.Index;\n+import jdk.internal.jextract.clang.LibClang;\n+import jdk.internal.jextract.clang.SourceLocation;\n+import jdk.internal.jextract.clang.SourceRange;\n+import jdk.internal.jextract.clang.TranslationUnit;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class Parser {\n+    private final TreeMaker treeMaker;\n+\n+    public Parser() {\n+        this.treeMaker = new TreeMaker();\n+    }\n+\n+    public Declaration.Scoped parse(Path path, Collection<String> args) {\n+        final Index index = LibClang.createIndex(false);\n+\n+        TranslationUnit tu = index.parse(path.toString(),\n+            d -> {\n+                if (d.severity() > Diagnostic.CXDiagnostic_Warning) {\n+                    throw new ClangException(d.toString());\n+                }\n+            },\n+            true, args.toArray(new String[0]));\n+\n+        MacroParser macroParser = MacroParser.make(treeMaker, tu, args);\n+\n+        List<Declaration> decls = new ArrayList<>();\n+        Cursor tuCursor = tu.getCursor();\n+        tuCursor.children().\n+            forEach(c -> {\n+                SourceLocation loc = c.getSourceLocation();\n+                if (loc == null) {\n+                    return;\n+                }\n+\n+                SourceLocation.Location src = loc.getFileLocation();\n+                if (src == null) {\n+                    return;\n+                }\n+\n+\n+                if (c.isDeclaration()) {\n+                    if (c.kind() == CursorKind.UnexposedDecl ||\n+                        c.kind() == CursorKind.Namespace) {\n+                        c.children().map(treeMaker::createTree)\n+                                .filter(t -> t != null)\n+                                .forEach(decls::add);\n+                    } else {\n+                        Declaration decl = treeMaker.createTree(c);\n+                        if (decl != null) {\n+                            decls.add(decl);\n+                        }\n+                    }\n+                } else if (isMacro(c) && src.path() != null) {\n+                    SourceRange range = c.getExtent();\n+                    String[] tokens = c.getTranslationUnit().tokens(range);\n+                    Optional<Declaration.Constant> constant = macroParser.parseConstant(treeMaker.toPos(c), c.spelling(), tokens);\n+                    if (constant.isPresent()) {\n+                        decls.add(constant.get());\n+                    }\n+                }\n+            });\n+\n+        decls.addAll(macroParser.macroTable.reparseConstants());\n+        Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);\n+        treeMaker.freeze();\n+        index.close();\n+        return rv;\n+    }\n+\n+    private boolean isMacro(Cursor c) {\n+        return c.isPreprocessing() && c.kind() == CursorKind.MacroDefinition;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/parser\/Parser.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.parser;\n+\n+import java.lang.constant.Constable;\n+import java.nio.ByteOrder;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+import jdk.internal.jextract.clang.Cursor;\n+import jdk.internal.jextract.clang.CursorKind;\n+import jdk.internal.jextract.clang.SourceLocation;\n+import jdk.internal.jextract.layout.Layouts;\n+import jdk.internal.jextract.util.PrettyPrinter;\n+\n+class TreeMaker {\n+    public TreeMaker() {}\n+\n+    TypeMaker typeMaker = new TypeMaker(this);\n+\n+    public void freeze() {\n+        typeMaker.resolveTypeReferences();\n+    }\n+\n+    interface ScopedFactoryLayout {\n+        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);\n+    }\n+\n+    interface ScopedFactoryNoLayout {\n+        Declaration.Scoped make(Position pos, String name, Declaration... decls);\n+    }\n+\n+    interface VarFactoryNoLayout {\n+        Declaration.Variable make(Position pos, String name, Type type);\n+    }\n+\n+    Map<String, List<Constable>> collectAttributes(Cursor c) {\n+        return c.children().filter(Cursor::isAttribute)\n+                .collect(Collectors.groupingBy(\n+                        attr -> attr.kind().name(),\n+                        Collectors.mapping(Cursor::spelling, Collectors.toList())\n+                ));\n+    }\n+\n+    public Declaration createTree(Cursor c) {\n+        Objects.requireNonNull(c);\n+        var rv = (DeclarationImpl) createTreeInternal(c);\n+        return (rv == null) ? null : rv.withAttributes(collectAttributes(c));\n+    }\n+\n+    private Declaration createTreeInternal(Cursor c) {\n+        switch (c.kind()) {\n+            case EnumDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.ENUM, Declaration::enum_, Declaration::enum_);\n+            case EnumConstantDecl:\n+                return createEnumConstant(c);\n+            case FieldDecl:\n+                return createVar(c.isBitField() ?\n+                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);\n+            case ParmDecl:\n+                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);\n+            case FunctionDecl:\n+                return createFunction(c);\n+            case StructDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n+            case UnionDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n+            case TypedefDecl: {\n+                return createTypedef(c);\n+            }\n+            case VarDecl:\n+                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    Position toPos(Cursor cursor) {\n+        SourceLocation loc = cursor.getSourceLocation();\n+        if (loc == null) {\n+            return Position.NO_POSITION;\n+        }\n+        SourceLocation.Location sloc = loc.getFileLocation();\n+        if (sloc == null) {\n+            return Position.NO_POSITION;\n+        }\n+        return new CursorPosition(cursor);\n+    }\n+\n+    static class CursorPosition implements Position {\n+        private final Cursor cursor;\n+        private final Path path;\n+        private final int line;\n+        private final int column;\n+\n+        CursorPosition(Cursor cursor) {\n+            this.cursor = cursor;\n+            SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();\n+            this.path = loc.path();\n+            this.line = loc.line();\n+            this.column = loc.column();\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+\n+        @Override\n+        public int line() {\n+            return line;\n+        }\n+\n+        @Override\n+        public int col() {\n+            return column;\n+        }\n+\n+        public Cursor cursor() {\n+            return cursor;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return PrettyPrinter.position(this);\n+        }\n+    }\n+\n+    public Declaration.Function createFunction(Cursor c) {\n+        checkCursor(c, CursorKind.FunctionDecl);\n+        List<Declaration.Variable> params = new ArrayList<>();\n+        for (int i = 0 ; i < c.numberOfArgs() ; i++) {\n+            params.add((Declaration.Variable)createTree(c.getArgument(i)));\n+        }\n+        Type type = toType(c);\n+        Type funcType = type instanceof Type.Delegated? ((Type.Delegated)type).type() : type;\n+        return Declaration.function(toPos(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0]));\n+    }\n+\n+    public Declaration.Constant createMacro(Cursor c, String name, Type type, Object value) {\n+        checkCursorAny(c, CursorKind.MacroDefinition);\n+        return Declaration.constant(toPos(c), name, value, type);\n+    }\n+\n+    public Declaration.Constant createEnumConstant(Cursor c) {\n+        return Declaration.constant(toPos(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));\n+    }\n+\n+    public Declaration.Scoped createHeader(Cursor c, List<Declaration> decls) {\n+        return Declaration.toplevel(toPos(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));\n+    }\n+\n+    public Declaration.Scoped createScoped(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+        List<Declaration> decls = filterNestedDeclarations(c.children()\n+                .filter(fc -> {\n+                    if (fc.isBitField()) {\n+                        \/\/ only non-empty and named bit fields are generated\n+                        return fc.getBitFieldWidth() != 0 && !fc.spelling().isEmpty();\n+                    }\n+                    return true;\n+                })\n+                .map(this::createTree).collect(Collectors.toList()));\n+        if (c.isDefinition()) {\n+            \/\/just a declaration AND definition, we have a layout\n+            MemoryLayout layout = null;\n+            try {\n+                layout = Layouts.getLayout(c.type());\n+            } catch (TypeMaker.TypeException ex) {\n+                System.err.println(ex);\n+                System.err.println(\"WARNING: generating empty struct: \" + c.spelling());\n+                return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            }\n+            List<Declaration> adaptedDecls = layout instanceof GroupLayout ?\n+                    collectBitfields(layout, decls) :\n+                    decls;\n+            return factoryLayout.make(toPos(c), c.spelling(), layout, adaptedDecls.toArray(new Declaration[0]));\n+        } else {\n+            \/\/just a declaration\n+            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n+                    scopeKind == Declaration.Scoped.Kind.UNION ||\n+                    scopeKind == Declaration.Scoped.Kind.ENUM ||\n+                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n+                \/\/if there's a real definition somewhere else, skip this redundant declaration\n+                if (!c.getDefinition().isInvalid()) {\n+                    return null;\n+                }\n+            }\n+            return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n+        }\n+    }\n+\n+    private static boolean isEnum(Declaration d) {\n+        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.ENUM;\n+    }\n+\n+    private static boolean isAnonymousStruct(Declaration declaration) {\n+        return ((CursorPosition)declaration.pos()).cursor.isAnonymousStruct();\n+    }\n+\n+    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {\n+        return declarations.stream()\n+                .filter(Objects::nonNull)\n+                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Declaration.Typedef createTypedef(Cursor c) {\n+        Type cursorType = toType(c);\n+        Type canonicalType = cursorType instanceof Type.Function\n+            ? cursorType\n+            : ((Type.Delegated) cursorType).type(); \/\/ normal typedef\n+        if (canonicalType instanceof Type.Declared) {\n+            Declaration.Scoped s = ((Type.Declared) canonicalType).tree();\n+            if (s.name().equals(c.spelling())) {\n+                \/\/ typedef record with the same name, no need to present twice\n+                return null;\n+            }\n+        }\n+        return Declaration.typedef(toPos(c), c.spelling(), canonicalType);\n+    }\n+\n+    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {\n+        checkCursorAny(c, CursorKind.VarDecl, CursorKind.FieldDecl, CursorKind.ParmDecl);\n+        if (c.isBitField()) {\n+            return Declaration.bitfield(toPos(c), c.spelling(), toType(c),\n+                    MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder()));\n+        } else {\n+            Type type = null;\n+            try {\n+                type = toType(c);\n+            } catch (TypeMaker.TypeException ex) {\n+                System.err.println(ex);\n+                System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n+                return null;\n+            }\n+            return varFactory.make(toPos(c), c.spelling(), type);\n+        }\n+    }\n+\n+    private static void collectNestedBitFields(Set<Declaration> out, Declaration.Scoped anonymousStruct) {\n+        for  (Declaration field : anonymousStruct.members()) {\n+            if (isAnonymousStruct(field)) {\n+                collectNestedBitFields(out, (Declaration.Scoped) field);\n+            } else if (field instanceof Declaration.Scoped\n+                       && ((Declaration.Scoped) field).kind() == Declaration.Scoped.Kind.BITFIELDS) {\n+                out.addAll(((Declaration.Scoped) field).members());\n+            }\n+        }\n+    }\n+\n+    private static Set<Declaration> nestedBitFields(List<Declaration> members) {\n+        Set<Declaration> res = new HashSet<>();\n+        for (Declaration member : members) {\n+            if (isAnonymousStruct(member)) {\n+                collectNestedBitFields(res, (Declaration.Scoped) member);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {\n+        Set<String> nestedBitfieldNames = nestedBitFields(declarations).stream()\n+                                                                       .map(Declaration::name)\n+                                                                       .collect(Collectors.toSet());\n+        List<Declaration> newDecls = new ArrayList<>();\n+        for (MemoryLayout e : ((GroupLayout)layout).memberLayouts()) {\n+            if (e instanceof GroupLayout contents && Layouts.isBitfields(contents)) {\n+                List<Declaration.Variable> bfDecls = new ArrayList<>();\n+                outer: for (MemoryLayout bitfield : contents.memberLayouts()) {\n+                    if (bitfield.name().isPresent() && !nestedBitfieldNames.contains(bitfield.name().get())) {\n+                        Iterator<Declaration> declIt = declarations.iterator();\n+                        while (declIt.hasNext()) {\n+                            Declaration d = declIt.next();\n+                            if (d.name().equals(bitfield.name().get())) {\n+                                bfDecls.add((Declaration.Variable)d);\n+                                declIt.remove();\n+                                continue outer;\n+                            }\n+                        }\n+                        throw new IllegalStateException(\"No matching declaration found for bitfield: \" + bitfield);\n+                    }\n+                }\n+                if (!bfDecls.isEmpty()) {\n+                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), \"\", contents, bfDecls.toArray(new Declaration.Variable[0])));\n+                }\n+            }\n+        }\n+        newDecls.addAll(declarations);\n+        return newDecls;\n+    }\n+\n+    private Type toType(Cursor c) {\n+        return typeMaker.makeType(c.type());\n+    }\n+\n+    private void checkCursor(Cursor c, CursorKind k) {\n+        if (c.kind() != k) {\n+            throw new IllegalArgumentException(\"Invalid cursor kind\");\n+        }\n+    }\n+\n+    private void checkCursorAny(Cursor c, CursorKind... kinds) {\n+        CursorKind expected = Objects.requireNonNull(c.kind());\n+        for (CursorKind k : kinds) {\n+            if (k == expected) {\n+                return;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid cursor kind\");\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/parser\/TreeMaker.java","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.parser;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Supplier;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import jdk.internal.jextract.util.PrettyPrinter;\n+\n+public abstract class TypeImpl implements Type {\n+\n+    @Override\n+    public boolean isErroneous() {\n+        return false;\n+    }\n+\n+    static boolean equals(Type t1, Type.Delegated t2) {\n+        assert t1 != null;\n+        assert t2 != null;\n+\n+        return (t2.kind() == Delegated.Kind.TYPEDEF) && t1.equals(t2.type());\n+    }\n+\n+    public static final TypeImpl ERROR = new TypeImpl() {\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitType(this, data);\n+        }\n+\n+        @Override\n+        public boolean isErroneous() {\n+            return true;\n+        }\n+    };\n+\n+    public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {\n+\n+        private final Primitive.Kind kind;\n+\n+        public PrimitiveImpl(Kind kind) {\n+            this.kind = Objects.requireNonNull(kind);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitPrimitive(this, data);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Primitive)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated)o);\n+            }\n+            Type.Primitive primitive = (Type.Primitive) o;\n+            return kind == primitive.kind();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind);\n+        }\n+    }\n+\n+    static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {\n+        Delegated.Kind kind;\n+        Optional<String> name;\n+\n+        DelegatedBase(Kind kind, Optional<String> name) {\n+            this.kind = Objects.requireNonNull(kind);\n+            this.name = Objects.requireNonNull(name);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDelegated(this, data);\n+        }\n+\n+        @Override\n+        public final Delegated.Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public final Optional<String> name() {\n+            return name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) {\n+                return (o instanceof Type) && equals((Type)o, this);\n+            }\n+            Type.Delegated that = (Type.Delegated) o;\n+            return kind == that.kind() &&\n+                    name.equals(that.name());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, name);\n+        }\n+    }\n+\n+    public static final class QualifiedImpl extends DelegatedBase {\n+        private final Type type;\n+\n+        public QualifiedImpl(Kind kind, Type type) {\n+            this(kind, Optional.empty(), type);\n+        }\n+\n+        public QualifiedImpl(Kind kind, String name, Type type) {\n+            this(kind, Optional.of(name), type);\n+        }\n+\n+        private QualifiedImpl(Kind kind, Optional<String> name, Type type) {\n+            super(kind, name);\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) return false;\n+            if (!super.equals(o)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Delegated qualified = (Type.Delegated) o;\n+            return Objects.equals(type, qualified.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class PointerImpl extends DelegatedBase {\n+        private final Supplier<Type> pointeeFactory;\n+\n+        public PointerImpl(Supplier<Type> pointeeFactory) {\n+            super(Kind.POINTER, Optional.empty());\n+            this.pointeeFactory = Objects.requireNonNull(pointeeFactory);\n+        }\n+\n+        public PointerImpl(Type pointee) {\n+            this(() -> pointee);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return pointeeFactory.get();\n+        }\n+    }\n+\n+    public static final class DeclaredImpl extends TypeImpl implements Type.Declared {\n+\n+        private final Declaration.Scoped declaration;\n+\n+        public DeclaredImpl(Declaration.Scoped declaration) {\n+            super();\n+            this.declaration = Objects.requireNonNull(declaration);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDeclared(this, data);\n+        }\n+\n+        @Override\n+        public Declaration.Scoped tree() {\n+            return declaration;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Declared)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Declared declared = (Type.Declared) o;\n+            return declaration.equals(declared.tree());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(declaration);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends TypeImpl implements Type.Function {\n+\n+        private final boolean varargs;\n+        private final List<Type> argtypes;\n+        private final Type restype;\n+\n+        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype) {\n+            super();\n+            this.varargs = varargs;\n+            this.argtypes = Objects.requireNonNull(argtypes);\n+            this.restype = Objects.requireNonNull(restype);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public boolean varargs() {\n+            return varargs;\n+        }\n+\n+        @Override\n+        public List<Type> argumentTypes() {\n+            return argtypes;\n+        }\n+\n+        @Override\n+        public Type returnType() {\n+            return restype;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Function)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Function function = (Type.Function) o;\n+            return varargs == function.varargs() &&\n+                    argtypes.equals(function.argumentTypes()) &&\n+                    restype.equals(function.returnType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(varargs, argtypes, restype);\n+        }\n+    }\n+\n+    public static final class ArrayImpl extends TypeImpl implements Type.Array {\n+\n+        private final Kind kind;\n+        private final OptionalLong elemCount;\n+        private final Type elemType;\n+\n+        public ArrayImpl(Kind kind, long count, Type elemType) {\n+            this(kind, elemType, OptionalLong.of(count));\n+        }\n+\n+        public ArrayImpl(Kind kind, Type elemType) {\n+            this(kind, elemType, OptionalLong.empty());\n+        }\n+\n+        private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {\n+            super();\n+            this.kind = Objects.requireNonNull(kind);\n+            this.elemCount = Objects.requireNonNull(elemCount);\n+            this.elemType = Objects.requireNonNull(elemType);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitArray(this, data);\n+        }\n+\n+        @Override\n+        public OptionalLong elementCount() {\n+            return elemCount;\n+        }\n+\n+        @Override\n+        public Type elementType() {\n+            return elemType;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Array)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Array array = (Type.Array) o;\n+            return kind == array.kind() &&\n+                    elemType.equals(array.elementType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, elemType);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return PrettyPrinter.type(this);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/parser\/TypeImpl.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.parser;\n+\n+\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.jextract.Type.Delegated;\n+import jdk.incubator.jextract.Type.Primitive;\n+\n+public class TypeMaker {\n+\n+    TreeMaker treeMaker;\n+    private final Map<jdk.internal.jextract.clang.Type, Type> typeCache = new HashMap<>();\n+    private List<ClangTypeReference> unresolved = new ArrayList<>();\n+\n+    private class ClangTypeReference implements Supplier<Type> {\n+        jdk.internal.jextract.clang.Type origin;\n+        Type derived;\n+\n+        private ClangTypeReference(jdk.internal.jextract.clang.Type origin) {\n+            this.origin = origin;\n+            derived = typeCache.get(origin);\n+        }\n+\n+        public boolean isUnresolved() {\n+            return null == derived;\n+        }\n+\n+        public void resolve() {\n+            derived = makeType(origin);\n+            Objects.requireNonNull(derived, \"Clang type cannot be resolved: \" + origin.spelling());\n+        }\n+\n+        public Type get() {\n+            Objects.requireNonNull(derived, \"Type is not yet resolved.\");\n+            return derived;\n+        }\n+    }\n+\n+    private ClangTypeReference reference(jdk.internal.jextract.clang.Type type) {\n+        ClangTypeReference ref = new ClangTypeReference(type);\n+        if (ref.isUnresolved()) {\n+            unresolved.add(ref);\n+        }\n+        return ref;\n+    }\n+\n+    public TypeMaker(TreeMaker treeMaker) {\n+        this.treeMaker = treeMaker;\n+    }\n+\n+    \/**\n+     * Resolve all type references. This method should be called before discard clang cursors\/types\n+     *\/\n+    void resolveTypeReferences() {\n+        List<ClangTypeReference> resolving = unresolved;\n+        unresolved = new ArrayList<>();\n+        while (! resolving.isEmpty()) {\n+            resolving.forEach(ClangTypeReference::resolve);\n+            resolving = unresolved;\n+            unresolved = new ArrayList<>();\n+        }\n+    }\n+\n+    Type makeType(jdk.internal.jextract.clang.Type t) {\n+        Type rv = typeCache.get(t);\n+        if (rv != null) {\n+            return rv;\n+        }\n+        rv = makeTypeInternal(t);\n+        if (null != rv && typeCache.put(t, rv) != null) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return rv;\n+    }\n+\n+    \/\/ TODO: this is used by Layouts\n+    public static class TypeException extends RuntimeException {\n+        static final long serialVersionUID = 1L;\n+\n+        public TypeException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    Type makeTypeInternal(jdk.internal.jextract.clang.Type t) {\n+        switch(t.kind()) {\n+            case Auto:\n+                return makeType(t.canonicalType());\n+            case Void:\n+                return Type.void_();\n+            case Char_S:\n+            case Char_U:\n+                return Type.primitive(Primitive.Kind.Char);\n+            case Short:\n+                return Type.primitive(Primitive.Kind.Short);\n+            case Int:\n+                return Type.primitive(Primitive.Kind.Int);\n+            case Long:\n+                return Type.primitive(Primitive.Kind.Long);\n+            case LongLong:\n+                return Type.primitive(Primitive.Kind.LongLong);\n+            case SChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.SIGNED, chType);\n+            }\n+            case UShort: {\n+                Type chType = Type.primitive(Primitive.Kind.Short);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UInt: {\n+                Type chType = Type.primitive(Primitive.Kind.Int);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULong: {\n+                Type chType = Type.primitive(Primitive.Kind.Long);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULongLong: {\n+                Type chType = Type.primitive(Primitive.Kind.LongLong);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+\n+            case Bool:\n+                return Type.primitive(Primitive.Kind.Bool);\n+            case Double:\n+                return Type.primitive(Primitive.Kind.Double);\n+            case Float:\n+                return Type.primitive(Primitive.Kind.Float);\n+            case Unexposed:\n+            case Elaborated:\n+                jdk.internal.jextract.clang.Type canonical = t.canonicalType();\n+                if (canonical.equalType(t)) {\n+                    throw new TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                }\n+                return makeType(canonical);\n+            case ConstantArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(t.getNumberOfElements(), elem);\n+            }\n+            case IncompleteArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(elem);\n+            }\n+            case FunctionProto:\n+            case FunctionNoProto: {\n+                List<Type> args = new ArrayList<>();\n+                for (int i = 0; i < t.numberOfArgs(); i++) {\n+                    \/\/ argument could be function pointer declared locally\n+                    args.add(lowerFunctionType(t.argType(i)));\n+                }\n+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n+            }\n+            case Enum:\n+            case Record: {\n+                if (treeMaker == null) {\n+                    \/\/ Macro evaluation, type is meaningless as this can only be pointer and we only care value\n+                    return Type.void_();\n+                }\n+                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));\n+            }\n+            case BlockPointer:\n+            case Pointer: {\n+                \/\/ TODO: We can always erase type for macro evaluation, should we?\n+                return new TypeImpl.PointerImpl(reference(t.getPointeeType()));\n+            }\n+            case Typedef: {\n+                Type __type = makeType(t.canonicalType());\n+                return Type.typedef(t.spelling(), __type);\n+            }\n+            case Complex: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.qualified(Delegated.Kind.COMPLEX, __type);\n+            }\n+            case Vector: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.vector(t.getNumberOfElements(), __type);\n+            }\n+            case WChar: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.WChar);\n+            case Char16: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Char16);\n+            case Half: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.HalfFloat);\n+            case Int128: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Int128);\n+            case LongDouble: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.LongDouble);\n+            case UInt128: { \/\/unsupported\n+                Type iType = Type.primitive(Primitive.Kind.Int128);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, iType);\n+            }\n+            default:\n+                return TypeImpl.ERROR;\n+        }\n+    }\n+\n+    private Type lowerFunctionType(jdk.internal.jextract.clang.Type t) {\n+        Type t2 = makeType(t);\n+        return t2.accept(lowerFunctionType, null);\n+    }\n+\n+    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n+        @Override\n+        public Type visitArray(Type.Array t, Void aVoid) {\n+            return Type.pointer(t.elementType());\n+        }\n+\n+        @Override\n+        public Type visitDelegated(Type.Delegated t, Void aVoid) {\n+            if (t.kind() == Delegated.Kind.TYPEDEF && t.type() instanceof Type.Array) {\n+                return visitArray((Type.Array)t.type(), aVoid);\n+            }\n+            return visitType(t, aVoid);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void aVoid) {\n+            return t;\n+        }\n+    };\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/parser\/TypeMaker.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/resources\/Messages.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/Messages.properties","status":"renamed"},{"patch":"","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/resources\/RuntimeHelper.java.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.util;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/util\/Filter.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Filter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -7,1 +7,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n@@ -23,1 +25,1 @@\n-package jdk.internal.jextract.impl;\n+package jdk.internal.jextract.util;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/util\/Options.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Options.java","status":"renamed"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.util;\n+\n+import java.lang.constant.Constable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+\n+public class PrettyPrinter implements Declaration.Visitor<Void, Void> {\n+\n+    int align = 0;\n+\n+    void incr() {\n+        align += 4;\n+    }\n+\n+    void decr() {\n+        align -= 4;\n+    }\n+\n+    void indent() {\n+        builder.append(\"                                                                                           \".substring(0, align));\n+    }\n+\n+    StringBuilder builder = new StringBuilder();\n+\n+    private void getAttributes(Declaration decl) {\n+        Set<String> attrs = decl.attributeNames();\n+        if (attrs.isEmpty()) {\n+            return;\n+        }\n+        incr();\n+        indent();\n+        for (String k: attrs) {\n+            builder.append(\"Attr: \");\n+            builder.append(k);\n+            builder.append(\" -> [\");\n+            builder.append(decl.getAttribute(k).get().stream()\n+                .map(Constable::toString)\n+                .collect(Collectors.joining(\", \")));\n+            builder.append(\"]\\n\");\n+        }\n+        decr();\n+    }\n+\n+    public String print(Declaration decl) {\n+        decl.accept(this, null);\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Void aVoid) {\n+        indent();\n+        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + d.layout().map(l -> \" layout = \" + l).orElse(\"\"));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.members().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Void aVoid) {\n+        indent();\n+        builder.append(\"Function: \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.parameters().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Void aVoid) {\n+        indent();\n+        builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null) + \", layout = \" + d.layout());\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Void aVoid) {\n+        indent();\n+        builder.append(\"Constant: \" + d.name() + \" \" + d.value() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef d, Void aVoid) {\n+        indent();\n+        builder.append(\"Typedef: \").append(d.name()).append(\" = \")\n+               .append(d.type().accept(typeVisitor, null)).append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    private static Type.Visitor<String, Void> typeVisitor = new Type.Visitor<>() {\n+        @Override\n+        public String visitPrimitive(Type.Primitive t, Void aVoid) {\n+            return t.kind().toString() + t.kind().layout().map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n+        }\n+\n+        @Override\n+        public String visitDelegated(Type.Delegated t, Void aVoid) {\n+            switch (t.kind()) {\n+                case TYPEDEF:\n+                    return \"typedef \" + t.name() + \" = \" + t.type().accept(this, null);\n+                case POINTER:\n+                    return \"(\" + t.type().accept(this, null) + \")*\";\n+                default:\n+                    return t.kind() + \" = \" + t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public String visitFunction(Type.Function t, Void aVoid) {\n+            String res = t.returnType().accept(this, null);\n+            String args = t.argumentTypes().stream()\n+                    .map(a -> a.accept(this, null))\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            return res + args;\n+        }\n+\n+        @Override\n+        public String visitDeclared(Type.Declared t, Void aVoid) {\n+            return \"Declared(\" + t.tree().layout().map(MemoryLayout::toString).orElse(\"\") + \")\";\n+        }\n+\n+        @Override\n+        public String visitArray(Type.Array t, Void aVoid) {\n+            String brackets = String.format(\"%s[%s]\", t.kind() == Type.Array.Kind.VECTOR ? \"v\" : \"\",\n+                    t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n+            return t.elementType().accept(this, null) + brackets;\n+        }\n+\n+        @Override\n+        public String visitType(Type t, Void aVoid) {\n+            return \"Unknown type: \" + t.getClass().getName();\n+        }\n+    };\n+\n+    public static String type(Type type) {\n+        return type.accept(typeVisitor, null);\n+    }\n+\n+    public static String position(Position pos) {\n+        return String.format(\"%s:%d:%d\",\n+                pos.path() == null ? \"N\/A\" : pos.path().toString(),\n+                pos.line(), pos.col());\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/util\/PrettyPrinter.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"}]}