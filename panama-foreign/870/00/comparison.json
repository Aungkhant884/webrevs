{"files":[{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public long alloc_calloc_arena() {\n+        CallocArena arena = new CallocArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    @Benchmark\n+    public long alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    public static class CallocArena implements Arena {\n+\n+        static final MethodHandle CALLOC = Linker.nativeLinker()\n+                .downcallHandle(\n+                        Linker.nativeLinker().defaultLookup().find(\"calloc\").get(),\n+                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+\n+        static MemorySegment calloc(long size) {\n+            try {\n+                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n+            } catch (Throwable ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return calloc(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n+            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n+            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}