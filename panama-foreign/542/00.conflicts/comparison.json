{"files":[{"patch":"@@ -59,0 +59,5 @@\n+<<<<<<< HEAD\n+=======\n+import jdk.internal.module.IllegalAccessLogger;\n+import jdk.internal.module.IllegalNativeAccessChecker;\n+>>>>>>> 0e1678d5d0bbb3f0010b07f46eb8d6e5841ddb79\n@@ -112,0 +117,2 @@\n+    \/\/ is this module a native module\n+    private volatile boolean enableNativeAccess = false;\n@@ -136,0 +143,4 @@\n+        if (loader == null || loader == ClassLoaders.platformClassLoader()) {\n+            \/\/ boot\/builtin modules are always native\n+            addEnableNativeAccess();\n+        }\n@@ -138,1 +149,0 @@\n-\n@@ -151,1 +161,0 @@\n-\n@@ -247,0 +256,14 @@\n+    boolean isEnableNativeAccess() {\n+        if (enableNativeAccess) {\n+            return true;\n+        }\n+\n+        \/\/ lazy init for unnamed modules\n+        if (!isNamed() && IllegalNativeAccessChecker.enableNativeAccessAllUnnamedModules()) {\n+            enableNativeAccess = true;\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n@@ -412,0 +435,5 @@\n+    Module addEnableNativeAccess() {\n+        enableNativeAccess = true;\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -267,1 +267,2 @@\n-        Modules.defineModule(null, base.descriptor(), baseUri);\n+        SharedSecrets.getJavaLangAccess()\n+                .addEnableNativeAccess(Modules.defineModule(null, base.descriptor(), baseUri));\n@@ -458,0 +459,15 @@\n+<<<<<<< HEAD\n+=======\n+        if (illegalAccess != null) {\n+            assert systemModules != null;\n+            addIllegalAccess(illegalAccess,\n+                             systemModules,\n+                             upgradeModulePath,\n+                             bootLayer,\n+                             extraExportsOrOpens);\n+        }\n+\n+        \/\/ add enable native access\n+        addEnableNativeAccess(bootLayer);\n+\n+>>>>>>> 0e1678d5d0bbb3f0010b07f46eb8d6e5841ddb79\n@@ -770,0 +786,108 @@\n+<<<<<<< HEAD\n+=======\n+     * Process the --illegal-access option to open packages of system modules\n+     * in the boot layer to code in unnamed modules.\n+     *\/\n+    private static void addIllegalAccess(String illegalAccess,\n+                                         SystemModules systemModules,\n+                                         ModuleFinder upgradeModulePath,\n+                                         ModuleLayer bootLayer,\n+                                         boolean extraExportsOrOpens) {\n+\n+        if (illegalAccess.equals(\"deny\"))\n+            return;  \/\/ nothing to do\n+\n+        IllegalAccessLogger.Mode mode = switch (illegalAccess) {\n+            case \"permit\" -> IllegalAccessLogger.Mode.ONESHOT;\n+            case \"warn\"   -> IllegalAccessLogger.Mode.WARN;\n+            case \"debug\"  -> IllegalAccessLogger.Mode.DEBUG;\n+            default -> {\n+                fail(\"Value specified to --illegal-access not recognized:\"\n+                        + \" '\" + illegalAccess + \"'\");\n+                yield null;\n+            }\n+        };\n+\n+        var builder = new IllegalAccessLogger.Builder(mode, System.err);\n+        Map<String, Set<String>> concealedPackagesToOpen = systemModules.concealedPackagesToOpen();\n+        Map<String, Set<String>> exportedPackagesToOpen = systemModules.exportedPackagesToOpen();\n+        if (concealedPackagesToOpen.isEmpty() && exportedPackagesToOpen.isEmpty()) {\n+            \/\/ need to generate (exploded build)\n+            IllegalAccessMaps maps = IllegalAccessMaps.generate(limitedFinder());\n+            concealedPackagesToOpen = maps.concealedPackagesToOpen();\n+            exportedPackagesToOpen = maps.exportedPackagesToOpen();\n+        }\n+\n+        \/\/ open specific packages in the system modules\n+        Set<String> emptySet = Set.of();\n+        for (Module m : bootLayer.modules()) {\n+            ModuleDescriptor descriptor = m.getDescriptor();\n+            String name = m.getName();\n+\n+            \/\/ skip open modules\n+            if (descriptor.isOpen()) {\n+                continue;\n+            }\n+\n+            \/\/ skip modules loaded from the upgrade module path\n+            if (upgradeModulePath != null\n+                && upgradeModulePath.find(name).isPresent()) {\n+                continue;\n+            }\n+\n+            Set<String> concealedPackages = concealedPackagesToOpen.getOrDefault(name, emptySet);\n+            Set<String> exportedPackages = exportedPackagesToOpen.getOrDefault(name, emptySet);\n+\n+            \/\/ refresh the set of concealed and exported packages if needed\n+            if (extraExportsOrOpens) {\n+                concealedPackages = new HashSet<>(concealedPackages);\n+                exportedPackages = new HashSet<>(exportedPackages);\n+                Iterator<String> iterator = concealedPackages.iterator();\n+                while (iterator.hasNext()) {\n+                    String pn = iterator.next();\n+                    if (m.isExported(pn, BootLoader.getUnnamedModule())) {\n+                        \/\/ concealed package is exported to ALL-UNNAMED\n+                        iterator.remove();\n+                        exportedPackages.add(pn);\n+                    }\n+                }\n+                iterator = exportedPackages.iterator();\n+                while (iterator.hasNext()) {\n+                    String pn = iterator.next();\n+                    if (m.isOpen(pn, BootLoader.getUnnamedModule())) {\n+                        \/\/ exported package is opened to ALL-UNNAMED\n+                        iterator.remove();\n+                    }\n+                }\n+            }\n+\n+            \/\/ log reflective access to all types in concealed packages\n+            builder.logAccessToConcealedPackages(m, concealedPackages);\n+\n+            \/\/ log reflective access to non-public members\/types in exported packages\n+            builder.logAccessToExportedPackages(m, exportedPackages);\n+\n+            \/\/ open the packages to unnamed modules\n+            JLA.addOpensToAllUnnamed(m, concealedPackages, exportedPackages);\n+        }\n+\n+        builder.complete();\n+    }\n+\n+    private static void addEnableNativeAccess(ModuleLayer layer) {\n+        \/\/ add native modules explicitly provided on the command line\n+\n+        JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+        for (String name : IllegalNativeAccessChecker.enableNativeAccessModules()) {\n+            Optional<Module> module = layer.findModule(name);\n+            if (module.isPresent()) {\n+                jla.addEnableNativeAccess(module.get());\n+            } else {\n+                \/\/ silently skip.\n+                \/\/ warnUnknownModule(ENABLE_NATIVE_ACCESS, name);\n+            }\n+        }\n+    }\n+\n+    \/**\n+>>>>>>> 0e1678d5d0bbb3f0010b07f46eb8d6e5841ddb79\n@@ -892,1 +1016,1 @@\n-\n+    private static final String ENABLE_NATIVE_ACCESS = \"--enable-native-access\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":126,"deletions":2,"binary":false,"changes":128,"status":"modified"}]}