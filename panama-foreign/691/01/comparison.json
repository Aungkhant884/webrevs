{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -43,0 +44,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -51,0 +53,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -53,0 +56,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -473,0 +478,6 @@\n+     * <p>\n+     * This method is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * return MemorySegment.mismatch(this, 0, this.byteSize(),\n+     *                               other, 0, other.byteSize());\n+     * }\n@@ -485,0 +496,2 @@\n+     *\n+     * @see MemorySegment#mismatch(MemorySegment, long, long, MemorySegment, long, long)\n@@ -1969,0 +1982,74 @@\n+\n+    \/**\n+     * Finds and returns the relative offset, in bytes, of the first mismatch between the source and the destination\n+     * segments. More specifically, the bytes at offset {@code srcFromOffset} through {@code srcToOffset - 1} in the\n+     * source segment are compared against the bytes at offset {@code dstFromOffset} through {@code dstToOffset - 1}\n+     * in the destination segment.\n+     * <p>\n+     * If the two segments, over the specified ranges, share a common prefix then the returned offset is the length\n+     * of the common prefix, and it follows that there is a mismatch between the two segments at that relative offset\n+     * within the respective segments. If one segment is a proper prefix of the other, over the specified ranges,\n+     * then the returned offset is the smallest range, and it follows that the relative offset is only\n+     * valid for the segment with the larger range. Otherwise, there is no mismatch and {@code -1} is returned.\n+     *\n+     * @param srcSegment the source segment.\n+     * @param srcFromOffset the offset (inclusive) of the first byte in the source segment to be tested.\n+     * @param srcToOffset the offset (exclusive) of the last byte in the source segment to be tested.\n+     * @param dstSegment the destination segment.\n+     * @param dstFromOffset the offset (inclusive) of the first byte in the destination segment to be tested.\n+     * @param dstToOffset the offset (exclusive) of the last byte in the destination segment to be tested.\n+     * @return the relative offset, in bytes, of the first mismatch between the source and destination segments,\n+     * otherwise -1 if no mismatch.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code srcSegment}.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IndexOutOfBoundsException if {@code srcFromOffset < 0}, {@code srcToOffset < srcFromOffset} or\n+     * {@code srcToOffset > srcSegment.byteSize()}\n+     * @throws IndexOutOfBoundsException if {@code dstFromOffset < 0}, {@code dstToOffset < dstFromOffset} or\n+     * {@code dstToOffset > dstSegment.byteSize()}\n+     *\n+     * @see MemorySegment#mismatch(MemorySegment)\n+     * @see Arrays#mismatch(Object[], int, int, Object[], int, int)\n+     *\/\n+    static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n+                         MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n+        long srcBytes = srcToOffset - srcFromOffset;\n+        long dstBytes = dstToOffset - dstFromOffset;\n+        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n+        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n+        if (dstImpl == srcImpl) {\n+            srcImpl.checkValidState();\n+            return -1;\n+        }\n+\n+        long bytes = Math.min(srcBytes, dstBytes);\n+        long i = 0;\n+        if (bytes > 7) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n+        }\n+        for (; i < bytes; i++) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n+                return i;\n+            }\n+        }\n+        return srcBytes != dstBytes ? bytes : -1;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -155,33 +155,2 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n-        final long thisSize = this.byteSize();\n-        final long thatSize = that.byteSize();\n-        final long length = Math.min(thisSize, thatSize);\n-        this.checkAccess(0, length, true);\n-        that.checkAccess(0, length, true);\n-        if (this == other) {\n-            checkValidState();\n-            return -1;\n-        }\n-\n-        long i = 0;\n-        if (length > 7) {\n-            if (get(JAVA_BYTE, 0) != that.get(JAVA_BYTE, 0)) {\n-                return 0;\n-            }\n-            i = vectorizedMismatchLargeForBytes(sessionImpl(), that.sessionImpl(),\n-                    this.unsafeGetBase(), this.unsafeGetOffset(),\n-                    that.unsafeGetBase(), that.unsafeGetOffset(),\n-                    length);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = length - remaining;\n-        }\n-        for (; i < length; i++) {\n-            if (get(JAVA_BYTE, i) != that.get(JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return thisSize != thatSize ? length : -1;\n+        Objects.requireNonNull(other);\n+        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n@@ -193,1 +162,1 @@\n-    private static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n+    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -39,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -48,2 +48,0 @@\n-    final static VarHandle BYTE_HANDLE = ValueLayout.JAVA_BYTE.varHandle();\n-\n@@ -53,1 +51,1 @@\n-            BYTE_HANDLE.set(segment.asSlice(i), (byte)i);\n+            segment.set(ValueLayout.JAVA_BYTE, i, (byte)i);\n@@ -58,0 +56,30 @@\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcFromOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, -1, 0, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstFromOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, -1, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcToOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, -1, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstToOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, 0, -1);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcLength(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 3, 2, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstLength(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, 3, 2);\n+    }\n+\n@@ -77,0 +105,20 @@\n+    @Test(dataProvider = \"slicesStatic\")\n+    public void testSameValuesStatic(SliceOffsetAndSize ss1, SliceOffsetAndSize ss2) {\n+        out.format(\"testSameValuesStatic s1:%s, s2:%s\\n\", ss1, ss2);\n+        MemorySegment s1 = initializeSegment(ss1.toSlice());\n+        MemorySegment s2 = initializeSegment(ss2.toSlice());\n+\n+        for (long i = ss2.offset ; i < ss2.size ; i++) {\n+            long bytes = i - ss2.offset;\n+            long expected = (bytes == ss1.size) ?\n+                    -1 : Long.min(ss1.size, bytes);\n+            assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss1.endOffset(), ss2.segment, ss2.offset, i), expected);\n+        }\n+        for (long i = ss1.offset ; i < ss1.size ; i++) {\n+            long bytes = i - ss1.offset;\n+            long expected = (bytes == ss2.size) ?\n+                    -1 : Long.min(ss2.size, bytes);\n+            assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss2.endOffset(), ss1.segment, ss1.offset, i), expected);\n+        }\n+    }\n+\n@@ -85,1 +133,1 @@\n-            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n+            s2.set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n@@ -102,0 +150,20 @@\n+    @Test(dataProvider = \"slicesStatic\")\n+    public void testDifferentValuesStatic(SliceOffsetAndSize ss1, SliceOffsetAndSize ss2) {\n+        out.format(\"testDifferentValues s1:%s, s2:%s\\n\", ss1, ss2);\n+\n+        for (long i = ss2.size - 1 ; i >= 0; i--) {\n+            if (i >= ss1.size) continue;\n+            initializeSegment(ss1.toSlice());\n+            initializeSegment(ss2.toSlice());\n+            long expectedMismatchOffset = i;\n+            ss2.toSlice().set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n+\n+            for (long j = expectedMismatchOffset + 1 ; j < ss2.size ; j++) {\n+                assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss1.endOffset(), ss2.segment, ss2.offset, j + ss2.offset), expectedMismatchOffset);\n+            }\n+            for (long j = expectedMismatchOffset + 1 ; j < ss1.size ; j++) {\n+                assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss2.endOffset(), ss1.segment, ss1.offset, j + ss1.offset), expectedMismatchOffset);\n+            }\n+        }\n+    }\n+\n@@ -136,0 +204,1 @@\n+            \/\/ instance\n@@ -139,0 +208,4 @@\n+            \/\/ static\n+            assertEquals(MemorySegment.mismatch(s1, 0, s1.byteSize(), s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s2, 0, s1.byteSize(), s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s1, 0, s1.byteSize(), s2, 0, i), -1);\n@@ -144,1 +217,1 @@\n-            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n+            s2.set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n@@ -224,2 +297,11 @@\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n+    record SliceOffsetAndSize(MemorySegment segment, long offset, long size) {\n+        MemorySegment toSlice() {\n+            return segment.asSlice(offset, size);\n+        }\n+        long endOffset() {\n+            return offset + size;\n+        }\n+    };\n+\n+    @DataProvider(name = \"slicesStatic\")\n+    static Object[][] slicesStatic() {\n@@ -227,3 +309,3 @@\n-        List<MemorySegment> aSlices = new ArrayList<>();\n-        List<MemorySegment> bSlices = new ArrayList<>();\n-        for (List<MemorySegment> slices : List.of(aSlices, bSlices)) {\n+        List<SliceOffsetAndSize> aSliceOffsetAndSizes = new ArrayList<>();\n+        List<SliceOffsetAndSize> bSliceOffsetAndSizes = new ArrayList<>();\n+        for (List<SliceOffsetAndSize> slices : List.of(aSliceOffsetAndSizes, bSliceOffsetAndSizes)) {\n@@ -235,2 +317,1 @@\n-                        MemorySegment slice = segment.asSlice(index, size);\n-                        slices.add(slice);\n+                        slices.add(new SliceOffsetAndSize(segment, index, size));\n@@ -241,5 +322,5 @@\n-        assert aSlices.size() == bSlices.size();\n-        Object[][] sliceArray = new Object[aSlices.size() * bSlices.size()][];\n-        for (int i = 0 ; i < aSlices.size() ; i++) {\n-            for (int j = 0 ; j < bSlices.size() ; j++) {\n-                sliceArray[i * aSlices.size() + j] = new Object[] { aSlices.get(i), bSlices.get(j) };\n+        assert aSliceOffsetAndSizes.size() == bSliceOffsetAndSizes.size();\n+        Object[][] sliceArray = new Object[aSliceOffsetAndSizes.size() * bSliceOffsetAndSizes.size()][];\n+        for (int i = 0 ; i < aSliceOffsetAndSizes.size() ; i++) {\n+            for (int j = 0 ; j < bSliceOffsetAndSizes.size() ; j++) {\n+                sliceArray[i * aSliceOffsetAndSizes.size() + j] = new Object[] { aSliceOffsetAndSizes.get(i), bSliceOffsetAndSizes.get(j) };\n@@ -250,0 +331,10 @@\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] slices() {\n+        Object[][] slicesStatic = slicesStatic();\n+        return Stream.of(slicesStatic)\n+                .map(arr -> new Object[]{\n+                        ((SliceOffsetAndSize) arr[0]).toSlice(),\n+                        ((SliceOffsetAndSize) arr[1]).toSlice()\n+                }).toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":109,"deletions":18,"binary":false,"changes":127,"status":"modified"}]}