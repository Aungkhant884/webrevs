{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -480,4 +481,2 @@\n-     * long length = Math.min(this.byteSize(), that.byteSize());\n-     * long mismatchOffset = MemorySegment.mismatch(this, 0, other, 0, length);\n-     * return (mismatchOffset == -1 && this.byteSize() != that.byteSize()) ?\n-     *             length : mismatchOffset;\n+     * return MemorySegment.mismatch(this, 0, this.byteSize(),\n+     *                               other, 0, other.byteSize());\n@@ -498,1 +497,1 @@\n-     * @see MemorySegment#mismatch(MemorySegment, long, MemorySegment, long, long)\n+     * @see MemorySegment#mismatch(MemorySegment, long, long, MemorySegment, long, long)\n@@ -1986,2 +1985,2 @@\n-     * segments. More specifically, the bytes at offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the\n-     * source segment are compared against the bytes at offset {@code dstOffset} through {@code dstOffset + bytes - 1}\n+     * segments. More specifically, the bytes at offset {@code srcFromOffset} through {@code srcToOffset - 1} in the\n+     * source segment are compared against the bytes at offset {@code dstFromOffset} through {@code dstToOffset - 1}\n@@ -1990,3 +1989,5 @@\n-     * If a mismatch is detected, the returned offset is relative to the {@linkplain #address() base address} of each\n-     * segment and will be in the range of 0 (inclusive) up to the {@code length}. Otherwise, there is no mismatch and\n-     * {@code -1} is returned.\n+     * If the two segments, over the specified ranges, share a common prefix then the returned offset is the length\n+     * of the common prefix, and it follows that there is a mismatch between the two segments at that relative offset\n+     * within the respective segments. If one segment is a proper prefix of the other, over the specified ranges,\n+     * then the returned offset is the smallest range, and it follows that the relative offset is only\n+     * valid for the segment with the larger range. Otherwise, there is no mismatch and {@code -1} is returned.\n@@ -1995,1 +1996,2 @@\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param srcFromOffset the offset (inclusive) of the first byte in the source segment to be tested.\n+     * @param srcToOffset the offset (exclusive) of the last byte in the source segment to be tested.\n@@ -1997,2 +1999,2 @@\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param bytes the number of bytes to be compared.\n+     * @param dstFromOffset the offset (inclusive) of the first byte in the destination segment to be tested.\n+     * @param dstToOffset the offset (exclusive) of the last byte in the destination segment to be tested.\n@@ -2009,3 +2011,4 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n-     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n-     * or {@code bytes} are {@code < 0}.\n+     * @throws IndexOutOfBoundsException if {@code srcFromOffset < 0}, {@code srcToOffset < srcFromOffset} or\n+     * {@code srcToOffset > srcSegment.byteSize()}\n+     * @throws IndexOutOfBoundsException if {@code dstFromOffset < 0}, {@code dstToOffset < dstFromOffset} or\n+     * {@code dstToOffset > dstSegment.byteSize()}\n@@ -2014,0 +2017,1 @@\n+     * @see Arrays#mismatch(Object[], int, int, Object[], int, int)\n@@ -2015,1 +2019,2 @@\n-    static long mismatch(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+    static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n+                         MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n@@ -2018,2 +2023,4 @@\n-        srcImpl.checkAccess(srcOffset, bytes, true);\n-        dstImpl.checkAccess(dstOffset, bytes, true);\n+        long srcBytes = srcToOffset - srcFromOffset;\n+        long dstBytes = dstToOffset - dstFromOffset;\n+        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n+        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n@@ -2025,0 +2032,1 @@\n+        long bytes = Math.min(srcBytes, dstBytes);\n@@ -2027,1 +2035,1 @@\n-            if (srcImpl.get(JAVA_BYTE, srcOffset) != dstImpl.get(JAVA_BYTE, dstOffset)) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n@@ -2031,2 +2039,2 @@\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n@@ -2042,1 +2050,1 @@\n-            if (srcImpl.get(JAVA_BYTE, srcOffset + i) != dstImpl.get(JAVA_BYTE, dstOffset + i)) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n@@ -2046,1 +2054,1 @@\n-        return -1;\n+        return srcBytes != dstBytes ? bytes : -1;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -156,6 +156,1 @@\n-        long thisSize = byteSize();\n-        long thatSize = other.byteSize();\n-        long length = Math.min(thisSize, thatSize);\n-        long mismatch = MemorySegment.mismatch(this, 0, other, 0, length);\n-        return (mismatch == -1 && thisSize != thatSize) ?\n-            length : mismatch;\n+        return MemorySegment.mismatch(this, 0, byteSize(), other, 0, other.byteSize());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-    public void testNegativeSrcOffset(MemorySegment s1, MemorySegment s2) {\n-        MemorySegment.mismatch(s1, -1, s2, 0, 0);\n+    public void testNegativeSrcFromOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, -1, 0, s2, 0, 0);\n@@ -62,2 +62,2 @@\n-    public void testNegativeDstOffset(MemorySegment s1, MemorySegment s2) {\n-        MemorySegment.mismatch(s1, 0, s2, -1, 0);\n+    public void testNegativeDstFromOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, -1, 0);\n@@ -67,2 +67,17 @@\n-    public void testNegativeLength(MemorySegment s1, MemorySegment s2) {\n-        MemorySegment.mismatch(s1, 0, s2, 0, -1);\n+    public void testNegativeSrcToOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, -1, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstToOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, 0, -1);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcLength(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 3, 2, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstLength(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, 0, s2, 3, 2);\n@@ -95,1 +110,0 @@\n-        long length = Math.min(s1.byteSize(), s2.byteSize());\n@@ -97,3 +111,11 @@\n-        for (int i = 0 ; i < length ; i++) {\n-            assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss2.segment, ss2.offset, i), -1);\n-            assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss1.segment, ss1.offset, i), -1);\n+        for (long i = ss2.offset ; i < ss2.size ; i++) {\n+            long bytes = i - ss2.offset;\n+            long expected = (bytes == ss1.size) ?\n+                    -1 : Long.min(ss1.size, bytes);\n+            assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss1.endOffset(), ss2.segment, ss2.offset, i), expected);\n+        }\n+        for (long i = ss1.offset ; i < ss1.size ; i++) {\n+            long bytes = i - ss1.offset;\n+            long expected = (bytes == ss2.size) ?\n+                    -1 : Long.min(ss2.size, bytes);\n+            assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss2.endOffset(), ss1.segment, ss1.offset, i), expected);\n@@ -131,1 +153,0 @@\n-        long length = Math.min(ss1.size(), ss2.size());\n@@ -134,0 +155,1 @@\n+            if (i >= ss1.size) continue;\n@@ -139,3 +161,5 @@\n-            for (long j = expectedMismatchOffset + 1 ; j < length ; j++) {\n-                assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss2.segment, ss2.offset, j), expectedMismatchOffset);\n-                assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss1.segment, ss1.offset, j), expectedMismatchOffset);\n+            for (long j = expectedMismatchOffset + 1 ; j < ss2.size ; j++) {\n+                assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss1.endOffset(), ss2.segment, ss2.offset, j + ss2.offset), expectedMismatchOffset);\n+            }\n+            for (long j = expectedMismatchOffset + 1 ; j < ss1.size ; j++) {\n+                assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss2.endOffset(), ss1.segment, ss1.offset, j + ss1.offset), expectedMismatchOffset);\n@@ -185,3 +209,3 @@\n-            assertEquals(MemorySegment.mismatch(s1, 0, s1, 0, i), -1);\n-            assertEquals(MemorySegment.mismatch(s2, 0, s1, 0, i), -1);\n-            assertEquals(MemorySegment.mismatch(s1, 0, s2, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s1, 0, s1.byteSize(), s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s2, 0, s1.byteSize(), s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s1, 0, s1.byteSize(), s2, 0, i), -1);\n@@ -277,0 +301,3 @@\n+        long endOffset() {\n+            return offset + size;\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":44,"deletions":17,"binary":false,"changes":61,"status":"modified"}]}