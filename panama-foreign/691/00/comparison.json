{"files":[{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -51,0 +52,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -53,0 +55,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -473,0 +477,8 @@\n+     * <p>\n+     * This method is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * long length = Math.min(this.byteSize(), that.byteSize());\n+     * long mismatchOffset = MemorySegment.mismatch(this, 0, other, 0, length);\n+     * return (mismatchOffset == -1 && this.byteSize() != that.byteSize()) ?\n+     *             length : mismatchOffset;\n+     * }\n@@ -485,0 +497,2 @@\n+     *\n+     * @see MemorySegment#mismatch(MemorySegment, long, MemorySegment, long, long)\n@@ -1969,0 +1983,65 @@\n+\n+    \/**\n+     * Finds and returns the relative offset, in bytes, of the first mismatch between the source and the destination\n+     * segments. More specifically, the bytes at offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the\n+     * source segment are compared against the bytes at offset {@code dstOffset} through {@code dstOffset + bytes - 1}\n+     * in the destination segment.\n+     * <p>\n+     * If a mismatch is detected, the returned offset is relative to the {@linkplain #address() base address} of each\n+     * segment and will be in the range of 0 (inclusive) up to the {@code length}. Otherwise, there is no mismatch and\n+     * {@code -1} is returned.\n+     *\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be compared.\n+     * @return the relative offset, in bytes, of the first mismatch between the source and destination segments,\n+     * otherwise -1 if no mismatch.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code srcSegment}.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     *\n+     * @see MemorySegment#mismatch(MemorySegment)\n+     *\/\n+    static long mismatch(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n+        srcImpl.checkAccess(srcOffset, bytes, true);\n+        dstImpl.checkAccess(dstOffset, bytes, true);\n+        if (dstImpl == srcImpl) {\n+            srcImpl.checkValidState();\n+            return -1;\n+        }\n+\n+        long i = 0;\n+        if (bytes > 7) {\n+            if (srcImpl.get(JAVA_BYTE, srcOffset) != dstImpl.get(JAVA_BYTE, dstOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n+        }\n+        for (; i < bytes; i++) {\n+            if (srcImpl.get(JAVA_BYTE, srcOffset + i) != dstImpl.get(JAVA_BYTE, dstOffset + i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -155,33 +155,7 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n-        final long thisSize = this.byteSize();\n-        final long thatSize = that.byteSize();\n-        final long length = Math.min(thisSize, thatSize);\n-        this.checkAccess(0, length, true);\n-        that.checkAccess(0, length, true);\n-        if (this == other) {\n-            checkValidState();\n-            return -1;\n-        }\n-\n-        long i = 0;\n-        if (length > 7) {\n-            if (get(JAVA_BYTE, 0) != that.get(JAVA_BYTE, 0)) {\n-                return 0;\n-            }\n-            i = vectorizedMismatchLargeForBytes(sessionImpl(), that.sessionImpl(),\n-                    this.unsafeGetBase(), this.unsafeGetOffset(),\n-                    that.unsafeGetBase(), that.unsafeGetOffset(),\n-                    length);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = length - remaining;\n-        }\n-        for (; i < length; i++) {\n-            if (get(JAVA_BYTE, i) != that.get(JAVA_BYTE, i)) {\n-                return i;\n-            }\n-        }\n-        return thisSize != thatSize ? length : -1;\n+        Objects.requireNonNull(other);\n+        long thisSize = byteSize();\n+        long thatSize = other.byteSize();\n+        long length = Math.min(thisSize, thatSize);\n+        long mismatch = MemorySegment.mismatch(this, 0, other, 0, length);\n+        return (mismatch == -1 && thisSize != thatSize) ?\n+            length : mismatch;\n@@ -193,1 +167,1 @@\n-    private static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n+    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":8,"deletions":34,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -39,0 +38,1 @@\n+import java.util.stream.Stream;\n@@ -48,2 +48,0 @@\n-    final static VarHandle BYTE_HANDLE = ValueLayout.JAVA_BYTE.varHandle();\n-\n@@ -53,1 +51,1 @@\n-            BYTE_HANDLE.set(segment.asSlice(i), (byte)i);\n+            segment.set(ValueLayout.JAVA_BYTE, i, (byte)i);\n@@ -58,0 +56,15 @@\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeSrcOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, -1, s2, 0, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeDstOffset(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, s2, -1, 0);\n+    }\n+\n+    @Test(dataProvider = \"slices\", expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testNegativeLength(MemorySegment s1, MemorySegment s2) {\n+        MemorySegment.mismatch(s1, 0, s2, 0, -1);\n+    }\n+\n@@ -77,0 +90,13 @@\n+    @Test(dataProvider = \"slicesStatic\")\n+    public void testSameValuesStatic(SliceOffsetAndSize ss1, SliceOffsetAndSize ss2) {\n+        out.format(\"testSameValuesStatic s1:%s, s2:%s\\n\", ss1, ss2);\n+        MemorySegment s1 = initializeSegment(ss1.toSlice());\n+        MemorySegment s2 = initializeSegment(ss2.toSlice());\n+        long length = Math.min(s1.byteSize(), s2.byteSize());\n+\n+        for (int i = 0 ; i < length ; i++) {\n+            assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss2.segment, ss2.offset, i), -1);\n+            assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss1.segment, ss1.offset, i), -1);\n+        }\n+    }\n+\n@@ -85,1 +111,1 @@\n-            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n+            s2.set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n@@ -102,0 +128,18 @@\n+    @Test(dataProvider = \"slicesStatic\")\n+    public void testDifferentValuesStatic(SliceOffsetAndSize ss1, SliceOffsetAndSize ss2) {\n+        out.format(\"testDifferentValues s1:%s, s2:%s\\n\", ss1, ss2);\n+        long length = Math.min(ss1.size(), ss2.size());\n+\n+        for (long i = ss2.size - 1 ; i >= 0; i--) {\n+            initializeSegment(ss1.toSlice());\n+            initializeSegment(ss2.toSlice());\n+            long expectedMismatchOffset = i;\n+            ss2.toSlice().set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n+\n+            for (long j = expectedMismatchOffset + 1 ; j < length ; j++) {\n+                assertEquals(MemorySegment.mismatch(ss1.segment, ss1.offset, ss2.segment, ss2.offset, j), expectedMismatchOffset);\n+                assertEquals(MemorySegment.mismatch(ss2.segment, ss2.offset, ss1.segment, ss1.offset, j), expectedMismatchOffset);\n+            }\n+        }\n+    }\n+\n@@ -136,0 +180,1 @@\n+            \/\/ instance\n@@ -139,0 +184,4 @@\n+            \/\/ static\n+            assertEquals(MemorySegment.mismatch(s1, 0, s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s2, 0, s1, 0, i), -1);\n+            assertEquals(MemorySegment.mismatch(s1, 0, s2, 0, i), -1);\n@@ -144,1 +193,1 @@\n-            BYTE_HANDLE.set(s2.asSlice(i), (byte) 0xFF);\n+            s2.set(ValueLayout.JAVA_BYTE, i, (byte) 0xFF);\n@@ -224,2 +273,8 @@\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n+    record SliceOffsetAndSize(MemorySegment segment, long offset, long size) {\n+        MemorySegment toSlice() {\n+            return segment.asSlice(offset, size);\n+        }\n+    };\n+\n+    @DataProvider(name = \"slicesStatic\")\n+    static Object[][] slicesStatic() {\n@@ -227,3 +282,3 @@\n-        List<MemorySegment> aSlices = new ArrayList<>();\n-        List<MemorySegment> bSlices = new ArrayList<>();\n-        for (List<MemorySegment> slices : List.of(aSlices, bSlices)) {\n+        List<SliceOffsetAndSize> aSliceOffsetAndSizes = new ArrayList<>();\n+        List<SliceOffsetAndSize> bSliceOffsetAndSizes = new ArrayList<>();\n+        for (List<SliceOffsetAndSize> slices : List.of(aSliceOffsetAndSizes, bSliceOffsetAndSizes)) {\n@@ -235,2 +290,1 @@\n-                        MemorySegment slice = segment.asSlice(index, size);\n-                        slices.add(slice);\n+                        slices.add(new SliceOffsetAndSize(segment, index, size));\n@@ -241,5 +295,5 @@\n-        assert aSlices.size() == bSlices.size();\n-        Object[][] sliceArray = new Object[aSlices.size() * bSlices.size()][];\n-        for (int i = 0 ; i < aSlices.size() ; i++) {\n-            for (int j = 0 ; j < bSlices.size() ; j++) {\n-                sliceArray[i * aSlices.size() + j] = new Object[] { aSlices.get(i), bSlices.get(j) };\n+        assert aSliceOffsetAndSizes.size() == bSliceOffsetAndSizes.size();\n+        Object[][] sliceArray = new Object[aSliceOffsetAndSizes.size() * bSliceOffsetAndSizes.size()][];\n+        for (int i = 0 ; i < aSliceOffsetAndSizes.size() ; i++) {\n+            for (int j = 0 ; j < bSliceOffsetAndSizes.size() ; j++) {\n+                sliceArray[i * aSliceOffsetAndSizes.size() + j] = new Object[] { aSliceOffsetAndSizes.get(i), bSliceOffsetAndSizes.get(j) };\n@@ -250,0 +304,10 @@\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] slices() {\n+        Object[][] slicesStatic = slicesStatic();\n+        return Stream.of(slicesStatic)\n+                .map(arr -> new Object[]{\n+                        ((SliceOffsetAndSize) arr[0]).toSlice(),\n+                        ((SliceOffsetAndSize) arr[1]).toSlice()\n+                }).toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":82,"deletions":18,"binary":false,"changes":100,"status":"modified"}]}