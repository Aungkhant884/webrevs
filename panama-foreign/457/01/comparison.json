{"files":[{"patch":"@@ -87,0 +87,5 @@\n+\n+const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+  ShouldNotCallThis();\n+  return {};\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -365,0 +365,10 @@\n+JavaFrameAnchor* EntryBlob::jfa_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+frame frame::sender_for_panama_entry_frame(RegisterMap* map) const {\n+  ShouldNotCallThis();\n+  return {};\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -961,1 +961,1 @@\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -980,1 +980,1 @@\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1004,1 +1004,1 @@\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,9 @@\n+\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n+  return false;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,0 +90,29 @@\n+\n+const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+  oop conv_oop = JNIHandles::resolve_non_null(jconv);\n+  objArrayOop arg_regs_oop = cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.arg_regs_offset));\n+  objArrayOop ret_regs_oop = cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.ret_regs_offset));\n+\n+  CallRegs result;\n+  result._args_length = arg_regs_oop->length();\n+  result._arg_regs = NEW_RESOURCE_ARRAY(VMReg, result._args_length);\n+\n+  result._rets_length = ret_regs_oop->length();\n+  result._ret_regs = NEW_RESOURCE_ARRAY(VMReg, result._rets_length);\n+\n+  for (int i = 0; i < result._args_length; i++) {\n+    oop storage = arg_regs_oop->obj_at(i);\n+    jint index = storage->int_field(VMS.index_offset);\n+    jint type = storage->int_field(VMS.type_offset);\n+    result._arg_regs[i] = VMRegImpl::vmStorageToVMReg(type, index);\n+  }\n+\n+  for (int i = 0; i < result._rets_length; i++) {\n+    oop storage = ret_regs_oop->obj_at(i);\n+    jint index = storage->int_field(VMS.index_offset);\n+    jint type = storage->int_field(VMS.type_offset);\n+    result._ret_regs[i] = VMRegImpl::vmStorageToVMReg(type, index);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -104,0 +104,2 @@\n+    } else if (is_panama_entry_frame()) {\n+      return fp_safe;\n@@ -201,0 +203,2 @@\n+    } else if (sender_blob->is_entry_blob()) {\n+      return false;\n@@ -355,0 +359,30 @@\n+JavaFrameAnchor* EntryBlob::jfa_for_frame(const frame& frame) const {\n+  \/\/ need unextended_sp here, since normal sp is wrong for interpreter callees\n+  return reinterpret_cast<JavaFrameAnchor*>(reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(jfa_sp_offset()));\n+}\n+\n+frame frame::sender_for_panama_entry_frame(RegisterMap* map) const {\n+  assert(map != NULL, \"map must be set\");\n+  EntryBlob* blob = _cb->as_entry_blob();\n+  \/\/ Java frame called from C; skip all C frames and return top C\n+  \/\/ frame of that chunk as the sender\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  assert(jfa->last_Java_sp() > sp(), \"must be above this frame on stack\");\n+  \/\/ Since we are walking the stack now this nested anchor is obviously walkable\n+  \/\/ even if it wasn't when it was stacked.\n+  if (!jfa->walkable()) {\n+    \/\/ Capture _last_Java_pc (if needed) and mark anchor walkable.\n+    jfa->capture_last_Java_pc();\n+  }\n+  map->clear();\n+  assert(map->include_argument_oops(), \"should be set by clear\");\n+  vmassert(jfa->last_Java_pc() != NULL, \"not walkable\");\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_fp(), jfa->last_Java_pc());\n+\n+  if (map->update_map() && jfa->saved_rbp_address()) {\n+    update_map_with_saved_link(map, jfa->saved_rbp_address());\n+  }\n+\n+  return fr;\n+}\n+\n@@ -484,2 +518,3 @@\n-  if (is_entry_frame())       return sender_for_entry_frame(map);\n-  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n+  if (is_entry_frame())        return sender_for_entry_frame(map);\n+  if (is_panama_entry_frame()) return sender_for_panama_entry_frame(map);\n+  if (is_interpreted_frame())  return sender_for_interpreter_frame(map);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -81,2 +81,0 @@\n-private:\n-\n","filename":"src\/hotspot\/cpu\/x86\/javaFrameAnchor_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1141,1 +1141,1 @@\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1259,1 +1259,1 @@\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1288,1 +1288,1 @@\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1313,1 +1313,1 @@\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1422,1 +1422,1 @@\n-  move32_64(masm, tmp, length_arg);\n+  SharedRuntime::move32_64(masm, tmp, length_arg);\n@@ -1428,1 +1428,1 @@\n-  move32_64(masm, tmp, length_arg);\n+  SharedRuntime::move32_64(masm, tmp, length_arg);\n@@ -1515,2 +1515,2 @@\n-  ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n-                    BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n+                  const BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n@@ -4018,0 +4018,10 @@\n+\n+void SharedRuntime::compute_move_order(const BasicType* in_sig_bt,\n+                                       int total_in_args, const VMRegPair* in_regs,\n+                                       int total_out_args, VMRegPair* out_regs,\n+                                       GrowableArray<int>& arg_order,\n+                                       VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder order(total_in_args, in_regs,\n+                         total_out_args, out_regs,\n+                         in_sig_bt, arg_order, tmp_vmreg);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -29,0 +33,2 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -144,0 +150,680 @@\n+\n+struct ArgMove {\n+  BasicType bt;\n+  VMRegPair from;\n+  VMRegPair to;\n+\n+  bool is_identity() const {\n+      return from.first() == to.first() && from.second() == to.second();\n+  }\n+};\n+\n+static GrowableArray<ArgMove> compute_argument_shuffle(Method* entry, int& out_arg_size_bytes, const CallRegs& conv, BasicType& ret_type) {\n+  assert(entry->is_static(), \"\");\n+\n+  \/\/ Fill in the signature array, for the calling-convention call.\n+  const int total_out_args = entry->size_of_parameters();\n+  assert(total_out_args > 0, \"receiver arg \");\n+\n+  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n+  VMRegPair* out_regs = NEW_RESOURCE_ARRAY(VMRegPair, total_out_args);\n+\n+  {\n+    int i = 0;\n+    SignatureStream ss(entry->signature());\n+    for (; !ss.at_return_type(); ss.next()) {\n+      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n+        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+    }\n+    assert(i == total_out_args, \"\");\n+    ret_type = ss.type();\n+  }\n+\n+  int out_arg_slots = SharedRuntime::java_calling_convention(out_sig_bt, out_regs, total_out_args);\n+\n+  const int total_in_args = total_out_args - 1; \/\/ skip receiver\n+  BasicType* in_sig_bt  = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n+  VMRegPair* in_regs    = NEW_RESOURCE_ARRAY(VMRegPair, total_in_args);\n+\n+  for (int i = 0; i < total_in_args ; i++ ) {\n+    in_sig_bt[i] = out_sig_bt[i+1]; \/\/ skip receiver\n+  }\n+\n+  \/\/ Now figure out where the args must be stored and how much stack space they require.\n+  conv.calling_convention(in_sig_bt, in_regs, total_in_args);\n+\n+  GrowableArray<int> arg_order(2 * total_in_args);\n+\n+  VMRegPair tmp_vmreg;\n+  tmp_vmreg.set2(rbx->as_VMReg());\n+\n+  \/\/ Compute a valid move order, using tmp_vmreg to break any cycles\n+  SharedRuntime::compute_move_order(in_sig_bt,\n+                                    total_in_args, in_regs,\n+                                    total_out_args, out_regs,\n+                                    arg_order,\n+                                    tmp_vmreg);\n+\n+  GrowableArray<ArgMove> arg_order_vmreg(total_in_args); \/\/ conservative\n+\n+#ifdef ASSERT\n+  bool reg_destroyed[RegisterImpl::number_of_registers];\n+  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n+  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+    reg_destroyed[r] = false;\n+  }\n+  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n+    freg_destroyed[f] = false;\n+  }\n+#endif \/\/ ASSERT\n+\n+  for (int i = 0; i < arg_order.length(); i += 2) {\n+    int in_arg  = arg_order.at(i);\n+    int out_arg = arg_order.at(i + 1);\n+\n+    assert(in_arg != -1 || out_arg != -1, \"\");\n+    BasicType arg_bt = (in_arg != -1 ? in_sig_bt[in_arg] : out_sig_bt[out_arg]);\n+    switch (arg_bt) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+      case T_FLOAT:\n+        break; \/\/ process\n+\n+      case T_LONG:\n+      case T_DOUBLE:\n+        assert(in_arg  == -1 || (in_arg  + 1 < total_in_args  &&  in_sig_bt[in_arg  + 1] == T_VOID), \"bad arg list: %d\", in_arg);\n+        assert(out_arg == -1 || (out_arg + 1 < total_out_args && out_sig_bt[out_arg + 1] == T_VOID), \"bad arg list: %d\", out_arg);\n+        break; \/\/ process\n+\n+      case T_VOID:\n+        continue; \/\/ skip\n+\n+      default:\n+        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+    }\n+\n+    ArgMove move;\n+    move.bt   = arg_bt;\n+    move.from = (in_arg != -1 ? in_regs[in_arg] : tmp_vmreg);\n+    move.to   = (out_arg != -1 ? out_regs[out_arg] : tmp_vmreg);\n+\n+    if(move.is_identity()) {\n+      continue; \/\/ useless move\n+    }\n+\n+#ifdef ASSERT\n+    if (in_arg != -1) {\n+      if (in_regs[in_arg].first()->is_Register()) {\n+        assert(!reg_destroyed[in_regs[in_arg].first()->as_Register()->encoding()], \"destroyed reg!\");\n+      } else if (in_regs[in_arg].first()->is_XMMRegister()) {\n+        assert(!freg_destroyed[in_regs[in_arg].first()->as_XMMRegister()->encoding()], \"destroyed reg!\");\n+      }\n+    }\n+    if (out_arg != -1) {\n+      if (out_regs[out_arg].first()->is_Register()) {\n+        reg_destroyed[out_regs[out_arg].first()->as_Register()->encoding()] = true;\n+      } else if (out_regs[out_arg].first()->is_XMMRegister()) {\n+        freg_destroyed[out_regs[out_arg].first()->as_XMMRegister()->encoding()] = true;\n+      }\n+    }\n+#endif \/* ASSERT *\/\n+\n+    arg_order_vmreg.push(move);\n+  }\n+\n+  int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;\n+  out_arg_size_bytes = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+\n+  return arg_order_vmreg;\n+}\n+\n+static const char* null_safe_string(const char* str) {\n+  return str == nullptr ? \"NULL\" : str;\n+}\n+\n+#ifdef ASSERT\n+static void print_arg_moves(const GrowableArray<ArgMove>& arg_moves, Method* entry) {\n+  LogTarget(Trace, panama) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print_cr(\"Argument shuffle for %s {\", entry->name_and_sig_as_C_string());\n+    for (int i = 0; i < arg_moves.length(); i++) {\n+      ArgMove arg_mv = arg_moves.at(i);\n+      BasicType arg_bt     = arg_mv.bt;\n+      VMRegPair from_vmreg = arg_mv.from;\n+      VMRegPair to_vmreg   = arg_mv.to;\n+\n+      ls.print(\"Move a %s from (\", null_safe_string(type2name(arg_bt)));\n+      from_vmreg.first()->print_on(&ls);\n+      ls.print(\",\");\n+      from_vmreg.second()->print_on(&ls);\n+      ls.print(\") to \");\n+      to_vmreg.first()->print_on(&ls);\n+      ls.print(\",\");\n+      to_vmreg.second()->print_on(&ls);\n+      ls.print_cr(\")\");\n+    }\n+    ls.print_cr(\"}\");\n+  }\n+}\n+#endif\n+\n+void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n+  __ block_comment(\"{ save_java_frame_anchor \");\n+  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n+\n+  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(thread, JavaThread::saved_rbp_address_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::saved_rbp_address_offset()), rscratch1);\n+\n+  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n+  __ block_comment(\"} save_java_frame_anchor \");\n+}\n+\n+void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n+  __ block_comment(\"{ restore_java_frame_anchor \");\n+  \/\/ thread->_last_Java_sp = NULL\n+  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n+\n+  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n+  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+\n+  \/\/_thread->frame_anchor()->copy(&_anchor);\n+\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n+\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n+\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::saved_rbp_address_offset()));\n+  __ movptr(Address(thread, JavaThread::saved_rbp_address_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n+  __ block_comment(\"} restore_java_frame_anchor \");\n+}\n+\n+static void save_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n+  __ block_comment(\"{ save_native_args \");\n+  int store_offset = arg_save_area_offset;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, store_offset), reg->as_Register());\n+      store_offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, store_offset), reg->as_XMMRegister());\n+      store_offset += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  __ block_comment(\"} save_native_args \");\n+}\n+\n+static void restore_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n+  __ block_comment(\"{ restore_native_args \");\n+  int load_offset = arg_save_area_offset;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, load_offset));\n+      load_offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, load_offset));\n+      load_offset += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  __ block_comment(\"} restore_native_args \");\n+}\n+\n+static bool is_valid_XMM(XMMRegister reg) {\n+  return reg->is_valid() && (UseAVX >= 3 || (reg->encoding() < 16)); \/\/ why is this not covered by is_valid()?\n+}\n+\n+\/\/ for callee saved regs, according to the caller's ABI\n+static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n+  int size = 0;\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        size += 64; \/\/ bytes\n+      } else if (UseAVX >= 1) {\n+        size += 32;\n+      } else {\n+        size += 16;\n+      }\n+    }\n+  }\n+\n+  return size;\n+}\n+\n+static int compute_arg_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  return result_size;\n+}\n+\n+static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to save it here\n+  \/\/ 2. save mxcsr (?)\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ preserve_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(Address(rsp, offset), reg);\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(Address(rsp, offset), reg, Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(Address(rsp, offset), reg);\n+        offset += 32;\n+      } else {\n+        __ movdqu(Address(rsp, offset), reg);\n+        offset += 16;\n+      }\n+    }\n+  }\n+  __ block_comment(\"} preserve_callee_saved_regs \");\n+\n+  \/\/ TODO mxcsr\n+}\n+\n+static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to restore it here\n+  \/\/ 2. restore mxcsr (?)\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ restore_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(reg, Address(rsp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(reg, Address(rsp, offset), Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(reg, Address(rsp, offset));\n+        offset += 32;\n+      } else {\n+        __ movdqu(reg, Address(rsp, offset));\n+        offset += 16;\n+      }\n+    }\n+  }\n+\n+  __ block_comment(\"} restore_callee_saved_regs \");\n+\n+  \/\/ TODO mxcsr\n+}\n+\n+static void shuffle_arguments(MacroAssembler* _masm, const GrowableArray<ArgMove>& arg_moves) {\n+  for (int i = 0; i < arg_moves.length(); i++) {\n+    ArgMove arg_mv = arg_moves.at(i);\n+    BasicType arg_bt     = arg_mv.bt;\n+    VMRegPair from_vmreg = arg_mv.from;\n+    VMRegPair to_vmreg   = arg_mv.to;\n+\n+    assert(\n+      !((from_vmreg.first()->is_Register() && to_vmreg.first()->is_XMMRegister())\n+      || (from_vmreg.first()->is_XMMRegister() && to_vmreg.first()->is_Register())),\n+       \"move between gp and fp reg not supported\");\n+\n+    __ block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n+    switch (arg_bt) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+       SharedRuntime::move32_64(_masm, from_vmreg, to_vmreg);\n+       break;\n+\n+      case T_FLOAT:\n+        SharedRuntime::float_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      case T_DOUBLE:\n+        SharedRuntime::double_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      case T_LONG :\n+        SharedRuntime::long_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      default:\n+        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+    }\n+  }\n+}\n+\n+struct AuxiliarySaves {\n+  JavaFrameAnchor jfa;\n+  uintptr_t thread;\n+  bool should_detach;\n+};\n+\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry, jobject jabi, jobject jconv) {\n+  ResourceMark rm;\n+  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n+  const CallRegs conv = ForeignGlobals::parse_call_regs(jconv);\n+  assert(conv._rets_length <= 1, \"no multi reg returns\");\n+  CodeBuffer buffer(\"upcall_stub_linkToNative\", \/* code_size = *\/ 1024, \/* locs_size = *\/ 1024);\n+\n+  int register_size = sizeof(uintptr_t);\n+  int buffer_alignment = xmm_reg_size;\n+\n+  int out_arg_area = -1;\n+  BasicType ret_type;\n+  GrowableArray<ArgMove> arg_moves = compute_argument_shuffle(entry, out_arg_area, conv, ret_type);\n+  assert(out_arg_area != -1, \"Should have been set\");\n+  DEBUG_ONLY(print_arg_moves(arg_moves, entry);)\n+\n+  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n+  \/\/ make sure it is big enough.\n+  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n+    out_arg_area = frame::arg_reg_save_area_bytes;\n+  }\n+\n+  int reg_save_area_size = compute_reg_save_area_size(abi);\n+  int arg_save_area_size = compute_arg_save_area_size(conv);\n+  \/\/ To spill receiver during deopt\n+  int deopt_spill_size = 1 * BytesPerWord;\n+\n+  int shuffle_area_offset    = 0;\n+  int deopt_spill_offset     = shuffle_area_offset    + out_arg_area;\n+  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_save_area_size;\n+  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n+\n+  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n+  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n+  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+\n+  int frame_size = frame_bottom_offset;\n+  frame_size = align_up(frame_size, StackAlignmentInBytes);\n+\n+  \/\/ Ok The space we have allocated will look like:\n+  \/\/\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      |                     |\n+  \/\/      | AuxiliarySaves      |\n+  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      |                     |\n+  \/\/      | reg_save_area       |\n+  \/\/      |---------------------| = reg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | arg_save_area       |\n+  \/\/      |---------------------| = arg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | deopt_spill         |\n+  \/\/      |---------------------| = deopt_spill_offset\n+  \/\/      |                     |\n+  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n+  \/\/\n+  \/\/\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+  Label call_return;\n+  address start = __ pc();\n+  __ enter(); \/\/ set up frame\n+  if ((abi._stack_alignment_bytes % 16) != 0) {\n+    \/\/ stack alignment of caller is not a multiple of 16\n+    __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack\n+  }\n+  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n+  __ subptr(rsp, frame_size);\n+\n+  \/\/ we have to always spill args since we need to do a call to get the thread\n+  \/\/ (and maybe attach it).\n+  save_native_arguments(_masm, conv, arg_save_area_offset);\n+\n+  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ block_comment(\"{ get_thread\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ movptr(r15_thread, rax);\n+  __ reinit_heapbase();\n+  __ movptr(Address(rsp, thread_offset), r15_thread);\n+  __ block_comment(\"} get_thread\");\n+\n+  \/\/ TODO:\n+  \/\/ We expect not to be coming from JNI code, but we might be.\n+  \/\/ We should figure out what our stance is on supporting that and then maybe add\n+  \/\/ some more handling here for:\n+  \/\/   - handle blocks\n+  \/\/   - check for active exceptions (and emit an error)\n+\n+  __ block_comment(\"{ safepoint poll\");\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n+\n+  if (os::is_MP()) {\n+    __ membar(Assembler::Membar_mask_bits(\n+                Assembler::LoadLoad  | Assembler::StoreLoad |\n+                Assembler::LoadStore | Assembler::StoreStore));\n+   }\n+\n+  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  Label L_after_safepoint_poll;\n+  Label L_safepoint_poll_slow_path;\n+\n+  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n+  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n+\n+  __ bind(L_after_safepoint_poll);\n+  __ block_comment(\"} safepoint poll\");\n+  \/\/ change thread state\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n+\n+  __ block_comment(\"{ reguard stack check\");\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n+  __ jcc(Assembler::equal, L_reguard);\n+  __ bind(L_after_reguard);\n+  __ block_comment(\"} reguard stack check\");\n+\n+  __ block_comment(\"{ argument shuffle\");\n+  \/\/ TODO merge these somehow\n+  restore_native_arguments(_masm, conv, arg_save_area_offset);\n+  shuffle_arguments(_masm, arg_moves);\n+  __ block_comment(\"} argument shuffle\");\n+\n+  __ block_comment(\"{ receiver \");\n+  __ movptr(rscratch1, (intptr_t)receiver);\n+  __ resolve_jobject(rscratch1, r15_thread, rscratch2);\n+  __ movptr(j_rarg0, rscratch1);\n+  __ block_comment(\"} receiver \");\n+\n+  __ mov_metadata(rbx, entry);\n+  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n+  __ reinit_heapbase();\n+\n+  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n+  __ reset_last_Java_frame(r15_thread, true);\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+#ifdef ASSERT\n+  if (conv._rets_length == 1) { \/\/ 0 or 1\n+    VMReg j_expected_result_reg;\n+    switch (ret_type) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+      case T_LONG:\n+       j_expected_result_reg = rax->as_VMReg();\n+       break;\n+      case T_FLOAT:\n+      case T_DOUBLE:\n+        j_expected_result_reg = xmm0->as_VMReg();\n+        break;\n+      default:\n+        fatal(\"unexpected return type: %s\", type2name(ret_type));\n+    }\n+    \/\/ No need to move for now, since CallArranger can pick a return type\n+    \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+    assert(conv._ret_regs[0] == j_expected_result_reg,\n+     \"unexpected result register: %s != %s\", conv._ret_regs[0]->name(), j_expected_result_reg->name());\n+  }\n+#endif\n+\n+  __ bind(call_return);\n+\n+  \/\/ also sets last Java frame\n+  __ movptr(r15_thread, Address(rsp, thread_offset));\n+  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n+  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n+\n+  __ block_comment(\"{ maybe_detach_thread\");\n+  Label L_after_detach;\n+  __ cmpb(Address(rsp, should_detach_offset), 0);\n+  __ jcc(Assembler::equal, L_after_detach);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, r15_thread);\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n+  __ reinit_heapbase();\n+  __ bind(L_after_detach);\n+  __ block_comment(\"} maybe_detach_thread\");\n+\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+  __ bind(L_safepoint_poll_slow_path);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, r15_thread);\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+  __ reinit_heapbase();\n+  __ jmp(L_after_safepoint_poll);\n+  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_reguard\");\n+  __ bind(L_reguard);\n+  __ vzeroupper();\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n+  __ reinit_heapbase();\n+  __ jmp(L_after_reguard);\n+  __ block_comment(\"} L_reguard\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ exception handler\");\n+\n+  intptr_t exception_handler_offset = __ pc() - start;\n+\n+  \/\/ TODO: this is always the same, can we bypass and call handle_uncaught_exception directly?\n+\n+  \/\/ native caller has no idea how to handle exceptions\n+  \/\/ we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(rax);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, rax);\n+  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n+  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows (not really needed)\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::handle_uncaught_exception)));\n+  __ should_not_reach_here();\n+\n+  __ block_comment(\"} exception handler\");\n+\n+  _masm->flush();\n+\n+\n+#ifndef PRODUCT\n+  stringStream ss;\n+  ss.print(\"panama_upcall_stub_%s\", entry->signature()->as_C_string());\n+  const char* name = _masm->code_string(ss.as_string());\n+#else \/\/ PRODUCT\n+  const char* name = \"panama_upcall_stub\";\n+#endif \/\/ PRODUCT\n+\n+  EntryBlob* blob = EntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+\n+  if (TracePanamaUpcallStubs) {\n+    blob->print_on(tty);\n+    Disassembler::decode(blob, tty);\n+  }\n+\n+  return blob->code_begin();\n+}\n+\n+bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":686,"deletions":0,"binary":false,"changes":686,"status":"modified"},{"patch":"@@ -711,0 +711,27 @@\n+\n+\/\/ Implementation of EntryBlob\n+\n+EntryBlob::EntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                     jobject receiver, ByteSize jfa_sp_offset) :\n+  BufferBlob(name, size, cb),\n+  _exception_handler_offset(exception_handler_offset),\n+  _receiver(receiver),\n+  _jfa_sp_offset(jfa_sp_offset) {\n+  CodeCache::commit(this);\n+}\n+\n+EntryBlob* EntryBlob::create(const char* name, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                             jobject receiver, ByteSize jfa_sp_offset) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  EntryBlob* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(EntryBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) EntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+\/\/    EntryBlob          : Used for upcalls from native code\n@@ -85,0 +86,2 @@\n+class EntryBlob; \/\/ for as_entry_blob()\n+class JavaFrameAnchor; \/\/ for EntryBlob::jfa_for_frame\n@@ -147,0 +150,1 @@\n+  virtual bool is_entry_blob() const                  { return false; }\n@@ -160,0 +164,1 @@\n+  EntryBlob* as_entry_blob() const             { assert(is_entry_blob(), \"must be entry blob\"); return (EntryBlob*) this; }\n@@ -391,0 +396,1 @@\n+  friend class EntryBlob;\n@@ -730,0 +736,29 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\n+\/\/ For Panama upcall stubs\n+class EntryBlob: public BufferBlob {\n+ private:\n+  intptr_t _exception_handler_offset;\n+  jobject _receiver;\n+  ByteSize _jfa_sp_offset;\n+\n+  EntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+            jobject receiver, ByteSize jfa_sp_offset);\n+\n+ public:\n+  \/\/ Creation\n+  static EntryBlob* create(const char* name, CodeBuffer* cb,\n+                           intptr_t exception_handler_offset, jobject receiver,\n+                           ByteSize jfa_sp_offset);\n+\n+  address exception_handler() { return code_begin() + _exception_handler_offset; }\n+  jobject receiver() { return _receiver; }\n+  ByteSize jfa_sp_offset() const { return _jfa_sp_offset; }\n+\n+  \/\/ defined in frame_ARCH.cpp\n+  JavaFrameAnchor* jfa_for_frame(const frame& frame) const;\n+\n+  \/\/ Typing\n+  virtual bool is_entry_blob() const override { return true; }\n+};\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  DEBUG_ONLY(LOG_TAG(panama)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,0 +62,4 @@\n+const CallRegs ForeignGlobals::parse_call_regs(jobject jconv) {\n+  return instance().parse_call_regs_impl(jconv);\n+}\n+\n@@ -68,5 +72,5 @@\n-  const char* strVMSArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n-  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray, (int)strlen(strVMSArray));\n-  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArray);\n-  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArray);\n-  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArray);\n+  const char* strVMSArrayArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n+  Symbol* symVMSArrayArray = SymbolTable::new_symbol(strVMSArrayArray);\n+  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArrayArray);\n+  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArrayArray);\n+  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArrayArray);\n@@ -79,0 +83,1 @@\n+  VMS.type_offset = field_offset(k_VMS, \"type\", vmSymbols::int_signature());\n@@ -88,0 +93,37 @@\n+\n+  \/\/ CallRegs\n+  const char* strVMSArray = \"[L\" FOREIGN_ABI \"VMStorage;\";\n+  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray);\n+  InstanceKlass* k_CC = find_InstanceKlass(FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs\", current_thread);\n+  CallConvOffsets.arg_regs_offset = field_offset(k_CC, \"argRegs\", symVMSArray);\n+  CallConvOffsets.ret_regs_offset = field_offset(k_CC, \"retRegs\", symVMSArray);\n+}\n+\n+void CallRegs::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n+  int src_pos = 0;\n+  for (uint i = 0; i < argcnt; i++) {\n+    switch (sig_bt[i]) {\n+      case T_BOOLEAN:\n+      case T_CHAR:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT:\n+      case T_FLOAT:\n+        assert(src_pos < _args_length, \"oob\");\n+        parm_regs[i].set1(_arg_regs[src_pos++]);\n+        break;\n+      case T_LONG:\n+      case T_DOUBLE:\n+        assert((i + 1) < argcnt && sig_bt[i + 1] == T_VOID, \"expecting half\");\n+        assert(src_pos < _args_length, \"oob\");\n+        parm_regs[i].set2(_arg_regs[src_pos++]);\n+        break;\n+      case T_VOID: \/\/ Halves of longs and doubles\n+        assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n+        parm_regs[i].set_bad();\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+        break;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -33,0 +33,10 @@\n+struct CallRegs {\n+  VMReg* _arg_regs;\n+  int _args_length;\n+\n+  VMReg* _ret_regs;\n+  int _rets_length;\n+\n+  void calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const;\n+};\n+\n@@ -45,0 +55,1 @@\n+    int type_offset;\n@@ -56,0 +67,5 @@\n+  struct {\n+    int arg_regs_offset;\n+    int ret_regs_offset;\n+  } CallConvOffsets;\n+\n@@ -68,0 +84,1 @@\n+  const CallRegs parse_call_regs_impl(jobject jconv) const;\n@@ -71,0 +88,1 @@\n+  static const CallRegs parse_call_regs(jobject jconv);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-JNI_LEAF(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))\n+JNI_ENTRY(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-JNI_LEAF(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))\n+JNI_ENTRY(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -52,1 +53,1 @@\n-void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n+Thread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n@@ -54,1 +55,0 @@\n-  bool should_detach = false;\n@@ -60,1 +60,1 @@\n-    should_detach = true;\n+    *should_detach = true;\n@@ -62,0 +62,2 @@\n+  } else {\n+    *should_detach = false;\n@@ -63,0 +65,11 @@\n+  return thread;\n+}\n+\n+void ProgrammableUpcallHandler::detach_thread(Thread* thread) {\n+  JavaVM_ *vm = (JavaVM *)(&main_vm);\n+  vm->functions->DetachCurrentThread(vm);\n+}\n+\n+void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n+  bool should_detach = false;\n+  Thread* thread = maybe_attach_and_get_thread(&should_detach);\n@@ -67,2 +80,1 @@\n-    JavaVM_ *vm = (JavaVM *)(&main_vm);\n-    vm->functions->DetachCurrentThread(vm);\n+    detach_thread(thread);\n@@ -80,1 +92,1 @@\n-  Symbol* sym = SymbolTable::new_symbol(FOREIGN_ABI \"ProgrammableUpcallHandler\");\n+  Symbol* sym = SymbolTable::new_symbol(FOREIGN_ABI \"ProgrammableUpcallHandler$InterpretedHandler\");\n@@ -86,1 +98,1 @@\n-  upcall_method.sig = SymbolTable::new_symbol(\"(L\" FOREIGN_ABI \"ProgrammableUpcallHandler;J)V\");\n+  upcall_method.sig = SymbolTable::new_symbol(\"(L\" FOREIGN_ABI \"ProgrammableUpcallHandler$InterpretedHandler;J)V\");\n@@ -93,1 +105,8 @@\n-JNI_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jobject rec, jobject abi, jobject buffer_layout))\n+void ProgrammableUpcallHandler::handle_uncaught_exception(oop exception) {\n+  \/\/ Based on CATCH macro\n+  tty->print_cr(\"Uncaught exception:\");\n+  exception->print();\n+  ShouldNotReachHere();\n+}\n+\n+JVM_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jclass unused, jobject rec, jobject abi, jobject buffer_layout))\n@@ -99,0 +118,19 @@\n+JVM_ENTRY(jlong, PUH_AllocateOptimzedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv))\n+  Handle mh_h(THREAD, JNIHandles::resolve(mh));\n+  jobject mh_j = JNIHandles::make_global(mh_h);\n+\n+  oop lform = java_lang_invoke_MethodHandle::form(mh_h());\n+  oop vmentry = java_lang_invoke_LambdaForm::vmentry(lform);\n+  Method* entry = java_lang_invoke_MemberName::vmtarget(vmentry);\n+  const methodHandle mh_entry(THREAD, entry);\n+\n+  assert(entry->method_holder()->is_initialized(), \"no clinit barrier\");\n+  CompilationPolicy::compile_if_required(mh_entry, CHECK_0);\n+\n+  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(mh_j, entry, abi, conv);\n+JVM_END\n+\n+JVM_ENTRY(jboolean, PUH_SupportsOptimzedUpcalls(JNIEnv *env, jclass unused))\n+  return (jboolean) ProgrammableUpcallHandler::supports_optimized_upcalls();\n+JVM_END\n+\n@@ -103,1 +141,3 @@\n-  {CC \"allocateUpcallStub\", CC \"(L\" FOREIGN_ABI \"ABIDescriptor;L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n+  {CC \"allocateUpcallStub\", CC \"(\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$InterpretedHandler;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n+  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \")J\", FN_PTR(PUH_AllocateOptimzedUpcallStub)},\n+  {CC \"supportsOptimizedUpcalls\", CC \"()Z\", FN_PTR(PUH_SupportsOptimzedUpcalls)},\n@@ -109,1 +149,2 @@\n-JNI_LEAF(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n+JNI_ENTRY(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":51,"deletions":10,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+\n+  static void handle_uncaught_exception(oop exception);\n+  static Thread* maybe_attach_and_get_thread(bool* should_detach);\n+  static void detach_thread(Thread* thread);\n@@ -49,0 +53,1 @@\n+  static address generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv);\n@@ -50,0 +55,1 @@\n+  static bool supports_optimized_upcalls();\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,2 +38,8 @@\n-  jobject* rec_ptr = (jobject*)(void*)cb -> content_begin();\n-  JNIHandles::destroy_global(*rec_ptr);\n+  jobject handle = NULL;\n+  if (cb->is_entry_blob()) {\n+    handle = ((EntryBlob*)cb)->receiver();\n+  } else {\n+    jobject* handle_ptr = (jobject*)(void*)cb->content_begin();\n+    handle = *handle_ptr;\n+  }\n+  JNIHandles::destroy_global(handle);\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1072,0 +1072,4 @@\n+  } else if (is_panama_entry_frame()) {\n+   \/\/ Nothing to do\n+   \/\/ receiver is a global ref\n+   \/\/ handle block is for JNI\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  bool is_panama_entry_frame()         const;\n@@ -174,0 +175,1 @@\n+  frame sender_for_panama_entry_frame(RegisterMap* map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,4 @@\n+inline bool frame::is_panama_entry_frame() const {\n+  return _cb != NULL && _cb->is_entry_blob();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2083,0 +2083,3 @@\n+                                                                            \\\n+  develop(bool, TracePanamaUpcallStubs, false,                              \\\n+                \"Trace Panama upcall stub generation\")                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -514,0 +514,3 @@\n+  if (blob != NULL && blob->is_entry_blob()) {\n+    return ((EntryBlob*)blob)->exception_handler();\n+  }\n@@ -1446,1 +1449,1 @@\n-  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame(), \"unexpected frame\");\n+  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame() && !caller_frame.is_panama_entry_frame(), \"unexpected frame\");\n@@ -1478,1 +1481,2 @@\n-      caller_frame.is_entry_frame()) {\n+      caller_frame.is_entry_frame() ||\n+      caller_frame.is_panama_entry_frame()) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -476,0 +476,5 @@\n+  static void   move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void   long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void  float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+\n@@ -525,0 +530,6 @@\n+  static void compute_move_order(const BasicType* in_sig_bt,\n+                                 int total_in_args, const VMRegPair* in_regs,\n+                                 int total_out_args, VMRegPair* out_regs,\n+                                 GrowableArray<int>& arg_order,\n+                                 VMRegPair tmp_vmreg);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1763,0 +1763,5 @@\n+            @Override\n+            public void ensureCustomized(MethodHandle mh) {\n+                mh.customize();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,0 +135,7 @@\n+\n+    \/**\n+     * Ensure given method handle is customized\n+     *\n+     * @param mh the method handle\n+     *\/\n+    void ensureCustomized(MethodHandle mh);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -544,1 +544,4 @@\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);\n+            \/\/ alignment is set to 1 byte here to avoid exceptions for cases where we do super word\n+            \/\/ copies of e.g. 2 int fields of a struct as a single long, while the struct is only\n+            \/\/ 4-byte-aligned (since it only contains ints)\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, 1, ByteOrder.nativeOrder()), 1, offset);\n@@ -925,1 +928,1 @@\n-            specializedHandle = filterArguments(specializedHandle, insertPos, toSegmentHandle);\n+            specializedHandle = collectArguments(specializedHandle, insertPos, toSegmentHandle);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.MemoryAddressImpl;\n@@ -118,1 +119,1 @@\n-    private static void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,\n+    private void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,\n@@ -131,0 +132,8 @@\n+        long stack_ptr = (long) VH_LONG.get(buff.asSlice(stack_args));\n+        long stack_bytes = (long) VH_LONG.get(buff.asSlice(stack_args_bytes));\n+        MemorySegment stackArgs = MemoryAddressImpl.ofLongUnchecked(stack_ptr, stack_bytes);\n+        stream.println(\"Stack {\");\n+        for (int i = 0; i < stack_bytes \/ 8; i += 8) {\n+            stream.printf(\"    @%d: %s%n\", i, getLongString(stackArgs, i));\n+        }\n+        stream.println(\"}\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -47,2 +46,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n@@ -53,1 +50,0 @@\n-import static java.lang.invoke.MethodHandles.empty;\n@@ -57,1 +53,0 @@\n-import static java.lang.invoke.MethodHandles.tryFinally;\n@@ -59,1 +54,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.Allocator.THROWING_ALLOCATOR;\n@@ -82,1 +76,0 @@\n-\n@@ -84,4 +77,0 @@\n-    private static final MethodHandle MH_MAKE_SCOPE;\n-    private static final MethodHandle MH_CLOSE_SCOPE;\n-    private static final MethodHandle MH_WRAP_SCOPE;\n-\n@@ -99,6 +88,0 @@\n-            MH_MAKE_SCOPE = lookup.findStatic(NativeScope.class, \"boundedScope\",\n-                    methodType(NativeScope.class, long.class));\n-            MH_CLOSE_SCOPE = lookup.findVirtual(NativeScope.class, \"close\",\n-                    methodType(void.class));\n-            MH_WRAP_SCOPE = lookup.findStatic(Allocator.class, \"ofScope\",\n-                    methodType(Allocator.class, NativeScope.class));\n@@ -179,2 +162,2 @@\n-            Map<VMStorage, Integer> argIndexMap = indexMap(argMoves);\n-            Map<VMStorage, Integer> retIndexMap = indexMap(retMoves);\n+            Map<VMStorage, Integer> argIndexMap = SharedUtils.indexMap(argMoves);\n+            Map<VMStorage, Integer> retIndexMap = SharedUtils.indexMap(retMoves);\n@@ -260,17 +243,1 @@\n-            \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n-            MethodHandle closer = leafType.returnType() == void.class\n-                  \/\/ (Throwable, Addressable, NativeScope) -> void\n-                ? collectArguments(empty(methodType(void.class, Throwable.class, Addressable.class)), 2, MH_CLOSE_SCOPE)\n-                  \/\/ (Throwable, V, Addressable, NativeScope) -> V\n-                : collectArguments( \/\/ (Throwable, V, Addressable, NativeScope) -> V\n-                    dropArguments( \/\/ (Throwable, V, Addressable) -> V\n-                        dropArguments( \/\/ (Throwable, V) -> V\n-                            identity(specializedHandle.type().returnType()), \/\/ (V) -> V\n-                            0, Throwable.class),\n-                        2, Addressable.class),\n-                                   3, MH_CLOSE_SCOPE);\n-            \/\/ Handle takes a SharedUtils.Allocator, so need to wrap our NativeScope\n-            specializedHandle = filterArguments(specializedHandle, argAllocatorPos, MH_WRAP_SCOPE);\n-            specializedHandle = tryFinally(specializedHandle, closer);\n-            MethodHandle makeScopeHandle = insertArguments(MH_MAKE_SCOPE, 0, bufferCopySize);\n-            specializedHandle = collectArguments(specializedHandle, argAllocatorPos, makeScopeHandle);\n+            specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, false);\n@@ -281,6 +248,0 @@\n-    private static Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n-        return IntStream.range(0, moves.length)\n-                        .boxed()\n-                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n-    }\n-\n@@ -353,4 +314,1 @@\n-        Allocator unboxAllocator = bufferCopySize != 0\n-                ? Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n-                : THROWING_ALLOCATOR;\n-        try (unboxAllocator) {\n+        try (Allocator unboxAllocator = SharedUtils.makeAllocator(bufferCopySize)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":4,"deletions":46,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,1 +35,1 @@\n-import jdk.internal.vm.annotation.Stable;\n+import sun.security.action.GetPropertyAction;\n@@ -37,0 +38,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -40,0 +42,2 @@\n+import java.util.List;\n+import java.util.Map;\n@@ -41,0 +45,1 @@\n+import java.util.stream.Stream;\n@@ -42,0 +47,7 @@\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n+import static java.lang.invoke.MethodHandles.identity;\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.foreign.abi.SharedUtils.mergeArguments;\n@@ -49,2 +61,1 @@\n-public class ProgrammableUpcallHandler implements UpcallHandler {\n-\n+public class ProgrammableUpcallHandler {\n@@ -53,0 +64,6 @@\n+    private static final boolean USE_SPEC = Boolean.parseBoolean(\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC\", \"true\"));\n+    private static final boolean USE_INTRINSICS = Boolean.parseBoolean(\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS\", \"true\"));\n+\n+    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n@@ -56,19 +73,65 @@\n-    @Stable\n-    private final MethodHandle mh;\n-    private final MethodType type;\n-    private final CallingSequence callingSequence;\n-    private final long entryPoint;\n-\n-    private final ABIDescriptor abi;\n-    private final BufferLayout layout;\n-\n-    private final long bufferCopySize;\n-\n-    public ProgrammableUpcallHandler(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n-        this.abi = abi;\n-        this.layout = BufferLayout.of(abi);\n-        this.type = callingSequence.methodType();\n-        this.callingSequence = callingSequence;\n-        this.mh = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n-        this.entryPoint = allocateUpcallStub(abi, layout);\n-        this.bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n+    private static final MethodHandle MH_invokeMoves;\n+    private static final MethodHandle MH_invokeInterpBindings;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = lookup();\n+            MH_invokeMoves = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeMoves\",\n+                    methodType(void.class, MemoryAddress.class, MethodHandle.class,\n+                               Binding.VMLoad[].class, Binding.VMStore[].class, ABIDescriptor.class, BufferLayout.class));\n+            MH_invokeInterpBindings = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeInterpBindings\",\n+                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class,\n+                            CallingSequence.class, long.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public static UpcallHandler make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n+        Binding.VMLoad[] argMoves = argMoveBindings(callingSequence);\n+        Binding.VMStore[] retMoves = retMoveBindings(callingSequence);\n+\n+        boolean isSimple = !(retMoves.length > 1);\n+\n+        Class<?> llReturn = !isSimple\n+            ? Object[].class\n+            : retMoves.length == 1\n+                ? retMoves[0].type()\n+                : void.class;\n+        Class<?>[] llParams = Arrays.stream(argMoves).map(Binding.Move::type).toArray(Class<?>[]::new);\n+        MethodType llType = MethodType.methodType(llReturn, llParams);\n+\n+        MethodHandle doBindings;\n+        long bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n+        if (USE_SPEC && isSimple) {\n+            doBindings = specializedBindingHandle(target, callingSequence, llReturn, bufferCopySize);\n+            assert doBindings.type() == llType;\n+        } else {\n+            Map<VMStorage, Integer> argIndices = SharedUtils.indexMap(argMoves);\n+            Map<VMStorage, Integer> retIndices = SharedUtils.indexMap(retMoves);\n+            target = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n+            doBindings = insertArguments(MH_invokeInterpBindings, 1, target, argIndices, retIndices, callingSequence,\n+                    bufferCopySize);\n+            doBindings = doBindings.asCollector(Object[].class, llType.parameterCount());\n+            doBindings = doBindings.asType(llType);\n+        }\n+\n+        long entryPoint;\n+        boolean usesStackArgs = argMoveBindingsStream(callingSequence)\n+                .map(Binding.VMLoad::storage)\n+                .anyMatch(s -> abi.arch.isStackType(s.type()));\n+        if (USE_INTRINSICS && isSimple && !usesStackArgs && supportsOptimizedUpcalls()) {\n+            checkPrimitive(doBindings.type());\n+            JLI.ensureCustomized(doBindings);\n+            VMStorage[] args = Arrays.stream(argMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+            VMStorage[] rets = Arrays.stream(retMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+            CallRegs conv = new CallRegs(args, rets);\n+            entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv);\n+        } else {\n+            BufferLayout layout = BufferLayout.of(abi);\n+            MethodHandle doBindingsErased = doBindings.asSpreader(Object[].class, doBindings.type().parameterCount());\n+            MethodHandle invokeMoves = insertArguments(MH_invokeMoves, 1, doBindingsErased, argMoves, retMoves, abi, layout);\n+            InterpretedHandler handler = new InterpretedHandler(invokeMoves);\n+            entryPoint = allocateUpcallStub(handler, abi, layout);\n+        }\n+        return () -> entryPoint;\n@@ -77,3 +140,4 @@\n-    @Override\n-    public long entryPoint() {\n-        return entryPoint;\n+    private static void checkPrimitive(MethodType type) {\n+        if (!type.returnType().isPrimitive()\n+                || type.parameterList().stream().anyMatch(p -> !p.isPrimitive()))\n+            throw new IllegalArgumentException(\"MethodHandle type must be primitive: \" + type);\n@@ -82,2 +146,4 @@\n-    public static void invoke(ProgrammableUpcallHandler handler, long address) {\n-        handler.invoke(MemoryAddress.ofLong(address));\n+    private static Stream<Binding.VMLoad> argMoveBindingsStream(CallingSequence callingSequence) {\n+        return callingSequence.argumentBindings()\n+                .filter(Binding.VMLoad.class::isInstance)\n+                .map(Binding.VMLoad.class::cast);\n@@ -86,6 +152,4 @@\n-    private void invoke(MemoryAddress buffer) {\n-        Allocator allocator = bufferCopySize != 0\n-                ? Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n-                : Allocator.empty();\n-        try (allocator) {\n-            MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n+    private static Binding.VMLoad[] argMoveBindings(CallingSequence callingSequence) {\n+        return argMoveBindingsStream(callingSequence)\n+                .toArray(Binding.VMLoad[]::new);\n+    }\n@@ -93,3 +157,40 @@\n-            if (DEBUG) {\n-                System.err.println(\"Buffer state before:\");\n-                layout.dump(abi.arch, bufferBase, System.err);\n+    private static Binding.VMStore[] retMoveBindings(CallingSequence callingSequence) {\n+        return callingSequence.returnBindings().stream()\n+                .filter(Binding.VMStore.class::isInstance)\n+                .map(Binding.VMStore.class::cast)\n+                .toArray(Binding.VMStore[]::new);\n+    }\n+\n+    private static MethodHandle specializedBindingHandle(MethodHandle target, CallingSequence callingSequence,\n+                                                         Class<?> llReturn, long bufferCopySize) {\n+        MethodType highLevelType = callingSequence.methodType();\n+\n+        MethodHandle specializedHandle = target; \/\/ initial\n+\n+        int argAllocatorPos = 0;\n+        int argInsertPos = 1;\n+        specializedHandle = dropArguments(specializedHandle, argAllocatorPos, SharedUtils.Allocator.class);\n+        for (int i = 0; i < highLevelType.parameterCount(); i++) {\n+            MethodHandle filter = identity(highLevelType.parameterType(i));\n+            int filterAllocatorPos = 0;\n+            int filterInsertPos = 1; \/\/ +1 for allocator\n+            filter = dropArguments(filter, filterAllocatorPos, Allocator.class);\n+\n+            List<Binding> bindings = callingSequence.argumentBindings(i);\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                filter = binding.specialize(filter, filterInsertPos, filterAllocatorPos);\n+            }\n+            specializedHandle = MethodHandles.collectArguments(specializedHandle, argInsertPos, filter);\n+            specializedHandle = mergeArguments(specializedHandle, argAllocatorPos, argInsertPos + filterAllocatorPos);\n+            argInsertPos += filter.type().parameterCount() - 1; \/\/ -1 for allocator\n+        }\n+\n+        if (llReturn != void.class) {\n+            int retAllocatorPos = -1; \/\/ assumed not needed\n+            int retInsertPos = 0;\n+            MethodHandle filter = identity(llReturn);\n+            List<Binding> bindings = callingSequence.returnBindings();\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n@@ -97,0 +198,2 @@\n+            specializedHandle = filterReturnValue(specializedHandle, filter);\n+        }\n@@ -98,3 +201,72 @@\n-            MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n-            Object[] args = new Object[type.parameterCount()];\n-            for (int i = 0 ; i < type.parameterCount() ; i++) {\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, true);\n+\n+        return specializedHandle;\n+    }\n+\n+    private static class InterpretedHandler {\n+        private final MethodHandle mh;\n+\n+        InterpretedHandler(MethodHandle mh) {\n+            this.mh = mh;\n+        }\n+\n+        public static void invoke(InterpretedHandler handler, long address) throws Throwable {\n+            handler.mh.invokeExact(MemoryAddress.ofLong(address));\n+        }\n+    }\n+\n+    private static void invokeMoves(MemoryAddress buffer, MethodHandle leaf,\n+                                    Binding.VMLoad[] argBindings, Binding.VMStore[] returnBindings,\n+                                    ABIDescriptor abi, BufferLayout layout) throws Throwable {\n+        MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n+\n+        if (DEBUG) {\n+            System.err.println(\"Buffer state before:\");\n+            layout.dump(abi.arch, bufferBase, System.err);\n+        }\n+\n+        MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n+        Object[] moves = new Object[argBindings.length];\n+        for (int i = 0; i < moves.length; i++) {\n+            Binding.VMLoad binding = argBindings[i];\n+            VMStorage storage = binding.storage();\n+            MemorySegment ptr = abi.arch.isStackType(storage.type())\n+                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n+                : bufferBase.asSlice(layout.argOffset(storage));\n+            moves[i] = SharedUtils.read(ptr, binding.type());\n+        }\n+\n+        \/\/ invokeInterpBindings, and then actual target\n+        Object o = leaf.invoke(moves);\n+\n+        if (o == null) {\n+            \/\/ nop\n+        } else if (o instanceof Object[] returns) {\n+            for (int i = 0; i < returnBindings.length; i++) {\n+                Binding.VMStore binding = returnBindings[i];\n+                VMStorage storage = binding.storage();\n+                MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n+                SharedUtils.writeOverSized(ptr, binding.type(), returns[i]);\n+            }\n+        } else { \/\/ single Object\n+            Binding.VMStore binding = returnBindings[0];\n+            VMStorage storage = binding.storage();\n+            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n+            SharedUtils.writeOverSized(ptr, binding.type(), o);\n+        }\n+\n+        if (DEBUG) {\n+            System.err.println(\"Buffer state after:\");\n+            layout.dump(abi.arch, bufferBase, System.err);\n+        }\n+    }\n+\n+    private static Object invokeInterpBindings(Object[] moves, MethodHandle leaf,\n+                                               Map<VMStorage, Integer> argIndexMap,\n+                                               Map<VMStorage, Integer> retIndexMap,\n+                                               CallingSequence callingSequence,\n+                                               long bufferCopySize) throws Throwable {\n+        try (Allocator allocator = SharedUtils.makeAllocator(bufferCopySize)) {\n+            \/\/\/ Invoke interpreter, got array of high-level arguments back\n+            Object[] args = new Object[callingSequence.methodType().parameterCount()];\n+            for (int i = 0; i < args.length; i++) {\n@@ -102,6 +274,1 @@\n-                        (storage, type) -> {\n-                            MemorySegment ptr = abi.arch.isStackType(storage.type())\n-                                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n-                                : bufferBase.asSlice(layout.argOffset(storage));\n-                            return SharedUtils.read(ptr, type);\n-                        }, allocator);\n+                        (storage, type) -> moves[argIndexMap.get(storage)], allocator);\n@@ -115,1 +282,2 @@\n-            Object o = mh.invoke(args);\n+            \/\/ invoke our target\n+            Object o = leaf.invoke(args);\n@@ -122,1 +290,2 @@\n-            if (mh.type().returnType() != void.class) {\n+            Object[] returnMoves = new Object[retIndexMap.size()];\n+            if (leaf.type().returnType() != void.class) {\n@@ -124,4 +293,1 @@\n-                        (storage, type, value) -> {\n-                            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-                            SharedUtils.writeOverSized(ptr, type, value);\n-                        }, null);\n+                        (storage, type, value) -> returnMoves[retIndexMap.get(storage)] = value, null);\n@@ -130,3 +296,6 @@\n-            if (DEBUG) {\n-                System.err.println(\"Buffer state after:\");\n-                layout.dump(abi.arch, bufferBase, System.err);\n+            if (returnMoves.length == 0) {\n+                return null;\n+            } else if (returnMoves.length == 1) {\n+                return returnMoves[0];\n+            } else {\n+                return returnMoves;\n@@ -134,2 +303,0 @@\n-        } catch (Throwable t) {\n-            throw new IllegalStateException(t);\n@@ -139,1 +306,6 @@\n-    public native long allocateUpcallStub(ABIDescriptor abi, BufferLayout layout);\n+    \/\/ used for transporting data into native code\n+    private static record CallRegs(VMStorage[] argRegs, VMStorage[] retRegs) {}\n+\n+    public static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv);\n+    public static native long allocateUpcallStub(InterpretedHandler handler, ABIDescriptor abi, BufferLayout layout);\n+    public static native boolean supportsOptimizedUpcalls();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":230,"deletions":58,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -53,0 +54,1 @@\n+import java.util.Map;\n@@ -54,0 +56,1 @@\n+import java.util.stream.Collectors;\n@@ -57,0 +60,5 @@\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.dropReturn;\n+import static java.lang.invoke.MethodHandles.empty;\n+import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n@@ -60,0 +68,1 @@\n+import static java.lang.invoke.MethodHandles.tryFinally;\n@@ -68,0 +77,2 @@\n+    private static final MethodHandle MH_MAKE_ALLOCATOR;\n+    private static final MethodHandle MH_CLOSE_ALLOCATOR;\n@@ -80,0 +91,4 @@\n+            MH_MAKE_ALLOCATOR = lookup.findStatic(SharedUtils.class, \"makeAllocator\",\n+                    methodType(Allocator.class, long.class));\n+            MH_CLOSE_ALLOCATOR = lookup.findVirtual(Allocator.class, \"close\",\n+                    methodType(void.class));\n@@ -181,1 +196,1 @@\n-    public static MethodHandle adaptUpcallForIMR(MethodHandle target) {\n+    public static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n@@ -187,0 +202,4 @@\n+        if (dropReturn) { \/\/ no handling for return value, need to drop it\n+            target = dropReturn(target);\n+        }\n+\n@@ -223,9 +242,17 @@\n-    public static Class<?> primitiveCarrierForSize(long size) {\n-        if (size == 1) {\n-            return byte.class;\n-        } else if(size == 2) {\n-            return short.class;\n-        } else if (size <= 4) {\n-            return int.class;\n-        } else if (size <= 8) {\n-            return long.class;\n+    public static Class<?> primitiveCarrierForSize(long size, boolean useFloat) {\n+        if (useFloat) {\n+            if (size == 4) {\n+                return float.class;\n+            } else if (size == 8) {\n+                return double.class;\n+            }\n+        } else {\n+            if (size == 1) {\n+                return byte.class;\n+            } else if (size == 2) {\n+                return short.class;\n+            } else if (size <= 4) {\n+                return int.class;\n+            } else if (size <= 8) {\n+                return long.class;\n+            }\n@@ -234,1 +261,1 @@\n-        throw new IllegalArgumentException(\"Size too large: \" + size);\n+        throw new IllegalArgumentException(\"No type for size: \" + size + \" isFloat=\" + useFloat);\n@@ -285,0 +312,6 @@\n+    static Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n+        return IntStream.range(0, moves.length)\n+                        .boxed()\n+                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n+    }\n+\n@@ -306,0 +339,35 @@\n+    static Allocator makeAllocator(long size) {\n+        return  size != 0\n+            ? Allocator.ofScope(NativeScope.boundedScope(size))\n+            : Allocator.empty();\n+    }\n+\n+    static MethodHandle wrapWithAllocator(MethodHandle specializedHandle,\n+                                          int allocatorPos, long bufferCopySize,\n+                                          boolean upcall) {\n+        \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n+        MethodHandle closer;\n+        int insertPos;\n+        if (specializedHandle.type().returnType() == void.class) {\n+            closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            insertPos = 1;\n+        } else {\n+            closer = identity(specializedHandle.type().returnType()); \/\/ (V) -> V\n+            closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n+            insertPos = 2;\n+        }\n+\n+        \/\/ downcalls get the leading Addressable param as well\n+        if (!upcall) {\n+            closer = dropArguments(closer, insertPos, Addressable.class); \/\/ (Throwable, V?, Addressable) -> V\/void\n+            insertPos++;\n+        }\n+\n+        closer = collectArguments(closer, insertPos, MH_CLOSE_ALLOCATOR); \/\/ (Throwable, V?, Addressable?, NativeScope) -> V\/void\n+\n+        specializedHandle = tryFinally(specializedHandle, closer);\n+        MethodHandle makeScopeHandle = insertArguments(MH_MAKE_ALLOCATOR, 0, bufferCopySize);\n+        specializedHandle = collectArguments(specializedHandle, allocatorPos, makeScopeHandle);\n+        return specializedHandle;\n+    }\n+\n@@ -346,1 +414,1 @@\n-            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize())))\n+            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n@@ -378,1 +446,1 @@\n-               handle = MethodHandles.filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n+               handle = filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n@@ -388,1 +456,1 @@\n-               handle = MethodHandles.filterArguments(handle, i, boxer);\n+               handle = filterArguments(handle, i, boxer);\n@@ -408,2 +476,0 @@\n-        Allocator THROWING_ALLOCATOR = (size, align) -> { throw new UnsupportedOperationException(\"Null allocator\"); };\n-\n@@ -464,1 +530,1 @@\n-                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize())))\n+                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":83,"deletions":17,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -145,1 +143,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n@@ -148,1 +146,1 @@\n-        return new ProgrammableUpcallHandler(C, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence);\n@@ -235,1 +233,1 @@\n-                Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -253,1 +251,1 @@\n-                Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -294,1 +292,1 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -327,1 +325,1 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size);\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, false);\n@@ -396,1 +394,1 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -426,1 +424,1 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size);\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, false);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -143,1 +141,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n@@ -146,1 +144,1 @@\n-        return new ProgrammableUpcallHandler(CSysV, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence);\n@@ -273,1 +271,0 @@\n-                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n@@ -277,0 +274,2 @@\n+                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n@@ -327,1 +326,2 @@\n-                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,1 +32,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -143,1 +141,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, false \/* need the return value as well *\/);\n@@ -146,1 +144,1 @@\n-        return new ProgrammableUpcallHandler(CWindows, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence);\n@@ -208,1 +206,1 @@\n-                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());\n+                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize(), false);\n@@ -273,1 +271,1 @@\n-                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());\n+                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize(), false);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -340,1 +340,2 @@\n-    java\/foreign\n+    java\/foreign \\\n+    -java\/foreign\/TestMatrix.java\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,17 +33,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity TestUpcall TestDowncall\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ *\n+  * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestDowncall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ *\/\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -33,17 +33,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,17 +33,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-                bufferLoad(8, long.class), vmStore(xmm0, long.class)\n+                bufferLoad(8, double.class), vmStore(xmm0, double.class)\n@@ -487,0 +487,24 @@\n+    @Test\n+    public void testFloatStructsUpcall() {\n+        MemoryLayout struct = MemoryLayout.ofStruct(C_FLOAT); \/\/ should be passed in float regs\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct, struct);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, true);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { allocate(struct), dup(), vmLoad(xmm0, float.class), bufferStore(0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[] {\n+            bufferLoad(0, float.class), vmStore(xmm0, float.class)\n+        });\n+\n+        assertEquals(bindings.nVectorArgs, 1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n@@ -44,0 +45,1 @@\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n@@ -57,0 +59,2 @@\n+    static final MethodHandle args5;\n+    static final MethodHandle args10;\n@@ -60,0 +64,2 @@\n+    static final MemoryAddress cb_args5;\n+    static final MemoryAddress cb_args10;\n@@ -63,0 +69,2 @@\n+    static final long cb_args5_jni;\n+    static final long cb_args10_jni;\n@@ -70,0 +78,2 @@\n+        cb_args5_jni = makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -74,9 +84,24 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"blank\").get();\n-                MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);\n-                FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_POINTER);\n-                blank = abi.downcallHandle(addr, mt, fd);\n-\n-                cb_blank = abi.upcallStub(\n-                    lookup().findStatic(Upcalls.class, \"blank\", MethodType.methodType(void.class)),\n-                    FunctionDescriptor.ofVoid()\n-                ).address();\n+                String name = \"blank\";\n+                MethodType mt = MethodType.methodType(void.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+\n+                blank = linkFunc(ll, name, mt, fd);\n+                cb_blank = makeCB(name, mt, fd);\n+            }\n+            {\n+                String name = \"identity\";\n+                MethodType mt = MethodType.methodType(int.class, int.class);\n+                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+\n+                identity = linkFunc(ll, name, mt, fd);\n+                cb_identity = makeCB(name, mt, fd);\n+            }\n+            {\n+                String name = \"args5\";\n+                MethodType mt = MethodType.methodType(void.class,\n+                        long.class, double.class, long.class, double.class, long.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                        C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG);\n+\n+                args5 = linkFunc(ll, name, mt, fd);\n+                cb_args5 = makeCB(name, mt, fd);\n@@ -85,9 +110,10 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n-                MethodType mt = MethodType.methodType(int.class, int.class, MemoryAddress.class);\n-                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, C_POINTER);\n-                identity = abi.downcallHandle(addr, mt, fd);\n-\n-                cb_identity = abi.upcallStub(\n-                    lookup().findStatic(Upcalls.class, \"identity\", MethodType.methodType(int.class, int.class)),\n-                    FunctionDescriptor.of(C_INT, C_INT)\n-                ).address();\n+                String name = \"args10\";\n+                MethodType mt = MethodType.methodType(void.class,\n+                        long.class, double.class, long.class, double.class, long.class,\n+                        double.class, long.class, double.class, long.class, double.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                        C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n+                        C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE);\n+\n+                args10 = linkFunc(ll, name, mt, fd);\n+                cb_args10 = makeCB(name, mt, fd);\n@@ -100,0 +126,15 @@\n+    static MethodHandle linkFunc(LibraryLookup ll, String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+        return abi.downcallHandle(\n+            ll.lookup(name).orElseThrow(),\n+            baseType.insertParameterTypes(baseType.parameterCount(), MemoryAddress.class),\n+            baseDesc.withAppendedArgumentLayouts(C_POINTER)\n+        );\n+    }\n+\n+    static MemoryAddress makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+        return abi.upcallStub(\n+            lookup().findStatic(Upcalls.class, name, mt),\n+            fd\n+        ).address();\n+    }\n+\n@@ -102,0 +143,3 @@\n+    static native void args5(long a0, double a1, long a2, double a3, long a4, long cb);\n+    static native void args10(long a0, double a1, long a2, double a3, long a4,\n+                              double a5, long a6, double a7, long a8, double a9, long cb);\n@@ -119,0 +163,10 @@\n+    @Benchmark\n+    public void jni_args5() throws Throwable {\n+        args5(1L, 2D, 3L, 4D, 5L, cb_args5_jni);\n+    }\n+\n+    @Benchmark\n+    public void jni_args10() throws Throwable {\n+        args10(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10_jni);\n+    }\n+\n@@ -124,0 +178,10 @@\n+    @Benchmark\n+    public void panama_args5() throws Throwable {\n+        args5.invokeExact(1L, 2D, 3L, 4D, 5L, cb_args5);\n+    }\n+\n+    @Benchmark\n+    public void panama_args10() throws Throwable {\n+        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10);\n+    }\n+\n@@ -126,0 +190,3 @@\n+    static void args5(long a0, double a1, long a2, double a3, long a4) { }\n+    static void args10(long a0, double a1, long a2, double a3, long a4,\n+                       double a5, long a6, double a7, long a8, double a9) { }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":85,"deletions":18,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -37,0 +37,12 @@\n+\n+EXPORT void args5(long long a0, double a1, long long a2, double a3, long long a4,\n+                  void (*cb)(long long, double, long long, double, long long)) {\n+    cb(a0, a1, a2, a3, a4);\n+}\n+\n+EXPORT void args10(long long a0, double a1, long long a2, double a3, long long a4,\n+                   double a5, long long a6, double a7, long long a8, double a9,\n+                   void (*cb)(long long, double, long long, double, long long,\n+                              double, long long, double, long long, double)) {\n+    cb(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcalls.c","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,8 +27,0 @@\n-void blank(void (*cb)(void)) {\n-    cb();\n-}\n-\n-int identity(int x, int (*cb)(int)) {\n-    return cb(x);\n-}\n-\n@@ -85,0 +77,17 @@\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args5\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4);\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args10\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jdouble a5, jlong a6, jdouble a7, jlong a8, jdouble a9,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"}]}