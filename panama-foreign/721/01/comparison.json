{"files":[{"patch":"@@ -29,1 +29,4 @@\n-import java.util.*;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.List;\n@@ -47,1 +50,2 @@\n-public sealed interface FunctionDescriptor permits FunctionDescriptorImpl {\n+public sealed interface FunctionDescriptor\n+        permits FunctionDescriptorImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-public sealed interface GroupLayout extends MemoryLayout permits StructLayout, UnionLayout {\n+public sealed interface GroupLayout\n+        extends MemoryLayout\n+        permits StructLayout, UnionLayout {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,52 +148,2 @@\n-public sealed interface Linker permits AbstractLinker {\n-\n-    \/**\n-     * Returns a linker for the ABI associated with the underlying native platform. The underlying native platform\n-     * is the combination of OS and processor where the Java runtime is currently executing.\n-     * <p>\n-     * When interacting with the returned linker, clients must describe the signature of a foreign function using a\n-     * {@link FunctionDescriptor function descriptor} whose argument and return layouts are specified as follows:\n-     * <ul>\n-     *     <li>Scalar types are modelled by a {@linkplain ValueLayout value layout} instance of a suitable carrier. Example\n-     *     of scalar types in C are {@code int}, {@code long}, {@code size_t}, etc. The mapping between a scalar type\n-     *     and its corresponding layout is dependent on the ABI of the returned linker;\n-     *     <li>Composite types are modelled by a {@linkplain GroupLayout group layout}. Depending on the ABI of the\n-     *     returned linker, additional {@linkplain MemoryLayout#paddingLayout(long) padding} member layouts might be required to conform\n-     *     to the size and alignment constraints of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n-     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemorySegment}.\n-     *     Examples of pointer types in C are {@code int**} and {@code int(*)(size_t*, size_t*)};<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Any layout not listed above is <em>unsupported<\/em>; function descriptors containing unsupported layouts\n-     * will cause an {@link IllegalArgumentException} to be thrown, when used to create a\n-     * {@link #downcallHandle(MemorySegment, FunctionDescriptor) downcall method handle} or an\n-     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}.\n-     * <p>\n-     * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n-     * list or with an empty formal parameter list) are not supported directly. However, it is possible to link a\n-     * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>}\n-     * function descriptor, in which the specialized signature of a given variable arity callsite is described in full.\n-     * Alternatively, where the foreign library allows it, clients might be able to interact with variadic functions by\n-     * passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @apiNote It is not currently possible to obtain a linker for a different combination of OS and processor.\n-     * @implNote The libraries exposed by the {@linkplain #defaultLookup() default lookup} associated with the returned\n-     * linker are the native libraries loaded in the process where the Java runtime is currently executing. For example,\n-     * on Linux, these libraries typically include {@code libc}, {@code libm} and {@code libdl}.\n-     *\n-     * @return a linker for the ABI associated with the OS and processor where the Java runtime is currently executing.\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static Linker nativeLinker() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"nativeLinker\");\n-        return SharedUtils.getSystemLinker();\n-    }\n+public sealed interface Linker\n+        permits AbstractLinker {\n@@ -221,1 +171,2 @@\n-        return downcallHandle(function).bindTo(symbol);\n+        return downcallHandle(function)\n+                .bindTo(symbol);\n@@ -269,1 +220,3 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n+    MemorySegment upcallStub(MethodHandle target,\n+                             FunctionDescriptor function,\n+                             MemorySession session);\n@@ -285,0 +238,51 @@\n+\n+    \/**\n+     * Returns a linker for the ABI associated with the underlying native platform. The underlying native platform\n+     * is the combination of OS and processor where the Java runtime is currently executing.\n+     * <p>\n+     * When interacting with the returned linker, clients must describe the signature of a foreign function using a\n+     * {@link FunctionDescriptor function descriptor} whose argument and return layouts are specified as follows:\n+     * <ul>\n+     *     <li>Scalar types are modelled by a {@linkplain ValueLayout value layout} instance of a suitable carrier. Example\n+     *     of scalar types in C are {@code int}, {@code long}, {@code size_t}, etc. The mapping between a scalar type\n+     *     and its corresponding layout is dependent on the ABI of the returned linker;\n+     *     <li>Composite types are modelled by a {@linkplain GroupLayout group layout}. Depending on the ABI of the\n+     *     returned linker, additional {@linkplain MemoryLayout#paddingLayout(long) padding} member layouts might be required to conform\n+     *     to the size and alignment constraints of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n+     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemorySegment}.\n+     *     Examples of pointer types in C are {@code int**} and {@code int(*)(size_t*, size_t*)};<\/li>\n+     * <\/ul>\n+     * <p>\n+     * Any layout not listed above is <em>unsupported<\/em>; function descriptors containing unsupported layouts\n+     * will cause an {@link IllegalArgumentException} to be thrown, when used to create a\n+     * {@link #downcallHandle(MemorySegment, FunctionDescriptor) downcall method handle} or an\n+     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub}.\n+     * <p>\n+     * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n+     * list or with an empty formal parameter list) are not supported directly. However, it is possible to link a\n+     * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>}\n+     * function descriptor, in which the specialized signature of a given variable arity callsite is described in full.\n+     * Alternatively, where the foreign library allows it, clients might be able to interact with variadic functions by\n+     * passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @apiNote It is not currently possible to obtain a linker for a different combination of OS and processor.\n+     * @implNote The libraries exposed by the {@linkplain #defaultLookup() default lookup} associated with the returned\n+     * linker are the native libraries loaded in the process where the Java runtime is currently executing. For example,\n+     * on Linux, these libraries typically include {@code libc}, {@code libm} and {@code libdl}.\n+     *\n+     * @return a linker for the ABI associated with the OS and processor where the Java runtime is currently executing.\n+     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static Linker nativeLinker() {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"nativeLinker\");\n+        return SharedUtils.getSystemLinker();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":58,"deletions":54,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.function.Function;\n@@ -42,1 +41,6 @@\n-import jdk.internal.foreign.layout.*;\n+import jdk.internal.foreign.layout.MemoryLayoutUtil;\n+import jdk.internal.foreign.layout.PaddingLayoutImpl;\n+import jdk.internal.foreign.layout.SequenceLayoutImpl;\n+import jdk.internal.foreign.layout.StructLayoutImpl;\n+import jdk.internal.foreign.layout.UnionLayoutImpl;\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -168,6 +172,2 @@\n-public sealed interface MemoryLayout permits SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n-\n-    \/**\n-     * {@return the layout size, in bits}\n-     *\/\n-    long bitSize();\n+public sealed interface MemoryLayout\n+        permits SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n@@ -197,18 +197,0 @@\n-    \/**\n-     * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power\n-     * of two {@code A} which is the bit-wise alignment of the layout. If {@code A <= 8} then {@code A\/8} is the number of\n-     * bytes that must be aligned for any pointer that correctly points to this layout. Thus:\n-     *\n-     * <ul>\n-     * <li>{@code A=8} means unaligned (in the usual sense), which is common in packets.<\/li>\n-     * <li>{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.<\/li>\n-     * <li>{@code A=512} is the most strict alignment required by the x86\/SV ABI (for AVX-512 data).<\/li>\n-     * <\/ul>\n-     *\n-     * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),\n-     * then this method returns the <a href=\"#layout-align\">natural alignment<\/a> constraint (in bits) associated with this layout.\n-     *\n-     * @return the layout alignment constraint, in bits.\n-     *\/\n-    long bitAlignment();\n-\n@@ -237,0 +219,18 @@\n+    \/**\n+     * Returns the alignment constraint associated with this layout, expressed in bits. Layout alignment defines a power\n+     * of two {@code A} which is the bit-wise alignment of the layout. If {@code A <= 8} then {@code A\/8} is the number of\n+     * bytes that must be aligned for any pointer that correctly points to this layout. Thus:\n+     *\n+     * <ul>\n+     * <li>{@code A=8} means unaligned (in the usual sense), which is common in packets.<\/li>\n+     * <li>{@code A=64} means word aligned (on LP64), {@code A=32} int aligned, {@code A=16} short aligned, etc.<\/li>\n+     * <li>{@code A=512} is the most strict alignment required by the x86\/SV ABI (for AVX-512 data).<\/li>\n+     * <\/ul>\n+     *\n+     * If no explicit alignment constraint was set on this layout (see {@link #withBitAlignment(long)}),\n+     * then this method returns the <a href=\"#layout-align\">natural alignment<\/a> constraint (in bits) associated with this layout.\n+     *\n+     * @return the layout alignment constraint, in bits.\n+     *\/\n+    long bitAlignment();\n+\n@@ -247,0 +247,17 @@\n+    \/**\n+     * Computes the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this\n+     * layout.\n+     *\n+     * @param elements the layout path elements.\n+     * @return The offset, in bytes, of the layout selected by the layout path in {@code elements}.\n+     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the\n+     * layout path contains one or more path elements that select multiple sequence element indices\n+     * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).\n+     * @throws UnsupportedOperationException if {@code bitOffset(elements)} is not a multiple of 8.\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n+     *\/\n+    default long byteOffset(PathElement... elements) {\n+        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.BITS_TO_BYTES_THROW_OFFSET);\n+    }\n+\n@@ -260,2 +277,4 @@\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offset,\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);\n+        return Utils.computePathOp(LayoutPath.rootPath(this),\n+                LayoutPath::offset,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE),\n+                elements);\n@@ -265,1 +284,1 @@\n-     * Creates a method handle that can be used to compute the offset, in bits, of the layout selected\n+     * Creates a method handle that can be used to compute the offset, in bytes, of the layout selected\n@@ -271,1 +290,1 @@\n-     * The returned method handle can be used to compute a layout offset similar to {@link #bitOffset(PathElement...)},\n+     * The returned method handle can be used to compute a layout offset similar to {@link #byteOffset(PathElement...)},\n@@ -277,1 +296,2 @@\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * offset = bitOffset \/ 8\n@@ -285,0 +305,3 @@\n+     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n+     * offset in bits is not a multiple of 8.\n+     *\n@@ -286,1 +309,1 @@\n-     * @return a method handle that can be used to compute the bit offset of the layout element\n+     * @return a method handle that can be used to compute the byte offset of the layout element\n@@ -291,20 +314,4 @@\n-    default MethodHandle bitOffsetHandle(PathElement... elements) {\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offsetHandle,\n-                EnumSet.of(PathKind.SEQUENCE_RANGE), elements);\n-    }\n-\n-    \/**\n-     * Computes the offset, in bytes, of the layout selected by the given layout path, where the path is considered rooted in this\n-     * layout.\n-     *\n-     * @param elements the layout path elements.\n-     * @return The offset, in bytes, of the layout selected by the layout path in {@code elements}.\n-     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout, or if the\n-     * layout path contains one or more path elements that select multiple sequence element indices\n-     * (see {@link PathElement#sequenceElement()} and {@link PathElement#sequenceElement(long, long)}).\n-     * @throws UnsupportedOperationException if {@code bitOffset(elements)} is not a multiple of 8.\n-     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n-     * in {@code elements} is {@code null}.\n-     *\/\n-    default long byteOffset(PathElement... elements) {\n-        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.bitsToBytesThrowOffset);\n+    default MethodHandle byteOffsetHandle(PathElement... elements) {\n+        MethodHandle mh = bitOffsetHandle(elements);\n+        mh = MethodHandles.filterReturnValue(mh, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET);\n+        return mh;\n@@ -314,1 +321,1 @@\n-     * Creates a method handle that can be used to compute the offset, in bytes, of the layout selected\n+     * Creates a method handle that can be used to compute the offset, in bits, of the layout selected\n@@ -320,1 +327,1 @@\n-     * The returned method handle can be used to compute a layout offset similar to {@link #byteOffset(PathElement...)},\n+     * The returned method handle can be used to compute a layout offset similar to {@link #bitOffset(PathElement...)},\n@@ -326,2 +333,1 @@\n-     * bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * offset = bitOffset \/ 8\n+     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -335,3 +341,0 @@\n-     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n-     * offset in bits is not a multiple of 8.\n-     *\n@@ -339,1 +342,1 @@\n-     * @return a method handle that can be used to compute the byte offset of the layout element\n+     * @return a method handle that can be used to compute the bit offset of the layout element\n@@ -344,4 +347,5 @@\n-    default MethodHandle byteOffsetHandle(PathElement... elements) {\n-        MethodHandle mh = bitOffsetHandle(elements);\n-        mh = MethodHandles.filterReturnValue(mh, Utils.MH_bitsToBytesOrThrowForOffset);\n-        return mh;\n+    default MethodHandle bitOffsetHandle(PathElement... elements) {\n+        return Utils.computePathOp(LayoutPath.rootPath(this),\n+                LayoutPath::offsetHandle,\n+                EnumSet.of(PathKind.SEQUENCE_RANGE),\n+                elements);\n@@ -386,2 +390,4 @@\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::dereferenceHandle,\n-                Set.of(), elements);\n+        return Utils.computePathOp(LayoutPath.rootPath(this),\n+                LayoutPath::dereferenceHandle,\n+                Set.of(),\n+                elements);\n@@ -429,2 +435,4 @@\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::sliceHandle,\n-                Set.of(), elements);\n+        return Utils.computePathOp(LayoutPath.rootPath(this),\n+                LayoutPath::sliceHandle,\n+                Set.of(),\n+                elements);\n@@ -443,2 +451,4 @@\n-        return computePathOp(LayoutPath.rootPath(this), LayoutPath::layout,\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);\n+        return Utils.computePathOp(LayoutPath.rootPath(this),\n+                LayoutPath::layout,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE),\n+                elements);\n@@ -447,9 +457,73 @@\n-    private static <Z> Z computePathOp(LayoutPath path, Function<LayoutPath, Z> finalizer,\n-                                       Set<PathKind> badKinds, PathElement... elements) {\n-        Objects.requireNonNull(elements);\n-        for (PathElement e : elements) {\n-            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n-            if (badKinds.contains(pathElem.kind())) {\n-                throw new IllegalArgumentException(String.format(\"Invalid %s selection in layout path\", pathElem.kind().description()));\n-            }\n-            path = pathElem.apply(path);\n+    \/**\n+     * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified\n+     * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of\n+     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n+     * conditions must be satisfied:\n+     * <ul>\n+     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n+     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n+     *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and\n+     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal<\/li>\n+     *     <li>two group layouts are considered equal if they are of the same type (see {@link StructLayout},\n+     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     * <\/ul>\n+     *\n+     * @param other the object to be compared for equality with this layout.\n+     * @return {@code true} if the specified object is equal to this layout.\n+     *\/\n+    boolean equals(Object other);\n+\n+    \/**\n+     * Creates a padding layout with the given size.\n+     *\n+     * @param size the padding size in bits.\n+     * @return the new selector layout.\n+     * @throws IllegalArgumentException if {@code size <= 0}.\n+     *\/\n+    static PaddingLayout paddingLayout(long size) {\n+        MemoryLayoutUtil.checkSize(size);\n+        return PaddingLayoutImpl.of(size);\n+    }\n+\n+    \/**\n+     * Creates a sequence layout with the given element layout and the maximum element\n+     * count such that it does not overflow a {@code long}.\n+     *\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n+     * }\n+     *\n+     * @param elementLayout the sequence element layout.\n+     * @return a new sequence layout with the given element layout and maximum element count.\n+     *\/\n+    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n+        Objects.requireNonNull(elementLayout);\n+        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n+    }\n+\n+    \/**\n+     * Creates a sequence layout with the given element layout and element count.\n+     *\n+     * @param elementCount the sequence element count.\n+     * @param elementLayout the sequence element layout.\n+     * @return the new sequence layout with the given element layout and size.\n+     * @throws IllegalArgumentException if {@code elementCount } is negative.\n+     *\/\n+    static SequenceLayout sequenceLayout(long elementCount, MemoryLayout elementLayout) {\n+        MemoryLayoutUtil.checkSize(elementCount, true);\n+        Objects.requireNonNull(elementLayout);\n+        return wrapOverflow(() ->\n+                SequenceLayoutImpl.of(elementCount, elementLayout));\n+    }\n+\n+    \/**\n+     * {@return the layout size, in bits}\n+     *\/\n+    long bitSize();\n+\n+    private static <L extends MemoryLayout> L wrapOverflow(Supplier<L> layoutSupplier) {\n+        try {\n+            return layoutSupplier.get();\n+        } catch (ArithmeticException ex) {\n+            throw new IllegalArgumentException(\"Layout size exceeds Long.MAX_VALUE\");\n@@ -457,1 +531,29 @@\n-        return finalizer.apply(path);\n+    }\n+\n+    \/**\n+     * Creates a struct layout with the given member layouts.\n+     *\n+     * @param elements The member layouts of the struct layout.\n+     * @return a struct layout with the given member layouts.\n+     * @throws IllegalArgumentException if the sum of the {@linkplain #bitSize() bit sizes} of the member layouts\n+     * overflows.\n+     *\/\n+    static StructLayout structLayout(MemoryLayout... elements) {\n+        Objects.requireNonNull(elements);\n+        return wrapOverflow(() ->\n+                StructLayoutImpl.of(Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .toList()));\n+    }\n+\n+    \/**\n+     * Creates a union layout with the given member layouts.\n+     *\n+     * @param elements The member layouts of the union layout.\n+     * @return a union layout with the given member layouts.\n+     *\/\n+    static UnionLayout unionLayout(MemoryLayout... elements) {\n+        Objects.requireNonNull(elements);\n+        return UnionLayoutImpl.of(Stream.of(elements)\n+                .map(Objects::requireNonNull)\n+                .toList());\n@@ -574,156 +676,0 @@\n-\n-    \/**\n-     * Compares the specified object with this layout for equality. Returns {@code true} if and only if the specified\n-     * object is also a layout, and it is equal to this layout. Two layouts are considered equal if they are of\n-     * the same kind, have the same size, name and alignment constraints. Furthermore, depending on the layout kind, additional\n-     * conditions must be satisfied:\n-     * <ul>\n-     *     <li>two value layouts are considered equal if they have the same {@linkplain ValueLayout#order() order},\n-     *     and {@linkplain ValueLayout#carrier() carrier}<\/li>\n-     *     <li>two sequence layouts are considered equal if they have the same element count (see {@link SequenceLayout#elementCount()}), and\n-     *     if their element layouts (see {@link SequenceLayout#elementLayout()}) are also equal<\/li>\n-     *     <li>two group layouts are considered equal if they are of the same type (see {@link StructLayout},\n-     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n-     * <\/ul>\n-     *\n-     * @param other the object to be compared for equality with this layout.\n-     * @return {@code true} if the specified object is equal to this layout.\n-     *\/\n-    boolean equals(Object other);\n-\n-    \/**\n-     * {@return the hash code value for this layout}\n-     *\/\n-    int hashCode();\n-\n-    \/**\n-     * {@return the string representation of this layout}\n-     *\/\n-    @Override\n-    String toString();\n-\n-    \/**\n-     * Creates a padding layout with the given size.\n-     *\n-     * @param size the padding size in bits.\n-     * @return the new selector layout.\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n-     *\/\n-    static PaddingLayout paddingLayout(long size) {\n-        MemoryLayoutUtil.checkSize(size);\n-        return PaddingLayoutImpl.of(size);\n-    }\n-\n-    \/**\n-     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n-     * by the carrier provided:\n-     * <ul>\n-     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n-     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n-     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n-     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n-     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n-     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n-     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n-     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n-     * <\/ul>\n-     * @param carrier the value layout carrier.\n-     * @param order the value layout's byte order.\n-     * @return a value layout with the given Java carrier and byte-order.\n-     * @throws IllegalArgumentException if the carrier type is not supported.\n-     *\/\n-    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(order);\n-        if (carrier == boolean.class) {\n-            return ValueLayouts.OfBooleanImpl.of(order);\n-        } else if (carrier == char.class) {\n-            return ValueLayouts.OfCharImpl.of(order);\n-        } else if (carrier == byte.class) {\n-            return ValueLayouts.OfByteImpl.of(order);\n-        } else if (carrier == short.class) {\n-            return ValueLayouts.OfShortImpl.of(order);\n-        } else if (carrier == int.class) {\n-            return ValueLayouts.OfIntImpl.of(order);\n-        } else if (carrier == float.class) {\n-            return ValueLayouts.OfFloatImpl.of(order);\n-        } else if (carrier == long.class) {\n-            return ValueLayouts.OfLongImpl.of(order);\n-        } else if (carrier == double.class) {\n-            return ValueLayouts.OfDoubleImpl.of(order);\n-        } else if (carrier == MemorySegment.class) {\n-            return ValueLayouts.OfAddressImpl.of(order);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n-        }\n-    }\n-\n-    \/**\n-     * Creates a sequence layout with the given element layout and element count.\n-     *\n-     * @param elementCount the sequence element count.\n-     * @param elementLayout the sequence element layout.\n-     * @return the new sequence layout with the given element layout and size.\n-     * @throws IllegalArgumentException if {@code elementCount } is negative.\n-     *\/\n-    static SequenceLayout sequenceLayout(long elementCount, MemoryLayout elementLayout) {\n-        MemoryLayoutUtil.checkSize(elementCount, true);\n-        Objects.requireNonNull(elementLayout);\n-        return wrapOverflow(() ->\n-                SequenceLayoutImpl.of(elementCount, elementLayout));\n-    }\n-\n-    \/**\n-     * Creates a sequence layout with the given element layout and the maximum element\n-     * count such that it does not overflow a {@code long}.\n-     *\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n-     * }\n-     *\n-     * @param elementLayout the sequence element layout.\n-     * @return a new sequence layout with the given element layout and maximum element count.\n-     *\/\n-    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n-        Objects.requireNonNull(elementLayout);\n-        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.bitSize(), elementLayout);\n-    }\n-\n-    \/**\n-     * Creates a struct layout with the given member layouts.\n-     *\n-     * @param elements The member layouts of the struct layout.\n-     * @return a struct layout with the given member layouts.\n-     * @throws IllegalArgumentException if the sum of the {@linkplain #bitSize() bit sizes} of the member layouts\n-     * overflows.\n-     *\/\n-    static StructLayout structLayout(MemoryLayout... elements) {\n-        Objects.requireNonNull(elements);\n-        return wrapOverflow(() ->\n-                StructLayoutImpl.of(Stream.of(elements)\n-                        .map(Objects::requireNonNull)\n-                        .toList()));\n-    }\n-\n-    \/**\n-     * Creates a union layout with the given member layouts.\n-     *\n-     * @param elements The member layouts of the union layout.\n-     * @return a union layout with the given member layouts.\n-     *\/\n-    static UnionLayout unionLayout(MemoryLayout... elements) {\n-        Objects.requireNonNull(elements);\n-        return UnionLayoutImpl.of(Stream.of(elements)\n-                .map(Objects::requireNonNull)\n-                .toList());\n-    }\n-\n-    private static <L extends MemoryLayout> L wrapOverflow(Supplier<L> layoutSupplier) {\n-        try {\n-            return layoutSupplier.get();\n-        } catch (ArithmeticException ex) {\n-            throw new IllegalArgumentException(\"Layout size exceeds Long.MAX_VALUE\");\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":182,"deletions":236,"binary":false,"changes":418,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.reflect.Array;\n@@ -49,2 +48,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.misc.Unsafe;\n@@ -55,2 +52,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n@@ -246,1 +241,7 @@\n-public sealed interface MemorySegment permits AbstractMemorySegmentImpl {\n+public sealed interface MemorySegment\n+        permits AbstractMemorySegmentImpl {\n+\n+    \/**\n+     * A zero-length native memory segment modelling the {@code NULL} address.\n+     *\/\n+    MemorySegment NULL = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(0L, 0);\n@@ -308,37 +309,0 @@\n-    \/**\n-     * {@return the size (in bytes) of this memory segment}\n-     *\/\n-    long byteSize();\n-\n-    \/**\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n-     * of this segment plus the given offset; its size is specified by the given argument.\n-     *\n-     * @see #asSlice(long)\n-     *\n-     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n-     * @param newSize The new segment size, specified in bytes.\n-     * @return a slice of this memory segment.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n-     *\/\n-    MemorySegment asSlice(long offset, long newSize);\n-\n-    \/**\n-     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n-     * of this segment plus the given offset; its size is computed by subtracting the specified offset from this segment size.\n-     * <p>\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * asSlice(offset, byteSize() - offset);\n-     * }\n-     *\n-     * @see #asSlice(long, long)\n-     *\n-     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n-     * @return a slice of this memory segment.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, or {@code offset > byteSize()}.\n-     *\/\n-    default MemorySegment asSlice(long offset) {\n-        return asSlice(offset, byteSize() - offset);\n-    }\n-\n@@ -471,0 +435,7 @@\n+    \/**\n+     * {@return the size (in bytes) of this memory segment}\n+     *\/\n+    long byteSize();\n+\n+\n+\n@@ -626,2 +597,1 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n-     * different from the {@linkplain ByteOrder#nativeOrder native order}, a byte swap operation will be performed on each array element.\n+     * @param byteLayout the source element layout.\n@@ -636,1 +606,1 @@\n-    byte[] toArray(ValueLayout.OfByte elementLayout);\n+    byte[] toArray(ValueLayout.OfByte byteLayout);\n@@ -640,1 +610,1 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * @param shortLayout the source element layout. If the byte order associated with the layout is\n@@ -650,1 +620,1 @@\n-    short[] toArray(ValueLayout.OfShort elementLayout);\n+    short[] toArray(ValueLayout.OfShort shortLayout);\n@@ -654,1 +624,1 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * @param charLayout the source element layout. If the byte order associated with the layout is\n@@ -664,1 +634,1 @@\n-    char[] toArray(ValueLayout.OfChar elementLayout);\n+    char[] toArray(ValueLayout.OfChar charLayout);\n@@ -668,1 +638,1 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * @param intLayout the source element layout. If the byte order associated with the layout is\n@@ -678,1 +648,1 @@\n-    int[] toArray(ValueLayout.OfInt elementLayout);\n+    int[] toArray(ValueLayout.OfInt intLayout);\n@@ -682,1 +652,1 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * @param floatLayout the source element layout. If the byte order associated with the layout is\n@@ -692,1 +662,1 @@\n-    float[] toArray(ValueLayout.OfFloat elementLayout);\n+    float[] toArray(ValueLayout.OfFloat floatLayout);\n@@ -696,1 +666,1 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * @param longLayout the source element layout. If the byte order associated with the layout is\n@@ -706,1 +676,1 @@\n-    long[] toArray(ValueLayout.OfLong elementLayout);\n+    long[] toArray(ValueLayout.OfLong longLayout);\n@@ -710,1 +680,1 @@\n-     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * @param doubleLayout the source element layout. If the byte order associated with the layout is\n@@ -720,1 +690,1 @@\n-    double[] toArray(ValueLayout.OfDouble elementLayout);\n+    double[] toArray(ValueLayout.OfDouble doubleLayout);\n@@ -771,1 +741,0 @@\n-\n@@ -773,7 +742,2 @@\n-     * Creates a buffer memory segment that models the memory associated with the given {@link Buffer} instance.\n-     * The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive).\n-     * <p>\n-     * If the buffer is {@linkplain ByteBuffer#isReadOnly() read-only}, the resulting segment will also be\n-     * {@linkplain ByteBuffer#isReadOnly() read-only}. The memory session associated with this segment can either be the\n-     * {@linkplain MemorySession#global() global} memory session, in case the buffer has been created independently,\n-     * or some other memory session, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n+     * of this segment plus the given offset; its size is computed by subtracting the specified offset from this segment size.\n@@ -781,1 +745,4 @@\n-     * The resulting memory segment keeps a reference to the backing buffer, keeping it <em>reachable<\/em>.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * asSlice(offset, byteSize() - offset);\n+     * }\n@@ -783,2 +750,5 @@\n-     * @param buffer the buffer instance backing the buffer memory segment.\n-     * @return a buffer memory segment.\n+     * @see #asSlice(long, long)\n+     *\n+     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @return a slice of this memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, or {@code offset > byteSize()}.\n@@ -786,2 +756,2 @@\n-    static MemorySegment ofBuffer(Buffer buffer) {\n-        return AbstractMemorySegmentImpl.ofBuffer(buffer);\n+    default MemorySegment asSlice(long offset) {\n+        return asSlice(offset, byteSize() - offset);\n@@ -791,2 +761,2 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated byte array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Returns a slice of this memory segment, at the given offset. The returned segment's base address is the base address\n+     * of this segment plus the given offset; its size is specified by the given argument.\n@@ -794,2 +764,6 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @see #asSlice(long)\n+     *\n+     * @param offset The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * @param newSize The new segment size, specified in bytes.\n+     * @return a slice of this memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n@@ -797,3 +771,1 @@\n-    static MemorySegment ofArray(byte[] arr) {\n-        return HeapMemorySegmentImpl.OfByte.fromArray(arr);\n-    }\n+    MemorySegment asSlice(long offset, long newSize);\n@@ -802,2 +774,1 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated char array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Reads a byte from this segment at the given offset, with the given layout.\n@@ -805,2 +776,12 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a byte value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n@@ -808,2 +789,3 @@\n-    static MemorySegment ofArray(char[] arr) {\n-        return HeapMemorySegmentImpl.OfChar.fromArray(arr);\n+    @ForceInline\n+    default byte get(ValueLayout.OfByte layout, long offset) {\n+        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n@@ -813,2 +795,1 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated short array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Writes a byte into this segment at the given offset, with the given layout.\n@@ -816,2 +797,13 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -819,2 +811,3 @@\n-    static MemorySegment ofArray(short[] arr) {\n-        return HeapMemorySegmentImpl.OfShort.fromArray(arr);\n+    @ForceInline\n+    default void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n@@ -824,2 +817,1 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated int array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Reads a boolean from this segment at the given offset, with the given layout.\n@@ -827,2 +819,12 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a boolean value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n@@ -830,2 +832,3 @@\n-    static MemorySegment ofArray(int[] arr) {\n-        return HeapMemorySegmentImpl.OfInt.fromArray(arr);\n+    @ForceInline\n+    default boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n@@ -835,2 +838,1 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated float array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Writes a boolean into this segment at the given offset, with the given layout.\n@@ -838,2 +840,13 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param value the boolean value to be written.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -841,2 +854,3 @@\n-    static MemorySegment ofArray(float[] arr) {\n-        return HeapMemorySegmentImpl.OfFloat.fromArray(arr);\n+    @ForceInline\n+    default void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n@@ -846,2 +860,1 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated long array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Reads a char from this segment at the given offset, with the given layout.\n@@ -849,2 +862,12 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a char value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n@@ -852,2 +875,3 @@\n-    static MemorySegment ofArray(long[] arr) {\n-        return HeapMemorySegmentImpl.OfLong.fromArray(arr);\n+    @ForceInline\n+    default char get(ValueLayout.OfChar layout, long offset) {\n+        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n@@ -857,2 +881,1 @@\n-     * Creates an array memory segment that models the memory associated with the given heap-allocated double array.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * Writes a char into this segment at the given offset, with the given layout.\n@@ -860,2 +883,13 @@\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return an array memory segment.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param value the char value to be written.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -863,2 +897,3 @@\n-    static MemorySegment ofArray(double[] arr) {\n-        return HeapMemorySegmentImpl.OfDouble.fromArray(arr);\n+    @ForceInline\n+    default void set(ValueLayout.OfChar layout, long offset, char value) {\n+        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n@@ -868,1 +903,14 @@\n-     * A zero-length native memory segment modelling the {@code NULL} address.\n+     * Reads a short from this segment at the given offset, with the given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address() + offset}.\n+     * @return a short value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n@@ -870,1 +918,4 @@\n-    MemorySegment NULL = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(0L, 0);\n+    @ForceInline\n+    default short get(ValueLayout.OfShort layout, long offset) {\n+        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n+    }\n@@ -873,9 +924,15 @@\n-     * Creates a zero-length native memory segment from the given {@linkplain #address() address value}.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, 0);\n-     *}\n-     * @param address the address of the returned native segment.\n-     * @return a zero-length native memory segment with the given address.\n+     * Writes a short into this segment at the given offset, with the given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this segment.\n+     * @throws IllegalArgumentException if the dereference operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n@@ -883,2 +940,3 @@\n-    static MemorySegment ofAddress(long address) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+    @ForceInline\n+    default void set(ValueLayout.OfShort layout, long offset, short value) {\n+        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n@@ -888,313 +946,1 @@\n-     * Creates a native memory segment with the given size and {@linkplain #address() address value}.\n-     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, bytesSize, MemorySession.global());\n-     *}\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param address the address of the returned native segment.\n-     * @param bytesSize the size (in bytes) of the returned native segment.\n-     * @return a zero-length native memory segment with the given address and size.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static MemorySegment ofAddress(long address, long bytesSize) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        return MemorySegment.ofAddress(address, bytesSize, MemorySession.global());\n-    }\n-\n-    \/**\n-     * Creates a native memory segment with the given size, base address, and memory session.\n-     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n-     * where an address to some underlying memory region is typically obtained from foreign code\n-     * (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided memory session.\n-     * <p>\n-     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param address the returned segment's base address.\n-     * @param bytesSize the desired size.\n-     * @param session the native segment memory session.\n-     * @return a native memory segment with the given base address, size and memory session.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static MemorySegment ofAddress(long address, long bytesSize, MemorySession session) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        Objects.requireNonNull(session);\n-        Utils.checkAllocationSizeAndAlign(bytesSize, 1);\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, bytesSize, session);\n-    }\n-\n-    \/**\n-     * Creates a native memory segment with the given layout.\n-     * <p>\n-     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n-     * memory session. As such, the native memory region associated with the returned segment is\n-     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n-     * <p>\n-     * Native segments featuring deterministic deallocation can be obtained using the\n-     * {@link MemorySession#allocate(MemoryLayout)} method.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemorySession.openImplicit()\n-     *         .allocate(layout.bytesSize(), layout.bytesAlignment());\n-     * }\n-     * <p>\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     *\n-     * @param layout the layout of the off-heap memory block backing the native memory segment.\n-     * @return a new native memory segment.\n-     * @see MemorySession#allocate(MemoryLayout)\n-     *\/\n-    static MemorySegment allocateNative(MemoryLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return allocateNative(layout.byteSize(), layout.byteAlignment());\n-    }\n-\n-    \/**\n-     * Creates a native memory segment with the given size (in bytes).\n-     * <p>\n-     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n-     * memory session. As such, the native memory region associated with the returned segment is\n-     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n-     * <p>\n-     * Native segments featuring deterministic deallocation can be obtained using the\n-     * {@link MemorySession#allocate(long)}} method.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemorySession.openImplicit()\n-     *     .allocate(bytesSize, 1)\n-     * }\n-     * <p>\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     * <p>\n-     * This method corresponds to the {@link ByteBuffer#allocateDirect(int)} method and has similar behavior.\n-     *\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n-     * @see ByteBuffer#allocateDirect(int)\n-     * @see MemorySession#allocate(long)\n-     *\/\n-    static MemorySegment allocateNative(long bytesSize) {\n-        return allocateNative(bytesSize, 1L);\n-    }\n-\n-    \/**\n-     * Creates a native memory segment with the given size (in bytes) and alignment (in bytes).\n-     * <p>\n-     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n-     * memory session. As such, the native memory region associated with the returned segment is\n-     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n-     * <p>\n-     * Native segments featuring deterministic deallocation can be obtained using the\n-     * {@link MemorySession#allocate(long, long)} method.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemorySession.openImplicit()\n-     *     .allocate(bytesSize, byteAlignment)\n-     * }\n-     * <p>\n-     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     *\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n-     * is not a power of 2.\n-     * @see MemorySession#allocate(long, long)\n-     *\/\n-    static MemorySegment allocateNative(long bytesSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(bytesSize, byteAlignment);\n-        return MemorySession.openImplicit()\n-                .allocate(bytesSize, byteAlignment);\n-    }\n-\n-    \/**\n-     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n-     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n-     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemorySegment.copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n-     * }\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code srcSegment}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code dstSegment}.\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n-     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n-     * or {@code bytes} are {@code < 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    @ForceInline\n-    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n-        copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n-    }\n-\n-    \/**\n-     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n-     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n-     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n-     * <p>\n-     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n-     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n-     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n-     * are swapped accordingly during the copy operation.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n-     * @param srcSegment the source segment.\n-     * @param srcElementLayout the element layout associated with the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstElementLayout the element layout associated with the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of elements to be copied.\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source (resp. destination) segment\/offset are\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source\n-     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this {@code srcSegment}.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with {@code dstSegment}.\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n-     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n-     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    @ForceInline\n-    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n-                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(srcElementLayout);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(dstElementLayout);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n-        }\n-        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n-        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        long size = elementCount * srcElementLayout.byteSize();\n-        srcImpl.checkAccess(srcOffset, size, true);\n-        dstImpl.checkAccess(dstOffset, size, false);\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n-        }\n-    }\n-\n-    \/**\n-     * Reads a byte from this segment at the given offset, with the given layout.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n-     * @return a byte value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n-     *\/\n-    @ForceInline\n-    default byte get(ValueLayout.OfByte layout, long offset) {\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n-    }\n-\n-    \/**\n-     * Writes a byte into this segment at the given offset, with the given layout.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n-     * @param value the byte value to be written.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n-     *\/\n-    @ForceInline\n-    default void set(ValueLayout.OfByte layout, long offset, byte value) {\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a boolean from this segment at the given offset, with the given layout.\n+     * Reads an int from this segment at the given offset, with the given layout.\n@@ -1205,1 +951,1 @@\n-     * @return a boolean value read from this segment.\n+     * @return an int value read from this segment.\n@@ -1216,2 +962,2 @@\n-    default boolean get(ValueLayout.OfBoolean layout, long offset) {\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n+    default int get(ValueLayout.OfInt layout, long offset) {\n+        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n@@ -1221,1 +967,1 @@\n-     * Writes a boolean into this segment at the given offset, with the given layout.\n+     * Writes an int into this segment at the given offset, with the given layout.\n@@ -1226,1 +972,1 @@\n-     * @param value the boolean value to be written.\n+     * @param value the int value to be written.\n@@ -1238,2 +984,2 @@\n-    default void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n+    default void set(ValueLayout.OfInt layout, long offset, int value) {\n+        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n@@ -1243,1 +989,1 @@\n-     * Reads a char from this segment at the given offset, with the given layout.\n+     * Reads a float from this segment at the given offset, with the given layout.\n@@ -1248,1 +994,1 @@\n-     * @return a char value read from this segment.\n+     * @return a float value read from this segment.\n@@ -1259,2 +1005,2 @@\n-    default char get(ValueLayout.OfChar layout, long offset) {\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n+    default float get(ValueLayout.OfFloat layout, long offset) {\n+        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n@@ -1264,1 +1010,1 @@\n-     * Writes a char into this segment at the given offset, with the given layout.\n+     * Writes a float into this segment at the given offset, with the given layout.\n@@ -1269,1 +1015,1 @@\n-     * @param value the char value to be written.\n+     * @param value the float value to be written.\n@@ -1281,2 +1027,2 @@\n-    default void set(ValueLayout.OfChar layout, long offset, char value) {\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n+    default void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n@@ -1286,1 +1032,1 @@\n-     * Reads a short from this segment at the given offset, with the given layout.\n+     * Reads a long from this segment at the given offset, with the given layout.\n@@ -1291,1 +1037,1 @@\n-     * @return a short value read from this segment.\n+     * @return a long value read from this segment.\n@@ -1302,2 +1048,2 @@\n-    default short get(ValueLayout.OfShort layout, long offset) {\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n+    default long get(ValueLayout.OfLong layout, long offset) {\n+        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n@@ -1307,1 +1053,1 @@\n-     * Writes a short into this segment at the given offset, with the given layout.\n+     * Writes a long into this segment at the given offset, with the given layout.\n@@ -1312,1 +1058,1 @@\n-     * @param value the short value to be written.\n+     * @param value the long value to be written.\n@@ -1324,2 +1070,2 @@\n-    default void set(ValueLayout.OfShort layout, long offset, short value) {\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n+    default void set(ValueLayout.OfLong layout, long offset, long value) {\n+        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n@@ -1329,1 +1075,1 @@\n-     * Reads an int from this segment at the given offset, with the given layout.\n+     * Reads a double from this segment at the given offset, with the given layout.\n@@ -1334,1 +1080,1 @@\n-     * @return an int value read from this segment.\n+     * @return a double value read from this segment.\n@@ -1345,2 +1091,2 @@\n-    default int get(ValueLayout.OfInt layout, long offset) {\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n+    default double get(ValueLayout.OfDouble layout, long offset) {\n+        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n@@ -1350,1 +1096,1 @@\n-     * Writes an int into this segment at the given offset, with the given layout.\n+     * Writes a double into this segment at the given offset, with the given layout.\n@@ -1355,1 +1101,1 @@\n-     * @param value the int value to be written.\n+     * @param value the double value to be written.\n@@ -1367,2 +1113,2 @@\n-    default void set(ValueLayout.OfInt layout, long offset, int value) {\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n+    default void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n@@ -1372,2 +1118,5 @@\n-     * Reads a float from this segment at the given offset, with the given layout.\n-     *\n+     * Reads an address from this segment at the given offset, with the given layout. The read address is wrapped in\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n+     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n+     * segment is {@code Long.MAX_VALUE}.\n@@ -1377,1 +1126,1 @@\n-     * @return a float value read from this segment.\n+     * @return a native segment wrapping an address read from this segment.\n@@ -1388,2 +1137,2 @@\n-    default float get(ValueLayout.OfFloat layout, long offset) {\n-        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n+    default MemorySegment get(ValueLayout.OfAddress layout, long offset) {\n+        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n@@ -1393,1 +1142,1 @@\n-     * Writes a float into this segment at the given offset, with the given layout.\n+     * Writes an address into this segment at the given offset, with the given layout.\n@@ -1398,1 +1147,1 @@\n-     * @param value the float value to be written.\n+     * @param value the address value to be written.\n@@ -1410,2 +1159,2 @@\n-    default void set(ValueLayout.OfFloat layout, long offset, float value) {\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n+    default void set(ValueLayout.OfAddress layout, long offset, MemorySegment value) {\n+        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n@@ -1415,1 +1164,1 @@\n-     * Reads a long from this segment at the given offset, with the given layout.\n+     * Reads a char from this segment at the given index, scaled by the given layout size.\n@@ -1418,3 +1167,3 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n-     * @return a long value read from this segment.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a char value read from this segment.\n@@ -1426,1 +1175,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n@@ -1431,2 +1181,4 @@\n-    default long get(ValueLayout.OfLong layout, long offset) {\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n+    default char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1436,1 +1188,1 @@\n-     * Writes a long into this segment at the given offset, with the given layout.\n+     * Writes a char into this segment at the given index, scaled by the given layout size.\n@@ -1439,3 +1191,3 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n-     * @param value the long value to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param value the char value to be written.\n@@ -1447,1 +1199,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n@@ -1453,23 +1206,4 @@\n-    default void set(ValueLayout.OfLong layout, long offset, long value) {\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a double from this segment at the given offset, with the given layout.\n-     *\n-     * @param layout the layout of the memory region to be read.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n-     * @return a double value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n-     *\/\n-    @ForceInline\n-    default double get(ValueLayout.OfDouble layout, long offset) {\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n+    default void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1479,1 +1213,1 @@\n-     * Writes a double into this segment at the given offset, with the given layout.\n+     * Reads a short from this segment at the given index, scaled by the given layout size.\n@@ -1481,25 +1215,0 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n-     * @param value the double value to be written.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n-     *\/\n-    @ForceInline\n-    default void set(ValueLayout.OfDouble layout, long offset, double value) {\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n-    }\n-\n-    \/**\n-     * Reads an address from this segment at the given offset, with the given layout. The read address is wrapped in\n-     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n-     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n-     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n-     * segment is {@code Long.MAX_VALUE}.\n@@ -1507,3 +1216,3 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + offset}.\n-     * @return a native segment wrapping an address read from this segment.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @return a short value read from this segment.\n@@ -1515,1 +1224,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n@@ -1520,2 +1230,4 @@\n-    default MemorySegment get(ValueLayout.OfAddress layout, long offset) {\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n+    default short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1525,1 +1237,1 @@\n-     * Writes an address into this segment at the given offset, with the given layout.\n+     * Writes a short into this segment at the given index, scaled by the given layout size.\n@@ -1528,3 +1240,3 @@\n-     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + offset}.\n-     * @param value the address value to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n@@ -1536,1 +1248,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n@@ -1542,2 +1255,4 @@\n-    default void set(ValueLayout.OfAddress layout, long offset, MemorySegment value) {\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n+    default void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1547,1 +1262,1 @@\n-     * Reads a char from this segment at the given index, scaled by the given layout size.\n+     * Reads an int from this segment at the given index, scaled by the given layout size.\n@@ -1552,1 +1267,1 @@\n-     * @return a char value read from this segment.\n+     * @return an int value read from this segment.\n@@ -1564,1 +1279,1 @@\n-    default char getAtIndex(ValueLayout.OfChar layout, long index) {\n+    default int getAtIndex(ValueLayout.OfInt layout, long index) {\n@@ -1567,1 +1282,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1571,1 +1286,1 @@\n-     * Writes a char into this segment at the given index, scaled by the given layout size.\n+     * Writes an int into this segment at the given index, scaled by the given layout size.\n@@ -1576,1 +1291,1 @@\n-     * @param value the char value to be written.\n+     * @param value the int value to be written.\n@@ -1589,1 +1304,1 @@\n-    default void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+    default void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n@@ -1592,1 +1307,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1596,1 +1311,1 @@\n-     * Reads a short from this segment at the given index, scaled by the given layout size.\n+     * Reads a float from this segment at the given index, scaled by the given layout size.\n@@ -1601,1 +1316,1 @@\n-     * @return a short value read from this segment.\n+     * @return a float value read from this segment.\n@@ -1613,1 +1328,1 @@\n-    default short getAtIndex(ValueLayout.OfShort layout, long index) {\n+    default float getAtIndex(ValueLayout.OfFloat layout, long index) {\n@@ -1616,1 +1331,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1620,1 +1335,1 @@\n-     * Writes a short into this segment at the given index, scaled by the given layout size.\n+     * Writes a float into this segment at the given index, scaled by the given layout size.\n@@ -1625,1 +1340,1 @@\n-     * @param value the short value to be written.\n+     * @param value the float value to be written.\n@@ -1638,1 +1353,1 @@\n-    default void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+    default void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n@@ -1641,1 +1356,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1645,1 +1360,1 @@\n-     * Reads an int from this segment at the given index, scaled by the given layout size.\n+     * Reads a long from this segment at the given index, scaled by the given layout size.\n@@ -1650,1 +1365,1 @@\n-     * @return an int value read from this segment.\n+     * @return a long value read from this segment.\n@@ -1662,1 +1377,1 @@\n-    default int getAtIndex(ValueLayout.OfInt layout, long index) {\n+    default long getAtIndex(ValueLayout.OfLong layout, long index) {\n@@ -1665,1 +1380,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1669,1 +1384,1 @@\n-     * Writes an int into this segment at the given index, scaled by the given layout size.\n+     * Writes a long into this segment at the given index, scaled by the given layout size.\n@@ -1674,1 +1389,1 @@\n-     * @param value the int value to be written.\n+     * @param value the long value to be written.\n@@ -1687,1 +1402,1 @@\n-    default void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+    default void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n@@ -1690,1 +1405,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1694,1 +1409,1 @@\n-     * Reads a float from this segment at the given index, scaled by the given layout size.\n+     * Reads a double from this segment at the given index, scaled by the given layout size.\n@@ -1699,1 +1414,1 @@\n-     * @return a float value read from this segment.\n+     * @return a double value read from this segment.\n@@ -1711,1 +1426,1 @@\n-    default float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+    default double getAtIndex(ValueLayout.OfDouble layout, long index) {\n@@ -1714,1 +1429,1 @@\n-        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1718,1 +1433,1 @@\n-     * Writes a float into this segment at the given index, scaled by the given layout size.\n+     * Writes a double into this segment at the given index, scaled by the given layout size.\n@@ -1723,1 +1438,1 @@\n-     * @param value the float value to be written.\n+     * @param value the double value to be written.\n@@ -1736,1 +1451,1 @@\n-    default void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+    default void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n@@ -1739,1 +1454,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n@@ -1743,1 +1458,5 @@\n-     * Reads a long from this segment at the given index, scaled by the given layout size.\n+     * Reads an address from this segment at the given at the given index, scaled by the given layout size. The read address is wrapped in\n+     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n+     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n+     * segment is {@code Long.MAX_VALUE}.\n@@ -1748,1 +1467,1 @@\n-     * @return a long value read from this segment.\n+     * @return a native segment wrapping an address read from this segment.\n@@ -1760,1 +1479,1 @@\n-    default long getAtIndex(ValueLayout.OfLong layout, long index) {\n+    default MemorySegment getAtIndex(ValueLayout.OfAddress layout, long index) {\n@@ -1763,1 +1482,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n@@ -1767,1 +1486,1 @@\n-     * Writes a long into this segment at the given index, scaled by the given layout size.\n+     * Writes an address into this segment at the given index, scaled by the given layout size.\n@@ -1772,1 +1491,1 @@\n-     * @param value the long value to be written.\n+     * @param value the address value to be written.\n@@ -1785,1 +1504,1 @@\n-    default void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+    default void setAtIndex(ValueLayout.OfAddress layout, long index, MemorySegment value) {\n@@ -1788,1 +1507,209 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n+    \/**\n+     * {@return the hash code value for this memory segment}\n+     *\/\n+    @Override\n+    int hashCode();\n+\n+    \/**\n+     * Compares the specified object with this memory segment for equality. Returns {@code true} if and only if the specified\n+     * object is also a memory segment, and if that segment refers to the same memory location as this segment. More specifically,\n+     * for two segments {@code s1} and {@code s2} to be considered equals, all the following must be true:\n+     * <ul>\n+     *     <li>{@code s1.array().equals(s2.array())}, that is, the two segments must be of the same kind;\n+     *     either both are {@linkplain #isNative() native segments}, backed by off-heap memory, or both are backed by\n+     *     the same on-heap Java array;\n+     *     <li>{@code s1.address() == s2.address()}, that is, the base address of the two segments should be the same.\n+     *     This means that the two segments either refer at the same off-heap memory location, or they refer\n+     *     to the same position inside their associated Java array instance.<\/li>\n+     * <\/ul>\n+     * @apiNote This method does not perform a structural comparison of the contents of the two memory segments. Clients can\n+     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead. Note that this\n+     * method does <em>not<\/em> compare the temporal and spatial bounds of two segments. As such it is suitable\n+     * to perform address checks, such as checking if a native memory segment has the {@code NULL} address.\n+     *\n+     * @param that the object to be compared for equality with this memory segment.\n+     * @return {@code true} if the specified object is equal to this memory segment.\n+     * @see #mismatch(MemorySegment)\n+     *\/\n+    @Override\n+    boolean equals(Object that);\n+\n+    \/**\n+     * Creates a buffer memory segment that models the memory associated with the given {@link Buffer} instance.\n+     * The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive).\n+     * <p>\n+     * If the buffer is {@linkplain ByteBuffer#isReadOnly() read-only}, the resulting segment will also be\n+     * {@linkplain ByteBuffer#isReadOnly() read-only}. The memory session associated with this segment can either be the\n+     * {@linkplain MemorySession#global() global} memory session, in case the buffer has been created independently,\n+     * or some other memory session, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * <p>\n+     * The resulting memory segment keeps a reference to the backing buffer, keeping it <em>reachable<\/em>.\n+     *\n+     * @param buffer the buffer instance backing the buffer memory segment.\n+     * @return a buffer memory segment.\n+     *\/\n+    static MemorySegment ofBuffer(Buffer buffer) {\n+        return AbstractMemorySegmentImpl.ofBuffer(buffer);\n+    }\n+\n+    \/**\n+     * Creates an array memory segment that models the memory associated with the given heap-allocated byte array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     *\n+     * @param byteArray the primitive array backing the array memory segment.\n+     * @return an array memory segment.\n+     *\/\n+    static MemorySegment ofArray(byte[] byteArray) {\n+        return HeapMemorySegmentImpl.OfByte.fromArray(byteArray);\n+    }\n+\n+    \/**\n+     * Creates an array memory segment that models the memory associated with the given heap-allocated char array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     *\n+     * @param charArray the primitive array backing the array memory segment.\n+     * @return an array memory segment.\n+     *\/\n+    static MemorySegment ofArray(char[] charArray) {\n+        return HeapMemorySegmentImpl.OfChar.fromArray(charArray);\n+    }\n+\n+    \/**\n+     * Creates an array memory segment that models the memory associated with the given heap-allocated short array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     *\n+     * @param shortArray the primitive array backing the array memory segment.\n+     * @return an array memory segment.\n+     *\/\n+    static MemorySegment ofArray(short[] shortArray) {\n+        return HeapMemorySegmentImpl.OfShort.fromArray(shortArray);\n+    }\n+\n+    \/**\n+     * Creates an array memory segment that models the memory associated with the given heap-allocated int array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     *\n+     * @param intArray the primitive array backing the array memory segment.\n+     * @return an array memory segment.\n+     *\/\n+    static MemorySegment ofArray(int[] intArray) {\n+        return HeapMemorySegmentImpl.OfInt.fromArray(intArray);\n+    }\n+\n+    \/**\n+     * Creates an array memory segment that models the memory associated with the given heap-allocated float array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     *\n+     * @param floatArray the primitive array backing the array memory segment.\n+     * @return an array memory segment.\n+     *\/\n+    static MemorySegment ofArray(float[] floatArray) {\n+        return HeapMemorySegmentImpl.OfFloat.fromArray(floatArray);\n+    }\n+\n+    \/**\n+     * Creates an array memory segment that models the memory associated with the given heap-allocated long array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     *\n+     * @param longArray the primitive array backing the array memory segment.\n+     * @return an array memory segment.\n+     *\/\n+    static MemorySegment ofArray(long[] longArray) {\n+        return HeapMemorySegmentImpl.OfLong.fromArray(longArray);\n+    }\n+\n+    \/**\n+     * Creates an array memory segment that models the memory associated with the given heap-allocated double array.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     *\n+     * @param doubleArray the primitive array backing the array memory segment.\n+     * @return an array memory segment.\n+     *\/\n+    static MemorySegment ofArray(double[] doubleArray) {\n+        return HeapMemorySegmentImpl.OfDouble.fromArray(doubleArray);\n+    }\n+\n+    \/**\n+     * Creates a zero-length native memory segment from the given {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, 0);\n+     *}\n+     * @param address the address of the returned native segment.\n+     * @return a zero-length native memory segment with the given address.\n+     *\/\n+    static MemorySegment ofAddress(long address) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, 0);\n+    }\n+\n+    \/**\n+     * Creates a native memory segment with the given size and {@linkplain #address() address value}.\n+     * The returned segment is associated with the {@linkplain MemorySession#global() global} memory session.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * ofAddress(address, byteSize, MemorySession.global());\n+     *}\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param address the address of the returned native segment.\n+     * @param byteSize the size (in bytes) of the returned native segment.\n+     * @return a zero-length native memory segment with the given address and size.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static MemorySegment ofAddress(long address, long byteSize) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n+        return MemorySegment.ofAddress(address, byteSize, MemorySession.global());\n+    }\n+\n+    \/**\n+     * Creates a native memory segment with the given size, base address, and memory session.\n+     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from foreign code\n+     * (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided memory session.\n+     * <p>\n+     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     *\n+     * @param address the returned segment's base address.\n+     * @param byteSize the desired size.\n+     * @param session the native segment memory session.\n+     * @return a native memory segment with the given base address, size and memory session.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is specified, but does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static MemorySegment ofAddress(long address,\n+                                   long byteSize,\n+                                   MemorySession session) {\n+\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n+        Objects.requireNonNull(session);\n+        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, session);\n@@ -1792,1 +1719,16 @@\n-     * Reads a double from this segment at the given index, scaled by the given layout size.\n+     * Creates a native memory segment with the given layout.\n+     * <p>\n+     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n+     * memory session. As such, the native memory region associated with the returned segment is\n+     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n+     * <p>\n+     * Native segments featuring deterministic deallocation can be obtained using the\n+     * {@link MemorySession#allocate(MemoryLayout)} method.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemorySession.openImplicit()\n+     *         .allocate(layout.bytesSize(), layout.bytesAlignment());\n+     * }\n+     * <p>\n+     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n@@ -1794,13 +1736,3 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n-     * @return a double value read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @param layout the layout of the off-heap memory block backing the native memory segment.\n+     * @return a new native memory segment.\n+     * @see MemorySession#allocate(MemoryLayout)\n@@ -1808,5 +1740,3 @@\n-    @ForceInline\n-    default double getAtIndex(ValueLayout.OfDouble layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    static MemorySegment allocateNative(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return allocateNative(layout.byteSize(), layout.byteAlignment());\n@@ -1816,1 +1746,18 @@\n-     * Writes a double into this segment at the given index, scaled by the given layout size.\n+     * Creates a native memory segment with the given size (in bytes).\n+     * <p>\n+     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n+     * memory session. As such, the native memory region associated with the returned segment is\n+     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n+     * <p>\n+     * Native segments featuring deterministic deallocation can be obtained using the\n+     * {@link MemorySession#allocate(long)}} method.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemorySession.openImplicit()\n+     *     .allocate(byteSize, 1)\n+     * }\n+     * <p>\n+     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n+     * <p>\n+     * This method corresponds to the {@link ByteBuffer#allocateDirect(int)} method and has similar behavior.\n@@ -1818,14 +1765,5 @@\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n-     * @param value the double value to be written.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}.\n+     * @see ByteBuffer#allocateDirect(int)\n+     * @see MemorySession#allocate(long)\n@@ -1833,5 +1771,2 @@\n-    @ForceInline\n-    default void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+    static MemorySegment allocateNative(long byteSize) {\n+        return allocateNative(byteSize, 1L);\n@@ -1841,5 +1776,16 @@\n-     * Reads an address from this segment at the given at the given index, scaled by the given layout size. The read address is wrapped in\n-     * a native segment, associated with the {@linkplain MemorySession#global() global} memory session. Under normal conditions,\n-     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n-     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n-     * segment is {@code Long.MAX_VALUE}.\n+     * Creates a native memory segment with the given size (in bytes) and alignment (in bytes).\n+     * <p>\n+     * The returned memory segment is associated with a new {@linkplain MemorySession#openImplicit implicit}\n+     * memory session. As such, the native memory region associated with the returned segment is\n+     * freed <em>automatically<\/em>, some unspecified time after it is no longer referenced.\n+     * <p>\n+     * Native segments featuring deterministic deallocation can be obtained using the\n+     * {@link MemorySession#allocate(long, long)} method.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemorySession.openImplicit()\n+     *     .allocate(byteSize, byteAlignment)\n+     * }\n+     * <p>\n+     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n@@ -1847,13 +1793,6 @@\n-     * @param layout the layout of the memory region to be read.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this read operation can be expressed as {@code address() + (index * layout.byteSize())}.\n-     * @return a native segment wrapping an address read from this segment.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n-     * {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n+     * @param byteSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param byteAlignment the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n+     * is not a power of 2.\n+     * @see MemorySession#allocate(long, long)\n@@ -1861,5 +1800,4 @@\n-    @ForceInline\n-    default MemorySegment getAtIndex(ValueLayout.OfAddress layout, long index) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    static MemorySegment allocateNative(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return MemorySession.openImplicit()\n+                .allocate(byteSize, byteAlignment);\n@@ -1869,7 +1807,23 @@\n-     * Writes an address into this segment at the given index, scaled by the given layout size.\n-     *\n-     * @param layout the layout of the memory region to be written.\n-     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n-     *               the final address of this write operation can be expressed as {@code address() + (index * layout.byteSize())}.\n-     * @param value the address value to be written.\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this segment is not\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemorySegment.copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+     * }\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n@@ -1878,7 +1832,9 @@\n-     * the {@linkplain #session() session} associated with this segment.\n-     * @throws IllegalArgumentException if the dereference operation is\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n-     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n-     * memory segment.\n-     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     * the {@linkplain #session() session} associated with {@code srcSegment}.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n@@ -1887,4 +1843,6 @@\n-    default void setAtIndex(ValueLayout.OfAddress layout, long index, MemorySegment value) {\n-        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n-        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+    static void copy(MemorySegment srcSegment,\n+                     long srcOffset,\n+                     MemorySegment dstSegment,\n+                     long dstOffset,\n+                     long bytes) {\n+        copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n@@ -1894,25 +1852,40 @@\n-     * Compares the specified object with this memory segment for equality. Returns {@code true} if and only if the specified\n-     * object is also a memory segment, and if that segment refers to the same memory location as this segment. More specifically,\n-     * for two segments {@code s1} and {@code s2} to be considered equals, all the following must be true:\n-     * <ul>\n-     *     <li>{@code s1.array().equals(s2.array())}, that is, the two segments must be of the same kind;\n-     *     either both are {@linkplain #isNative() native segments}, backed by off-heap memory, or both are backed by\n-     *     the same on-heap Java array;\n-     *     <li>{@code s1.address() == s2.address()}, that is, the base address of the two segments should be the same.\n-     *     This means that the two segments either refer at the same off-heap memory location, or they refer\n-     *     to the same position inside their associated Java array instance.<\/li>\n-     * <\/ul>\n-     * @apiNote This method does not perform a structural comparison of the contents of the two memory segments. Clients can\n-     * compare memory segments structurally by using the {@link #mismatch(MemorySegment)} method instead. Note that this\n-     * method does <em>not<\/em> compare the temporal and spatial bounds of two segments. As such it is suitable\n-     * to perform address checks, such as checking if a native memory segment has the {@code NULL} address.\n-     *\n-     * @param that the object to be compared for equality with this memory segment.\n-     * @return {@code true} if the specified object is equal to this memory segment.\n-     * @see #mismatch(MemorySegment)\n-     *\/\n-    @Override\n-    boolean equals(Object that);\n-\n-    \/**\n-     * {@return the hash code value for this memory segment}\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain FileChannel#map mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source (resp. destination) segment\/offset are\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraints<\/a> in the source\n+     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code srcSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with this {@code srcSegment}.\n+     * @throws IllegalStateException if the {@linkplain #session() session} associated with {@code dstSegment} is not\n+     * {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread owning\n+     * the {@linkplain #session() session} associated with {@code dstSegment}.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n@@ -1920,2 +1893,14 @@\n-    @Override\n-    int hashCode();\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment,\n+                     ValueLayout srcElementLayout,\n+                     long srcOffset,\n+                     MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout,\n+                     long dstOffset,\n+                     long elementCount) {\n+\n+        \/\/ Check the trivial invariants here\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n@@ -1923,0 +1908,2 @@\n+        Utils.copy(srcSegment, srcElementLayout, srcOffset, dstSegment, dstElementLayout, dstOffset, elementCount);\n+    }\n@@ -1946,3 +1933,7 @@\n-    static void copy(\n-            MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n-            Object dstArray, int dstIndex, int elementCount) {\n+    static void copy(MemorySegment srcSegment,\n+                     ValueLayout srcLayout,\n+                     long srcOffset,\n+                     Object dstArray,\n+                     int dstIndex,\n+                     int elementCount) {\n+        \/\/ Check the trivial invariants here\n@@ -1952,22 +1943,2 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n-        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n-        }\n-        int dstBase = (int)baseAndScale;\n-        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n-        }\n+\n+        Utils.copy(srcSegment, srcLayout, srcOffset, dstArray, dstIndex, elementCount);\n@@ -1998,3 +1969,7 @@\n-    static void copy(\n-            Object srcArray, int srcIndex,\n-            MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset, int elementCount) {\n+    static void copy(Object srcArray,\n+                     int srcIndex,\n+                     MemorySegment dstSegment,\n+                     ValueLayout dstLayout,\n+                     long dstOffset,\n+                     int elementCount) {\n+        \/\/ Check the trivial invariants here\n@@ -2004,23 +1979,0 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n-        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n-        }\n-        int srcBase = (int)baseAndScale;\n-        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n-        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n-        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n-        }\n-    }\n@@ -2028,18 +1980,1 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long)Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+        Utils.copy(srcArray, srcIndex, dstSegment, dstLayout, dstOffset, elementCount);\n@@ -2084,36 +2019,12 @@\n-    static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n-                         MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n-        long srcBytes = srcToOffset - srcFromOffset;\n-        long dstBytes = dstToOffset - dstFromOffset;\n-        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n-        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n-        if (dstImpl == srcImpl) {\n-            srcImpl.checkValidState();\n-            return -1;\n-        }\n-\n-        long bytes = Math.min(srcBytes, dstBytes);\n-        long i = 0;\n-        if (bytes > 7) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n-                return 0;\n-            }\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n-                    bytes);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = bytes - remaining;\n-        }\n-        for (; i < bytes; i++) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n-                return i;\n-            }\n-        }\n-        return srcBytes != dstBytes ? bytes : -1;\n+    static long mismatch(MemorySegment srcSegment,\n+                         long srcFromOffset,\n+                         long srcToOffset,\n+                         MemorySegment dstSegment,\n+                         long dstFromOffset,\n+                         long dstToOffset) {\n+\n+        \/\/ Check the trivial invariants here\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstSegment);\n+\n+        return Utils.mismatch(srcSegment,srcFromOffset,srcToOffset, dstSegment, dstFromOffset, dstToOffset);\n@@ -2121,0 +2032,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":718,"deletions":806,"binary":false,"changes":1524,"status":"modified"},{"patch":"@@ -132,1 +132,3 @@\n-public sealed interface MemorySession extends AutoCloseable, SegmentAllocator permits MemorySessionImpl, MemorySessionImpl.NonCloseableView {\n+public sealed interface MemorySession\n+        extends AutoCloseable, SegmentAllocator\n+        permits MemorySessionImpl, MemorySessionImpl.NonCloseableView {\n@@ -210,6 +212,0 @@\n-    \/**\n-     * {@return the hash code value for this memory session}\n-     *\/\n-    @Override\n-    int hashCode();\n-\n@@ -218,1 +214,1 @@\n-      * this memory session.\n+     * this memory session.\n@@ -234,1 +230,1 @@\n-    @Override\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,3 @@\n-public sealed interface PaddingLayout extends MemoryLayout permits PaddingLayoutImpl {\n+public sealed interface PaddingLayout\n+        extends MemoryLayout\n+        permits PaddingLayoutImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,21 @@\n+    \/**\n+     * Allocates a memory segment with the given layout.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout.byteSize(), layout.byteAlignment())}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    default MemorySegment allocate(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return allocate(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+    \/**\n+     * Allocates a memory segment with the given size and alignment constraints.\n+     * @param byteSize the size (in bytes) of the block of memory to be allocated.\n+     * @param byteAlignment the alignment (in bytes) of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code byteAlignment <= 0},\n+     * or if {@code alignmentBytes} is not a power of 2.\n+     *\/\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n+\n@@ -222,0 +243,27 @@\n+    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n+                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n+        int size = Array.getLength(Objects.requireNonNull(array));\n+        MemorySegment addr = allocateArray(Objects.requireNonNull(elementLayout), size);\n+        if (size > 0) {\n+            MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n+                    addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n+        }\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocates a memory segment with the given element layout and size.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(MemoryLayout.sequenceLayout(count, elementLayout))}.\n+     * @param elementLayout the array element layout.\n+     * @param count the array element count.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code count < 0}.\n+     *\/\n+    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+        Objects.requireNonNull(elementLayout);\n+        if (count < 0) {\n+            throw new IllegalArgumentException(\"Negative array size\");\n+        }\n+        return allocate(MemoryLayout.sequenceLayout(count, elementLayout));\n+    }\n+\n@@ -288,38 +336,0 @@\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n-        int size = Array.getLength(Objects.requireNonNull(array));\n-        MemorySegment addr = allocateArray(Objects.requireNonNull(elementLayout), size);\n-        if (size > 0) {\n-            MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n-                    addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n-        }\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocates a memory segment with the given layout.\n-     * @implSpec the default implementation for this method calls {@code this.allocate(layout.byteSize(), layout.byteAlignment())}.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     *\/\n-    default MemorySegment allocate(MemoryLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return allocate(layout.byteSize(), layout.byteAlignment());\n-    }\n-\n-    \/**\n-     * Allocates a memory segment with the given element layout and size.\n-     * @implSpec the default implementation for this method calls {@code this.allocate(MemoryLayout.sequenceLayout(count, elementLayout))}.\n-     * @param elementLayout the array element layout.\n-     * @param count the array element count.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code count < 0}.\n-     *\/\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n-        Objects.requireNonNull(elementLayout);\n-        if (count < 0) {\n-            throw new IllegalArgumentException(\"Negative array size\");\n-        }\n-        return allocate(MemoryLayout.sequenceLayout(count, elementLayout));\n-    }\n-\n@@ -328,2 +338,2 @@\n-     * @implSpec the default implementation for this method calls {@code this.allocate(bytesSize, 1)}.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(byteSize, 1)}.\n+     * @param byteSize the size (in bytes) of the block of memory to be allocated.\n@@ -331,1 +341,1 @@\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}\n+     * @throws IllegalArgumentException if {@code byteSize < 0}\n@@ -333,2 +343,2 @@\n-    default MemorySegment allocate(long bytesSize) {\n-        return allocate(bytesSize, 1);\n+    default MemorySegment allocate(long byteSize) {\n+        return allocate(byteSize, 1);\n@@ -337,10 +347,0 @@\n-    \/**\n-     * Allocates a memory segment with the given size and alignment constraints.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n-     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes <= 0},\n-     * or if {@code alignmentBytes} is not a power of 2.\n-     *\/\n-    MemorySegment allocate(long bytesSize, long bytesAlignment);\n-\n@@ -365,20 +365,0 @@\n-    \/**\n-     * Creates an arena-based allocator used to allocate native memory segments.\n-     * The returned allocator features a block size set to the specified arena size, and the native segments\n-     * it allocates are associated with the provided memory session. Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * SegmentAllocator.newNativeArena(arenaSize, arenaSize, session);\n-     * }\n-     *\n-     * @param arenaSize the size (in bytes) of the allocation arena.\n-     * @param session the memory session associated with the segments allocated by the arena-based allocator.\n-     * @return a new unbounded arena-based allocator\n-     * @throws IllegalArgumentException if {@code arenaSize <= 0}.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread other than the thread\n-     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n-     *\/\n-    static SegmentAllocator newNativeArena(long arenaSize, MemorySession session) {\n-        return newNativeArena(arenaSize, arenaSize, session);\n-    }\n-\n@@ -418,1 +398,4 @@\n-    static SegmentAllocator newNativeArena(long arenaSize, long blockSize, MemorySession session) {\n+    static SegmentAllocator newNativeArena(long arenaSize,\n+                                           long blockSize,\n+                                           MemorySession session) {\n+\n@@ -429,0 +412,20 @@\n+    \/**\n+     * Creates an arena-based allocator used to allocate native memory segments.\n+     * The returned allocator features a block size set to the specified arena size, and the native segments\n+     * it allocates are associated with the provided memory session. Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * SegmentAllocator.newNativeArena(arenaSize, arenaSize, session);\n+     * }\n+     *\n+     * @param arenaSize the size (in bytes) of the allocation arena.\n+     * @param session the memory session associated with the segments allocated by the arena-based allocator.\n+     * @return a new unbounded arena-based allocator\n+     * @throws IllegalArgumentException if {@code arenaSize <= 0}.\n+     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread other than the thread\n+     * {@linkplain MemorySession#ownerThread() owning} {@code session}.\n+     *\/\n+    static SegmentAllocator newNativeArena(long arenaSize, MemorySession session) {\n+        return newNativeArena(arenaSize, arenaSize, session);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":77,"deletions":74,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -56,1 +56,3 @@\n-public sealed interface SequenceLayout extends MemoryLayout permits SequenceLayoutImpl {\n+public sealed interface SequenceLayout\n+        extends MemoryLayout\n+        permits SequenceLayoutImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,3 @@\n-public sealed interface StructLayout extends GroupLayout permits StructLayoutImpl {\n+public sealed interface StructLayout\n+        extends GroupLayout\n+        permits StructLayoutImpl {\n@@ -46,1 +48,1 @@\n-    StructLayout withBitAlignment(long alignmentBits);\n+    StructLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n- *\n+ * <p>\n@@ -66,1 +66,1 @@\n- *\n+ * <p>\n@@ -78,2 +78,2 @@\n- *\n- * {@snippet lang=java :\n+ * <p>\n+ * {@snippet lang = java:\n@@ -84,2 +84,2 @@\n- * }\n- *\n+ *}\n+ * <p>\n@@ -93,1 +93,1 @@\n- *\n+ * <p>\n@@ -98,1 +98,1 @@\n- *\n+ * <p>\n@@ -101,1 +101,1 @@\n- *\n+ * <p>\n@@ -112,1 +112,1 @@\n- *\n+ * <p>\n@@ -119,1 +119,1 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -125,0 +125,1 @@\n+     *\n@@ -179,0 +180,8 @@\n+     *\n+     * @param name    the name of the library in which symbols should be looked up.\n+     * @param session the memory session which controls the library lifecycle.\n+     * @return a new symbol lookup suitable to find symbols in a library with the given name.\n+     * @throws IllegalArgumentException if {@code name} does not identify a valid library.\n+     * @throws IllegalCallerException   if access to this method occurs from a module {@code M} and the command line option\n+     *                                  {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     *                                  {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -187,8 +196,0 @@\n-     *\n-     * @param name the name of the library in which symbols should be looked up.\n-     * @param session the memory session which controls the library lifecycle.\n-     * @return a new symbol lookup suitable to find symbols in a library with the given name.\n-     * @throws IllegalArgumentException if {@code name} does not identify a valid library.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -212,3 +213,1 @@\n-     * @implNote On Linux, the functionalities provided by this factory method and the returned symbol lookup are\n-     * implemented using the {@code dlopen}, {@code dlsym} and {@code dlclose} functions.\n-     * @param path the path of the library in which symbols should be looked up.\n+     * @param path    the path of the library in which symbols should be looked up.\n@@ -218,3 +217,5 @@\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * @throws IllegalCallerException   if access to this method occurs from a module {@code M} and the command line option\n+     *                                  {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     *                                  {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * @implNote On Linux, the functionalities provided by this factory method and the returned symbol lookup are\n+     * implemented using the {@code dlopen}, {@code dlsym} and {@code dlclose} functions.\n@@ -228,1 +229,3 @@\n-    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, MemorySession session) {\n+    private static <Z> SymbolLookup libraryLookup(Z libDesc,\n+                                                  BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc,\n+                                                  MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -40,1 +40,3 @@\n-public sealed interface UnionLayout extends GroupLayout permits UnionLayoutImpl {\n+public sealed interface UnionLayout\n+        extends GroupLayout\n+        permits UnionLayoutImpl {\n@@ -46,1 +48,1 @@\n-    UnionLayout withBitAlignment(long alignmentBits);\n+    UnionLayout withBitAlignment(long bitAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,2 @@\n-public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n+public sealed interface VaList\n+        permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n@@ -106,1 +107,1 @@\n-     * @param layout the layout of the value to be read.\n+     * @param intLayout the intLayout of the value to be read.\n@@ -114,1 +115,1 @@\n-    int nextVarg(ValueLayout.OfInt layout);\n+    int nextVarg(ValueLayout.OfInt intLayout);\n@@ -120,1 +121,1 @@\n-     * @param layout the layout of the value to be read.\n+     * @param longLayout the longLayout of the value to be read.\n@@ -128,1 +129,1 @@\n-    long nextVarg(ValueLayout.OfLong layout);\n+    long nextVarg(ValueLayout.OfLong longLayout);\n@@ -134,1 +135,1 @@\n-     * @param layout the layout of the value\n+     * @param doubleLayout the doubleLayout of the value\n@@ -142,1 +143,1 @@\n-    double nextVarg(ValueLayout.OfDouble layout);\n+    double nextVarg(ValueLayout.OfDouble doubleLayout);\n@@ -149,2 +150,2 @@\n-     * segment is {@code 0}. However, if the provided layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded}\n-     * address layout, then the size of the returned segment is {@code Long.MAX_VALUE}.\n+     * segment is {@code 0}. However, if the provided addressLayout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded}\n+     * address addressLayout, then the size of the returned segment is {@code Long.MAX_VALUE}.\n@@ -152,1 +153,1 @@\n-     * @param layout the layout of the value to be read.\n+     * @param addressLayout the addressLayout of the value to be read.\n@@ -161,1 +162,1 @@\n-    MemorySegment nextVarg(ValueLayout.OfAddress layout);\n+    MemorySegment nextVarg(ValueLayout.OfAddress addressLayout);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.Objects;\n@@ -53,1 +52,162 @@\n-public sealed interface ValueLayout extends MemoryLayout {\n+public sealed interface ValueLayout\n+        extends MemoryLayout {\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * bit alignment set to {@code sizeof(size_t) * 8}, byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * ADDRESS.of(ByteOrder.nativeOrder())\n+     *             .withBitAlignment(<address size>);\n+     * }\n+     *\/\n+    OfAddress ADDRESS = ValueLayouts.OfAddressImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code byte},\n+     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_BYTE.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }\n+     *\/\n+    OfByte JAVA_BYTE = ValueLayouts.OfByteImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code boolean},\n+     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_BOOLEAN.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }\n+     *\/\n+    OfBoolean JAVA_BOOLEAN = ValueLayouts.OfBooleanImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code char},\n+     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_CHAR.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * }\n+     *\/\n+    OfChar JAVA_CHAR = ValueLayouts.OfCharImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code short},\n+     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_SHORT.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n+     * }\n+     *\/\n+    OfShort JAVA_SHORT = ValueLayouts.OfShortImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code int},\n+     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_INT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * }\n+     *\/\n+    OfInt JAVA_INT = ValueLayouts.OfIntImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code long},\n+     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_LONG.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * }\n+     *\/\n+    OfLong JAVA_LONG = ValueLayouts.OfLongImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code float},\n+     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_FLOAT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n+     * }\n+     *\/\n+    OfFloat JAVA_FLOAT = ValueLayouts.OfFloatImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code double},\n+     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_DOUBLE.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n+     * }\n+     *\/\n+    OfDouble JAVA_DOUBLE = ValueLayouts.OfDoubleImpl.of(ByteOrder.nativeOrder());\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * ADDRESS.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code char}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_CHAR.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code short}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_SHORT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code int}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_INT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code long}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_LONG.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code float}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_FLOAT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code double}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_DOUBLE.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n@@ -151,1 +311,1 @@\n-        OfBoolean withName(String name);\n+        OfBoolean withOrder(ByteOrder order);\n@@ -154,1 +314,1 @@\n-        OfBoolean withBitAlignment(long alignmentBits);\n+        OfBoolean withName(String name);\n@@ -157,1 +317,1 @@\n-        OfBoolean withOrder(ByteOrder order);\n+        OfBoolean withBitAlignment(long bitAlignment);\n@@ -172,1 +332,1 @@\n-        OfByte withName(String name);\n+        OfByte withOrder(ByteOrder order);\n@@ -175,1 +335,1 @@\n-        OfByte withBitAlignment(long alignmentBits);\n+        OfByte withName(String name);\n@@ -178,1 +338,1 @@\n-        OfByte withOrder(ByteOrder order);\n+        OfByte withBitAlignment(long bitAlignment);\n@@ -193,1 +353,1 @@\n-        OfChar withName(String name);\n+        OfChar withOrder(ByteOrder order);\n@@ -196,1 +356,1 @@\n-        OfChar withBitAlignment(long alignmentBits);\n+        OfChar withName(String name);\n@@ -199,1 +359,1 @@\n-        OfChar withOrder(ByteOrder order);\n+        OfChar withBitAlignment(long bitAlignment);\n@@ -214,1 +374,1 @@\n-        OfShort withName(String name);\n+        OfShort withOrder(ByteOrder order);\n@@ -217,1 +377,1 @@\n-        OfShort withBitAlignment(long alignmentBits);\n+        OfShort withName(String name);\n@@ -220,1 +380,1 @@\n-        OfShort withOrder(ByteOrder order);\n+        OfShort withBitAlignment(long bitAlignment);\n@@ -235,1 +395,1 @@\n-        OfInt withName(String name);\n+        OfInt withOrder(ByteOrder order);\n@@ -238,1 +398,1 @@\n-        OfInt withBitAlignment(long alignmentBits);\n+        OfInt withName(String name);\n@@ -241,1 +401,1 @@\n-        OfInt withOrder(ByteOrder order);\n+        OfInt withBitAlignment(long bitAlignment);\n@@ -256,1 +416,1 @@\n-        OfFloat withName(String name);\n+        OfFloat withOrder(ByteOrder order);\n@@ -259,1 +419,1 @@\n-        OfFloat withBitAlignment(long alignmentBits);\n+        OfFloat withName(String name);\n@@ -262,1 +422,1 @@\n-        OfFloat withOrder(ByteOrder order);\n+        OfFloat withBitAlignment(long bitAlignment);\n@@ -277,1 +437,1 @@\n-        OfLong withName(String name);\n+        OfLong withOrder(ByteOrder order);\n@@ -280,1 +440,1 @@\n-        OfLong withBitAlignment(long alignmentBits);\n+        OfLong withName(String name);\n@@ -283,1 +443,1 @@\n-        OfLong withOrder(ByteOrder order);\n+        OfLong withBitAlignment(long bitAlignment);\n@@ -298,1 +458,1 @@\n-        OfDouble withName(String name);\n+        OfDouble withOrder(ByteOrder order);\n@@ -301,1 +461,1 @@\n-        OfDouble withBitAlignment(long alignmentBits);\n+        OfDouble withName(String name);\n@@ -304,1 +464,1 @@\n-        OfDouble withOrder(ByteOrder order);\n+        OfDouble withBitAlignment(long bitAlignment);\n@@ -319,1 +479,1 @@\n-        OfAddress withName(String name);\n+        OfAddress withOrder(ByteOrder order);\n@@ -322,1 +482,1 @@\n-        OfAddress withBitAlignment(long alignmentBits);\n+        OfAddress withName(String name);\n@@ -325,1 +485,1 @@\n-        OfAddress withOrder(ByteOrder order);\n+        OfAddress withBitAlignment(long bitAlignment);\n@@ -351,175 +511,0 @@\n-    \/**\n-     * A value layout constant whose size is the same as that of a machine address ({@code size_t}),\n-     * bit alignment set to {@code sizeof(size_t) * 8}, byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * ADDRESS.of(ByteOrder.nativeOrder())\n-     *             .withBitAlignment(<address size>);\n-     * }\n-     *\/\n-    OfAddress ADDRESS = ValueLayouts.OfAddressImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code byte},\n-     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_BYTE.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n-     * }\n-     *\/\n-    OfByte JAVA_BYTE = ValueLayouts.OfByteImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code boolean},\n-     * bit alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_BOOLEAN.of(ByteOrder.nativeOrder()).withBitAlignment(8);\n-     * }\n-     *\/\n-    OfBoolean JAVA_BOOLEAN = ValueLayouts.OfBooleanImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code char},\n-     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_CHAR.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n-     * }\n-     *\/\n-    OfChar JAVA_CHAR = ValueLayouts.OfCharImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code short},\n-     * bit alignment set to 16, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_SHORT.of(ByteOrder.nativeOrder()).withBitAlignment(16);\n-     * }\n-     *\/\n-    OfShort JAVA_SHORT = ValueLayouts.OfShortImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code int},\n-     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_INT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n-     * }\n-     *\/\n-    OfInt JAVA_INT = ValueLayouts.OfIntImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code long},\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_LONG.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n-     * }\n-     *\/\n-    OfLong JAVA_LONG = ValueLayouts.OfLongImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code float},\n-     * bit alignment set to 32, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_FLOAT.of(ByteOrder.nativeOrder()).withBitAlignment(32);\n-     * }\n-     *\/\n-    OfFloat JAVA_FLOAT = ValueLayouts.OfFloatImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code double},\n-     * bit alignment set to 64, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_DOUBLE.of(ByteOrder.nativeOrder()).withBitAlignment(64);\n-     * }\n-     *\/\n-    OfDouble JAVA_DOUBLE = ValueLayouts.OfDoubleImpl.of(ByteOrder.nativeOrder());\n-\n-    \/**\n-     * An unaligned value layout constant whose size is the same as that of a machine address ({@code size_t}),\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * ADDRESS.withBitAlignment(8);\n-     * }\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n-     *\/\n-    OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n-\n-    \/**\n-     * An unaligned value layout constant whose size is the same as that of a Java {@code char}\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_CHAR.withBitAlignment(8);\n-     * }\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n-     *\/\n-    OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n-\n-    \/**\n-     * An unaligned value layout constant whose size is the same as that of a Java {@code short}\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_SHORT.withBitAlignment(8);\n-     * }\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n-     *\/\n-    OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n-\n-    \/**\n-     * An unaligned value layout constant whose size is the same as that of a Java {@code int}\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_INT.withBitAlignment(8);\n-     * }\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n-     *\/\n-    OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-\n-    \/**\n-     * An unaligned value layout constant whose size is the same as that of a Java {@code long}\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_LONG.withBitAlignment(8);\n-     * }\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n-     *\/\n-    OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n-\n-    \/**\n-     * An unaligned value layout constant whose size is the same as that of a Java {@code float}\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_FLOAT.withBitAlignment(8);\n-     * }\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n-     *\/\n-    OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-\n-    \/**\n-     * An unaligned value layout constant whose size is the same as that of a Java {@code double}\n-     * and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * JAVA_DOUBLE.withBitAlignment(8);\n-     * }\n-     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n-     *          performance and portability issues.\n-     *\/\n-    OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":189,"deletions":204,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n@@ -71,3 +72,0 @@\n-\n-    static final JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n-\n@@ -79,1 +77,3 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySession session) {\n+    AbstractMemorySegmentImpl(long length,\n+                              boolean readOnly,\n+                              MemorySession session) {\n@@ -85,1 +85,5 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return asSlice(0, byteSize);\n+    }    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n@@ -87,1 +91,3 @@\n-    abstract ByteBuffer makeByteBuffer();\n+    public void checkValidState() {\n+        sessionImpl().checkValidState();\n+    }    abstract ByteBuffer makeByteBuffer();\n@@ -90,0 +96,5 @@\n+    public RuntimeException apply(String s, List<Number> numbers) {\n+        long offset = numbers.get(0).longValue();\n+        long length = byteSize() - numbers.get(1).longValue() + 1;\n+        return outOfBoundException(offset, length);\n+    }    @Override\n@@ -95,0 +106,5 @@\n+    public int hashCode() {\n+        return Objects.hash(\n+                unsafeGetOffset(),\n+                unsafeGetBase());\n+    }    @Override\n@@ -100,0 +116,5 @@\n+    public boolean equals(Object o) {\n+        return o instanceof AbstractMemorySegmentImpl that &&\n+                unsafeGetBase() == that.unsafeGetBase() &&\n+                unsafeGetOffset() == that.unsafeGetOffset();\n+    }    @Override\n@@ -106,0 +127,3 @@\n+    public String toString() {\n+        return \"MemorySegment{ array: \" + array() + \" address:\" + address() + \" limit: \" + length + \" }\";\n+    }    @Override\n@@ -111,1 +135,34 @@\n-    private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {\n+    \/**\n+     * Mismatch over long lengths.\n+     *\/\n+    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession,\n+                                                       MemorySessionImpl bSession,\n+                                                       Object a,\n+                                                       long aOffset,\n+                                                       Object b,\n+                                                       long bOffset,\n+                                                       long length) {\n+        long off = 0;\n+        long remaining = length;\n+        int i, size;\n+        boolean lastSubRange = false;\n+        while (remaining > 7 && !lastSubRange) {\n+            if (remaining > Integer.MAX_VALUE) {\n+                size = Integer.MAX_VALUE;\n+            } else {\n+                size = (int) remaining;\n+                lastSubRange = true;\n+            }\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n+                    a, aOffset + off,\n+                    b, bOffset + off,\n+                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n+            if (i >= 0)\n+                return off + i;\n+\n+            i = size - ~i;\n+            off += i;\n+            remaining -= i;\n+        }\n+        return ~remaining;\n+    }    private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {\n@@ -115,1 +172,44 @@\n-    @Override\n+    public static AbstractMemorySegmentImpl ofBuffer(Buffer bb) {\n+        Objects.requireNonNull(bb);\n+        long bbAddress = NIO_ACCESS.getBufferAddress(bb);\n+        Object base = NIO_ACCESS.getBufferBase(bb);\n+        UnmapperProxy unmapper = NIO_ACCESS.unmapper(bb);\n+\n+        int pos = bb.position();\n+        int limit = bb.limit();\n+        int size = limit - pos;\n+\n+        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl) NIO_ACCESS.bufferSegment(bb);\n+        final MemorySession bufferSession;\n+        if (bufferSegment != null) {\n+            bufferSession = bufferSegment.session;\n+        } else {\n+            bufferSession = MemorySessionImpl.heapSession(bb);\n+        }\n+        boolean readOnly = bb.isReadOnly();\n+        int scaleFactor = getScaleFactor(bb);\n+        if (base != null) {\n+            if (base instanceof byte[]) {\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+            } else if (base instanceof short[]) {\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+            } else if (base instanceof char[]) {\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+            } else if (base instanceof int[]) {\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+            } else if (base instanceof float[]) {\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+            } else if (base instanceof long[]) {\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+            } else if (base instanceof double[]) {\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+            } else {\n+                throw new AssertionError(\"Cannot get here\");\n+            }\n+        } else if (unmapper == null) {\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferSession);\n+        } else {\n+            \/\/ we can ignore scale factor here, a mapped buffer is always a byte buffer, so scaleFactor == 0.\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferSession);\n+        }\n+    }    @Override\n@@ -132,1 +232,19 @@\n-    @Override\n+    private static int getScaleFactor(Buffer buffer) {\n+        if (buffer instanceof ByteBuffer) {\n+            return 0;\n+        } else if (buffer instanceof CharBuffer) {\n+            return 1;\n+        } else if (buffer instanceof ShortBuffer) {\n+            return 1;\n+        } else if (buffer instanceof IntBuffer) {\n+            return 2;\n+        } else if (buffer instanceof FloatBuffer) {\n+            return 2;\n+        } else if (buffer instanceof LongBuffer) {\n+            return 3;\n+        } else if (buffer instanceof DoubleBuffer) {\n+            return 3;\n+        } else {\n+            throw new AssertionError(\"Cannot get here\");\n+        }\n+    }    @Override\n@@ -137,1 +255,75 @@\n-    @Override\n+    static final class SegmentSplitter implements Spliterator<MemorySegment> {\n+        final long elementSize;\n+        AbstractMemorySegmentImpl segment;\n+        long elemCount;\n+        long currentIndex;\n+\n+        SegmentSplitter(long elementSize,\n+                        long elemCount,\n+                        AbstractMemorySegmentImpl segment) {\n+            this.segment = segment;\n+            this.elementSize = elementSize;\n+            this.elemCount = elemCount;\n+        }\n+\n+        @Override\n+        public boolean tryAdvance(Consumer<? super MemorySegment> action) {\n+            Objects.requireNonNull(action);\n+            if (currentIndex < elemCount) {\n+                AbstractMemorySegmentImpl acquired = segment;\n+                try {\n+                    action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));\n+                } finally {\n+                    currentIndex++;\n+                    if (currentIndex == elemCount) {\n+                        segment = null;\n+                    }\n+                }\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public void forEachRemaining(Consumer<? super MemorySegment> action) {\n+            Objects.requireNonNull(action);\n+            if (currentIndex < elemCount) {\n+                AbstractMemorySegmentImpl acquired = segment;\n+                try {\n+                    for (long i = currentIndex ; i < elemCount ; i++) {\n+                        action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));\n+                    }\n+                } finally {\n+                    currentIndex = elemCount;\n+                    segment = null;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public SegmentSplitter trySplit() {\n+            if (currentIndex == 0 && elemCount > 1) {\n+                AbstractMemorySegmentImpl parent = segment;\n+                long rem = elemCount % 2;\n+                long split = elemCount \/ 2;\n+                long lobound = split * elementSize;\n+                long hibound = lobound + (rem * elementSize);\n+                elemCount  = split + rem;\n+                segment = parent.asSliceNoCheck(lobound, hibound);\n+                return new SegmentSplitter(elementSize, split, parent.asSliceNoCheck(0, lobound));\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public long estimateSize() {\n+            return elemCount;\n+        }\n+\n+        @Override\n+        public int characteristics() {\n+            return NONNULL | SUBSIZED | SIZED | IMMUTABLE | ORDERED;\n+        }\n+    }    @Override\n@@ -144,5 +336,1 @@\n-    @Override\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        Utils.checkAllocationSizeAndAlign(bytesSize, bytesAlignment);\n-        return asSlice(0, bytesSize);\n-    }\n+\n@@ -156,24 +344,0 @@\n-    \/**\n-     * Mismatch over long lengths.\n-     *\/\n-    public static long vectorizedMismatchLargeForBytes(MemorySessionImpl aSession, MemorySessionImpl bSession,\n-                                                        Object a, long aOffset,\n-                                                        Object b, long bOffset,\n-                                                        long length) {\n-        long off = 0;\n-        long remaining = length;\n-        int i, size;\n-        boolean lastSubRange = false;\n-        while (remaining > 7 && !lastSubRange) {\n-            if (remaining > Integer.MAX_VALUE) {\n-                size = Integer.MAX_VALUE;\n-            } else {\n-                size = (int) remaining;\n-                lastSubRange = true;\n-            }\n-            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aSession, bSession,\n-                    a, aOffset + off,\n-                    b, bOffset + off,\n-                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n-            if (i >= 0)\n-                return off + i;\n@@ -181,6 +345,0 @@\n-            i = size - ~i;\n-            off += i;\n-            remaining -= i;\n-        }\n-        return ~remaining;\n-    }\n@@ -243,1 +401,1 @@\n-        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+        throw newUnsupportedOperationExceptionNotAMappedSegment();\n@@ -248,1 +406,1 @@\n-        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+        throw newUnsupportedOperationExceptionNotAMappedSegment();\n@@ -253,1 +411,1 @@\n-        throw new UnsupportedOperationException(\"Not a mapped segment\");\n+        throw newUnsupportedOperationExceptionNotAMappedSegment();\n@@ -258,0 +416,4 @@\n+        throw newUnsupportedOperationExceptionNotAMappedSegment();\n+    }\n+\n+    private static UnsupportedOperationException newUnsupportedOperationExceptionNotAMappedSegment() {\n@@ -262,2 +424,2 @@\n-    public final byte[] toArray(ValueLayout.OfByte elementLayout) {\n-        return toArray(byte[].class, elementLayout, byte[]::new, MemorySegment::ofArray);\n+    public final byte[] toArray(ValueLayout.OfByte byteLayout) {\n+        return toArray(byte[].class, byteLayout, byte[]::new, MemorySegment::ofArray);\n@@ -267,2 +429,2 @@\n-    public final short[] toArray(ValueLayout.OfShort elementLayout) {\n-        return toArray(short[].class, elementLayout, short[]::new, MemorySegment::ofArray);\n+    public final short[] toArray(ValueLayout.OfShort shortLayout) {\n+        return toArray(short[].class, shortLayout, short[]::new, MemorySegment::ofArray);\n@@ -272,2 +434,2 @@\n-    public final char[] toArray(ValueLayout.OfChar elementLayout) {\n-        return toArray(char[].class, elementLayout, char[]::new, MemorySegment::ofArray);\n+    public final char[] toArray(ValueLayout.OfChar charLayout) {\n+        return toArray(char[].class, charLayout, char[]::new, MemorySegment::ofArray);\n@@ -277,2 +439,2 @@\n-    public final int[] toArray(ValueLayout.OfInt elementLayout) {\n-        return toArray(int[].class, elementLayout, int[]::new, MemorySegment::ofArray);\n+    public final int[] toArray(ValueLayout.OfInt intLayout) {\n+        return toArray(int[].class, intLayout, int[]::new, MemorySegment::ofArray);\n@@ -282,2 +444,2 @@\n-    public final float[] toArray(ValueLayout.OfFloat elementLayout) {\n-        return toArray(float[].class, elementLayout, float[]::new, MemorySegment::ofArray);\n+    public final float[] toArray(ValueLayout.OfFloat floatLayout) {\n+        return toArray(float[].class, floatLayout, float[]::new, MemorySegment::ofArray);\n@@ -287,2 +449,2 @@\n-    public final long[] toArray(ValueLayout.OfLong elementLayout) {\n-        return toArray(long[].class, elementLayout, long[]::new, MemorySegment::ofArray);\n+    public final long[] toArray(ValueLayout.OfLong longLayout) {\n+        return toArray(long[].class, longLayout, long[]::new, MemorySegment::ofArray);\n@@ -292,2 +454,2 @@\n-    public final double[] toArray(ValueLayout.OfDouble elementLayout) {\n-        return toArray(double[].class, elementLayout, double[]::new, MemorySegment::ofArray);\n+    public final double[] toArray(ValueLayout.OfDouble doubleLayout) {\n+        return toArray(double[].class, doubleLayout, double[]::new, MemorySegment::ofArray);\n@@ -312,4 +474,0 @@\n-    public void checkValidState() {\n-        sessionImpl().checkValidState();\n-    }\n-\n@@ -320,2 +478,0 @@\n-    \/\/ Helper methods\n-\n@@ -350,7 +506,0 @@\n-    @Override\n-    public RuntimeException apply(String s, List<Number> numbers) {\n-        long offset = numbers.get(0).longValue();\n-        long length = byteSize() - numbers.get(1).longValue() + 1;\n-        return outOfBoundException(offset, length);\n-    }\n-\n@@ -367,159 +516,0 @@\n-    static class SegmentSplitter implements Spliterator<MemorySegment> {\n-        AbstractMemorySegmentImpl segment;\n-        long elemCount;\n-        final long elementSize;\n-        long currentIndex;\n-\n-        SegmentSplitter(long elementSize, long elemCount, AbstractMemorySegmentImpl segment) {\n-            this.segment = segment;\n-            this.elementSize = elementSize;\n-            this.elemCount = elemCount;\n-        }\n-\n-        @Override\n-        public SegmentSplitter trySplit() {\n-            if (currentIndex == 0 && elemCount > 1) {\n-                AbstractMemorySegmentImpl parent = segment;\n-                long rem = elemCount % 2;\n-                long split = elemCount \/ 2;\n-                long lobound = split * elementSize;\n-                long hibound = lobound + (rem * elementSize);\n-                elemCount  = split + rem;\n-                segment = parent.asSliceNoCheck(lobound, hibound);\n-                return new SegmentSplitter(elementSize, split, parent.asSliceNoCheck(0, lobound));\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public boolean tryAdvance(Consumer<? super MemorySegment> action) {\n-            Objects.requireNonNull(action);\n-            if (currentIndex < elemCount) {\n-                AbstractMemorySegmentImpl acquired = segment;\n-                try {\n-                    action.accept(acquired.asSliceNoCheck(currentIndex * elementSize, elementSize));\n-                } finally {\n-                    currentIndex++;\n-                    if (currentIndex == elemCount) {\n-                        segment = null;\n-                    }\n-                }\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        @Override\n-        public void forEachRemaining(Consumer<? super MemorySegment> action) {\n-            Objects.requireNonNull(action);\n-            if (currentIndex < elemCount) {\n-                AbstractMemorySegmentImpl acquired = segment;\n-                try {\n-                    for (long i = currentIndex ; i < elemCount ; i++) {\n-                        action.accept(acquired.asSliceNoCheck(i * elementSize, elementSize));\n-                    }\n-                } finally {\n-                    currentIndex = elemCount;\n-                    segment = null;\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public long estimateSize() {\n-            return elemCount;\n-        }\n-\n-        @Override\n-        public int characteristics() {\n-            return NONNULL | SUBSIZED | SIZED | IMMUTABLE | ORDERED;\n-        }\n-    }\n-\n-    \/\/ Object methods\n-\n-    @Override\n-    public String toString() {\n-        return \"MemorySegment{ array: \" + array() + \" address:\" + address() + \" limit: \" + length + \" }\";\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return o instanceof AbstractMemorySegmentImpl that &&\n-                unsafeGetBase() == that.unsafeGetBase() &&\n-                unsafeGetOffset() == that.unsafeGetOffset();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(\n-                unsafeGetOffset(),\n-                unsafeGetBase());\n-    }\n-\n-    public static AbstractMemorySegmentImpl ofBuffer(Buffer bb) {\n-        Objects.requireNonNull(bb);\n-        long bbAddress = nioAccess.getBufferAddress(bb);\n-        Object base = nioAccess.getBufferBase(bb);\n-        UnmapperProxy unmapper = nioAccess.unmapper(bb);\n-\n-        int pos = bb.position();\n-        int limit = bb.limit();\n-        int size = limit - pos;\n-\n-        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);\n-        final MemorySession bufferSession;\n-        if (bufferSegment != null) {\n-            bufferSession = bufferSegment.session;\n-        } else {\n-            bufferSession = MemorySessionImpl.heapSession(bb);\n-        }\n-        boolean readOnly = bb.isReadOnly();\n-        int scaleFactor = getScaleFactor(bb);\n-        if (base != null) {\n-            if (base instanceof byte[]) {\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n-            } else if (base instanceof short[]) {\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n-            } else if (base instanceof char[]) {\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n-            } else if (base instanceof int[]) {\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n-            } else if (base instanceof float[]) {\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n-            } else if (base instanceof long[]) {\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n-            } else if (base instanceof double[]) {\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n-            } else {\n-                throw new AssertionError(\"Cannot get here\");\n-            }\n-        } else if (unmapper == null) {\n-            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferSession);\n-        } else {\n-            \/\/ we can ignore scale factor here, a mapped buffer is always a byte buffer, so scaleFactor == 0.\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferSession);\n-        }\n-    }\n-\n-    private static int getScaleFactor(Buffer buffer) {\n-        if (buffer instanceof ByteBuffer) {\n-            return 0;\n-        } else if (buffer instanceof CharBuffer) {\n-            return 1;\n-        } else if (buffer instanceof ShortBuffer) {\n-            return 1;\n-        } else if (buffer instanceof IntBuffer) {\n-            return 2;\n-        } else if (buffer instanceof FloatBuffer) {\n-            return 2;\n-        } else if (buffer instanceof LongBuffer) {\n-            return 3;\n-        } else if (buffer instanceof DoubleBuffer) {\n-            return 3;\n-        } else {\n-            throw new AssertionError(\"Cannot get here\");\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":224,"deletions":234,"binary":false,"changes":458,"status":"modified"},{"patch":"@@ -35,5 +35,0 @@\n-\n-    private MemorySegment segment;\n-\n-    private long sp = 0L;\n-    private long size = 0;\n@@ -43,0 +38,3 @@\n+    private MemorySegment segment;\n+    private long sp = 0L;\n+    private long size = 0;\n@@ -44,1 +42,3 @@\n-    public ArenaAllocator(long blockSize, long arenaSize, MemorySession session) {\n+    public ArenaAllocator(long blockSize,\n+                          long arenaSize,\n+                          MemorySession session) {\n@@ -51,14 +51,2 @@\n-    MemorySegment trySlice(long bytesSize, long bytesAlignment) {\n-        long min = segment.address();\n-        long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n-        if (segment.byteSize() - start < bytesSize) {\n-            return null;\n-        } else {\n-            MemorySegment slice = segment.asSlice(start, bytesSize);\n-            sp = start + bytesSize;\n-            return slice;\n-        }\n-    }\n-\n-    private MemorySegment newSegment(long bytesSize, long bytesAlignment) {\n-        long allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n+    private MemorySegment newSegment(long byteSize, long byteAlignment) {\n+        long allocatedSize = Utils.alignUp(byteSize, byteAlignment);\n@@ -69,1 +57,1 @@\n-        return session.allocate(bytesSize, bytesAlignment);\n+        return session.allocate(byteSize, byteAlignment);\n@@ -73,2 +61,2 @@\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        Utils.checkAllocationSizeAndAlign(bytesSize, bytesAlignment);\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n@@ -77,1 +65,1 @@\n-        MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+        MemorySegment slice = trySlice(byteSize, byteAlignment);\n@@ -81,1 +69,1 @@\n-            long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n+            long maxPossibleAllocationSize = byteSize + byteAlignment - 1;\n@@ -86,1 +74,1 @@\n-                return newSegment(bytesSize, bytesAlignment);\n+                return newSegment(byteSize, byteAlignment);\n@@ -91,1 +79,1 @@\n-                slice = trySlice(bytesSize, bytesAlignment);\n+                slice = trySlice(byteSize, byteAlignment);\n@@ -96,0 +84,12 @@\n+\n+    MemorySegment trySlice(long byteSize, long byteAlignment) {\n+        long min = segment.address();\n+        long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+        if (segment.byteSize() - start < byteSize) {\n+            return null;\n+        } else {\n+            MemorySegment slice = segment.asSlice(start, byteSize);\n+            sp = start + byteSize;\n+            return slice;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-    private int asyncReleaseCount = 0;\n-\n@@ -54,0 +52,3 @@\n+    \/\/ Accessed via the VarHandle ASYNC_RELEASE_COUNT\n+    private int asyncReleaseCount = 0;\n+\n@@ -58,10 +59,0 @@\n-    @Override\n-    @ForceInline\n-    public void acquire0() {\n-        checkValidState();\n-        if (state == MAX_FORKS) {\n-            throw tooManyAcquires();\n-        }\n-        state++;\n-    }\n-\n@@ -82,0 +73,10 @@\n+    @Override\n+    @ForceInline\n+    public void acquire0() {\n+        checkValidState();\n+        if (state == MAX_FORKS) {\n+            throw tooManyAcquires();\n+        }\n+        state++;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,7 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -29,1 +36,0 @@\n-import java.util.*;\n@@ -34,2 +40,0 @@\n-import static java.util.Objects.requireNonNull;\n-\n@@ -63,15 +67,0 @@\n-    \/**\n-     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n-     * function descriptor argument layouts. The resulting function descriptor can report the position\n-     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n-     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n-     * will throw an {@link UnsupportedOperationException}.\n-     *\n-     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n-     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n-     *\/\n-    public final FunctionDescriptorImpl asVariadic(MemoryLayout... variadicLayouts) {\n-        \/\/ Null checks are implicit in the constructor of VariadicFunction\n-        return variadicLayouts.length == 0 ? this : new VariadicFunctionDescriptor(this, variadicLayouts);\n-    }\n-\n@@ -126,1 +115,1 @@\n-        requireNonNull(newReturn);\n+        Objects.requireNonNull(newReturn);\n@@ -140,10 +129,0 @@\n-    private static Class<?> carrierTypeFor(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout valueLayout) {\n-            return valueLayout.carrier();\n-        } else if (layout instanceof GroupLayout) {\n-            return MemorySegment.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n-        }\n-    }\n-\n@@ -161,1 +140,16 @@\n-     * {@return the string representation of this function descriptor}\n+     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n+     * function descriptor argument layouts. The resulting function descriptor can report the position\n+     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n+     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n+     * will throw an {@link UnsupportedOperationException}.\n+     *\n+     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n+     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n+     *\/\n+    public final FunctionDescriptorImpl asVariadic(MemoryLayout... variadicLayouts) {\n+        \/\/ Null checks are implicit in the constructor of VariadicFunction\n+        return variadicLayouts.length == 0 ? this : new VariadicFunctionDescriptor(this, variadicLayouts);\n+    }\n+\n+    \/**\n+     * {@return the hash code value for this function descriptor}\n@@ -164,7 +158,2 @@\n-    public final String toString() {\n-        return String.format(\"(%s)%s\",\n-                IntStream.range(0, argLayouts.size())\n-                        .mapToObj(i -> (i == firstVariadicArgumentIndex() ?\n-                                \"...\" : \"\") + argLayouts.get(i))\n-                        .collect(Collectors.joining()),\n-                returnLayout().map(Object::toString).orElse(\"v\"));\n+    public final int hashCode() {\n+        return Objects.hash(argLayouts, resLayout, firstVariadicArgumentIndex());\n@@ -194,1 +183,1 @@\n-     * {@return the hash code value for this function descriptor}\n+     * {@return the string representation of this function descriptor}\n@@ -197,2 +186,19 @@\n-    public final int hashCode() {\n-        return Objects.hash(argLayouts, resLayout, firstVariadicArgumentIndex());\n+    public final String toString() {\n+        return String.format(\"(%s)%s\",\n+                IntStream.range(0, argLayouts.size())\n+                        .mapToObj(i -> (i == firstVariadicArgumentIndex() ?\n+                                \"...\" : \"\") + argLayouts.get(i))\n+                        .collect(Collectors.joining()),\n+                returnLayout()\n+                        .map(Object::toString)\n+                        .orElse(\"v\"));\n+    }\n+\n+    private static Class<?> carrierTypeFor(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n@@ -222,1 +228,3 @@\n-                    Stream.concat(descriptor.argumentLayouts().stream(), Arrays.stream(argLayouts).map(Objects::requireNonNull)).toList());\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Arrays.stream(argLayouts)\n+                            .map(Objects::requireNonNull))\n+                            .toList());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":49,"deletions":41,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -64,5 +64,0 @@\n-    @Override\n-    public Optional<Object> array() {\n-        return Optional.of(base);\n-    }\n-\n@@ -70,1 +65,4 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly) {\n+    HeapMemorySegmentImpl(long offset,\n+                          Object base,\n+                          long length,\n+                          boolean readOnly) {\n@@ -77,2 +75,2 @@\n-    public long unsafeGetOffset() {\n-        return offset;\n+    public Optional<Object> array() {\n+        return Optional.of(base);\n@@ -82,1 +80,4 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session);\n+    abstract HeapMemorySegmentImpl dup(long offset,\n+                                       long size,\n+                                       boolean readOnly,\n+                                       MemorySession session);\n@@ -93,0 +94,5 @@\n+    @Override\n+    public long unsafeGetOffset() {\n+        return offset;\n+    }\n+\n@@ -111,6 +117,0 @@\n-        public static MemorySegment fromArray(byte[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false);\n-        }\n-\n@@ -126,0 +126,6 @@\n+\n+        public static MemorySegment fromArray(byte[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false);\n+        }\n@@ -144,6 +150,0 @@\n-        public static MemorySegment fromArray(char[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false);\n-        }\n-\n@@ -159,0 +159,6 @@\n+\n+        public static MemorySegment fromArray(char[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false);\n+        }\n@@ -177,6 +183,0 @@\n-        public static MemorySegment fromArray(short[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false);\n-        }\n-\n@@ -192,0 +192,6 @@\n+\n+        public static MemorySegment fromArray(short[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false);\n+        }\n@@ -210,6 +216,0 @@\n-        public static MemorySegment fromArray(int[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false);\n-        }\n-\n@@ -225,0 +225,6 @@\n+\n+        public static MemorySegment fromArray(int[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false);\n+        }\n@@ -243,6 +249,0 @@\n-        public static MemorySegment fromArray(long[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false);\n-        }\n-\n@@ -258,0 +258,6 @@\n+\n+        public static MemorySegment fromArray(long[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false);\n+        }\n@@ -276,6 +282,0 @@\n-        public static MemorySegment fromArray(float[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false);\n-        }\n-\n@@ -291,0 +291,6 @@\n+\n+        public static MemorySegment fromArray(float[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false);\n+        }\n@@ -309,6 +315,0 @@\n-        public static MemorySegment fromArray(double[] arr) {\n-            Objects.requireNonNull(arr);\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false);\n-        }\n-\n@@ -324,0 +324,6 @@\n+\n+        public static MemorySegment fromArray(double[] arr) {\n+            Objects.requireNonNull(arr);\n+            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":57,"deletions":51,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -52,1 +52,4 @@\n-public class LayoutPath {\n+public final class LayoutPath {\n+\n+    private static final long[] EMPTY_STRIDES = new long[0];\n+    private static final long[] EMPTY_BOUNDS = new long[0];\n@@ -76,1 +79,5 @@\n-    private LayoutPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath enclosing) {\n+    private LayoutPath(MemoryLayout layout,\n+                       long offset,\n+                       long[] strides,\n+                       long[] bounds,\n+                       LayoutPath enclosing) {\n@@ -93,0 +100,32 @@\n+    private void check(Class<?> layoutClass, String msg) {\n+        if (!layoutClass.isAssignableFrom(layout.getClass())) {\n+            throw badLayoutPath(msg);\n+        }\n+    }\n+\n+    private static LayoutPath nestedPath(MemoryLayout layout,\n+                                         long offset,\n+                                         long[] strides,\n+                                         long[] bounds,\n+                                         LayoutPath encl) {\n+        return new LayoutPath(layout, offset, strides, bounds, encl);\n+    }\n+\n+    private long[] addStride(long stride) {\n+        long[] newStrides = Arrays.copyOf(strides, strides.length + 1);\n+        newStrides[strides.length] = stride;\n+        return newStrides;\n+    }\n+\n+    \/\/ Layout path projections\n+\n+    private long[] addBound(long maxIndex) {\n+        long[] newBounds = Arrays.copyOf(bounds, bounds.length + 1);\n+        newBounds[bounds.length] = maxIndex;\n+        return newBounds;\n+    }\n+\n+    private static IllegalArgumentException badLayoutPath(String cause) {\n+        return new IllegalArgumentException(\"Bad layout path: \" + cause);\n+    }\n+\n@@ -107,0 +146,6 @@\n+    private void checkSequenceBounds(SequenceLayout seq, long index) {\n+        if (index >= seq.elementCount()) {\n+            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n+        }\n+    }\n+\n@@ -137,1 +182,1 @@\n-    \/\/ Layout path projections\n+    \/\/ Layout path construction\n@@ -163,17 +208,1 @@\n-    @ForceInline\n-    private static long addScaledOffset(long base, long index, long stride, long bound) {\n-        Objects.checkIndex(index, bound);\n-        return base + (stride * index);\n-    }\n-\n-    public MethodHandle offsetHandle() {\n-        MethodHandle mh = MethodHandles.identity(long.class);\n-        for (int i = strides.length - 1; i >=0; i--) {\n-            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2, strides[i], bounds[i]);\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            mh = MethodHandles.collectArguments(mh, 0, collector);\n-        }\n-        mh = MethodHandles.insertArguments(mh, 0, offset);\n-        return mh;\n-    }\n+    \/\/ Helper methods\n@@ -184,1 +213,1 @@\n-            Utils.bitsToBytesOrThrow(offset, Utils.bitsToBytesThrowOffset);\n+            Utils.bitsToBytesOrThrow(offset, Utils.BITS_TO_BYTES_THROW_OFFSET);\n@@ -188,1 +217,1 @@\n-        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_bitsToBytesOrThrowForOffset); \/\/ byte offset\n+        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET); \/\/ byte offset\n@@ -197,0 +226,12 @@\n+    public MethodHandle offsetHandle() {\n+        MethodHandle mh = MethodHandles.identity(long.class);\n+        for (int i = strides.length - 1; i >=0; i--) {\n+            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2, strides[i], bounds[i]);\n+            \/\/ (J, ...) -> J to (J, J, ...) -> J\n+            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n+            mh = MethodHandles.collectArguments(mh, 0, collector);\n+        }\n+        mh = MethodHandles.insertArguments(mh, 0, offset);\n+        return mh;\n+    }\n+\n@@ -201,2 +242,0 @@\n-    \/\/ Layout path construction\n-\n@@ -207,20 +246,4 @@\n-    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath encl) {\n-        return new LayoutPath(layout, offset, strides, bounds, encl);\n-    }\n-\n-    \/\/ Helper methods\n-\n-    private void check(Class<?> layoutClass, String msg) {\n-        if (!layoutClass.isAssignableFrom(layout.getClass())) {\n-            throw badLayoutPath(msg);\n-        }\n-    }\n-\n-    private void checkSequenceBounds(SequenceLayout seq, long index) {\n-        if (index >= seq.elementCount()) {\n-            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n-        }\n-    }\n-\n-    private static IllegalArgumentException badLayoutPath(String cause) {\n-        return new IllegalArgumentException(\"Bad layout path: \" + cause);\n+    @ForceInline\n+    private static long addScaledOffset(long base, long index, long stride, long bound) {\n+        Objects.checkIndex(index, bound);\n+        return base + (stride * index);\n@@ -249,15 +272,0 @@\n-    private long[] addStride(long stride) {\n-        long[] newStrides = Arrays.copyOf(strides, strides.length + 1);\n-        newStrides[strides.length] = stride;\n-        return newStrides;\n-    }\n-\n-    private long[] addBound(long maxIndex) {\n-        long[] newBounds = Arrays.copyOf(bounds, bounds.length + 1);\n-        newBounds[bounds.length] = maxIndex;\n-        return newBounds;\n-    }\n-\n-    private static final long[] EMPTY_STRIDES = new long[0];\n-    private static final long[] EMPTY_BOUNDS = new long[0];\n-\n@@ -270,0 +278,16 @@\n+        final PathKind kind;\n+        final UnaryOperator<LayoutPath> pathOp;\n+        public PathElementImpl(PathKind kind, UnaryOperator<LayoutPath> pathOp) {\n+            this.kind = kind;\n+            this.pathOp = pathOp;\n+        }\n+\n+        @Override\n+        public LayoutPath apply(LayoutPath layoutPath) {\n+            return pathOp.apply(layoutPath);\n+        }\n+\n+        public PathKind kind() {\n+            return kind;\n+        }\n+\n@@ -286,17 +310,0 @@\n-\n-        final PathKind kind;\n-        final UnaryOperator<LayoutPath> pathOp;\n-\n-        public PathElementImpl(PathKind kind, UnaryOperator<LayoutPath> pathOp) {\n-            this.kind = kind;\n-            this.pathOp = pathOp;\n-        }\n-\n-        @Override\n-        public LayoutPath apply(LayoutPath layoutPath) {\n-            return pathOp.apply(layoutPath);\n-        }\n-\n-        public PathKind kind() {\n-            return kind;\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":83,"deletions":76,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-    private final UnmapperProxy unmapper;\n-\n@@ -45,0 +43,1 @@\n+    private final UnmapperProxy unmapper;\n@@ -46,1 +45,5 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySession session) {\n+    public MappedMemorySegmentImpl(long min,\n+                                   UnmapperProxy unmapper,\n+                                   long length,\n+                                   boolean readOnly,\n+                                   MemorySession session) {\n@@ -52,3 +55,5 @@\n-    ByteBuffer makeByteBuffer() {\n-        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null,\n-                session == MemorySessionImpl.GLOBAL ? null : this);\n+    MappedMemorySegmentImpl dup(long offset,\n+                                long size,\n+                                boolean readOnly,\n+                                MemorySession session) {\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, session);\n@@ -58,2 +63,3 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySession session) {\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, session);\n+    ByteBuffer makeByteBuffer() {\n+        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null,\n+                session == MemorySessionImpl.GLOBAL ? null : this);\n@@ -76,4 +82,0 @@\n-    public MemorySegment segment() {\n-        return MappedMemorySegmentImpl.this;\n-    }\n-\n@@ -96,0 +98,4 @@\n+    public MemorySegment segment() {\n+        return MappedMemorySegmentImpl.this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -58,3 +58,0 @@\n-    final ResourceList resourceList;\n-    final Cleaner.Cleanable cleanable;\n-    final Thread owner;\n@@ -62,0 +59,1 @@\n+    public static final MemorySessionImpl GLOBAL = new GlobalSessionImpl(null);\n@@ -65,3 +63,0 @@\n-\n-    int state = OPEN;\n-\n@@ -69,0 +64,3 @@\n+    static final int MAX_FORKS = Integer.MAX_VALUE;\n+    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n+    static final ScopedMemoryAccess.ScopedAccessError WRONG_THREAD = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::wrongThread);\n@@ -78,1 +76,4 @@\n-    static final int MAX_FORKS = Integer.MAX_VALUE;\n+    final ResourceList resourceList;\n+    final Cleaner.Cleanable cleanable;\n+    final Thread owner;\n+    int state = OPEN;\n@@ -80,4 +81,7 @@\n-    @Override\n-    public void addCloseAction(Runnable runnable) {\n-        Objects.requireNonNull(runnable);\n-        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n+    protected MemorySessionImpl(Thread owner,\n+                                ResourceList resourceList,\n+                                Cleaner cleaner) {\n+        this.owner = owner;\n+        this.resourceList = resourceList;\n+        cleanable = (cleaner != null) ?\n+            cleaner.register(this, resourceList) : null;\n@@ -105,20 +109,3 @@\n-    void addInternal(ResourceList.ResourceCleanup resource) {\n-        checkValidState();\n-        \/\/ Note: from here on we no longer check the session state. Two cases are possible: either the resource cleanup\n-        \/\/ is added to the list when the session is still open, in which case everything works ok; or the resource\n-        \/\/ cleanup is added while the session is being closed. In this latter case, what matters is whether we have already\n-        \/\/ called `ResourceList::cleanup` to run all the cleanup actions. If not, we can still add this resource\n-        \/\/ to the list (and, in case of an add vs. close race, it might happen that the cleanup action will be\n-        \/\/ called immediately after).\n-        resourceList.add(resource);\n-    }\n-\n-    protected MemorySessionImpl(Thread owner, ResourceList resourceList, Cleaner cleaner) {\n-        this.owner = owner;\n-        this.resourceList = resourceList;\n-        cleanable = (cleaner != null) ?\n-            cleaner.register(this, resourceList) : null;\n-    }\n-\n-    public static MemorySession createConfined(Thread thread, Cleaner cleaner) {\n-        return new ConfinedSession(thread, cleaner);\n+    @Override\n+    public final int hashCode() {\n+        return super.hashCode();\n@@ -127,2 +114,4 @@\n-    public static MemorySession createShared(Cleaner cleaner) {\n-        return new SharedSession(cleaner);\n+    @Override\n+    public final boolean equals(Object o) {\n+        return (o instanceof MemorySession other) &&\n+            toSessionImpl(other) == this;\n@@ -131,2 +120,4 @@\n-    public static MemorySessionImpl createImplicit() {\n-        return new ImplicitSession();\n+    @ForceInline\n+    public static MemorySessionImpl toSessionImpl(MemorySession session) {\n+        return session instanceof MemorySessionImpl sessionImpl ?\n+                sessionImpl : ((NonCloseableView)session).session;\n@@ -136,3 +127,2 @@\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        Utils.checkAllocationSizeAndAlign(bytesSize, bytesAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, bytesAlignment, this);\n+    protected Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n@@ -141,3 +131,7 @@\n-    public abstract void release0();\n-\n-    public abstract void acquire0();\n+    \/**\n+     * Returns true, if this session is still open. This method may be called in any thread.\n+     * @return {@code true} if this session is not closed yet.\n+     *\/\n+    public boolean isAlive() {\n+        return state >= OPEN;\n+    }\n@@ -146,3 +140,2 @@\n-    public final boolean equals(Object o) {\n-        return (o instanceof MemorySession other) &&\n-            toSessionImpl(other) == this;\n+    public boolean isCloseable() {\n+        return true;\n@@ -151,3 +144,6 @@\n-    @Override\n-    public final int hashCode() {\n-        return super.hashCode();\n+    \/**\n+     * Returns \"owner\" thread of this session.\n+     * @return owner thread (or null for a shared session)\n+     *\/\n+    public final Thread ownerThread() {\n+        return owner;\n@@ -167,14 +163,4 @@\n-    \/**\n-     * Returns \"owner\" thread of this session.\n-     * @return owner thread (or null for a shared session)\n-     *\/\n-    public final Thread ownerThread() {\n-        return owner;\n-    }\n-\n-    \/**\n-     * Returns true, if this session is still open. This method may be called in any thread.\n-     * @return {@code true} if this session is not closed yet.\n-     *\/\n-    public boolean isAlive() {\n-        return state >= OPEN;\n+    @Override\n+    public void addCloseAction(Runnable runnable) {\n+        Objects.requireNonNull(runnable);\n+        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n@@ -183,4 +169,9 @@\n-    @Override\n-    public MemorySession asNonCloseable() {\n-        return isCloseable() ?\n-                new NonCloseableView(this) : this;\n+    void addInternal(ResourceList.ResourceCleanup resource) {\n+        checkValidState();\n+        \/\/ Note: from here on we no longer check the session state. Two cases are possible: either the resource cleanup\n+        \/\/ is added to the list when the session is still open, in which case everything works ok; or the resource\n+        \/\/ cleanup is added while the session is being closed. In this latter case, what matters is whether we have already\n+        \/\/ called `ResourceList::cleanup` to run all the cleanup actions. If not, we can still add this resource\n+        \/\/ to the list (and, in case of an add vs. close race, it might happen that the cleanup action will be\n+        \/\/ called immediately after).\n+        resourceList.add(resource);\n@@ -189,4 +180,11 @@\n-    @ForceInline\n-    public static MemorySessionImpl toSessionImpl(MemorySession session) {\n-        return session instanceof MemorySessionImpl sessionImpl ?\n-                sessionImpl : ((NonCloseableView)session).session;\n+    \/**\n+     * Checks that this session is still alive (see {@link #isAlive()}).\n+     * @throws IllegalStateException if this session is already closed or if this is\n+     * a confined session and this method is called outside of the owner thread.\n+     *\/\n+    public void checkValidState() {\n+        try {\n+            checkValidStateRaw();\n+        } catch (ScopedMemoryAccess.ScopedAccessError error) {\n+            throw error.newRuntimeException();\n+        }\n@@ -213,23 +211,0 @@\n-    \/**\n-     * Checks that this session is still alive (see {@link #isAlive()}).\n-     * @throws IllegalStateException if this session is already closed or if this is\n-     * a confined session and this method is called outside of the owner thread.\n-     *\/\n-    public void checkValidState() {\n-        try {\n-            checkValidStateRaw();\n-        } catch (ScopedMemoryAccess.ScopedAccessError error) {\n-            throw error.newRuntimeException();\n-        }\n-    }\n-\n-    @Override\n-    protected Object clone() throws CloneNotSupportedException {\n-        throw new CloneNotSupportedException();\n-    }\n-\n-    @Override\n-    public boolean isCloseable() {\n-        return true;\n-    }\n-\n@@ -255,0 +230,12 @@\n+    @Override\n+    public MemorySession asNonCloseable() {\n+        return isCloseable() ?\n+                new NonCloseableView(this) : this;\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        Utils.checkAllocationSizeAndAlign(bytesSize, bytesAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, bytesAlignment, this);\n+    }\n+\n@@ -257,0 +244,42 @@\n+    public abstract void acquire0();\n+\n+    public abstract void release0();\n+\n+    public static MemorySession createConfined(Thread thread, Cleaner cleaner) {\n+        return new ConfinedSession(thread, cleaner);\n+    }\n+\n+    public static MemorySession createShared(Cleaner cleaner) {\n+        return new SharedSession(cleaner);\n+    }\n+\n+    public static MemorySessionImpl createImplicit() {\n+        return new ImplicitSession();\n+    }\n+\n+    public static MemorySessionImpl heapSession(Object ref) {\n+        return new GlobalSessionImpl(ref);\n+    }\n+\n+    static IllegalStateException tooManyAcquires() {\n+        return new IllegalStateException(\"Session acquire limit exceeded\");\n+    }\n+\n+    static IllegalStateException alreadyAcquired(int acquires) {\n+        return new IllegalStateException(String.format(\"Session is acquired by %d clients\", acquires));\n+    }\n+\n+    static IllegalStateException alreadyClosed() {\n+        return new IllegalStateException(\"Already closed\");\n+    }\n+\n+    static WrongThreadException wrongThread() {\n+        return new WrongThreadException(\"Attempted access outside owning thread\");\n+    }\n+\n+    \/\/ helper functions to centralize error handling\n+\n+    static UnsupportedOperationException nonCloseable() {\n+        return new UnsupportedOperationException(\"Attempted to close a non-closeable session\");\n+    }\n+\n@@ -272,2 +301,1 @@\n-        @ForceInline\n-        public void release0() {\n+        void addInternal(ResourceList.ResourceCleanup resource) {\n@@ -278,2 +306,3 @@\n-        public boolean isCloseable() {\n-            return false;\n+        @ForceInline\n+        public void release0() {\n+            \/\/ do nothing\n@@ -289,2 +318,2 @@\n-        void addInternal(ResourceList.ResourceCleanup resource) {\n-            \/\/ do nothing\n+        public boolean isCloseable() {\n+            return false;\n@@ -299,6 +328,0 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSessionImpl(null);\n-\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSessionImpl(ref);\n-    }\n-\n@@ -319,5 +342,0 @@\n-        @Override\n-        public void release0() {\n-            Reference.reachabilityFence(this);\n-        }\n-\n@@ -330,2 +348,2 @@\n-        public boolean isCloseable() {\n-            return false;\n+        public void release0() {\n+            Reference.reachabilityFence(this);\n@@ -338,0 +356,5 @@\n+\n+        @Override\n+        public boolean isCloseable() {\n+            return false;\n+        }\n@@ -370,2 +393,2 @@\n-        public boolean equals(Object o) {\n-            return session.equals(o);\n+        public void whileAlive(Runnable action) {\n+            session.whileAlive(action);\n@@ -375,2 +398,2 @@\n-        public int hashCode() {\n-            return session.hashCode();\n+        public void addCloseAction(Runnable runnable) {\n+            session.addCloseAction(runnable);\n@@ -380,2 +403,2 @@\n-        public void whileAlive(Runnable action) {\n-            session.whileAlive(action);\n+        public void close() {\n+            throw new UnsupportedOperationException();\n@@ -390,2 +413,2 @@\n-        public void addCloseAction(Runnable runnable) {\n-            session.addCloseAction(runnable);\n+        public int hashCode() {\n+            return session.hashCode();\n@@ -395,2 +418,2 @@\n-        public void close() {\n-            throw new UnsupportedOperationException();\n+        public boolean equals(Object o) {\n+            return session.equals(o);\n@@ -411,2 +434,0 @@\n-        abstract void cleanup();\n-\n@@ -417,0 +438,2 @@\n+        abstract void cleanup();\n+\n@@ -426,4 +449,0 @@\n-            ResourceCleanup next;\n-\n-            public abstract void cleanup();\n-\n@@ -436,0 +455,3 @@\n+            ResourceCleanup next;\n+\n+            public abstract void cleanup();\n@@ -448,25 +470,0 @@\n-    \/\/ helper functions to centralize error handling\n-\n-    static IllegalStateException tooManyAcquires() {\n-        return new IllegalStateException(\"Session acquire limit exceeded\");\n-    }\n-\n-    static IllegalStateException alreadyAcquired(int acquires) {\n-        return new IllegalStateException(String.format(\"Session is acquired by %d clients\", acquires));\n-    }\n-\n-    static IllegalStateException alreadyClosed() {\n-        return new IllegalStateException(\"Already closed\");\n-    }\n-\n-    static WrongThreadException wrongThread() {\n-        return new WrongThreadException(\"Attempted access outside owning thread\");\n-    }\n-\n-    static UnsupportedOperationException nonCloseable() {\n-        return new UnsupportedOperationException(\"Attempted to close a non-closeable session\");\n-    }\n-\n-    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n-\n-    static final ScopedMemoryAccess.ScopedAccessError WRONG_THREAD = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::wrongThread);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":149,"deletions":152,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -45,11 +45,1 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    @Override\n-    public long address() {\n-        return min;\n-    }\n-\n-    @Override\n-    public Optional<Object> array() {\n-        return Optional.empty();\n-    }\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -60,1 +50,0 @@\n-\n@@ -66,1 +55,4 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySession session) {\n+    NativeMemorySegmentImpl(long min,\n+                            long length,\n+                            boolean readOnly,\n+                            MemorySession session) {\n@@ -71,0 +63,10 @@\n+    @Override\n+    public long address() {\n+        return min;\n+    }\n+\n+    @Override\n+    public Optional<Object> array() {\n+        return Optional.empty();\n+    }\n+\n@@ -79,1 +81,1 @@\n-        return nioAccess.newDirectByteBuffer(min, (int) this.length, null,\n+        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null,\n@@ -105,1 +107,3 @@\n-    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes, MemorySession session) {\n+    public static MemorySegment makeNativeSegment(long byteSize,\n+                                                  long byteAlignment,\n+                                                  MemorySession session) {\n@@ -109,1 +113,1 @@\n-            alignmentBytes = Math.max(alignmentBytes, nioAccess.pageSize());\n+            byteAlignment = Math.max(byteAlignment, NIO_ACCESS.pageSize());\n@@ -111,3 +115,3 @@\n-        long alignedSize = Math.max(1L, alignmentBytes > MAX_MALLOC_ALIGN ?\n-                bytesSize + (alignmentBytes - 1) :\n-                bytesSize);\n+        long alignedSize = Math.max(1L, byteAlignment > MAX_MALLOC_ALIGN ?\n+                byteSize + (byteAlignment - 1) :\n+                byteSize);\n@@ -115,1 +119,1 @@\n-        nioAccess.reserveMemory(alignedSize, bytesSize);\n+        NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n@@ -117,1 +121,1 @@\n-        long buf = unsafe.allocateMemory(alignedSize);\n+        long buf = UNSAFE.allocateMemory(alignedSize);\n@@ -119,1 +123,1 @@\n-            unsafe.setMemory(buf, alignedSize, (byte)0);\n+            UNSAFE.setMemory(buf, alignedSize, (byte)0);\n@@ -121,1 +125,1 @@\n-        long alignedBuf = Utils.alignUp(buf, alignmentBytes);\n+        long alignedBuf = Utils.alignUp(buf, byteAlignment);\n@@ -127,2 +131,2 @@\n-                unsafe.freeMemory(buf);\n-                nioAccess.unreserveMemory(alignedSize, bytesSize);\n+                UNSAFE.freeMemory(buf);\n+                NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n@@ -131,1 +135,1 @@\n-        if (alignedSize != bytesSize) {\n+        if (alignedSize != byteSize) {\n@@ -133,1 +137,1 @@\n-            segment = segment.asSlice(delta, bytesSize);\n+            segment = segment.asSlice(delta, byteSize);\n@@ -142,1 +146,3 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize, MemorySession session) {\n+    public static MemorySegment makeNativeSegmentUnchecked(long min,\n+                                                           long byteSize,\n+                                                           MemorySession session) {\n@@ -145,1 +151,1 @@\n-        return new NativeMemorySegmentImpl(min, bytesSize, false, session);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, session);\n@@ -149,2 +155,2 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long bytesSize) {\n-        return new NativeMemorySegmentImpl(min, bytesSize, false, MemorySession.global());\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize) {\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySession.global());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-        private SysV() {\n-            \/\/just the one\n-        }\n@@ -48,1 +45,0 @@\n-\n@@ -53,1 +49,0 @@\n-\n@@ -58,1 +53,0 @@\n-\n@@ -63,1 +57,0 @@\n-\n@@ -68,1 +61,0 @@\n-\n@@ -73,1 +65,0 @@\n-\n@@ -78,1 +69,0 @@\n-\n@@ -83,1 +73,0 @@\n-\n@@ -88,1 +77,0 @@\n-\n@@ -93,0 +81,4 @@\n+\n+        private SysV() {\n+            \/\/just the one\n+        }\n@@ -100,4 +92,0 @@\n-        private Win64() {\n-            \/\/just the one\n-        }\n-\n@@ -108,1 +96,0 @@\n-\n@@ -113,1 +100,0 @@\n-\n@@ -118,1 +104,0 @@\n-\n@@ -127,1 +112,0 @@\n-\n@@ -132,1 +116,0 @@\n-\n@@ -137,1 +120,0 @@\n-\n@@ -142,1 +124,0 @@\n-\n@@ -147,1 +128,0 @@\n-\n@@ -152,0 +132,4 @@\n+\n+        private Win64() {\n+            \/\/just the one\n+        }\n@@ -159,4 +143,0 @@\n-        private AArch64() {\n-            \/\/just the one\n-        }\n-\n@@ -167,1 +147,0 @@\n-\n@@ -172,1 +151,0 @@\n-\n@@ -177,1 +155,0 @@\n-\n@@ -182,1 +159,0 @@\n-\n@@ -187,1 +163,0 @@\n-\n@@ -192,1 +167,0 @@\n-\n@@ -197,1 +171,0 @@\n-\n@@ -202,1 +175,0 @@\n-\n@@ -207,1 +179,0 @@\n-\n@@ -212,0 +183,4 @@\n+\n+        private AArch64() {\n+            \/\/just the one\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":12,"deletions":37,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -51,0 +51,14 @@\n+    void justClose() {\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n+        if (prevState < 0) {\n+            throw alreadyClosed();\n+        } else if (prevState != OPEN) {\n+            throw alreadyAcquired(prevState);\n+        }\n+        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+        STATE.setVolatile(this, success ? CLOSED : OPEN);\n+        if (!success) {\n+            throw alreadyAcquired(1);\n+        }\n+    }\n+\n@@ -80,14 +94,0 @@\n-    void justClose() {\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n-        if (prevState < 0) {\n-            throw alreadyClosed();\n-        } else if (prevState != OPEN) {\n-            throw alreadyAcquired(prevState);\n-        }\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : OPEN);\n-        if (!success) {\n-            throw alreadyAcquired(1);\n-        }\n-    }\n-\n@@ -97,1 +97,1 @@\n-    static class SharedResourceList extends ResourceList {\n+    static final class SharedResourceList extends ResourceList {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-    private SystemLookup() { }\n-\n@@ -48,1 +46,0 @@\n-\n@@ -51,1 +48,0 @@\n-\n@@ -58,0 +54,11 @@\n+    private SystemLookup() { }\n+\n+    @Override\n+    public Optional<MemorySegment> find(String name) {\n+        return SYSTEM_LOOKUP.find(name);\n+    }\n+\n+    public static SystemLookup getInstance() {\n+        return INSTANCE;\n+    }\n+\n@@ -72,29 +79,0 @@\n-    private static SymbolLookup makeWindowsLookup() {\n-        Path system32 = Path.of(System.getenv(\"SystemRoot\"), \"System32\");\n-        Path ucrtbase = system32.resolve(\"ucrtbase.dll\");\n-        Path msvcrt = system32.resolve(\"msvcrt.dll\");\n-\n-        boolean useUCRT = Files.exists(ucrtbase);\n-        Path stdLib = useUCRT ? ucrtbase : msvcrt;\n-        SymbolLookup lookup = libLookup(libs -> libs.load(stdLib));\n-\n-        if (useUCRT) {\n-            \/\/ use a fallback lookup to look up inline functions from fallback lib\n-\n-            SymbolLookup fallbackLibLookup =\n-                    libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n-\n-            int numSymbols = WindowsFallbackSymbols.values().length;\n-            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.find(\"funcs\").orElseThrow().address(),\n-                ADDRESS.byteSize() * numSymbols, MemorySession.global());\n-\n-            Function<String, Optional<MemorySegment>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, MemorySession.global()));\n-\n-            final SymbolLookup finalLookup = lookup;\n-            lookup = name -> finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n-        }\n-\n-        return lookup;\n-    }\n-\n@@ -129,0 +107,4 @@\n+    private static SymbolLookup makeWindowsLookup() {\n+        Path system32 = Path.of(System.getenv(\"SystemRoot\"), \"System32\");\n+        Path ucrtbase = system32.resolve(\"ucrtbase.dll\");\n+        Path msvcrt = system32.resolve(\"msvcrt.dll\");\n@@ -130,3 +112,3 @@\n-    public static SystemLookup getInstance() {\n-        return INSTANCE;\n-    }\n+        boolean useUCRT = Files.exists(ucrtbase);\n+        Path stdLib = useUCRT ? ucrtbase : msvcrt;\n+        SymbolLookup lookup = libLookup(libs -> libs.load(stdLib));\n@@ -134,3 +116,18 @@\n-    @Override\n-    public Optional<MemorySegment> find(String name) {\n-        return SYSTEM_LOOKUP.find(name);\n+        if (useUCRT) {\n+            \/\/ use a fallback lookup to look up inline functions from fallback lib\n+\n+            SymbolLookup fallbackLibLookup =\n+                    libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+\n+            int numSymbols = WindowsFallbackSymbols.values().length;\n+            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.find(\"funcs\").orElseThrow().address(),\n+                ADDRESS.byteSize() * numSymbols, MemorySession.global());\n+\n+            Function<String, Optional<MemorySegment>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, MemorySession.global()));\n+\n+            final SymbolLookup finalLookup = lookup;\n+            lookup = name -> finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n+        }\n+\n+        return lookup;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":36,"deletions":39,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.lang.reflect.Array;\n+import java.nio.ByteOrder;\n@@ -38,0 +40,2 @@\n+import java.util.Objects;\n+import java.util.Set;\n@@ -39,0 +43,1 @@\n+import java.util.function.Function;\n@@ -41,0 +46,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n@@ -48,0 +55,3 @@\n+    public static final MethodHandle MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET;\n+    public static final Supplier<RuntimeException> BITS_TO_BYTES_THROW_OFFSET\n+            = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n@@ -51,5 +61,2 @@\n-    private static final MethodHandle LONG_TO_ADDRESS_SAFE, LONG_TO_ADDRESS_UNSAFE;\n-    public static final MethodHandle MH_bitsToBytesOrThrowForOffset;\n-\n-    public static final Supplier<RuntimeException> bitsToBytesThrowOffset\n-            = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n+    private static final MethodHandle LONG_TO_ADDRESS_SAFE;\n+    private static final MethodHandle LONG_TO_ADDRESS_UNSAFE;\n@@ -70,1 +77,1 @@\n-            MH_bitsToBytesOrThrowForOffset = MethodHandles.insertArguments(\n+            MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET = MethodHandles.insertArguments(\n@@ -74,1 +81,1 @@\n-                    bitsToBytesThrowOffset);\n+                    BITS_TO_BYTES_THROW_OFFSET);\n@@ -80,2 +87,1 @@\n-    public static long alignUp(long n, long alignment) {\n-        return (n + alignment - 1) & -alignment;\n+    private Utils() {\n@@ -89,0 +95,4 @@\n+    public static long alignUp(long n, long alignment) {\n+        return (n + alignment - 1) & -alignment;\n+    }\n+\n@@ -97,0 +107,5 @@\n+    @ForceInline\n+    public static boolean isAligned(long offset, long align) {\n+        return (offset & (align - 1)) == 0;\n+    }\n+\n@@ -131,0 +146,40 @@\n+    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n+        MemorySegment addr = allocator.allocate(bytes.length + 1);\n+        copy(addr, bytes);\n+        return addr;\n+    }\n+\n+    public static void copy(MemorySegment addr, byte[] bytes) {\n+        var heapSegment = MemorySegment.ofArray(bytes);\n+        addr.copyFrom(heapSegment);\n+        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n+    }\n+\n+    @ForceInline\n+    public static void checkElementAlignment(MemoryLayout layout, String msg) {\n+        if (layout.bitAlignment() > layout.bitSize()) {\n+            throw new IllegalArgumentException(msg);\n+        }\n+    }\n+\n+    public static long pointeeSize(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n+            return addressLayout.isUnbounded() ? Long.MAX_VALUE : 0L;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    public static void checkAllocationSizeAndAlign(long byteSize, long byteAlignment) {\n+        \/\/ size should be >= 0\n+        if (byteSize < 0) {\n+            throw new IllegalArgumentException(\"Invalid allocation size : \" + byteSize);\n+        }\n+\n+        \/\/ alignment should be > 0, and power of two\n+        if (byteAlignment <= 0 ||\n+                ((byteAlignment & (byteAlignment - 1)) != 0L)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + byteAlignment);\n+        }\n+    }\n+\n@@ -132,0 +187,1 @@\n+\n@@ -141,1 +197,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, 0);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, 0L);\n@@ -149,4 +205,13 @@\n-    public static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n+    public static <Z> Z computePathOp(LayoutPath path,\n+                                      Function<LayoutPath, Z> finalizer,\n+                                      Set<LayoutPath.PathElementImpl.PathKind> badKinds,\n+                                      MemoryLayout.PathElement... elements) {\n+        Objects.requireNonNull(elements);\n+        for (MemoryLayout.PathElement e : elements) {\n+            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n+            if (badKinds.contains(pathElem.kind())) {\n+                throw new IllegalArgumentException(String.format(\"Invalid %s selection in layout path\", pathElem.kind().description()));\n+            }\n+            path = pathElem.apply(path);\n+        }\n+        return finalizer.apply(path);\n@@ -155,4 +220,34 @@\n-    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1);\n-        copy(addr, bytes);\n-        return addr;\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment,\n+                            ValueLayout srcElementLayout,\n+                            long srcOffset,\n+                            MemorySegment dstSegment,\n+                            ValueLayout dstElementLayout,\n+                            long dstOffset,\n+                            long elementCount) {\n+\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n+        }\n+        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n+        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n@@ -162,2 +257,29 @@\n-    public static boolean isAligned(long offset, long align) {\n-        return (offset & (align - 1)) == 0;\n+    public static void copy(MemorySegment srcSegment,\n+                            ValueLayout srcLayout,\n+                            long srcOffset,\n+                            Object dstArray,\n+                            int dstIndex,\n+                            int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n+        }\n+        int dstBase = (int)baseAndScale;\n+        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n@@ -167,3 +289,28 @@\n-    public static void checkElementAlignment(MemoryLayout layout, String msg) {\n-        if (layout.bitAlignment() > layout.bitSize()) {\n-            throw new IllegalArgumentException(msg);\n+    public static void copy(Object srcArray,\n+                            int srcIndex,\n+                            MemorySegment dstSegment,\n+                            ValueLayout dstLayout,\n+                            long dstOffset,\n+                            int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n+        }\n+        int srcBase = (int)baseAndScale;\n+        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n+        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n@@ -173,3 +320,15 @@\n-    public static long pointeeSize(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n-            return addressLayout.isUnbounded() ? Long.MAX_VALUE : 0L;\n+    private static long getBaseAndScale(Class<?> arrayType) {\n+        if (arrayType.equals(byte[].class)) {\n+            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(char[].class)) {\n+            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(short[].class)) {\n+            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(int[].class)) {\n+            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(float[].class)) {\n+            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(long[].class)) {\n+            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(double[].class)) {\n+            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n@@ -177,1 +336,1 @@\n-            throw new UnsupportedOperationException();\n+            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n@@ -181,4 +340,16 @@\n-    public static void checkAllocationSizeAndAlign(long bytesSize, long alignmentBytes) {\n-        \/\/ size should be >= 0\n-        if (bytesSize < 0) {\n-            throw new IllegalArgumentException(\"Invalid allocation size : \" + bytesSize);\n+    public static long mismatch(MemorySegment srcSegment,\n+                                long srcFromOffset,\n+                                long srcToOffset,\n+                                MemorySegment dstSegment,\n+                                long dstFromOffset,\n+                                long dstToOffset) {\n+\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n+        long srcBytes = srcToOffset - srcFromOffset;\n+        long dstBytes = dstToOffset - dstFromOffset;\n+        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n+        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n+        if (dstImpl == srcImpl) {\n+            srcImpl.checkValidState();\n+            return -1;\n@@ -187,4 +358,16 @@\n-        \/\/ alignment should be > 0, and power of two\n-        if (alignmentBytes <= 0 ||\n-                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {\n-            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + alignmentBytes);\n+        long bytes = Math.min(srcBytes, dstBytes);\n+        long i = 0;\n+        if (bytes > 7) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n@@ -192,0 +375,6 @@\n+        for (; i < bytes; i++) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n+                return i;\n+            }\n+        }\n+        return srcBytes != dstBytes ? bytes : -1;\n@@ -193,0 +382,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":225,"deletions":35,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *\n+ * <p>\n@@ -32,3 +32,1 @@\n-public class ABIDescriptor {\n-    final Architecture arch;\n-\n+public final class ABIDescriptor {\n@@ -37,1 +35,1 @@\n-\n+    final Architecture arch;\n@@ -46,3 +44,8 @@\n-    public ABIDescriptor(Architecture arch, VMStorage[][] inputStorage, VMStorage[][] outputStorage,\n-                         VMStorage[][] volatileStorage, int stackAlignment, int shadowSpace,\n-                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+    public ABIDescriptor(Architecture arch,\n+                         VMStorage[][] inputStorage,\n+                         VMStorage[][] outputStorage,\n+                         VMStorage[][] volatileStorage,\n+                         int stackAlignment,\n+                         int shadowSpace,\n+                         VMStorage targetAddrStorage,\n+                         VMStorage retBufAddrStorage) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -60,1 +60,3 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession scope) {\n+    public MemorySegment upcallStub(MethodHandle target,\n+                                    FunctionDescriptor function,\n+                                    MemorySession scope) {\n@@ -73,2 +75,4 @@\n-    protected abstract MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType,\n-                                                   FunctionDescriptor function, MemorySession scope);\n+    protected abstract MemorySegment arrangeUpcall(MethodHandle target,\n+                                                   MethodType targetType,\n+                                                   FunctionDescriptor function,\n+                                                   MemorySession scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- *\n+ * <p>\n@@ -45,1 +45,1 @@\n- *\n+ * <p>\n@@ -47,5 +47,5 @@\n- *  - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine\n- *    storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.\n- *  - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.\n- *    If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.\n- *    The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.\n+ * - Unboxing is the process of taking a Java value and decomposing it, and storing components into machine\n+ * storage locations. As such, the binding interpreter stack starts with the Java value on it, and should end empty.\n+ * - Boxing is the process of re-composing a Java value by pulling components from machine storage locations.\n+ * If a MemorySegment is needed to store the result, one should be allocated using the ALLOCATE_BUFFER operator.\n+ * The binding interpreter stack starts off empty, and ends with the value to be returned as the only value on it.\n@@ -54,1 +54,1 @@\n- *\n+ * <p>\n@@ -58,1 +58,1 @@\n- *\n+ * <p>\n@@ -60,1 +60,1 @@\n- *\n+ * <p>\n@@ -62,1 +62,1 @@\n- *\n+ * <p>\n@@ -65,1 +65,1 @@\n- *\n+ * <p>\n@@ -68,1 +68,1 @@\n- *\n+ * <p>\n@@ -70,1 +70,1 @@\n- *\n+ * <p>\n@@ -72,1 +72,1 @@\n- *\n+ * <p>\n@@ -75,2 +75,2 @@\n- *    VM_STORE(rcx, long.class) \/\/ the 'long' is moved into the RCX register\n- *\n+ * VM_STORE(rcx, long.class) \/\/ the 'long' is moved into the RCX register\n+ * <p>\n@@ -79,1 +79,1 @@\n- *\n+ * <p>\n@@ -81,1 +81,1 @@\n- *\n+ * <p>\n@@ -83,1 +83,1 @@\n- *\n+ * <p>\n@@ -86,1 +86,1 @@\n- *\n+ * <p>\n@@ -89,2 +89,2 @@\n- *    BOX_ADDRESS \/\/ convert the 'long' into a 'MemoryAddress'\n- *\n+ * BOX_ADDRESS \/\/ convert the 'long' into a 'MemoryAddress'\n+ * <p>\n@@ -92,1 +92,1 @@\n- *\n+ * <p>\n@@ -94,2 +94,2 @@\n- *   int x;\n- *   int y;\n+ * int x;\n+ * int y;\n@@ -97,1 +97,1 @@\n- *\n+ * <p>\n@@ -99,1 +99,1 @@\n- *\n+ * <p>\n@@ -102,2 +102,2 @@\n- *    VM_STORE(rcx, long.class) \/\/ and copy that into the RCX register\n- *\n+ * VM_STORE(rcx, long.class) \/\/ and copy that into the RCX register\n+ * <p>\n@@ -106,1 +106,1 @@\n- *\n+ * <p>\n@@ -108,1 +108,1 @@\n- *\n+ * <p>\n@@ -110,2 +110,2 @@\n- *   long long x;\n- *   long long y;\n+ * long long x;\n+ * long long y;\n@@ -113,1 +113,1 @@\n- *\n+ * <p>\n@@ -115,1 +115,1 @@\n- *\n+ * <p>\n@@ -117,1 +117,1 @@\n- *\n+ * <p>\n@@ -120,4 +120,4 @@\n- *    BASE_ADDRESS \/\/ take the base address of the copy\n- *    UNBOX_ADDRESS \/\/ converts the base address to a 'long'\n- *    VM_STORE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n- *\n+ * BASE_ADDRESS \/\/ take the base address of the copy\n+ * UNBOX_ADDRESS \/\/ converts the base address to a 'long'\n+ * VM_STORE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n+ * <p>\n@@ -126,1 +126,1 @@\n- *\n+ * <p>\n@@ -128,1 +128,1 @@\n- *\n+ * <p>\n@@ -131,5 +131,5 @@\n- *    BUFFER_LOAD(0, long.class) \/\/ loads a 'long' from offset '0'\n- *    VM_STORE(rdx, long.class) \/\/ moves the long into the RDX register\n- *    BUFFER_LOAD(8, long.class) \/\/ loads a 'long' from offset '8'\n- *    VM_STORE(rcx, long.class) \/\/ moves the long into the RCX register\n- *\n+ * BUFFER_LOAD(0, long.class) \/\/ loads a 'long' from offset '0'\n+ * VM_STORE(rdx, long.class) \/\/ moves the long into the RDX register\n+ * BUFFER_LOAD(8, long.class) \/\/ loads a 'long' from offset '8'\n+ * VM_STORE(rcx, long.class) \/\/ moves the long into the RCX register\n+ * <p>\n@@ -138,1 +138,1 @@\n- *\n+ * <p>\n@@ -140,1 +140,1 @@\n- *\n+ * <p>\n@@ -142,2 +142,2 @@\n- *   int x;\n- *   int y;\n+ * int x;\n+ * int y;\n@@ -145,1 +145,1 @@\n- *\n+ * <p>\n@@ -147,1 +147,1 @@\n- *\n+ * <p>\n@@ -150,1 +150,1 @@\n- *\n+ * <p>\n@@ -153,4 +153,4 @@\n- *    DUP \/\/ duplicate the allocated buffer\n- *    VM_LOAD(rax, long.class) \/\/ loads a 'long' from rax\n- *    BUFFER_STORE(0, long.class) \/\/ stores a 'long' at offset 0\n- *\n+ * DUP \/\/ duplicate the allocated buffer\n+ * VM_LOAD(rax, long.class) \/\/ loads a 'long' from rax\n+ * BUFFER_STORE(0, long.class) \/\/ stores a 'long' at offset 0\n+ * <p>\n@@ -158,1 +158,1 @@\n- *\n+ * <p>\n@@ -160,2 +160,2 @@\n- *   long long x;\n- *   long long y;\n+ * long long x;\n+ * long long y;\n@@ -163,1 +163,1 @@\n- *\n+ * <p>\n@@ -165,1 +165,1 @@\n- *\n+ * <p>\n@@ -167,1 +167,1 @@\n- *\n+ * <p>\n@@ -170,2 +170,2 @@\n- *    VM_STORE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n- *\n+ * VM_STORE(rcx, long.class) \/\/ moves the 'long' into the RCX register\n+ * <p>\n@@ -174,1 +174,1 @@\n- *\n+ * <p>\n@@ -176,1 +176,1 @@\n- *\n+ * <p>\n@@ -178,1 +178,1 @@\n- *\n+ * <p>\n@@ -180,1 +180,1 @@\n- *\n+ * <p>\n@@ -183,1 +183,1 @@\n- *\n+ * <p>\n@@ -185,3 +185,3 @@\n- *    VM_STORE(rdx, float.class) \/\/ move one copy into the RDX register\n- *    VM_STORE(xmm1, float.class) \/\/ moves the other copy into the xmm2 register\n- *\n+ * VM_STORE(rdx, float.class) \/\/ move one copy into the RDX register\n+ * VM_STORE(xmm1, float.class) \/\/ moves the other copy into the xmm2 register\n+ * <p>\n@@ -190,1 +190,1 @@\n- *\n+ * <p>\n@@ -195,96 +195,0 @@\n-    \/**\n-     * A binding context is used as an helper to carry out evaluation of certain bindings; for instance,\n-     * it helps {@link Allocate} bindings, by providing the {@link SegmentAllocator} that should be used for\n-     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link MemorySession} that\n-     * should be used to create an unsafe struct from a memory address.\n-     *\/\n-    class Context implements AutoCloseable {\n-        private final SegmentAllocator allocator;\n-        private final MemorySession session;\n-\n-        private Context(SegmentAllocator allocator, MemorySession session) {\n-            this.allocator = allocator;\n-            this.session = session;\n-        }\n-\n-        public SegmentAllocator allocator() {\n-            return allocator;\n-        }\n-\n-        public MemorySession session() {\n-            return session;\n-        }\n-\n-        @Override\n-        public void close() {\n-            session().close();\n-        }\n-\n-        \/**\n-         * Create a binding context from given native scope.\n-         *\/\n-        public static Context ofBoundedAllocator(long size) {\n-            MemorySession scope = MemorySession.openConfined();\n-            return new Context(SegmentAllocator.newNativeArena(size, scope), scope);\n-        }\n-\n-        \/**\n-         * Create a binding context from given segment allocator. The resulting context will throw when\n-         * the context's scope is accessed.\n-         *\/\n-        public static Context ofAllocator(SegmentAllocator allocator) {\n-            return new Context(allocator, null) {\n-                @Override\n-                public MemorySession session() {\n-                    throw new UnsupportedOperationException();\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Create a binding context from given scope. The resulting context will throw when\n-         * the context's allocator is accessed.\n-         *\/\n-        public static Context ofSession() {\n-            MemorySession scope = MemorySession.openConfined();\n-            return new Context(null, scope) {\n-                @Override\n-                public SegmentAllocator allocator() { throw new UnsupportedOperationException(); }\n-            };\n-        }\n-\n-        \/**\n-         * Dummy binding context. Throws exceptions when attempting to access scope, return a throwing allocator, and has\n-         * an idempotent {@link #close()}.\n-         *\/\n-        public static final Context DUMMY = new Context(null, null) {\n-            @Override\n-            public SegmentAllocator allocator() {\n-                return SharedUtils.THROWING_ALLOCATOR;\n-            }\n-\n-            @Override\n-            public MemorySession session() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public void close() {\n-                \/\/ do nothing\n-            }\n-        };\n-    }\n-\n-    enum Tag {\n-        VM_STORE,\n-        VM_LOAD,\n-        BUFFER_STORE,\n-        BUFFER_LOAD,\n-        COPY_BUFFER,\n-        ALLOC_BUFFER,\n-        BOX_ADDRESS,\n-        UNBOX_ADDRESS,\n-        DUP,\n-        CAST\n-    }\n-\n@@ -295,12 +199,4 @@\n-    void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                   BindingInterpreter.LoadFunc loadFunc, Context context);\n-\n-    private static void checkType(Class<?> type) {\n-        if (!type.isPrimitive() || type == void.class)\n-            throw new IllegalArgumentException(\"Illegal type: \" + type);\n-    }\n-\n-    private static void checkOffset(long offset) {\n-        if (offset < 0)\n-            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n-    }\n+    void interpret(Deque<Object> stack,\n+                   BindingInterpreter.StoreFunc storeFunc,\n+                   BindingInterpreter.LoadFunc loadFunc,\n+                   Context context);\n@@ -313,0 +209,5 @@\n+    private static void checkType(Class<?> type) {\n+        if (!type.isPrimitive() || type == void.class)\n+            throw new IllegalArgumentException(\"Illegal type: \" + type);\n+    }\n+\n@@ -324,0 +225,5 @@\n+    private static void checkOffset(long offset) {\n+        if (offset < 0)\n+            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n+    }\n+\n@@ -362,1 +268,0 @@\n-\n@@ -367,0 +272,26 @@\n+    enum Tag {\n+        VM_STORE,\n+        VM_LOAD,\n+        BUFFER_STORE,\n+        BUFFER_LOAD,\n+        COPY_BUFFER,\n+        ALLOC_BUFFER,\n+        BOX_ADDRESS,\n+        UNBOX_ADDRESS,\n+        DUP,\n+        CAST\n+    }\n+\n+\n+    interface Move extends Binding {\n+        VMStorage storage();\n+\n+        Class<?> type();\n+    }\n+\n+    interface Dereference extends Binding {\n+        long offset();\n+\n+        Class<?> type();\n+    }\n+\n@@ -368,1 +299,4 @@\n-     * A builder helper class for generating lists of Bindings\n+     * A binding context is used as an helper to carry out evaluation of certain bindings; for instance,\n+     * it helps {@link Allocate} bindings, by providing the {@link SegmentAllocator} that should be used for\n+     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link MemorySession} that\n+     * should be used to create an unsafe struct from a memory address.\n@@ -370,2 +304,10 @@\n-    class Builder {\n-        private final List<Binding> bindings = new ArrayList<>();\n+    class Context implements AutoCloseable {\n+        \/**\n+         * Dummy binding context. Throws exceptions when attempting to access scope, return a throwing allocator, and has\n+         * an idempotent {@link #close()}.\n+         *\/\n+        public static final Context DUMMY = new Context(null, null) {\n+            @Override\n+            public SegmentAllocator allocator() {\n+                return SharedUtils.THROWING_ALLOCATOR;\n+            }\n@@ -373,2 +315,50 @@\n-        private static boolean isSubIntType(Class<?> type) {\n-            return type == boolean.class || type == byte.class || type == short.class || type == char.class;\n+            @Override\n+            public MemorySession session() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void close() {\n+                \/\/ do nothing\n+            }\n+        };\n+        private final SegmentAllocator allocator;\n+        private final MemorySession session;\n+\n+        private Context(SegmentAllocator allocator, MemorySession session) {\n+            this.allocator = allocator;\n+            this.session = session;\n+        }\n+\n+        public SegmentAllocator allocator() {\n+            return allocator;\n+        }\n+\n+        @Override\n+        public void close() {\n+            session().close();\n+        }\n+\n+        public MemorySession session() {\n+            return session;\n+        }\n+\n+        \/**\n+         * Create a binding context from given native scope.\n+         *\/\n+        public static Context ofBoundedAllocator(long size) {\n+            MemorySession scope = MemorySession.openConfined();\n+            return new Context(SegmentAllocator.newNativeArena(size, scope), scope);\n+        }\n+\n+        \/**\n+         * Create a binding context from given segment allocator. The resulting context will throw when\n+         * the context's scope is accessed.\n+         *\/\n+        public static Context ofAllocator(SegmentAllocator allocator) {\n+            return new Context(allocator, null) {\n+                @Override\n+                public MemorySession session() {\n+                    throw new UnsupportedOperationException();\n+                }\n+            };\n@@ -377,0 +367,21 @@\n+        \/**\n+         * Create a binding context from given scope. The resulting context will throw when\n+         * the context's allocator is accessed.\n+         *\/\n+        public static Context ofSession() {\n+            MemorySession scope = MemorySession.openConfined();\n+            return new Context(null, scope) {\n+                @Override\n+                public SegmentAllocator allocator() {\n+                    throw new UnsupportedOperationException();\n+                }\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * A builder helper class for generating lists of Bindings\n+     *\/\n+    final class Builder {\n+        private final List<Binding> bindings = new ArrayList<>();\n+\n@@ -386,0 +397,4 @@\n+        private static boolean isSubIntType(Class<?> type) {\n+            return type == boolean.class || type == byte.class || type == short.class || type == char.class;\n+        }\n+\n@@ -443,5 +458,0 @@\n-    interface Move extends Binding {\n-        VMStorage storage();\n-        Class<?> type();\n-    }\n-\n@@ -496,5 +506,0 @@\n-    interface Dereference extends Binding {\n-        long offset();\n-        Class<?> type();\n-    }\n-\n@@ -522,2 +527,4 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack,\n+                              BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc,\n+                              Context context) {\n@@ -552,2 +559,4 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack,\n+                              BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc,\n+                              Context context) {\n@@ -562,3 +571,3 @@\n-     *   Creates a new MemorySegment with the given [size] and [alignment],\n-     *     and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,\n-     *     and pushes the new buffer onto the operand stack\n+     * Creates a new MemorySegment with the given [size] and [alignment],\n+     * and copies contents from a MemorySegment popped from the top of the operand stack into this new buffer,\n+     * and pushes the new buffer onto the operand stack\n@@ -567,5 +576,0 @@\n-        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment)\n-                            .copyFrom(operand.asSlice(0, size));\n-        }\n-\n@@ -591,0 +595,8 @@\n+\n+        private static MemorySegment copyBuffer(MemorySegment operand,\n+                                                long size,\n+                                                long alignment,\n+                                                Context context) {\n+            return context.allocator().allocate(size, alignment)\n+                    .copyFrom(operand.asSlice(0, size));\n+        }\n@@ -595,1 +607,1 @@\n-     *   Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.\n+     * Creates a new MemorySegment with the give [size] and [alignment], and pushes it onto the operand stack.\n@@ -598,4 +610,0 @@\n-        private static MemorySegment allocateBuffer(long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment);\n-        }\n-\n@@ -617,0 +625,4 @@\n+\n+        private static MemorySegment allocateBuffer(long size, long alignment, Context context) {\n+            return context.allocator().allocate(size, alignment);\n+        }\n@@ -640,3 +652,5 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(((MemorySegment)stack.pop()).address());\n+        public void interpret(Deque<Object> stack,\n+                              BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc,\n+                              Context context) {\n+            stack.push(((MemorySegment) stack.pop()).address());\n@@ -666,4 +680,7 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            MemorySession session = needsSession ?\n-                    context.session() : MemorySession.global();\n+        public void interpret(Deque<Object> stack,\n+                              BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc,\n+                              Context context) {\n+            MemorySession session = needsSession\n+                    ? context.session()\n+                    : MemorySession.global();\n@@ -676,2 +693,2 @@\n-     *   Duplicates the value on the top of the operand stack (without popping it!),\n-     *   and pushes the duplicate onto the operand stack\n+     * Duplicates the value on the top of the operand stack (without popping it!),\n+     * and pushes the duplicate onto the operand stack\n@@ -693,2 +710,4 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack,\n+                              BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc,\n+                              Context context) {\n@@ -701,3 +720,2 @@\n-     *   Pop a [fromType] from the stack, convert it to [toType], and push the resulting\n-     *   value onto the stack.\n-     *\n+     * Pop a [fromType] from the stack, convert it to [toType], and push the resulting\n+     * value onto the stack.\n@@ -720,2 +738,4 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack,\n+                              BindingInterpreter.StoreFunc storeFunc,\n+                              BindingInterpreter.LoadFunc loadFunc,\n+                              Context context) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":253,"deletions":233,"binary":false,"changes":486,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-public class BindingInterpreter {\n+public final class BindingInterpreter {\n@@ -33,1 +33,7 @@\n-    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, Binding.Context context) {\n+    private BindingInterpreter() {\n+    }\n+\n+    static void unbox(Object arg,\n+                      List<Binding> bindings,\n+                      StoreFunc storeFunc,\n+                      Binding.Context context) {\n@@ -42,1 +48,3 @@\n-    static Object box(List<Binding> bindings, LoadFunc loadFunc, Binding.Context context) {\n+    static Object box(List<Binding> bindings,\n+                      LoadFunc loadFunc,\n+                      Binding.Context context) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-public class BindingSpecializer {\n+public final class BindingSpecializer {\n@@ -139,1 +139,5 @@\n-    private BindingSpecializer(MethodVisitor mv, MethodType callerMethodType, CallingSequence callingSequence, ABIDescriptor abi, MethodType leafType) {\n+    private BindingSpecializer(MethodVisitor mv,\n+                               MethodType callerMethodType,\n+                               CallingSequence callingSequence,\n+                               ABIDescriptor abi,\n+                               MethodType leafType) {\n@@ -147,96 +151,0 @@\n-    static MethodHandle specialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n-        if (callingSequence.forUpcall()) {\n-            MethodHandle wrapper = UPCALL_WRAPPER_CACHE.get(callingSequence.functionDesc(), fd -> specializeUpcall(leafHandle, callingSequence, abi));\n-            return MethodHandles.insertArguments(wrapper, 0, leafHandle); \/\/ lazily customized for leaf handle instances\n-        } else {\n-            return specializeDowncall(leafHandle, callingSequence, abi);\n-        }\n-    }\n-\n-    private static MethodHandle specializeDowncall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n-        MethodType callerMethodType = callingSequence.callerMethodType();\n-        if (callingSequence.needsReturnBuffer()) {\n-            callerMethodType = callerMethodType.dropParameterTypes(0, 1); \/\/ Return buffer does not appear in the parameter list\n-        }\n-        callerMethodType = callerMethodType.insertParameterTypes(0, SegmentAllocator.class);\n-\n-        byte[] bytes = specializeHelper(leafHandle.type(), callerMethodType, callingSequence, abi);\n-\n-        try {\n-            MethodHandles.Lookup definedClassLookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, false);\n-            return definedClassLookup.findStatic(definedClassLookup.lookupClass(), METHOD_NAME, callerMethodType);\n-        } catch (IllegalAccessException | NoSuchMethodException e) {\n-            throw new InternalError(\"Should not happen\", e);\n-        }\n-    }\n-\n-    private static MethodHandle specializeUpcall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n-        MethodType callerMethodType = callingSequence.callerMethodType();\n-        callerMethodType = callerMethodType.insertParameterTypes(0, MethodHandle.class); \/\/ target\n-\n-        byte[] bytes = specializeHelper(leafHandle.type(), callerMethodType, callingSequence, abi);\n-\n-        try {\n-            \/\/ For upcalls, we must initialize the class since the upcall stubs don't have a clinit barrier,\n-            \/\/ and the slow path in the c2i adapter we end up calling can not handle the particular code shape\n-            \/\/ where the caller is an upcall stub.\n-            MethodHandles.Lookup defineClassLookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n-            return defineClassLookup.findStatic(defineClassLookup.lookupClass(), METHOD_NAME, callerMethodType);\n-        } catch (IllegalAccessException | NoSuchMethodException e) {\n-            throw new InternalError(\"Should not happen\", e);\n-        }\n-    }\n-\n-    private static byte[] specializeHelper(MethodType leafType, MethodType callerMethodType,\n-                                           CallingSequence callingSequence, ABIDescriptor abi) {\n-        String className = callingSequence.forDowncall() ? CLASS_NAME_DOWNCALL : CLASS_NAME_UPCALL;\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(CLASSFILE_VERSION, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, SUPER_NAME, null);\n-\n-        String descriptor = callerMethodType.descriptorString();\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, METHOD_NAME, descriptor, null, null);\n-\n-        new BindingSpecializer(mv, callerMethodType, callingSequence, abi, leafType).specialize();\n-\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-\n-        byte[] bytes = cw.toByteArray();\n-        if (DUMP_CLASSES_DIR != null) {\n-            String fileName = className + escapeForFileName(callingSequence.functionDesc().toString()) + \".class\";\n-            Path dumpPath = Path.of(DUMP_CLASSES_DIR).resolve(fileName);\n-            try {\n-                Files.createDirectories(dumpPath.getParent());\n-                Files.write(dumpPath, bytes);\n-            } catch (IOException e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-\n-        if (PERFORM_VERIFICATION) {\n-            boolean printResults = false; \/\/ only print in case of exception\n-            CheckClassAdapter.verify(new ClassReader(bytes), null, printResults, new PrintWriter(System.err));\n-        }\n-\n-        return bytes;\n-    }\n-\n-    private static String escapeForFileName(String str) {\n-        StringBuilder sb = new StringBuilder(str.length());\n-        for (int i = 0; i < str.length(); i++) {\n-            char c = str.charAt(i);\n-            sb.append(switch (c) {\n-                case ' ' -> '_';\n-                case '[', '<' -> '{';\n-                case ']', '>' -> '}';\n-                case '\/', '\\\\', ':', '*', '?', '\"', '|' -> '!'; \/\/ illegal in Windows file names.\n-                default -> c;\n-            });\n-        }\n-        return sb.toString();\n-    }\n-\n-    \/\/ binding operand stack manipulation\n-\n@@ -257,2 +165,0 @@\n-    \/\/ specialization\n-\n@@ -458,0 +364,2 @@\n+    \/\/ binding operand stack manipulation\n+\n@@ -482,0 +390,2 @@\n+    \/\/ specialization\n+\n@@ -775,49 +685,3 @@\n-    private static String valueLayoutConstantFor(Class<?> type) {\n-        if (type == boolean.class) {\n-            return \"JAVA_BOOLEAN\";\n-        } else if (type == byte.class) {\n-            return \"JAVA_BYTE\";\n-        } else if (type == short.class) {\n-            return \"JAVA_SHORT_UNALIGNED\";\n-        } else if (type == char.class) {\n-            return \"JAVA_CHAR_UNALIGNED\";\n-        } else if (type == int.class) {\n-            return \"JAVA_INT_UNALIGNED\";\n-        } else if (type == long.class) {\n-            return \"JAVA_LONG_UNALIGNED\";\n-        } else if (type == float.class) {\n-            return \"JAVA_FLOAT_UNALIGNED\";\n-        } else if (type == double.class) {\n-            return \"JAVA_DOUBLE_UNALIGNED\";\n-        } else if (type == MemorySegment.class) {\n-            return \"ADDRESS_UNALIGNED\";\n-        } else {\n-            throw new IllegalStateException(\"Unknown type: \" + type);\n-        }\n-    }\n-\n-    private static Class<?> valueLayoutTypeFor(Class<?> type) {\n-        if (type == boolean.class) {\n-            return ValueLayout.OfBoolean.class;\n-        } else if (type == byte.class) {\n-            return ValueLayout.OfByte.class;\n-        } else if (type == short.class) {\n-            return ValueLayout.OfShort.class;\n-        } else if (type == char.class) {\n-            return ValueLayout.OfChar.class;\n-        } else if (type == int.class) {\n-            return ValueLayout.OfInt.class;\n-        } else if (type == long.class) {\n-            return ValueLayout.OfLong.class;\n-        } else if (type == float.class) {\n-            return ValueLayout.OfFloat.class;\n-        } else if (type == double.class) {\n-            return ValueLayout.OfDouble.class;\n-        } else if (type == MemorySegment.class) {\n-            return ValueLayout.OfAddress.class;\n-        } else {\n-            throw new IllegalStateException(\"Unknown type: \" + type);\n-        }\n-    }\n-\n-    private void emitInvokeStatic(Class<?> owner, String methodName, String descriptor) {\n+    private void emitInvokeStatic(Class<?> owner,\n+                                  String methodName,\n+                                  String descriptor) {\n@@ -827,1 +691,3 @@\n-    private void emitInvokeInterface(Class<?> owner, String methodName, String descriptor) {\n+    private void emitInvokeInterface(Class<?> owner,\n+                                     String methodName,\n+                                     String descriptor) {\n@@ -831,1 +697,3 @@\n-    private void emitInvokeVirtual(Class<?> owner, String methodName, String descriptor) {\n+    private void emitInvokeVirtual(Class<?> owner,\n+                                   String methodName,\n+                                   String descriptor) {\n@@ -835,1 +703,3 @@\n-    private void emitGetStatic(Class<?> owner, String fieldName, String descriptor) {\n+    private void emitGetStatic(Class<?> owner,\n+                               String fieldName,\n+                               String descriptor) {\n@@ -851,4 +721,0 @@\n-    \/*\n-     * Low-level emit helpers.\n-     *\/\n-\n@@ -961,0 +827,154 @@\n+    static MethodHandle specialize(MethodHandle leafHandle,\n+                                   CallingSequence callingSequence,\n+                                   ABIDescriptor abi) {\n+        if (callingSequence.forUpcall()) {\n+            MethodHandle wrapper = UPCALL_WRAPPER_CACHE.get(callingSequence.functionDesc(), fd -> specializeUpcall(leafHandle, callingSequence, abi));\n+            return MethodHandles.insertArguments(wrapper, 0, leafHandle); \/\/ lazily customized for leaf handle instances\n+        } else {\n+            return specializeDowncall(leafHandle, callingSequence, abi);\n+        }\n+    }\n+\n+    \/*\n+     * Low-level emit helpers.\n+     *\/\n+\n+    private static MethodHandle specializeDowncall(MethodHandle leafHandle,\n+                                                   CallingSequence callingSequence,\n+                                                   ABIDescriptor abi) {\n+        MethodType callerMethodType = callingSequence.callerMethodType();\n+        if (callingSequence.needsReturnBuffer()) {\n+            callerMethodType = callerMethodType.dropParameterTypes(0, 1); \/\/ Return buffer does not appear in the parameter list\n+        }\n+        callerMethodType = callerMethodType.insertParameterTypes(0, SegmentAllocator.class);\n+\n+        byte[] bytes = specializeHelper(leafHandle.type(), callerMethodType, callingSequence, abi);\n+\n+        try {\n+            MethodHandles.Lookup definedClassLookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, false);\n+            return definedClassLookup.findStatic(definedClassLookup.lookupClass(), METHOD_NAME, callerMethodType);\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new InternalError(\"Should not happen\", e);\n+        }\n+    }\n+\n+    private static MethodHandle specializeUpcall(MethodHandle leafHandle,\n+                                                 CallingSequence callingSequence,\n+                                                 ABIDescriptor abi) {\n+        MethodType callerMethodType = callingSequence.callerMethodType();\n+        callerMethodType = callerMethodType.insertParameterTypes(0, MethodHandle.class); \/\/ target\n+\n+        byte[] bytes = specializeHelper(leafHandle.type(), callerMethodType, callingSequence, abi);\n+\n+        try {\n+            \/\/ For upcalls, we must initialize the class since the upcall stubs don't have a clinit barrier,\n+            \/\/ and the slow path in the c2i adapter we end up calling can not handle the particular code shape\n+            \/\/ where the caller is an upcall stub.\n+            MethodHandles.Lookup defineClassLookup = MethodHandles.lookup().defineHiddenClass(bytes, true);\n+            return defineClassLookup.findStatic(defineClassLookup.lookupClass(), METHOD_NAME, callerMethodType);\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new InternalError(\"Should not happen\", e);\n+        }\n+    }\n+\n+    private static byte[] specializeHelper(MethodType leafType,\n+                                           MethodType callerMethodType,\n+                                           CallingSequence callingSequence,\n+                                           ABIDescriptor abi) {\n+        String className = callingSequence.forDowncall() ? CLASS_NAME_DOWNCALL : CLASS_NAME_UPCALL;\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n+        cw.visit(CLASSFILE_VERSION, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, SUPER_NAME, null);\n+\n+        String descriptor = callerMethodType.descriptorString();\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, METHOD_NAME, descriptor, null, null);\n+\n+        new BindingSpecializer(mv, callerMethodType, callingSequence, abi, leafType).specialize();\n+\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+\n+        cw.visitEnd();\n+\n+        byte[] bytes = cw.toByteArray();\n+        if (DUMP_CLASSES_DIR != null) {\n+            String fileName = className + escapeForFileName(callingSequence.functionDesc().toString()) + \".class\";\n+            Path dumpPath = Path.of(DUMP_CLASSES_DIR).resolve(fileName);\n+            try {\n+                Files.createDirectories(dumpPath.getParent());\n+                Files.write(dumpPath, bytes);\n+            } catch (IOException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        if (PERFORM_VERIFICATION) {\n+            boolean printResults = false; \/\/ only print in case of exception\n+            CheckClassAdapter.verify(new ClassReader(bytes), null, printResults, new PrintWriter(System.err));\n+        }\n+\n+        return bytes;\n+    }\n+\n+    private static String escapeForFileName(String str) {\n+        StringBuilder sb = new StringBuilder(str.length());\n+        for (int i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            sb.append(switch (c) {\n+                case ' ' -> '_';\n+                case '[', '<' -> '{';\n+                case ']', '>' -> '}';\n+                case '\/', '\\\\', ':', '*', '?', '\"', '|' -> '!'; \/\/ illegal in Windows file names.\n+                default -> c;\n+            });\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static String valueLayoutConstantFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return \"JAVA_BOOLEAN\";\n+        } else if (type == byte.class) {\n+            return \"JAVA_BYTE\";\n+        } else if (type == short.class) {\n+            return \"JAVA_SHORT_UNALIGNED\";\n+        } else if (type == char.class) {\n+            return \"JAVA_CHAR_UNALIGNED\";\n+        } else if (type == int.class) {\n+            return \"JAVA_INT_UNALIGNED\";\n+        } else if (type == long.class) {\n+            return \"JAVA_LONG_UNALIGNED\";\n+        } else if (type == float.class) {\n+            return \"JAVA_FLOAT_UNALIGNED\";\n+        } else if (type == double.class) {\n+            return \"JAVA_DOUBLE_UNALIGNED\";\n+        } else if (type == MemorySegment.class) {\n+            return \"ADDRESS_UNALIGNED\";\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n+    private static Class<?> valueLayoutTypeFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return ValueLayout.OfBoolean.class;\n+        } else if (type == byte.class) {\n+            return ValueLayout.OfByte.class;\n+        } else if (type == short.class) {\n+            return ValueLayout.OfShort.class;\n+        } else if (type == char.class) {\n+            return ValueLayout.OfChar.class;\n+        } else if (type == int.class) {\n+            return ValueLayout.OfInt.class;\n+        } else if (type == long.class) {\n+            return ValueLayout.OfLong.class;\n+        } else if (type == float.class) {\n+            return ValueLayout.OfFloat.class;\n+        } else if (type == double.class) {\n+            return ValueLayout.OfDouble.class;\n+        } else if (type == MemorySegment.class) {\n+            return ValueLayout.OfAddress.class;\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":176,"deletions":156,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class CallingSequence {\n+public final class CallingSequence {\n@@ -45,3 +45,9 @@\n-    public CallingSequence(boolean forUpcall, MethodType callerMethodType, MethodType calleeMethodType, FunctionDescriptor desc,\n-                           boolean needsReturnBuffer, long returnBufferSize, long allocationSize,\n-                           List<List<Binding>> argumentBindings, List<Binding> returnBindings) {\n+    public CallingSequence(boolean forUpcall,\n+                           MethodType callerMethodType,\n+                           MethodType calleeMethodType,\n+                           FunctionDescriptor desc,\n+                           boolean needsReturnBuffer,\n+                           long returnBufferSize,\n+                           long allocationSize,\n+                           List<List<Binding>> argumentBindings,\n+                           List<Binding> returnBindings) {\n@@ -59,18 +65,0 @@\n-    \/**\n-     * An important distinction is that downcalls have 1 recipe per caller parameter and\n-     * each callee parameter corresponds to a VM_STORE. Upcalls have 1 recipe per callee parameter and\n-     * each caller parameter corresponds to a VM_LOAD.\n-     *\n-     * The VM_STOREs are then implemented by the leaf handle for downcalls, and vice versa, the wrapper\n-     * stub that wraps an upcall handle implements the VM_LOADS. In both cases the register values are\n-     * communicated through Java primitives.\n-     *\n-     * The 'argumentBindingsCount' below corresponds to the number of recipes, so it is the\n-     * caller parameter count for downcalls, and the callee parameter count for upcalls.\n-     *\n-     * @return the number of binding recipes in this calling sequence\n-     *\/\n-    public int argumentBindingsCount() {\n-        return argumentBindings.size();\n-    }\n-\n@@ -202,0 +190,18 @@\n+\n+    \/**\n+     * An important distinction is that downcalls have 1 recipe per caller parameter and\n+     * each callee parameter corresponds to a VM_STORE. Upcalls have 1 recipe per callee parameter and\n+     * each caller parameter corresponds to a VM_LOAD.\n+     *\n+     * The VM_STOREs are then implemented by the leaf handle for downcalls, and vice versa, the wrapper\n+     * stub that wraps an upcall handle implements the VM_LOADS. In both cases the register values are\n+     * communicated through Java primitives.\n+     *\n+     * The 'argumentBindingsCount' below corresponds to the number of recipes, so it is the\n+     * caller parameter count for downcalls, and the callee parameter count for upcalls.\n+     *\n+     * @return the number of binding recipes in this calling sequence\n+     *\/\n+    public int argumentBindingsCount() {\n+        return argumentBindings.size();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-public class CallingSequenceBuilder {\n+public final class CallingSequenceBuilder {\n@@ -48,0 +48,24 @@\n+    private static final Set<Binding.Tag> UNBOX_TAGS = EnumSet.of(\n+            VM_STORE,\n+            \/\/VM_LOAD,\n+            \/\/BUFFER_STORE,\n+            BUFFER_LOAD,\n+            COPY_BUFFER,\n+            \/\/ALLOC_BUFFER,\n+            \/\/BOX_ADDRESS,\n+            UNBOX_ADDRESS,\n+            DUP,\n+            CAST\n+    );\n+    private static final Set<Binding.Tag> BOX_TAGS = EnumSet.of(\n+            \/\/VM_STORE,\n+            VM_LOAD,\n+            BUFFER_STORE,\n+            \/\/BUFFER_LOAD,\n+            COPY_BUFFER,\n+            ALLOC_BUFFER,\n+            BOX_ADDRESS,\n+            \/\/UNBOX_ADDRESS,\n+            DUP,\n+            CAST\n+    );\n@@ -50,1 +74,0 @@\n-\n@@ -54,1 +77,0 @@\n-\n@@ -63,2 +85,3 @@\n-    public final CallingSequenceBuilder addArgumentBindings(Class<?> carrier, MemoryLayout layout,\n-                                                            List<Binding> bindings) {\n+    public CallingSequenceBuilder addArgumentBindings(Class<?> carrier,\n+                                                      MemoryLayout layout,\n+                                                      List<Binding> bindings) {\n@@ -69,1 +92,4 @@\n-    private void addArgumentBinding(int index, Class<?> carrier, MemoryLayout layout, List<Binding> bindings) {\n+    private void addArgumentBinding(int index,\n+                                    Class<?> carrier,\n+                                    MemoryLayout layout,\n+                                    List<Binding> bindings) {\n@@ -76,1 +102,39 @@\n-    public CallingSequenceBuilder setReturnBindings(Class<?> carrier, MemoryLayout layout,\n+    private void verifyBindings(boolean forArguments,\n+                                Class<?> carrier,\n+                                List<Binding> bindings) {\n+        if (VERIFY_BINDINGS) {\n+            if (forUpcall == forArguments) {\n+                verifyBoxBindings(carrier, bindings);\n+            } else {\n+                verifyUnboxBindings(carrier, bindings);\n+            }\n+        }\n+    }\n+\n+    private static void verifyBoxBindings(Class<?> expectedOutType, List<Binding> bindings) {\n+        Deque<Class<?>> stack = new ArrayDeque<>();\n+\n+        for (Binding b : bindings) {\n+            if (!BOX_TAGS.contains(b.tag()))\n+                throw new IllegalArgumentException(\"Unexpected operator: \" + b);\n+            b.verify(stack);\n+        }\n+    }\n+\n+    private static void verifyUnboxBindings(Class<?> inType, List<Binding> bindings) {\n+        Deque<Class<?>> stack = new ArrayDeque<>();\n+        stack.push(inType);\n+\n+        for (Binding b : bindings) {\n+            if (!UNBOX_TAGS.contains(b.tag()))\n+                throw new IllegalArgumentException(\"Unexpected operator: \" + b);\n+            b.verify(stack);\n+        }\n+\n+        if (!stack.isEmpty()) {\n+            throw new IllegalArgumentException(\"Stack must be empty after recipe\");\n+        }\n+    }\n+\n+    public CallingSequenceBuilder setReturnBindings(Class<?> carrier,\n+                                                    MemoryLayout layout,\n@@ -85,6 +149,0 @@\n-    private boolean needsReturnBuffer() {\n-        return outputBindings.stream()\n-            .filter(Binding.Move.class::isInstance)\n-            .count() > 1;\n-    }\n-\n@@ -123,6 +181,4 @@\n-    private MethodType computeCallerTypeForUpcall() {\n-        return computeTypeHelper(Binding.VMLoad.class, Binding.VMStore.class);\n-    }\n-\n-    private MethodType computeCalleeTypeForDowncall() {\n-        return computeTypeHelper(Binding.VMStore.class, Binding.VMLoad.class);\n+    private boolean needsReturnBuffer() {\n+        return outputBindings.stream()\n+            .filter(Binding.Move.class::isInstance)\n+            .count() > 1;\n@@ -131,16 +187,8 @@\n-    private MethodType computeTypeHelper(Class<? extends Binding.Move> inputVMClass,\n-                                         Class<? extends Binding.Move> outputVMClass) {\n-        Class<?>[] paramTypes = inputBindings.stream()\n-                .flatMap(List::stream)\n-                .filter(inputVMClass::isInstance)\n-                .map(inputVMClass::cast)\n-                .map(Binding.Move::type)\n-                .toArray(Class<?>[]::new);\n-\n-        Binding.Move[] retMoves = outputBindings.stream()\n-                .filter(outputVMClass::isInstance)\n-                .map(outputVMClass::cast)\n-                .toArray(Binding.Move[]::new);\n-        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n-\n-        return methodType(returnType, paramTypes);\n+    private long computeReturnBuferSize() {\n+        return outputBindings.stream()\n+                .filter(Binding.Move.class::isInstance)\n+                .map(Binding.Move.class::cast)\n+                .map(Binding.Move::storage)\n+                .map(VMStorage::type)\n+                .mapToLong(abi.arch::typeSize)\n+                .sum();\n@@ -167,18 +215,2 @@\n-    private long computeReturnBuferSize() {\n-        return outputBindings.stream()\n-                .filter(Binding.Move.class::isInstance)\n-                .map(Binding.Move.class::cast)\n-                .map(Binding.Move::storage)\n-                .map(VMStorage::type)\n-                .mapToLong(abi.arch::typeSize)\n-                .sum();\n-    }\n-\n-    private void verifyBindings(boolean forArguments, Class<?> carrier, List<Binding> bindings) {\n-        if (VERIFY_BINDINGS) {\n-            if (forUpcall == forArguments) {\n-                verifyBoxBindings(carrier, bindings);\n-            } else {\n-                verifyUnboxBindings(carrier, bindings);\n-            }\n-        }\n+    private MethodType computeCalleeTypeForDowncall() {\n+        return computeTypeHelper(Binding.VMStore.class, Binding.VMLoad.class);\n@@ -187,26 +219,2 @@\n-    private static final Set<Binding.Tag> UNBOX_TAGS = EnumSet.of(\n-        VM_STORE,\n-        \/\/VM_LOAD,\n-        \/\/BUFFER_STORE,\n-        BUFFER_LOAD,\n-        COPY_BUFFER,\n-        \/\/ALLOC_BUFFER,\n-        \/\/BOX_ADDRESS,\n-        UNBOX_ADDRESS,\n-        DUP,\n-        CAST\n-    );\n-\n-    private static void verifyUnboxBindings(Class<?> inType, List<Binding> bindings) {\n-        Deque<Class<?>> stack = new ArrayDeque<>();\n-        stack.push(inType);\n-\n-        for (Binding b : bindings) {\n-            if (!UNBOX_TAGS.contains(b.tag()))\n-                throw new IllegalArgumentException(\"Unexpected operator: \" + b);\n-            b.verify(stack);\n-        }\n-\n-        if (!stack.isEmpty()) {\n-            throw new IllegalArgumentException(\"Stack must be empty after recipe\");\n-        }\n+    private MethodType computeCallerTypeForUpcall() {\n+        return computeTypeHelper(Binding.VMLoad.class, Binding.VMStore.class);\n@@ -215,21 +223,8 @@\n-    private static final Set<Binding.Tag> BOX_TAGS = EnumSet.of(\n-        \/\/VM_STORE,\n-        VM_LOAD,\n-        BUFFER_STORE,\n-        \/\/BUFFER_LOAD,\n-        COPY_BUFFER,\n-        ALLOC_BUFFER,\n-        BOX_ADDRESS,\n-        \/\/UNBOX_ADDRESS,\n-        DUP,\n-        CAST\n-    );\n-\n-    private static void verifyBoxBindings(Class<?> expectedOutType, List<Binding> bindings) {\n-        Deque<Class<?>> stack = new ArrayDeque<>();\n-\n-        for (Binding b : bindings) {\n-            if (!BOX_TAGS.contains(b.tag()))\n-                throw new IllegalArgumentException(\"Unexpected operator: \" + b);\n-            b.verify(stack);\n-        }\n+    private MethodType computeTypeHelper(Class<? extends Binding.Move> inputVMClass,\n+                                         Class<? extends Binding.Move> outputVMClass) {\n+        Class<?>[] paramTypes = inputBindings.stream()\n+                .flatMap(List::stream)\n+                .filter(inputVMClass::isInstance)\n+                .map(inputVMClass::cast)\n+                .map(Binding.Move::type)\n+                .toArray(Class<?>[]::new);\n@@ -237,3 +232,5 @@\n-        if (stack.size() != 1) {\n-            throw new IllegalArgumentException(\"Stack must contain exactly 1 value\");\n-        }\n+        Binding.Move[] retMoves = outputBindings.stream()\n+                .filter(outputVMClass::isInstance)\n+                .map(outputVMClass::cast)\n+                .toArray(Binding.Move[]::new);\n+        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -241,2 +238,1 @@\n-        Class<?> actualOutType = stack.pop();\n-        SharedUtils.checkType(actualOutType, expectedOutType);\n+        return methodType(returnType, paramTypes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":101,"deletions":105,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-public class DowncallLinker {\n+public final class DowncallLinker {\n@@ -120,9 +120,0 @@\n-    \/\/ Funnel from type to Object[]\n-    private static MethodHandle makeCollectorHandle(MethodType type) {\n-        return type.parameterCount() == 0\n-            ? EMPTY_OBJECT_ARRAY_HANDLE\n-            : identity(Object[].class)\n-                .asCollector(Object[].class, type.parameterCount())\n-                .asType(type.changeReturnType(Object[].class));\n-    }\n-\n@@ -139,0 +130,13 @@\n+    private VMStorage[] toStorageArray(Binding.Move[] moves) {\n+        return Arrays.stream(moves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+    }\n+\n+    \/\/ Funnel from type to Object[]\n+    private static MethodHandle makeCollectorHandle(MethodType type) {\n+        return type.parameterCount() == 0\n+            ? EMPTY_OBJECT_ARRAY_HANDLE\n+            : identity(Object[].class)\n+                .asCollector(Object[].class, type.parameterCount())\n+                .asType(type.changeReturnType(Object[].class));\n+    }\n+\n@@ -145,7 +149,3 @@\n-    private VMStorage[] toStorageArray(Binding.Move[] moves) {\n-        return Arrays.stream(moves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n-    }\n-\n-    private record InvocationData(MethodHandle leaf, Map<VMStorage, Integer> argIndexMap, Map<VMStorage, Integer> retIndexMap) {}\n-\n-    Object invokeInterpBindings(SegmentAllocator allocator, Object[] args, InvocationData invData) throws Throwable {\n+    Object invokeInterpBindings(SegmentAllocator allocator,\n+                                Object[] args,\n+                                InvocationData invData) throws Throwable {\n@@ -199,0 +199,2 @@\n+\n+    private record InvocationData(MethodHandle leaf, Map<VMStorage, Integer> argIndexMap, Map<VMStorage, Integer> retIndexMap) {}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":19,"deletions":17,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -38,1 +38,4 @@\n-public class NativeEntryPoint {\n+public final class NativeEntryPoint {\n+    private static final Cleaner CLEANER = CleanerFactory.cleaner();\n+    private static final SoftReferenceCache<CacheKey, NativeEntryPoint> NEP_CACHE = new SoftReferenceCache<>();\n+\n@@ -45,7 +48,0 @@\n-\n-    private static final Cleaner CLEANER = CleanerFactory.cleaner();\n-    private static final SoftReferenceCache<CacheKey, NativeEntryPoint> NEP_CACHE = new SoftReferenceCache<>();\n-    private record CacheKey(MethodType methodType, ABIDescriptor abi,\n-                            List<VMStorage> argMoves, List<VMStorage> retMoves,\n-                            boolean needsReturnBuffer) {}\n-\n@@ -57,0 +53,4 @@\n+    public MethodType type() {\n+        return methodType;\n+    }\n+\n@@ -58,2 +58,4 @@\n-                                        VMStorage[] argMoves, VMStorage[] returnMoves,\n-                                        MethodType methodType, boolean needsReturnBuffer) {\n+                                        VMStorage[] argMoves,\n+                                        VMStorage[] returnMoves,\n+                                        MethodType methodType,\n+                                        boolean needsReturnBuffer) {\n@@ -76,2 +78,4 @@\n-    private static native long makeDowncallStub(MethodType methodType, ABIDescriptor abi,\n-                                                VMStorage[] encArgMoves, VMStorage[] encRetMoves,\n+    private static native long makeDowncallStub(MethodType methodType,\n+                                                ABIDescriptor abi,\n+                                                VMStorage[] encArgMoves,\n+                                                VMStorage[] encRetMoves,\n@@ -80,1 +84,0 @@\n-    private static native boolean freeDowncallStub0(long downcallStub);\n@@ -87,3 +90,1 @@\n-    public MethodType type() {\n-        return methodType;\n-    }\n+    private static native boolean freeDowncallStub0(long downcallStub);\n@@ -92,0 +93,6 @@\n+\n+    private record CacheKey(MethodType methodType,\n+                            ABIDescriptor abi,\n+                            List<VMStorage> argMoves,\n+                            List<VMStorage> retMoves,\n+                            boolean needsReturnBuffer) {}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -68,3 +68,4 @@\n-    private SharedUtils() {\n-    }\n-\n+    \/\/ this allocator should be used when no allocation is expected\n+    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n+        throw new IllegalStateException(\"Cannot get here\");\n+    };\n@@ -92,4 +93,2 @@\n-    \/\/ this allocator should be used when no allocation is expected\n-    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n-        throw new IllegalStateException(\"Cannot get here\");\n-    };\n+    private SharedUtils() {\n+    }\n@@ -101,1 +100,3 @@\n-    public static long align(MemoryLayout t, boolean isVar, long addr) {\n+    public static long align(MemoryLayout t,\n+                             boolean isVar,\n+                             long addr) {\n@@ -129,22 +130,0 @@\n-    private static long alignmentOfScalar(ValueLayout st) {\n-        return st.byteSize();\n-    }\n-\n-    private static long alignmentOfArray(SequenceLayout ar, boolean isVar) {\n-        if (ar.elementCount() == 0) {\n-            \/\/ VLA or incomplete\n-            return 16;\n-        } else if ((ar.byteSize()) >= 16 && isVar) {\n-            return 16;\n-        } else {\n-            \/\/ align as element type\n-            MemoryLayout elementType = ar.elementLayout();\n-            return alignment(elementType, false);\n-        }\n-    }\n-\n-    private static long alignmentOfContainer(GroupLayout ct) {\n-        \/\/ Most strict member\n-        return ct.memberLayouts().stream().mapToLong(t -> alignment(t, false)).max().orElse(1);\n-    }\n-\n@@ -180,0 +159,41 @@\n+    static MethodHandle mergeArguments(MethodHandle mh,\n+                                       int sourceIndex,\n+                                       int destIndex) {\n+        MethodType oldType = mh.type();\n+        Class<?> sourceType = oldType.parameterType(sourceIndex);\n+        Class<?> destType = oldType.parameterType(destIndex);\n+        if (sourceType != destType) {\n+            \/\/ TODO meet?\n+            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n+        }\n+        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n+        int[] reorder = new int[oldType.parameterCount()];\n+        if (destIndex < sourceIndex) {\n+            sourceIndex--;\n+        }\n+        for (int i = 0, index = 0; i < reorder.length; i++) {\n+            if (i != destIndex) {\n+                reorder[i] = index++;\n+            } else {\n+                reorder[i] = sourceIndex;\n+            }\n+        }\n+        return permuteArguments(mh, newType, reorder);\n+    }\n+\n+    static MethodHandle swapArguments(MethodHandle mh,\n+                                      int firstArg,\n+                                      int secondArg) {\n+        MethodType mtype = mh.type();\n+        int[] perms = new int[mtype.parameterCount()];\n+        MethodType swappedType = MethodType.methodType(mtype.returnType());\n+        for (int i = 0 ; i < perms.length ; i++) {\n+            int dst = i;\n+            if (i == firstArg) dst = secondArg;\n+            if (i == secondArg) dst = firstArg;\n+            perms[i] = dst;\n+            swappedType = swappedType.appendParameterTypes(mtype.parameterType(dst));\n+        }\n+        return permuteArguments(mh, swappedType, perms);\n+    }\n+\n@@ -205,4 +225,0 @@\n-    private static MemorySegment bufferCopy(MemorySegment dest, MemorySegment buffer) {\n-        return dest.copyFrom(buffer);\n-    }\n-\n@@ -264,42 +280,0 @@\n-    static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {\n-        MethodType oldType = mh.type();\n-        Class<?> sourceType = oldType.parameterType(sourceIndex);\n-        Class<?> destType = oldType.parameterType(destIndex);\n-        if (sourceType != destType) {\n-            \/\/ TODO meet?\n-            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n-        }\n-        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n-        int[] reorder = new int[oldType.parameterCount()];\n-        if (destIndex < sourceIndex) {\n-            sourceIndex--;\n-        }\n-        for (int i = 0, index = 0; i < reorder.length; i++) {\n-            if (i != destIndex) {\n-                reorder[i] = index++;\n-            } else {\n-                reorder[i] = sourceIndex;\n-            }\n-        }\n-        return permuteArguments(mh, newType, reorder);\n-    }\n-\n-\n-    static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n-        MethodType mtype = mh.type();\n-        int[] perms = new int[mtype.parameterCount()];\n-        MethodType swappedType = MethodType.methodType(mtype.returnType());\n-        for (int i = 0 ; i < perms.length ; i++) {\n-            int dst = i;\n-            if (i == firstArg) dst = secondArg;\n-            if (i == secondArg) dst = firstArg;\n-            perms[i] = dst;\n-            swappedType = swappedType.appendParameterTypes(mtype.parameterType(dst));\n-        }\n-        return permuteArguments(mh, swappedType, perms);\n-    }\n-\n-    private static MethodHandle reachabilityFenceHandle(Class<?> type) {\n-        return MH_REACHABILITY_FENCE.asType(MethodType.methodType(void.class, type));\n-    }\n-\n@@ -378,68 +352,3 @@\n-    public static final class SimpleVaArg {\n-        public final MemoryLayout layout;\n-        public final Object value;\n-\n-        public SimpleVaArg(MemoryLayout layout, Object value) {\n-            this.layout = layout;\n-            this.value = value;\n-        }\n-\n-        public VarHandle varHandle() {\n-            return layout.varHandle();\n-        }\n-    }\n-\n-    public static non-sealed class EmptyVaList implements VaList {\n-\n-        private final MemorySegment address;\n-\n-        public EmptyVaList(MemorySegment address) {\n-            this.address = address;\n-        }\n-\n-        private static UnsupportedOperationException uoe() {\n-            return new UnsupportedOperationException(\"Empty VaList\");\n-        }\n-\n-        @Override\n-        public int nextVarg(ValueLayout.OfInt layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public long nextVarg(ValueLayout.OfLong layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public double nextVarg(ValueLayout.OfDouble layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public void skip(MemoryLayout... layouts) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public VaList copy() {\n-            return this;\n-        }\n-\n-        @Override\n-        public MemorySegment segment() {\n-            return address;\n-        }\n-    }\n-\n-    static void writeOverSized(MemorySegment ptr, Class<?> type, Object o) {\n+    static void writeOverSized(MemorySegment ptr,\n+                               Class<?> type,\n+                               Object o) {\n@@ -469,1 +378,3 @@\n-    static void write(MemorySegment ptr, Class<?> type, Object o) {\n+    static void write(MemorySegment ptr,\n+                      Class<?> type,\n+                      Object o) {\n@@ -512,0 +423,97 @@\n+\n+    private static long alignmentOfScalar(ValueLayout st) {\n+        return st.byteSize();\n+    }\n+\n+    private static long alignmentOfArray(SequenceLayout ar, boolean isVar) {\n+        if (ar.elementCount() == 0) {\n+            \/\/ VLA or incomplete\n+            return 16;\n+        } else if ((ar.byteSize()) >= 16 && isVar) {\n+            return 16;\n+        } else {\n+            \/\/ align as element type\n+            MemoryLayout elementType = ar.elementLayout();\n+            return alignment(elementType, false);\n+        }\n+    }\n+\n+    private static long alignmentOfContainer(GroupLayout ct) {\n+        \/\/ Most strict member\n+        return ct.memberLayouts().stream().mapToLong(t -> alignment(t, false)).max().orElse(1);\n+    }\n+\n+    private static MemorySegment bufferCopy(MemorySegment dest, MemorySegment buffer) {\n+        return dest.copyFrom(buffer);\n+    }\n+\n+    private static MethodHandle reachabilityFenceHandle(Class<?> type) {\n+        return MH_REACHABILITY_FENCE.asType(MethodType.methodType(void.class, type));\n+    }\n+\n+    public static final class SimpleVaArg {\n+        public final MemoryLayout layout;\n+        public final Object value;\n+\n+        public SimpleVaArg(MemoryLayout layout, Object value) {\n+            this.layout = layout;\n+            this.value = value;\n+        }\n+\n+        public VarHandle varHandle() {\n+            return layout.varHandle();\n+        }\n+    }\n+\n+    public static final class EmptyVaList implements VaList {\n+\n+        private final MemorySegment address;\n+\n+        public EmptyVaList(MemorySegment address) {\n+            this.address = address;\n+        }\n+\n+        @Override\n+        public int nextVarg(ValueLayout.OfInt intLayout) {\n+            throw uoe();\n+        }\n+\n+        private static UnsupportedOperationException uoe() {\n+            return new UnsupportedOperationException(\"Empty VaList\");\n+        }\n+\n+        @Override\n+        public long nextVarg(ValueLayout.OfLong longLayout) {\n+            throw uoe();\n+        }\n+\n+        @Override\n+        public double nextVarg(ValueLayout.OfDouble doubleLayout) {\n+            throw uoe();\n+        }\n+\n+        @Override\n+        public MemorySegment nextVarg(ValueLayout.OfAddress addressLayout) {\n+            throw uoe();\n+        }\n+\n+        @Override\n+        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n+            throw uoe();\n+        }\n+\n+        @Override\n+        public void skip(MemoryLayout... layouts) {\n+            throw uoe();\n+        }\n+\n+        @Override\n+        public VaList copy() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MemorySegment segment() {\n+            return address;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":153,"deletions":145,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class SoftReferenceCache<K, V> {\n+final class SoftReferenceCache<K, V> {\n@@ -44,1 +44,1 @@\n-        public Node() {\n+        private Node() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SoftReferenceCache.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-public class UpcallLinker {\n+public final class UpcallLinker {\n@@ -64,1 +64,7 @@\n-    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, MemorySession session) {\n+    private UpcallLinker() {\n+    }\n+\n+    public static MemorySegment make(ABIDescriptor abi,\n+                                     MethodHandle target,\n+                                     CallingSequence callingSequence,\n+                                     MemorySession session) {\n@@ -201,2 +207,5 @@\n-    static native long makeUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv,\n-                                      boolean needsReturnBuffer, long returnBufferSize);\n+    static native long makeUpcallStub(MethodHandle mh,\n+                                      ABIDescriptor abi,\n+                                      CallRegs conv,\n+                                      boolean needsReturnBuffer,\n+                                      long returnBufferSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-    private UpcallStubs() {\n+    static {\n+        registerNatives();\n@@ -37,4 +38,1 @@\n-    private static void freeUpcallStub(long stubAddress) {\n-        if (!freeUpcallStub0(stubAddress)) {\n-            throw new IllegalStateException(\"Not a stub address: \" + stubAddress);\n-        }\n+    private UpcallStubs() {\n@@ -45,8 +43,0 @@\n-    \/\/ returns true if the stub was found (and freed)\n-    private static native boolean freeUpcallStub0(long addr);\n-\n-    private static native void registerNatives();\n-    static {\n-        registerNatives();\n-    }\n-\n@@ -62,0 +52,11 @@\n+\n+    private static void freeUpcallStub(long stubAddress) {\n+        if (!freeUpcallStub0(stubAddress)) {\n+            throw new IllegalStateException(\"Not a stub address: \" + stubAddress);\n+        }\n+    }\n+\n+    \/\/ returns true if the stub was found (and freed)\n+    private static native boolean freeUpcallStub0(long addr);\n+\n+    private static native void registerNatives();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,20 +29,13 @@\n-public class VMStorage {\n-    \/**\n-     * Type of storage. e.g. stack, or which register type (GP, FP, vector)\n-     *\/\n-    private final byte type;\n-\n-    \/**\n-     * The (on stack) size in bytes when type = stack, a register mask otherwise.\n-     * The register mask indicates which segments of a register are used.\n-     *\/\n-    private final short segmentMaskOrSize;\n-\n-    \/**\n-     * The index is either a register number within a type, or\n-     * a stack offset in bytes if type = stack.\n-     * (a particular platform might add a bias to this in generate code)\n-     *\/\n-    private final int indexOrOffset;\n-\n-    private final String debugName;\n+\/**\n+ * @param type              the type of storage. e.g. stack, or which register type (GP, FP, vector)\n+ * @param segmentMaskOrSize The (on stack) size in bytes when type = stack, a register mask, otherwise\n+ *                          the register mask indicates which segments of a register are used.\n+ * @param indexOrOffset     The index is either a register number within a type, or\n+ *                          a stack offset in bytes if type = stack.\n+ *                          (a particular platform might add a bias to this in generate code)\n+ * @param debugName         the debug name to use\n+ *\/\n+public record VMStorage(byte type,\n+                        short segmentMaskOrSize,\n+                        int indexOrOffset,\n+                        String debugName) {\n@@ -50,5 +43,2 @@\n-    private VMStorage(byte type, short segmentMaskOrSize, int indexOrOffset, String debugName) {\n-        this.type = type;\n-        this.segmentMaskOrSize = segmentMaskOrSize;\n-        this.indexOrOffset = indexOrOffset;\n-        this.debugName = debugName;\n+    public VMStorage {\n+        Objects.requireNonNull(debugName);\n@@ -57,1 +47,3 @@\n-    public static VMStorage stackStorage(byte type, short size, int byteOffset) {\n+    public static VMStorage stackStorage(byte type,\n+                                         short size,\n+                                         int byteOffset) {\n@@ -61,1 +53,4 @@\n-    public static VMStorage regStorage(byte type, short segmentMask, int index, String debugName) {\n+    public static VMStorage regStorage(byte type,\n+                                       short segmentMask,\n+                                       int index,\n+                                       String debugName) {\n@@ -65,40 +60,0 @@\n-    public byte type() {\n-        return type;\n-    }\n-\n-    public short segmentMaskOrSize() {\n-        return segmentMaskOrSize;\n-    }\n-\n-    public int indexOrOffset() {\n-        return indexOrOffset;\n-    }\n-\n-    public String name() {\n-        return debugName;\n-    }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        return (o instanceof VMStorage vmStorage)\n-            && type == vmStorage.type\n-            && segmentMaskOrSize == vmStorage.segmentMaskOrSize\n-            && indexOrOffset == vmStorage.indexOrOffset\n-            && Objects.equals(debugName, vmStorage.debugName);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(type, segmentMaskOrSize, indexOrOffset, debugName);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"VMStorage{\" +\n-                \"type=\" + type +\n-                \", segmentMaskOrSize=\" + segmentMaskOrSize +\n-                \", indexOrOffset=\" + indexOrOffset +\n-                \", debugName='\" + debugName + '\\'' +\n-                '}';\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","additions":22,"deletions":67,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-public class AArch64Architecture implements Architecture {\n+public final class AArch64Architecture implements Architecture {\n+\n@@ -57,0 +58,40 @@\n+    public static VMStorage stackStorage(short size, int byteOffset) {\n+        return VMStorage.stackStorage(StorageClasses.STACK, size, byteOffset);\n+    }\n+\n+    public static ABIDescriptor abiFor(VMStorage[] inputIntRegs,\n+                                       VMStorage[] inputVectorRegs,\n+                                       VMStorage[] outputIntRegs,\n+                                       VMStorage[] outputVectorRegs,\n+                                       VMStorage[] volatileIntRegs,\n+                                       VMStorage[] volatileVectorRegs,\n+                                       int stackAlignment,\n+                                       int shadowSpace,\n+                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+        return new ABIDescriptor(\n+            INSTANCE,\n+            new VMStorage[][] {\n+                inputIntRegs,\n+                inputVectorRegs,\n+            },\n+            new VMStorage[][] {\n+                outputIntRegs,\n+                outputVectorRegs,\n+            },\n+            new VMStorage[][] {\n+                volatileIntRegs,\n+                volatileVectorRegs,\n+            },\n+            stackAlignment,\n+            shadowSpace,\n+            targetAddrStorage, retBufAddrStorage);\n+    }\n+\n+    private static VMStorage integerRegister(int index) {\n+        return VMStorage.regStorage(StorageClasses.INTEGER, REG64_MASK, index, \"r\" + index);\n+    }\n+\n+    private static VMStorage vectorRegister(int index) {\n+        return VMStorage.regStorage(StorageClasses.VECTOR, V128_MASK, index, \"v\" + index);\n+    }\n+\n@@ -131,40 +172,0 @@\n-    private static VMStorage integerRegister(int index) {\n-        return VMStorage.regStorage(StorageClasses.INTEGER, REG64_MASK, index, \"r\" + index);\n-    }\n-\n-    private static VMStorage vectorRegister(int index) {\n-        return VMStorage.regStorage(StorageClasses.VECTOR, V128_MASK, index, \"v\" + index);\n-    }\n-\n-    public static VMStorage stackStorage(short size, int byteOffset) {\n-        return VMStorage.stackStorage(StorageClasses.STACK, size, byteOffset);\n-    }\n-\n-    public static ABIDescriptor abiFor(VMStorage[] inputIntRegs,\n-                                       VMStorage[] inputVectorRegs,\n-                                       VMStorage[] outputIntRegs,\n-                                       VMStorage[] outputVectorRegs,\n-                                       VMStorage[] volatileIntRegs,\n-                                       VMStorage[] volatileVectorRegs,\n-                                       int stackAlignment,\n-                                       int shadowSpace,\n-                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n-        return new ABIDescriptor(\n-            INSTANCE,\n-            new VMStorage[][] {\n-                inputIntRegs,\n-                inputVectorRegs,\n-            },\n-            new VMStorage[][] {\n-                outputIntRegs,\n-                outputVectorRegs,\n-            },\n-            new VMStorage[][] {\n-                volatileIntRegs,\n-                volatileVectorRegs,\n-            },\n-            stackAlignment,\n-            shadowSpace,\n-            targetAddrStorage, retBufAddrStorage);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-    private static final int STACK_SLOT_SIZE = 8;\n@@ -68,0 +67,3 @@\n+    public static final CallArranger LINUX = new LinuxAArch64CallArranger();\n+    public static final CallArranger MACOS = new MacOsAArch64CallArranger();\n+    private static final int STACK_SLOT_SIZE = 8;\n@@ -69,1 +71,0 @@\n-\n@@ -95,21 +96,1 @@\n-    \/\/ record\n-    public static class Bindings {\n-        public final CallingSequence callingSequence;\n-        public final boolean isInMemoryReturn;\n-\n-        Bindings(CallingSequence callingSequence, boolean isInMemoryReturn) {\n-            this.callingSequence = callingSequence;\n-            this.isInMemoryReturn = isInMemoryReturn;\n-        }\n-    }\n-\n-    public static final CallArranger LINUX = new LinuxAArch64CallArranger();\n-    public static final CallArranger MACOS = new MacOsAArch64CallArranger();\n-\n-    \/**\n-     * Are variadic arguments assigned to registers as in the standard calling\n-     * convention, or always passed on the stack?\n-     *\n-     * @return true if variadic arguments should be spilled to the stack.\n-      *\/\n-     protected abstract boolean varArgsOnStack();\n+    protected CallArranger() {}\n@@ -122,1 +103,2 @@\n-    protected CallArranger() {}\n+    public final MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n+        Bindings bindings = getBindings(mt, cDesc, false);\n@@ -124,1 +106,12 @@\n-    public Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n+        MethodHandle handle = new DowncallLinker(C, bindings.callingSequence).getBoundMethodHandle();\n+\n+        if (bindings.isInMemoryReturn) {\n+            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n+        }\n+\n+        return handle;\n+    }\n+\n+    public final Bindings getBindings(MethodType mt,\n+                                      FunctionDescriptor cDesc,\n+                                      boolean forUpcall) {\n@@ -152,10 +145,5 @@\n-    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n-\n-        MethodHandle handle = new DowncallLinker(C, bindings.callingSequence).getBoundMethodHandle();\n-\n-        if (bindings.isInMemoryReturn) {\n-            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n-        }\n-\n-        return handle;\n+    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n+        return returnLayout\n+            .filter(GroupLayout.class::isInstance)\n+            .filter(g -> TypeClass.classifyLayout(g) == TypeClass.STRUCT_REFERENCE)\n+            .isPresent();\n@@ -164,1 +152,12 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    \/**\n+     * Are variadic arguments assigned to registers as in the standard calling\n+     * convention, or always passed on the stack?\n+     *\n+     * @return true if variadic arguments should be spilled to the stack.\n+      *\/\n+     protected abstract boolean varArgsOnStack();\n+\n+    public final MemorySegment arrangeUpcall(MethodHandle target,\n+                                             MethodType mt,\n+                                             FunctionDescriptor cDesc,\n+                                             MemorySession session) {\n@@ -174,8 +173,1 @@\n-    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n-        return returnLayout\n-            .filter(GroupLayout.class::isInstance)\n-            .filter(g -> TypeClass.classifyLayout(g) == TypeClass.STRUCT_REFERENCE)\n-            .isPresent();\n-    }\n-\n-    class StorageCalculator {\n+    final class StorageCalculator {\n@@ -183,2 +175,0 @@\n-        private boolean forVarArgs = false;\n-\n@@ -186,0 +176,1 @@\n+        private boolean forVarArgs = false;\n@@ -192,27 +183,2 @@\n-        VMStorage stackAlloc(long size, long alignment) {\n-            assert forArguments : \"no stack returns\";\n-            \/\/ Implementation limit: each arg must take up at least an 8 byte stack slot (on the Java side)\n-            \/\/ There is currently no way to address stack offsets that are not multiples of 8 bytes\n-            \/\/ The VM can only address multiple-of-4-bytes offsets, which is also not good enough for some ABIs\n-            \/\/ see JDK-8283462 and related issues\n-            long stackSlotAlignment = Math.max(alignment, STACK_SLOT_SIZE);\n-            long alignedStackOffset = Utils.alignUp(stackOffset, stackSlotAlignment);\n-            \/\/ macos-aarch64 ABI potentially requires addressing stack offsets that are not multiples of 8 bytes\n-            \/\/ Reject such call types here, to prevent undefined behavior down the line\n-            \/\/ Reject if the above stack-slot-aligned offset does not match the offset the ABI really wants\n-            \/\/ Except for variadic arguments, which _are_ passed at 8-byte-aligned offsets\n-            if (requiresSubSlotStackPacking() && alignedStackOffset != Utils.alignUp(stackOffset, alignment)\n-                    && !forVarArgs) \/\/ varargs are given a pass on all aarch64 ABIs\n-                throw new UnsupportedOperationException(\"Call type not supported on this platform\");\n-\n-            short encodedSize = (short) size;\n-            assert (encodedSize & 0xFFFF) == size;\n-\n-            VMStorage storage =\n-                AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n-            stackOffset = alignedStackOffset + size;\n-            return storage;\n-        }\n-\n-        VMStorage stackAlloc(MemoryLayout layout) {\n-            return stackAlloc(layout.byteSize(), SharedUtils.alignment(layout, true));\n+        VMStorage[] regAlloc(int type, MemoryLayout layout) {\n+            return regAlloc(type, (int)Utils.alignUp(layout.byteSize(), 8) \/ 8);\n@@ -238,4 +204,0 @@\n-        VMStorage[] regAlloc(int type, MemoryLayout layout) {\n-            return regAlloc(type, (int)Utils.alignUp(layout.byteSize(), 8) \/ 8);\n-        }\n-\n@@ -251,0 +213,29 @@\n+        VMStorage stackAlloc(MemoryLayout layout) {\n+            return stackAlloc(layout.byteSize(), SharedUtils.alignment(layout, true));\n+        }\n+\n+        VMStorage stackAlloc(long size, long alignment) {\n+            assert forArguments : \"no stack returns\";\n+            \/\/ Implementation limit: each arg must take up at least an 8 byte stack slot (on the Java side)\n+            \/\/ There is currently no way to address stack offsets that are not multiples of 8 bytes\n+            \/\/ The VM can only address multiple-of-4-bytes offsets, which is also not good enough for some ABIs\n+            \/\/ see JDK-8283462 and related issues\n+            long stackSlotAlignment = Math.max(alignment, STACK_SLOT_SIZE);\n+            long alignedStackOffset = Utils.alignUp(stackOffset, stackSlotAlignment);\n+            \/\/ macos-aarch64 ABI potentially requires addressing stack offsets that are not multiples of 8 bytes\n+            \/\/ Reject such call types here, to prevent undefined behavior down the line\n+            \/\/ Reject if the above stack-slot-aligned offset does not match the offset the ABI really wants\n+            \/\/ Except for variadic arguments, which _are_ passed at 8-byte-aligned offsets\n+            if (requiresSubSlotStackPacking() && alignedStackOffset != Utils.alignUp(stackOffset, alignment)\n+                    && !forVarArgs) \/\/ varargs are given a pass on all aarch64 ABIs\n+                throw new UnsupportedOperationException(\"Call type not supported on this platform\");\n+\n+            short encodedSize = (short) size;\n+            assert (encodedSize & 0xFFFF) == size;\n+\n+            VMStorage storage =\n+                AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n+            stackOffset = alignedStackOffset + size;\n+            return storage;\n+        }\n+\n@@ -312,1 +303,1 @@\n-    class UnboxBindingCalculator extends BindingCalculator {\n+    final class UnboxBindingCalculator extends BindingCalculator {\n@@ -317,8 +308,0 @@\n-        @Override\n-        List<Binding> getIndirectBindings() {\n-            return Binding.builder()\n-                .unboxAddress()\n-                .vmStore(INDIRECT_RESULT, long.class)\n-                .build();\n-        }\n-\n@@ -411,6 +394,0 @@\n-    }\n-\n-    class BoxBindingCalculator extends BindingCalculator {\n-        BoxBindingCalculator(boolean forArguments) {\n-            super(forArguments);\n-        }\n@@ -421,2 +398,2 @@\n-                .vmLoad(INDIRECT_RESULT, long.class)\n-                .boxAddressRaw(Long.MAX_VALUE)\n+                .unboxAddress()\n+                .vmStore(INDIRECT_RESULT, long.class)\n@@ -425,0 +402,6 @@\n+    }\n+\n+    final class BoxBindingCalculator extends BindingCalculator {\n+        BoxBindingCalculator(boolean forArguments) {\n+            super(forArguments);\n+        }\n@@ -431,1 +414,1 @@\n-                case STRUCT_REGISTER: {\n+                case STRUCT_REGISTER -> {\n@@ -435,1 +418,1 @@\n-                        StorageClasses.INTEGER, layout);\n+                            StorageClasses.INTEGER, layout);\n@@ -452,1 +435,0 @@\n-                    break;\n@@ -454,1 +436,1 @@\n-                case STRUCT_REFERENCE: {\n+                case STRUCT_REFERENCE -> {\n@@ -457,1 +439,1 @@\n-                        StorageClasses.INTEGER, AArch64.C_POINTER);\n+                            StorageClasses.INTEGER, AArch64.C_POINTER);\n@@ -460,1 +442,0 @@\n-                    break;\n@@ -462,1 +443,1 @@\n-                case STRUCT_HFA: {\n+                case STRUCT_HFA -> {\n@@ -465,1 +446,1 @@\n-                    GroupLayout group = (GroupLayout)layout;\n+                    GroupLayout group = (GroupLayout) layout;\n@@ -467,1 +448,1 @@\n-                        StorageClasses.VECTOR, group.memberLayouts().size());\n+                            StorageClasses.VECTOR, group.memberLayouts().size());\n@@ -483,1 +464,0 @@\n-                    break;\n@@ -485,1 +465,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -487,1 +467,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n@@ -490,1 +470,0 @@\n-                    break;\n@@ -492,1 +471,1 @@\n-                case INTEGER: {\n+                case INTEGER -> {\n@@ -494,1 +473,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n@@ -496,1 +475,0 @@\n-                    break;\n@@ -498,1 +476,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -500,1 +478,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                            storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n@@ -502,1 +480,0 @@\n-                    break;\n@@ -504,2 +481,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n@@ -509,0 +485,8 @@\n+\n+        @Override\n+        List<Binding> getIndirectBindings() {\n+            return Binding.builder()\n+                .vmLoad(INDIRECT_RESULT, long.class)\n+                .boxAddressRaw(Long.MAX_VALUE)\n+                .build();\n+        }\n@@ -510,0 +494,4 @@\n+\n+    public record Bindings(\n+        CallingSequence callingSequence,\n+        boolean isInMemoryReturn) {}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":103,"deletions":115,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -44,0 +44,10 @@\n+    public static TypeClass classifyLayout(MemoryLayout type) {\n+        if (type instanceof ValueLayout) {\n+            return classifyValueType((ValueLayout) type);\n+        } else if (type instanceof GroupLayout) {\n+            return classifyStructType(type);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n+        }\n+    }\n+\n@@ -58,2 +68,7 @@\n-    static boolean isRegisterAggregate(MemoryLayout type) {\n-        return type.bitSize() <= MAX_AGGREGATE_REGS_SIZE * 64;\n+    private static TypeClass classifyStructType(MemoryLayout layout) {\n+        if (isHomogeneousFloatAggregate(layout)) {\n+            return TypeClass.STRUCT_HFA;\n+        } else if (isRegisterAggregate(layout)) {\n+            return TypeClass.STRUCT_REGISTER;\n+        }\n+        return TypeClass.STRUCT_REFERENCE;\n@@ -94,17 +109,2 @@\n-    private static TypeClass classifyStructType(MemoryLayout layout) {\n-        if (isHomogeneousFloatAggregate(layout)) {\n-            return TypeClass.STRUCT_HFA;\n-        } else if (isRegisterAggregate(layout)) {\n-            return TypeClass.STRUCT_REGISTER;\n-        }\n-        return TypeClass.STRUCT_REFERENCE;\n-    }\n-\n-    public static TypeClass classifyLayout(MemoryLayout type) {\n-        if (type instanceof ValueLayout) {\n-            return classifyValueType((ValueLayout) type);\n-        } else if (type instanceof GroupLayout) {\n-            return classifyStructType(type);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n-        }\n+    static boolean isRegisterAggregate(MemoryLayout type) {\n+        return type.bitSize() <= MAX_AGGREGATE_REGS_SIZE * 64;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class LinuxAArch64CallArranger extends CallArranger {\n+public final class LinuxAArch64CallArranger extends CallArranger {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,8 +45,0 @@\n-    public static LinuxAArch64Linker getInstance() {\n-        final class Holder {\n-            private static final LinuxAArch64Linker INSTANCE = new LinuxAArch64Linker();\n-        }\n-\n-        return Holder.INSTANCE;\n-    }\n-\n@@ -63,1 +55,4 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target,\n+                                          MethodType targetType,\n+                                          FunctionDescriptor function,\n+                                          MemorySession scope) {\n@@ -67,0 +62,8 @@\n+    public static LinuxAArch64Linker getInstance() {\n+        final class Holder {\n+            private static final LinuxAArch64Linker INSTANCE = new LinuxAArch64Linker();\n+        }\n+\n+        return Holder.INSTANCE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.SegmentAllocator;\n@@ -51,2 +57,8 @@\n-public non-sealed class LinuxAArch64VaList implements VaList {\n-    private static final Unsafe U = Unsafe.getUnsafe();\n+public final class LinuxAArch64VaList implements VaList {\n+    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n+        AArch64.C_POINTER.withName(\"__stack\"),\n+        AArch64.C_POINTER.withName(\"__gr_top\"),\n+        AArch64.C_POINTER.withName(\"__vr_top\"),\n+        AArch64.C_INT.withName(\"__gr_offs\"),\n+        AArch64.C_INT.withName(\"__vr_offs\")\n+    ).withName(\"__va_list\");\n@@ -64,9 +76,1 @@\n-\n-    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n-        AArch64.C_POINTER.withName(\"__stack\"),\n-        AArch64.C_POINTER.withName(\"__gr_top\"),\n-        AArch64.C_POINTER.withName(\"__vr_top\"),\n-        AArch64.C_INT.withName(\"__gr_offs\"),\n-        AArch64.C_INT.withName(\"__vr_offs\")\n-    ).withName(\"__va_list\");\n-\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -82,0 +86,1 @@\n+    private static final int MAX_GP_OFFSET = (int) LAYOUT_GP_REGS.byteSize();\n@@ -84,1 +89,1 @@\n-\n+    private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();\n@@ -87,4 +92,0 @@\n-\n-    private static final int MAX_GP_OFFSET = (int) LAYOUT_GP_REGS.byteSize();\n-    private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();\n-\n@@ -103,1 +104,0 @@\n-    private MemorySegment stack;\n@@ -108,0 +108,1 @@\n+    private MemorySegment stack;\n@@ -109,2 +110,6 @@\n-    private LinuxAArch64VaList(MemorySegment segment, MemorySegment stack,\n-                               MemorySegment gpRegsArea, long gpLimit, MemorySegment fpRegsArea, long fpLimit) {\n+    private LinuxAArch64VaList(MemorySegment segment,\n+                               MemorySegment stack,\n+                               MemorySegment gpRegsArea,\n+                               long gpLimit,\n+                               MemorySegment fpRegsArea,\n+                               long fpLimit) {\n@@ -119,98 +124,3 @@\n-    private static LinuxAArch64VaList readFromAddress(long address, MemorySession session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n-        MemorySegment stack = stackPtr(segment); \/\/ size unknown\n-        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).address() - MAX_GP_OFFSET, MAX_GP_OFFSET, session);\n-        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).address() - MAX_FP_OFFSET, MAX_FP_OFFSET, session);\n-        return new LinuxAArch64VaList(segment, stack, gpRegsArea, MAX_GP_OFFSET, fpRegsArea, MAX_FP_OFFSET);\n-    }\n-\n-    private static MemorySegment emptyListAddress() {\n-        long ptr = U.allocateMemory(LAYOUT.byteSize());\n-        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n-        ms.session().addCloseAction(() -> U.freeMemory(ptr));\n-        VH_stack.set(ms, MemorySegment.NULL);\n-        VH_gr_top.set(ms, MemorySegment.NULL);\n-        VH_vr_top.set(ms, MemorySegment.NULL);\n-        VH_gr_offs.set(ms, 0);\n-        VH_vr_offs.set(ms, 0);\n-        return ms;\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    private MemorySegment grTop() {\n-        return grTop(segment);\n-    }\n-\n-    private static MemorySegment grTop(MemorySegment segment) {\n-        return (MemorySegment) VH_gr_top.get(segment);\n-    }\n-\n-    private MemorySegment vrTop() {\n-        return vrTop(segment);\n-    }\n-\n-    private static MemorySegment vrTop(MemorySegment segment) {\n-        return (MemorySegment) VH_vr_top.get(segment);\n-    }\n-\n-    private int grOffs() {\n-        final int offs = (int) VH_gr_offs.get(segment);\n-        assert offs <= 0;\n-        return offs;\n-    }\n-\n-    private int vrOffs() {\n-        final int offs = (int) VH_vr_offs.get(segment);\n-        assert offs <= 0;\n-        return offs;\n-    }\n-\n-    private static MemorySegment stackPtr(MemorySegment segment) {\n-        return (MemorySegment) VH_stack.get(segment);\n-    }\n-\n-    private MemorySegment stackPtr() {\n-        return stackPtr(segment);\n-    }\n-\n-    private void setStack(MemorySegment newStack) {\n-        stack = newStack;\n-        VH_stack.set(segment, stack);\n-    }\n-\n-    private void consumeGPSlots(int num) {\n-        final int old = (int) VH_gr_offs.get(segment);\n-        VH_gr_offs.set(segment, old + num * GP_SLOT_SIZE);\n-    }\n-\n-    private void consumeFPSlots(int num) {\n-        final int old = (int) VH_vr_offs.get(segment);\n-        VH_vr_offs.set(segment, old + num * FP_SLOT_SIZE);\n-    }\n-\n-    private long currentGPOffset() {\n-        \/\/ Offset from start of GP register segment. __gr_top points to the top\n-        \/\/ (highest address) of the GP registers area. __gr_offs is the negative\n-        \/\/ offset of next saved register from the top.\n-\n-        return gpRegsArea.byteSize() + grOffs();\n-    }\n-\n-    private long currentFPOffset() {\n-        \/\/ Offset from start of FP register segment. __vr_top points to the top\n-        \/\/ (highest address) of the FP registers area. __vr_offs is the negative\n-        \/\/ offset of next saved register from the top.\n-\n-        return fpRegsArea.byteSize() + vrOffs();\n-    }\n-\n-    private long preAlignOffset(MemoryLayout layout) {\n-        long alignmentOffset = 0;\n-        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n-            long addr = stack.address();\n-            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n-        }\n-        return alignmentOffset;\n+    @Override\n+    public int nextVarg(ValueLayout.OfInt intLayout) {\n+        return (int) read(intLayout);\n@@ -219,2 +129,3 @@\n-    private void preAlignStack(MemoryLayout layout) {\n-        setStack(stack.asSlice(preAlignOffset(layout)));\n+    @Override\n+    public long nextVarg(ValueLayout.OfLong longLayout) {\n+        return (long) read(longLayout);\n@@ -223,2 +134,3 @@\n-    private void postAlignStack(MemoryLayout layout) {\n-        setStack(stack.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n+    @Override\n+    public double nextVarg(ValueLayout.OfDouble doubleLayout) {\n+        return (double) read(doubleLayout);\n@@ -228,2 +140,2 @@\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress addressLayout) {\n+        return (MemorySegment) read(addressLayout);\n@@ -233,2 +145,3 @@\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read( layout, allocator);\n@@ -238,2 +151,23 @@\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {\n+                checkStackElement(layout);\n+                preAlignStack(layout);\n+                postAlignStack(layout);\n+            } else if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n+                long slots = numSlots(layout);\n+                checkFPElement(layout, slots);\n+                consumeFPSlots((int) slots);\n+            } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n+                checkGPElement(layout, 1);\n+                consumeGPSlots(1);\n+            } else {\n+                long slots = numSlots(layout);\n+                checkGPElement(layout, slots);\n+                consumeGPSlots((int) slots);\n+            }\n+        }\n@@ -243,2 +177,4 @@\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n+    public VaList copy() {\n+        MemorySegment copy = segment.session().allocate(LAYOUT);\n+        copy.copyFrom(segment);\n+        return new LinuxAArch64VaList(copy, stack, gpRegsArea, gpLimit, fpRegsArea, fpLimit);\n@@ -248,3 +184,2 @@\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read( layout, allocator);\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -341,3 +276,10 @@\n-    private void checkGPElement(MemoryLayout layout, long slots) {\n-        if ((grOffs() + MAX_GP_OFFSET) + (slots * GP_SLOT_SIZE) > gpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n+    private static boolean isRegOverflow(long currentGPOffset,\n+                                         long currentFPOffset,\n+                                         TypeClass typeClass,\n+                                         MemoryLayout layout) {\n+        if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n+            return currentFPOffset > MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;\n+        } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n+            return currentGPOffset > MAX_GP_OFFSET - GP_SLOT_SIZE;\n+        } else {\n+            return currentGPOffset > MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;\n@@ -347,4 +289,14 @@\n-    private void checkFPElement(MemoryLayout layout, long slots) {\n-        if ((vrOffs() + MAX_FP_OFFSET) + (slots * FP_SLOT_SIZE) > fpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n+    private long currentGPOffset() {\n+        \/\/ Offset from start of GP register segment. __gr_top points to the top\n+        \/\/ (the highest address) of the GP registers area. __gr_offs is the negative\n+        \/\/ offset of next saved register from the top.\n+\n+        return gpRegsArea.byteSize() + grOffs();\n+    }\n+\n+    private long currentFPOffset() {\n+        \/\/ Offset from start of FP register segment. __vr_top points to the top\n+        \/\/ (the highest address) of the FP registers area. __vr_offs is the negative\n+        \/\/ offset of next saved register from the top.\n+\n+        return fpRegsArea.byteSize() + vrOffs();\n@@ -359,23 +311,11 @@\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {\n-                checkStackElement(layout);\n-                preAlignStack(layout);\n-                postAlignStack(layout);\n-            } else if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n-                long slots = numSlots(layout);\n-                checkFPElement(layout, slots);\n-                consumeFPSlots((int) slots);\n-            } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n-                checkGPElement(layout, 1);\n-                consumeGPSlots(1);\n-            } else {\n-                long slots = numSlots(layout);\n-                checkGPElement(layout, slots);\n-                consumeGPSlots((int) slots);\n-            }\n+    private void preAlignStack(MemoryLayout layout) {\n+        setStack(stack.asSlice(preAlignOffset(layout)));\n+    }\n+\n+    private void postAlignStack(MemoryLayout layout) {\n+        setStack(stack.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n+    }\n+\n+    private void checkGPElement(MemoryLayout layout, long slots) {\n+        if ((grOffs() + MAX_GP_OFFSET) + (slots * GP_SLOT_SIZE) > gpLimit) {\n+            throw SharedUtils.newVaListNSEE(layout);\n@@ -385,2 +325,2 @@\n-    static LinuxAArch64VaList.Builder builder(MemorySession session) {\n-        return new LinuxAArch64VaList.Builder(session);\n+    private static long numSlots(MemoryLayout layout) {\n+        return Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE) \/ STACK_SLOT_SIZE;\n@@ -389,2 +329,3 @@\n-    public static VaList ofAddress(long address, MemorySession session) {\n-        return readFromAddress(address, session);\n+    private void consumeGPSlots(int num) {\n+        final int old = (int) VH_gr_offs.get(segment);\n+        VH_gr_offs.set(segment, old + num * GP_SLOT_SIZE);\n@@ -393,5 +334,4 @@\n-    @Override\n-    public VaList copy() {\n-        MemorySegment copy = segment.session().allocate(LAYOUT);\n-        copy.copyFrom(segment);\n-        return new LinuxAArch64VaList(copy, stack, gpRegsArea, gpLimit, fpRegsArea, fpLimit);\n+    private void checkFPElement(MemoryLayout layout, long slots) {\n+        if ((vrOffs() + MAX_FP_OFFSET) + (slots * FP_SLOT_SIZE) > fpLimit) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n@@ -400,3 +340,3 @@\n-    @Override\n-    public MemorySegment segment() {\n-        return segment.asSlice(0, 0);\n+    private void consumeFPSlots(int num) {\n+        final int old = (int) VH_vr_offs.get(segment);\n+        VH_vr_offs.set(segment, old + num * FP_SLOT_SIZE);\n@@ -405,2 +345,4 @@\n-    private static long numSlots(MemoryLayout layout) {\n-        return Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE) \/ STACK_SLOT_SIZE;\n+    private int grOffs() {\n+        final int offs = (int) VH_gr_offs.get(segment);\n+        assert offs <= 0;\n+        return offs;\n@@ -409,8 +351,11 @@\n-    private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset,\n-                                         TypeClass typeClass, MemoryLayout layout) {\n-        if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n-            return currentFPOffset > MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;\n-        } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n-            return currentGPOffset > MAX_GP_OFFSET - GP_SLOT_SIZE;\n-        } else {\n-            return currentGPOffset > MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;\n+    private int vrOffs() {\n+        final int offs = (int) VH_vr_offs.get(segment);\n+        assert offs <= 0;\n+        return offs;\n+    }\n+\n+    private long preAlignOffset(MemoryLayout layout) {\n+        long alignmentOffset = 0;\n+        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n+            long addr = stack.address();\n+            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n@@ -418,0 +363,6 @@\n+        return alignmentOffset;\n+    }\n+\n+    private void setStack(MemorySegment newStack) {\n+        stack = newStack;\n+        VH_stack.set(segment, stack);\n@@ -431,1 +382,57 @@\n-    public static non-sealed class Builder implements VaList.Builder {\n+    private MemorySegment stackPtr() {\n+        return stackPtr(segment);\n+    }\n+\n+    private MemorySegment grTop() {\n+        return grTop(segment);\n+    }\n+\n+    private MemorySegment vrTop() {\n+        return vrTop(segment);\n+    }\n+\n+    private static MemorySegment stackPtr(MemorySegment segment) {\n+        return (MemorySegment) VH_stack.get(segment);\n+    }\n+\n+    private static MemorySegment grTop(MemorySegment segment) {\n+        return (MemorySegment) VH_gr_top.get(segment);\n+    }\n+\n+    private static MemorySegment vrTop(MemorySegment segment) {\n+        return (MemorySegment) VH_vr_top.get(segment);\n+    }\n+\n+    public static VaList empty() {\n+        return EMPTY;\n+    }\n+\n+    static LinuxAArch64VaList.Builder builder(MemorySession session) {\n+        return new LinuxAArch64VaList.Builder(session);\n+    }\n+\n+    public static VaList ofAddress(long address, MemorySession session) {\n+        return readFromAddress(address, session);\n+    }\n+\n+    private static LinuxAArch64VaList readFromAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n+        MemorySegment stack = stackPtr(segment); \/\/ size unknown\n+        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).address() - MAX_GP_OFFSET, MAX_GP_OFFSET, session);\n+        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).address() - MAX_FP_OFFSET, MAX_FP_OFFSET, session);\n+        return new LinuxAArch64VaList(segment, stack, gpRegsArea, MAX_GP_OFFSET, fpRegsArea, MAX_FP_OFFSET);\n+    }\n+\n+    private static MemorySegment emptyListAddress() {\n+        long ptr = UNSAFE.allocateMemory(LAYOUT.byteSize());\n+        MemorySegment ms = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n+        ms.session().addCloseAction(() -> UNSAFE.freeMemory(ptr));\n+        VH_stack.set(ms, MemorySegment.NULL);\n+        VH_gr_top.set(ms, MemorySegment.NULL);\n+        VH_vr_top.set(ms, MemorySegment.NULL);\n+        VH_gr_offs.set(ms, 0);\n+        VH_vr_offs.set(ms, 0);\n+        return ms;\n+    }\n+\n+    public static final class Builder implements VaList.Builder {\n@@ -435,1 +442,1 @@\n-\n+        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n@@ -438,1 +445,0 @@\n-        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n@@ -527,4 +533,0 @@\n-        private boolean isEmpty() {\n-            return currentGPOffset == 0 && currentFPOffset == 0 && stackArgs.isEmpty();\n-        }\n-\n@@ -564,0 +566,4 @@\n+\n+        private boolean isEmpty() {\n+            return currentGPOffset == 0 && currentFPOffset == 0 && stackArgs.isEmpty();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":198,"deletions":192,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class MacOsAArch64CallArranger extends CallArranger {\n+public final class MacOsAArch64CallArranger extends CallArranger {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * ABI implementation for macOS on Apple Silicon. Based on AAPCS with\n@@ -45,8 +45,0 @@\n-    public static MacOsAArch64Linker getInstance() {\n-        final class Holder {\n-            private static final MacOsAArch64Linker INSTANCE = new MacOsAArch64Linker();\n-        }\n-\n-        return Holder.INSTANCE;\n-    }\n-\n@@ -63,1 +55,4 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target,\n+                                          MethodType targetType,\n+                                          FunctionDescriptor function,\n+                                          MemorySession scope) {\n@@ -67,0 +62,8 @@\n+    public static MacOsAArch64Linker getInstance() {\n+        final class Holder {\n+            private static final MacOsAArch64Linker INSTANCE = new MacOsAArch64Linker();\n+        }\n+\n+        return Holder.INSTANCE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -47,1 +53,1 @@\n-public non-sealed class MacOsAArch64VaList implements VaList {\n+public final class MacOsAArch64VaList implements VaList {\n@@ -59,4 +65,0 @@\n-    public static final VaList empty() {\n-        return EMPTY;\n-    }\n-\n@@ -64,2 +66,2 @@\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n+    public int nextVarg(ValueLayout.OfInt intLayout) {\n+        return (int) read(intLayout);\n@@ -69,2 +71,2 @@\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n+    public long nextVarg(ValueLayout.OfLong longLayout) {\n+        return (long) read(longLayout);\n@@ -74,2 +76,2 @@\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n+    public double nextVarg(ValueLayout.OfDouble doubleLayout) {\n+        return (double) read(doubleLayout);\n@@ -79,2 +81,2 @@\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress addressLayout) {\n+        return (MemorySegment) read(addressLayout);\n@@ -89,0 +91,31 @@\n+    @Override\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            long size = sizeOf(layout);\n+            checkElement(layout, size);\n+            segment = segment.asSlice(size);\n+        }\n+    }\n+\n+    private static long sizeOf(MemoryLayout layout) {\n+        return switch (TypeClass.classifyLayout(layout)) {\n+            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n+            default -> VA_SLOT_SIZE_BYTES;\n+        };\n+    }\n+\n+    @Override\n+    public VaList copy() {\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        return new MacOsAArch64VaList(segment);\n+    }\n+\n+    @Override\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n+    }\n+\n@@ -127,20 +160,0 @@\n-    private static long sizeOf(MemoryLayout layout) {\n-        return switch (TypeClass.classifyLayout(layout)) {\n-            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-            default -> VA_SLOT_SIZE_BYTES;\n-        };\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n-\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            long size = sizeOf(layout);\n-            checkElement(layout, size);\n-            segment = segment.asSlice(size);\n-        }\n-    }\n-\n@@ -153,0 +166,4 @@\n+    public static VaList empty() {\n+        return EMPTY;\n+    }\n+\n@@ -162,12 +179,1 @@\n-    @Override\n-    public VaList copy() {\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n-        return new MacOsAArch64VaList(segment);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n+    public static final class Builder implements VaList.Builder {\n@@ -183,0 +189,5 @@\n+        @Override\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n+            return arg(layout, value);\n+        }\n+\n@@ -190,5 +201,0 @@\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":57,"deletions":51,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.abi.aarch64.AArch64Architecture;\n@@ -34,1 +33,1 @@\n-public class X86_64Architecture implements Architecture {\n+public final class X86_64Architecture implements Architecture {\n@@ -68,0 +67,49 @@\n+    public static VMStorage stackStorage(short size, int byteOffset) {\n+        return VMStorage.stackStorage(StorageClasses.STACK, size, byteOffset);\n+    }\n+\n+    public static ABIDescriptor abiFor(VMStorage[] inputIntRegs,\n+                                       VMStorage[] inputVectorRegs,\n+                                       VMStorage[] outputIntRegs,\n+                                       VMStorage[] outputVectorRegs,\n+                                       int numX87Outputs,\n+                                       VMStorage[] volatileIntRegs,\n+                                       VMStorage[] volatileVectorRegs,\n+                                       int stackAlignment,\n+                                       int shadowSpace,\n+                                       VMStorage targetAddrStorage,\n+                                       VMStorage retBufAddrStorage) {\n+        return new ABIDescriptor(\n+            INSTANCE,\n+            new VMStorage[][] {\n+                inputIntRegs,\n+                inputVectorRegs,\n+            },\n+            new VMStorage[][] {\n+                outputIntRegs,\n+                outputVectorRegs,\n+                IntStream.range(0, numX87Outputs)\n+                        .mapToObj(X86_64Architecture::x87Storage)\n+                        .toArray(VMStorage[]::new)\n+            },\n+            new VMStorage[][] {\n+                volatileIntRegs,\n+                volatileVectorRegs,\n+            },\n+            stackAlignment,\n+            shadowSpace,\n+            targetAddrStorage, retBufAddrStorage);\n+    }\n+\n+    public static VMStorage x87Storage(int index) {\n+        return VMStorage.regStorage(StorageClasses.X87, STP_MASK, index, \"X87(\" + index + \")\");\n+    }\n+\n+    private static VMStorage integerRegister(int index, String debugName) {\n+        return VMStorage.regStorage(StorageClasses.INTEGER, REG64_MASK, index, debugName);\n+    }\n+\n+    private static VMStorage vectorRegister(int index, String debugName) {\n+        return VMStorage.regStorage(StorageClasses.VECTOR, XMM_MASK, index, debugName);\n+    }\n+\n@@ -75,1 +123,1 @@\n-    public static class Regs { \/\/ break circular dependency\n+    public static final class Regs { \/\/ break circular dependency\n@@ -127,40 +175,0 @@\n-    private static VMStorage integerRegister(int index, String debugName) {\n-        return VMStorage.regStorage(StorageClasses.INTEGER, REG64_MASK, index, debugName);\n-    }\n-\n-    private static VMStorage vectorRegister(int index, String debugName) {\n-        return VMStorage.regStorage(StorageClasses.VECTOR, XMM_MASK, index, debugName);\n-    }\n-\n-    public static VMStorage stackStorage(short size, int byteOffset) {\n-        return VMStorage.stackStorage(StorageClasses.STACK, size, byteOffset);\n-    }\n-\n-    public static VMStorage x87Storage(int index) {\n-        return VMStorage.regStorage(StorageClasses.X87, STP_MASK, index, \"X87(\" + index + \")\");\n-    }\n-\n-    public static ABIDescriptor abiFor(VMStorage[] inputIntRegs, VMStorage[] inputVectorRegs, VMStorage[] outputIntRegs,\n-                                       VMStorage[] outputVectorRegs, int numX87Outputs, VMStorage[] volatileIntRegs,\n-                                       VMStorage[] volatileVectorRegs, int stackAlignment, int shadowSpace,\n-                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n-        return new ABIDescriptor(\n-            INSTANCE,\n-            new VMStorage[][] {\n-                inputIntRegs,\n-                inputVectorRegs,\n-            },\n-            new VMStorage[][] {\n-                outputIntRegs,\n-                outputVectorRegs,\n-                IntStream.range(0, numX87Outputs).mapToObj(X86_64Architecture::x87Storage).toArray(VMStorage[]::new)\n-            },\n-            new VMStorage[][] {\n-                volatileIntRegs,\n-                volatileVectorRegs,\n-            },\n-            stackAlignment,\n-            shadowSpace,\n-            targetAddrStorage, retBufAddrStorage);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":51,"deletions":43,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-public class CallArranger {\n+public final class CallArranger {\n@@ -80,5 +80,5 @@\n-    \/\/ record\n-    public static class Bindings {\n-        public final CallingSequence callingSequence;\n-        public final boolean isInMemoryReturn;\n-        public final int nVectorArgs;\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n+        Bindings bindings = getBindings(mt, cDesc, false);\n+\n+        MethodHandle handle = new DowncallLinker(CSysV, bindings.callingSequence).getBoundMethodHandle();\n+        handle = MethodHandles.insertArguments(handle, handle.type().parameterCount() - 1, bindings.nVectorArgs);\n@@ -86,4 +86,2 @@\n-        Bindings(CallingSequence callingSequence, boolean isInMemoryReturn, int nVectorArgs) {\n-            this.callingSequence = callingSequence;\n-            this.isInMemoryReturn = isInMemoryReturn;\n-            this.nVectorArgs = nVectorArgs;\n+        if (bindings.isInMemoryReturn) {\n+            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n@@ -91,0 +89,2 @@\n+\n+        return handle;\n@@ -93,1 +93,3 @@\n-    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n+    public static Bindings getBindings(MethodType mt,\n+                                       FunctionDescriptor cDesc,\n+                                       boolean forUpcall) {\n@@ -125,11 +127,5 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n-\n-        MethodHandle handle = new DowncallLinker(CSysV, bindings.callingSequence).getBoundMethodHandle();\n-        handle = MethodHandles.insertArguments(handle, handle.type().parameterCount() - 1, bindings.nVectorArgs);\n-\n-        if (bindings.isInMemoryReturn) {\n-            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n-        }\n-\n-        return handle;\n+    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n+        return returnLayout\n+                .filter(GroupLayout.class::isInstance)\n+                .filter(g -> TypeClass.classifyLayout(g).inMemory())\n+                .isPresent();\n@@ -138,1 +134,4 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target,\n+                                              MethodType mt,\n+                                              FunctionDescriptor cDesc,\n+                                              MemorySession session) {\n@@ -148,6 +147,4 @@\n-    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n-        return returnLayout\n-                .filter(GroupLayout.class::isInstance)\n-                .filter(g -> TypeClass.classifyLayout(g).inMemory())\n-                .isPresent();\n-    }\n+    public record Bindings(\n+        CallingSequence callingSequence,\n+        boolean isInMemoryReturn,\n+        int nVectorArgs) {}\n@@ -155,1 +152,1 @@\n-    static class StorageCalculator {\n+    static final class StorageCalculator {\n@@ -166,25 +163,0 @@\n-        private int maxRegisterArguments(int type) {\n-            return type == StorageClasses.INTEGER ?\n-                    MAX_INTEGER_ARGUMENT_REGISTERS :\n-                    MAX_VECTOR_ARGUMENT_REGISTERS;\n-        }\n-\n-        VMStorage stackAlloc() {\n-            assert forArguments : \"no stack returns\";\n-            VMStorage storage = X86_64Architecture.stackStorage((short) STACK_SLOT_SIZE, (int)stackOffset);\n-            stackOffset += STACK_SLOT_SIZE;\n-            return storage;\n-        }\n-\n-        VMStorage nextStorage(int type) {\n-            int registerCount = registerCount(type);\n-            if (registerCount < maxRegisterArguments(type)) {\n-                VMStorage[] source =\n-                    (forArguments ? CSysV.inputStorage : CSysV.outputStorage)[type];\n-                incrementRegisterCount(type);\n-                return source[registerCount];\n-            } else {\n-                return stackAlloc();\n-            }\n-        }\n-\n@@ -218,8 +190,16 @@\n-        int registerCount(int type) {\n-            switch (type) {\n-                case StorageClasses.INTEGER:\n-                    return nIntegerReg;\n-                case StorageClasses.VECTOR:\n-                    return nVectorReg;\n-                default:\n-                    throw new IllegalStateException();\n+        VMStorage stackAlloc() {\n+            assert forArguments : \"no stack returns\";\n+            VMStorage storage = X86_64Architecture.stackStorage((short) STACK_SLOT_SIZE, (int)stackOffset);\n+            stackOffset += STACK_SLOT_SIZE;\n+            return storage;\n+        }\n+\n+        VMStorage nextStorage(int type) {\n+            int registerCount = registerCount(type);\n+            if (registerCount < maxRegisterArguments(type)) {\n+                VMStorage[] source =\n+                    (forArguments ? CSysV.inputStorage : CSysV.outputStorage)[type];\n+                incrementRegisterCount(type);\n+                return source[registerCount];\n+            } else {\n+                return stackAlloc();\n@@ -229,0 +209,14 @@\n+        int registerCount(int type) {\n+            return switch (type) {\n+                case StorageClasses.INTEGER -> nIntegerReg;\n+                case StorageClasses.VECTOR -> nVectorReg;\n+                default -> throw new IllegalStateException();\n+            };\n+        }\n+\n+        private int maxRegisterArguments(int type) {\n+            return type == StorageClasses.INTEGER ?\n+                    MAX_INTEGER_ARGUMENT_REGISTERS :\n+                    MAX_VECTOR_ARGUMENT_REGISTERS;\n+        }\n+\n@@ -231,8 +225,3 @@\n-                case StorageClasses.INTEGER:\n-                    nIntegerReg++;\n-                    break;\n-                case StorageClasses.VECTOR:\n-                    nVectorReg++;\n-                    break;\n-                default:\n-                    throw new IllegalStateException();\n+                case StorageClasses.INTEGER -> nIntegerReg++;\n+                case StorageClasses.VECTOR -> nVectorReg++;\n+                default -> throw new IllegalStateException();\n@@ -253,1 +242,1 @@\n-    static class UnboxBindingCalculator extends BindingCalculator {\n+    static final class UnboxBindingCalculator extends BindingCalculator {\n@@ -264,1 +253,1 @@\n-                case STRUCT: {\n+                case STRUCT -> {\n@@ -281,1 +270,0 @@\n-                    break;\n@@ -283,1 +271,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -287,3 +275,2 @@\n-                    break;\n-                }\n-                case INTEGER: {\n+                                    }\n+                case INTEGER -> {\n@@ -292,1 +279,0 @@\n-                    break;\n@@ -294,1 +280,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -297,1 +283,0 @@\n-                    break;\n@@ -299,2 +284,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n@@ -306,1 +290,1 @@\n-    static class BoxBindingCalculator extends BindingCalculator {\n+    static final class BoxBindingCalculator extends BindingCalculator {\n@@ -317,1 +301,1 @@\n-                case STRUCT: {\n+                case STRUCT -> {\n@@ -333,1 +317,0 @@\n-                    break;\n@@ -335,1 +318,1 @@\n-                case POINTER: {\n+                case POINTER -> {\n@@ -339,1 +322,0 @@\n-                    break;\n@@ -341,1 +323,1 @@\n-                case INTEGER: {\n+                case INTEGER -> {\n@@ -344,1 +326,0 @@\n-                    break;\n@@ -346,1 +327,1 @@\n-                case FLOAT: {\n+                case FLOAT -> {\n@@ -349,1 +330,0 @@\n-                    break;\n@@ -351,2 +331,1 @@\n-                default:\n-                    throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n+                default -> throw new UnsupportedOperationException(\"Unhandled class \" + argumentClass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":73,"deletions":94,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -47,3 +53,1 @@\n-public non-sealed class SysVVaList implements VaList {\n-    private static final Unsafe U = Unsafe.getUnsafe();\n-\n+public final class SysVVaList implements VaList {\n@@ -65,1 +69,1 @@\n-\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -99,4 +103,0 @@\n-\n-    private static final int GP_SLOT_SIZE = (int) GP_REG.byteSize();\n-    private static final int FP_SLOT_SIZE = (int) FP_REG.byteSize();\n-\n@@ -105,1 +105,2 @@\n-\n+    private static final int GP_SLOT_SIZE = (int) GP_REG.byteSize();\n+    private static final int FP_SLOT_SIZE = (int) FP_REG.byteSize();\n@@ -114,1 +115,0 @@\n-    private MemorySegment overflowArgArea;\n@@ -118,0 +118,1 @@\n+    private MemorySegment overflowArgArea;\n@@ -121,1 +122,3 @@\n-                       MemorySegment regSaveArea, long gpLimit, long fpLimit) {\n+                       MemorySegment regSaveArea,\n+                       long gpLimit,\n+                       long fpLimit) {\n@@ -129,59 +132,3 @@\n-    private static SysVVaList readFromAddress(long address, MemorySession session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n-        MemorySegment regSaveArea = getRegSaveArea(segment);\n-        MemorySegment overflowArgArea = getArgOverflowArea(segment);\n-        return new SysVVaList(segment, overflowArgArea, regSaveArea, MAX_GP_OFFSET, MAX_FP_OFFSET);\n-    }\n-\n-    private static MemorySegment emptyListAddress() {\n-        long ptr = U.allocateMemory(LAYOUT.byteSize());\n-        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n-        base.session().addCloseAction(() -> U.freeMemory(ptr));\n-        VH_gp_offset.set(base, MAX_GP_OFFSET);\n-        VH_fp_offset.set(base, MAX_FP_OFFSET);\n-        VH_overflow_arg_area.set(base, MemorySegment.NULL);\n-        VH_reg_save_area.set(base, MemorySegment.NULL);\n-        return base;\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    private int currentGPOffset() {\n-        return (int) VH_gp_offset.get(segment);\n-    }\n-\n-    private void currentGPOffset(int i) {\n-        VH_gp_offset.set(segment, i);\n-    }\n-\n-    private int currentFPOffset() {\n-        return (int) VH_fp_offset.get(segment);\n-    }\n-\n-    private void currentFPOffset(int i) {\n-        VH_fp_offset.set(segment, i);\n-    }\n-\n-    private static MemorySegment getRegSaveArea(MemorySegment segment) {\n-        return ((MemorySegment)VH_reg_save_area.get(segment))\n-                .asSlice(0, LAYOUT_REG_SAVE_AREA.byteSize());\n-    }\n-\n-    private static MemorySegment getArgOverflowArea(MemorySegment segment) {\n-        return (MemorySegment)VH_overflow_arg_area.get(segment); \/\/ size unknown\n-    }\n-\n-    private long preAlignOffset(MemoryLayout layout) {\n-        long alignmentOffset = 0;\n-        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n-            long addr = overflowArgArea.address();\n-            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n-        }\n-        return alignmentOffset;\n-    }\n-\n-    private void setOverflowArgArea(MemorySegment newSegment) {\n-        overflowArgArea = newSegment;\n-        VH_overflow_arg_area.set(segment, overflowArgArea);\n+    @Override\n+    public int nextVarg(ValueLayout.OfInt intLayout) {\n+        return (int) read(intLayout);\n@@ -190,2 +137,3 @@\n-    private void preAlignStack(MemoryLayout layout) {\n-        setOverflowArgArea(overflowArgArea.asSlice(preAlignOffset(layout)));\n+    @Override\n+    public long nextVarg(ValueLayout.OfLong longLayout) {\n+        return (long) read(longLayout);\n@@ -194,2 +142,3 @@\n-    private void postAlignStack(MemoryLayout layout) {\n-        setOverflowArgArea(overflowArgArea.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n+    @Override\n+    public double nextVarg(ValueLayout.OfDouble doubleLayout) {\n+        return (double) read(doubleLayout);\n@@ -199,2 +148,2 @@\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress addressLayout) {\n+        return (MemorySegment) read(addressLayout);\n@@ -204,2 +153,3 @@\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(layout, allocator);\n@@ -209,2 +159,16 @@\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            TypeClass typeClass = TypeClass.classifyLayout(layout);\n+            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)) {\n+                checkStackElement(layout);\n+                preAlignStack(layout);\n+                postAlignStack(layout);\n+            } else {\n+                checkRegSaveAreaElement(layout, typeClass);\n+                currentGPOffset(currentGPOffset() + (((int) typeClass.nIntegerRegs()) * GP_SLOT_SIZE));\n+                currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));\n+            }\n+        }\n@@ -214,2 +178,4 @@\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n+    public VaList copy() {\n+        MemorySegment copy = segment.session().allocate(LAYOUT);\n+        copy.copyFrom(segment);\n+        return new SysVVaList(copy, overflowArgArea, regSaveArea, gpLimit, fpLimit);\n@@ -219,3 +185,2 @@\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n@@ -288,7 +253,13 @@\n-    private void checkRegSaveAreaElement(MemoryLayout layout, TypeClass typeClass) {\n-        long gpSize = typeClass.nIntegerRegs() * GP_SLOT_SIZE;\n-        long fpSize = typeClass.nVectorRegs() * FP_SLOT_SIZE;\n-        if (currentGPOffset() + gpSize > gpLimit\n-            || currentFPOffset() + fpSize > fpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n+    private static boolean isRegOverflow(long currentGPOffset,\n+                                         long currentFPOffset,\n+                                         TypeClass typeClass) {\n+        return currentGPOffset > MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE\n+                || currentFPOffset > MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;\n+    }\n+\n+    private int currentGPOffset() {\n+        return (int) VH_gp_offset.get(segment);\n+    }\n+\n+    private int currentFPOffset() {\n+        return (int) VH_fp_offset.get(segment);\n@@ -304,17 +275,2 @@\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)) {\n-                checkStackElement(layout);\n-                preAlignStack(layout);\n-                postAlignStack(layout);\n-            } else {\n-                checkRegSaveAreaElement(layout, typeClass);\n-                currentGPOffset(currentGPOffset() + (((int) typeClass.nIntegerRegs()) * GP_SLOT_SIZE));\n-                currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));\n-            }\n-        }\n+    private void preAlignStack(MemoryLayout layout) {\n+        setOverflowArgArea(overflowArgArea.asSlice(preAlignOffset(layout)));\n@@ -323,2 +279,2 @@\n-    static SysVVaList.Builder builder(MemorySession session) {\n-        return new SysVVaList.Builder(session);\n+    private void postAlignStack(MemoryLayout layout) {\n+        setOverflowArgArea(overflowArgArea.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n@@ -327,2 +283,7 @@\n-    public static VaList ofAddress(long address, MemorySession session) {\n-        return readFromAddress(address, session);\n+    private void checkRegSaveAreaElement(MemoryLayout layout, TypeClass typeClass) {\n+        long gpSize = typeClass.nIntegerRegs() * GP_SLOT_SIZE;\n+        long fpSize = typeClass.nVectorRegs() * FP_SLOT_SIZE;\n+        if (currentGPOffset() + gpSize > gpLimit\n+            || currentFPOffset() + fpSize > fpLimit) {\n+            throw SharedUtils.newVaListNSEE(layout);\n+        }\n@@ -331,5 +292,2 @@\n-    @Override\n-    public VaList copy() {\n-        MemorySegment copy = segment.session().allocate(LAYOUT);\n-        copy.copyFrom(segment);\n-        return new SysVVaList(copy, overflowArgArea, regSaveArea, gpLimit, fpLimit);\n+    private void currentFPOffset(int i) {\n+        VH_fp_offset.set(segment, i);\n@@ -338,3 +296,2 @@\n-    @Override\n-    public MemorySegment segment() {\n-        return segment.asSlice(0, 0);\n+    private void currentGPOffset(int i) {\n+        VH_gp_offset.set(segment, i);\n@@ -343,3 +300,12 @@\n-    private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {\n-        return currentGPOffset > MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE\n-                || currentFPOffset > MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;\n+    private long preAlignOffset(MemoryLayout layout) {\n+        long alignmentOffset = 0;\n+        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n+            long addr = overflowArgArea.address();\n+            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n+        }\n+        return alignmentOffset;\n+    }\n+\n+    private void setOverflowArgArea(MemorySegment newSegment) {\n+        overflowArgArea = newSegment;\n+        VH_overflow_arg_area.set(segment, overflowArgArea);\n@@ -358,1 +324,40 @@\n-    public static non-sealed class Builder implements VaList.Builder {\n+    public static VaList empty() {\n+        return EMPTY;\n+    }\n+\n+    public static VaList ofAddress(long address, MemorySession session) {\n+        return readFromAddress(address, session);\n+    }\n+\n+    private static SysVVaList readFromAddress(long address, MemorySession session) {\n+        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), session);\n+        MemorySegment regSaveArea = getRegSaveArea(segment);\n+        MemorySegment overflowArgArea = getArgOverflowArea(segment);\n+        return new SysVVaList(segment, overflowArgArea, regSaveArea, MAX_GP_OFFSET, MAX_FP_OFFSET);\n+    }\n+\n+    private static MemorySegment getRegSaveArea(MemorySegment segment) {\n+        return ((MemorySegment)VH_reg_save_area.get(segment))\n+                .asSlice(0, LAYOUT_REG_SAVE_AREA.byteSize());\n+    }\n+\n+    private static MemorySegment getArgOverflowArea(MemorySegment segment) {\n+        return (MemorySegment)VH_overflow_arg_area.get(segment); \/\/ size unknown\n+    }\n+\n+    static SysVVaList.Builder builder(MemorySession session) {\n+        return new SysVVaList.Builder(session);\n+    }\n+\n+    private static MemorySegment emptyListAddress() {\n+        long ptr = UNSAFE.allocateMemory(LAYOUT.byteSize());\n+        MemorySegment base = MemorySegment.ofAddress(ptr, LAYOUT.byteSize(), MemorySession.openImplicit());\n+        base.session().addCloseAction(() -> UNSAFE.freeMemory(ptr));\n+        VH_gp_offset.set(base, MAX_GP_OFFSET);\n+        VH_fp_offset.set(base, MAX_FP_OFFSET);\n+        VH_overflow_arg_area.set(base, MemorySegment.NULL);\n+        VH_reg_save_area.set(base, MemorySegment.NULL);\n+        return base;\n+    }\n+\n+    public static final class Builder implements VaList.Builder {\n@@ -361,0 +366,1 @@\n+        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n@@ -363,1 +369,0 @@\n-        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n@@ -437,4 +442,0 @@\n-        private boolean isEmpty() {\n-            return currentGPOffset == 0 && currentFPOffset == FP_OFFSET && stackArgs.isEmpty();\n-        }\n-\n@@ -475,0 +476,4 @@\n+\n+        private boolean isEmpty() {\n+            return currentGPOffset == 0 && currentFPOffset == FP_OFFSET && stackArgs.isEmpty();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":136,"deletions":131,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -43,8 +43,0 @@\n-    public static SysVx64Linker getInstance() {\n-        final class Holder {\n-            private static final SysVx64Linker INSTANCE = new SysVx64Linker();\n-        }\n-\n-        return Holder.INSTANCE;\n-    }\n-\n@@ -54,0 +46,1 @@\n+\n@@ -60,1 +53,4 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target,\n+                                          MethodType targetType,\n+                                          FunctionDescriptor function,\n+                                          MemorySession scope) {\n@@ -64,0 +60,8 @@\n+    public static SysVx64Linker getInstance() {\n+        final class Holder {\n+            private static final SysVx64Linker INSTANCE = new SysVx64Linker();\n+        }\n+\n+        return Holder.INSTANCE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,7 +41,1 @@\n-class TypeClass {\n-    enum Kind {\n-        STRUCT,\n-        POINTER,\n-        INTEGER,\n-        FLOAT\n-    }\n+final class TypeClass {\n@@ -49,1 +43,10 @@\n-    private final Kind kind;\n+    static final List<ArgumentClassImpl> COMPLEX_X87_CLASSES = List.of(\n+         ArgumentClassImpl.X87,\n+         ArgumentClassImpl.X87UP,\n+         ArgumentClassImpl.X87,\n+         ArgumentClassImpl.X87UP\n+    );\n+\n+    \/\/ The AVX 512 enlightened ABI says \"eight eightbytes\"\n+    \/\/ Although AMD64 0.99.6 states 4 eightbytes\n+    private static final int MAX_AGGREGATE_REGS_SIZE = 8;\n@@ -51,0 +54,1 @@\n+    private final Kind kind;\n@@ -57,16 +61,0 @@\n-    public static TypeClass ofValue(ValueLayout layout) {\n-        final Kind kind;\n-        ArgumentClassImpl argClass = argumentClassFor(layout);\n-        kind = switch (argClass) {\n-            case POINTER -> Kind.POINTER;\n-            case INTEGER -> Kind.INTEGER;\n-            case SSE -> Kind.FLOAT;\n-            default -> throw new IllegalStateException(\"Unexpected argument class: \" + argClass);\n-        };\n-        return new TypeClass(kind, List.of(argClass));\n-    }\n-\n-    public static TypeClass ofStruct(GroupLayout layout) {\n-        return new TypeClass(Kind.STRUCT, classifyStructType(layout));\n-    }\n-\n@@ -77,4 +65,0 @@\n-    private long numClasses(ArgumentClassImpl clazz) {\n-        return classes.stream().filter(c -> c == clazz).count();\n-    }\n-\n@@ -85,0 +69,4 @@\n+    private long numClasses(ArgumentClassImpl clazz) {\n+        return classes.stream().filter(c -> c == clazz).count();\n+    }\n+\n@@ -93,0 +81,12 @@\n+    public static TypeClass ofValue(ValueLayout layout) {\n+        final Kind kind;\n+        ArgumentClassImpl argClass = argumentClassFor(layout);\n+        kind = switch (argClass) {\n+            case POINTER -> Kind.POINTER;\n+            case INTEGER -> Kind.INTEGER;\n+            case SSE -> Kind.FLOAT;\n+            default -> throw new IllegalStateException(\"Unexpected argument class: \" + argClass);\n+        };\n+        return new TypeClass(kind, List.of(argClass));\n+    }\n+\n@@ -95,9 +95,18 @@\n-    \/\/ The AVX 512 enlightened ABI says \"eight eightbytes\"\n-    \/\/ Although AMD64 0.99.6 states 4 eightbytes\n-    private static final int MAX_AGGREGATE_REGS_SIZE = 8;\n-    static final List<ArgumentClassImpl> COMPLEX_X87_CLASSES = List.of(\n-         ArgumentClassImpl.X87,\n-         ArgumentClassImpl.X87UP,\n-         ArgumentClassImpl.X87,\n-         ArgumentClassImpl.X87UP\n-    );\n+    public static TypeClass ofStruct(GroupLayout layout) {\n+        return new TypeClass(Kind.STRUCT, classifyStructType(layout));\n+    }\n+\n+    static TypeClass classifyLayout(MemoryLayout type) {\n+        try {\n+            if (type instanceof ValueLayout) {\n+                return ofValue((ValueLayout)type);\n+            } else if (type instanceof GroupLayout) {\n+                return ofStruct((GroupLayout)type);\n+            } else {\n+                throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n+            }\n+        } catch (UnsupportedOperationException e) {\n+            System.err.println(\"Failed to classify layout: \" + type);\n+            throw e;\n+        }\n+    }\n@@ -176,15 +185,0 @@\n-    static TypeClass classifyLayout(MemoryLayout type) {\n-        try {\n-            if (type instanceof ValueLayout) {\n-                return ofValue((ValueLayout)type);\n-            } else if (type instanceof GroupLayout) {\n-                return ofStruct((GroupLayout)type);\n-            } else {\n-                throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n-            }\n-        } catch (UnsupportedOperationException e) {\n-            System.err.println(\"Failed to classify layout: \" + type);\n-            throw e;\n-        }\n-    }\n-\n@@ -205,1 +199,3 @@\n-    private static void groupByEightBytes(MemoryLayout l, long offset, List<ArgumentClassImpl>[] groups) {\n+    private static void groupByEightBytes(MemoryLayout l,\n+                                          long offset,\n+                                          List<ArgumentClassImpl>[] groups) {\n@@ -236,0 +232,7 @@\n+\n+    enum Kind {\n+        STRUCT,\n+        POINTER,\n+        INTEGER,\n+        FLOAT\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":56,"deletions":53,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-public class CallArranger {\n+public final class CallArranger {\n@@ -76,4 +76,2 @@\n-    \/\/ record\n-    public static class Bindings {\n-        public final CallingSequence callingSequence;\n-        public final boolean isInMemoryReturn;\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n+        Bindings bindings = getBindings(mt, cDesc, false);\n@@ -81,3 +79,4 @@\n-        Bindings(CallingSequence callingSequence, boolean isInMemoryReturn) {\n-            this.callingSequence = callingSequence;\n-            this.isInMemoryReturn = isInMemoryReturn;\n+        MethodHandle handle = new DowncallLinker(CWindows, bindings.callingSequence).getBoundMethodHandle();\n+\n+        if (bindings.isInMemoryReturn) {\n+            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n@@ -85,0 +84,2 @@\n+\n+        return handle;\n@@ -87,1 +88,3 @@\n-    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n+    public static Bindings getBindings(MethodType mt,\n+                                       FunctionDescriptor cDesc,\n+                                       boolean forUpcall) {\n@@ -124,10 +127,5 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n-\n-        MethodHandle handle = new DowncallLinker(CWindows, bindings.callingSequence).getBoundMethodHandle();\n-\n-        if (bindings.isInMemoryReturn) {\n-            handle = SharedUtils.adaptDowncallForIMR(handle, cDesc);\n-        }\n-\n-        return handle;\n+    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n+        return returnLayout\n+                .filter(GroupLayout.class::isInstance)\n+                .filter(g -> !TypeClass.isRegisterAggregate(g))\n+                .isPresent();\n@@ -136,1 +134,4 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target,\n+                                              MethodType mt,\n+                                              FunctionDescriptor cDesc,\n+                                              MemorySession session) {\n@@ -146,5 +147,2 @@\n-    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n-        return returnLayout\n-                .filter(GroupLayout.class::isInstance)\n-                .filter(g -> !TypeClass.isRegisterAggregate(g))\n-                .isPresent();\n+    private interface BindingCalculator {\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg);\n@@ -153,1 +151,4 @@\n-    static class StorageCalculator {\n+    public record Bindings(CallingSequence callingSequence,\n+                           boolean isInMemoryReturn) {}\n+\n+    static final class StorageCalculator {\n@@ -186,4 +187,0 @@\n-    private interface BindingCalculator {\n-        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg);\n-    }\n-\n@@ -198,1 +195,3 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+        public List<Binding> getBindings(Class<?> carrier,\n+                                         MemoryLayout layout,\n+                                         boolean isVararg) {\n@@ -252,1 +251,1 @@\n-    static class BoxBindingCalculator implements BindingCalculator {\n+    static final class BoxBindingCalculator implements BindingCalculator {\n@@ -260,1 +259,3 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+        public List<Binding> getBindings(Class<?> carrier,\n+                                         MemoryLayout layout,\n+                                         boolean isVararg) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -40,0 +40,10 @@\n+    static TypeClass typeClassFor(MemoryLayout type, boolean isVararg) {\n+        if (type instanceof ValueLayout) {\n+            return classifyValueType((ValueLayout) type, isVararg);\n+        } else if (type instanceof GroupLayout) {\n+            return classifyStructType(type);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n+        }\n+    }\n+\n@@ -41,1 +51,1 @@\n-        \/\/ No 128 bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but they act just\n+        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but they act just\n@@ -67,8 +77,0 @@\n-    static boolean isRegisterAggregate(MemoryLayout type) {\n-        long size = type.byteSize();\n-        return size == 1\n-            || size == 2\n-            || size == 4\n-            || size == 8;\n-    }\n-\n@@ -82,8 +84,6 @@\n-    static TypeClass typeClassFor(MemoryLayout type, boolean isVararg) {\n-        if (type instanceof ValueLayout) {\n-            return classifyValueType((ValueLayout) type, isVararg);\n-        } else if (type instanceof GroupLayout) {\n-            return classifyStructType(type);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported layout: \" + type);\n-        }\n+    static boolean isRegisterAggregate(MemoryLayout type) {\n+        long size = type.byteSize();\n+        return size == 1\n+            || size == 2\n+            || size == 4\n+            || size == 8;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,1 +28,7 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.VaList;\n+import java.lang.foreign.ValueLayout;\n@@ -57,1 +63,1 @@\n-public non-sealed class WinVaList implements VaList {\n+public final class WinVaList implements VaList {\n@@ -69,4 +75,0 @@\n-    public static final VaList empty() {\n-        return EMPTY;\n-    }\n-\n@@ -74,2 +76,2 @@\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n+    public int nextVarg(ValueLayout.OfInt intLayout) {\n+        return (int) read(intLayout);\n@@ -79,2 +81,2 @@\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n+    public long nextVarg(ValueLayout.OfLong longLayout) {\n+        return (long) read(longLayout);\n@@ -84,2 +86,2 @@\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n+    public double nextVarg(ValueLayout.OfDouble doubleLayout) {\n+        return (double) read(doubleLayout);\n@@ -89,2 +91,2 @@\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n+    public MemorySegment nextVarg(ValueLayout.OfAddress addressLayout) {\n+        return (MemorySegment) read(addressLayout);\n@@ -99,0 +101,22 @@\n+    @Override\n+    public void skip(MemoryLayout... layouts) {\n+        Objects.requireNonNull(layouts);\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        for (MemoryLayout layout : layouts) {\n+            Objects.requireNonNull(layout);\n+            checkElement(layout);\n+            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n+        }\n+    }\n+\n+    @Override\n+    public VaList copy() {\n+        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n+        return new WinVaList(segment);\n+    }\n+\n+    @Override\n+    public MemorySegment segment() {\n+        return segment.asSlice(0, 0);\n+    }\n+\n@@ -135,9 +159,2 @@\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            checkElement(layout);\n-            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        }\n+    public static VaList empty() {\n+        return EMPTY;\n@@ -154,12 +171,1 @@\n-    @Override\n-    public VaList copy() {\n-        MemorySessionImpl.toSessionImpl(segment.session()).checkValidState();\n-        return new WinVaList(segment);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n+    public static final class Builder implements VaList.Builder {\n@@ -175,0 +181,5 @@\n+        @Override\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n+            return arg(layout, value);\n+        }\n+\n@@ -182,5 +193,0 @@\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":46,"deletions":40,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -42,8 +42,0 @@\n-    public static Windowsx64Linker getInstance() {\n-        final class Holder {\n-            private static final Windowsx64Linker INSTANCE = new Windowsx64Linker();\n-        }\n-\n-        return Holder.INSTANCE;\n-    }\n-\n@@ -60,1 +52,4 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession scope) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target,\n+                                          MethodType targetType,\n+                                          FunctionDescriptor function,\n+                                          MemorySession scope) {\n@@ -64,0 +59,8 @@\n+    public static Windowsx64Linker getInstance() {\n+        final class Holder {\n+            private static final Windowsx64Linker INSTANCE = new Windowsx64Linker();\n+        }\n+\n+        return Holder.INSTANCE;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements) {\n+    AbstractGroupLayout(Kind kind,\n+                        List<MemoryLayout> elements) {\n@@ -57,1 +58,4 @@\n-    AbstractGroupLayout(Kind kind, List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+    AbstractGroupLayout(Kind kind,\n+                        List<MemoryLayout> elements,\n+                        long bitAlignment,\n+                        Optional<String> name) {\n@@ -76,3 +80,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -80,11 +81,2 @@\n-    public final String toString() {\n-        return decorateLayoutString(elements.stream()\n-                .map(Object::toString)\n-                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n-    }\n-\n-    \/**\n-     * {@return {@code true}, if this group layout is a struct layout}\n-     *\/\n-    public final boolean isStruct() {\n-        return kind == Kind.STRUCT;\n+    public final boolean hasNaturalAlignment() {\n+        return bitAlignment() == kind.alignof(elements);\n@@ -94,1 +86,1 @@\n-     * {@return {@code true}, if this group layout is a union layout}\n+     * {@inheritDoc}\n@@ -96,2 +88,3 @@\n-    public final boolean isUnion() {\n-        return kind == Kind.UNION;\n+    @Override\n+    public final int hashCode() {\n+        return Objects.hash(super.hashCode(), kind, elements);\n@@ -120,7 +113,4 @@\n-    public final int hashCode() {\n-        return Objects.hash(super.hashCode(), kind, elements);\n-    }\n-\n-    @Override\n-    public final boolean hasNaturalAlignment() {\n-        return bitAlignment() == kind.alignof(elements);\n+    public final String toString() {\n+        return decorateLayoutString(elements.stream()\n+                .map(Object::toString)\n+                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n-import java.lang.foreign.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -45,1 +50,3 @@\n-    AbstractLayout(long bitSize, long bitAlignment, Optional<String> name) {\n+    AbstractLayout(long bitSize,\n+                   long bitAlignment,\n+                   Optional<String> name) {\n@@ -56,2 +63,5 @@\n-    public final Optional<String> name() {\n-        return name;\n+    abstract L dup(long alignment, Optional<String> name);\n+\n+    public final L withBitAlignment(long bitAlignment) {\n+        checkAlignment(bitAlignment);\n+        return dup(bitAlignment, name);\n@@ -60,3 +70,5 @@\n-    public final L withBitAlignment(long alignmentBits) {\n-        checkAlignment(alignmentBits);\n-        return dup(alignmentBits, name);\n+    private static void checkAlignment(long alignmentBitCount) {\n+        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n+                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n+            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n+        }\n@@ -82,8 +94,0 @@\n-    public boolean hasNaturalAlignment() {\n-        return bitSize == bitAlignment;\n-    }\n-\n-    public boolean isPadding() {\n-        return false;\n-    }\n-\n@@ -111,2 +115,2 @@\n-     *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},\n-     *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     *     <li>two group layouts are considered equal if they are of the same type (see {@link StructLayout},\n+     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n@@ -135,1 +139,7 @@\n-    abstract L dup(long alignment, Optional<String> name);\n+    public final Optional<String> name() {\n+        return name;\n+    }\n+\n+    public boolean hasNaturalAlignment() {\n+        return bitSize == bitAlignment;\n+    }\n@@ -147,8 +157,0 @@\n-    private static void checkAlignment(long alignmentBitCount) {\n-        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n-                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n-            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n-        }\n-    }\n-\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -38,1 +38,3 @@\n-    private PaddingLayoutImpl(long bitSize, long bitAlignment, Optional<String> name) {\n+    private PaddingLayoutImpl(long bitSize,\n+                              long bitAlignment,\n+                              Optional<String> name) {\n@@ -43,2 +45,7 @@\n-    public String toString() {\n-        return decorateLayoutString(\"x\" + bitSize());\n+    PaddingLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new PaddingLayoutImpl(bitSize(), bitAlignment, name);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), bitSize());\n@@ -62,7 +69,2 @@\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), bitSize());\n-    }\n-\n-    @Override\n-    PaddingLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new PaddingLayoutImpl(bitSize(), bitAlignment, name);\n+    public String toString() {\n+        return decorateLayoutString(\"x\" + bitSize());\n@@ -76,5 +78,0 @@\n-    @Override\n-    public boolean isPadding() {\n-        return true;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/PaddingLayoutImpl.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout) {\n+    private SequenceLayoutImpl(long elemCount,\n+                               MemoryLayout elementLayout) {\n@@ -42,1 +43,4 @@\n-    private SequenceLayoutImpl(long elemCount, MemoryLayout elementLayout, long bitAlignment, Optional<String> name) {\n+    private SequenceLayoutImpl(long elemCount,\n+                               MemoryLayout elementLayout,\n+                               long bitAlignment,\n+                               Optional<String> name) {\n@@ -48,1 +52,4 @@\n-    \/**\n+    @Override\n+    SequenceLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+        return new SequenceLayoutImpl(elementCount(), elementLayout, bitAlignment, name);\n+    }    \/**\n@@ -55,1 +62,4 @@\n-    \/**\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(super.hashCode(), elemCount, elementLayout);\n+    }    \/**\n@@ -62,1 +72,12 @@\n-    \/**\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!super.equals(other)) {\n+            return false;\n+        }\n+        return other instanceof SequenceLayoutImpl otherSeq &&\n+                elemCount == otherSeq.elemCount &&\n+                elementLayout.equals(otherSeq.elementLayout);\n+    }    \/**\n@@ -75,1 +96,5 @@\n-    \/**\n+    @Override\n+    public String toString() {\n+        return decorateLayoutString(String.format(\"[%s:%s]\",\n+                elemCount, elementLayout));\n+    }    \/**\n@@ -151,1 +176,4 @@\n-    \/**\n+    @Override\n+    public boolean hasNaturalAlignment() {\n+        return bitAlignment() == elementLayout.bitAlignment();\n+    }    \/**\n@@ -178,34 +206,0 @@\n-    @Override\n-    public String toString() {\n-        return decorateLayoutString(String.format(\"[%s:%s]\",\n-                elemCount, elementLayout));\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof SequenceLayoutImpl otherSeq &&\n-                elemCount == otherSeq.elemCount &&\n-                elementLayout.equals(otherSeq.elementLayout);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(super.hashCode(), elemCount, elementLayout);\n-    }\n-\n-    @Override\n-    SequenceLayoutImpl dup(long bitAlignment, Optional<String> name) {\n-        return new SequenceLayoutImpl(elementCount(), elementLayout, bitAlignment, name);\n-    }\n-\n-    @Override\n-    public boolean hasNaturalAlignment() {\n-        return bitAlignment() == elementLayout.bitAlignment();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":35,"deletions":41,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -39,1 +39,3 @@\n-    private StructLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+    private StructLayoutImpl(List<MemoryLayout> elements,\n+                             long bitAlignment,\n+                             Optional<String> name) {\n@@ -44,1 +46,2 @@\n-    StructLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+    StructLayoutImpl dup(long bitAlignment,\n+                         Optional<String> name) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,3 @@\n-    private UnionLayoutImpl(List<MemoryLayout> elements, long bitAlignment, Optional<String> name) {\n+    private UnionLayoutImpl(List<MemoryLayout> elements,\n+                            long bitAlignment,\n+                            Optional<String> name) {\n@@ -44,1 +46,2 @@\n-    UnionLayoutImpl dup(long bitAlignment, Optional<String> name) {\n+    UnionLayoutImpl dup(long bitAlignment,\n+                        Optional<String> name) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -74,1 +73,3 @@\n-        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize) {\n+        AbstractValueLayout(Class<?> carrier,\n+                            ByteOrder order,\n+                            long bitSize) {\n@@ -78,1 +79,5 @@\n-        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize, long bitAlignment, Optional<String> name) {\n+        AbstractValueLayout(Class<?> carrier,\n+                            ByteOrder order,\n+                            long bitSize,\n+                            long bitAlignment,\n+                            Optional<String> name) {\n@@ -85,0 +90,27 @@\n+        static void checkCarrierSize(Class<?> carrier, long size) {\n+            if (!isValidCarrier(carrier)) {\n+                throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n+            }\n+            if (carrier == MemorySegment.class && size != ADDRESS_SIZE_BITS) {\n+                throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n+            }\n+            if (carrier.isPrimitive()) {\n+                int expectedSize = carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n+                if (size != expectedSize) {\n+                    throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+                }\n+            }\n+        }\n+\n+        static boolean isValidCarrier(Class<?> carrier) {\n+            return carrier == boolean.class\n+                    || carrier == byte.class\n+                    || carrier == short.class\n+                    || carrier == char.class\n+                    || carrier == int.class\n+                    || carrier == long.class\n+                    || carrier == float.class\n+                    || carrier == double.class\n+                    || carrier == MemorySegment.class;\n+        }\n+\n@@ -101,22 +133,0 @@\n-        @Override\n-        public final String toString() {\n-            char descriptor = carrier == MemorySegment.class ? 'A' : carrier.descriptorString().charAt(0);\n-            if (order == ByteOrder.LITTLE_ENDIAN) {\n-                descriptor = Character.toLowerCase(descriptor);\n-            }\n-            return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (this == other) {\n-                return true;\n-            }\n-            if (!super.equals(other)) {\n-                return false;\n-            }\n-            return other instanceof AbstractValueLayout<?> otherValue &&\n-                    carrier.equals(otherValue.carrier) &&\n-                    order.equals(otherValue.order);\n-        }\n-\n@@ -138,0 +148,5 @@\n+        @SuppressWarnings(\"unchecked\")\n+        final V self() {\n+            return (V) this;\n+        }\n+\n@@ -145,0 +160,3 @@\n+        @Override\n+        abstract V dup(long bitAlignment, Optional<String> name);\n+\n@@ -151,8 +169,3 @@\n-        abstract V dup(long bitAlignment, Optional<String> name);\n-\n-        static void checkCarrierSize(Class<?> carrier, long size) {\n-            if (!isValidCarrier(carrier)) {\n-                throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n-            }\n-            if (carrier == MemorySegment.class && size != ADDRESS_SIZE_BITS) {\n-                throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n@@ -160,5 +173,2 @@\n-            if (carrier.isPrimitive()) {\n-                int expectedSize = carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n-                if (size != expectedSize) {\n-                    throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n-                }\n+            if (!super.equals(other)) {\n+                return false;\n@@ -166,0 +176,3 @@\n+            return other instanceof AbstractValueLayout<?> otherValue &&\n+                    carrier.equals(otherValue.carrier) &&\n+                    order.equals(otherValue.order);\n@@ -168,10 +181,7 @@\n-        static boolean isValidCarrier(Class<?> carrier) {\n-            return carrier == boolean.class\n-                    || carrier == byte.class\n-                    || carrier == short.class\n-                    || carrier == char.class\n-                    || carrier == int.class\n-                    || carrier == long.class\n-                    || carrier == float.class\n-                    || carrier == double.class\n-                    || carrier == MemorySegment.class;\n+        @Override\n+        public final String toString() {\n+            char descriptor = carrier == MemorySegment.class ? 'A' : carrier.descriptorString().charAt(0);\n+            if (order == ByteOrder.LITTLE_ENDIAN) {\n+                descriptor = Character.toLowerCase(descriptor);\n+            }\n+            return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n@@ -180,1 +190,0 @@\n-\n@@ -189,5 +198,0 @@\n-\n-        @SuppressWarnings(\"unchecked\")\n-        final V self() {\n-            return (V) this;\n-        }\n@@ -206,5 +210,0 @@\n-        @Override\n-        OfBooleanImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfBooleanImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -217,0 +216,5 @@\n+        @Override\n+        OfBooleanImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfBooleanImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -232,5 +236,0 @@\n-        @Override\n-        OfByteImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfByteImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -243,0 +242,5 @@\n+        @Override\n+        OfByteImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfByteImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -258,5 +262,0 @@\n-        @Override\n-        OfCharImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfCharImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -269,0 +268,5 @@\n+        @Override\n+        OfCharImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfCharImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -284,5 +288,0 @@\n-        @Override\n-        OfShortImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfShortImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -295,0 +294,5 @@\n+        @Override\n+        OfShortImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfShortImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -310,5 +314,0 @@\n-        @Override\n-        OfIntImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfIntImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -321,0 +320,5 @@\n+        @Override\n+        OfIntImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfIntImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -336,5 +340,0 @@\n-        @Override\n-        OfFloatImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfFloatImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -347,0 +346,5 @@\n+        @Override\n+        OfFloatImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfFloatImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -362,5 +366,0 @@\n-        @Override\n-        OfLongImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfLongImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -373,0 +372,5 @@\n+        @Override\n+        OfLongImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfLongImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -388,5 +392,0 @@\n-        @Override\n-        OfDoubleImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfDoubleImpl(order(), bitAlignment, name);\n-        }\n-\n@@ -399,0 +398,5 @@\n+        @Override\n+        OfDoubleImpl dup(long bitAlignment, Optional<String> name) {\n+            return new OfDoubleImpl(order(), bitAlignment, name);\n+        }\n+\n@@ -419,5 +423,0 @@\n-        @Override\n-        OfAddressImpl dup(long alignment, Optional<String> name) {\n-            return new OfAddressImpl(order(), bitSize(), alignment, isUnbounded, name);\n-        }\n-\n@@ -441,0 +440,5 @@\n+        @Override\n+        OfAddressImpl dup(long alignment, Optional<String> name) {\n+            return new OfAddressImpl(order(), bitSize(), alignment, isUnbounded, name);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":103,"deletions":99,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *          java.base\/jdk.internal.foreign.layout\n@@ -48,1 +49,1 @@\n-        ValueLayout newLayout = MemoryLayout.valueLayout(layout.carrier(), layout.order());\n+        ValueLayout newLayout = ValueLayoutUtil.valueLayout(layout.carrier(), layout.order());\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-            public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            public MemorySegment allocate(long bytesSize, long byteAlignment) {\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+import jdk.internal.foreign.layout.ValueLayouts;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+import java.util.Objects;\n+\n+public final class ValueLayoutUtil {\n+\n+    private ValueLayoutUtil() {\n+    }\n+\n+    \/**\n+     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n+     * by the carrier provided:\n+     * <ul>\n+     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n+     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n+     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n+     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n+     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n+     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n+     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n+     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n+     * <\/ul>\n+     * @param carrier the value layout carrier.\n+     * @param order the value layout's byte order.\n+     * @return a value layout with the given Java carrier and byte-order.\n+     * @throws IllegalArgumentException if the carrier type is not supported.\n+     *\/\n+    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(order);\n+        if (carrier == boolean.class) {\n+            return ValueLayouts.OfBooleanImpl.of(order);\n+        } else if (carrier == char.class) {\n+            return ValueLayouts.OfCharImpl.of(order);\n+        } else if (carrier == byte.class) {\n+            return ValueLayouts.OfByteImpl.of(order);\n+        } else if (carrier == short.class) {\n+            return ValueLayouts.OfShortImpl.of(order);\n+        } else if (carrier == int.class) {\n+            return ValueLayouts.OfIntImpl.of(order);\n+        } else if (carrier == float.class) {\n+            return ValueLayouts.OfFloatImpl.of(order);\n+        } else if (carrier == long.class) {\n+            return ValueLayouts.OfLongImpl.of(order);\n+        } else if (carrier == double.class) {\n+            return ValueLayouts.OfDoubleImpl.of(order);\n+        } else if (carrier == MemorySegment.class) {\n+            return ValueLayouts.OfAddressImpl.of(order);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/ValueLayoutUtil.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -65,2 +65,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -89,2 +89,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -119,2 +119,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -141,2 +141,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -201,2 +201,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -232,2 +232,2 @@\n-        assertTrue(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -256,2 +256,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -285,2 +285,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -323,2 +323,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -377,2 +377,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -406,2 +406,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -429,2 +429,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -78,1 +78,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -94,2 +94,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -108,1 +108,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -125,2 +125,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -139,1 +139,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -155,2 +155,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -169,1 +169,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -185,2 +185,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -199,1 +199,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -210,2 +210,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -228,1 +228,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -241,2 +241,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -261,1 +261,1 @@\n-        assertEquals(bindings.nVectorArgs, 8);\n+        assertEquals(bindings.nVectorArgs(), 8);\n@@ -276,2 +276,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -306,1 +306,1 @@\n-        assertEquals(bindings.nVectorArgs, 8);\n+        assertEquals(bindings.nVectorArgs(), 8);\n@@ -333,2 +333,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -359,1 +359,1 @@\n-        assertEquals(bindings.nVectorArgs, 3);\n+        assertEquals(bindings.nVectorArgs(), 3);\n@@ -376,2 +376,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -389,1 +389,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -398,2 +398,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -411,1 +411,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -457,2 +457,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -478,1 +478,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -489,2 +489,2 @@\n-        assertTrue(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -502,1 +502,1 @@\n-        assertEquals(bindings.nVectorArgs, 0);\n+        assertEquals(bindings.nVectorArgs(), 0);\n@@ -513,2 +513,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -526,1 +526,1 @@\n-        assertEquals(bindings.nVectorArgs, 1);\n+        assertEquals(bindings.nVectorArgs(), 1);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -81,2 +81,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -103,2 +103,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -127,2 +127,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -158,2 +158,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -195,2 +195,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -229,2 +229,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -259,2 +259,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -290,2 +290,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -311,2 +311,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -335,2 +335,2 @@\n-        assertTrue(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n@@ -364,2 +364,2 @@\n-        assertFalse(bindings.isInMemoryReturn);\n-        CallingSequence callingSequence = bindings.callingSequence;\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        MemorySegment symbol = symbolLookup.lookup(\"start_threads\").orElseThrow();\n+        MemorySegment symbol = symbolLookup.find(\"start_threads\").orElseThrow();\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *          java.base\/jdk.internal.foreign.layout\n@@ -49,1 +50,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -52,0 +52,2 @@\n+\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -56,0 +58,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -64,0 +67,1 @@\n+import java.util.Objects;\n@@ -172,1 +176,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(valueLayout(carrier, ByteOrder.nativeOrder()));\n@@ -389,0 +393,26 @@\n+    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(order);\n+        if (carrier == boolean.class) {\n+            return ValueLayouts.OfBooleanImpl.of(order);\n+        } else if (carrier == char.class) {\n+            return ValueLayouts.OfCharImpl.of(order);\n+        } else if (carrier == byte.class) {\n+            return ValueLayouts.OfByteImpl.of(order);\n+        } else if (carrier == short.class) {\n+            return ValueLayouts.OfShortImpl.of(order);\n+        } else if (carrier == int.class) {\n+            return ValueLayouts.OfIntImpl.of(order);\n+        } else if (carrier == float.class) {\n+            return ValueLayouts.OfFloatImpl.of(order);\n+        } else if (carrier == long.class) {\n+            return ValueLayouts.OfLongImpl.of(order);\n+        } else if (carrier == double.class) {\n+            return ValueLayouts.OfDoubleImpl.of(order);\n+        } else if (carrier == MemorySegment.class) {\n+            return ValueLayouts.OfAddressImpl.of(order);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"}]}