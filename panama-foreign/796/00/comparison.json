{"files":[{"patch":"@@ -321,1 +321,1 @@\n-        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.BITS_TO_BYTES_THROW_OFFSET);\n+        return Utils.bitsToBytes(bitOffset(elements));\n@@ -359,1 +359,1 @@\n-        mh = MethodHandles.filterReturnValue(mh, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET);\n+        mh = MethodHandles.filterReturnValue(mh, Utils.MH_BITS_TO_BYTES_FOR_OFFSET);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-                    Utils.bitsToBytesOrThrow(strides[i], IllegalArgumentException::new),\n+                    Utils.bitsToBytes(strides[i]),\n@@ -206,1 +206,1 @@\n-                Utils.bitsToBytesOrThrow(offset, IllegalArgumentException::new));\n+                Utils.bitsToBytes(offset));\n@@ -235,5 +235,0 @@\n-        if (strides.length == 0) {\n-            \/\/ trigger checks eagerly\n-            Utils.bitsToBytesOrThrow(offset, Utils.BITS_TO_BYTES_THROW_OFFSET);\n-        }\n-\n@@ -241,1 +236,1 @@\n-        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET); \/\/ byte offset\n+        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_BITS_TO_BYTES_FOR_OFFSET); \/\/ byte offset\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.lang.foreign.Arena;\n@@ -43,1 +42,1 @@\n-import java.util.function.Supplier;\n+\n@@ -57,0 +56,1 @@\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n@@ -63,4 +63,1 @@\n-    public static final MethodHandle MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET;\n-\n-    public static final Supplier<RuntimeException> BITS_TO_BYTES_THROW_OFFSET\n-            = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n+    public static final MethodHandle MH_BITS_TO_BYTES_FOR_OFFSET;\n@@ -79,5 +76,2 @@\n-            MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET = MethodHandles.insertArguments(\n-                    lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n-                            MethodType.methodType(long.class, long.class, Supplier.class)),\n-                    1,\n-                    BITS_TO_BYTES_THROW_OFFSET);\n+            MH_BITS_TO_BYTES_FOR_OFFSET = lookup.findStatic(Utils.class, \"bitsToBytes\",\n+                    MethodType.methodType(long.class, long.class));\n@@ -98,6 +92,3 @@\n-    public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {\n-        if (Utils.isAligned(bits, 8)) {\n-            return bits \/ 8;\n-        } else {\n-            throw exFactory.get();\n-        }\n+    public static long bitsToBytes(long bits) {\n+        \/\/ We are always bit-aligned at a byte boundary\n+        return bits \/ Byte.SIZE;\n@@ -118,2 +109,2 @@\n-                case 8 -> long.class;\n-                case 4 -> int.class;\n+                case Long.BYTES -> long.class;\n+                case Integer.BYTES -> int.class;\n@@ -131,1 +122,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress) {\n+        } else if (layout instanceof ValueLayout.OfAddress addressLayout) {\n@@ -135,1 +126,1 @@\n-                            pointeeSize(layout), pointeeAlign(layout)));\n+                            pointeeByteSize(addressLayout), pointeeByteAlign(addressLayout)));\n@@ -183,1 +174,1 @@\n-        if (layout.bitAlignment() > layout.bitSize()) {\n+        if (layout.byteAlignment() > layout.byteSize()) {\n@@ -188,6 +179,4 @@\n-    public static long pointeeSize(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n-            return addressLayout.targetLayout().map(MemoryLayout::byteSize).orElse(0L);\n-        } else {\n-            throw new UnsupportedOperationException();\n-        }\n+    public static long pointeeByteSize(ValueLayout.OfAddress addressLayout) {\n+        return addressLayout.targetLayout()\n+                .map(MemoryLayout::byteSize)\n+                .orElse(0L);\n@@ -196,6 +185,4 @@\n-    public static long pointeeAlign(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n-            return addressLayout.targetLayout().map(MemoryLayout::byteAlignment).orElse(1L);\n-        } else {\n-            throw new UnsupportedOperationException();\n-        }\n+    public static long pointeeByteAlign(ValueLayout.OfAddress addressLayout) {\n+        return addressLayout.targetLayout()\n+                .map(MemoryLayout::byteAlignment)\n+                .orElse(1L);\n@@ -228,1 +215,2 @@\n-     * {@return return a struct layout constructed from the given elements, with padding computed automatically}\n+     * {@return return a struct layout constructed from the given elements, with padding\n+     * computed automatically so that they are naturally aligned}.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":24,"deletions":36,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.Linker;\n@@ -497,1 +496,2 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, (ValueLayout) layout);\n+                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, addressLayout);\n@@ -499,1 +499,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -396,0 +397,1 @@\n+                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n@@ -398,1 +400,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -319,0 +320,1 @@\n+                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n@@ -321,1 +323,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -279,0 +280,1 @@\n+                    ValueLayout.OfAddress addressLayout = (ValueLayout.OfAddress)layout;\n@@ -281,1 +283,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout), Utils.pointeeAlign(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}