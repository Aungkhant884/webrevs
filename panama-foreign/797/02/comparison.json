{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Linker.Option;\n@@ -31,0 +32,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -43,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -347,1 +350,3 @@\n- * to the code calling the foreign function and hoping to use its result.\n+ * to the code calling the foreign function and hoping to use its result. In addition to having no insight\n+ * into the size of the region of memory backing a pointer returned from a foreign function, it also has no insight\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it.\n@@ -349,8 +354,18 @@\n- * The {@link Linker} represents a pointer returned from a foreign function with a <em>zero-length memory segment<\/em>.\n- * The address of the segment is the address stored in the pointer. The size of the segment is zero. Similarly, when a\n- * client reads an <em>address<\/em> from a memory segment, a zero-length memory segment is returned.\n- * <p>\n- * Since a zero-length segment features trivial spatial bounds, any attempt to access these segments will fail with\n- * {@link IndexOutOfBoundsException}. This is a crucial safety feature: as these segments are associated with a region\n- * of memory whose size is not known, any access operations involving these segments cannot be validated.\n- * In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent.\n+ * The {@code MemorySegment} API uses <em>zero-length memory segments<\/em> to represent:\n+ * <ul>\n+ *     <li>pointers returned from a foreign function;<\/li>\n+ *     <li>pointers passed by a foreign function to an\n+ *     {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}; and<\/li>\n+ *     <li>pointers {@linkplain MemorySegment#get(OfAddress, long) read} from a memory segment.<\/li>\n+ * <\/ul>\n+ * The address of the zero-length segment is the address stored in the pointer. The spatial and temporal bounds of the\n+ * zero-length segment are as follows:\n+ * <ul>\n+ *     <li>The size of the segment is zero. any attempt to access these segments will fail with {@link IndexOutOfBoundsException}.\n+ *     This is a crucial safety feature: as these segments are associated with a region\n+ *     of memory whose size is not known, any access operations involving these segments cannot be validated.\n+ *     In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent\n+ *     (see below);<\/li>\n+ *     <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length\n+ *     memory segments cannot be accessed directly, they can be passed, opaquely, to other pointer-accepting foreign functions.<\/li>\n+ * <\/ul>\n@@ -358,5 +373,1 @@\n- * Zero-length memory segments obtained when interacting with foreign functions are associated with\n- * a fresh scope that is always alive. This is because the Java runtime, in addition to having no insight\n- * into the size of the region of memory backing a pointer returned from a foreign function, also has no insight\n- * into the lifetime intended for said region of memory by the foreign function that allocated it. Thus, zero-length\n- * memory segments cannot be accessed directly, but can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * To work with native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>.\n@@ -364,1 +375,9 @@\n- * To access native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>.\n+ * First, clients can unsafely resize a zero-length memory segment by {@linkplain #reinterpret(long) obtaining} a\n+ * memory segment with the same base address as the zero-length memory segment, but with the desired size,\n+ * so that the resulting segment can then be accessed directly, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ size = 0\n+ *                                    .reinterpret(4)               \/\/ size = 4\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n+ *}\n@@ -366,3 +385,3 @@\n- * First, clients can unsafely resize a zero-length memory segment by {@linkplain #asUnbounded() obtaining} a\n- * memory segment with same base address as the zero-length memory segment, but with maximal size (i.e. {@link Long#MAX_VALUE}).\n- * This segment can then be resized as needed, so that the resulting segment can then be accessed directly, as follows:\n+ * In some cases, a client might additionally want to assign new temporal bounds to a zero-length memory segment.\n+ * This can be done using the {@link #reinterpret(long, Scope, Consumer)} method, which returns a\n+ * new native segment with the desired size and the same temporal bounds as those in the provided arena:\n@@ -371,4 +390,7 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n- * foreign = foreign.asUnbounded()                                  \/\/ size = Long.MAX_VALUE\n- *                  .asSlice(0, JAVA_INT);                          \/\/ size = 4\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ok\n+ * MemorySegment foreign = null;\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *       foreign = someSegment.get(ValueLayout.ADDRESS, 0)           \/\/ size = 0, scope = always alive\n+ *                            .reinterpret(4, arena.scope(), null);  \/\/ size = 4, scope = arena.scope()\n+ *       int x = foreign.get(ValueLayout.JAVA_INT, 0);               \/\/ ok\n+ * }\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ throws IllegalStateException\n@@ -384,2 +406,2 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ wrap address into segment (size = 4)\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ size = 4\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                                               \/\/ ok\n@@ -387,15 +409,0 @@\n- *\n- * Finally, clients can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, Arena) obtain}\n- * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n- *\n- * {@snippet lang = java:\n- * Arena arena = ... \/\/ obtains an arena\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n- * foreign = MemorySegment.ofAddress(foreign.address(), 4, arena);  \/\/ create new segment (size = 4)\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n- *}\n- *\n- * All of {@link #asUnbounded()}, {@link ValueLayout.OfAddress#withTargetLayout(MemoryLayout)}\n- * and {@link #ofAddress(long, long, Arena)} are\n- * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n- * for instance, resizing a segment incorrectly could result in a VM crash when attempting to access the memory segment.\n@@ -409,0 +416,7 @@\n+ * <p>\n+ * All the methods which can be used to manipulate zero-length memory segments\n+ * ({@link #reinterpret(long)}, {@link #reinterpret(Scope, Consumer)}, {@link #reinterpret(long, Scope, Consumer)} and\n+ * {@link ValueLayout.OfAddress#withTargetLayout(MemoryLayout)}) are\n+ * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n+ * assigning a segment incorrect spatial and\/or temporal bounds could result in a VM crash when attempting to access\n+ * the memory segment.\n@@ -559,3 +573,2 @@\n-     * Returns a new memory segment that has the same address and lifecycle as this segment, but with <em>unbounded<\/em> size.\n-     * That is, the byte size of the returned segment is set to {@link Long#MAX_VALUE}. This method\n-     * can be used, in combination with other slicing methods, to resize zero-length memory segments:\n+     * Returns a new memory segment that has the same address and scope as this segment, but with the provided size.\n+     * Equivalent to the following code:\n@@ -563,3 +576,1 @@\n-     * MemorySegment zeroLengthSegment = ... \/\/ (size = 0)\n-     * MemorySegment intSegment = zeroLengthSegment.asUnbounded() \/\/ (size = Long.MAX_VALUE)\n-     *                                             .asSlice(0, ValueLayout.JAVA_INT) \/\/ (size = 0)\n+     * reinterpret(newSize, scope(), null);\n@@ -573,0 +584,24 @@\n+     * @param newSize the size of the returned segment.\n+     * @return a new memory segment that has the same address and scope as this segment, but the new\n+     * provided size.\n+     * @throws IllegalArgumentException if {@code newSize < 0}.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     *\/\n+    @CallerSensitive\n+    MemorySegment reinterpret(long newSize);\n+\n+    \/**\n+     * Returns a new memory segment with the same address and size as this segment, but with the provided scope.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * reinterpret(byteSize(), scope, cleanup);\n+     * }\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param newScope the scope of the returned segment.\n+     * @param cleanup the cleanup action that should be executed when the provided arena is closed (can be {@code null}).\n@@ -574,0 +609,42 @@\n+     * @throws IllegalArgumentException if {@code newSize < 0}.\n+     * @throws IllegalStateException if {@code scope.isAlive() == false}.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     *\/\n+    @CallerSensitive\n+    MemorySegment reinterpret(Scope newScope, Consumer<MemorySegment> cleanup);\n+\n+    \/**\n+     * Returns a new segment with the same address as this segment, but with the provided size and scope.\n+     * As such, the returned segment cannot be accessed after the provided\n+     * scope has been invalidated. Moreover, if the provided scope is an arena scope,\n+     * the returned segment can be accessed compatibly with the confinement restrictions associated with the\n+     * corresponding arena: that is, if the provided scope is the scope of a {@linkplain Arena#ofConfined() confined arena},\n+     * the returned segment can only be accessed by the arena's owner thread, regardless of the confinement restrictions\n+     * associated with this segment. In other words, if the provided scope is an arena scope, this method returns a segment\n+     * that behaves as if it had been allocated using the arena associated with the provided scope.\n+     * <p>\n+     * Clients can specify an optional cleanup action that should be executed when the provided scope becomes\n+     * invalid. This cleanup action receives a fresh memory segment that is obtained from this segment as follows:\n+     * {@snippet lang=java :\n+     * MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address());\n+     * }\n+     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * and is accessible from any thread. The size of the segment accepted by the cleanup action is {@code newSize}.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @apiNote The cleanup action (if present) should take care not to leak the received segment to external\n+     * clients which might access the segment after its backing region of memory is no longer available. Furthermore,\n+     * if the provided scope is the scope of an {@linkplain Arena#ofAuto() automatic arena}, the cleanup action\n+     * must not prevent the scope from becoming <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     * A failure to do so will permanently prevent the regions of memory allocated by the automatic arena from being deallocated.\n+     *\n+     * @param newSize the size of the returned segment.\n+     * @param newScope the scope of the returned segment.\n+     * @param cleanup the cleanup action that should be executed when the provided arena is closed (can be {@code null}).\n+     * @return a new segment that has the same address as this segment, but with new size and its scope set to\n+     * that of the provided arena.\n@@ -575,0 +652,2 @@\n+     * @throws IllegalArgumentException if {@code newSize < 0}.\n+     * @throws IllegalStateException if {@code scope.isAlive() == false}.\n@@ -578,1 +657,1 @@\n-    MemorySegment asUnbounded();\n+    MemorySegment reinterpret(long newSize, Scope newScope, Consumer<MemorySegment> cleanup);\n@@ -1126,5 +1205,0 @@\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, 0);\n-     *}\n-     * <p>\n@@ -1142,111 +1216,0 @@\n-    \/**\n-     * Creates a native segment with the given size and {@linkplain #address() address value}.\n-     * The returned segment is not {@linkplain MemorySegment#isReadOnly()} read-only), and is associated\n-     * with a fresh scope that is always alive.\n-     * <p>\n-     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid address from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * <p>\n-     * On 32-bit platforms, the given address value will be normalized such that the\n-     * highest-order (\"leftmost\") 32 bits of the {@link MemorySegment#address() address}\n-     * of the returned memory segment are set to zero.\n-     *\n-     * @param address the address of the returned native segment.\n-     * @param byteSize the size (in bytes) of the returned native segment.\n-     * @return a zero-length native segment with the given address and size.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    static MemorySegment ofAddress(long address, long byteSize) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        return MemorySegment.ofAddress(address, byteSize, Arena.global());\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size, {@linkplain #address() address value} and arena.\n-     * The returned segment is always accessible, from any thread.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, byteSize, arena, null);\n-     *}\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * <p>\n-     * On 32-bit platforms, the given address value will be normalized such that the\n-     * highest-order (\"leftmost\") 32 bits of the {@link MemorySegment#address() address}\n-     * of the returned memory segment are set to zero.\n-     *\n-     * @param address the returned segment's address.\n-     * @param byteSize the desired size.\n-     * @param arena the arena associated with the returned native segment.\n-     * @return a native segment with the given address, size and arena.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n-     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n-     * thread {@code T}, other than the arena's owner thread.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    @ForceInline\n-    static MemorySegment ofAddress(long address, long byteSize, Arena arena) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        Objects.requireNonNull(arena);\n-        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize,\n-                MemorySessionImpl.toMemorySession(arena), null);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size, {@linkplain #address() address value}, and arena.\n-     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n-     * where an address to some underlying region of memory is typically obtained from foreign code\n-     * (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment is not {@linkplain MemorySegment#isReadOnly()} read-only), and its lifetime is controlled\n-     * by the provided arena. For instance, if the provided arena is a confined arena, the returned\n-     * native segment will be invalidated - and the provided cleanup action invoked - when the provided confined arena\n-     * is {@linkplain Arena#close() closed}.\n-     * <p>\n-     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid address from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * <p>\n-     * On 32-bit platforms, the given address value will be normalized such that the\n-     * highest-order (\"leftmost\") 32 bits of the {@link MemorySegment#address() address}\n-     * of the returned memory segment are set to zero.\n-     *\n-     * @param address the returned segment's address.\n-     * @param byteSize the desired size.\n-     * @param arena the arena associated with the returned native segment.\n-     * @param cleanupAction the custom cleanup action to be associated to the returned segment (can be null).\n-     * @return a native segment with the given address, size and arena.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n-     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n-     * thread {@code T}, other than the arena's owner thread.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    static MemorySegment ofAddress(long address, long byteSize, Arena arena, Runnable cleanupAction) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        Objects.requireNonNull(arena);\n-        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize,\n-                MemorySessionImpl.toMemorySession(arena), cleanupAction);\n-    }\n-\n@@ -2238,8 +2201,3 @@\n-     * A scope controls access to one or more memory segments. That is, a memory segment cannot be accessed if its\n-     * associated scope is not {@linkplain #isAlive() alive}. In other words, a scope models the <em>lifetime<\/em>\n-     * of all the memory segments associated with it.\n-     * <p>\n-     * A new scope can be created, indirectly, by creating a new {@linkplain Arena arena}. For instance, when a new\n-     * {@linkplain Arena#ofConfined() confined} arena is created, a new scope is also created. This scope - the arena scope - is\n-     * starts as {@link #isAlive() alive}. When the confined arena is {@linkplain Arena#close() closed},\n-     * the arena scope becomes no longer alive.\n+     * A scope models the <em>lifetime<\/em> of all the memory segments associated with it. That is, a memory segment\n+     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. A new scope is typically\n+     * obtained indirectly, by creating a new {@linkplain Arena arena}.\n@@ -2259,2 +2217,2 @@\n-         * Returns {@code true}, if the provided object is also a scope, and the lifetime associated with this scope\n-         * and that scope are the same. In that case, it is always the case that\n+         * Returns {@code true}, if the provided object is also a scope, which models the same lifetime as that\n+         * modelled by this scope. In that case, it is always the case that\n@@ -2263,2 +2221,2 @@\n-         * @return {@code true}, if the provided object is also a scope, and the lifetime associated with this scope\n-         * and that scope are the same.\n+         * @return {@code true}, if the provided object is also a scope, which models the same lifetime as that\n+         * modelled by this scope.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":132,"deletions":174,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- *     {@link MemorySegment#ofAddress(long, long, Arena) resizing} the segment first).<\/li>\n+ *     {@link MemorySegment#reinterpret(long)} () resizing} the segment first).<\/li>\n@@ -164,1 +164,1 @@\n-        Arena loaderScope;\/\/ builtin loaders never go away\n+        Arena loaderArena;\/\/ builtin loaders never go away\n@@ -166,1 +166,1 @@\n-            loaderScope = Arena.global();\n+            loaderArena = Arena.global();\n@@ -169,1 +169,1 @@\n-            loaderScope = session.asArena();\n+            loaderArena = session.asArena();\n@@ -178,1 +178,2 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0L, loaderScope));\n+                    Optional.of(MemorySegment.ofAddress(addr)\n+                                    .reinterpret(loaderArena.scope(), null));\n@@ -241,1 +242,1 @@\n-    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, Arena libScope) {\n+    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, Arena libArena) {\n@@ -243,1 +244,1 @@\n-        Objects.requireNonNull(libScope);\n+        Objects.requireNonNull(libArena);\n@@ -251,1 +252,1 @@\n-        MemorySessionImpl.toMemorySession(libScope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        MemorySessionImpl.toMemorySession(libArena).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -262,1 +263,2 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0, libScope));\n+                    Optional.of(MemorySegment.ofAddress(addr)\n+                            .reinterpret(libArena.scope(), null));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -200,2 +200,3 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, Arena)}\n- * can be used to create a fresh segment with the given spatial bounds out of a native address.\n+ * the restricted method {@link java.lang.foreign.MemorySegment#reinterpret(long)} ()}\n+ * can be used to create a fresh segment with the same address and temporal bounds,\n+ * but with the provided size. This can be useful to resize memory segments obtained when interacting with native functions.\n@@ -204,5 +205,5 @@\n- * or memory corruption when the bound Java API element is accessed. For instance, in the case of\n- * {@link java.lang.foreign.MemorySegment#ofAddress(long, long, Arena)}, if the provided spatial bounds are\n- * incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n- * memory when attempting to access said segment. For these reasons, it is crucial for code that calls a restricted method\n- * to never pass arguments that might cause incorrect binding of foreign data and\/or functions to a Java API.\n+ * or memory corruption when the bound Java API element is accessed. For instance, incorrectly resizing a native\n+ * memory sgement using {@link java.lang.foreign.MemorySegment#reinterpret(long)} can lead to a JVM crash, or, worse,\n+ * lead to silent memory corruption when attempting to access the resized segment. For these reasons, it is crucial for\n+ * code that calls a restricted method to never pass arguments that might cause incorrect binding of foreign data and\/or\n+ * functions to a Java API.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -125,2 +125,22 @@\n-    public final AbstractMemorySegmentImpl asUnbounded() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"asUnbounded\");\n+    public MemorySegment reinterpret(long newSize, Scope newScope, Consumer<MemorySegment> cleanup) {\n+        return reinterpretInternal(Reflection.getCallerClass(), newSize, newScope, null);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public MemorySegment reinterpret(long newSize) {\n+        return reinterpretInternal(Reflection.getCallerClass(), newSize, scope, null);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public MemorySegment reinterpret(Scope newScope, Consumer<MemorySegment> cleanup) {\n+        return reinterpretInternal(Reflection.getCallerClass(), byteSize(), newScope, cleanup);\n+    }\n+\n+    public MemorySegment reinterpretInternal(Class<?> callerClass, long newSize, Scope scope, Consumer<MemorySegment> cleanup) {\n+        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\");\n+        Objects.requireNonNull(scope);\n+        if (newSize < 0) {\n+            throw new IllegalArgumentException(\"newSize < 0\");\n+        }\n@@ -128,1 +148,5 @@\n-        return asSliceNoCheck(0, Long.MAX_VALUE);\n+        Runnable action = cleanup != null ?\n+                () -> cleanup.accept(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize)) :\n+                null;\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize,\n+                (MemorySessionImpl)scope, action);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.*;\n@@ -42,1 +40,0 @@\n-import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n@@ -51,1 +48,4 @@\n-    private static final SymbolLookup FALLBACK_LOOKUP = name -> Optional.empty();\n+    private static final SymbolLookup FALLBACK_LOOKUP = name -> {\n+        Objects.requireNonNull(name);\n+        return Optional.empty();\n+    };\n@@ -89,3 +89,2 @@\n-            int numSymbols = WindowsFallbackSymbols.values().length;\n-            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.find(\"funcs\").orElseThrow().address(),\n-                ADDRESS.byteSize() * numSymbols, Arena.global());\n+            MemorySegment funcs = fallbackLibLookup.find(\"funcs\").orElseThrow()\n+                    .reinterpret(WindowsFallbackSymbols.LAYOUT.byteSize());\n@@ -94,1 +93,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, Arena.global()));\n+                .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n@@ -97,1 +96,4 @@\n-            lookup = name -> finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n+            lookup = name -> {\n+                Objects.requireNonNull(name);\n+                return finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n+            };\n@@ -111,1 +113,1 @@\n-                        Optional.of(MemorySegment.ofAddress(addr, 0, Arena.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr));\n@@ -204,0 +206,3 @@\n+\n+        static SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(\n+                values().length, ADDRESS);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-    static MemorySegment makeUpcall(long entry, Arena scope) {\n-        MemorySessionImpl.toMemorySession(scope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+    static MemorySegment makeUpcall(long entry, Arena arena) {\n+        MemorySessionImpl.toMemorySession(arena).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -60,1 +60,1 @@\n-        return MemorySegment.ofAddress(entry, 0, scope);\n+        return MemorySegment.ofAddress(entry).reinterpret(arena.scope(), null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-            MemorySegment argsSeg = MemorySegment.ofAddress(argPtrs.address(), numArgs * ADDRESS.byteSize(), upcallArena);\n+            MemorySegment argsSeg = argPtrs.reinterpret(numArgs * ADDRESS.byteSize(), upcallArena.scope(), null);\n@@ -194,1 +194,1 @@\n-                ? MemorySegment.ofAddress(retPtr.address(), retLayout.byteSize(), upcallArena)\n+                ? retPtr.reinterpret(retLayout.byteSize(), upcallArena.scope(), null)\n@@ -200,2 +200,2 @@\n-                MemorySegment argPtr = MemorySegment.ofAddress(argsSeg.getAtIndex(JAVA_LONG, i), argLayout.byteSize(), upcallArena);\n-\n+                MemorySegment argPtr = argsSeg.getAtIndex(ADDRESS, i)\n+                        .reinterpret(argLayout.byteSize(), upcallArena.scope(), null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-\n@@ -119,1 +118,1 @@\n-     * @param scope the scope to which to attach the created upcall stub\n+     * @param arena the scope to which to attach the created upcall stub\n@@ -126,1 +125,1 @@\n-                                       Thread.UncaughtExceptionHandler handler, Arena scope)\n+                                       Thread.UncaughtExceptionHandler handler, Arena arena)\n@@ -139,1 +138,1 @@\n-        return MemorySegment.ofAddress(execPtr, 0, scope, () -> freeClosure(closurePtr, globalTarget));\n+        return MemorySegment.ofAddress(execPtr).reinterpret(arena.scope(), unused -> freeClosure(closurePtr, globalTarget));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), Arena.global());\n+        MemorySegment segment = MemorySegment.NULL.reinterpret(seq.byteSize());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, Arena.ofAuto());\n+        MemorySegment segment = MemorySegment.NULL.reinterpret(Integer.MAX_VALUE + 10L);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.Arena;\n@@ -34,1 +33,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -62,4 +60,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(\n-                SymbolLookup.loaderLookup().find(\"c\").get().address(),\n-                ValueLayout.JAVA_INT.byteSize(),\n-                Arena.global());\n+        MemorySegment segment = SymbolLookup.loaderLookup().find(\"c\").get().reinterpret(1);\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -168,2 +168,2 @@\n-            MemorySegment mallocSegment = MemorySegment.ofAddress(addr.address(), 12,\n-                    arena, () -> freeMemory(addr));\n+            MemorySegment mallocSegment = addr.asSlice(0, 12)\n+                    .reinterpret(arena.scope(), TestNative::freeMemory);\n@@ -179,2 +179,2 @@\n-            mallocSegment = MemorySegment.ofAddress(addr.address(), 12,\n-                    arena, () -> freeMemory(addr));\n+            mallocSegment = addr.asSlice(0, 12)\n+                    .reinterpret(arena.scope(), TestNative::freeMemory);\n@@ -195,1 +195,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test\n@@ -198,2 +198,3 @@\n-            MemorySegment segment = arena.allocate(4, 1);;\n-            MemorySegment.ofAddress(segment.address(), -1, Arena.global());\n+            MemorySegment segment = arena.allocate(4, 1);\n+            assertThrows(IllegalArgumentException.class, () -> segment.reinterpret(-1));\n+            assertThrows(IllegalArgumentException.class, () -> segment.reinterpret(-1, Arena.ofAuto().scope(), null));\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -111,1 +111,2 @@\n-            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.Arena,java.lang.Runnable)\/3\/0\"\n+            \"java.lang.foreign.MemorySegment\/reinterpret(java.lang.foreign.MemorySegment$Scope,java.util.function.Consumer)\/1\/0\",\n+            \"java.lang.foreign.MemorySegment\/reinterpret(long,java.lang.foreign.MemorySegment$Scope,java.util.function.Consumer)\/2\/0\"\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -198,1 +196,1 @@\n-            UNSAFE(session -> MemorySegment.ofAddress(0, 10, session));\n+            UNSAFE(session -> MemorySegment.NULL.reinterpret(10, session.scope(), null));\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address(), 0, session);\n+            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address());\n@@ -140,1 +140,1 @@\n-            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, Arena.global()));\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address()));\n@@ -164,1 +164,1 @@\n-            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, Arena.global()).hashCode());\n+            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address()).hashCode());\n@@ -221,2 +221,2 @@\n-    public void testIsAccessibleBy(Arena scope, boolean isConfined) {\n-        MemorySegment segment = MemorySegment.ofAddress(0, 0, scope);\n+    public void testIsAccessibleBy(Arena arena, boolean isConfined) {\n+        MemorySegment segment = MemorySegment.NULL.reinterpret(arena.scope(), null);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena);\n@@ -105,1 +104,1 @@\n-                    assertEquals(getInt(sharedSegment), 42);\n+                    assertEquals(getInt(s), 42);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -125,14 +125,0 @@\n-    @Test\n-    public void testUnboundedSlice() {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment segment = arena.allocate(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT)); \/\/ size = 8\n-            MemorySegment slice = segment.asSlice(0, ValueLayout.JAVA_INT); \/\/ size = 4\n-            assertThrows(IndexOutOfBoundsException.class, () -> slice.getAtIndex(ValueLayout.JAVA_INT, 1));\n-            MemorySegment unbounded = slice.asUnbounded();\n-            assertEquals(unbounded.byteSize(), Long.MAX_VALUE);\n-            unbounded = unbounded.asSlice(0, MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT)); \/\/ size = 8\n-            assertEquals(unbounded.byteSize(), segment.byteSize());\n-            assertEquals(segment.getAtIndex(ValueLayout.JAVA_INT, 1), unbounded.getAtIndex(ValueLayout.JAVA_INT, 1));\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -188,1 +188,2 @@\n-            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena);\n+            MemorySegment seg = ptr.asSlice(0, layout)\n+                    .reinterpret(arena.scope(), null);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        MemorySegment.ofAddress(0, 4000, Arena.global());\n+        MemorySegment.NULL.reinterpret(10);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,3 +46,3 @@\n-        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                MethodType.methodType(MemorySegment.class, long.class, long.class, Arena.class));\n-        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, Arena.global());\n+        var mh = MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                MethodType.methodType(MemorySegment.class, long.class));\n+        var seg = (MemorySegment)mh.invokeExact(MemorySegment.NULL, 10L);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, Arena.class);\n-        method.invoke(null, 0L, 4000L, Arena.global());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"reinterpret\", long.class);\n+        method.invoke(MemorySegment.NULL, 10L);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.function.Consumer;\n@@ -76,0 +77,1 @@\n+        addDefaultMapping(MemorySegment.Scope.class, Arena.ofAuto().scope());\n@@ -87,0 +89,1 @@\n+        addDefaultMapping(Consumer.class, (Consumer<Object>)(Object o) -> {});\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -53,9 +54,9 @@\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class)),\n-                            \"MemorySegment::ofAddress\/2\" },\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, Arena.class)),\n-                            \"MemorySegment::ofAddress\/3\" },\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, Arena.class, Runnable.class)),\n-                            \"MemorySegment::ofAddress\/4\" },\n+                    { MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                            MethodType.methodType(MemorySegment.class, long.class)),\n+                            \"MemorySegment::reinterpret\/1\" },\n+                    { MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                            MethodType.methodType(MemorySegment.class, MemorySegment.Scope.class, Consumer.class)),\n+                            \"MemorySegment::reinterpret\/2\" },\n+                    { MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                            MethodType.methodType(MemorySegment.class, long.class, MemorySegment.Scope.class, Consumer.class)),\n+                            \"MemorySegment::reinterpret\/3\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-            res += MemorySegment.ofAddress(i, i % 100).address();\n+            res += MemorySegment.ofAddress(i)\n+                    .reinterpret(i % 100).address();\n@@ -73,1 +74,2 @@\n-            res += MemorySegment.ofAddress(i, i % 100, Arena.global()).address();\n+            res += MemorySegment.ofAddress(i)\n+                    .reinterpret(i % 100, Arena.global().scope(), null).address();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena);\n+        MemorySegment newSegment = segment.reinterpret(100, arena.scope(), null);\n@@ -106,1 +106,1 @@\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena);\n+        MemorySegment newSegment = segment.reinterpret(100, arena.scope(), null);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,2 +196,2 @@\n-                MemorySegment segment = slicing.allocate(byteSize, byteAlignment);\n-                return MemorySegment.ofAddress(segment.address(), byteSize, arena);\n+                return slicing.allocate(byteSize, byteAlignment)\n+                        .reinterpret(arena.scope(), null);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,2 +70,4 @@\n-            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, Arena.global());\n-            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, Arena.global());\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress)\n+                    .reinterpret(8*SIZE);\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress)\n+                    .reinterpret(8*SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena);\n+      final var srcSegmentConfined = srcSegment.reinterpret(arena.scope(), null);\n+      final var dstSegmentConfined = dstSegment.reinterpret(arena.scope(), null);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,2 +168,2 @@\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena);\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena);\n+      final var srcSegmentConfined = srcSegment.reinterpret(arena.scope(), null);\n+      final var dstSegmentConfined = dstSegment.reinterpret(arena.scope(), null);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}