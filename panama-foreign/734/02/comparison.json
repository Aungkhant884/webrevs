{"files":[{"patch":"@@ -419,1 +419,2 @@\n-                FunctionDescriptor.of(JAVA_INT, ADDRESS).asVariadic(JAVA_INT, JAVA_INT, JAVA_INT)\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT),\n+                Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n","filename":"doc\/panama_ffi.md","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor) downcall method handles} or\n+ * {@linkplain Linker#downcallHandle(MemorySegment, FunctionDescriptor, Linker.Option...) downcall method handles} or\n@@ -61,7 +61,0 @@\n-    \/**\n-     * The index of the first variadic argument layout (where defined).\n-     * @return The index of the first variadic argument layout, or {@code -1} if this is not a\n-     * {@linkplain #asVariadic(MemoryLayout...) variadic} layout.\n-     *\/\n-    int firstVariadicArgumentIndex();\n-\n@@ -116,11 +109,0 @@\n-    \/**\n-     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n-     * function descriptor argument layouts. The resulting function descriptor can report the position\n-     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n-     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n-     * will throw an {@link UnsupportedOperationException}.\n-     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n-     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n-     *\/\n-    FunctionDescriptor asVariadic(MemoryLayout... variadicLayouts);\n-\n@@ -148,1 +130,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -49,1 +50,1 @@\n- * {@linkplain #downcallHandle(MemorySegment, FunctionDescriptor) downcall method handles}; and<\/li>\n+ * {@linkplain #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handles}; and<\/li>\n@@ -64,1 +65,1 @@\n- * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n+ * {@linkplain #downcallHandle(FunctionDescriptor, Option...) Linking a foreign function} is a process which requires a function descriptor,\n@@ -80,1 +81,1 @@\n- * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a target address},\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor, Option...) without specifying a target address},\n@@ -169,1 +170,1 @@\n-     * {@link #downcallHandle(MemorySegment, FunctionDescriptor) downcall method handle} or an\n+     * {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handle} or an\n@@ -174,4 +175,4 @@\n-     * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>}\n-     * function descriptor, in which the specialized signature of a given variable arity callsite is described in full.\n-     * Alternatively, where the foreign library allows it, clients might be able to interact with variadic functions by\n-     * passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n+     * variadic function by using {@linkplain Linker.Option#firstVariadicArg(int) a linker option} to indicate\n+     * the start of the list of variadic arguments, together with a specialized function descriptor describing a\n+     * given variable arity callsite. Alternatively, where the foreign library allows it, clients might be able to\n+     * interact with variadic functions by passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n@@ -213,1 +214,1 @@\n-     * @param symbol the address of the target function.\n+     * @param symbol   the address of the target function.\n@@ -215,0 +216,1 @@\n+     * @param options  any linker options.\n@@ -217,1 +219,2 @@\n-     * or if the symbol is {@link MemorySegment#NULL}\n+     *                                  or if the symbol is {@link MemorySegment#NULL}\n+     * @throws IllegalArgumentException if an invalid combination of linker options is given.\n@@ -219,1 +222,1 @@\n-    default MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function) {\n+    default MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function, Option... options) {\n@@ -221,1 +224,1 @@\n-        return downcallHandle(function).bindTo(symbol);\n+        return downcallHandle(function, options).bindTo(symbol);\n@@ -238,0 +241,1 @@\n+     * @param options  any linker options.\n@@ -241,0 +245,1 @@\n+     * @throws IllegalArgumentException if an invalid combination of linker options is given.\n@@ -242,1 +247,1 @@\n-    MethodHandle downcallHandle(FunctionDescriptor function);\n+    MethodHandle downcallHandle(FunctionDescriptor function, Option... options);\n@@ -285,0 +290,17 @@\n+\n+    \/**\n+     * A linker option that can be used to indicate additional linking requirements to the linker,\n+     * besides what is described by a function descriptor.\n+     *\/\n+    sealed interface Option\n+            permits LinkerOptions.FirstVariadicArg {\n+\n+        \/**\n+         * {@return A linker option used to denote the index of the first variadic argument layout in a\n+         *          foreign function call}\n+         * @param index the index of the first variadic argument in a downcall handle linkage request.\n+         *\/\n+        static Option firstVariadicArg(int index) {\n+            return new LinkerOptions.FirstVariadicArg(index);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":35,"deletions":13,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handles} can accept an additional\n+ * {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles} can accept an additional\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- *     <li>It can be passed to an existing {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handle}, as an argument to the underlying foreign function.<\/li>\n+ *     <li>It can be passed to an existing {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle}, as an argument to the underlying foreign function.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * argument list, which can then be passed to {@linkplain Linker#downcallHandle(FunctionDescriptor) downcall method handles}\n+ * argument list, which can then be passed to {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n- * {@linkplain java.lang.foreign.Linker#downcallHandle(java.lang.foreign.FunctionDescriptor) obtained}.\n+ * {@linkplain java.lang.foreign.Linker#downcallHandle(FunctionDescriptor, Linker.Option...) obtained}.\n@@ -228,1 +228,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, java.lang.foreign.FunctionDescriptor, java.lang.foreign.MemorySession) create}\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, MemorySession) create}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -30,1 +31,0 @@\n-import java.lang.foreign.GroupLayout;\n@@ -33,1 +33,0 @@\n-\n@@ -35,1 +34,0 @@\n-import java.util.Arrays;\n@@ -40,2 +38,0 @@\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n@@ -48,1 +44,1 @@\n-public sealed class FunctionDescriptorImpl implements FunctionDescriptor {\n+public final class FunctionDescriptorImpl implements FunctionDescriptor {\n@@ -72,25 +68,0 @@\n-    \/**\n-     * Creates a specialized variadic function descriptor, by appending given variadic layouts to this\n-     * function descriptor argument layouts. The resulting function descriptor can report the position\n-     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n-     * in any way: for instance, calling {@link #changeReturnLayout(MemoryLayout)} on the resulting descriptor\n-     * will throw an {@link UnsupportedOperationException}.\n-     *\n-     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n-     * @return a variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n-     *\/\n-    public final FunctionDescriptorImpl asVariadic(MemoryLayout... variadicLayouts) {\n-        \/\/ Null checks are implicit in the constructor of VariadicFunction\n-        return variadicLayouts.length == 0 ? this : new VariadicFunctionDescriptor(this, variadicLayouts);\n-    }\n-\n-    \/**\n-     * The index of the first variadic argument layout (where defined).\n-     *\n-     * @return The index of the first variadic argument layout, or {@code -1} if this is not a\n-     * {@linkplain #asVariadic(MemoryLayout...) variadic} layout.\n-     *\/\n-    public int firstVariadicArgumentIndex() {\n-        return -1;\n-    }\n-\n@@ -175,3 +146,1 @@\n-                IntStream.range(0, argLayouts.size())\n-                        .mapToObj(i -> (i == firstVariadicArgumentIndex() ?\n-                                \"...\" : \"\") + argLayouts.get(i))\n+                argLayouts.stream().map(Object::toString)\n@@ -190,1 +159,0 @@\n-     *     <li>the two function descriptors have the same leading {@linkplain #firstVariadicArgumentIndex() variadic argument index}<\/li>\n@@ -200,2 +168,1 @@\n-                Objects.equals(argLayouts, f.argLayouts) &&\n-                firstVariadicArgumentIndex() == f.firstVariadicArgumentIndex();\n+                Objects.equals(argLayouts, f.argLayouts);\n@@ -209,1 +176,1 @@\n-        return Objects.hash(argLayouts, resLayout, firstVariadicArgumentIndex());\n+        return Objects.hash(argLayouts, resLayout);\n@@ -219,44 +186,0 @@\n-\n-    static final class VariadicFunctionDescriptor extends FunctionDescriptorImpl {\n-\n-        private final int firstVariadicIndex;\n-\n-        \/**\n-         * Constructor.\n-         *\n-         * @param descriptor the original functional descriptor\n-         * @param argLayouts the memory layouts to apply\n-         * @throws NullPointerException if any of the provided parameters or array elements are {@code null}\n-         *\/\n-        VariadicFunctionDescriptor(FunctionDescriptorImpl descriptor, MemoryLayout... argLayouts) {\n-            super(descriptor.returnLayout().orElse(null),\n-                    Stream.concat(descriptor.argumentLayouts().stream(), Arrays.stream(argLayouts)\n-                            .map(Objects::requireNonNull))\n-                            .toList());\n-            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n-        }\n-\n-        @Override\n-        public int firstVariadicArgumentIndex() {\n-            return firstVariadicIndex;\n-        }\n-\n-        @Override\n-        public FunctionDescriptorImpl insertArgumentLayouts(int index, MemoryLayout... addedLayouts) {\n-            throw newUnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptorImpl changeReturnLayout(MemoryLayout newReturn) {\n-            throw newUnsupportedOperationException();\n-        }\n-\n-        @Override\n-        public FunctionDescriptorImpl dropReturnLayout() {\n-            throw newUnsupportedOperationException();\n-        }\n-\n-        private UnsupportedOperationException newUnsupportedOperationException() {\n-            return new UnsupportedOperationException(\"Method not supported by \" + VariadicFunctionDescriptor.class.getSimpleName());\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/FunctionDescriptorImpl.java","additions":5,"deletions":82,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.lang.foreign.PaddingLayout;\n@@ -42,1 +41,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -50,1 +48,2 @@\n-    private final SoftReferenceCache<FunctionDescriptor, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();\n+    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {}\n+    private final SoftReferenceCache<LinkRequest, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();\n@@ -53,1 +52,1 @@\n-    public MethodHandle downcallHandle(FunctionDescriptor function) {\n+    public MethodHandle downcallHandle(FunctionDescriptor function, Option... options) {\n@@ -55,0 +54,1 @@\n+        Objects.requireNonNull(options);\n@@ -56,0 +56,1 @@\n+        LinkerOptions optionSet = LinkerOptions.of(options);\n@@ -57,1 +58,2 @@\n-        return DOWNCALL_CACHE.get(function, fd -> {\n+        return DOWNCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->  {\n+            FunctionDescriptor fd = linkRequest.descriptor();\n@@ -59,1 +61,1 @@\n-            MethodHandle handle = arrangeDowncall(type, fd);\n+            MethodHandle handle = arrangeDowncall(type, fd, linkRequest.options());\n@@ -64,1 +66,1 @@\n-    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function);\n+    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.foreign.Linker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class LinkerOptions {\n+\n+    private static final LinkerOptions EMPTY = LinkerOptions.of();\n+    private final Map<Class<?>, Linker.Option> optionsMap;\n+\n+    private LinkerOptions(Map<Class<?>, Linker.Option> optionsMap) {\n+        this.optionsMap = optionsMap;\n+    }\n+\n+    public static LinkerOptions of(Linker.Option... options) {\n+        Map<Class<?>, Linker.Option> optionMap = new HashMap<>();\n+\n+        for (Linker.Option option : options) {\n+            if (optionMap.containsKey(option.getClass())) {\n+                throw new IllegalArgumentException(\"Duplicate option: \" + option);\n+            }\n+            optionMap.put(option.getClass(), option);\n+        }\n+\n+        return new LinkerOptions(optionMap);\n+    }\n+\n+    public static LinkerOptions empty() {\n+        return EMPTY;\n+    }\n+\n+    private <T extends Linker.Option> T getOption(Class<T> type) {\n+        return type.cast(optionsMap.get(type));\n+    }\n+\n+    public boolean isVarargsIndex(int argIndex) {\n+        FirstVariadicArg fva = getOption(FirstVariadicArg.class);\n+        return fva != null && argIndex >= fva.index();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        return o instanceof LinkerOptions that\n+                && Objects.equals(optionsMap, that.optionsMap);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(optionsMap);\n+    }\n+\n+    public record FirstVariadicArg(int index) implements Linker.Option { }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -319,5 +319,0 @@\n-    public static boolean isVarargsIndex(FunctionDescriptor descriptor, int argIndex) {\n-        int firstPos = descriptor.firstVariadicArgumentIndex();\n-        return firstPos != -1 && argIndex >= firstPos;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -125,0 +126,4 @@\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n@@ -143,1 +148,1 @@\n-            if (varArgsOnStack() && SharedUtils.isVarargsIndex(cDesc, i)) {\n+            if (varArgsOnStack() && options.isVarargsIndex(i)) {\n@@ -152,2 +157,2 @@\n-    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -58,2 +59,2 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n-        return CallArranger.LINUX.arrangeDowncall(inferredMethodType, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.LINUX.arrangeDowncall(inferredMethodType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -58,2 +59,2 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n-        return CallArranger.MACOS.arrangeDowncall(inferredMethodType, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.MACOS.arrangeDowncall(inferredMethodType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -55,1 +56,1 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -88,0 +89,4 @@\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n@@ -118,1 +123,1 @@\n-            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i), SharedUtils.isVarargsIndex(cDesc, i));\n+            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i), options.isVarargsIndex(i));\n@@ -124,2 +129,2 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -55,2 +56,2 @@\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n-        return CallArranger.arrangeDowncall(inferredMethodType, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeDowncall(inferredMethodType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.SegmentAllocator;\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+            Linker.Option varargIndex = Linker.Option.firstVariadicArg(fd.argumentLayouts().size());\n@@ -326,1 +327,2 @@\n-                    fd.asVariadic(variadicLayouts.toArray(new MemoryLayout[args.size()])));\n+                    fd.appendArgumentLayouts(variadicLayouts.toArray(new MemoryLayout[args.size()])),\n+                    varargIndex);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,2 +103,0 @@\n-        FunctionDescriptor fd_va1 = FunctionDescriptor.of(C_INT).asVariadic(C_INT, C_INT);\n-        FunctionDescriptor fd_va2 = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_INT);\n@@ -106,2 +104,0 @@\n-        assertNotEquals(fd, fd_va1);\n-        assertNotEquals(fd, fd_va2);\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n@@ -109,2 +110,3 @@\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n-            tests.add(abi.downcallHandle(ma, fd), 1, 1, 10D, 2, 3F, 4L);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT,\n+                                                                 C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd, firstVariadicArg(1)), 1, 1, 10D, 2, 3F, 4L);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLinker\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.assertNotSame;\n+\n+public class TestLinker extends NativeTestHelper {\n+\n+    @Test\n+    public void testLinkerOptionsCache() {\n+        Linker linker = Linker.nativeLinker();\n+        FunctionDescriptor descriptor = FunctionDescriptor.ofVoid(C_INT, C_INT);\n+        MethodHandle mh1 = linker.downcallHandle(descriptor);\n+        MethodHandle mh2 = linker.downcallHandle(descriptor, Linker.Option.firstVariadicArg(1));\n+        \/\/ assert that these are 2 distinct link request. No caching allowed\n+        assertNotSame(mh1, mh2);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -92,2 +92,3 @@\n-            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new))\n-                    .asVariadic(args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));\n+            FunctionDescriptor baseDesc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new));\n+            Linker.Option varargIndex = Linker.Option.firstVariadicArg(baseDesc.argumentLayouts().size());\n+            FunctionDescriptor desc = baseDesc.appendArgumentLayouts(args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));\n@@ -95,1 +96,1 @@\n-            MethodHandle downcallHandle = LINKER.downcallHandle(VARARGS_ADDR, desc);\n+            MethodHandle downcallHandle = LINKER.downcallHandle(VARARGS_ADDR, desc, varargIndex);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.Linker;\n@@ -40,0 +41,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -46,0 +48,1 @@\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n@@ -402,1 +405,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n@@ -404,1 +407,1 @@\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n@@ -425,1 +428,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n@@ -427,1 +430,1 @@\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.foreign.Linker;\n@@ -41,0 +42,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -46,0 +48,1 @@\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n@@ -190,1 +193,1 @@\n-                C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n+                C_INT, C_DOUBLE, C_INT, C_DOUBLE, C_DOUBLE);\n@@ -193,1 +196,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(2)));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,2 +66,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n@@ -69,1 +67,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n@@ -72,1 +69,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.Param;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-                FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_DOUBLE, C_LONG_LONG));\n+                FunctionDescriptor.ofVoid(C_INT, C_INT, C_DOUBLE, C_LONG_LONG),\n+                Linker.Option.firstVariadicArg(1));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}