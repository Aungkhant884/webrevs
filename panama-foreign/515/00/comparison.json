{"files":[{"patch":"@@ -49,1 +49,1 @@\n- * Closing a resource scope will cause all the cleanup actions associated with that scope (see {@link #addOnClose(Runnable)}) to be called.\n+ * Closing a resource scope will cause all the cleanup actions associated with that scope (see {@link #addCloseAction(Runnable)}) to be called.\n@@ -66,1 +66,1 @@\n- * that is, cleanup actions (see {@link #addOnClose(Runnable)}) associated with a resource scope, whether managed or not,\n+ * that is, cleanup actions (see {@link #addCloseAction(Runnable)}) associated with a resource scope, whether managed or not,\n@@ -111,6 +111,6 @@\n- * When using shared resource scopes, clients should make sure that no other thread is accessing the segment while\n- * the segment is being closed. If one or more threads attempts to access a segment concurrently while the\n- * segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should\n- * refrain from attempting to close a shared resource scope repeatedly (e.g. keep calling {@link #close()} until no exception is thrown);\n- * such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads\n- * accessing\/closing the resources associated with the shared resource scope.\n+ * Explicit shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n+ * a resource associated with a shared scope while the scope is being closed from another thread, an exception might occur on both\n+ * the accessing and the closing threads. Clients should refrain from attempting to close a shared resource scope repeatedly\n+ * (e.g. keep calling {@link #close()} until no exception is thrown). Instead, clients of shared resource scopes\n+ * should always ensure that proper synchronization mechanisms (e.g. using resource scope handles, see below) are put in place\n+ * so that threads closing shared resource scopes can never race against threads accessing resources managed by same scopes.\n@@ -194,0 +194,1 @@\n+     * The order in which custom cleanup actions are invoked once the scope is closed is unspecified.\n@@ -197,1 +198,1 @@\n-    void addOnClose(Runnable runnable);\n+    void addCloseAction(Runnable runnable);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -62,4 +62,0 @@\n- * <p>\n- * Unless otherwise specified, whenever an allocator is associated with a <em>shared<\/em> resource scope, then allocation is\n- * thread-safe and may be performed concurrently; conversely, if the allocator is associated with a <em>confined<\/em> resource scope\n- * then allocation is confined to the owning thread of the allocator's resource scope.\n@@ -359,0 +355,4 @@\n+     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n+     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n+     * allocation requests can only occur from the thread owning the allocator's resource scope.\n+     * <p>\n@@ -391,0 +391,4 @@\n+     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n+     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n+     * allocation requests can only occur from the thread owning the allocator's resource scope.\n+     * <p>\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-            scope.addOnClose(cleanupAction);\n+            scope.addCloseAction(cleanupAction);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    public void addOnClose(Runnable runnable) {\n+    public void addCloseAction(Runnable runnable) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            scope.addOnClose(() -> acc.addAndGet(delta));\n+            scope.addCloseAction(() -> acc.addAndGet(delta));\n@@ -85,1 +85,1 @@\n-            scope.addOnClose(() -> acc.addAndGet(delta));\n+            scope.addCloseAction(() -> acc.addAndGet(delta));\n@@ -114,1 +114,1 @@\n-                    scopeRef.get().addOnClose(() -> {\n+                    scopeRef.get().addCloseAction(() -> {\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-            ScopedOperation.ofScope(scope -> scope.addOnClose(() -> {}), \"ResourceScope::addOnClose\");\n+            ScopedOperation.ofScope(scope -> scope.addCloseAction(() -> {}), \"ResourceScope::addOnClose\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}