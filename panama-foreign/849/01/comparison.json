{"files":[{"patch":"@@ -429,3 +429,8 @@\n-            dependencies: [\"devkit\", \"gtest\"],\n-            configure_args: concat(common.configure_args_32bit,\n-                \"--with-jvm-variants=minimal,server\", \"--with-zlib=system\"),\n+            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n+            configure_args: concat(common.configure_args_32bit, [\n+                \"--with-jvm-variants=minimal,server\",\n+                \"--with-zlib=system\",\n+                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n+                \"--enable-libffi-bundling\",\n+                \"--enable-fallback-linker\"\n+            ])\n","filename":"make\/conf\/jib-profiles.js","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+    public static final Linker LINKER = Linker.nativeLinker();\n+\n@@ -95,1 +97,1 @@\n-    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) LINKER.canonicalLayouts().get(\"bool\");\n@@ -99,1 +101,1 @@\n-    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfByte C_CHAR = (ValueLayout.OfByte) LINKER.canonicalLayouts().get(\"char\");\n@@ -103,1 +105,1 @@\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) LINKER.canonicalLayouts().get(\"short\");\n@@ -107,1 +109,1 @@\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) LINKER.canonicalLayouts().get(\"int\");\n@@ -112,1 +114,1 @@\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"long long\");\n@@ -116,1 +118,1 @@\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) LINKER.canonicalLayouts().get(\"float\");\n@@ -120,1 +122,1 @@\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) LINKER.canonicalLayouts().get(\"double\");\n@@ -124,1 +126,1 @@\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+    public static final AddressLayout C_POINTER = ((AddressLayout) LINKER.canonicalLayouts().get(\"void*\"))\n@@ -126,2 +128,19 @@\n-\n-    public static final Linker LINKER = Linker.nativeLinker();\n+    \/**\n+     * The layout for the {@code size_t} C type\n+     *\/\n+    public static final ValueLayout C_SIZE_T = (ValueLayout) LINKER.canonicalLayouts().get(\"size_t\");\n+\n+    \/\/ Common layout shared by some tests\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    public static final MemoryLayout S_PDI_LAYOUT = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+        case 8 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"),\n+            MemoryLayout.paddingLayout(4));\n+        case 4 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"));\n+        default -> throw new UnsupportedOperationException(\"Unsupported address size\");\n+    };\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-@Test\n@@ -124,2 +123,5 @@\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n+        String javaFormatArgs = args.stream()\n+                .map(a -> a.javaFormat)\n+                .collect(Collectors.joining(\",\"));\n+        String nativeFormatArgs = args.stream()\n+                .map(a -> a.nativeFormat)\n@@ -128,1 +130,2 @@\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+        String javaFormatString = \"hello(\" + javaFormatArgs + \")\\n\";\n+        String nativeFormatString = \"hello(\" + nativeFormatArgs + \")\\n\";\n@@ -130,1 +133,1 @@\n-        String expected = String.format(formatString, args.stream()\n+        String expected = String.format(javaFormatString, args.stream()\n@@ -133,1 +136,1 @@\n-        int found = stdLibHelper.printf(formatString, args);\n+        int found = stdLibHelper.printf(nativeFormatString, args);\n@@ -159,0 +162,1 @@\n+        \/\/ void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) );\n@@ -160,1 +164,1 @@\n-                FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER));\n@@ -285,1 +289,5 @@\n-                qsort.invokeExact(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                \/\/ both of these fit in an int\n+                \/\/ automatically widen them to long on x64\n+                int count = arr.length;\n+                int size = (int) C_INT.byteSize();\n+                qsort.invoke(nativeArr, count, size, qsortUpcallStub);\n@@ -381,4 +389,4 @@\n-        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateFrom(\"str\"), \"str\");\n+        INT(int.class, C_INT, \"%d\", \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%lld\", \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", \"%s\", arena -> arena.allocateFrom(\"str\"), \"str\");\n@@ -388,1 +396,2 @@\n-        final String format;\n+        final String nativeFormat;\n+        final String javaFormat;\n@@ -392,1 +401,2 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String nativeFormat, String javaFormat,\n+                                             Function<Arena, Z> nativeValueFactory, Object javaValue) {\n@@ -395,1 +405,2 @@\n-            this.format = format;\n+            this.nativeFormat = nativeFormat;\n+            this.javaFormat = javaFormat;\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -187,0 +189,2 @@\n+        private static final Pattern LAYOUT_PATTERN = Pattern.compile(\"^(?<align>\\\\d+%)?(?<char>[azcsifjdAZCSIFJD])\\\\d+$\");\n+\n@@ -188,11 +192,14 @@\n-            return switch (layoutString.charAt(0)) {\n-                case 'A','a' -> ADDRESS;\n-                case 'z','Z' -> BOOL;\n-                case 'c','C' -> CHAR;\n-                case 's','S' -> SHORT;\n-                case 'i','I' -> INT;\n-                case 'f','F' -> FLOAT;\n-                case 'j','J' -> LONG;\n-                case 'd','D' -> DOUBLE;\n-                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n-            };\n+            Matcher matcher = LAYOUT_PATTERN.matcher(layoutString);\n+            if (matcher.matches()) {\n+                switch (matcher.group(\"char\")) {\n+                    case \"A\",\"a\": return ADDRESS;\n+                    case \"z\",\"Z\": return BOOL;\n+                    case \"c\",\"C\": return CHAR;\n+                    case \"s\",\"S\": return SHORT;\n+                    case \"i\",\"I\": return INT;\n+                    case \"f\",\"F\": return FLOAT;\n+                    case \"j\",\"J\": return LONG;\n+                    case \"d\",\"D\": return DOUBLE;\n+                };\n+            }\n+            throw new AssertionError(\"Invalid layout string: \" + layoutString);\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+import static java.lang.foreign.ValueLayout.*;\n+\n@@ -131,1 +133,1 @@\n-                    \"Unsupported layout: 2%a8\"\n+                    \"Unsupported layout: 2%a\" + ADDRESS.byteSize()\n@@ -188,7 +190,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n-                            ValueLayout.JAVA_LONG,\n-                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n-                    NO_OPTIONS,\n-                    \"has unexpected size\"\n-            },\n@@ -222,0 +217,9 @@\n+        if (ValueLayout.JAVA_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    NO_OPTIONS,\n+                    \"has unexpected size\"\n+            });\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -96,4 +96,0 @@\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) },\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) },\n@@ -118,0 +114,6 @@\n+        if (C_LONG_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) });\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) });\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.bits == 64\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,9 +51,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n-\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n@@ -57,8 +56,0 @@\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n-\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}