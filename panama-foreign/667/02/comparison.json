{"files":[{"patch":"@@ -58,1 +58,4 @@\n- * For instance, consider the following struct declaration in C:\n+ * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be referred to when\n+ * constructing <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ * <p>\n+ * Consider the following struct declaration in C:\n@@ -123,2 +126,1 @@\n- * corresponding to the selected layout, to {@linkplain #select(PathElement...) select} an arbitrarily nested layout inside\n- * another layout, or to {@link #map(UnaryOperator, PathElement...) transform} a nested layout element inside\n+ * corresponding to the selected layout, or to {@linkplain #select(PathElement...) select} an arbitrarily nested layout inside\n@@ -141,16 +143,0 @@\n- * And, we can also replace the layout named {@code value} with another layout, as follows:\n- * {@snippet lang=java :\n- * MemoryLayout taggedValuesWithHole = taggedValues.map(l -> MemoryLayout.paddingLayout(32),\n- *                                             PathElement.sequenceElement(), PathElement.groupElement(\"value\"));\n- * }\n- *\n- * That is, the above declaration is identical to the following, more verbose one:\n- * {@snippet lang=java :\n- * MemoryLayout taggedValuesWithHole = MemoryLayout.sequenceLayout(5,\n- *     MemoryLayout.structLayout(\n- *         ValueLayout.JAVA_BYTE.withName(\"kind\"),\n- *         MemoryLayout.paddingLayout(32),\n- *         MemoryLayout.paddingLayout(32)\n- * ));\n- * }\n- *\n@@ -186,5 +172,0 @@\n- * <h2>Layout attributes<\/h2>\n- *\n- * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be referred to when\n- * constructing <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n- *\n@@ -295,1 +276,1 @@\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset,\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offset,\n@@ -327,1 +308,1 @@\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offsetHandle,\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::offsetHandle,\n@@ -419,1 +400,1 @@\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::dereferenceHandle,\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::dereferenceHandle,\n@@ -444,1 +425,1 @@\n-        return computePathOp(LayoutPath.rootPath(MemoryLayout.sequenceLayout(Long.MAX_VALUE, this), MemoryLayout::bitSize),\n+        return computePathOp(LayoutPath.rootPath(MemoryLayout.sequenceLayout(Long.MAX_VALUE, this)),\n@@ -487,1 +468,1 @@\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::sliceHandle,\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::sliceHandle,\n@@ -501,19 +482,1 @@\n-        return computePathOp(LayoutPath.rootPath(this, l -> 0L), LayoutPath::layout,\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);\n-    }\n-\n-    \/**\n-     * Creates a transformed copy of this layout where a selected layout, from a path rooted in this layout,\n-     * is replaced with the result of applying the given operation.\n-     *\n-     * @param op the unary operation to be applied to the selected layout.\n-     * @param elements the layout path elements.\n-     * @return a new layout where the layout selected by the layout path in {@code elements},\n-     * has been replaced by the result of applying {@code op} to the selected layout.\n-     * @throws IllegalArgumentException if the layout path does not select any layout nested in this layout,\n-     * or if the layout path contains one or more path elements that select one or more sequence element indices\n-     * (see {@link PathElement#sequenceElement(long)} and {@link PathElement#sequenceElement(long, long)}).\n-     *\/\n-    default MemoryLayout map(UnaryOperator<MemoryLayout> op, PathElement... elements) {\n-        Objects.requireNonNull(op);\n-        return computePathOp(LayoutPath.rootPath(this, l -> 0L), path -> path.map(op),\n+        return computePathOp(LayoutPath.rootPath(this), LayoutPath::layout,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":11,"deletions":48,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -37,5 +37,0 @@\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.List;\n-import java.util.function.ToLongFunction;\n@@ -45,1 +40,1 @@\n- * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout, ToLongFunction)},\n+ * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)},\n@@ -54,1 +49,0 @@\n-    private static final MethodHandle ADD_STRIDE;\n@@ -58,2 +52,0 @@\n-    private static final int UNSPECIFIED_ELEM_INDEX = -1;\n-\n@@ -63,2 +55,0 @@\n-            ADD_STRIDE = lookup.findStatic(LayoutPath.class, \"addStride\",\n-                    MethodType.methodType(long.class, MemorySegment.class, long.class, long.class, long.class));\n@@ -78,2 +68,0 @@\n-    private final long elementIndex;\n-    private final ToLongFunction<MemoryLayout> sizeFunc;\n@@ -81,1 +69,1 @@\n-    private LayoutPath(MemoryLayout layout, long offset, long[] strides, long elementIndex, LayoutPath enclosing, ToLongFunction<MemoryLayout> sizeFunc) {\n+    private LayoutPath(MemoryLayout layout, long offset, long[] strides, LayoutPath enclosing) {\n@@ -86,2 +74,0 @@\n-        this.elementIndex = elementIndex;\n-        this.sizeFunc = sizeFunc;\n@@ -96,1 +82,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(sizeFunc.applyAsLong(elem)), UNSPECIFIED_ELEM_INDEX, this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), this);\n@@ -104,3 +90,2 @@\n-        long elemSize = sizeFunc.applyAsLong(elem);\n-        return LayoutPath.nestedPath(elem, offset + (start * elemSize), addStride(elemSize * step),\n-                UNSPECIFIED_ELEM_INDEX, this);\n+        long elemSize = elem.bitSize();\n+        return LayoutPath.nestedPath(elem, offset + (start * elemSize), addStride(elemSize * step), this);\n@@ -116,1 +101,1 @@\n-            long elemSize = sizeFunc.applyAsLong(seq.elementLayout());\n+            long elemSize = seq.elementLayout().bitSize();\n@@ -119,1 +104,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, index, this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, this);\n@@ -127,1 +112,0 @@\n-        int index = -1;\n@@ -133,1 +117,0 @@\n-                index = i;\n@@ -136,1 +119,1 @@\n-                offset += sizeFunc.applyAsLong(l);\n+                offset += l.bitSize();\n@@ -142,1 +125,1 @@\n-        return LayoutPath.nestedPath(elem, this.offset + offset, strides, index, this);\n+        return LayoutPath.nestedPath(elem, this.offset + offset, strides, this);\n@@ -157,5 +140,0 @@\n-        List<Class<?>> expectedCoordinates = new ArrayList<>();\n-        Deque<Integer> perms = new ArrayDeque<>();\n-        perms.addFirst(0);\n-        expectedCoordinates.add(MemorySegment.class);\n-\n@@ -163,15 +141,6 @@\n-\n-        for (int i = 0 ; i < strides.length ; i++) {\n-            expectedCoordinates.add(long.class);\n-            perms.addFirst(0);\n-            perms.addLast(i + 1);\n-            \/\/add stride\n-            handle = MethodHandles.collectCoordinates(handle, 1 + i,\n-                    MethodHandles.insertArguments(ADD_STRIDE, 1, Utils.bitsToBytesOrThrow(strides[strides.length - 1 - i], IllegalStateException::new))); \/\/ MS, long, MS_n, long_n, long\n-        }\n-        \/\/add offset\n-        handle = MethodHandles.insertCoordinates(handle, 1 + strides.length, Utils.bitsToBytesOrThrow(offset, IllegalStateException::new));\n-\n-        if (strides.length > 0) {\n-            \/\/ remove duplicate MS args\n-            handle = MethodHandles.permuteCoordinates(handle, expectedCoordinates, perms.stream().mapToInt(i -> i).toArray());\n+        for (int i = strides.length - 1; i >= 0; i--) {\n+            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2,\n+                    Utils.bitsToBytesOrThrow(strides[i], IllegalArgumentException::new));\n+            \/\/ (J, ...) -> J to (J, J, ...) -> J\n+            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n+            handle = MethodHandles.collectCoordinates(handle, 1, collector);\n@@ -179,0 +148,2 @@\n+        handle = MethodHandles.insertCoordinates(handle, 1,\n+                Utils.bitsToBytesOrThrow(offset, IllegalArgumentException::new));\n@@ -218,28 +189,0 @@\n-    public MemoryLayout map(UnaryOperator<MemoryLayout> op) {\n-        MemoryLayout newLayout = op.apply(layout);\n-        if (enclosing == null) {\n-            return newLayout;\n-        } else if (enclosing.layout instanceof SequenceLayout seq) {\n-            return enclosing.map(l -> dup(l, MemoryLayout.sequenceLayout(seq.elementCount(), newLayout)));\n-        } else if (enclosing.layout instanceof GroupLayout g) {\n-            List<MemoryLayout> newElements = new ArrayList<>(g.memberLayouts());\n-            \/\/if we selected a layout in a group we must have a valid index\n-            newElements.set((int)elementIndex, newLayout);\n-            if (g.isUnion()) {\n-                return enclosing.map(l -> dup(l, MemoryLayout.unionLayout(newElements.toArray(new MemoryLayout[0]))));\n-            } else {\n-                return enclosing.map(l -> dup(l, MemoryLayout.structLayout(newElements.toArray(new MemoryLayout[0]))));\n-            }\n-        } else {\n-            return newLayout;\n-        }\n-    }\n-\n-    private MemoryLayout dup(MemoryLayout oldLayout, MemoryLayout newLayout) {\n-        newLayout = newLayout.withBitAlignment(oldLayout.bitAlignment());\n-        if (oldLayout.name().isPresent()) {\n-            newLayout = newLayout.withName(oldLayout.name().get());\n-        }\n-        return newLayout;\n-    }\n-\n@@ -248,2 +191,2 @@\n-    public static LayoutPath rootPath(MemoryLayout layout, ToLongFunction<MemoryLayout> sizeFunc) {\n-        return new LayoutPath(layout, 0L, EMPTY_STRIDES, -1, null, sizeFunc);\n+    public static LayoutPath rootPath(MemoryLayout layout) {\n+        return new LayoutPath(layout, 0L, EMPTY_STRIDES, null);\n@@ -252,2 +195,2 @@\n-    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, long elementIndex, LayoutPath encl) {\n-        return new LayoutPath(layout, offset, strides, elementIndex, encl, encl.sizeFunc);\n+    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, LayoutPath encl) {\n+        return new LayoutPath(layout, offset, strides, encl);\n@@ -343,4 +286,0 @@\n-\n-    private static long addStride(MemorySegment segment, long stride, long base, long index) {\n-        return base + (stride * index);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":21,"deletions":82,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -261,13 +261,0 @@\n-    @Test\n-    public void testBadSequencePathInMap() {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, JAVA_INT);\n-        for (PathElement e : List.of( sequenceElement(0), sequenceElement(0, 2) )) {\n-            try {\n-                seq.map(l -> l, e);\n-                fail();\n-            } catch (IllegalArgumentException ex) {\n-                assertTrue(true);\n-            }\n-        }\n-    }\n-\n@@ -299,14 +286,0 @@\n-\n-        \/\/ test map\n-\n-        for (int i = 1 ; i <= 4 ; i++) {\n-            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n-            assertTrue(g2.isStruct());\n-            for (int j = 0 ; j < 4 ; j++) {\n-                if (j == i - 1) {\n-                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n-                } else {\n-                    assertEquals(g2.memberLayouts().get(j), g.memberLayouts().get(j));\n-                }\n-            }\n-        }\n@@ -340,14 +313,0 @@\n-\n-        \/\/ test map\n-\n-        for (int i = 1 ; i <= 4 ; i++) {\n-            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n-            assertTrue(g2.isUnion());\n-            for (int j = 0 ; j < 4 ; j++) {\n-                if (j == i - 1) {\n-                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n-                } else {\n-                    assertEquals(g2.memberLayouts().get(j), g.memberLayouts().get(j));\n-                }\n-            }\n-        }\n@@ -374,5 +333,0 @@\n-\n-        \/\/ test map\n-\n-        SequenceLayout seq2 = (SequenceLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, sequenceElement());\n-        assertTrue(seq2.elementLayout() == ValueLayout.JAVA_DOUBLE);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -52,51 +52,0 @@\n-    @Test\n-    public void testVLAInStruct() {\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"size\"),\n-                MemoryLayout.paddingLayout(32),\n-                MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_DOUBLE).withName(\"arr\"));\n-        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(\n-                MemoryLayout.PathElement.groupElement(\"arr\"),\n-                MemoryLayout.PathElement.sequenceElement());\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(\n-                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\")), session);\n-            size_handle.set(segment, 4);\n-            for (int i = 0 ; i < 4 ; i++) {\n-                array_elem_handle.set(segment, i, (double)i);\n-            }\n-            \/\/check\n-            assertEquals(4, (int)size_handle.get(segment));\n-            for (int i = 0 ; i < 4 ; i++) {\n-                assertEquals((double)i, (double)array_elem_handle.get(segment, i));\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testVLAInSequence() {\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-                ValueLayout.JAVA_INT.withName(\"size\"),\n-                MemoryLayout.paddingLayout(32),\n-                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_DOUBLE)).withName(\"arr\"));\n-        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(\n-                MemoryLayout.PathElement.groupElement(\"arr\"),\n-                MemoryLayout.PathElement.sequenceElement(0),\n-                MemoryLayout.PathElement.sequenceElement());\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(\n-                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\"), MemoryLayout.PathElement.sequenceElement()), session);\n-            size_handle.set(segment, 4);\n-            for (int i = 0 ; i < 4 ; i++) {\n-                array_elem_handle.set(segment, i, (double)i);\n-            }\n-            \/\/check\n-            assertEquals(4, (int)size_handle.get(segment));\n-            for (int i = 0 ; i < 4 ; i++) {\n-                assertEquals((double)i, (double)array_elem_handle.get(segment, i));\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"}]}