{"files":[{"patch":"@@ -0,0 +1,46 @@\n+package java.lang.foreign;\n+\n+import java.util.NoSuchElementException;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A compound layout aggregates multiple <em>memory layout<\/em> elements. There are two ways in which\n+ * element layouts can be combined: if element layouts can be heterogeneous, the resulting compound\n+ * layout is said to be a <em>group layout<\/em> (see {@link GroupLayout});\n+ * conversely, if all element layouts are homogeneous, the resulting compound layout is said to be a\n+ * <em>sequence layout<\/em> (see {@link SequenceLayout}).\n+ *\n+ * @implSpec\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n+ * @since 20\n+ *\/\n+public sealed interface CompoundLayout extends MemoryLayout, Iterable<MemoryLayout> permits GroupLayout, SequenceLayout {\n+\n+    \/**\n+     * {@return the size of this group layout (i.e. the number of elements in this group).}\n+     *\/\n+    long elementCount();\n+\n+    \/**\n+     * {@return the element at the provided {@code index}.}\n+     *\n+     * @apiNote the order in which member layouts are produced is the same order in which member layouts have\n+     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n+     * {@link MemoryLayout#unionLayout(MemoryLayout...)}, {@link MemoryLayout#sequenceLayout(long, MemoryLayout)}).\n+     *\n+     * @param index the index for the MemoryLayout to retrieve\n+     * @throws NoSuchElementException if the provided {@code index} is negative or if greater or equal to {@link #elementCount()}\n+     *\/\n+    MemoryLayout elementAt(long index);\n+\n+    \/**\n+     * {@return a stream of all elements in this group.}\n+     *\n+     * @apiNote the order in which element layouts are produced is the same order in which member layouts have\n+     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n+     * {@link MemoryLayout#unionLayout(MemoryLayout...)}, {@link MemoryLayout#sequenceLayout(long, MemoryLayout)}).\n+     *\/\n+    Stream<MemoryLayout> stream();\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CompoundLayout.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.List;\n@@ -38,1 +37,1 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -43,12 +42,1 @@\n-public sealed interface GroupLayout extends MemoryLayout permits StructLayout, UnionLayout {\n-\n-    \/**\n-     * Returns the member layouts associated with this group.\n-     *\n-     * @apiNote the order in which member layouts are returned is the same order in which member layouts have\n-     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n-     * {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n-     *\n-     * @return the member layouts associated with this group.\n-     *\/\n-    List<MemoryLayout> memberLayouts();\n+public sealed interface GroupLayout extends CompoundLayout permits StructLayout, UnionLayout {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-public sealed interface MemoryLayout permits SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n+public sealed interface MemoryLayout permits CompoundLayout, PaddingLayout, ValueLayout {\n@@ -463,2 +463,2 @@\n-     * path elements are used to select a named member layout within a {@link GroupLayout}. Sequence\n-     * path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection\n+     * path elements are used to select a named member layout within a {@link StructLayout} or a {@link UnionLayout}.\n+     * Sequence path elements are used to select a sequence element layout within a {@link SequenceLayout}; selection\n@@ -586,1 +586,1 @@\n-     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     *     {@link UnionLayout}) and if their member layouts (see {@link GroupLayout#stream()} ()}) are also equal<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ * Implementing classes are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n@@ -56,2 +56,1 @@\n-public sealed interface SequenceLayout extends MemoryLayout permits SequenceLayoutImpl {\n-\n+public sealed interface SequenceLayout extends CompoundLayout permits SequenceLayoutImpl {\n@@ -64,5 +63,0 @@\n-    \/**\n-     * {@return the element count of this sequence layout}\n-     *\/\n-    long elementCount();\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-        for (int i = 0; i < g.memberLayouts().size(); i++) {\n-            MemoryLayout l = g.memberLayouts().get(i);\n+        for (int i = 0; i < g.elementCount(); i++) {\n+            MemoryLayout l = g.elementAt(i);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-        return ct.memberLayouts().stream().mapToLong(t -> alignment(t, false)).max().orElse(1);\n+        return ct.stream().mapToLong(t -> alignment(t, false)).max().orElse(1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-                        StorageClasses.VECTOR, group.memberLayouts().size());\n+                        StorageClasses.VECTOR, Math.toIntExact(group.elementCount()));\n@@ -368,1 +368,1 @@\n-                        for (int i = 0; i < group.memberLayouts().size(); i++) {\n+                        for (int i = 0; i < Math.toIntExact(group.elementCount()); i++) {\n@@ -370,1 +370,1 @@\n-                            final long size = group.memberLayouts().get(i).byteSize();\n+                            final long size = group.elementAt(i).byteSize();\n@@ -373,1 +373,1 @@\n-                            if (i + 1 < group.memberLayouts().size()) {\n+                            if (i + 1 < Math.toIntExact(group.elementCount())) {\n@@ -465,1 +465,1 @@\n-                        StorageClasses.VECTOR, group.memberLayouts().size());\n+                        StorageClasses.VECTOR, Math.toIntExact(group.elementCount()));\n@@ -468,1 +468,1 @@\n-                        for (int i = 0; i < group.memberLayouts().size(); i++) {\n+                        for (int i = 0; i < Math.toIntExact(group.elementCount()); i++) {\n@@ -470,1 +470,1 @@\n-                            final long size = group.memberLayouts().get(i).byteSize();\n+                            final long size = group.elementAt(i).byteSize();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,5 +28,3 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n+import jdk.internal.foreign.layout.AbstractGroupLayout;\n+\n+import java.lang.foreign.*;\n@@ -66,1 +64,1 @@\n-        final int numElements = groupLayout.memberLayouts().size();\n+        final long numElements = groupLayout.elementCount();\n@@ -70,1 +68,1 @@\n-        MemoryLayout baseType = groupLayout.memberLayouts().get(0);\n+        MemoryLayout baseType = groupLayout.elementAt(0);\n@@ -79,1 +77,1 @@\n-        for (MemoryLayout elem : groupLayout.memberLayouts()) {\n+        for (MemoryLayout elem : groupLayout) {\n@@ -106,2 +104,0 @@\n-        } else if (type instanceof GroupLayout) {\n-            return classifyStructType(type);\n@@ -110,0 +106,2 @@\n+        } else if (type instanceof GroupLayout) {\n+            return classifyStructType(type);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-                    for (MemoryLayout elem : group.memberLayouts()) {\n+                    for (MemoryLayout elem : group) {\n@@ -496,1 +496,1 @@\n-                        for (MemoryLayout elem : group.memberLayouts()) {\n+                        for (MemoryLayout elem : group) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-        for (MemoryLayout l : group.memberLayouts()) {\n+        for (MemoryLayout l : group) {\n@@ -207,1 +207,1 @@\n-            for (MemoryLayout m : group.memberLayouts()) {\n+            for (MemoryLayout m : group) {\n@@ -217,1 +217,1 @@\n-            for (long i = 0 ; i < seq.elementCount() ; i++) {\n+            for (long i = 0; i < seq.elementCount() ; i++) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Iterator;\n@@ -34,0 +35,3 @@\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.foreign.layout.MemoryLayoutUtil.checkGetIndex;\n@@ -48,0 +52,1 @@\n+        implements Iterable<MemoryLayout>\n@@ -51,1 +56,1 @@\n-    private final List<MemoryLayout> elements;\n+    final List<MemoryLayout> elements;\n@@ -63,11 +68,7 @@\n-    \/**\n-     * Returns the member layouts associated with this group.\n-     *\n-     * @apiNote the order in which member layouts are returned is the same order in which member layouts have\n-     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n-     * {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n-     *\n-     * @return the member layouts associated with this group.\n-     *\/\n-    public final List<MemoryLayout> memberLayouts() {\n-        return elements; \/\/ \"elements\" are already unmodifiable.\n+    public long elementCount() {\n+        return elements.size();\n+    }\n+\n+    public MemoryLayout elementAt(long index) {\n+        checkGetIndex(elements.size(), index);\n+        return elements.get((int)index);\n@@ -76,3 +77,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -80,4 +78,2 @@\n-    public final String toString() {\n-        return decorateLayoutString(elements.stream()\n-                .map(Object::toString)\n-                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n+    public Iterator<MemoryLayout> iterator() {\n+        return elements.iterator();\n@@ -86,5 +82,2 @@\n-    \/**\n-     * {@return {@code true}, if this group layout is a struct layout}\n-     *\/\n-    public final boolean isStruct() {\n-        return kind == Kind.STRUCT;\n+    public Stream<MemoryLayout> stream() {\n+        return elements.stream();\n@@ -93,5 +86,5 @@\n-    \/**\n-     * {@return {@code true}, if this group layout is a union layout}\n-     *\/\n-    public final boolean isUnion() {\n-        return kind == Kind.UNION;\n+    @Override\n+    public final String toString() {\n+        return decorateLayoutString(elements.stream()\n+                .map(Object::toString)\n+                .collect(Collectors.joining(kind.delimTag, \"[\", \"]\")));\n@@ -100,3 +93,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n@@ -116,3 +106,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":22,"deletions":35,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-     *     <li>two group layouts are considered equal if they are of the same kind (see {@link GroupLayout#isStruct()},\n-     *     {@link GroupLayout#isUnion()}) and if their member layouts (see {@link GroupLayout#memberLayouts()}) are also equal<\/li>\n+     *     <li>two group layouts are considered equal if they are of the same type (see {@link StructLayout},\n+     *     {@link UnionLayout}, {@link SequenceLayout}) and if their member layouts (see {@link GroupLayout#stream()} ()}) are also equal<\/li>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.NoSuchElementException;\n+\n@@ -43,0 +45,6 @@\n+    public static void checkGetIndex(long toExclusive, long index) {\n+        if (index < 0 || index >= toExclusive) {\n+            throw new NoSuchElementException(\"The index must be in range [0, \" + toExclusive + \") but was \" + index);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Iterator;\n@@ -32,0 +33,4 @@\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.foreign.layout.MemoryLayoutUtil.checkGetIndex;\n@@ -48,3 +53,0 @@\n-    \/**\n-     * {@return the element layout associated with this sequence layout}\n-     *\/\n@@ -55,3 +57,0 @@\n-    \/**\n-     * {@return the element count of this sequence layout}\n-     *\/\n@@ -62,8 +61,17 @@\n-    \/**\n-     * Returns a sequence layout with the same element layout, alignment constraints and name as this sequence layout,\n-     * but with the specified element count.\n-     *\n-     * @param elementCount the new element count.\n-     * @return a sequence layout with the given element count.\n-     * @throws IllegalArgumentException if {@code elementCount < 0}.\n-     *\/\n+    @Override\n+    public MemoryLayout elementAt(long index) {\n+        checkGetIndex(elemCount, index);\n+        return elementLayout;\n+    }\n+\n+    @Override\n+    public Iterator<MemoryLayout> iterator() {\n+        return stream().iterator();\n+    }\n+\n+    @Override\n+    public Stream<MemoryLayout> stream() {\n+        return LongStream.range(0, elemCount)\n+                .mapToObj(i -> elementLayout);\n+    }\n+\n@@ -75,34 +83,0 @@\n-    \/**\n-     * Re-arrange the elements in this sequence layout into a multi-dimensional sequence layout.\n-     * The resulting layout is a sequence layout where element layouts in the flattened projection of this\n-     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts\n-     * according to the provided element counts. This transformation preserves the layout size;\n-     * that is, multiplying the provided element counts must yield the same element count\n-     * as the flattened projection of this sequence layout.\n-     * <p>\n-     * For instance, given a sequence layout of the kind:\n-     * {@snippet lang = java:\n-     * var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n-     *}\n-     * calling {@code seq.reshape(2, 6)} will yield the following sequence layout:\n-     * {@snippet lang = java:\n-     * var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, ValueLayout.JAVA_INT));\n-     *}\n-     * <p>\n-     * If one of the provided element count is the special value {@code -1}, then the element\n-     * count in that position will be inferred from the remaining element counts and the\n-     * element count of the flattened projection of this layout. For instance, a layout equivalent to\n-     * the above {@code reshapeSeq} can also be computed in the following ways:\n-     * {@snippet lang = java:\n-     * var reshapeSeqImplicit1 = seq.reshape(-1, 6);\n-     * var reshapeSeqImplicit2 = seq.reshape(2, -1);\n-     *}\n-     *\n-     * @param elementCounts an array of element counts, of which at most one can be {@code -1}.\n-     * @return a sequence layout where element layouts in the flattened projection of this\n-     * sequence layout (see {@link #flatten()}) are re-arranged into one or more nested sequence layouts.\n-     * @throws IllegalArgumentException if two or more element counts are set to {@code -1}, or if one\n-     *                                  or more element count is {@code <= 0} (but other than {@code -1}) or, if, after any required inference,\n-     *                                  multiplying the element counts does not yield the same element count as the flattened projection of this\n-     *                                  sequence layout.\n-     *\/\n@@ -151,17 +125,0 @@\n-    \/**\n-     * Returns a flattened sequence layout. The element layout of the returned sequence layout\n-     * is the first non-sequence element layout found by recursively traversing the element layouts of this sequence layout.\n-     * This transformation preserves the layout size; nested sequence layout in this sequence layout will\n-     * be dropped and their element counts will be incorporated into that of the returned sequence layout.\n-     * For instance, given a sequence layout of the kind:\n-     * {@snippet lang = java:\n-     * var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n-     *}\n-     * calling {@code seq.flatten()} will yield the following sequence layout:\n-     * {@snippet lang = java:\n-     * var flattenedSeq = MemoryLayout.sequenceLayout(12, ValueLayout.JAVA_INT);\n-     *}\n-     *\n-     * @return a sequence layout with the same size as this layout (but, possibly, with different\n-     * element count), whose element layout is not a sequence layout.\n-     *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":22,"deletions":65,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        return new StructLayoutImpl(memberLayouts(), bitAlignment, name);\n+        return new StructLayoutImpl(elements, bitAlignment, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/StructLayoutImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        return new UnionLayoutImpl(memberLayouts(), bitAlignment, name);\n+        return new UnionLayoutImpl(elements, bitAlignment, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/UnionLayoutImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        for (MemoryLayout field : g.memberLayouts()) {\n+        for (MemoryLayout field : (Iterable<MemoryLayout>) g.stream()::iterator) {\n@@ -419,1 +419,1 @@\n-        for (MemoryLayout l : g.memberLayouts()) {\n+        for (MemoryLayout l : (Iterable<MemoryLayout>) g.stream()::iterator) {\n@@ -421,1 +421,1 @@\n-            VarHandle accessor = g.varHandle(MemoryLayout.PathElement.groupElement(l.name().get()));\n+            VarHandle accessor = g.varHandle(MemoryLayout.PathElement.groupElement(l.name().orElseThrow()));\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng\/othervm GraphSealedHierarchyTest\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.System.lineSeparator;\n+import static org.testng.Assert.*;\n+\n+public class GraphSealedHierarchyTest {\n+\n+    @Test\n+    public void graph() {\n+        Stream.of(\n+                        MemoryLayout.class\n+                )\n+                .map(GraphSealedHierarchyTest::graph)\n+                .forEach(System.out::println);\n+    }\n+\n+    \/\/ Generates a graph in DOT format\n+    static String graph(Class<?> rootClass) {\n+        final State state = new State(rootClass);\n+        traverse(state, rootClass);\n+        return state.render();\n+    }\n+\n+    static void traverse(State state, Class<?> node) {\n+        for (Class<?> subNode : permittedSubclasses(node)) {\n+            state.addEdge(node, subNode);\n+            traverse(state, subNode);\n+        }\n+    }\n+\n+    private static final class State {\n+\n+        private final StringBuilder builder;\n+        private final Map<Class<?>, List<String>> labels;\n+        private final Map<Class<?>, Map<String, String>> stylings;\n+\n+        public State(Class<?> rootNode) {\n+            builder = new StringBuilder()\n+                    .append(\"digraph G {\")\n+                    .append(lineSeparator())\n+                    .append(\"  labelloc=\\\"b\\\";\")\n+                    .append(lineSeparator())\n+                    .append(\"  label=\\\"The Sealed Hierarchy of \")\n+                    .append(rootNode.getName())\n+                    .append(\"\\\";\")\n+                    .append(lineSeparator())\n+                    .append(\"  rankdir=\\\"BT\\\";\")\n+                    .append(lineSeparator());\n+            labels = new HashMap<>();\n+            stylings = new HashMap<>();\n+        }\n+\n+        public void addEdge(Class<?> node, Class<?> subNode) {\n+            builder.append(\"  \")\n+                    .append(subNode.getSimpleName())\n+                    .append(\" -> \")\n+                    .append(node.getSimpleName())\n+                    .append(\";\")\n+                    .append(lineSeparator());\n+            var subNodeStyles = stylings.computeIfAbsent(subNode, k -> new HashMap<>());\n+            var subNodeLabels = labels.computeIfAbsent(subNode, k -> new ArrayList<>());\n+            if (subNode.getName().contains(\".internal\")) {\n+                subNodeStyles.put(\"style\", \"filled\");\n+                subNodeStyles.put(\"fillcolor\", \"gray\");\n+                subNodeLabels.add(\"internal\");\n+            }\n+            if (!subNode.isInterface()) {\n+                if (Modifier.isPublic(subNode.getModifiers()) && !subNode.getName().contains(\".internal\")) {\n+                    subNodeLabels.add(\"public impl\");\n+                    subNodeStyles.put(\"style\", \"filled\");\n+                    subNodeStyles.put(\"fillcolor\", \"#FFD0D0\");\n+                }\n+                if (Modifier.isAbstract(subNode.getModifiers())) {\n+                    subNodeLabels.add(\"abstract\");\n+                    subNodeStyles.put(\"style\", \"filled\");\n+                    subNodeStyles.put(\"fillcolor\", \"red\");\n+                }\n+            }\n+            if (!Modifier.isPublic(subNode.getModifiers())) {\n+                subNodeLabels.add(\"non-public\");\n+                subNodeStyles.put(\"style\", \"filled\");\n+                subNodeStyles.put(\"fillcolor\", \"red\");\n+            }\n+\n+        }\n+\n+        public String render() {\n+            final StringBuilder result = new StringBuilder(builder);\n+\n+            labels.forEach((node, l) -> {\n+                final var label = Stream.concat(\n+                        Stream.of(node.getSimpleName()),\n+                        l.stream()).collect(Collectors.joining(\"\\\\n\"));\n+                stylings.computeIfAbsent(node, k -> new HashMap<>())\n+                        .put(\"label\", label);\n+            });\n+\n+            stylings.forEach((node, styles) -> {\n+                result.append(\"  \")\n+                        .append(node.getSimpleName());\n+\n+                result.append(\"[\");\n+                result.append(styles.entrySet().stream()\n+                        .map(e -> String.format(\"%s=\\\"%s\\\"\", e.getKey(), e.getValue()))\n+                        .collect(Collectors.joining(\", \")));\n+                result.append(\"];\")\n+                        .append(lineSeparator());\n+            });\n+\n+            result.append(\"}\");\n+            return result.toString();\n+        }\n+\n+    }\n+\n+    private static Class<?>[] permittedSubclasses(Class<?> node) {\n+        return java.util.Optional.ofNullable(node.getPermittedSubclasses())\n+                .orElse(new Class<?>[0]);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/GraphSealedHierarchyTest.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -67,9 +67,1 @@\n-            },\n-            {\n-                    FunctionDescriptor.of(MemoryLayout.sequenceLayout(2, C_INT)),\n-                    \"Unsupported layout: [2:i32]\"\n-            },\n-            {\n-                    FunctionDescriptor.ofVoid(MemoryLayout.sequenceLayout(2, C_INT)),\n-                    \"Unsupported layout: [2:i32]\"\n-            },\n+            }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-            assertTrue(selected == g.memberLayouts().get(i - 1));\n+            assertTrue(selected == g.elementAt(i - 1));\n@@ -302,1 +302,1 @@\n-            assertTrue(selected == g.memberLayouts().get(i - 1));\n+            assertTrue(selected == g.elementAt(i - 1));\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,2 +141,3 @@\n-        assertEquals(MemoryLayout.sequenceLayout(layout),\n-                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.bitSize(), layout));\n+        \/\/ assertEquals() will take too long\n+        assertTrue(MemoryLayout.sequenceLayout(layout).equals(\n+                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.bitSize(), layout)));\n@@ -246,1 +247,1 @@\n-        return Stream.of(basicLayouts)\n+        return Stream.of(BASIC_LAYOUTS)\n@@ -253,1 +254,1 @@\n-        Object[][] layoutsAndAlignments = new Object[basicLayouts.length * 4][];\n+        Object[][] layoutsAndAlignments = new Object[BASIC_LAYOUTS.length * 4][];\n@@ -256,1 +257,1 @@\n-        for (MemoryLayout l : basicLayouts) {\n+        for (MemoryLayout l : BASIC_LAYOUTS) {\n@@ -260,1 +261,1 @@\n-        for (MemoryLayout l : basicLayouts) {\n+        for (MemoryLayout l : BASIC_LAYOUTS) {\n@@ -264,1 +265,1 @@\n-        for (MemoryLayout l : basicLayouts) {\n+        for (MemoryLayout l : BASIC_LAYOUTS) {\n@@ -268,1 +269,1 @@\n-        for (MemoryLayout l : basicLayouts) {\n+        for (MemoryLayout l : BASIC_LAYOUTS) {\n@@ -274,1 +275,1 @@\n-    static MemoryLayout[] basicLayouts = {\n+    static final MemoryLayout[] BASIC_LAYOUTS = {\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            for (int i = 0 ; i < layout.elementCount() ; i++) {\n+            for (int i = 0; i < layout.elementCount() ; i++) {\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}