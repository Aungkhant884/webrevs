{"files":[{"patch":"@@ -33,3 +33,0 @@\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n@@ -52,1 +49,0 @@\n-import java.util.Optional;\n@@ -62,1 +58,0 @@\n-import jdk.internal.foreign.MemorySessionImpl;\n@@ -2463,22 +2458,0 @@\n-    \/**\n-     * Finds the address of a native symbol with given name, in one of the libraries {@linkplain System#loadLibrary(String) associated}\n-     * with this classloader.\n-     *\n-     * @param name the symbol name.\n-     * @return a zero-length segment, whose base address is the symbol address (if any).\n-     * @throws NullPointerException if name is null.\n-     * @see System#load(String)\n-     * @see System#loadLibrary(String)\n-     *\/\n-    public final Optional<MemorySegment> findNative(String name) {\n-        Objects.requireNonNull(name);\n-\n-        MemoryAddress addr = MemoryAddress.ofLong(findNative(this, name));\n-        return addr == MemoryAddress.NULL? Optional.empty()\n-                : Optional.of(MemorySegment.ofAddress(addr, 0L, loaderScope));\n-    }\n-\n-    \/\/ A memory session which keeps this loader reachable. Useful when returning\n-    \/\/ segments associated with libraries loaded by this loader.\n-    private final MemorySession loaderScope = MemorySessionImpl.heapSession(this);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -108,4 +108,0 @@\n- * <h2>Symbol lookup<\/h2>\n- * Clients can {@linkplain #lookup(String) look up} symbols in the standard libraries associated with this linker.\n- * The set of symbols available for lookup is unspecified, as it depends on the platform and on the operating system.\n- *\n@@ -164,10 +160,0 @@\n-    \/**\n-     * Look up a symbol in the standard libraries associated with this linker.\n-     * The set of symbols available for lookup is unspecified, as it depends on the platform and on the operating system.\n-     * @param name the symbol name\n-     * @return a zero-length segment, whose base address is the symbol address (if any).\n-     *\/\n-    default Optional<MemorySegment> lookup(String name) {\n-        return SystemLookup.getInstance().lookup(name);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -127,0 +127,5 @@\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.SystemLookup;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.loader.NativeLibrary;\n+import jdk.internal.loader.RawNativeLibraries;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * A symbol lookup can be used to look up a symbol in one or more loaded libraries. A symbol lookup allows for searching\n+ * symbols by name, see {@link SymbolLookup#lookup(String)}. A library symbol is modelled as a zero-length {@linkplain MemorySegment memory segment};\n+ * it can be used directly to create a {@linkplain CLinker#downcallHandle(Addressable, FunctionDescriptor) downcall method handle},\n+ * or it can be {@linkplain MemorySegment#ofAddress(MemoryAddress, long, MemorySession) resized} accordingly, if it models\n+ * a <em>global variable<\/em> that needs to be dereferenced.\n+ * <p>\n+ * Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n+ * which can be used to search symbols in libraries loaded by the current classloader (e.g. using {@link System#load(String)},\n+ * or {@link System#loadLibrary(String)}).\n+ * <p>\n+ * Alternatively, clients can search symbols in the standard C library using a {@linkplain SymbolLookup#systemLookup() system lookup},\n+ * which conveniently implements this interface. The set of symbols available in the system lookup is unspecified,\n+ * as it depends on the platform and on the operating system.\n+ * <p>\n+ * Finally, clients can load a library and obtain a {@linkplain #libraryLookup(Path, MemorySession) library lookup} which can be used\n+ * to search symbols in that library. A library lookup is associated with a {@linkplain  MemorySession memory session},\n+ * and the library it refers to is unloaded when the session is {@linkplain MemorySession#close() closed}.\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+@FunctionalInterface\n+public interface SymbolLookup {\n+\n+    \/**\n+     * Looks up a symbol with given name in this lookup.\n+     *\n+     * @param name the symbol name.\n+     * @return the lookup symbol (if any).\n+     *\/\n+    Optional<MemorySegment> lookup(String name);\n+\n+    \/**\n+     * Obtains a symbol lookup suitable to find symbols in native libraries associated with the caller's classloader.\n+     * The returned lookup returns native symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n+     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     *\n+     * @return a symbol lookup suitable to find symbols in libraries loaded by the caller's classloader.\n+     * @see System#load(String)\n+     * @see System#loadLibrary(String)\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup loaderLookup() {\n+        Class<?> caller = Reflection.getCallerClass();\n+        ClassLoader loader = Objects.requireNonNull(caller.getClassLoader());\n+        MemorySessionImpl loaderSession = MemorySessionImpl.heapSession(loader);\n+        return name -> {\n+            Objects.requireNonNull(name);\n+            JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n+            MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n+            return addr == MemoryAddress.NULL\n+                    ? Optional.empty() :\n+                    Optional.of(MemorySegment.ofAddress(addr, 0L, loaderSession));\n+        };\n+    }\n+\n+    \/**\n+     * Obtains a system lookup suitable to find symbols in the standard C libraries. The set of symbols\n+     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n+     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n+     *\/\n+    static SymbolLookup systemLookup() {\n+        return SystemLookup.getInstance();\n+    }\n+\n+    \/**\n+     * Loads a library with given name and obtains a symbol lookup suitable to find symbols in that library.\n+     * The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed}.\n+     * @apiNote The process of resolving a library name is platform-specific. For instance, on POSIX\n+     * systems, the library name is resolved according to the specification of the {@code dlopen} function.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param name the name of the library in which symbols should be looked up.\n+     * @param session the memory session which controls the library lifecycle.\n+     * @return a symbol lookup suitable to find symbols in a library with given name.\n+     * @throws IllegalArgumentException if {@code name} does not identify a valid library.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup libraryLookup(String name, MemorySession session) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), SymbolLookup.class, \"libraryLookup\");\n+        Objects.requireNonNull(name);\n+        Objects.requireNonNull(session);\n+        RawNativeLibraries nativeLibraries = RawNativeLibraries.newInstance(MethodHandles.lookup());\n+        NativeLibrary library = nativeLibraries.load(name);\n+        if (library == null) {\n+            throw new IllegalArgumentException(\"Cannot open library: \" + name);\n+        }\n+        return libraryLookup(nativeLibraries, library, session);\n+    }\n+\n+    \/**\n+     * Loads a library with given path and obtains a symbol lookup suitable to find symbols in that library.\n+     * The library will be unloaded when the provided memory session is {@linkplain MemorySession#close() closed}.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param path the path of the library in which symbols should be looked up.\n+     * @param session the memory session which controls the library lifecycle.\n+     * @return a symbol lookup suitable to find symbols in a library with given path.\n+     * @throws IllegalArgumentException if {@code path} does not point to a valid library.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup libraryLookup(Path path, MemorySession session) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), SymbolLookup.class, \"libraryLookup\");\n+        Objects.requireNonNull(path);\n+        Objects.requireNonNull(session);\n+        RawNativeLibraries nativeLibraries = RawNativeLibraries.newInstance(MethodHandles.lookup());\n+        NativeLibrary library = nativeLibraries.load(path);\n+        if (library == null) {\n+            throw new IllegalArgumentException(\"Cannot open library: \" + path);\n+        }\n+        return libraryLookup(nativeLibraries, library, session);\n+    }\n+\n+    private static SymbolLookup libraryLookup(RawNativeLibraries nativeLibraries, NativeLibrary library, MemorySession session) {\n+        \/\/ register hook to unload library when session is closed\n+        MemorySessionImpl.toSessionImpl(session).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                nativeLibraries.unload(library);\n+            }\n+        });\n+        return name -> {\n+            Objects.requireNonNull(name);\n+            MemoryAddress addr = MemoryAddress.ofLong(library.find(name));\n+            return addr == MemoryAddress.NULL\n+                    ? Optional.empty() :\n+                    Optional.of(MemorySegment.ofAddress(addr, 0L, session));\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -98,4 +98,4 @@\n- * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.FunctionDescriptor} and\n- * {@link java.lang.foreign.CLinker}.\n- * The first is used to model the signature of foreign functions, while the second provides linking capabilities\n- * which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.SymbolLookup},\n+ * {@link java.lang.foreign.FunctionDescriptor} and {@link java.lang.foreign.CLinker}. The first is used to look up symbols\n+ * inside native libraries; the second is used to model the signature of foreign functions, while the third provides\n+ * linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -111,1 +111,1 @@\n- *     linker.lookup(\"strlen\").get(),\n+ *     SymbolLookup.systemLookup().lookup(\"strlen\").get(),\n@@ -122,2 +122,2 @@\n- * Here, we obtain a {@linkplain java.lang.foreign.CLinker#systemCLinker() linker instance} and we use it\n- * to {@linkplain java.lang.foreign.CLinker#lookup(java.lang.String) look up} the {@code strlen} symbol in the\n+ * Here, we obtain a {@linkplain java.lang.foreign.SymbolLookup#systemLookup() system lookup} and we use it\n+ * to {@linkplain java.lang.foreign.SymbolLookup#lookup(java.lang.String) look up} the {@code strlen} symbol in the\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -43,1 +44,1 @@\n-public class SystemLookup {\n+public class SystemLookup implements SymbolLookup {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -339,12 +340,0 @@\n-    \/\/ lazy init MH_ALLOC and MH_FREE handles\n-    private static class AllocHolder {\n-\n-        private static final CLinker SYS_LINKER = getSystemLinker();\n-\n-        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"malloc\").get(),\n-                FunctionDescriptor.of(ADDRESS, JAVA_LONG));\n-\n-        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"free\").get(),\n-                FunctionDescriptor.ofVoid(ADDRESS));\n-    }\n-\n@@ -365,16 +354,0 @@\n-    public static MemoryAddress allocateMemoryInternal(long size) {\n-        try {\n-            return (MemoryAddress) AllocHolder.MH_MALLOC.invokeExact(size);\n-        } catch (Throwable th) {\n-            throw new RuntimeException(th);\n-        }\n-    }\n-\n-    public static void freeMemoryInternal(MemoryAddress addr) {\n-        try {\n-            AllocHolder.MH_FREE.invokeExact((Addressable)addr);\n-        } catch (Throwable th) {\n-            throw new RuntimeException(th);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+import java.nio.file.Path;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED LibraryLookupTest\n+ *\/\n+public class LibraryLookupTest {\n+\n+    static final Path JAVA_LIBRARY_PATH = Path.of(System.getProperty(\"java.library.path\"));\n+    static final MethodHandle INC = CLinker.systemCLinker().downcallHandle(FunctionDescriptor.ofVoid());\n+    static final Path LIB_PATH = JAVA_LIBRARY_PATH.resolve(System.mapLibraryName(\"LibraryLookup\"));\n+\n+    @Test\n+    void testLoadLibraryConfined() {\n+        try (MemorySession session0 = MemorySession.openConfined()) {\n+            callFunc(loadLibrary(session0));\n+            try (MemorySession session1 = MemorySession.openConfined()) {\n+                callFunc(loadLibrary(session1));\n+                try (MemorySession session2 = MemorySession.openConfined()) {\n+                    callFunc(loadLibrary(session2));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    void testLoadLibraryConfinedClosed() {\n+        Addressable addr;\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            addr = loadLibrary(session);\n+        }\n+        callFunc(addr);\n+    }\n+\n+    private static Addressable loadLibrary(MemorySession session) {\n+        SymbolLookup lib = SymbolLookup.libraryLookup(LIB_PATH, session);\n+        MemorySegment addr = lib.lookup(\"inc\").get();\n+        assertEquals(addr.session(), session);\n+        return addr;\n+    }\n+\n+    private static void callFunc(Addressable addr) {\n+        try {\n+            INC.invokeExact(addr);\n+        } catch (IllegalStateException ex) {\n+            throw ex;\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static final int ITERATIONS = 100;\n+    static final int MAX_EXECUTOR_WAIT_SECONDS = 20;\n+    static final int NUM_ACCESSORS = Math.min(10, Runtime.getRuntime().availableProcessors());\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void testBadLibraryLookupName() {\n+        SymbolLookup.libraryLookup(\"nonExistent\", MemorySession.global());\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void testBadLibraryLookupPath() {\n+        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), MemorySession.global());\n+    }\n+\n+    @Test\n+    void testLoadLibraryShared() throws Throwable {\n+        ExecutorService accessExecutor = Executors.newCachedThreadPool();\n+        for (int i = 0; i < NUM_ACCESSORS ; i++) {\n+            accessExecutor.execute(new LibraryLoadAndAccess());\n+        }\n+        accessExecutor.shutdown();\n+        assertTrue(accessExecutor.awaitTermination(MAX_EXECUTOR_WAIT_SECONDS, TimeUnit.SECONDS));\n+    }\n+\n+    static class LibraryLoadAndAccess implements Runnable {\n+        @Override\n+        public void run() {\n+            for (int i = 0 ; i < ITERATIONS ; i++) {\n+                try (MemorySession session = MemorySession.openConfined()) {\n+                    callFunc(loadLibrary(session));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testLoadLibrarySharedClosed() throws Throwable {\n+        MemorySession session = MemorySession.openShared();\n+        Addressable addr = loadLibrary(session);\n+        ExecutorService accessExecutor = Executors.newCachedThreadPool();\n+        for (int i = 0; i < NUM_ACCESSORS ; i++) {\n+            accessExecutor.execute(new LibraryAccess(addr));\n+        }\n+        while (true) {\n+            try {\n+                session.close();\n+                break;\n+            } catch (IllegalStateException ex) {\n+                \/\/ wait for addressable parameter to be released\n+                Thread.onSpinWait();\n+            }\n+        }\n+        accessExecutor.shutdown();\n+        assertTrue(accessExecutor.awaitTermination(MAX_EXECUTOR_WAIT_SECONDS, TimeUnit.SECONDS));\n+    }\n+\n+    static class LibraryAccess implements Runnable {\n+\n+        final Addressable addr;\n+\n+        LibraryAccess(Addressable addr) {\n+            this.addr = addr;\n+        }\n+\n+        @Override\n+        public void run() {\n+            for (int i = 0 ; i < ITERATIONS ; i++) {\n+                try {\n+                    callFunc(addr);\n+                } catch (IllegalStateException ex) {\n+                    \/\/ library closed\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -88,1 +89,1 @@\n-            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            SymbolLookup.systemLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -91,1 +92,1 @@\n-            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            SymbolLookup.systemLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n@@ -109,2 +110,2 @@\n-    public static Addressable findNativeOrThrow(Class<?> clazz, String name) {\n-        return clazz.getClassLoader().findNative(name).orElseThrow();\n+    public static Addressable findNativeOrThrow(String name) {\n+        return SymbolLookup.loaderLookup().lookup(name).orElseThrow();\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.Arrays;\n@@ -65,1 +64,1 @@\n-                findNativeOrThrow(SafeFunctionAccessTest.class,\"struct_func\"),\n+                findNativeOrThrow(\"struct_func\"),\n@@ -74,1 +73,1 @@\n-                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_6\"),\n+                findNativeOrThrow(\"addr_func_6\"),\n@@ -116,1 +115,1 @@\n-                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func\"),\n+                findNativeOrThrow(\"addr_func\"),\n@@ -131,1 +130,1 @@\n-                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func\"),\n+                findNativeOrThrow(\"addr_func\"),\n@@ -142,1 +141,1 @@\n-                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_cb\"),\n+                findNativeOrThrow(\"addr_func_cb\"),\n@@ -154,1 +153,1 @@\n-                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_cb\"),\n+                findNativeOrThrow(\"addr_func_cb\"),\n@@ -166,1 +165,1 @@\n-                findNativeOrThrow(SafeFunctionAccessTest.class, \"addr_func_cb\"),\n+                findNativeOrThrow(\"addr_func_cb\"),\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -155,1 +155,3 @@\n-        final static MethodHandle strcat = abi.downcallHandle(abi.lookup(\"strcat\").get(),\n+        final static SymbolLookup stdlib = SymbolLookup.systemLookup();\n+\n+        final static MethodHandle strcat = abi.downcallHandle(stdlib.lookup(\"strcat\").get(),\n@@ -159,1 +161,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(abi.lookup(\"strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(stdlib.lookup(\"strcmp\").get(),\n@@ -162,1 +164,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(abi.lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(stdlib.lookup(\"puts\").get(),\n@@ -165,1 +167,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(stdlib.lookup(\"strlen\").get(),\n@@ -168,1 +170,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(abi.lookup(\"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(stdlib.lookup(\"gmtime\").get(),\n@@ -171,1 +173,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(abi.lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(stdlib.lookup(\"qsort\").get(),\n@@ -178,1 +180,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(abi.lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(stdlib.lookup(\"rand\").get(),\n@@ -181,1 +183,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(abi.lookup(\"vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(stdlib.lookup(\"vprintf\").get(),\n@@ -184,1 +186,1 @@\n-        final static Addressable printfAddr = abi.lookup(\"printf\").get();\n+        final static Addressable printfAddr = stdlib.lookup(\"printf\").get();\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -51,1 +52,1 @@\n-        assertFalse(this.getClass().getClassLoader().findNative(\"f\").isEmpty());\n+        assertFalse(SymbolLookup.loaderLookup().lookup(\"f\").isEmpty());\n@@ -56,1 +57,1 @@\n-        assertTrue(this.getClass().getClassLoader().findNative(\"nonExistent\").isEmpty());\n+        assertTrue(SymbolLookup.loaderLookup().lookup(\"nonExistent\").isEmpty());\n@@ -61,1 +62,4 @@\n-        MemorySegment segment = MemorySegment.ofAddress(this.getClass().getClassLoader().findNative(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), MemorySession.global());\n+        MemorySegment segment = MemorySegment.ofAddress(\n+                SymbolLookup.loaderLookup().lookup(\"c\").get().address(),\n+                ValueLayout.JAVA_INT.byteSize(),\n+                MemorySession.global());\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        Addressable addr = findNativeOrThrow(TestDowncall.class, fName);\n+        Addressable addr = findNativeOrThrow(fName);\n@@ -91,1 +91,1 @@\n-        Addressable addr = findNativeOrThrow(TestDowncall.class, \"s\" + fName);\n+        Addressable addr = findNativeOrThrow(\"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -41,2 +42,1 @@\n-        CLinker linker = CLinker.systemCLinker();\n-        assertTrue(linker.lookup(\"nonExistentSymbol\").isEmpty());\n+        assertTrue(SymbolLookup.systemLookup().lookup(\"nonExistentSymbol\").isEmpty());\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            Addressable ma = findNativeOrThrow(TestIntrinsics.class, name);\n+            Addressable ma = findNativeOrThrow(name);\n@@ -96,1 +96,1 @@\n-            Addressable ma = findNativeOrThrow(TestIntrinsics.class, \"empty\");\n+            Addressable ma = findNativeOrThrow(\"empty\");\n@@ -111,1 +111,1 @@\n-            Addressable ma = findNativeOrThrow(TestIntrinsics.class, \"identity_va\");\n+            Addressable ma = findNativeOrThrow(\"identity_va\");\n@@ -124,1 +124,1 @@\n-                Addressable ma = findNativeOrThrow(TestIntrinsics.class, \"invoke_high_arity\" + i);\n+                Addressable ma = findNativeOrThrow(\"invoke_high_arity\" + i);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-            MemorySession.class\n+            MemorySession.class,\n+            SymbolLookup.class\n@@ -177,0 +178,1 @@\n+        addDefaultMapping(SymbolLookup.class, SymbolLookup.loaderLookup());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        Addressable addr = findNativeOrThrow(TestUpcallAsync.class, fName);\n+        Addressable addr = findNativeOrThrow(fName);\n@@ -96,1 +96,1 @@\n-                            TestUpcallAsync.class.getClassLoader().findNative(symbol).orElseThrow(),\n+                            findNativeOrThrow(symbol),\n@@ -104,1 +104,1 @@\n-            Addressable invokerSymbol = TestUpcallAsync.class.getClassLoader().findNative(symbol).orElseThrow();\n+            Addressable invokerSymbol = findNativeOrThrow(symbol);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-                    findNativeOrThrow(TestUpcallHighArity.class, \"do_upcall\"),\n+                    findNativeOrThrow(\"do_upcall\"),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        Addressable addr = findNativeOrThrow(TestUpcallScope.class, fName);\n+        Addressable addr = findNativeOrThrow(fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        Addressable addr = findNativeOrThrow(TestUpcallStack.class, \"s\" + fName);\n+        Addressable addr = findNativeOrThrow(\"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-                findNativeOrThrow(TestUpcallStructScope.class, \"do_upcall\"),\n+                findNativeOrThrow(\"do_upcall\"),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    static final Addressable VARARGS_ADDR = findNativeOrThrow(TestVarArgs.class, \"varargs\");\n+    static final Addressable VARARGS_ADDR = findNativeOrThrow(\"varargs\");\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-            ThrowingUpcall.class.getClassLoader().findNative(\"f0_V__\").orElseThrow(),\n+            findNativeOrThrow(\"f0_V__\"),\n@@ -46,1 +46,1 @@\n-                ThrowingUpcall.class.getClassLoader().findNative(\"f10_I_I_\").orElseThrow(),\n+                findNativeOrThrow(\"f10_I_I_\"),\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -88,0 +89,1 @@\n+        addDefaultMapping(SymbolLookup.class, SymbolLookup.loaderLookup());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\n+import java.lang.foreign.SymbolLookup;\n@@ -39,0 +39,3 @@\n+\n+import java.nio.file.Path;\n+\n@@ -53,1 +56,1 @@\n-                            MethodType.methodType(CLinker.class)), \"ForeignLinker::systemCLinker\" },\n+                            MethodType.methodType(CLinker.class)), \"CLinker::systemCLinker\" },\n@@ -60,0 +63,6 @@\n+                    { MethodHandles.lookup().findStatic(SymbolLookup.class, \"libraryLookup\",\n+                            MethodType.methodType(SymbolLookup.class, String.class, MemorySession.class)),\n+                            \"SymbolLookup::libraryLookup(String)\" },\n+                    { MethodHandles.lookup().findStatic(SymbolLookup.class, \"libraryLookup\",\n+                            MethodType.methodType(SymbolLookup.class, Path.class, MemorySession.class)),\n+                            \"SymbolLookup::libraryLookup(Path)\" },\n@@ -120,0 +129,42 @@\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n+                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n+                            \"MemoryAddress::getAtIndex\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n+                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n+                            \"MemoryAddress::getAtIndex\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n+                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n+                            \"MemoryAddress::getAtIndex\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n+                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n+                            \"MemoryAddress::getAtIndex\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n+                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n+                            \"MemoryAddress::getAtIndex\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n+                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n+                            \"MemoryAddress::getAtIndex\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getAtIndex\",\n+                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n+                            \"MemoryAddress::getAtIndex\/address\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n+                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n+                            \"MemoryAddress::setAtIndex\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n+                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n+                            \"MemoryAddress::setAtIndex\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n+                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n+                            \"MemoryAddress::setAtIndex\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n+                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n+                            \"MemoryAddress::setAtIndex\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n+                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n+                            \"MemoryAddress::set\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n+                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n+                            \"MemoryAddress::set\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setAtIndex\",\n+                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n+                            \"MemoryAddress::set\/address\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+int count = 0;\n+\n+EXPORT int inc() {\n+  return count++;\n+}\n","filename":"test\/jdk\/java\/foreign\/libLibraryLookup.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -34,1 +35,1 @@\n-        return Lookup.class.getClassLoader().findNative(\"foo\").get();\n+        return SymbolLookup.loaderLookup().lookup(\"foo\").get();\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-                TestMixedMallocFree.class.getClassLoader().findNative(\"my_malloc\").orElseThrow(),\n+                findNativeOrThrow(\"my_malloc\"),\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                    findNativeOrThrow(TestAsyncStackWalk.class, \"asyncStackWalk\"),\n+                    findNativeOrThrow(\"asyncStackWalk\"),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                    findNativeOrThrow(TestStackWalk.class, \"foo\"),\n+                    findNativeOrThrow(\"foo\"),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-                    TestUpcallDeopt.class.getClassLoader().findNative(\"foo\").orElseThrow(),\n+                    findNativeOrThrow(\"foo\"),\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        return abi.downcallHandle(findNativeOrThrow(VaListTest.class, symbol), fd);\n+        return abi.downcallHandle(findNativeOrThrow(symbol), fd);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,3 +58,3 @@\n-        funcA = findNativeOrThrow(TestVirtualCalls.class, \"funcA\");\n-        funcB = findNativeOrThrow(TestVirtualCalls.class, \"funcB\");\n-        funcC = findNativeOrThrow(TestVirtualCalls.class, \"funcC\");\n+        funcA = findNativeOrThrow(\"funcA\");\n+        funcB = findNativeOrThrow(\"funcB\");\n+        funcC = findNativeOrThrow(\"funcC\");\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -75,1 +76,1 @@\n-            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            SymbolLookup.systemLookup().lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -78,1 +79,1 @@\n-            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+            SymbolLookup.systemLookup().lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -94,0 +95,1 @@\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n@@ -95,1 +97,1 @@\n-            func_addr = CallOverheadHelper.class.getClassLoader().findNative(\"func\").orElseThrow();\n+            func_addr = loaderLibs.lookup(\"func\").orElseThrow();\n@@ -102,1 +104,1 @@\n-            identity_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity\").orElseThrow();\n+            identity_addr = loaderLibs.lookup(\"identity\").orElseThrow();\n@@ -107,1 +109,1 @@\n-        identity_struct_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_struct\").orElseThrow();\n+        identity_struct_addr = loaderLibs.lookup(\"identity_struct\").orElseThrow();\n@@ -112,1 +114,1 @@\n-        identity_struct_3_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_struct_3\").orElseThrow();\n+        identity_struct_3_addr = loaderLibs.lookup(\"identity_struct_3\").orElseThrow();\n@@ -117,1 +119,1 @@\n-        identity_memory_address_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_addr = loaderLibs.lookup(\"identity_memory_address\").orElseThrow();\n@@ -122,1 +124,1 @@\n-        identity_memory_address_3_addr = CallOverheadHelper.class.getClassLoader().findNative(\"identity_memory_address_3\").orElseThrow();\n+        identity_memory_address_3_addr = loaderLibs.lookup(\"identity_memory_address_3\").orElseThrow();\n@@ -127,1 +129,1 @@\n-        args1_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args1\").orElseThrow();\n+        args1_addr = loaderLibs.lookup(\"args1\").orElseThrow();\n@@ -132,1 +134,1 @@\n-        args2_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args2\").orElseThrow();\n+        args2_addr = loaderLibs.lookup(\"args2\").orElseThrow();\n@@ -137,1 +139,1 @@\n-        args3_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args3\").orElseThrow();\n+        args3_addr = loaderLibs.lookup(\"args3\").orElseThrow();\n@@ -142,1 +144,1 @@\n-        args4_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args4\").orElseThrow();\n+        args4_addr = loaderLibs.lookup(\"args4\").orElseThrow();\n@@ -147,1 +149,1 @@\n-        args5_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args5\").orElseThrow();\n+        args5_addr = loaderLibs.lookup(\"args5\").orElseThrow();\n@@ -152,1 +154,1 @@\n-        args10_addr = CallOverheadHelper.class.getClassLoader().findNative(\"args10\").orElseThrow();\n+        args10_addr = loaderLibs.lookup(\"args10\").orElseThrow();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -67,1 +68,2 @@\n-        F_LONG = abi.downcallHandle(PointerInvoke.class.getClassLoader().findNative(\"func_as_long\").get(),\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        F_LONG = abi.downcallHandle(loaderLibs.lookup(\"func_as_long\").get(),\n@@ -69,1 +71,1 @@\n-        F_PTR = abi.downcallHandle(PointerInvoke.class.getClassLoader().findNative(\"func_as_ptr\").get(),\n+        F_PTR = abi.downcallHandle(loaderLibs.lookup(\"func_as_ptr\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -65,1 +66,1 @@\n-    static Addressable qsort_addr = abi.lookup(\"qsort\").get();\n+    static Addressable qsort_addr = SymbolLookup.systemLookup().lookup(\"qsort\").get();\n@@ -80,1 +81,1 @@\n-            native_compar = QSort.class.getClassLoader().findNative(\"compar\").orElseThrow();\n+            native_compar = SymbolLookup.loaderLookup().lookup(\"compar\").orElseThrow();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -77,1 +78,1 @@\n-        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n+        STRLEN = abi.downcallHandle(SymbolLookup.systemLookup().lookup(\"strlen\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -124,1 +125,1 @@\n-                Upcalls.class.getClassLoader().findNative(name).orElseThrow(),\n+                SymbolLookup.loaderLookup().lookup(name).orElseThrow(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -59,1 +60,2 @@\n-        MH_ellipsis = linker.downcallHandle(VaList.class.getClassLoader().findNative(\"ellipsis\").get(),\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n+        MH_ellipsis = linker.downcallHandle(loaderLibs.lookup(\"ellipsis\").get(),\n@@ -61,1 +63,1 @@\n-        MH_vaList = linker.downcallHandle(VaList.class.getClassLoader().findNative(\"vaList\").get(),\n+        MH_vaList = linker.downcallHandle(loaderLibs.lookup(\"vaList\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -53,0 +54,1 @@\n+        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n@@ -54,1 +56,1 @@\n-                PanamaPoint.class.getClassLoader().findNative(\"distance\").get(),\n+                loaderLibs.lookup(\"distance\").get(),\n@@ -58,1 +60,1 @@\n-                PanamaPoint.class.getClassLoader().findNative(\"distance_ptrs\").get(),\n+                loaderLibs.lookup(\"distance_ptrs\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}