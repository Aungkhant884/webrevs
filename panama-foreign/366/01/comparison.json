{"files":[{"patch":"@@ -418,0 +418,28 @@\n+    \/**\n+     * Obtains a new confined memory segment backed by the same underlying memory region as this segment, but whose\n+     * temporal bounds are controlled by the provided {@link NativeScope} instance.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>;\n+     * as a side-effect, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n+     * The returned segment will feature only {@link MemorySegment#READ} and {@link MemorySegment#WRITE} access modes\n+     * (assuming these were available in the original segment). As such the returned segment cannot be closed directly\n+     * using {@link MemorySegment#close()} - but it will be closed indirectly when this native scope is closed. The\n+     * returned segment will also be confined by the same thread as the provided native scope (see {@link NativeScope#ownerThread()}).\n+     * <p>\n+     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n+     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on the new owner thread.\n+     *\n+     * @param nativeScope the native scope.\n+     * @return a new confined memory segment backed by the same underlying memory region as this segment, but whose life-cycle\n+     * is tied to that of {@code nativeScope}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n+     * @throws NullPointerException if {@code nativeScope == null}.\n+     *\/\n+    MemorySegment handoff(NativeScope nativeScope);\n+\n@@ -851,1 +879,1 @@\n-                 .withOwnerThread(null)\n+                 .share()\n@@ -901,1 +929,1 @@\n-     * (see {@link #handoff(Thread)}).\n+     * (see {@link #handoff(NativeScope)} and {@link #handoff(Thread)}).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -52,2 +51,2 @@\n- * To allow for more usability, it is possible for an native scope to reclaim ownership of an existing memory segments\n- * (see {@link #register(MemorySegment)}). This might be useful to allow one or more segments which were independently\n+ * To allow for more usability, it is possible for a native scope to reclaim ownership of an existing memory segment\n+ * (see {@link MemorySegment#handoff(NativeScope)}). This might be useful to allow one or more segments which were independently\n@@ -407,19 +406,0 @@\n-    \/**\n-     * Register a segment on this scope, which will then reclaim ownership of said segment.\n-     * The input segment must be closeable - that is, it must feature the {@link MemorySegment#CLOSE} access mode.\n-     * As a side-effect, the input segment will be marked as <em>not alive<\/em>, and a new segment will be returned.\n-     * <p>\n-     * The returned segment will feature only {@link MemorySegment#READ} and\n-     * {@link MemorySegment#WRITE} access modes (assuming these were available in the original segment). As such\n-     * the resulting segment cannot be closed directly using {@link MemorySegment#close()} - but it will be closed\n-     * indirectly when this native scope is closed.\n-     * @param segment the segment which will be registered on this native scope.\n-     * @return a new, non closeable memory segment, backed by the same underlying region as {@code segment},\n-     * but whose life-cycle is tied to that of this native scope.\n-     * @throws IllegalStateException if {@code segment} is not <em>alive<\/em> (see {@link MemorySegment#isAlive()}).\n-     * @throws NullPointerException if {@code segment == null}\n-     * @throws IllegalArgumentException if {@code segment} is not confined and {@code segment.ownerThread() != this.ownerThread()},\n-     * or if {@code segment} does not feature the {@link MemorySegment#CLOSE} access mode.\n-     *\/\n-    MemorySegment register(MemorySegment segment);\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -314,0 +314,16 @@\n+   @Override\n+    public MemorySegment handoff(NativeScope scope) {\n+        Objects.requireNonNull(scope);\n+        checkValidState();\n+        if (!isSet(HANDOFF)) {\n+            throw unsupportedAccessMode(HANDOFF);\n+        }\n+        if (!isSet(CLOSE)) {\n+            throw unsupportedAccessMode(CLOSE);\n+        }\n+        MemorySegment dup = handoff(scope.ownerThread());\n+        ((AbstractNativeScope)scope).register(dup);\n+        return dup.withAccessModes(accessModes() & (READ | WRITE));\n+    }\n+\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -8,1 +8,0 @@\n-import java.util.Objects;\n@@ -29,7 +28,1 @@\n-        for (MemorySegment segment : segments) {\n-            try {\n-                segment.close();\n-            } catch (IllegalStateException ex) {\n-                \/\/already closed - skip\n-            }\n-        }\n+        segments.forEach(MemorySegment::close);\n@@ -54,12 +47,2 @@\n-    @Override\n-    public MemorySegment register(MemorySegment segment) {\n-        Objects.requireNonNull(segment);\n-        if (segment.ownerThread() != null && (segment.ownerThread() != ownerThread())) {\n-            throw new IllegalArgumentException(\"Cannot register segment owned by a different thread\");\n-        } else if (!segment.hasAccessModes(MemorySegment.CLOSE)) {\n-            throw new IllegalArgumentException(\"Cannot register a non-closeable segment\");\n-        }\n-        MemorySegment attachedSegment = segment.handoff(ownerThread());\n-        segments.add(attachedSegment);\n-        return attachedSegment\n-                .withAccessModes(segment.accessModes() & SCOPE_MASK);\n+    public void register(MemorySegment segment) {\n+        segments.add(segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractNativeScope.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    final MemoryScope confineTo(Thread newOwner) {\n+    MemoryScope confineTo(Thread newOwner) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0, () -> freeUpcallStub(stubAddress), null)\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(\n+                MemoryAddress.ofLong(stubAddress), 0, () -> freeUpcallStub(stubAddress), null)\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        liveness = scope.register(liveness);\n+        liveness = liveness.handoff(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-                    .withOwnerThread(null);\n+                    .share();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TranslationUnit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4215,1 +4215,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -4234,1 +4234,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -4253,1 +4253,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -4272,1 +4272,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -5230,1 +5230,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -5758,1 +5758,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -6026,1 +6026,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -6045,1 +6045,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n@@ -7826,1 +7826,1 @@\n-            return scope.register(allocate(fi));\n+            return allocate(fi).handoff(scope);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                    .withOwnerThread(null))).orElse(null);\n+                    .share())).orElse(null);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/RuntimeHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        builder.append(\"return scope.register(allocate(fi));\\n\");\n+        builder.append(\"return allocate(fi).handoff(scope);\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                    .withOwnerThread(null))).orElse(null);\n+                    .share())).orElse(null);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-                qsortUpcallStub = scope.register(qsortUpcallStub);\n+                qsortUpcallStub = qsortUpcallStub.handoff(scope);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import java.util.function.BiFunction;\n@@ -130,1 +129,1 @@\n-            MemorySegment ss1 = scope.register(s1);\n+            MemorySegment ss1 = s1.handoff(scope);\n@@ -134,1 +133,1 @@\n-            MemorySegment ss2 = scope.register(s2);\n+            MemorySegment ss2 = s2.handoff(scope);\n@@ -138,1 +137,1 @@\n-            MemorySegment ss3 = scope.register(s3);\n+            MemorySegment ss3 = s3.handoff(scope);\n@@ -152,1 +151,1 @@\n-            MemorySegment attached = scope.register(s1);\n+            MemorySegment attached = s1.handoff(scope);\n@@ -162,1 +161,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n@@ -167,1 +166,1 @@\n-        scope2.register(scope1.register(s1));\n+        s1.handoff(scope1).handoff(scope2);\n@@ -172,1 +171,1 @@\n-        NativeScope.boundedScope(10).register(null);\n+        MemorySegment.ofArray(new byte[5]).handoff((NativeScope)null);\n@@ -179,17 +178,1 @@\n-        NativeScope.boundedScope(10).register(segment);\n-    }\n-\n-    @Test\n-    public void testNoClaimFromWrongThread() throws InterruptedException {\n-        MemorySegment s = MemorySegment.ofArray(new byte[1]);\n-        AtomicBoolean failed = new AtomicBoolean(false);\n-        Thread t = new Thread(() -> {\n-            try {\n-                NativeScope.boundedScope(10).register(s);\n-            } catch (IllegalArgumentException ex) {\n-                failed.set(true);\n-            }\n-        });\n-        t.start();\n-        t.join();\n-        assertTrue(failed.get());\n+        segment.handoff(NativeScope.boundedScope(10));\n@@ -202,1 +185,1 @@\n-        MemorySegment registered = scope.register(unconfined);\n+        MemorySegment registered = unconfined.handoff(scope);\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            sum = scope.register(sum);\n+            sum = sum.handoff(scope);\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/LibTest8246400Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}