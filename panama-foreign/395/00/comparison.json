{"files":[{"patch":"@@ -64,0 +64,1 @@\n+        Objects.requireNonNull(name);\n@@ -74,0 +75,1 @@\n+        Objects.requireNonNull(name);\n@@ -84,0 +86,1 @@\n+        Objects.requireNonNull(name);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -78,0 +79,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -97,0 +99,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -116,0 +119,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -148,0 +152,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -154,0 +159,1 @@\n+        Objects.requireNonNull(segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -93,0 +94,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -95,0 +97,1 @@\n+        Objects.requireNonNull(segment);\n@@ -104,0 +107,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -106,0 +110,1 @@\n+        Objects.requireNonNull(segment);\n@@ -119,0 +124,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -134,0 +140,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -149,0 +156,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -164,0 +172,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -179,0 +188,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -194,0 +204,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -209,0 +220,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -224,0 +236,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -239,0 +252,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -254,0 +268,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -269,0 +284,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -284,0 +300,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -300,0 +317,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -302,0 +320,1 @@\n+        Objects.requireNonNull(segment);\n@@ -316,0 +335,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code value == null}.\n@@ -318,0 +338,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(value);\n@@ -333,0 +355,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -335,0 +358,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -350,0 +375,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -352,0 +378,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -367,0 +395,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -369,0 +398,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -384,0 +415,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -386,0 +418,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -401,0 +435,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -403,0 +438,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -418,0 +455,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -420,0 +458,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -435,0 +475,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -437,0 +478,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -452,0 +495,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -454,0 +498,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -469,0 +515,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -471,0 +518,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -486,0 +535,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -488,0 +538,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -503,0 +555,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -505,0 +558,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -520,0 +575,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -522,0 +578,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -535,0 +593,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -549,0 +608,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -563,0 +623,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -577,0 +638,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -591,0 +653,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -605,0 +668,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -619,0 +683,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -633,0 +698,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -647,0 +713,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -661,0 +728,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -675,0 +743,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -689,0 +758,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -703,0 +773,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -717,0 +788,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -731,0 +803,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -745,0 +818,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code value == null}.\n@@ -760,0 +834,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -775,0 +850,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -790,0 +866,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -805,0 +882,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -820,0 +898,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -835,0 +914,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -850,0 +930,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -865,0 +946,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -880,0 +962,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -895,0 +978,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -910,0 +994,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -925,0 +1010,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -940,0 +1026,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -955,0 +1042,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -970,0 +1058,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -985,0 +1074,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1000,0 +1090,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1015,0 +1106,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1030,0 +1122,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1045,0 +1138,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1060,0 +1154,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1075,0 +1170,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1090,0 +1186,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1096,1 +1193,1 @@\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1100,1 +1197,1 @@\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n+    setDoubleAtOffset(segment, 8 * index, value);\n@@ -1104,1 +1201,2 @@\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n+     * @param value the double value to be written.\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1106,2 +1204,2 @@\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n+    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n+        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n@@ -1111,1 +1209,1 @@\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1115,1 +1213,1 @@\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n+    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n@@ -1119,1 +1217,2 @@\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1121,2 +1220,2 @@\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n+    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n+        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n@@ -1126,1 +1225,1 @@\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1130,1 +1229,1 @@\n-    setDoubleAtOffset(segment, 8 * index, value);\n+    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n@@ -1134,1 +1233,2 @@\n-     * @param value the double value to be written.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * @throws NullPointerException if {@code segment == null}, or if {@code value == null}.\n@@ -1136,2 +1236,2 @@\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n+    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n+        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n@@ -1151,0 +1251,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1167,0 +1268,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1183,0 +1285,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1199,0 +1302,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1215,0 +1319,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1231,0 +1336,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1247,0 +1353,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1263,0 +1370,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1279,0 +1387,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1295,0 +1404,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1311,0 +1421,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1327,0 +1438,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":127,"deletions":15,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+     * @throws NullPointerException if {@code carrier == null}, or {@code byteOrder == null}.\n@@ -173,1 +174,0 @@\n-        checkCarrier(carrier);\n@@ -197,0 +197,1 @@\n+     * @throws NullPointerException if {@code carrier == null}, or {@code byteOrder == null}.\n@@ -199,0 +200,2 @@\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(byteOrder);\n@@ -221,0 +224,1 @@\n+     * @throws NullPointerException if {@code target == null}.\n@@ -223,0 +227,1 @@\n+        Objects.requireNonNull(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.stream.Collectors;\n@@ -253,0 +254,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -311,0 +313,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -322,0 +325,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -345,0 +349,1 @@\n+     * @throws NullPointerException if any of the elements in {@code elements} is {@code null}.\n@@ -364,0 +369,1 @@\n+     * @throws NullPointerException if any of the elements in {@code elements} is {@code null}.\n@@ -404,0 +410,1 @@\n+     * @throws NullPointerException if {@code carrier == null}, or if any of the elements in {@code elements} is {@code null}.\n@@ -406,0 +413,1 @@\n+        Objects.requireNonNull(carrier);\n@@ -418,0 +426,1 @@\n+     * @throws NullPointerException if any of the elements in {@code elements} is {@code null}.\n@@ -435,0 +444,1 @@\n+     * @throws NullPointerException if {@code op == null}, or if any of the elements in {@code elements} is {@code null}.\n@@ -437,0 +447,1 @@\n+        Objects.requireNonNull(op);\n@@ -444,1 +455,1 @@\n-            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;\n+            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n@@ -608,0 +619,1 @@\n+     * @throws NullPointerException if {@code order == null}.\n@@ -611,1 +623,1 @@\n-        return new ValueLayout(order, size);\n+        return new ValueLayout(Objects.requireNonNull(order), size);\n@@ -621,0 +633,1 @@\n+     * @throws NullPointerException if {@code elementLayout == null}.\n@@ -625,1 +638,1 @@\n-        return new SequenceLayout(size, elementLayout);\n+        return new SequenceLayout(size, Objects.requireNonNull(elementLayout));\n@@ -633,0 +646,1 @@\n+     * @throws NullPointerException if {@code elementLayout == null}.\n@@ -635,1 +649,1 @@\n-        return new SequenceLayout(OptionalLong.empty(), elementLayout);\n+        return new SequenceLayout(OptionalLong.empty(), Objects.requireNonNull(elementLayout));\n@@ -643,0 +657,1 @@\n+     * @throws NullPointerException if {@code elements == null}, or if any of the layouts in {@code elements} is {@code null}.\n@@ -645,1 +660,5 @@\n-        return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.STRUCT,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n@@ -653,0 +672,1 @@\n+     * @throws NullPointerException if {@code elements == null}, or if any of the layouts in {@code elements} is {@code null}.\n@@ -655,1 +675,5 @@\n-        return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.UNION,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -254,0 +254,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -478,0 +479,1 @@\n+     * @throws NullPointerException if {@code cleaner == null}.\n@@ -528,0 +530,1 @@\n+     * @throws NullPointerException if {@code src == null}.\n@@ -554,0 +557,1 @@\n+     * @throws NullPointerException if {@code src == null}.\n@@ -678,0 +682,1 @@\n+     * @throws NullPointerException if {@code bb == null}.\n@@ -692,0 +697,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -706,0 +712,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -720,0 +727,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -734,0 +742,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -748,0 +757,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -762,0 +772,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -776,0 +787,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -796,0 +808,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -798,0 +811,1 @@\n+        Objects.requireNonNull(layout);\n@@ -860,0 +874,1 @@\n+     * @throws NullPointerException if {@code path == null} or if {@code mapMode == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+     * @throws NullPointerException if {@code order == null}.\n@@ -80,1 +81,1 @@\n-        return new ValueLayout(order, bitSize(), alignment, attributes);\n+        return new ValueLayout(Objects.requireNonNull(order), bitSize(), alignment, attributes);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+        Objects.requireNonNull(sequenceLayout);\n@@ -128,1 +129,1 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n@@ -139,1 +140,1 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n@@ -569,0 +570,1 @@\n+        Objects.requireNonNull(bb);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+        Objects.requireNonNull(arr);\n@@ -93,0 +94,1 @@\n+        Objects.requireNonNull(arr);\n@@ -98,0 +100,1 @@\n+        Objects.requireNonNull(arr);\n@@ -103,0 +106,1 @@\n+        Objects.requireNonNull(arr);\n@@ -108,0 +112,1 @@\n+        Objects.requireNonNull(arr);\n@@ -113,0 +118,1 @@\n+        Objects.requireNonNull(arr);\n@@ -118,0 +124,1 @@\n+        Objects.requireNonNull(arr);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -112,0 +113,2 @@\n+        Objects.requireNonNull(path);\n+        Objects.requireNonNull(mapMode);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testBadAdaptNull() {\n+        MemoryHandles.asAddressVarHandle(null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -126,0 +126,6 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullCleaner() {\n+        MemorySegment segment = MemorySegment.ofArray(new byte[10]);\n+        segment.registerCleaner(null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,0 +83,14 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testWithNameNull() {\n+        MemoryLayouts.BITS_8_BE.withName(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testFetchAttributeNull() {\n+        MemoryLayouts.BITS_8_BE.attribute(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testPutAttributeNull() {\n+        MemoryLayouts.BITS_8_BE.withAttribute(null, \"Hello\");\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutAttributes.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Function;\n@@ -34,0 +35,1 @@\n+import java.util.function.UnaryOperator;\n@@ -224,0 +226,75 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testValueLayoutNullOrder() {\n+        MemoryLayout.ofValueBits(10, null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testValueLayoutWithNullOrder() {\n+        MemoryLayout.ofValueBits(10, ByteOrder.BIG_ENDIAN).withOrder(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testUnboundSequenceLayoutNullElement() {\n+        MemoryLayout.ofSequence(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testBoundSequenceLayoutNullElement() {\n+        MemoryLayout.ofSequence(10, null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testStructNullElements() {\n+        MemoryLayout.ofStruct(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testUnionNullElements() {\n+        MemoryLayout.ofUnion(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testStructWithNullElement() {\n+        MemoryLayout.ofStruct(new MemoryLayout[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testUnionWithNullElement() {\n+        MemoryLayout.ofUnion(new MemoryLayout[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testMapWithNullPathElement() {\n+        MemoryLayouts.BITS_8_BE.map(UnaryOperator.identity(), new MemoryLayout.PathElement[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testMapWithNullOp() {\n+        MemoryLayouts.BITS_8_BE.map(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testBitOffsetWithNullPathElement() {\n+        MemoryLayouts.BITS_8_BE.bitOffset(new MemoryLayout.PathElement[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testByteOffsetWithNullPathElement() {\n+        MemoryLayouts.BITS_8_BE.byteOffset(new MemoryLayout.PathElement[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testSelectWithNullPathElement() {\n+        MemoryLayouts.BITS_8_BE.select(new MemoryLayout.PathElement[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testHandleWithNullPathElement() {\n+        MemoryLayouts.BITS_8_BE.varHandle(int.class, new MemoryLayout.PathElement[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testHandleWithNullCarrier() {\n+        MemoryLayouts.BITS_8_BE.varHandle(null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,405 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestMemoryAccessStatics\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryAccessStatics {\n+\n+    static class Accessor<X> {\n+\n+        interface SegmentGetter<X> {\n+            X get(MemorySegment segment);\n+        }\n+\n+        interface SegmentSetter<X> {\n+            void set(MemorySegment segment, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, X o);\n+        }\n+\n+        final X value;\n+        final SegmentGetter<X> segmentGetter;\n+        final SegmentSetter<X> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(X value,\n+                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            segmentSetter.set(segment, value);\n+            assertEquals(bufferGetter.get(buffer), value);\n+            bufferSetter.set(buffer, value);\n+            assertEquals(value, segmentGetter.get(segment));\n+        }\n+\n+        <Z> Accessor<Z> of(Z value,\n+                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n+                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n+            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n+        accessor.test();\n+    }\n+\n+    @Test\n+    public void testNulls() {\n+        for (Method m : MemoryAccess.class.getMethods()) {\n+            if ((m.getModifiers() & Modifier.STATIC) == 0) continue;\n+            Object[] args = new Object[m.getParameterCount()];\n+            for (int i = 0 ; i < args.length ; i++) {\n+                args[i] = defaultValue(m.getParameterTypes()[i]);\n+            }\n+            try {\n+                m.invoke(null, args);\n+                fail();\n+            } catch (InvocationTargetException ex) {\n+                assertEquals(ex.getCause().getClass(), NullPointerException.class);\n+                assertTrue(ex.getCause().getStackTrace()[1].getClassName().contains(\"MemoryAccess\"));\n+            } catch (Throwable ex) {\n+                fail();\n+            }\n+        }\n+    }\n+\n+    static Object defaultValue(Class<?> carrier) {\n+        if (carrier == char.class) {\n+            return (char)0;\n+        } else if (carrier == byte.class) {\n+            return (byte)0;\n+        } else if (carrier == short.class) {\n+            return (short)0;\n+        } else if (carrier == int.class) {\n+            return 0;\n+        } else if (carrier == long.class) {\n+            return 0L;\n+        } else if (carrier == float.class) {\n+            return 0f;\n+        } else if (carrier == double.class) {\n+            return 0d;\n+        } else {\n+            \/\/ reference type!\n+            return null;\n+        }\n+    }\n+\n+    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n+    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"accessors\")\n+    static Object[][] accessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", new Accessor<>((byte) 42,\n+                        MemoryAccess::getByte, MemoryAccess::setByte,\n+                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n+                },\n+                {\"char\", new Accessor<>((char) 42,\n+                        MemoryAccess::getChar, MemoryAccess::setChar,\n+                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n+                },\n+                {\"char\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n+                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n+                },\n+                {\"char\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n+                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n+                },\n+                {\"short\", new Accessor<>((short) 42,\n+                        MemoryAccess::getShort, MemoryAccess::setShort,\n+                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n+                },\n+                {\"short\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n+                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n+                },\n+                {\"short\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n+                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n+                },\n+                {\"int\", new Accessor<>(42,\n+                        MemoryAccess::getInt, MemoryAccess::setInt,\n+                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n+                },\n+                {\"int\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n+                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n+                },\n+                {\"int\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n+                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n+                },\n+                \/\/ float, no offset\n+                {\"float\", new Accessor<>(42f,\n+                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n+                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n+                },\n+                {\"float\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n+                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n+                },\n+                {\"float\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n+                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n+                },\n+                \/\/ double, no offset\n+                {\"double\", new Accessor<>(42d,\n+                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n+                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n+                },\n+                {\"double\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n+                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n+                },\n+                {\"double\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n+                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n+                },\n+\n+\n+                \/\/ byte, offset\n+                {\"byte\/offset\", new Accessor<>((byte) 42,\n+                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n+                        (bb) -> bb.get(4), (bb, v) -> bb.put(4, v))\n+                },\n+                \/\/ char, offset\n+                {\"char\/offset\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getChar(4), (bb, v) -> bb.order(NE).putChar(4, v))\n+                },\n+                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getChar(4), (bb, v) -> bb.order(LE).putChar(4, v))\n+                },\n+                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getChar(4), (bb, v) -> bb.order(BE).putChar(4, v))\n+                },\n+                \/\/ short, offset\n+                {\"short\/offset\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getShort(4), (bb, v) -> bb.order(NE).putShort(4, v))\n+                },\n+                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getShort(4), (bb, v) -> bb.order(LE).putShort(4, v))\n+                },\n+                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getShort(4), (bb, v) -> bb.order(BE).putShort(4, v))\n+                },\n+                \/\/ int, offset\n+                {\"int\/offset\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getInt(4), (bb, v) -> bb.order(NE).putInt(4, v))\n+                },\n+                {\"int\/offset\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getInt(4), (bb, v) -> bb.order(LE).putInt(4, v))\n+                },\n+                {\"int\/offset\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getInt(4), (bb, v) -> bb.order(BE).putInt(4, v))\n+                },\n+                \/\/ float, offset\n+                {\"float\/offset\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getFloat(4), (bb, v) -> bb.order(NE).putFloat(4, v))\n+                },\n+                {\"float\/offset\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getFloat(4), (bb, v) -> bb.order(LE).putFloat(4, v))\n+                },\n+                {\"float\/offset\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getFloat(4), (bb, v) -> bb.order(BE).putFloat(4, v))\n+                },\n+                \/\/ double, offset\n+                {\"double\/offset\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getDouble(4), (bb, v) -> bb.order(NE).putDouble(4, v))\n+                },\n+                {\"double\/offset\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getDouble(4), (bb, v) -> bb.order(LE).putDouble(4, v))\n+                },\n+                {\"double\/offset\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getDouble(4), (bb, v) -> bb.order(BE).putDouble(4, v))\n+                },\n+\n+\n+                \/\/ char, index\n+                {\"char\/index\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n+                },\n+                {\"char\/index\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n+                },\n+                {\"char\/index\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n+                },\n+                \/\/ short, index\n+                {\"short\/index\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n+                },\n+                {\"short\/index\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n+                },\n+                {\"short\/index\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n+                },\n+                {\"int\/index\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n+                },\n+                {\"int\/index\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n+                },\n+                {\"int\/index\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n+                },\n+                {\"float\/index\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n+                },\n+                {\"float\/index\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n+                },\n+                {\"float\/index\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n+                },\n+                {\"double\/index\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n+                },\n+                {\"double\/index\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n+                },\n+                {\"double\/index\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n+                },\n+\n+                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(0) : nb.getInt(0);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(0, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(0, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(4) : nb.getInt(4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(4, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.asLongBuffer().put(2, v.toRawLongValue());\n+                            } else {\n+                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"@@ -64,0 +64,6 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNull() {\n+        var segment = MemorySegment.ofArray(new byte[4]);\n+        segment.copyFrom(null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MappedMemorySegments;\n@@ -35,0 +36,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -41,0 +44,2 @@\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n@@ -275,0 +280,53 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullAllocateNative() {\n+        MemorySegment.allocateNative(null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullAllocateBuffer() {\n+        MemorySegment.ofByteBuffer(null);\n+    }\n+\n+    @Test\n+    public void testNullAllocateArray() {\n+        for (Method m : MemorySegment.class.getMethods()) {\n+            if (((m.getModifiers() & Modifier.STATIC) == 0) ||\n+                    !m.getName().startsWith(\"ofArray\")) continue;\n+            try {\n+                m.invoke(null, new Object[] { null });\n+                fail();\n+            } catch (InvocationTargetException ex) {\n+                assertEquals(ex.getCause().getClass(), NullPointerException.class);\n+            } catch (Throwable ex) {\n+                fail();\n+            }\n+        }\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testMapNullPath() throws IOException {\n+        MemorySegment.mapFile(null, 0, 10, FileChannel.MapMode.PRIVATE);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testMapNullMapMode() throws IOException  {\n+        File f = File.createTempFile(\"hello\", \"txt\");\n+        f.deleteOnExit();\n+        MemorySegment.mapFile(f.toPath(), 0, 10, null);\n+    }\n+\n+    @Test\n+    public void testMappedSegmentsOpsNullArgs() {\n+        for (Method m : MappedMemorySegments.class.getMethods()) {\n+            if ((m.getModifiers() & Modifier.STATIC) == 0) continue;\n+            try {\n+                m.invoke(null, new Object[] { null });\n+                fail();\n+            } catch (InvocationTargetException ex) {\n+                assertEquals(ex.getCause().getClass(), NullPointerException.class);\n+            } catch (Throwable ex) {\n+                fail();\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -231,0 +231,5 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullSpliteratoorLayout() {\n+        MemorySegment.ofArray(new byte[10]).spliterator(null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -124,0 +124,20 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testVarHandleNullCarrierNoAlign() {\n+        MemoryHandles.varHandle(null, ByteOrder.nativeOrder());\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testVarHandleNullCarrierAlign() {\n+        MemoryHandles.varHandle(null, 8, ByteOrder.nativeOrder());\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testVarHandleNullOrderNoAlign() {\n+        MemoryHandles.varHandle(int.class, null);\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testVarHandleNullOrderAlign() {\n+        MemoryHandles.varHandle(int.class, 8, null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}