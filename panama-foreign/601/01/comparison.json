{"files":[{"patch":"@@ -44,0 +44,2 @@\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64CallArranger;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64CallArranger;\n@@ -58,0 +60,4 @@\n+ *\n+ * There are minor differences between the ABIs implemented on Linux, macOS, and Windows\n+ * which are handled in sub-classes. Clients should access these through the provided\n+ * public constants CallArranger.LINUX and CallArranger.MACOS.\n@@ -59,1 +65,1 @@\n-public class CallArranger {\n+public abstract class CallArranger {\n@@ -99,1 +105,14 @@\n-    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n+    public static final CallArranger LINUX = new LinuxAArch64CallArranger();\n+    public static final CallArranger MACOS = new MacOsAArch64CallArranger();\n+\n+    \/**\n+     * Are variadic arguments assigned to registers as in the standard calling\n+     * convention, or always passed on the stack?\n+     *\n+     * @returns true if variadic arguments should be spilled to the stack.\n+     *\/\n+    protected abstract boolean varArgsOnStack();\n+\n+    protected CallArranger() {}\n+\n+    public Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n@@ -118,1 +137,1 @@\n-            if (SharedUtils.isVarargsIndex(cDesc, i)) {\n+            if (varArgsOnStack() && SharedUtils.isVarargsIndex(cDesc, i)) {\n@@ -129,1 +148,1 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n+    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -141,1 +160,1 @@\n-    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.linux;\n+\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for Linux ABI.\n+ *\/\n+public class LinuxAArch64CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        \/\/ Variadic arguments are passed as normal arguments\n+        return false;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n+        MethodHandle handle = CallArranger.LINUX.arrangeDowncall(type, function);\n@@ -82,1 +82,1 @@\n-        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n+        return CallArranger.LINUX.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-                        MemorySegment.copy(gpRegsArea, currentFPOffset(), value, offset, copy);\n+                        MemorySegment.copy(fpRegsArea, currentFPOffset(), value, offset, copy);\n@@ -460,1 +460,1 @@\n-                            MemorySegment.copy(valueSegment, offset, gpRegs, currentFPOffset, copy);\n+                            MemorySegment.copy(valueSegment, offset, fpRegs, currentFPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for macOS ABI.\n+ *\/\n+public class MacOsAArch64CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        \/\/ Variadic arguments are always passed on the stack\n+        return true;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n+        MethodHandle handle = CallArranger.MACOS.arrangeDowncall(type, function);\n@@ -81,1 +81,1 @@\n-        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n+        return CallArranger.MACOS.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -81,1 +81,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -106,1 +106,1 @@\n-      MethodType mt = MethodType.methodType(void.class,\n+        MethodType mt = MethodType.methodType(void.class,\n@@ -110,1 +110,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -131,1 +131,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -190,1 +190,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -220,1 +220,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -243,1 +243,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -269,1 +269,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -305,1 +305,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -358,1 +358,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -380,0 +380,42 @@\n+\n+    @Test\n+    public void testVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"}]}