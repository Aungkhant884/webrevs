{"files":[{"patch":"@@ -99,1 +99,1 @@\n-    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, boolean varArgsOnStack) {\n@@ -119,1 +119,1 @@\n-                argCalc.storageCalculator.adjustForVarArgs();\n+                argCalc.storageCalculator.adjustForVarArgs(varArgsOnStack);\n@@ -129,2 +129,2 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, boolean varArgsOnStack) {\n+        Bindings bindings = getBindings(mt, cDesc, false, varArgsOnStack);\n@@ -141,2 +141,2 @@\n-    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope, boolean varArgsOnStack) {\n+        Bindings bindings = getBindings(mt, cDesc, true, varArgsOnStack);\n@@ -213,5 +213,7 @@\n-        void adjustForVarArgs() {\n-            \/\/ This system passes all variadic parameters on the stack. Ensure\n-            \/\/ no further arguments are allocated to registers.\n-            nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n-            nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n+        void adjustForVarArgs(boolean varArgsOnStack) {\n+            if (varArgsOnStack) {\n+                \/\/ This system passes all variadic parameters on the stack. Ensure\n+                \/\/ no further arguments are allocated to registers.\n+                nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+                nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n+            }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+    static final boolean varArgsOnStack = false;\n+\n@@ -64,1 +66,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function, varArgsOnStack);\n@@ -82,1 +84,1 @@\n-        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope, varArgsOnStack);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-                        MemorySegment.copy(gpRegsArea, currentFPOffset(), value, offset, copy);\n+                        MemorySegment.copy(fpRegsArea, currentFPOffset(), value, offset, copy);\n@@ -460,1 +460,1 @@\n-                            MemorySegment.copy(valueSegment, offset, gpRegs, currentFPOffset, copy);\n+                            MemorySegment.copy(valueSegment, offset, fpRegs, currentFPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+    static final boolean varArgsOnStack = true;\n+\n@@ -64,1 +66,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function, varArgsOnStack);\n@@ -81,1 +83,1 @@\n-        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope, varArgsOnStack);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -81,1 +81,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -106,1 +106,1 @@\n-      MethodType mt = MethodType.methodType(void.class,\n+        MethodType mt = MethodType.methodType(void.class,\n@@ -110,1 +110,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -131,1 +131,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -190,1 +190,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -220,1 +220,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -243,1 +243,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -269,1 +269,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -305,1 +305,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -358,1 +358,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, false);\n@@ -380,0 +380,44 @@\n+\n+    @Test\n+    public void testVarArgsInRegs() {\n+        final boolean varArgsOnStack = false;   \/\/ Linux ABI\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, varArgsOnStack);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsOnStack() {\n+        final boolean varArgsOnStack = true;   \/\/ Mac\/Windows ABI\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, varArgsOnStack);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":56,"deletions":12,"binary":false,"changes":68,"status":"modified"}]}