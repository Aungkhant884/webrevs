{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -52,0 +54,1 @@\n+        emitFunctionaRestrictedFactory();\n@@ -94,0 +97,56 @@\n+\n+    private void emitFunctionaRestrictedFactory() {\n+        emitWithConstantClass(className(), constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(), FunctionInfo.ofFunctionPointer(fiType, fiDesc), true);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" \" + className() + \" ofAddressRestricted(MemoryAddress addr) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return new \" + className() + \"() {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"public \" + fiType.returnType().getName() + \" apply(\");\n+            String delim = \"\";\n+            for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+                append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+                delim = \", \";\n+            }\n+            append(\") {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"try {\\n\");\n+            incrAlign();\n+            indent();\n+            if (!fiType.returnType().equals(void.class)) {\n+                append(\"return (\" + fiType.returnType().getName() + \")\");\n+            }\n+            append(mhConstant.accessExpression() + \".invokeExact((Addressable)addr\");\n+            if (fiType.parameterCount() > 0) {\n+                String params = IntStream.range(0, fiType.parameterCount())\n+                        .mapToObj(i -> \"x\" + i)\n+                        .collect(Collectors.joining(\", \"));\n+                append(\", \" + params);\n+            }\n+            append(\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"} catch (Throwable ex$) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"};\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -79,5 +79,2 @@\n-                if (varInfo.functionInfo().isPresent()) {\n-                    FunctionInfo functionInfo = varInfo.functionInfo().get();\n-                    Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, true)\n-                            .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-                    emitVirtualFunctionWrapper(mhConstant, javaName, functionInfo.methodType());\n+                if (varInfo.fiName().isPresent()) {\n+                    emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n@@ -189,1 +186,1 @@\n-    private void emitVirtualFunctionWrapper(Constant mhConstant, String javaName, MethodType mtype) {\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n@@ -193,19 +190,1 @@\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n-        String delim = \"\";\n-        List<String> pExprs = new ArrayList<>();\n-        int numParams = mtype.parameterCount();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = \"x\" + i;\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n-            Class<?> pType = mtype.parameterType(i);\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n-            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n-            delim = \", \";\n-        }\n-        append(\") {\\n\");\n+        append(fiName + \" \" + javaName + \" () {\\n\");\n@@ -214,23 +193,1 @@\n-        append(\"var mh$ = \");\n-        append(mhConstant.accessExpression());\n-        append(\";\\n\");\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n-        }\n-        append(\"mh$.invokeExact(\");\n-        append(\"(Addressable)\");\n-        append(javaName + \"$get(), \");\n-        append(String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n+        append(\"return \" + fiName + \".ofAddressRestricted(\" + javaName + \"$get());\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":5,"deletions":48,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-            Optional<FunctionInfo> functionInfo) {\n+            Optional<String> fiName) {\n@@ -148,2 +148,2 @@\n-        static VarInfo ofFunctionPointerVar(Class<?> carrier, MemoryLayout layout, FunctionInfo functionInfo) {\n-            return new VarInfo(carrier, layout, Optional.of(functionInfo));\n+        static VarInfo ofFunctionalPointerVar(Class<?> carrier, MemoryLayout layout, String fiName) {\n+            return new VarInfo(carrier, layout, Optional.ofNullable(fiName));\n@@ -173,1 +173,1 @@\n-    public void addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n@@ -178,0 +178,1 @@\n+        return builder.fullName();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-    private boolean generateFunctionalInterface(Type.Function func, String name) {\n+    private String generateFunctionalInterface(Type.Function func, String name) {\n@@ -238,2 +238,2 @@\n-                .map(fInfo -> { currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo); return true; })\n-                .orElse(false);\n+                .map(fInfo -> currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo))\n+                .orElse(null);\n@@ -265,1 +265,1 @@\n-                    if (!generateFunctionalInterface(f, name)) {\n+                    if (generateFunctionalInterface(f, name) == null) {\n@@ -278,2 +278,8 @@\n-    Type.Function getAsFunctionPointer(Type type) {\n-        return getAsFunctionPointer(type, false);\n+    Optional<String> getAsFunctionPointerTypedef(Type type) {\n+        if (type instanceof Type.Delegated delegated &&\n+                delegated.kind() == Type.Delegated.Kind.TYPEDEF &&\n+                getAsFunctionPointer(delegated.type()) != null) {\n+            return delegated.name();\n+        } else {\n+            return Optional.empty();\n+        }\n@@ -282,1 +288,1 @@\n-    Type.Function getAsFunctionPointer(Type type, boolean followTypedefs) {\n+    Type.Function getAsFunctionPointer(Type type) {\n@@ -284,3 +290,3 @@\n-            Type.Delegated delegated = (Type.Delegated)type;\n-            return (followTypedefs || delegated.kind() == Type.Delegated.Kind.POINTER) ?\n-                getAsFunctionPointer(delegated.type(), followTypedefs) : null;\n+            Type.Delegated delegated = (Type.Delegated) type;\n+            return (delegated.kind() == Type.Delegated.Kind.POINTER) ?\n+                    getAsFunctionPointer(delegated.type()) : null;\n@@ -294,1 +300,1 @@\n-            return (Type.Function)type;\n+            return (Type.Function) type;\n@@ -380,5 +386,0 @@\n-        Type.Function func = getAsFunctionPointer(type);\n-        if (func != null) {\n-            generateFunctionalInterface(func, fieldName);\n-        }\n-\n@@ -392,0 +393,17 @@\n+\n+\n+        VarInfo varInfo = VarInfo.ofVar(clazz, layout);\n+        Type.Function func = getAsFunctionPointer(type);\n+        String fiName;\n+        if (func != null) {\n+            fiName = generateFunctionalInterface(func, fieldName);\n+            if (fiName != null) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, fiName);\n+            }\n+        } else {\n+            Optional<String> funcTypedef = getAsFunctionPointerTypedef(type);\n+            if (funcTypedef.isPresent()) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, funcTypedef.get());\n+            }\n+        }\n+\n@@ -405,1 +423,0 @@\n-        MemoryLayout treeLayout = tree.layout().orElseThrow();\n@@ -407,7 +424,0 @@\n-            VarInfo varInfo = VarInfo.ofVar(clazz, treeLayout);\n-            Type.Function funcPtr = getAsFunctionPointer(tree.type(), true);\n-            if (funcPtr != null) {\n-                varInfo = functionInfo(funcPtr, tree.name(), false, FunctionInfo::ofFunctionPointer)\n-                        .map(fInfo -> VarInfo.ofFunctionPointerVar(clazz, treeLayout, fInfo))\n-                        .orElse(varInfo);\n-            }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":34,"deletions":24,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -148,5 +148,2 @@\n-            if (varInfo.functionInfo().isPresent()) {\n-                FunctionInfo functionInfo = varInfo.functionInfo().get();\n-                Constant mhConstant = addMethodHandle(javaName, nativeName, functionInfo, true)\n-                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-                emitVirtualFunctionWrapper(mhConstant, javaName, functionInfo.methodType());\n+            if (varInfo.fiName().isPresent()) {\n+                emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n@@ -157,1 +154,1 @@\n-    private void emitVirtualFunctionWrapper(Constant mhConstant, String javaName, MethodType mtype) {\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n@@ -161,36 +158,1 @@\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (MemorySegment segment\");\n-        List<String> pExprs = new ArrayList<>();\n-        int numParams = mtype.parameterCount();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = \"x\" + i;\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n-            Class<?> pType = mtype.parameterType(i);\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n-            append(\", \" + pType.getSimpleName() + \" \" + pName);\n-        }\n-        append(\") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"var mh$ = \");\n-        append(mhConstant.accessExpression());\n-        append(\";\\n\");\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n-        }\n-        append(\"mh$.invokeExact(\");\n-        append(\"(Addressable)\");\n-        append(javaName + \"$get(segment), \");\n-        append(String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n+        append(fiName + \" \" + javaName + \" (MemorySegment segment) {\\n\");\n@@ -199,4 +161,1 @@\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n+        append(\"return \" + fiName + \".ofAddressRestricted(\" + javaName + \"$get(segment));\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":5,"deletions":46,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -107,2 +107,2 @@\n-    public void addFunctionalInterface(String name, FunctionInfo functionInfo) {\n-        nextHeader().addFunctionalInterface(name, functionInfo);\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        return nextHeader().addFunctionalInterface(name, functionInfo);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,12 @@\n-            Bar.foo(bar, 42);\n+            Bar.foo(bar).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFI() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddressRestricted(Bar.foo$get(bar)).apply(42);\n@@ -64,1 +75,11 @@\n-            f(42);\n+            f().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFI() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddressRestricted(f$get()).apply(42);\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"}]}