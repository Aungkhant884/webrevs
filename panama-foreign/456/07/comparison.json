{"files":[{"patch":"@@ -69,3 +69,3 @@\n-    public Constant addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout,\n-                                    Class<?> type, String rootJavaName, List<String> prefixElementNames) {\n-        return addVarHandle(javaName, nativeName, layout, type, rootJavaName, prefixElementNames);\n+    public Constant addFieldVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootJavaName, List<String> prefixElementNames) {\n+        return addVarHandle(javaName, nativeName, varInfo, rootJavaName, prefixElementNames);\n@@ -74,2 +74,2 @@\n-    public Constant addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        return addVarHandle(javaName, nativeName, layout, type, null, List.of());\n+    public Constant addGlobalVarHandle(String javaName, String nativeName, VarInfo varInfo) {\n+        return addVarHandle(javaName, nativeName, varInfo, null, List.of());\n@@ -78,1 +78,1 @@\n-    private Constant addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type,\n+    private Constant addVarHandle(String javaName, String nativeName, VarInfo varInfo,\n@@ -81,1 +81,1 @@\n-                () -> emitVarHandleField(javaName, nativeName, type, layout, rootLayoutName, prefixElementNames));\n+                () -> emitVarHandleField(javaName, nativeName, varInfo, rootLayoutName, prefixElementNames));\n@@ -84,1 +84,1 @@\n-    public Constant addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n+    public Constant addMethodHandle(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n@@ -86,1 +86,1 @@\n-                () -> emitMethodHandleField(javaName, nativeName, mtype, desc, varargs));\n+                () -> emitMethodHandleField(javaName, nativeName, functionInfo, virtual));\n@@ -144,1 +144,1 @@\n-        private List<String> getterNameParts() {\n+        List<String> getterNameParts() {\n@@ -188,3 +188,2 @@\n-    private Constant emitMethodHandleField(String javaName, String nativeName, MethodType mtype,\n-                                         FunctionDescriptor desc, boolean varargs) {\n-        Constant functionDesc = addFunctionDesc(javaName, desc);\n+    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        Constant functionDesc = addFunctionDesc(javaName, functionInfo.descriptor());\n@@ -198,4 +197,6 @@\n-        append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n-        append(\",\\n\");\n-        indent();\n-        append(\"\\\"\" + mtype.toMethodDescriptorString() + \"\\\",\\n\");\n+        if (!virtual) {\n+            append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+            append(\",\\n\");\n+            indent();\n+        }\n+        append(\"\\\"\" + functionInfo.methodType().toMethodDescriptorString() + \"\\\",\\n\");\n@@ -206,1 +207,1 @@\n-        append(varargs);\n+        append(functionInfo.isVarargs());\n@@ -215,1 +216,1 @@\n-    private Constant emitVarHandleField(String javaName, String nativeName, Class<?> type, MemoryLayout layout,\n+    private Constant emitVarHandleField(String javaName, String nativeName, VarInfo varInfo,\n@@ -219,1 +220,1 @@\n-                addLayout(javaName, layout).accessExpression();\n+                addLayout(javaName, varInfo.layout()).accessExpression();\n@@ -221,1 +222,1 @@\n-        String typeName = type.getName();\n+        String typeName = varInfo.carrier().getName();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n@@ -52,0 +54,1 @@\n+        emitFunctionalRestrictedFactory();\n@@ -94,0 +97,56 @@\n+\n+    private void emitFunctionalRestrictedFactory() {\n+        emitWithConstantClass(className(), constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(), FunctionInfo.ofFunctionPointer(fiType, fiDesc), true);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" \" + className() + \" ofAddressRestricted(MemoryAddress addr) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return new \" + className() + \"() {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"public \" + fiType.returnType().getName() + \" apply(\");\n+            String delim = \"\";\n+            for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+                append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+                delim = \", \";\n+            }\n+            append(\") {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"try {\\n\");\n+            incrAlign();\n+            indent();\n+            if (!fiType.returnType().equals(void.class)) {\n+                append(\"return (\" + fiType.returnType().getName() + \")\");\n+            }\n+            append(mhConstant.accessExpression() + \".invokeExact((Addressable)addr\");\n+            if (fiType.parameterCount() > 0) {\n+                String params = IntStream.range(0, fiType.parameterCount())\n+                        .mapToObj(i -> \"x\" + i)\n+                        .collect(Collectors.joining(\", \"));\n+                append(\", \" + params);\n+            }\n+            append(\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"} catch (Throwable ex$) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"};\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        if (type.equals(MemorySegment.class)) {\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n@@ -66,1 +66,1 @@\n-                constantBuilder.addSegment(javaName, nativeName, layout)\n+                constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n@@ -71,1 +71,1 @@\n-                constantBuilder.addLayout(javaName, layout)\n+                constantBuilder.addLayout(javaName, varInfo.layout())\n@@ -73,1 +73,1 @@\n-                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, layout, type)\n+                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, varInfo)\n@@ -75,1 +75,1 @@\n-                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, layout)\n+                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n@@ -77,2 +77,5 @@\n-                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, type);\n-                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, type);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                if (varInfo.fiName().isPresent()) {\n+                    emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+                }\n@@ -84,1 +87,1 @@\n-    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n@@ -86,1 +89,1 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, varargs)\n+            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, false)\n@@ -88,1 +91,1 @@\n-            emitFunctionWrapper(mhConstant, javaName, nativeName, mtype, varargs, paramNames);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, functionInfo);\n@@ -118,2 +121,1 @@\n-    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType mtype,\n-                                  boolean varargs, List<String> paramNames) {\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, FunctionInfo functionInfo) {\n@@ -123,1 +125,1 @@\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        append(functionInfo.methodType().returnType().getSimpleName() + \" \" + javaName + \" (\");\n@@ -126,0 +128,1 @@\n+        List<String> paramNames = functionInfo.parameterNames().get();\n@@ -132,1 +135,1 @@\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n+            if (functionInfo.methodType().parameterType(i).equals(MemoryAddress.class)) {\n@@ -137,1 +140,1 @@\n-            Class<?> pType = mtype.parameterType(i);\n+            Class<?> pType = functionInfo.methodType().parameterType(i);\n@@ -144,1 +147,1 @@\n-        if (varargs) {\n+        if (functionInfo.isVarargs()) {\n@@ -164,2 +167,2 @@\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n@@ -183,0 +186,14 @@\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" () {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddressRestricted(\" + javaName + \"$get());\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Optional;\n@@ -123,1 +124,30 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+    public static record FunctionInfo(\n+            MethodType methodType,\n+            FunctionDescriptor descriptor,\n+            boolean isVarargs,\n+            Optional<List<String>> parameterNames) {\n+\n+        static FunctionInfo ofFunction(MethodType methodType, FunctionDescriptor functionDescriptor, boolean isVarargs, List<String> parameterNames) {\n+            return new FunctionInfo(methodType, functionDescriptor, isVarargs, Optional.of(parameterNames));\n+        }\n+\n+        static FunctionInfo ofFunctionPointer(MethodType methodType, FunctionDescriptor functionDescriptor) {\n+            return new FunctionInfo(methodType, functionDescriptor, false, Optional.empty());\n+        }\n+    }\n+\n+    public static record VarInfo(\n+            Class<?> carrier,\n+            MemoryLayout layout,\n+            Optional<String> fiName) {\n+\n+        static VarInfo ofVar(Class<?> carrier, MemoryLayout layout) {\n+            return new VarInfo(carrier, layout, Optional.empty());\n+        }\n+\n+        static VarInfo ofFunctionalPointerVar(Class<?> carrier, MemoryLayout layout, String fiName) {\n+            return new VarInfo(carrier, layout, Optional.ofNullable(fiName));\n+        }\n+    }\n+\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n@@ -127,1 +157,1 @@\n-    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n@@ -143,2 +173,3 @@\n-    public void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, mtype, desc);\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name,\n+                functionInfo.methodType(), functionInfo.descriptor());\n@@ -147,0 +178,1 @@\n+        return builder.fullName();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import jdk.internal.jextract.impl.JavaSourceBuilder.VarInfo;\n+import jdk.internal.jextract.impl.JavaSourceBuilder.FunctionInfo;\n+\n@@ -47,0 +50,1 @@\n+import java.util.Optional;\n@@ -48,0 +52,1 @@\n+import java.util.function.BiFunction;\n@@ -69,0 +74,1 @@\n+    private final Map<Type, String> functionTypeDefNames = new HashMap<>();\n@@ -82,0 +88,12 @@\n+    private void addFunctionTypedef(Type.Delegated typedef, String name) {\n+        functionTypeDefNames.put(typedef, name);\n+    }\n+\n+    private boolean functionTypedefSeen(Type.Delegated typedef) {\n+        return functionTypeDefNames.containsKey(typedef);\n+    }\n+\n+    private String functionTypedefName(Type.Delegated decl) {\n+        return functionTypeDefNames.get(decl);\n+    }\n+\n@@ -161,1 +179,1 @@\n-                clazz, constant.value());\n+                typeTranslator.getJavaType(constant.type()), constant.value());\n@@ -194,16 +212,0 @@\n-    private static boolean isVaList(FunctionDescriptor desc) {\n-        List<MemoryLayout> argLayouts = desc.argumentLayouts();\n-        int size = argLayouts.size();\n-        if (size > 0) {\n-            MemoryLayout lastLayout = argLayouts.get(size - 1);\n-            if (lastLayout instanceof SequenceLayout) {\n-                SequenceLayout seq = (SequenceLayout)lastLayout;\n-                MemoryLayout elem = seq.elementLayout();\n-                \/\/ FIXME: hack for now to use internal symbol used by clang for va_list\n-                return elem.name().orElse(\"\").equals(VA_LIST_TAG);\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n@@ -247,22 +249,4 @@\n-    private boolean generateFunctionalInterface(Type.Function func, String name) {\n-        name = Utils.javaSafeIdentifier(name);\n-        \/\/generate functional interface\n-        if (func.varargs()) {\n-            warn(\"varargs in callbacks is not supported: \" + name);\n-        }\n-        MethodType fitype = getMethodType(func, false);\n-        if (fitype == null) {\n-            warn(\"skipping \" + name + \" because of unsupported type usage\");\n-            return false;\n-        }\n-\n-        FunctionDescriptor fpDesc = Type.descriptorFor(func).orElseThrow();\n-        MemoryLayout unsupportedLayout = isUnsupported(fpDesc);\n-        if (unsupportedLayout != null) {\n-            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n-                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n-            return false;\n-        }\n-\n-        currentBuilder.addFunctionalInterface(name, fitype, fpDesc);\n-        return true;\n+    private String generateFunctionalInterface(Type.Function func, String name) {\n+        return functionInfo(func, name, false, FunctionInfo::ofFunctionPointer)\n+                .map(fInfo -> currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo))\n+                .orElse(null);\n@@ -277,30 +261,0 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n-        if (descriptor == null) {\n-            \/\/abort\n-            return null;\n-        }\n-\n-        MemoryLayout unsupportedLayout = isUnsupported(descriptor);\n-        if (unsupportedLayout != null) {\n-            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage: \" +\n-                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n-            return null;\n-        }\n-\n-        MethodType mtype = getMethodType(funcTree.type());\n-        if (mtype == null) {\n-            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage\");\n-            return null;\n-        }\n-\n-        if (isVaList(descriptor)) {\n-            MemoryLayout[] argLayouts = descriptor.argumentLayouts().toArray(new MemoryLayout[0]);\n-            argLayouts[argLayouts.length - 1] = CLinker.C_VA_LIST;\n-            descriptor = descriptor.returnLayout().isEmpty()?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(descriptor.returnLayout().get(), argLayouts);\n-            Class<?>[] argTypes = mtype.parameterArray();\n-            argTypes[argLayouts.length - 1] = MemoryAddress.class;\n-            mtype = MethodType.methodType(mtype.returnType(), argTypes);\n-        }\n-\n@@ -314,7 +268,14 @@\n-        int i = 0;\n-        for (Declaration.Variable param : funcTree.parameters()) {\n-            Type.Function f = getAsFunctionPointer(param.type());\n-            if (f != null) {\n-                String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n-                if (! generateFunctionalInterface(f, name)) {\n-                    return null;\n+\n+        Optional<FunctionInfo> functionInfo = functionInfo(funcTree.type(), funcTree.name(), true,\n+                (mtype, desc) -> FunctionInfo.ofFunction(mtype, desc, funcTree.type().varargs(), paramNames));\n+\n+        if (functionInfo.isPresent()) {\n+            int i = 0;\n+            for (Declaration.Variable param : funcTree.parameters()) {\n+                Type.Function f = getAsFunctionPointer(param.type());\n+                if (f != null) {\n+                    String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                    if (generateFunctionalInterface(f, name) == null) {\n+                        return null;\n+                    }\n+                    i++;\n@@ -322,1 +283,0 @@\n-                i++;\n@@ -324,1 +284,0 @@\n-        }\n@@ -326,2 +285,2 @@\n-        toplevelBuilder.addFunction(mhName, funcTree.name(), mtype,\n-                descriptor, funcTree.type().varargs(), paramNames);\n+            toplevelBuilder.addFunction(mhName, funcTree.name(), functionInfo.get());\n+        }\n@@ -332,0 +291,10 @@\n+    Optional<String> getAsFunctionPointerTypedef(Type type) {\n+        if (type instanceof Type.Delegated delegated &&\n+                delegated.kind() == Type.Delegated.Kind.TYPEDEF &&\n+                functionTypedefSeen(delegated)) {\n+            return Optional.of(functionTypedefName(delegated));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n@@ -334,3 +303,3 @@\n-            Type.Delegated delegated = (Type.Delegated)type;\n-            return delegated.kind() == Type.Delegated.Kind.POINTER ?\n-                getAsFunctionPointer(delegated.type()) : null;\n+            Type.Delegated delegated = (Type.Delegated) type;\n+            return (delegated.kind() == Type.Delegated.Kind.POINTER) ?\n+                    getAsFunctionPointer(delegated.type()) : null;\n@@ -344,1 +313,1 @@\n-            return (Type.Function)type;\n+            return (Type.Function) type;\n@@ -391,1 +360,4 @@\n-                generateFunctionalInterface(func, tree.name());\n+                String funcIntfName = generateFunctionalInterface(func, tree.name());\n+                if (funcIntfName != null) {\n+                    addFunctionTypedef(Type.typedef(tree.name(), tree.type()), funcIntfName);\n+                }\n@@ -430,0 +402,10 @@\n+        Class<?> clazz = getJavaType(type);\n+        if (clazz == null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage\");\n+            return null;\n+        }\n+\n+\n+        VarInfo varInfo = VarInfo.ofVar(clazz, layout);\n@@ -431,0 +413,1 @@\n+        String fiName;\n@@ -432,1 +415,9 @@\n-            generateFunctionalInterface(func, fieldName);\n+            fiName = generateFunctionalInterface(func, fieldName);\n+            if (fiName != null) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, fiName);\n+            }\n+        } else {\n+            Optional<String> funcTypedef = getAsFunctionPointerTypedef(type);\n+            if (funcTypedef.isPresent()) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, Utils.javaSafeIdentifier(funcTypedef.get()));\n+            }\n@@ -448,1 +439,0 @@\n-        MemoryLayout treeLayout = tree.layout().orElseThrow();\n@@ -450,8 +440,1 @@\n-            Class<?> clazz = getJavaType(type);\n-            if (clazz == null) {\n-                String name = parent != null? parent.name() + \".\" : \"\";\n-                name += fieldName;\n-                warn(\"skipping \" + name + \" because of unsupported type usage\");\n-                return null;\n-            }\n-            currentBuilder.addVar(fieldName, tree.name(), treeLayout, clazz);\n+            currentBuilder.addVar(fieldName, tree.name(), varInfo);\n@@ -465,0 +448,27 @@\n+    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean allowVarargs,\n+                                                BiFunction<MethodType, FunctionDescriptor, FunctionInfo> functionInfoFactory) {\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcPtr).orElse(null);\n+        if (descriptor == null) {\n+            \/\/abort\n+            return Optional.empty();\n+        }\n+\n+        \/\/generate functional interface\n+        if (!allowVarargs && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n+            warn(\"varargs in callbacks is not supported: \" + funcPtr);\n+            return Optional.empty();\n+        }\n+\n+        MemoryLayout unsupportedLayout = isUnsupported(descriptor);\n+        if (unsupportedLayout != null) {\n+            warn(\"skipping \" + nativeName + \" because of unsupported type usage: \" +\n+                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n+            return Optional.empty();\n+        }\n+\n+        MethodType mtype = getMethodType(funcPtr, allowVarargs);\n+        return mtype != null ?\n+                Optional.of(functionInfoFactory.apply(mtype, descriptor)) :\n+                Optional.empty();\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":105,"deletions":95,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -28,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -33,0 +36,1 @@\n+import java.lang.invoke.MethodType;\n@@ -138,3 +142,3 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        if (type.equals(MemorySegment.class)) {\n-            emitSegmentGetter(javaName, nativeName, layout);\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitSegmentGetter(javaName, nativeName, varInfo.layout());\n@@ -142,1 +146,1 @@\n-            Constant vhConstant = addFieldVarHandle(javaName, nativeName, layout, type, layoutField(), prefixNamesList())\n+            Constant vhConstant = addFieldVarHandle(javaName, nativeName, varInfo, layoutField(), prefixNamesList())\n@@ -144,4 +148,7 @@\n-            emitFieldGetter(vhConstant, javaName, type);\n-            emitFieldSetter(vhConstant, javaName, type);\n-            emitIndexedFieldGetter(vhConstant, javaName, type);\n-            emitIndexedFieldSetter(vhConstant, javaName, type);\n+            emitFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            if (varInfo.fiName().isPresent()) {\n+                emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+            }\n@@ -151,0 +158,14 @@\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" (MemorySegment segment) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddressRestricted(\" + javaName + \"$get(segment));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        nextHeader().addVar(javaName, nativeName, layout, type);\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        nextHeader().addVar(javaName, nativeName, varInfo);\n@@ -87,2 +87,2 @@\n-    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n-        nextHeader().addFunction(javaName, nativeName, mtype, desc, varargs, paramNames);\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        nextHeader().addFunction(javaName, nativeName, functionInfo);\n@@ -107,2 +107,2 @@\n-    public void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc) {\n-        nextHeader().addFunctionalInterface(name, mtype, desc);\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        return nextHeader().addFunctionalInterface(name, functionInfo);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                \"--release\", \"16\",\n+                \"--release\", \"17\",\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Writer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,8 @@\n+    static final MethodHandle downcallHandle(String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+        return LINKER.downcallHandle(mt, fdesc);\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.testng.Assert.*;\n+import static test.jextract.funcpointers.func_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestFuncPointerInvokers\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestFuncPointerInvokers\n+ *\/\n+public class TestFuncPointerInvokers {\n+    @Test\n+    public void testStructFieldTypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Bar.foo(bar).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFITypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddressRestricted(Bar.foo$get(bar)).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalTypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            f().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFITypedef() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddressRestricted(f$get()).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp(baz).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFIFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp.ofAddressRestricted(Baz.fp$get(baz)).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFIFunctionPointer() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp.ofAddressRestricted(fp$get()).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void (*Foo)(int arg);\n+\n+struct Bar {\n+   Foo foo;\n+};\n+\n+EXPORT Foo f;\n+\n+struct Baz {\n+   void (*fp)(int arg);\n+};\n+\n+EXPORT void (*fp)(int arg);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/func.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"func.h\"\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/libFunc.c","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"}]}