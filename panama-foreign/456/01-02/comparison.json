{"files":[{"patch":"@@ -69,3 +69,3 @@\n-    public Constant addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout,\n-                                    Class<?> type, String rootJavaName, List<String> prefixElementNames) {\n-        return addVarHandle(javaName, nativeName, layout, type, rootJavaName, prefixElementNames);\n+    public Constant addFieldVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootJavaName, List<String> prefixElementNames) {\n+        return addVarHandle(javaName, nativeName, varInfo, rootJavaName, prefixElementNames);\n@@ -74,2 +74,2 @@\n-    public Constant addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        return addVarHandle(javaName, nativeName, layout, type, null, List.of());\n+    public Constant addGlobalVarHandle(String javaName, String nativeName, VarInfo varInfo) {\n+        return addVarHandle(javaName, nativeName, varInfo, null, List.of());\n@@ -78,1 +78,1 @@\n-    private Constant addVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type,\n+    private Constant addVarHandle(String javaName, String nativeName, VarInfo varInfo,\n@@ -81,1 +81,1 @@\n-                () -> emitVarHandleField(javaName, nativeName, type, layout, rootLayoutName, prefixElementNames));\n+                () -> emitVarHandleField(javaName, nativeName, varInfo, rootLayoutName, prefixElementNames));\n@@ -84,3 +84,3 @@\n-    public MethodHandleConstant addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean virtual, boolean varargs) {\n-        return (MethodHandleConstant)emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n-                () -> emitMethodHandleField(javaName, nativeName, mtype, desc, virtual, varargs));\n+    public Constant addMethodHandle(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitMethodHandleField(javaName, nativeName, functionInfo, virtual));\n@@ -172,48 +172,0 @@\n-    static class MethodHandleConstant extends Constant {\n-\n-        final MethodType mtype;\n-        final boolean virtual;\n-        final boolean varargs;\n-\n-\n-        MethodHandleConstant(String className, String javaName, Kind kind, MethodType mtype, boolean virtual, boolean varargs) {\n-            super(className, javaName, kind);\n-            this.mtype = mtype;\n-            this.virtual = virtual;\n-            this.varargs = varargs;\n-        }\n-\n-        @Override\n-        MethodHandleConstant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n-            return (MethodHandleConstant)super.emitGetter(builder, mods, getterNameFunc);\n-        }\n-\n-        @Override\n-        MethodHandleConstant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n-            return (MethodHandleConstant)super.emitGetter(builder, mods, getterNameFunc, symbolName);\n-        }\n-\n-        MethodHandleConstant emitFunction(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc,\n-                                          List<String> paramNames) {\n-            if (virtual) {\n-                builder.emitVirtualFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression());\n-            } else {\n-                builder.emitFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression(),\n-                        varargs, paramNames);\n-            }\n-            return this;\n-        }\n-\n-        MethodHandleConstant emitFunction(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc,\n-                                          List<String> paramNames, String symbolName) {\n-            if (virtual) {\n-                builder.emitVirtualFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression(),\n-                        true, symbolName);\n-            } else {\n-                builder.emitFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression(),\n-                        varargs, paramNames, true, symbolName);\n-            }\n-            return this;\n-        }\n-    }\n-\n@@ -236,3 +188,2 @@\n-    private MethodHandleConstant emitMethodHandleField(String javaName, String nativeName, MethodType mtype,\n-                                                                FunctionDescriptor desc, boolean virtual, boolean varargs) {\n-        Constant functionDesc = addFunctionDesc(javaName, desc);\n+    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        Constant functionDesc = addFunctionDesc(javaName, functionInfo.descriptor());\n@@ -251,1 +202,1 @@\n-        append(\"\\\"\" + mtype.toMethodDescriptorString() + \"\\\",\\n\");\n+        append(\"\\\"\" + functionInfo.methodType().toMethodDescriptorString() + \"\\\",\\n\");\n@@ -256,1 +207,1 @@\n-        append(varargs);\n+        append(functionInfo.isVarargs());\n@@ -262,1 +213,1 @@\n-        return new MethodHandleConstant(className(), javaName, Constant.Kind.METHOD_HANDLE, mtype, virtual, varargs);\n+        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n@@ -265,1 +216,1 @@\n-    private Constant emitVarHandleField(String javaName, String nativeName, Class<?> type, MemoryLayout layout,\n+    private Constant emitVarHandleField(String javaName, String nativeName, VarInfo varInfo,\n@@ -269,1 +220,1 @@\n-                addLayout(javaName, layout).accessExpression();\n+                addLayout(javaName, varInfo.layout()).accessExpression();\n@@ -271,1 +222,1 @@\n-        String typeName = type.getName();\n+        String typeName = varInfo.carrier().getName();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":18,"deletions":67,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -37,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -61,2 +63,2 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        if (type.equals(MemorySegment.class)) {\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n@@ -64,1 +66,1 @@\n-                constantBuilder.addSegment(javaName, nativeName, layout)\n+                constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n@@ -69,1 +71,1 @@\n-                constantBuilder.addLayout(javaName, layout)\n+                constantBuilder.addLayout(javaName, varInfo.layout())\n@@ -71,1 +73,1 @@\n-                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, layout, type)\n+                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, varInfo)\n@@ -73,1 +75,1 @@\n-                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, layout)\n+                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n@@ -75,2 +77,8 @@\n-                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, type);\n-                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, type);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                if (varInfo.functionInfo().isPresent()) {\n+                    FunctionInfo functionInfo = varInfo.functionInfo().get();\n+                    Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, true)\n+                            .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+                    emitVirtualFunctionWrapper(mhConstant, javaName, functionInfo.methodType());\n+                }\n@@ -82,1 +90,1 @@\n-    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n@@ -84,12 +92,3 @@\n-            constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, false, varargs)\n-                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName)\n-                    .emitFunction(this, MEMBER_MODS, Constant.JAVA_NAME, paramNames, nativeName);\n-        });\n-    }\n-\n-    @Override\n-    public void addVirtualFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc) {\n-        emitWithConstantClass(javaName, constantBuilder -> {\n-            constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, true, false)\n-                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME)\n-                    .emitFunction(this, MEMBER_MODS, Constant.JAVA_NAME, null);\n+            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, false)\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, functionInfo);\n@@ -125,0 +124,119 @@\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, FunctionInfo functionInfo) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(functionInfo.methodType().returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        List<String> paramNames = functionInfo.parameterNames().get();\n+        final int numParams = paramNames.size();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = paramNames.get(i);\n+            if (pName.isEmpty()) {\n+                pName = \"x\" + i;\n+            }\n+            if (functionInfo.methodType().parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = functionInfo.methodType().parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        if (functionInfo.isVarargs()) {\n+            String lastArg = \"x\" + numParams;\n+            if (numParams > 0) {\n+                append(\", \");\n+            }\n+            append(\"Object... \" + lastArg);\n+            pExprs.add(lastArg);\n+        }\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+        append(mhConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\");\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitVirtualFunctionWrapper(Constant mhConstant, String javaName, MethodType mtype) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        int numParams = mtype.parameterCount();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = \"x\" + i;\n+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = mtype.parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = \");\n+        append(mhConstant.accessExpression());\n+        append(\";\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!mtype.returnType().equals(void.class)) {\n+            append(\"return (\" + mtype.returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\");\n+        append(\"(Addressable)\");\n+        append(javaName + \"$get(), \");\n+        append(String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":139,"deletions":21,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -30,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -38,1 +36,0 @@\n-import java.util.ArrayList;\n@@ -41,0 +38,1 @@\n+import java.util.Optional;\n@@ -126,2 +124,27 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        throw new UnsupportedOperationException();\n+    public static record FunctionInfo(\n+            MethodType methodType,\n+            FunctionDescriptor descriptor,\n+            boolean isVarargs,\n+            Optional<List<String>> parameterNames) {\n+\n+        static FunctionInfo ofFunction(MethodType methodType, FunctionDescriptor functionDescriptor, boolean isVarargs, List<String> parameterNames) {\n+            return new FunctionInfo(methodType, functionDescriptor, isVarargs, Optional.of(parameterNames));\n+        }\n+\n+        static FunctionInfo ofFunctionPointer(MethodType methodType, FunctionDescriptor functionDescriptor) {\n+            return new FunctionInfo(methodType, functionDescriptor, false, Optional.empty());\n+        }\n+    }\n+\n+    public static record VarInfo(\n+            Class<?> carrier,\n+            MemoryLayout layout,\n+            Optional<FunctionInfo> functionInfo) {\n+\n+        static VarInfo ofVar(Class<?> carrier, MemoryLayout layout) {\n+            return new VarInfo(carrier, layout, Optional.empty());\n+        }\n+\n+        static VarInfo ofFunctionPointerVar(Class<?> carrier, MemoryLayout layout, FunctionInfo functionInfo) {\n+            return new VarInfo(carrier, layout, Optional.of(functionInfo));\n+        }\n@@ -130,1 +153,1 @@\n-    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n@@ -134,1 +157,1 @@\n-    public void addVirtualFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc) {\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n@@ -150,2 +173,3 @@\n-    public void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, mtype, desc);\n+    public void addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name,\n+                functionInfo.methodType(), functionInfo.descriptor());\n@@ -266,141 +290,0 @@\n-    protected void emitFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n-                                     boolean varargs, List<String> paramNames, boolean nullCheck, String symbolName) {\n-        incrAlign();\n-        indent();\n-        append(mods + \" \");\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n-        String delim = \"\";\n-        List<String> pExprs = new ArrayList<>();\n-        final int numParams = paramNames.size();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = paramNames.get(i);\n-            if (pName.isEmpty()) {\n-                pName = \"x\" + i;\n-            }\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n-            Class<?> pType = mtype.parameterType(i);\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n-            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n-            delim = \", \";\n-        }\n-        if (varargs) {\n-            String lastArg = \"x\" + numParams;\n-            if (numParams > 0) {\n-                append(\", \");\n-            }\n-            append(\"Object... \" + lastArg);\n-            pExprs.add(lastArg);\n-        }\n-        append(\") {\\n\");\n-        incrAlign();\n-        indent();\n-        if (nullCheck) {\n-            append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n-            append(access);\n-            append(\", \\\"\");\n-            append(symbolName);\n-            append(\"\\\");\\n\");\n-        } else {\n-            append(\"var mh$ = \" + access + \";\");\n-        }\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n-        }\n-        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n-    protected void emitFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n-                                       boolean varargs, List<String> paramNames) {\n-        emitFunctionWrapper(mods, mtype, javaName, access, varargs, paramNames, false, null);\n-    }\n-\n-    protected void emitVirtualFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n-                                     boolean nullCheck, String symbolName) {\n-        incrAlign();\n-        indent();\n-        append(mods + \" \");\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n-        String delim = \"\";\n-        List<String> pExprs = new ArrayList<>();\n-        int numParams = mtype.parameterCount();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = \"x\" + i;\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n-            Class<?> pType = mtype.parameterType(i);\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n-            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n-            delim = \", \";\n-        }\n-        append(\") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"var mh$ = \");\n-        if (nullCheck) {\n-            append(\"RuntimeHelper.requireNonNull(\");\n-        }\n-        append(access);\n-        if (nullCheck) {\n-            append(\",\\\"\");\n-            append(symbolName);\n-            append(\"\\\")\");\n-        }\n-        append(\";\\n\");\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n-        }\n-        append(\"mh$.invokeExact(\");\n-        append(\"(Addressable)\");\n-        append(javaName + \"$get(), \");\n-        append(String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n-    protected void emitVirtualFunctionWrapper(String mods, MethodType mtype, String javaName, String access) {\n-        emitVirtualFunctionWrapper(mods, mtype, javaName, access, false, null);\n-    }\n-\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":33,"deletions":150,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import jdk.internal.jextract.impl.JavaSourceBuilder.VarInfo;\n+import jdk.internal.jextract.impl.JavaSourceBuilder.FunctionInfo;\n+\n@@ -47,0 +50,1 @@\n+import java.util.Optional;\n@@ -48,0 +52,1 @@\n+import java.util.function.BiFunction;\n@@ -194,16 +199,0 @@\n-    private static boolean isVaList(FunctionDescriptor desc) {\n-        List<MemoryLayout> argLayouts = desc.argumentLayouts();\n-        int size = argLayouts.size();\n-        if (size > 0) {\n-            MemoryLayout lastLayout = argLayouts.get(size - 1);\n-            if (lastLayout instanceof SequenceLayout) {\n-                SequenceLayout seq = (SequenceLayout)lastLayout;\n-                MemoryLayout elem = seq.elementLayout();\n-                \/\/ FIXME: hack for now to use internal symbol used by clang for va_list\n-                return elem.name().orElse(\"\").equals(VA_LIST_TAG);\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n@@ -248,22 +237,3 @@\n-        name = Utils.javaSafeIdentifier(name);\n-        \/\/generate functional interface\n-        if (func.varargs() && !func.argumentTypes().isEmpty()) {\n-            warn(\"varargs in callbacks is not supported: \" + name);\n-            return false;\n-        }\n-        MethodType fitype = getMethodType(func, false);\n-        if (fitype == null) {\n-            warn(\"skipping \" + name + \" because of unsupported type usage\");\n-            return false;\n-        }\n-\n-        FunctionDescriptor fpDesc = Type.descriptorFor(func).orElseThrow();\n-        MemoryLayout unsupportedLayout = isUnsupported(fpDesc);\n-        if (unsupportedLayout != null) {\n-            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n-                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n-            return false;\n-        }\n-\n-        currentBuilder.addFunctionalInterface(name, fitype, fpDesc);\n-        return true;\n+        return functionInfo(func, name, false, FunctionInfo::ofFunctionPointer)\n+                .map(fInfo -> { currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo); return true; })\n+                .orElse(false);\n@@ -278,19 +248,0 @@\n-        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);\n-        if (descriptor == null) {\n-            \/\/abort\n-            return null;\n-        }\n-\n-        MemoryLayout unsupportedLayout = isUnsupported(descriptor);\n-        if (unsupportedLayout != null) {\n-            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage: \" +\n-                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n-            return null;\n-        }\n-\n-        MethodType mtype = getMethodType(funcTree.type());\n-        if (mtype == null) {\n-            warn(\"skipping \" + funcTree.name() + \" because of unsupported type usage\");\n-            return null;\n-        }\n-\n@@ -304,7 +255,14 @@\n-        int i = 0;\n-        for (Declaration.Variable param : funcTree.parameters()) {\n-            Type.Function f = getAsFunctionPointer(param.type());\n-            if (f != null) {\n-                String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n-                if (! generateFunctionalInterface(f, name)) {\n-                    return null;\n+\n+        Optional<FunctionInfo> functionInfo = functionInfo(funcTree.type(), funcTree.name(), true,\n+                (mtype, desc) -> FunctionInfo.ofFunction(mtype, desc, funcTree.type().varargs(), paramNames));\n+\n+        if (functionInfo.isPresent()) {\n+            int i = 0;\n+            for (Declaration.Variable param : funcTree.parameters()) {\n+                Type.Function f = getAsFunctionPointer(param.type());\n+                if (f != null) {\n+                    String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                    if (!generateFunctionalInterface(f, name)) {\n+                        return null;\n+                    }\n+                    i++;\n@@ -312,1 +270,0 @@\n-                i++;\n@@ -314,1 +271,0 @@\n-        }\n@@ -316,2 +272,2 @@\n-        toplevelBuilder.addFunction(mhName, funcTree.name(), mtype,\n-                descriptor, funcTree.type().varargs(), paramNames);\n+            toplevelBuilder.addFunction(mhName, funcTree.name(), functionInfo.get());\n+        }\n@@ -451,1 +407,1 @@\n-            currentBuilder.addVar(fieldName, tree.name(), treeLayout, clazz);\n+            VarInfo varInfo = VarInfo.ofVar(clazz, treeLayout);\n@@ -454,1 +410,3 @@\n-                addFunctionPointerInvoker(funcPtr, fieldName, tree.name());\n+                varInfo = functionInfo(funcPtr, tree.name(), false, FunctionInfo::ofFunctionPointer)\n+                        .map(fInfo -> VarInfo.ofFunctionPointerVar(clazz, treeLayout, fInfo))\n+                        .orElse(varInfo);\n@@ -456,0 +414,1 @@\n+            currentBuilder.addVar(fieldName, tree.name(), varInfo);\n@@ -463,1 +422,2 @@\n-    void addFunctionPointerInvoker(Type.Function funcPtr, String javaName, String nativeName) {\n+    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean allowVarargs,\n+                                                BiFunction<MethodType, FunctionDescriptor, FunctionInfo> functionInfoFactory) {\n@@ -467,1 +427,1 @@\n-            return;\n+            return Optional.empty();\n@@ -471,1 +431,1 @@\n-        if (funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n+        if (!allowVarargs && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n@@ -473,1 +433,1 @@\n-            return;\n+            return Optional.empty();\n@@ -480,1 +440,1 @@\n-            return;\n+            return Optional.empty();\n@@ -483,2 +443,4 @@\n-        MethodType mtype = typeTranslator.getMethodType(funcPtr);\n-        currentBuilder.addVirtualFunction(javaName, nativeName, mtype, descriptor);\n+        MethodType mtype = getMethodType(funcPtr, allowVarargs);\n+        return mtype != null ?\n+                Optional.of(functionInfoFactory.apply(mtype, descriptor)) :\n+                Optional.empty();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":39,"deletions":77,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -138,3 +138,3 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        if (type.equals(MemorySegment.class)) {\n-            emitSegmentGetter(javaName, nativeName, layout);\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitSegmentGetter(javaName, nativeName, varInfo.layout());\n@@ -142,1 +142,1 @@\n-            Constant vhConstant = addFieldVarHandle(javaName, nativeName, layout, type, layoutField(), prefixNamesList())\n+            Constant vhConstant = addFieldVarHandle(javaName, nativeName, varInfo, layoutField(), prefixNamesList())\n@@ -144,4 +144,10 @@\n-            emitFieldGetter(vhConstant, javaName, type);\n-            emitFieldSetter(vhConstant, javaName, type);\n-            emitIndexedFieldGetter(vhConstant, javaName, type);\n-            emitIndexedFieldSetter(vhConstant, javaName, type);\n+            emitFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            if (varInfo.functionInfo().isPresent()) {\n+                FunctionInfo functionInfo = varInfo.functionInfo().get();\n+                Constant mhConstant = addMethodHandle(javaName, nativeName, functionInfo, true)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+                emitVirtualFunctionWrapper(mhConstant, javaName, functionInfo.methodType());\n+            }\n@@ -151,9 +157,1 @@\n-    @Override\n-    public void addVirtualFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc) {\n-        addMethodHandle(javaName, nativeName, mtype, desc, true, false)\n-                .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME)\n-                .emitFunction(this, MEMBER_MODS, Constant.JAVA_NAME, null);\n-    }\n-\n-    protected void emitVirtualFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n-                                              boolean nullCheck, String symbolName) {\n+    private void emitVirtualFunctionWrapper(Constant mhConstant, String javaName, MethodType mtype) {\n@@ -162,1 +160,1 @@\n-        append(mods + \" \");\n+        append(MEMBER_MODS + \" \");\n@@ -183,9 +181,1 @@\n-        if (nullCheck) {\n-            append(\"RuntimeHelper.requireNonNull(\");\n-        }\n-        append(access);\n-        if (nullCheck) {\n-            append(\",\\\"\");\n-            append(symbolName);\n-            append(\"\\\")\");\n-        }\n+        append(mhConstant.accessExpression());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":17,"deletions":27,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-    public void addVar(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n-        nextHeader().addVar(javaName, nativeName, layout, type);\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        nextHeader().addVar(javaName, nativeName, varInfo);\n@@ -87,2 +87,2 @@\n-    public void addFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n-        nextHeader().addFunction(javaName, nativeName, mtype, desc, varargs, paramNames);\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        nextHeader().addFunction(javaName, nativeName, functionInfo);\n@@ -107,2 +107,2 @@\n-    public void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor desc) {\n-        nextHeader().addFunctionalInterface(name, mtype, desc);\n+    public void addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        nextHeader().addFunctionalInterface(name, functionInfo);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}