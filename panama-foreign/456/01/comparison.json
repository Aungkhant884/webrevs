{"files":[{"patch":"@@ -84,3 +84,3 @@\n-    public Constant addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n-        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n-                () -> emitMethodHandleField(javaName, nativeName, mtype, desc, varargs));\n+    public MethodHandleConstant addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean virtual, boolean varargs) {\n+        return (MethodHandleConstant)emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitMethodHandleField(javaName, nativeName, mtype, desc, virtual, varargs));\n@@ -144,1 +144,1 @@\n-        private List<String> getterNameParts() {\n+        List<String> getterNameParts() {\n@@ -172,0 +172,48 @@\n+    static class MethodHandleConstant extends Constant {\n+\n+        final MethodType mtype;\n+        final boolean virtual;\n+        final boolean varargs;\n+\n+\n+        MethodHandleConstant(String className, String javaName, Kind kind, MethodType mtype, boolean virtual, boolean varargs) {\n+            super(className, javaName, kind);\n+            this.mtype = mtype;\n+            this.virtual = virtual;\n+            this.varargs = varargs;\n+        }\n+\n+        @Override\n+        MethodHandleConstant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n+            return (MethodHandleConstant)super.emitGetter(builder, mods, getterNameFunc);\n+        }\n+\n+        @Override\n+        MethodHandleConstant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n+            return (MethodHandleConstant)super.emitGetter(builder, mods, getterNameFunc, symbolName);\n+        }\n+\n+        MethodHandleConstant emitFunction(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc,\n+                                          List<String> paramNames) {\n+            if (virtual) {\n+                builder.emitVirtualFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression());\n+            } else {\n+                builder.emitFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression(),\n+                        varargs, paramNames);\n+            }\n+            return this;\n+        }\n+\n+        MethodHandleConstant emitFunction(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc,\n+                                          List<String> paramNames, String symbolName) {\n+            if (virtual) {\n+                builder.emitVirtualFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression(),\n+                        true, symbolName);\n+            } else {\n+                builder.emitFunctionWrapper(mods, mtype, getterNameFunc.apply(getterNameParts()), accessExpression(),\n+                        varargs, paramNames, true, symbolName);\n+            }\n+            return this;\n+        }\n+    }\n+\n@@ -188,2 +236,2 @@\n-    private Constant emitMethodHandleField(String javaName, String nativeName, MethodType mtype,\n-                                         FunctionDescriptor desc, boolean varargs) {\n+    private MethodHandleConstant emitMethodHandleField(String javaName, String nativeName, MethodType mtype,\n+                                                                FunctionDescriptor desc, boolean virtual, boolean varargs) {\n@@ -198,3 +246,5 @@\n-        append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n-        append(\",\\n\");\n-        indent();\n+        if (!virtual) {\n+            append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+            append(\",\\n\");\n+            indent();\n+        }\n@@ -212,1 +262,1 @@\n-        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n+        return new MethodHandleConstant(className(), javaName, Constant.Kind.METHOD_HANDLE, mtype, virtual, varargs);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":60,"deletions":10,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -38,1 +37,0 @@\n-import java.util.ArrayList;\n@@ -86,3 +84,12 @@\n-            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, varargs)\n-                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n-            emitFunctionWrapper(mhConstant, javaName, nativeName, mtype, varargs, paramNames);\n+            constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, false, varargs)\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName)\n+                    .emitFunction(this, MEMBER_MODS, Constant.JAVA_NAME, paramNames, nativeName);\n+        });\n+    }\n+\n+    @Override\n+    public void addVirtualFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc) {\n+        emitWithConstantClass(javaName, constantBuilder -> {\n+            constantBuilder.addMethodHandle(javaName, nativeName, mtype, desc, true, false)\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME)\n+                    .emitFunction(this, MEMBER_MODS, Constant.JAVA_NAME, null);\n@@ -118,65 +125,0 @@\n-    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, MethodType mtype,\n-                                  boolean varargs, List<String> paramNames) {\n-        incrAlign();\n-        indent();\n-        append(MEMBER_MODS + \" \");\n-        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n-        String delim = \"\";\n-        List<String> pExprs = new ArrayList<>();\n-        final int numParams = paramNames.size();\n-        for (int i = 0 ; i < numParams; i++) {\n-            String pName = paramNames.get(i);\n-            if (pName.isEmpty()) {\n-                pName = \"x\" + i;\n-            }\n-            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n-                pExprs.add(pName + \".address()\");\n-            } else {\n-                pExprs.add(pName);\n-            }\n-            Class<?> pType = mtype.parameterType(i);\n-            if (pType.equals(MemoryAddress.class)) {\n-                pType = Addressable.class;\n-            }\n-            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n-            delim = \", \";\n-        }\n-        if (varargs) {\n-            String lastArg = \"x\" + numParams;\n-            if (numParams > 0) {\n-                append(\", \");\n-            }\n-            append(\"Object... \" + lastArg);\n-            pExprs.add(lastArg);\n-        }\n-        append(\") {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n-        append(mhConstant.accessExpression());\n-        append(\", \\\"\");\n-        append(nativeName);\n-        append(\"\\\");\\n\");\n-        indent();\n-        append(\"try {\\n\");\n-        incrAlign();\n-        indent();\n-        if (!mtype.returnType().equals(void.class)) {\n-            append(\"return (\" + mtype.returnType().getName() + \")\");\n-        }\n-        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"} catch (Throwable ex$) {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":12,"deletions":70,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -29,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -36,0 +38,1 @@\n+import java.util.ArrayList;\n@@ -131,0 +134,4 @@\n+    public void addVirtualFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n@@ -259,0 +266,141 @@\n+    protected void emitFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n+                                     boolean varargs, List<String> paramNames, boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \");\n+        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        final int numParams = paramNames.size();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = paramNames.get(i);\n+            if (pName.isEmpty()) {\n+                pName = \"x\" + i;\n+            }\n+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = mtype.parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        if (varargs) {\n+            String lastArg = \"x\" + numParams;\n+            if (numParams > 0) {\n+                append(\", \");\n+            }\n+            append(\"Object... \" + lastArg);\n+            pExprs.add(lastArg);\n+        }\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        if (nullCheck) {\n+            append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+            append(access);\n+            append(\", \\\"\");\n+            append(symbolName);\n+            append(\"\\\");\\n\");\n+        } else {\n+            append(\"var mh$ = \" + access + \";\");\n+        }\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!mtype.returnType().equals(void.class)) {\n+            append(\"return (\" + mtype.returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    protected void emitFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n+                                       boolean varargs, List<String> paramNames) {\n+        emitFunctionWrapper(mods, mtype, javaName, access, varargs, paramNames, false, null);\n+    }\n+\n+    protected void emitVirtualFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n+                                     boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \");\n+        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        int numParams = mtype.parameterCount();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = \"x\" + i;\n+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = mtype.parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = \");\n+        if (nullCheck) {\n+            append(\"RuntimeHelper.requireNonNull(\");\n+        }\n+        append(access);\n+        if (nullCheck) {\n+            append(\",\\\"\");\n+            append(symbolName);\n+            append(\"\\\")\");\n+        }\n+        append(\";\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!mtype.returnType().equals(void.class)) {\n+            append(\"return (\" + mtype.returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\");\n+        append(\"(Addressable)\");\n+        append(javaName + \"$get(), \");\n+        append(String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    protected void emitVirtualFunctionWrapper(String mods, MethodType mtype, String javaName, String access) {\n+        emitVirtualFunctionWrapper(mods, mtype, javaName, access, false, null);\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-                clazz, constant.value());\n+                typeTranslator.getJavaType(constant.type()), constant.value());\n@@ -250,1 +250,1 @@\n-        if (func.varargs()) {\n+        if (func.varargs() && !func.argumentTypes().isEmpty()) {\n@@ -252,0 +252,1 @@\n+            return false;\n@@ -296,11 +297,0 @@\n-        if (isVaList(descriptor)) {\n-            MemoryLayout[] argLayouts = descriptor.argumentLayouts().toArray(new MemoryLayout[0]);\n-            argLayouts[argLayouts.length - 1] = CLinker.C_VA_LIST;\n-            descriptor = descriptor.returnLayout().isEmpty()?\n-                    FunctionDescriptor.ofVoid(argLayouts) :\n-                    FunctionDescriptor.of(descriptor.returnLayout().get(), argLayouts);\n-            Class<?>[] argTypes = mtype.parameterArray();\n-            argTypes[argLayouts.length - 1] = MemoryAddress.class;\n-            mtype = MethodType.methodType(mtype.returnType(), argTypes);\n-        }\n-\n@@ -333,0 +323,4 @@\n+        return getAsFunctionPointer(type, false);\n+    }\n+\n+    Type.Function getAsFunctionPointer(Type type, boolean followTypedefs) {\n@@ -335,2 +329,2 @@\n-            return delegated.kind() == Type.Delegated.Kind.POINTER ?\n-                getAsFunctionPointer(delegated.type()) : null;\n+            return (followTypedefs || delegated.kind() == Type.Delegated.Kind.POINTER) ?\n+                getAsFunctionPointer(delegated.type(), followTypedefs) : null;\n@@ -435,0 +429,7 @@\n+        Class<?> clazz = getJavaType(type);\n+        if (clazz == null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage\");\n+            return null;\n+        }\n@@ -450,7 +451,0 @@\n-            Class<?> clazz = getJavaType(type);\n-            if (clazz == null) {\n-                String name = parent != null? parent.name() + \".\" : \"\";\n-                name += fieldName;\n-                warn(\"skipping \" + name + \" because of unsupported type usage\");\n-                return null;\n-            }\n@@ -458,0 +452,4 @@\n+            Type.Function funcPtr = getAsFunctionPointer(tree.type(), true);\n+            if (funcPtr != null) {\n+                addFunctionPointerInvoker(funcPtr, fieldName, tree.name());\n+            }\n@@ -465,0 +463,24 @@\n+    void addFunctionPointerInvoker(Type.Function funcPtr, String javaName, String nativeName) {\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcPtr).orElse(null);\n+        if (descriptor == null) {\n+            \/\/abort\n+            return;\n+        }\n+\n+        \/\/generate functional interface\n+        if (funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n+            warn(\"varargs in callbacks is not supported: \" + funcPtr);\n+            return;\n+        }\n+\n+        MemoryLayout unsupportedLayout = isUnsupported(descriptor);\n+        if (unsupportedLayout != null) {\n+            warn(\"skipping \" + nativeName + \" because of unsupported type usage: \" +\n+                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n+            return;\n+        }\n+\n+        MethodType mtype = typeTranslator.getMethodType(funcPtr);\n+        currentBuilder.addVirtualFunction(javaName, nativeName, mtype, descriptor);\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":44,"deletions":22,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -28,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -33,0 +36,1 @@\n+import java.lang.invoke.MethodType;\n@@ -147,0 +151,68 @@\n+    @Override\n+    public void addVirtualFunction(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc) {\n+        addMethodHandle(javaName, nativeName, mtype, desc, true, false)\n+                .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME)\n+                .emitFunction(this, MEMBER_MODS, Constant.JAVA_NAME, null);\n+    }\n+\n+    protected void emitVirtualFunctionWrapper(String mods, MethodType mtype, String javaName, String access,\n+                                              boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \");\n+        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (MemorySegment segment\");\n+        List<String> pExprs = new ArrayList<>();\n+        int numParams = mtype.parameterCount();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = \"x\" + i;\n+            if (mtype.parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = mtype.parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(\", \" + pType.getSimpleName() + \" \" + pName);\n+        }\n+        append(\") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = \");\n+        if (nullCheck) {\n+            append(\"RuntimeHelper.requireNonNull(\");\n+        }\n+        append(access);\n+        if (nullCheck) {\n+            append(\",\\\"\");\n+            append(symbolName);\n+            append(\"\\\")\");\n+        }\n+        append(\";\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!mtype.returnType().equals(void.class)) {\n+            append(\"return (\" + mtype.returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\");\n+        append(\"(Addressable)\");\n+        append(javaName + \"$get(segment), \");\n+        append(String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                \"--release\", \"16\",\n+                \"--release\", \"17\",\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Writer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,8 @@\n+    static final MethodHandle downcallHandle(String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+        return LINKER.downcallHandle(mt, fdesc);\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.testng.annotations.Test;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.testng.Assert.*;\n+import static test.jextract.funcpointers.func_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestFuncPointerInvokers\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestFuncPointerInvokers\n+ *\/\n+public class TestFuncPointerInvokers {\n+    @Test\n+    public void testStructField() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Bar.foo(bar, 42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobal() {\n+        try (NativeScope scope = NativeScope.unboundedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            f(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+#include <stdarg.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void (*Foo)(int arg);\n+\n+struct Bar {\n+   Foo foo;\n+};\n+\n+EXPORT Foo f;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/func.h","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+#include \"func.h\"\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/libFunc.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"}]}