{"files":[{"patch":"@@ -101,9 +101,0 @@\n-    private static final DirectMethodHandleDesc BSM_GET_STATIC_FINAL = ConstantDescs.ofConstantBootstrap(\n-            CD_ConstantBootstraps,\n-            \"getStaticFinal\",\n-            CD_Object,\n-            CD_Class\n-    );\n-\n-    private static final ConstantDesc TRUE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, \"TRUE\", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);\n-    private static final ConstantDesc FALSE = DynamicConstantDesc.ofNamed(BSM_GET_STATIC_FINAL, \"FALSE\", ConstantDescs.CD_Boolean, ConstantDescs.CD_Boolean);\n@@ -136,7 +127,21 @@\n-    ClassConstantHelper(String parentClassName, ClassDesc runtimeHelper, ClassDesc cString, String[] libraryNames) {\n-        this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        String className = parentClassName + \"$constants\";\n-        this.CD_constantsHelper = ClassDesc.of(className);\n-        this.internalClassName = className.replace('.', '\/');\n-\n-        this.MH_downcallHandle = findRuntimeHelperBootstrap(\n+    public ClassConstantHelper(ClassWriter cw, ClassDesc CD_constantsHelper, String internalClassName,\n+            DirectMethodHandleDesc MH_downcallHandle, DirectMethodHandleDesc MH_lookupGlobalVariable,\n+            DirectMethodHandleDesc MH_makeCString, ConstantDesc LIBRARIES) {\n+        this.cw = cw;\n+        this.MH_downcallHandle = MH_downcallHandle;\n+        this.MH_lookupGlobalVariable = MH_lookupGlobalVariable;\n+        this.MH_makeCString = MH_makeCString;\n+        this.internalClassName = internalClassName;\n+        this.CD_constantsHelper = CD_constantsHelper;\n+        this.LIBRARIES = LIBRARIES;\n+    }\n+\n+    public static ConstantHelper make(String packageName, String className, ClassDesc runtimeHelper, ClassDesc cString,\n+                                      String[] libraryNames, String baseClassName, boolean isFinal) {\n+        String qualName = Utils.qualifiedClassName(packageName, className);\n+        String qualBaseName = baseClassName != null ? Utils.qualifiedClassName(packageName, baseClassName) : null;\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n+        ClassDesc CD_constantsHelper = ClassDesc.of(qualName);\n+        String internalClassName = toInternalName(qualName);\n+\n+        DirectMethodHandleDesc MH_downcallHandle = findRuntimeHelperBootstrap(\n@@ -153,1 +158,1 @@\n-        this.MH_lookupGlobalVariable = findRuntimeHelperBootstrap(\n+        DirectMethodHandleDesc MH_lookupGlobalVariable = findRuntimeHelperBootstrap(\n@@ -162,1 +167,1 @@\n-        this.MH_makeCString = findRuntimeHelperBootstrap(\n+        DirectMethodHandleDesc MH_makeCString = findRuntimeHelperBootstrap(\n@@ -170,1 +175,1 @@\n-        this.LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(\n+        ConstantDesc LIBRARIES = librariesDesc(findRuntimeHelperBootstrap(\n@@ -178,1 +183,17 @@\n-        cw.visit(V15, ACC_PUBLIC, internalClassName, null, INTR_OBJECT, null);\n+        ClassConstantHelper helper = new ClassConstantHelper(cw, CD_constantsHelper, internalClassName,\n+                MH_downcallHandle, MH_lookupGlobalVariable, MH_makeCString, LIBRARIES);\n+        helper.classBegin(qualBaseName, isFinal);\n+        return helper;\n+    }\n+\n+    private static String toInternalName(String className) {\n+        return className.replace('.', '\/');\n+    }\n+\n+    private void classBegin(String baseClassName, boolean isFinal) {\n+        String baseName = baseClassName != null ? toInternalName(baseClassName) : INTR_OBJECT;\n+        int mods = ACC_PUBLIC;\n+        if (isFinal) {\n+            mods |= ACC_FINAL;\n+        }\n+        cw.visit(V15, mods, internalClassName, null, baseName, null);\n@@ -475,1 +496,1 @@\n-            varargs ? TRUE : FALSE);\n+            desc(varargs));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClassConstantHelper.java","additions":42,"deletions":21,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static ConstantHelper make(boolean source, String parentClassName, ClassDesc runtimeHelper,\n+    static ConstantHelper make(boolean source, String packageName, String headerClassName, ClassDesc runtimeHelper,\n@@ -48,5 +48,4 @@\n-        if (source) {\n-            return new SourceConstantHelper(parentClassName, libraryNames);\n-        } else {\n-            return new ClassConstantHelper(parentClassName, runtimeHelper, cString, libraryNames);\n-        }\n+        return new MultiFileConstantHelper(headerClassName,\n+            (simpleClassName, baseClassName, isFinal) -> source\n+                ? SourceConstantHelper.make(packageName, simpleClassName, libraryNames, baseClassName, isFinal)\n+                : ClassConstantHelper.make(packageName, simpleClassName, runtimeHelper, cString, libraryNames, baseClassName, isFinal));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantHelper.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class MultiFileConstantHelper implements ConstantHelper {\n+\n+    private static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 1000);\n+\n+    @FunctionalInterface\n+    interface ConstantHelperFunc {\n+        ConstantHelper make(String simpleClassName, String baseClassName, boolean isFinal);\n+    }\n+\n+    private final ConstantHelperFunc delegateFactory;\n+    private final String headerClassName;\n+\n+    private int constantCount;\n+    private int constantClassCount;\n+    private ConstantHelper delegate;\n+\n+    private final List<JavaFileObject> finishedClasses = new ArrayList<>();\n+\n+    public MultiFileConstantHelper(String headerClassName, ConstantHelperFunc func) {\n+        this.headerClassName = headerClassName;\n+        this.delegateFactory = func;\n+        this.delegate = delegateFactory.make(getConstantClassName(), null, false);\n+    }\n+\n+    private String getConstantClassName() {\n+        return headerClassName + \"$constants$\" + constantClassCount;\n+    }\n+\n+    private void checkNewConstantsClass() {\n+        if (constantCount > CONSTANTS_PER_CLASS) {\n+            newConstantsClass(false, null);\n+        }\n+        constantCount++;\n+    }\n+\n+    private void newConstantsClass(boolean isFinal, String nameOverride) {\n+        finishedClasses.addAll(delegate.getClasses());\n+        String currentClassName = getConstantClassName();\n+        constantClassCount++;\n+        String newClassName = nameOverride != null ? nameOverride : getConstantClassName();\n+        delegate = delegateFactory.make(newClassName, currentClassName, isFinal);\n+        this.constantCount = 0;\n+    }\n+\n+    @Override\n+    public DirectMethodHandleDesc addLayout(String javaName, MemoryLayout layout) {\n+        checkNewConstantsClass();\n+        return delegate.addLayout(javaName, layout);\n+    }\n+\n+    @Override\n+    public DirectMethodHandleDesc addFieldVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String parentJavaName, MemoryLayout parentLayout) {\n+        checkNewConstantsClass();\n+        return delegate.addFieldVarHandle(javaName, nativeName, layout, type, parentJavaName, parentLayout);\n+    }\n+\n+    @Override\n+    public DirectMethodHandleDesc addGlobalVarHandle(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        checkNewConstantsClass();\n+        return delegate.addGlobalVarHandle(javaName, nativeName, layout, type);\n+    }\n+\n+    @Override\n+    public DirectMethodHandleDesc addMethodHandle(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs) {\n+        checkNewConstantsClass();\n+        return delegate.addMethodHandle(javaName, nativeName, mtype, desc, varargs);\n+    }\n+\n+    @Override\n+    public DirectMethodHandleDesc addSegment(String javaName, String nativeName, MemoryLayout layout) {\n+        checkNewConstantsClass();\n+        return delegate.addSegment(javaName, nativeName, layout);\n+    }\n+\n+    @Override\n+    public DirectMethodHandleDesc addFunctionDesc(String javaName, FunctionDescriptor fDesc) {\n+        checkNewConstantsClass();\n+        return delegate.addFunctionDesc(javaName, fDesc);\n+    }\n+\n+    @Override\n+    public DirectMethodHandleDesc addConstant(String name, Class<?> type, Object value) {\n+        checkNewConstantsClass();\n+        return delegate.addConstant(name, type, value);\n+    }\n+\n+    @Override\n+    public List<JavaFileObject> getClasses() {\n+        newConstantsClass(true, headerClassName + \"$constants\");\n+        return new ArrayList<>(finishedClasses);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/MultiFileConstantHelper.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -97,2 +97,1 @@\n-        String qualName = pkgName.isEmpty() ? clsName : pkgName + \".\" + clsName;\n-        ConstantHelper constantHelper = ConstantHelper.make(source, qualName,\n+        ConstantHelper constantHelper = ConstantHelper.make(source, pkgName, clsName,\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,6 +75,2 @@\n-    private final String headerClassName;\n-    private int constantCount;\n-    private int constantClassCount;\n-    private String constantClassName;\n-    private ClassDesc CD_constantsHelper;\n-    private final List<String> classes = new ArrayList<>();\n+    private final String constantClassName;\n+    private final ClassDesc CD_constantsHelper;\n@@ -82,7 +78,4 @@\n-    SourceConstantHelper(String parentClassName, String[] libraryNames) {\n-        int idx = parentClassName.lastIndexOf('.');\n-        this.pkgName = idx == -1? \"\" : parentClassName.substring(0, idx);\n-        this.headerClassName =  parentClassName.substring(idx + 1);\n-        this.constantClassName = getConstantClassName(headerClassName, constantClassCount);\n-        this.CD_constantsHelper = ClassDesc.of(pkgName.isEmpty() ? constantClassName : (pkgName + \".\" + constantClassName));\n-        classBegin(libraryNames, null, false);\n+    private SourceConstantHelper(String packageName, String className, ClassDesc CD_constantsHelper) {\n+        this.pkgName = packageName;\n+        this.constantClassName = className;\n+        this.CD_constantsHelper = CD_constantsHelper;\n@@ -91,16 +84,6 @@\n-    private static String getConstantClassName(String className, int count) {\n-        return className + \"$constants$\" + count;\n-    }\n-\n-    private void newConstantClass() {\n-        if (constantCount > CONSTANTS_PER_CLASS) {\n-            classEnd();\n-            constantClassCount++;\n-            String baseClassName = constantClassName;\n-            this.constantClassName = getConstantClassName(headerClassName, constantClassCount);\n-            this.CD_constantsHelper = ClassDesc.of(pkgName.isEmpty() ? constantClassName : (pkgName + \".\" + constantClassName));\n-            this.constantCount = 0;\n-            this.sb = new StringBuilder();\n-            classBegin(null, baseClassName, false);\n-        }\n-        constantCount++;\n+    public static ConstantHelper make(String packageName, String className, String[] libraryNames,\n+                                      String baseClassName, boolean isFinal) {\n+        ClassDesc CD_constantsHelper = ClassDesc.of(className);\n+        SourceConstantHelper helper = new SourceConstantHelper(packageName, className, CD_constantsHelper);\n+        helper.classBegin(libraryNames, baseClassName, isFinal);\n+        return helper;\n@@ -111,1 +94,0 @@\n-        newConstantClass();\n@@ -134,1 +116,0 @@\n-        newConstantClass();\n@@ -149,1 +130,0 @@\n-        newConstantClass();\n@@ -163,1 +143,0 @@\n-        newConstantClass();\n@@ -177,1 +156,0 @@\n-        newConstantClass();\n@@ -192,2 +170,0 @@\n-        newConstantClass();\n-\n@@ -219,19 +195,3 @@\n-\n-        List<JavaFileObject> javaFileObjects = new ArrayList<>();\n-        int count = 0;\n-        for (String src : classes) {\n-            String name = getConstantClassName(headerClassName, count);\n-            javaFileObjects.add(newJavaFileObject(name, src));\n-            count++;\n-        }\n-\n-        \/\/ generate overall header$constants subclass that inherits from\n-        \/\/ the individual \"split\" header$constants$N classes.\n-        this.sb = new StringBuilder();\n-        String baseClassName = constantClassName;\n-        this.constantClassName = headerClassName + \"$constants\";\n-        classBegin(null, baseClassName, true);\n-        classEnd();\n-        javaFileObjects.add(newJavaFileObject(constantClassName, sb.toString()));\n-\n-        return javaFileObjects;\n+        JavaFileObject result = newJavaFileObject(constantClassName, sb.toString());\n+        sb = null;\n+        return List.of(result);\n@@ -250,1 +210,1 @@\n-    private void classBegin(String[] libraryNames, String baseClassName, boolean leafClass) {\n+    private void classBegin(String[] libraryNames, String baseClassName, boolean isFinal) {\n@@ -254,1 +214,1 @@\n-        if (leafClass) {\n+        if (isFinal) {\n@@ -265,1 +225,1 @@\n-        if (libraryNames != null) {\n+        if (baseClassName == null) { \/\/ only for the first one\n@@ -272,1 +232,0 @@\n-        classes.add(sb.toString());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/SourceConstantHelper.java","additions":18,"deletions":59,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+    public static String qualifiedClassName(String packageName, String simpleName) {\n+        return (packageName.isEmpty() ? \"\" : packageName + \".\") + simpleName;\n+    }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Utils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}