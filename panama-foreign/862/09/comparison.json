{"files":[{"patch":"@@ -108,0 +108,1 @@\n+        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -30,2 +31,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n@@ -33,1 +32,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -35,1 +33,0 @@\n-import java.util.Objects;\n@@ -37,4 +34,1 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -49,17 +43,0 @@\n-    \/\/ Maximum segment byte size for which a critical method will be invoked.\n-    private static final long MAX_CRITICAL_SIZE = 1024L;\n-    private static final MethodHandle STRNLEN_CRITICAL;\n-    private static final MethodHandle STRNLEN;\n-    private static final boolean SIZE_T_IS_INT;\n-\n-    static {\n-        var size_t = Objects.requireNonNull(Linker.nativeLinker().canonicalLayouts().get(\"size_t\"));\n-        Linker linker = Linker.nativeLinker();\n-        var strnlen = linker.defaultLookup().find(\"strnlen\").orElseThrow();\n-        var description = FunctionDescriptor.of(size_t, ADDRESS, size_t);\n-\n-        STRNLEN_CRITICAL = linker.downcallHandle(strnlen, description, Linker.Option.critical());\n-        STRNLEN = linker.downcallHandle(strnlen, description);\n-        SIZE_T_IS_INT = (size_t.byteSize() == Integer.BYTES);\n-    }\n-\n@@ -68,3 +45,3 @@\n-            case SINGLE_BYTE -> readFast_byte(segment, offset, charset);\n-            case DOUBLE_BYTE -> readFast_short(segment, offset, charset);\n-            case QUAD_BYTE -> readFast_int(segment, offset, charset);\n+            case SINGLE_BYTE -> readByte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readShort(segment, offset, charset);\n+            case QUAD_BYTE -> readInt(segment, offset, charset);\n@@ -76,3 +53,3 @@\n-            case SINGLE_BYTE -> writeFast_byte(segment, offset, charset, string);\n-            case DOUBLE_BYTE -> writeFast_short(segment, offset, charset, string);\n-            case QUAD_BYTE -> writeFast_int(segment, offset, charset, string);\n+            case SINGLE_BYTE -> writeByte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeShort(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeInt(segment, offset, charset, string);\n@@ -81,2 +58,3 @@\n-    private static String readFast_byte(MemorySegment segment, long offset, Charset charset) {\n-        long len = native_strlen_byte(segment, offset);\n+\n+    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenByte(segment, offset);\n@@ -88,1 +66,1 @@\n-    private static void writeFast_byte(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -94,2 +72,2 @@\n-    private static String readFast_short(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlen_short(segment, offset);\n+    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenShort(segment, offset);\n@@ -101,1 +79,1 @@\n-    private static void writeFast_short(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -107,2 +85,2 @@\n-    private static String readFast_int(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlen_int(segment, offset);\n+    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlenInt(segment, offset);\n@@ -114,1 +92,1 @@\n-    private static void writeFast_int(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -120,5 +98,23 @@\n-    private static int native_strlen_byte(MemorySegment segment, long start) {\n-        \/\/ Heap segments must be handled by Java code\n-        if (!segment.isNative()) {\n-            return strlen_byte(segment, start);\n-        }\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * <p>\n+     * The method divides the region of interest into three distinct regions:\n+     * <ul>\n+     *     <li>head (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n+     *     <li>body (long aligned access handling eight bytes at a time) (if any)<\/li>\n+     *     <li>tail (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The body is using a heuristic method to determine if a long word\n+     * contains a zero byte. The method might have false positives but\n+     * never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n@@ -126,3 +122,2 @@\n-        if (start > 0) {\n-            segment = segment.asSlice(start);\n-        }\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n@@ -130,12 +125,5 @@\n-        long segmentSize = segment.byteSize();\n-        final long len;\n-        if (SIZE_T_IS_INT) {\n-            if (segmentSize < MAX_CRITICAL_SIZE) {\n-                len = strnlen_int_critical(segment, segmentSize);\n-            } else if (segmentSize < Integer.MAX_VALUE * 2L) { \/\/ size_t is unsigned\n-                len = strnlen_int(segment, segmentSize);\n-            } else {\n-                \/\/ There is no way to express the max size in the native method using an int so, revert\n-                \/\/ to a Java method. It is possible to use a reduction of several STRNLEN invocations\n-                \/\/ in a future optimization.\n-                len = strlen_byte(segment, 0);\n+        int offset = 0;\n+        for (; offset < headCount; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n@@ -143,4 +131,0 @@\n-        } else {\n-            len = segmentSize < MAX_CRITICAL_SIZE\n-                    ? strnlen_long_critical(segment, segmentSize)\n-                    : strnlen_long(segment, segmentSize);\n@@ -148,2 +132,15 @@\n-        if (len > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n-            throw newIaeStringTooLarge();\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroByte(curr)) {\n+                for (int j = 0; j < 8; j++) {\n+                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n@@ -151,1 +148,3 @@\n-        return (int)len;\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n@@ -154,8 +153,15 @@\n-    static long strnlen_int_critical(MemorySegment segment, long size) {\n-        try {\n-            return Integer.toUnsignedLong((int)STRNLEN_CRITICAL.invokeExact(segment, (int)size));\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n-        }\n+    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+       the \"holes\".  Note that there is a hole just to the left of\n+       each byte, with an extra at the end:\n+\n+       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+       The 1-bits make sure that carries propagate to the next 0-bit.\n+       The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n@@ -164,8 +170,5 @@\n-    static long strnlen_int(MemorySegment segment, long size) {\n-        try {\n-            return Integer.toUnsignedLong((int)STRNLEN.invokeExact(segment, (int)size));\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n-        }\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n@@ -174,7 +177,3 @@\n-    static long strnlen_long_critical(MemorySegment segment, long size) {\n-        try {\n-            return (long)STRNLEN_CRITICAL.invokeExact(segment, size);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n+    static int requireWithinArraySize(long size) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n@@ -182,0 +181,1 @@\n+        return (int) size;\n@@ -184,8 +184,7 @@\n-    static long strnlen_long(MemorySegment segment, long size) {\n-        try {\n-            return (long)STRNLEN.invokeExact(segment, size);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n-        }\n+    static int bodyCount(long remaining) {\n+        return (int) Math.min(\n+                \/\/ Make sure we do not wrap around\n+                Integer.MAX_VALUE - Long.BYTES,\n+                \/\/ Remaining bytes to consider\n+                remaining)\n+                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n@@ -194,3 +193,2 @@\n-    private static int strlen_byte(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 1) {\n+    private static int strlenByte(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n@@ -205,3 +203,20 @@\n-    private static int strlen_short(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 2) {\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero short in the provided {@code segment}}\n+     * <p>\n+     * Note: The inspected region must be short aligned.\n+     *\n+     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero shorts\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset += Short.BYTES) {\n@@ -213,0 +228,28 @@\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroShort(curr)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n+    }\n+\n+    private static int strlenShort(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n+            if (curr == (short)0) {\n+                return offset;\n+            }\n+        }\n@@ -216,4 +259,6 @@\n-    private static int strlen_int(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 4) {\n-            int curr = segment.get(JAVA_INT, start + offset);\n+    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n+    \/\/ so, there is only one method for ints.\n+    public static int strlenInt(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":153,"deletions":108,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -58,1 +57,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -130,0 +128,4 @@\n+    public static long remainsToAlignment(long addr, long alignment) {\n+        return alignUp(addr, alignment) - addr;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -47,0 +48,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -49,2 +51,1 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -55,0 +56,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -64,20 +66,22 @@\n-                try (Arena arena = Arena.ofConfined()) {\n-                    MemorySegment text = arena.allocateFrom(testString, charset);\n-\n-                    int terminatorSize = \"\\0\".getBytes(charset).length;\n-                    if (charset == StandardCharsets.UTF_16) {\n-                        terminatorSize -= 2; \/\/ drop BOM\n-                    }\n-                    \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n-                    \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n-                    \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n-\n-                    int expectedByteLength =\n-                            testString.getBytes(charset).length +\n-                            terminatorSize;\n-\n-                    assertEquals(text.byteSize(), expectedByteLength);\n-\n-                    String roundTrip = text.getString(0, charset);\n-                    if (charset.newEncoder().canEncode(testString)) {\n-                        assertEquals(roundTrip, testString);\n+                for (Arena arena : arenas()) {\n+                    try (arena) {\n+                        MemorySegment text = arena.allocateFrom(testString, charset);\n+\n+                        int terminatorSize = \"\\0\".getBytes(charset).length;\n+                        if (charset == StandardCharsets.UTF_16) {\n+                            terminatorSize -= 2; \/\/ drop BOM\n+                        }\n+                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+\n+                        int expectedByteLength =\n+                                testString.getBytes(charset).length +\n+                                        terminatorSize;\n+\n+                        assertEquals(text.byteSize(), expectedByteLength);\n+\n+                        String roundTrip = text.getString(0, charset);\n+                        if (charset.newEncoder().canEncode(testString)) {\n+                            assertEquals(roundTrip, testString);\n+                        }\n@@ -92,0 +96,1 @@\n+\n@@ -95,3 +100,4 @@\n-            try (Arena arena = Arena.ofConfined()) {\n-                MemorySegment text = arena.allocateFrom(testString, charset);\n-                text = toHeapSegment(text);\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                    text = toHeapSegment(text);\n@@ -99,2 +105,2 @@\n-                int expectedByteLength =\n-                        testString.getBytes(charset).length + 1;\n+                    int expectedByteLength =\n+                            testString.getBytes(charset).length + 1;\n@@ -102,1 +108,1 @@\n-                assertEquals(text.byteSize(), expectedByteLength);\n+                    assertEquals(text.byteSize(), expectedByteLength);\n@@ -104,3 +110,4 @@\n-                String roundTrip = text.getString(0, charset);\n-                if (charset.newEncoder().canEncode(testString)) {\n-                    assertEquals(roundTrip, testString);\n+                    String roundTrip = text.getString(0, charset);\n+                    if (charset.newEncoder().canEncode(testString)) {\n+                        assertEquals(roundTrip, testString);\n+                    }\n@@ -172,11 +179,13 @@\n-            try (var arena = Arena.ofConfined()) {\n-                var segment = arena.allocate(len, 4);\n-                var arr = new byte[len];\n-                random.nextBytes(arr);\n-                segment.copyFrom(MemorySegment.ofArray(arr));\n-                int terminatorIndex = random.nextInt(len);\n-                segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n-                for (Charset charset : singleByteCharsets()) {\n-                    var s = segment.getString(0, charset);\n-                    var ref = referenceImpl(segment, 0, charset);\n-                    assertEquals(s, ref);\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    var segment = arena.allocate(len, 1);\n+                    var arr = new byte[len];\n+                    random.nextBytes(arr);\n+                    segment.copyFrom(MemorySegment.ofArray(arr));\n+                    int terminatorIndex = random.nextInt(len);\n+                    segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n+                    for (Charset charset : singleByteCharsets()) {\n+                        var s = segment.getString(0, charset);\n+                        var ref = referenceImpl(segment, 0, charset);\n+                        assertEquals(s, ref);\n+                    }\n@@ -188,1 +197,0 @@\n-\n@@ -194,6 +202,8 @@\n-        for(var charset:singleByteCharsets()) {\n-            try (Arena arena = Arena.ofConfined()) {\n-                MemorySegment inSegment = arena.allocateFrom(testString, charset);\n-                for (int i = 0; i < 3; i++) {\n-                    String actual = inSegment.getString(i, charset);\n-                    assertEquals(actual, testString.substring(i));\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment inSegment = arena.allocateFrom(testString, charset);\n+                    for (int i = 0; i < 3; i++) {\n+                        String actual = inSegment.getString(i, charset);\n+                        assertEquals(actual, testString.substring(i));\n+                    }\n@@ -241,1 +251,1 @@\n-           \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n+            \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n@@ -288,1 +298,1 @@\n-                seg.fill((byte)1);\n+                seg.fill((byte) 1);\n@@ -299,0 +309,78 @@\n+    private static final int TEST_LENGTH_MAX = 277;\n+\n+    private Random deterministicRandom() {\n+        return new Random(42);\n+    }\n+\n+    @Test\n+    public void chunked_strlen_byte() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew++) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate(len + 1 + skew)\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        byte value;\n+                        while ((value = (byte) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_BYTE, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_BYTE, len, (byte) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        assertEquals(actual, len - j);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void chunked_strlen_short() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Short.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Short.BYTES + skew, JAVA_SHORT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        short value;\n+                        while ((value = (short) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_SHORT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_SHORT, len, (short) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        assertEquals(actual, (len - j) * Short.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void strlen_int() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Integer.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Integer.BYTES + skew, JAVA_INT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        int value;\n+                        while ((value = random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_INT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_INT, len, 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        assertEquals(actual, (len - j) * Integer.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -350,1 +438,0 @@\n-\n@@ -358,1 +445,0 @@\n-\n@@ -371,0 +457,56 @@\n+    private static List<Arena> arenas() {\n+        return Arrays.asList(\n+                Arena.ofConfined(),          \/\/ Native memory\n+                new HeapArena(byte.class),   \/\/ Heap memory backed by a byte array\n+                new HeapArena(short.class),  \/\/ Heap memory backed by a short array\n+                new HeapArena(int.class),    \/\/ Heap memory backed by an int array\n+                new HeapArena(long.class));  \/\/ Heap memory backed by a long array\n+    }\n+\n+    private static final class HeapArena implements Arena {\n+\n+        private static final int ELEMENT_SIZE = 1_000;\n+\n+        private final MemorySegment backingSegment;\n+        private final SegmentAllocator allocator;\n+\n+        public HeapArena(Class<?> type) {\n+            if (!type.isPrimitive()) {\n+                throw new IllegalArgumentException(type.toString());\n+            }\n+            backingSegment = switch (type) {\n+                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[ELEMENT_SIZE]);\n+                case Class<?> c when short.class.equals(c) ->\n+                        MemorySegment.ofArray(new short[ELEMENT_SIZE]);\n+                case Class<?> c when int.class.equals(c) ->\n+                        MemorySegment.ofArray(new int[ELEMENT_SIZE]);\n+                case Class<?> c when long.class.equals(c) ->\n+                        MemorySegment.ofArray(new long[ELEMENT_SIZE]);\n+                default -> throw new IllegalArgumentException();\n+            };\n+            allocator = SegmentAllocator.slicingAllocator(backingSegment);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return backingSegment.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"HeapArena{\" +\n+                    \"type=\" + backingSegment.heapBase().orElseThrow().getClass().getName() +\n+                    '}';\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":195,"deletions":53,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static jdk.internal.foreign.StringSupport.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class InternalStrLen {\n+\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n+\n+    @Param({\"1\", \"4\", \"16\", \"251\", \"1024\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n+        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        Stream.of(singleByteSegment, doubleByteSegment, quadByteSegment)\n+                .forEach(s -> IntStream.range(0, (int) s.byteSize() - 1)\n+                        .forEach(i -> s.set(\n+                                ValueLayout.JAVA_BYTE,\n+                                i,\n+                                (byte) ThreadLocalRandom.current().nextInt(1, 254)\n+                        )));\n+        singleByteSegment.set(ValueLayout.JAVA_BYTE, singleByteSegment.byteSize() - Byte.BYTES, (byte) 0);\n+        doubleByteSegment.set(ValueLayout.JAVA_SHORT, doubleByteSegment.byteSize() - Short.BYTES, (short) 0);\n+        quadByteSegment.set(ValueLayout.JAVA_INT, quadByteSegment.byteSize() - Integer.BYTES, 0);\n+        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+                asSlice(1);\n+        MemorySegment.copy(singleByteSegment, 0, singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+    }\n+\n+    @Benchmark\n+    public int legacySingleByte() {\n+        return legacy_strlen_byte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int legacySingleByteMisaligned() {\n+        return legacy_strlen_byte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int legacyDoubleByte() {\n+        return legacy_strlen_short(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int legacyQuadByte() {\n+        return legacy_strlen_int(quadByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int newSingleByte() {\n+        return chunkedStrlenByte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int newSingleByteMisaligned() {\n+        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int newDoubleByte() {\n+        return chunkedStrlenShort(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int newQuadByte() {\n+        return strlenInt(quadByteSegment, 0);\n+    }\n+\n+    \/\/ These are the legacy methods\n+\n+    private static int legacy_strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"}]}