{"files":[{"patch":"@@ -45,3 +45,3 @@\n-            case SINGLE_BYTE -> readFast_byte(segment, offset, charset);\n-            case DOUBLE_BYTE -> readFast_short(segment, offset, charset);\n-            case QUAD_BYTE -> readFast_int(segment, offset, charset);\n+            case SINGLE_BYTE -> readByte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readShort(segment, offset, charset);\n+            case QUAD_BYTE -> readInt(segment, offset, charset);\n@@ -53,3 +53,3 @@\n-            case SINGLE_BYTE -> writeFast_byte(segment, offset, charset, string);\n-            case DOUBLE_BYTE -> writeFast_short(segment, offset, charset, string);\n-            case QUAD_BYTE -> writeFast_int(segment, offset, charset, string);\n+            case SINGLE_BYTE -> writeByte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeShort(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeInt(segment, offset, charset, string);\n@@ -59,2 +59,4 @@\n-    private static String readFast_byte(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunked_strlen_byte(segment, offset);\n+    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n+        long len = segment.isNative()\n+                ? chunkedStrlenByte(segment, offset)\n+                : strlenByte(segment, offset); \/\/ Heap segments might not be 64-bit aligned\n@@ -66,1 +68,1 @@\n-    private static void writeFast_byte(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -72,2 +74,4 @@\n-    private static String readFast_short(MemorySegment segment, long offset, Charset charset) {\n-        long len = chunked_strlen_short(segment, offset);\n+    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n+        long len = segment.isNative()\n+                ? chunkedStrlenShort(segment, offset)\n+                : strlenShort(segment, offset); \/\/ Heap segments might not be 64-bit aligned\n@@ -79,1 +83,1 @@\n-    private static void writeFast_short(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -85,2 +89,2 @@\n-    private static String readFast_int(MemorySegment segment, long offset, Charset charset) {\n-        long len = strlen_int(segment, offset);\n+    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlenInt(segment, offset);\n@@ -92,1 +96,1 @@\n-    private static void writeFast_int(MemorySegment segment, long offset, Charset charset, String string) {\n+    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n@@ -120,1 +124,1 @@\n-    public static int chunked_strlen_byte(MemorySegment segment, long start) {\n+    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n@@ -150,1 +154,1 @@\n-        return requireWithinArraySize((long) offset + strlen_byte(segment, start + offset));\n+        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n@@ -193,1 +197,1 @@\n-    private static int strlen_byte(MemorySegment segment, long start) {\n+    private static int strlenByte(MemorySegment segment, long start) {\n@@ -209,1 +213,1 @@\n-     * @see #chunked_strlen_byte(MemorySegment, long) for more information\n+     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n@@ -216,1 +220,1 @@\n-    public static int chunked_strlen_short(MemorySegment segment, long start) {\n+    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n@@ -246,1 +250,1 @@\n-        return requireWithinArraySize((long) offset + strlen_short(segment, start + offset));\n+        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n@@ -249,7 +253,2 @@\n-    private static int strlen_short(MemorySegment segment, long start) {\n-        \/\/ Do an initial read using aligned semantics.\n-        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n-        if (segment.get(JAVA_SHORT, start) == (short)0) {\n-            return 0;\n-        }\n-        for (int offset = Short.BYTES; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+    private static int strlenShort(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n@@ -265,7 +264,3 @@\n-    public static int strlen_int(MemorySegment segment, long start) {\n-        \/\/ Do an initial read using aligned semantics.\n-        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n-        if (segment.get(JAVA_INT, start) == 0) {\n-            return 0;\n-        }\n-        for (int offset = Integer.BYTES; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+    \/\/ so, there is only one method for ints.\n+    public static int strlenInt(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":30,"deletions":35,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Objects;\n@@ -65,2 +66,12 @@\n-                try (Arena arena = Arena.ofConfined()) {\n-                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                for (Arena arena : arenas()) {\n+                    try (arena) {\n+                        System.out.println(\"arena = \" + arena);\n+                        MemorySegment text = arena.allocateFrom(testString, charset);\n+\n+                        int terminatorSize = \"\\0\".getBytes(charset).length;\n+                        if (charset == StandardCharsets.UTF_16) {\n+                            terminatorSize -= 2; \/\/ drop BOM\n+                        }\n+                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n@@ -68,7 +79,3 @@\n-                    int terminatorSize = \"\\0\".getBytes(charset).length;\n-                    if (charset == StandardCharsets.UTF_16) {\n-                        terminatorSize -= 2; \/\/ drop BOM\n-                    }\n-                    \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n-                    \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n-                    \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+                        int expectedByteLength =\n+                                testString.getBytes(charset).length +\n+                                        terminatorSize;\n@@ -76,3 +83,1 @@\n-                    int expectedByteLength =\n-                            testString.getBytes(charset).length +\n-                            terminatorSize;\n+                        assertEquals(text.byteSize(), expectedByteLength);\n@@ -80,5 +85,4 @@\n-                    assertEquals(text.byteSize(), expectedByteLength);\n-\n-                    String roundTrip = text.getString(0, charset);\n-                    if (charset.newEncoder().canEncode(testString)) {\n-                        assertEquals(roundTrip, testString);\n+                        String roundTrip = text.getString(0, charset);\n+                        if (charset.newEncoder().canEncode(testString)) {\n+                            assertEquals(roundTrip, testString);\n+                        }\n@@ -93,0 +97,1 @@\n+\n@@ -96,3 +101,4 @@\n-            try (Arena arena = Arena.ofConfined()) {\n-                MemorySegment text = arena.allocateFrom(testString, charset);\n-                text = toHeapSegment(text);\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                    text = toHeapSegment(text);\n@@ -100,2 +106,2 @@\n-                int expectedByteLength =\n-                        testString.getBytes(charset).length + 1;\n+                    int expectedByteLength =\n+                            testString.getBytes(charset).length + 1;\n@@ -103,1 +109,1 @@\n-                assertEquals(text.byteSize(), expectedByteLength);\n+                    assertEquals(text.byteSize(), expectedByteLength);\n@@ -105,3 +111,4 @@\n-                String roundTrip = text.getString(0, charset);\n-                if (charset.newEncoder().canEncode(testString)) {\n-                    assertEquals(roundTrip, testString);\n+                    String roundTrip = text.getString(0, charset);\n+                    if (charset.newEncoder().canEncode(testString)) {\n+                        assertEquals(roundTrip, testString);\n+                    }\n@@ -173,11 +180,13 @@\n-            try (var arena = Arena.ofConfined()) {\n-                var segment = arena.allocate(len, 4);\n-                var arr = new byte[len];\n-                random.nextBytes(arr);\n-                segment.copyFrom(MemorySegment.ofArray(arr));\n-                int terminatorIndex = random.nextInt(len);\n-                segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n-                for (Charset charset : singleByteCharsets()) {\n-                    var s = segment.getString(0, charset);\n-                    var ref = referenceImpl(segment, 0, charset);\n-                    assertEquals(s, ref);\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    var segment = arena.allocate(len, 4);\n+                    var arr = new byte[len];\n+                    random.nextBytes(arr);\n+                    segment.copyFrom(MemorySegment.ofArray(arr));\n+                    int terminatorIndex = random.nextInt(len);\n+                    segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n+                    for (Charset charset : singleByteCharsets()) {\n+                        var s = segment.getString(0, charset);\n+                        var ref = referenceImpl(segment, 0, charset);\n+                        assertEquals(s, ref);\n+                    }\n@@ -189,1 +198,0 @@\n-\n@@ -196,5 +204,7 @@\n-            try (Arena arena = Arena.ofConfined()) {\n-                MemorySegment inSegment = arena.allocateFrom(testString, charset);\n-                for (int i = 0; i < 3; i++) {\n-                    String actual = inSegment.getString(i, charset);\n-                    assertEquals(actual, testString.substring(i));\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment inSegment = arena.allocateFrom(testString, charset);\n+                    for (int i = 0; i < 3; i++) {\n+                        String actual = inSegment.getString(i, charset);\n+                        assertEquals(actual, testString.substring(i));\n+                    }\n@@ -289,1 +299,1 @@\n-                seg.fill((byte)1);\n+                seg.fill((byte) 1);\n@@ -302,1 +312,1 @@\n-    private final Random deterministicRandom() {\n+    private Random deterministicRandom() {\n@@ -322,1 +332,1 @@\n-                        int actual = StringSupport.chunked_strlen_byte(segment, j);\n+                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n@@ -346,1 +356,1 @@\n-                        int actual = StringSupport.chunked_strlen_short(segment, j * Short.BYTES);\n+                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n@@ -370,1 +380,1 @@\n-                        int actual = StringSupport.strlen_int(segment, j * Integer.BYTES);\n+                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n@@ -450,0 +460,57 @@\n+    private static List<Arena> arenas() {\n+        return Arrays.asList(\n+                Arena.ofConfined(),          \/\/ Native memory\n+                new HeapArena(byte.class),   \/\/ Heap memory backed by a byte array\n+                new HeapArena(short.class),  \/\/ Heap memory backed by a short array\n+                new HeapArena(int.class),    \/\/ Heap memory backed by an int array\n+                new HeapArena(long.class));  \/\/ Heap memory backed by a long array\n+    }\n+\n+    private static final class HeapArena implements Arena {\n+\n+        private final Class<?> type;\n+        private final Arena delegate;\n+\n+        public HeapArena(Class<?> type) {\n+            if (!type.isPrimitive()) {\n+                throw new IllegalArgumentException(type.toString());\n+            }\n+            this.type = type;\n+            this.delegate = Arena.ofConfined();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            var seg = switch (type) {\n+                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[Math.toIntExact(byteSize)]);\n+                case Class<?> c when short.class.equals(c) ->\n+                        MemorySegment.ofArray(new short[1 + Math.toIntExact(byteSize \/ Short.BYTES)]);\n+                case Class<?> c when int.class.equals(c) ->\n+                        MemorySegment.ofArray(new int[1 + Math.toIntExact(byteSize \/ Integer.BYTES)]);\n+                case Class<?> c when long.class.equals(c) ->\n+                        MemorySegment.ofArray(new long[1 + Math.toIntExact(byteSize \/ Long.BYTES)]);\n+                default -> throw new IllegalArgumentException();\n+            };\n+            seg = seg.asSlice(0, byteSize);\n+            return seg;\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return delegate.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"HeapArena{\" +\n+                    \"type=\" + type +\n+                    \", delegate=\" + delegate +\n+                    '}';\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":115,"deletions":48,"binary":false,"changes":163,"status":"modified"}]}