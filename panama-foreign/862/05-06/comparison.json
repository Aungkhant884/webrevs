{"files":[{"patch":"@@ -108,0 +108,1 @@\n+        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,3 +60,1 @@\n-        long len = segment.isNative() ||\n-                segment instanceof HeapMemorySegmentImpl.OfLong ||\n-                segment instanceof HeapMemorySegmentImpl.OfDouble\n+        long len = canUseChunkedAccess(segment)\n@@ -77,3 +75,1 @@\n-        long len = segment.isNative() ||\n-                segment instanceof HeapMemorySegmentImpl.OfLong ||\n-                segment instanceof HeapMemorySegmentImpl.OfDouble\n+        long len = canUseChunkedAccess(segment)\n@@ -106,0 +102,6 @@\n+    private static boolean canUseChunkedAccess(MemorySegment segment) {\n+        return segment.isNative() ||\n+                segment instanceof HeapMemorySegmentImpl.OfLong ||\n+                segment instanceof HeapMemorySegmentImpl.OfDouble;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -43,1 +44,0 @@\n-import java.util.Objects;\n@@ -68,1 +68,0 @@\n-                        System.out.println(\"arena = \" + arena);\n@@ -182,1 +181,1 @@\n-                    var segment = arena.allocate(len, 4);\n+                    var segment = arena.allocate(len, 1);\n@@ -439,1 +438,0 @@\n-\n@@ -447,1 +445,0 @@\n-\n@@ -471,2 +468,4 @@\n-        private final Class<?> type;\n-        private final Arena delegate;\n+        private static final int ELEMENT_SIZE = 1_000;\n+\n+        private final MemorySegment backingSegment;\n+        private final SegmentAllocator allocator;\n@@ -478,8 +477,2 @@\n-            this.type = type;\n-            this.delegate = Arena.ofConfined();\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long byteSize, long byteAlignment) {\n-            var seg = switch (type) {\n-                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[Math.toIntExact(byteSize)]);\n+            backingSegment = switch (type) {\n+                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[ELEMENT_SIZE]);\n@@ -487,1 +480,1 @@\n-                        MemorySegment.ofArray(new short[1 + Math.toIntExact(byteSize \/ Short.BYTES)]);\n+                        MemorySegment.ofArray(new short[ELEMENT_SIZE]);\n@@ -489,1 +482,1 @@\n-                        MemorySegment.ofArray(new int[1 + Math.toIntExact(byteSize \/ Integer.BYTES)]);\n+                        MemorySegment.ofArray(new int[ELEMENT_SIZE]);\n@@ -491,1 +484,1 @@\n-                        MemorySegment.ofArray(new long[1 + Math.toIntExact(byteSize \/ Long.BYTES)]);\n+                        MemorySegment.ofArray(new long[ELEMENT_SIZE]);\n@@ -494,2 +487,6 @@\n-            seg = seg.asSlice(0, byteSize);\n-            return seg;\n+            allocator = SegmentAllocator.slicingAllocator(backingSegment);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n@@ -500,1 +497,1 @@\n-            return delegate.scope();\n+            return backingSegment.scope();\n@@ -505,1 +502,1 @@\n-            delegate.close();\n+            \/\/ Do nothing\n@@ -511,2 +508,1 @@\n-                    \"type=\" + type +\n-                    \", delegate=\" + delegate +\n+                    \"type=\" + backingSegment.heapBase().orElseThrow().getClass().getName() +\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static jdk.internal.foreign.StringSupport.*;\n@@ -52,1 +53,1 @@\n-@Fork(value = 3, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"}, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n@@ -64,2 +65,0 @@\n-    \/\/ Todo: The segment might not be aligned to the element size? E.g. a short might be byte aligned\n-\n@@ -107,2 +106,0 @@\n-    \/\/\n-\n@@ -111,1 +108,1 @@\n-        return chunked_strlen_byte(singleByteSegment, 0);\n+        return chunkedStrlenByte(singleByteSegment, 0);\n@@ -116,1 +113,1 @@\n-        return chunked_strlen_byte(singleByteSegmentMisaligned, 0);\n+        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n@@ -121,1 +118,1 @@\n-        return chunked_strlen_short(doubleByteSegment, 0);\n+        return chunkedStrlenShort(doubleByteSegment, 0);\n@@ -126,154 +123,1 @@\n-        return strlen_int(quadByteSegment, 0);\n-    }\n-\n-    \/\/ New methods\n-\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero byte in the provided {@code segment}}\n-     * <p>\n-     * The method divides the region of interest into three distinct regions:\n-     * <ul>\n-     *     <li>head (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n-     *     <li>body (long aligned access handling eight bytes at a time) (if any)<\/li>\n-     *     <li>tail (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n-     * <\/ul>\n-     * <p>\n-     * The body is using a heuristic method to determine if a long word\n-     * contains a zero byte. The method might have false positives but\n-     * never false negatives.\n-     * <p>\n-     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero bytes\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    private static int chunked_strlen_byte(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int) remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroByte(curr)) {\n-                for (int j = 0; j < 8; j++) {\n-                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlen_byte(segment, start + offset));\n-    }\n-\n-    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n-       the \"holes\".  Note that there is a hole just to the left of\n-       each byte, with an extra at the end:\n-\n-       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n-       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n-\n-       The 1-bits make sure that carries propagate to the next 0-bit.\n-       The 0-bits provide holes for carries to fall into.\n-    *\/\n-    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n-    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n-\n-    static boolean mightContainZeroByte(long l) {\n-        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n-    }\n-\n-    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n-    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n-\n-    static boolean mightContainZeroShort(long l) {\n-        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n-    }\n-\n-    static int requireWithinArraySize(long size) {\n-        if (size > SOFT_MAX_ARRAY_LENGTH) {\n-            throw newIaeStringTooLarge();\n-        }\n-        return (int) size;\n-    }\n-\n-    static int bodyCount(long remaining) {\n-        return (int) Math.min(\n-                \/\/ Make sure we do not wrap around\n-                Integer.MAX_VALUE - Long.BYTES,\n-                \/\/ Remaining bytes to consider\n-                remaining)\n-                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n-    }\n-\n-    private static int strlen_byte(MemorySegment segment, long start) {\n-        for (int offset = 0; offset < SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n-    \/**\n-     * {@return the shortest distance beginning at the provided {@code start}\n-     *  to the encountering of a zero short in the provided {@code segment}}\n-     * <p>\n-     * Note: The inspected region must be short aligned.\n-     *\n-     * @see #chunked_strlen_byte(MemorySegment, long) for more information\n-     *\n-     * @param segment to examine\n-     * @param start   from where examination shall begin\n-     * @throws IllegalArgumentException if the examined region contains no zero shorts\n-     *                                  within a length that can be accepted by a String\n-     *\/\n-    private static int chunked_strlen_short(MemorySegment segment, long start) {\n-\n-        \/\/ Handle the first unaligned \"head\" bytes separately\n-        int headCount = (int)remainsToAlignment(segment.address() + start, Long.BYTES);\n-\n-        int offset = 0;\n-        for (; offset < headCount; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-\n-        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n-        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n-\n-        for (; offset < bodyCount; offset += Long.BYTES) {\n-            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n-            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n-            \/\/ Is this a candidate?\n-            if (mightContainZeroShort(curr)) {\n-                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n-                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n-                        return offset + j;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Handle the \"tail\"\n-        return requireWithinArraySize((long) offset + strlen_short(segment, start + offset));\n+        return strlenInt(quadByteSegment, 0);\n@@ -282,38 +126,0 @@\n-    private static int strlen_short(MemorySegment segment, long start) {\n-        \/\/ Do an initial read using aligned semantics.\n-        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n-        if (segment.get(JAVA_SHORT, start) == (short)0) {\n-            return 0;\n-        }\n-        for (int offset = Short.BYTES; offset < SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n-            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n-            if (curr == (short)0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n-    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n-    private static int strlen_int(MemorySegment segment, long start) {\n-        \/\/ Do an initial read using aligned semantics.\n-        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n-        if (segment.get(JAVA_INT, start) == 0) {\n-            return 0;\n-        }\n-        for (int offset = Integer.BYTES; offset < SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n-            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n-            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw newIaeStringTooLarge();\n-    }\n-\n-    private static IllegalArgumentException newIaeStringTooLarge() {\n-        return new IllegalArgumentException(\"String too large\");\n-    }\n-\n-    public static final int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":6,"deletions":200,"binary":false,"changes":206,"status":"modified"}]}