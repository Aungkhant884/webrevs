{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -30,2 +31,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n@@ -33,1 +32,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -36,1 +34,0 @@\n-import java.util.Objects;\n@@ -38,4 +35,1 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -48,16 +42,0 @@\n-    \/\/ Maximum segment byte size for which a critical method will be invoked.\n-    private static final long MAX_CRITICAL_SIZE = 1024L;\n-    private static final MethodHandle STRNLEN_CRITICAL;\n-    private static final MethodHandle STRNLEN;\n-    private static final boolean SIZE_T_IS_INT;\n-\n-    static {\n-        var size_t = Objects.requireNonNull(Linker.nativeLinker().canonicalLayouts().get(\"size_t\"));\n-        Linker linker = Linker.nativeLinker();\n-        var strnlen = linker.defaultLookup().find(\"strnlen\").orElseThrow();\n-        var description = FunctionDescriptor.of(size_t, ADDRESS, size_t);\n-\n-        STRNLEN_CRITICAL = linker.downcallHandle(strnlen, description, Linker.Option.critical());\n-        STRNLEN = linker.downcallHandle(strnlen, description);\n-        SIZE_T_IS_INT = (size_t.byteSize() == Integer.BYTES);\n-    }\n@@ -83,1 +61,1 @@\n-        long len = native_strlen_byte(segment, offset);\n+        long len = chunked_strlen_byte(segment, offset);\n@@ -96,1 +74,1 @@\n-        long len = strlen_short(segment, offset);\n+        long len = chunked_strlen_short(segment, offset);\n@@ -121,5 +99,23 @@\n-    private static int native_strlen_byte(MemorySegment segment, long start) {\n-        \/\/ Heap segments must be handled by Java code\n-        if (!segment.isNative()) {\n-            return strlen_byte(segment, start);\n-        }\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * <p>\n+     * The method divides the region of interest into three distinct regions:\n+     * <ul>\n+     *     <li>head (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n+     *     <li>body (long aligned access handling eight bytes at a time) (if any)<\/li>\n+     *     <li>tail (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The body is using a heuristic method to determine if a long word\n+     * contains a zero byte. The method might have false positives but\n+     * never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunked_strlen_byte(MemorySegment segment, long start) {\n@@ -127,3 +123,2 @@\n-        if (start > 0) {\n-            segment = segment.asSlice(start);\n-        }\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n@@ -131,12 +126,5 @@\n-        long segmentSize = segment.byteSize();\n-        final long len;\n-        if (SIZE_T_IS_INT) {\n-            if (segmentSize < MAX_CRITICAL_SIZE) {\n-                len = strnlen_int_critical(segment, segmentSize);\n-            } else if (segmentSize < Integer.MAX_VALUE * 2L) { \/\/ size_t is unsigned\n-                len = strnlen_int(segment, segmentSize);\n-            } else {\n-                \/\/ There is no way to express the max size in the native method using an int so, revert\n-                \/\/ to a Java method. It is possible to use a reduction of several STRNLEN invocations\n-                \/\/ in a future optimization.\n-                len = strlen_byte(segment, 0);\n+        int offset = 0;\n+        for (; offset < headCount; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n@@ -144,4 +132,0 @@\n-        } else {\n-            len = segmentSize < MAX_CRITICAL_SIZE\n-                    ? strnlen_long_critical(segment, segmentSize)\n-                    : strnlen_long(segment, segmentSize);\n@@ -149,2 +133,15 @@\n-        if (len > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n-            throw newIaeStringTooLarge();\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroByte(curr)) {\n+                for (int j = 0; j < 8; j++) {\n+                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n@@ -152,1 +149,3 @@\n-        return (int)len;\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlen_byte(segment, start + offset));\n@@ -155,8 +154,15 @@\n-    static long strnlen_int_critical(MemorySegment segment, long size) {\n-        try {\n-            return Integer.toUnsignedLong((int)STRNLEN_CRITICAL.invokeExact(segment, (int)size));\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n-        }\n+    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+       the \"holes\".  Note that there is a hole just to the left of\n+       each byte, with an extra at the end:\n+\n+       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+       The 1-bits make sure that carries propagate to the next 0-bit.\n+       The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n@@ -165,8 +171,5 @@\n-    static long strnlen_int(MemorySegment segment, long size) {\n-        try {\n-            return Integer.toUnsignedLong((int)STRNLEN.invokeExact(segment, (int)size));\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n-        }\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n@@ -175,7 +178,3 @@\n-    static long strnlen_long_critical(MemorySegment segment, long size) {\n-        try {\n-            return (long)STRNLEN_CRITICAL.invokeExact(segment, size);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n+    static int requireWithinArraySize(long size) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n@@ -183,0 +182,1 @@\n+        return (int) size;\n@@ -185,8 +185,7 @@\n-    static long strnlen_long(MemorySegment segment, long size) {\n-        try {\n-            return (long)STRNLEN.invokeExact(segment, size);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new IllegalArgumentException(e);\n-        }\n+    static int bodyCount(long remaining) {\n+        return (int) Math.min(\n+                \/\/ Make sure we do not wrap around\n+                Integer.MAX_VALUE - Long.BYTES,\n+                \/\/ Remaining bytes to consider\n+                remaining)\n+                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n@@ -196,2 +195,1 @@\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 1) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n@@ -206,3 +204,20 @@\n-    private static int strlen_short(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 2) {\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero short in the provided {@code segment}}\n+     * <p>\n+     * Note: The inspected region must be short aligned.\n+     *\n+     * @see #chunked_strlen_byte(MemorySegment, long) for more information\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero shorts\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunked_strlen_short(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset += Short.BYTES) {\n@@ -214,0 +229,33 @@\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroShort(curr)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlen_short(segment, start + offset));\n+    }\n+\n+    private static int strlen_short(MemorySegment segment, long start) {\n+        \/\/ Do an initial read using aligned semantics.\n+        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n+        if (segment.get(JAVA_SHORT, start) == (short)0) {\n+            return 0;\n+        }\n+        for (int offset = Short.BYTES; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n+            if (curr == (short)0) {\n+                return offset;\n+            }\n+        }\n@@ -217,4 +265,10 @@\n-    private static int strlen_int(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset += 4) {\n-            int curr = segment.get(JAVA_INT, start + offset);\n+    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n+    public static int strlen_int(MemorySegment segment, long start) {\n+        \/\/ Do an initial read using aligned semantics.\n+        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n+        if (segment.get(JAVA_INT, start) == 0) {\n+            return 0;\n+        }\n+        for (int offset = Integer.BYTES; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":147,"deletions":93,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -58,1 +57,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -130,0 +128,4 @@\n+    public static long remainsToAlignment(long addr, long alignment) {\n+        return alignUp(addr, alignment) - addr;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -49,2 +50,1 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -55,0 +55,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -77,1 +78,1 @@\n-                            terminatorSize;\n+                                    terminatorSize;\n@@ -194,1 +195,1 @@\n-        for(var charset:singleByteCharsets()) {\n+        for (var charset : singleByteCharsets()) {\n@@ -241,1 +242,1 @@\n-           \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n+            \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n@@ -288,1 +289,1 @@\n-                seg.fill((byte)1);\n+                seg.fill((byte) 1);\n@@ -299,0 +300,78 @@\n+    private static final int TEST_LENGTH_MAX = 277;\n+\n+    private final Random deterministicRandom() {\n+        return new Random(42);\n+    }\n+\n+    @Test\n+    public void chunked_strlen_byte() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew++) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate(len + 1 + skew)\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        byte value;\n+                        while ((value = (byte) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_BYTE, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_BYTE, len, (byte) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunked_strlen_byte(segment, j);\n+                        assertEquals(actual, len - j);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void chunked_strlen_short() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Short.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Short.BYTES + skew, JAVA_SHORT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        short value;\n+                        while ((value = (short) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_SHORT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_SHORT, len, (short) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunked_strlen_short(segment, j * Short.BYTES);\n+                        assertEquals(actual, (len - j) * Short.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void strlen_int() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Integer.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Integer.BYTES + skew, JAVA_INT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        int value;\n+                        while ((value = random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_INT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_INT, len, 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.strlen_int(segment, j * Integer.BYTES);\n+                        assertEquals(actual, (len - j) * Integer.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":85,"deletions":6,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -0,0 +1,410 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/*\n+Mac M1, Arm\n+Benchmark                                  (size)  Mode  Cnt    Score   Error  Units\n+InternalStrLen.legacyDoubleByte                 1  avgt   30    1.899 ? 0.018  ns\/op\n+InternalStrLen.legacyDoubleByte                 4  avgt   30    3.784 ? 0.016  ns\/op\n+InternalStrLen.legacyDoubleByte                16  avgt   30   11.334 ? 0.090  ns\/op\n+InternalStrLen.legacyDoubleByte               251  avgt   30  165.397 ? 0.529  ns\/op\n+InternalStrLen.legacyDoubleByte              1024  avgt   30  648.698 ? 2.378  ns\/op\n+InternalStrLen.legacyQuadByte                   1  avgt   30    1.875 ? 0.006  ns\/op\n+InternalStrLen.legacyQuadByte                   4  avgt   30    3.754 ? 0.016  ns\/op\n+InternalStrLen.legacyQuadByte                  16  avgt   30   11.237 ? 0.026  ns\/op\n+InternalStrLen.legacyQuadByte                 251  avgt   30  166.247 ? 1.045  ns\/op\n+InternalStrLen.legacyQuadByte                1024  avgt   30  647.522 ? 1.655  ns\/op\n+InternalStrLen.legacySingleByte                 1  avgt   30    1.580 ? 0.017  ns\/op\n+InternalStrLen.legacySingleByte                 4  avgt   30    3.752 ? 0.753  ns\/op\n+InternalStrLen.legacySingleByte                16  avgt   30    8.589 ? 0.022  ns\/op\n+InternalStrLen.legacySingleByte               251  avgt   30  125.007 ? 0.424  ns\/op\n+InternalStrLen.legacySingleByte              1024  avgt   30  488.003 ? 2.353  ns\/op\n+InternalStrLen.legacySingleByteMisaligned       1  avgt   30    1.563 ? 0.005  ns\/op\n+InternalStrLen.legacySingleByteMisaligned       4  avgt   30    2.968 ? 0.009  ns\/op\n+InternalStrLen.legacySingleByteMisaligned      16  avgt   30    8.583 ? 0.023  ns\/op\n+InternalStrLen.legacySingleByteMisaligned     251  avgt   30  125.197 ? 0.712  ns\/op\n+InternalStrLen.legacySingleByteMisaligned    1024  avgt   30  487.469 ? 1.375  ns\/op\n+InternalStrLen.newDoubleByte                    1  avgt   30    2.033 ? 0.006  ns\/op\n+InternalStrLen.newDoubleByte                    4  avgt   30    4.065 ? 0.018  ns\/op\n+InternalStrLen.newDoubleByte                   16  avgt   30    5.943 ? 0.017  ns\/op\n+InternalStrLen.newDoubleByte                  251  avgt   30   28.519 ? 0.076  ns\/op\n+InternalStrLen.newDoubleByte                 1024  avgt   30   71.109 ? 0.271  ns\/op\n+InternalStrLen.newQuadByte                      1  avgt   30    1.576 ? 0.014  ns\/op\n+InternalStrLen.newQuadByte                      4  avgt   30    3.788 ? 0.012  ns\/op\n+InternalStrLen.newQuadByte                     16  avgt   30    6.902 ? 0.028  ns\/op\n+InternalStrLen.newQuadByte                    251  avgt   30   47.852 ? 0.212  ns\/op\n+InternalStrLen.newQuadByte                   1024  avgt   30  194.088 ? 1.644  ns\/op\n+InternalStrLen.newSingleByte                    1  avgt   30    1.886 ? 0.006  ns\/op\n+InternalStrLen.newSingleByte                    4  avgt   30    4.084 ? 0.018  ns\/op\n+InternalStrLen.newSingleByte                   16  avgt   30    5.337 ? 0.018  ns\/op\n+InternalStrLen.newSingleByte                  251  avgt   30   22.275 ? 0.287  ns\/op\n+InternalStrLen.newSingleByte                 1024  avgt   30   38.859 ? 0.229  ns\/op\n+InternalStrLen.newSingleByteMisaligned          1  avgt   30    1.754 ? 0.018  ns\/op\n+InternalStrLen.newSingleByteMisaligned          4  avgt   30    7.204 ? 0.042  ns\/op\n+InternalStrLen.newSingleByteMisaligned         16  avgt   30    9.692 ? 0.237  ns\/op\n+InternalStrLen.newSingleByteMisaligned        251  avgt   30   27.572 ? 0.100  ns\/op\n+InternalStrLen.newSingleByteMisaligned       1024  avgt   30   44.960 ? 2.210  ns\/op\n+ *\/\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"}, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class InternalStrLen {\n+\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n+\n+    @Param({\"1\", \"4\", \"16\", \"251\", \"1024\"})\n+    \/\/ @Param({\"4\", \"251\"})\n+    int size;\n+\n+    \/\/ Todo: The segment might not be aligned to the element size? E.g. a short might be byte aligned\n+\n+    @Setup\n+    public void setup() {\n+        singleByteSegment = Arena.ofAuto().allocate((size + 1L) * Byte.BYTES);\n+        singleByteSegmentMisaligned = Arena.ofAuto().allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = Arena.ofAuto().allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = Arena.ofAuto().allocate((size + 1L) * Integer.BYTES);\n+        Stream.of(singleByteSegment, doubleByteSegment, quadByteSegment)\n+                .forEach(s -> IntStream.range(0, (int) s.byteSize() - 1)\n+                        .forEach(i -> s.set(\n+                                ValueLayout.JAVA_BYTE,\n+                                i,\n+                                (byte) ThreadLocalRandom.current().nextInt(1, 254)\n+                        )));\n+        singleByteSegment.set(ValueLayout.JAVA_BYTE, singleByteSegment.byteSize() - Byte.BYTES, (byte) 0);\n+        doubleByteSegment.set(ValueLayout.JAVA_SHORT, doubleByteSegment.byteSize() - Short.BYTES, (short) 0);\n+        quadByteSegment.set(ValueLayout.JAVA_INT, quadByteSegment.byteSize() - Integer.BYTES, 0);\n+        singleByteSegmentMisaligned = Arena.ofAuto().allocate(singleByteSegment.byteSize() + 1).\n+                asSlice(1);\n+        MemorySegment.copy(singleByteSegment, 0, singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+    }\n+\n+    @Benchmark\n+    public int legacySingleByte() {\n+        return legacy_strlen_byte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int legacySingleByteMisaligned() {\n+        return legacy_strlen_byte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int legacyDoubleByte() {\n+        return legacy_strlen_short(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int legacyQuadByte() {\n+        return legacy_strlen_int(quadByteSegment, 0);\n+    }\n+\n+    \/\/\n+\n+    @Benchmark\n+    public int newSingleByte() {\n+        return chunked_strlen_byte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int newSingleByteMisaligned() {\n+        return chunked_strlen_byte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int newDoubleByte() {\n+        return chunked_strlen_short(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int newQuadByte() {\n+        return strlen_int(quadByteSegment, 0);\n+    }\n+\n+    \/\/ New methods\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * <p>\n+     * The method divides the region of interest into three distinct regions:\n+     * <ul>\n+     *     <li>head (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n+     *     <li>body (long aligned access handling eight bytes at a time) (if any)<\/li>\n+     *     <li>tail (un-aligned access handling on a byte-by-byte basis) (if any)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The body is using a heuristic method to determine if a long word\n+     * contains a zero byte. The method might have false positives but\n+     * never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    private static int chunked_strlen_byte(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int) remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroByte(curr)) {\n+                for (int j = 0; j < 8; j++) {\n+                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlen_byte(segment, start + offset));\n+    }\n+\n+    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+       the \"holes\".  Note that there is a hole just to the left of\n+       each byte, with an extra at the end:\n+\n+       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+       The 1-bits make sure that carries propagate to the next 0-bit.\n+       The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n+    }\n+\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n+    }\n+\n+    static int requireWithinArraySize(long size) {\n+        if (size > SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n+        }\n+        return (int) size;\n+    }\n+\n+    static int bodyCount(long remaining) {\n+        return (int) Math.min(\n+                \/\/ Make sure we do not wrap around\n+                Integer.MAX_VALUE - Long.BYTES,\n+                \/\/ Remaining bytes to consider\n+                remaining)\n+                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n+    }\n+\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero short in the provided {@code segment}}\n+     * <p>\n+     * Note: The inspected region must be short aligned.\n+     *\n+     * @see #chunked_strlen_byte(MemorySegment, long) for more information\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero shorts\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    private static int chunked_strlen_short(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroShort(curr)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlen_short(segment, start + offset));\n+    }\n+\n+    private static int strlen_short(MemorySegment segment, long start) {\n+        \/\/ Do an initial read using aligned semantics.\n+        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n+        if (segment.get(JAVA_SHORT, start) == (short)0) {\n+            return 0;\n+        }\n+        for (int offset = Short.BYTES; offset < SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n+            if (curr == (short)0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n+    private static int strlen_int(MemorySegment segment, long start) {\n+        \/\/ Do an initial read using aligned semantics.\n+        \/\/ If this succeeds, we know that all other subsequent reads will be aligned\n+        if (segment.get(JAVA_INT, start) == 0) {\n+            return 0;\n+        }\n+        for (int offset = Integer.BYTES; offset < SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    private static IllegalArgumentException newIaeStringTooLarge() {\n+        return new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    public static final int SOFT_MAX_ARRAY_LENGTH = Integer.MAX_VALUE - 8;\n+\n+    \/\/ These are the legacy methods\n+\n+    private static int legacy_strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+\n+    public static long alignUp(long addr, long alignment) {\n+        return ((addr - 1) | (alignment - 1)) + 1;\n+    }\n+\n+    public static long remainsToAlignment(long addr, long alignment) {\n+        return alignUp(addr, alignment) - addr;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":410,"deletions":0,"binary":false,"changes":410,"status":"added"}]}