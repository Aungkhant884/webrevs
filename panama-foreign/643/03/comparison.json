{"files":[{"patch":"@@ -71,0 +71,21 @@\n+\/*\n+ * To store problematic threads during an handshake, we need an atomic data structure.\n+ * This is because the handshake closure can run concurrently either on the thread that\n+ * is the target of the handshake operation, or on the thread that is performing the\n+ * handshake (e.g. if the target thread is blocked, or in native state).\n+ *\/\n+class LockFreeStackThreadsElement : public CHeapObj<mtInternal> {\n+  typedef LockFreeStackThreadsElement Element;\n+\n+  Element* volatile _next;\n+  static Element* volatile* next_ptr(Element& e) { return &e._next; }\n+\n+public:\n+  JavaThread* _thread;\n+  LockFreeStackThreadsElement(JavaThread* thread) : _next(nullptr), _thread(thread) {}\n+  typedef LockFreeStack<Element, &next_ptr> ThreadStack;\n+};\n+\n+typedef LockFreeStackThreadsElement::ThreadStack ThreadStack;\n+typedef LockFreeStackThreadsElement ThreadStackElement;\n+\n@@ -73,0 +94,1 @@\n+  ThreadStack *_threads;\n@@ -75,3 +97,1 @@\n-  jboolean _found;\n-\n-  CloseScopedMemoryClosure(jobject deopt)\n+  CloseScopedMemoryClosure(jobject deopt, ThreadStack *threads)\n@@ -80,1 +100,1 @@\n-    , _found(false) {}\n+    , _threads(threads) {}\n@@ -123,1 +143,2 @@\n-              _found = true;\n+              ThreadStackElement *element = new ThreadStackElement(jt);\n+              _threads->push(*element);\n@@ -141,6 +162,11 @@\n- * This function issues a global handshake operation with all\n- * Java threads. This is useful for implementing asymmetric\n- * dekker synchronization schemes, where expensive synchronization\n- * in performance sensitive common paths, may be shifted to\n- * a less common slow path instead.\n- * Top frames containg obj will be deoptimized.\n+ * This functin performs a thread-local handshake against all threads running at the time\n+ * the given scope (deopt) was closed. If the handshake closure finds that a thread has\n+ * safepointed inside a scoped method (that is, a method inside the ScopedMemoryAccess class\n+ * annotated with the '@Scoped' annotation), whose local variables mention the scope being closed\n+ * (deopt), the thread is added to a problematic stack. After the handshake, each thread in\n+ * the problematic stack is handshaked again, individually, to check that it has exited\n+ * the scoped method. This should happen quickly, because once we find a problematic\n+ * thread, we also deoptimize it, meaning that when the thread resumes execution, it should\n+ * also see the updated scope state. This function returns when the stack of problematic\n+ * threads is empty. To prevent premature thread termination we take a snapshot of the live\n+ * threads in the system using a ThreadsListHandle.\n@@ -148,2 +174,4 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt))\n-  CloseScopedMemoryClosure cl(deopt);\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt))\n+  ThreadStack threads;\n+  CloseScopedMemoryClosure cl(deopt, &threads);\n+  \/\/ do a first handshake and collect all problematic threads\n@@ -151,1 +179,18 @@\n-  return !cl._found;\n+  if (threads.empty()) {\n+    \/\/ fast-path: return if no problematic thread is found\n+    return;\n+  }\n+  \/\/ now iterate on all problematic threads, until we converge\n+  ThreadsListHandle tlh;\n+  ThreadStackElement *element = threads.pop();\n+  while (element != NULL) {\n+    JavaThread* thread = element->_thread;\n+    \/\/ if the thread is not in the list handle, we can safely skip further handshakes,\n+    \/\/ as that means that the thread has been created when the scope state has already\n+    \/\/ been set to CLOSED - meaning that the thread access will fail anyway.\n+    if (tlh.list()->includes(thread)) {\n+      Handshake::execute(&cl, thread);\n+    }\n+    delete element;\n+    element = threads.pop();\n+  }\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":59,"deletions":14,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -117,5 +117,4 @@\n- * a resource associated with a shared scope while the scope is being closed from another thread, an exception might occur on both\n- * the accessing and the closing threads. Clients should refrain from attempting to close a shared resource scope repeatedly\n- * (e.g. keep calling {@link #close()} until no exception is thrown). Instead, clients of shared resource scopes\n- * should always ensure that proper synchronization mechanisms (e.g. using temporal dependencies, see below) are put in place\n- * so that threads closing shared resource scopes can never race against threads accessing resources managed by same scopes.\n+ * a resource associated with a shared scope while the scope is being closed from another thread, an exception might occur\n+ * on the accessing thread. Clients of shared resource scopes should always ensure that proper synchronization mechanisms\n+ * (e.g. using temporal dependencies, see below) are put in place so that threads closing shared resource scopes can\n+ * never race against threads accessing resources managed by same scopes.\n@@ -177,1 +176,0 @@\n-     *     <li>this resource scope is shared and a resource associated with this scope is accessed while this method is called<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ResourceScope.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n+    static final int CLOSED = -1;\n@@ -192,1 +191,1 @@\n-        if (state < ALIVE) {\n+        if (state == CLOSED) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-        int prevState = (int) STATE.compareAndExchange(this, ALIVE, CLOSING);\n-        if (prevState < 0) {\n+        int prevState = (int) STATE.compareAndExchange(this, ALIVE, CLOSED);\n+        if (prevState == CLOSED) {\n@@ -87,5 +87,1 @@\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : ALIVE);\n-        if (!success) {\n-            throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n-        }\n+        SCOPED_MEMORY_ACCESS.closeScope(this); \/\/ handshake\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+        final AtomicBoolean failed = new AtomicBoolean();\n@@ -105,6 +106,8 @@\n-                    long delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" suspending - elapsed (ms): \" + delay);\n-                    backoff();\n-                    delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" resuming - elapsed (ms): \" + delay);\n-                    continue outer;\n+                    if (!failed.get()) {\n+                        \/\/ ignore - this means segment was alive, but was closed while we were accessing it\n+                        \/\/ next isAlive test should fail\n+                        failed.set(true);\n+                    } else {\n+                        \/\/ rethrow!\n+                        throw ex;\n+                    }\n@@ -249,8 +252,1 @@\n-            while (true) {\n-                try {\n-                    scope.close();\n-                    break;\n-                } catch (IllegalStateException ex) {\n-                    Thread.onSpinWait();\n-                }\n-            }\n+            scope.close(); \/\/ this should NOT throw\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"}]}