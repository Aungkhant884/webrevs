{"files":[{"patch":"@@ -71,0 +71,21 @@\n+\/*\n+ * To store problematic threads during an handshake, we need an atomic data structure.\n+ * This is because the handshake closure can run concurrently either on the thread that\n+ * is the target of the handshake operation, or on the thread that is performing the\n+ * handshake (e.g. if the target thread is blocked, or in native state).\n+ *\/\n+class LockFreeStackThreadsElement : public CHeapObj<mtInternal> {\n+  typedef LockFreeStackThreadsElement Element;\n+\n+  Element* volatile _next;\n+  static Element* volatile* next_ptr(Element& e) { return &e._next; }\n+\n+public:\n+  JavaThread* _thread;\n+  LockFreeStackThreadsElement(JavaThread* thread) : _next(nullptr), _thread(thread) {}\n+  typedef LockFreeStack<Element, &next_ptr> ThreadStack;\n+};\n+\n+typedef LockFreeStackThreadsElement::ThreadStack ThreadStack;\n+typedef LockFreeStackThreadsElement ThreadStackElement;\n+\n@@ -73,0 +94,1 @@\n+  ThreadStack *_threads;\n@@ -75,3 +97,1 @@\n-  jboolean _found;\n-\n-  CloseScopedMemoryClosure(jobject deopt)\n+  CloseScopedMemoryClosure(jobject deopt, ThreadStack *threads)\n@@ -80,1 +100,1 @@\n-    , _found(false) {}\n+    , _threads(threads) {}\n@@ -123,1 +143,2 @@\n-              _found = true;\n+              ThreadStackElement *element = new ThreadStackElement(jt);\n+              _threads->push(*element);\n@@ -141,6 +162,11 @@\n- * This function issues a global handshake operation with all\n- * Java threads. This is useful for implementing asymmetric\n- * dekker synchronization schemes, where expensive synchronization\n- * in performance sensitive common paths, may be shifted to\n- * a less common slow path instead.\n- * Top frames containg obj will be deoptimized.\n+ * This functin performs a thread-local handshake against all threads running at the time\n+ * the given scope (deopt) was closed. If the handshake closure finds that a thread has\n+ * safepointed inside a scoped method (that is, a method inside the ScopedMemoryAccess class\n+ * annotated with the '@Scoped' annotation), whose local variables mention the scope being closed\n+ * (deopt), the thread is added to a problematic stack. After the handshake, each thread in\n+ * the problematic stack is handshaked again, individually, to check that it has exited\n+ * the scoped method. This should happen quickly, because once we find a problematic\n+ * thread, we also deoptimize it, meaning that when the thread resumes execution, it should\n+ * also see the updated scope state. This function returns when the stack of problematic\n+ * threads is empty. To prevent premature thread termination we take a snapshot of the live\n+ * threads in the system using a ThreadsListHandle.\n@@ -148,2 +174,4 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt))\n-  CloseScopedMemoryClosure cl(deopt);\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt))\n+  ThreadStack threads;\n+  CloseScopedMemoryClosure cl(deopt, &threads);\n+  \/\/ do a first handshake and collect all problematic threads\n@@ -151,1 +179,20 @@\n-  return !cl._found;\n+  if (threads.empty()) {\n+    \/\/ fast-path: return if no problematic thread is found\n+    return;\n+  }\n+  \/\/ now iterate on all problematic threads, until we converge. Note: from this point on,\n+  \/\/ we only need to focus on the problematic threads found in the previous step, as\n+  \/\/ any new thread created after the initial handshake will see the scope as CLOSED,\n+  \/\/ and will fail to access memory anyway.\n+  ThreadsListHandle tlh;\n+  ThreadStackElement *element = threads.pop();\n+  while (element != NULL) {\n+    JavaThread* thread = element->_thread;\n+    \/\/ if the thread is not in the list handle, it means that the thread has died,\n+    \/\/ so that we can safely skip further handshakes.\n+    if (tlh.list()->includes(thread)) {\n+      Handshake::execute(&cl, thread);\n+    }\n+    delete element;\n+    element = threads.pop();\n+  }\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":61,"deletions":14,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-     * @throws IllegalStateException this memory session is shared and a resource associated with this session is accessed while this method is called.\n+     * @throws IllegalStateException if this session is {@linkplain #whileAlive(Runnable) kept alive} by another client.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,2 +60,1 @@\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n+    static final int CLOSED = -1;\n@@ -191,1 +190,1 @@\n-        if (state < OPEN) {\n+        if (state == CLOSED) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n-        if (prevState < 0) {\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSED);\n+        if (prevState == CLOSED) {\n@@ -87,5 +87,1 @@\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : OPEN);\n-        if (!success) {\n-            throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n-        }\n+        SCOPED_MEMORY_ACCESS.closeScope(this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+        final AtomicBoolean failed = new AtomicBoolean();\n@@ -249,8 +250,1 @@\n-            while (true) {\n-                try {\n-                    session.close();\n-                    break;\n-                } catch (IllegalStateException ex) {\n-                    Thread.onSpinWait();\n-                }\n-            }\n+            session.close(); \/\/ this should NOT throw\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"}]}