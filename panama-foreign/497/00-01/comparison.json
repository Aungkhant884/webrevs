{"files":[{"patch":"@@ -177,1 +177,1 @@\n- * to a Java method) into a native memory segment (see {@link jdk.incubator.foreign.MemorySegment}), so that Java code\n+ * to a Java method) into a native memory address (see {@link jdk.incubator.foreign.MemoryAddress}), so that Java code\n@@ -200,1 +200,1 @@\n- * Now that we have a method handle instance, we can link it into a fresh native memory segment, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n+ * Now that we have a method handle instance, we can link it into a fresh native memory address, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n@@ -203,1 +203,2 @@\n-MemorySegment comparFunc = CLinker.getInstance().upcallStub(\n+ResourceScope scope = ...\n+MemoryAddress comparFunc = CLinker.getInstance().upcallStub(\n@@ -205,1 +206,2 @@\n-     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER)\n+     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+     scope\n@@ -212,1 +214,3 @@\n- * by the platform C ABI.\n+ * by the platform C ABI. The lifecycle of the memory address returned by\n+ * {@link jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope)}\n+ * is tied to the {@link jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"}]}