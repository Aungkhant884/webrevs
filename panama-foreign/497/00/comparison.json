{"files":[{"patch":"@@ -188,1 +188,1 @@\n-     * Allocates a native segment with given scope which can be passed to other foreign functions (as a function pointer);\n+     * Allocates a native stub with given scope which can be passed to other foreign functions (as a function pointer);\n@@ -192,1 +192,3 @@\n-     * the corresponding native stub will be deallocated.<\/p>\n+     * the corresponding native stub will be deallocated. The returned memory address maintain a strong reference\n+     * to the resource scope parameter; this helps keeping the native stub alive if, for instance,\n+     * an {@link ResourceScope#isImplicit() implicit} resource scope is used.\n@@ -201,1 +203,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n+    MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public static MemorySegment upcallAddress(UpcallHandler handler, ResourceScopeImpl scope) {\n+    public static MemoryAddress upcallAddress(UpcallHandler handler, ResourceScopeImpl scope) {\n@@ -37,1 +37,1 @@\n-                () -> freeUpcallStub(stubAddress), scope);\n+                () -> freeUpcallStub(stubAddress), scope).address();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    public final MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope);\n+                MemoryAddress qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope);\n@@ -302,1 +302,1 @@\n-                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub.address());\n+                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    static MemorySegment dummyStub;\n+    static MemoryAddress dummyStub;\n@@ -192,2 +192,1 @@\n-        MemorySegment stub = abi.upcallStub(mh, func, scope);\n-        return stub.address();\n+        return abi.upcallStub(mh, func, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n+            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestUpcallStubs\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.*;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n-import static org.testng.Assert.assertFalse;\n-\n-public class TestUpcallStubs {\n-\n-    static final CLinker abi = CLinker.getInstance();\n-    static final MethodHandle MH_dummy;\n-\n-    static {\n-        try {\n-            MH_dummy = MethodHandles.lookup()\n-                .findStatic(TestUpcallStubs.class, \"dummy\", MethodType.methodType(void.class));\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new BootstrapMethodError(e);\n-        }\n-    }\n-\n-    private static MemorySegment getStub() {\n-        return abi.upcallStub(MH_dummy, FunctionDescriptor.ofVoid(), ResourceScope.newConfinedScope());\n-    }\n-\n-    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n-    public void testNoAccess() {\n-        MemorySegment stub = getStub();\n-        VarHandle vh = JAVA_INT.varHandle(int.class);\n-        vh.set(stub, 10);\n-        stub.scope().close();\n-    }\n-\n-    @Test\n-    public void testFree() {\n-        MemorySegment stub = getStub();\n-        stub.scope().close();\n-        assertFalse(stub.scope().isAlive());\n-    }\n-\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testAlreadyFreed() {\n-        MemorySegment stub = getStub();\n-        stub.scope().close();\n-        \/\/ should fail\n-        stub.scope().close();\n-    }\n-\n-    @DataProvider\n-    public static Object[][] badAddresses() {\n-        return new Object[][]{\n-            { MemoryAddress.ofLong(42) \/* random address *\/ },\n-            { MemorySegment.ofArray(new int []{ 1, 2, 3 }).address() \/* heap address *\/ }\n-        };\n-    }\n-\n-    \/\/ where\n-    public static void dummy() {}\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStubs.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -91,1 +91,1 @@\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-            MemorySegment stub = abi.upcallStub(callback, desc, scope);\n+            MemoryAddress stub = abi.upcallStub(callback, desc, scope);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}