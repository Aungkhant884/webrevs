{"files":[{"patch":"@@ -30,0 +30,2 @@\n+import java.nio.MappedByteBuffer;\n+\n@@ -32,2 +34,14 @@\n- * and {@link #load(MemorySegment)}. The behavior of the methods in this class might is highly platform-dependent;\n- * as a result, calling these methods might be a no-op on certain platforms.\n+ * and {@link #load(MemorySegment)}. The methods in these class are suitable replacements for some of the\n+ * functionality in the {@link java.nio.MappedByteBuffer} class. Note that, while it is possible to map a segment\n+ * into a byte buffer (see {@link MemorySegment#asByteBuffer()}), and call e.g. {@link MappedByteBuffer#force()} that way,\n+ * this can only be done when the source segment is small enough, due to the size limitation inherent to the\n+ * ByteBuffer API.\n+ * <p>\n+ * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n+ * custom mapped memory segment factories; using JNI, e.g. on Linux, it is possible to call {@code mmap}\n+ * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)}.\n+ *\n+ * @implNote\n+ * The behavior of the methods in this class is highly platform-dependent; as a result, calling these methods might\n+ * be a no-op on certain platforms.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n- * {@link #fileDescriptor()} method.\n+ * {@link #fileDescriptor()} method. For more operations on mapped memory segments, please refer to the\n+ * {@link MappedMemorySegments} class.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}