{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -90,0 +91,2 @@\n+    static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -176,1 +179,1 @@\n-        return MappedMemoryUtils.isLoaded(address, isSync, capacity());\n+        return SCOPED_MEMORY_ACCESS.isLoaded(scope(), address, isSync, capacity());\n@@ -194,1 +197,1 @@\n-            MappedMemoryUtils.load(address, isSync, capacity());\n+            SCOPED_MEMORY_ACCESS.load(scope(), address, isSync, capacity());\n@@ -283,1 +286,1 @@\n-            MappedMemoryUtils.force(fd, address, isSync, index, length);\n+            SCOPED_MEMORY_ACCESS.force(scope(), fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -34,0 +35,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -238,0 +240,84 @@\n+\n+    @ForceInline\n+    public boolean isLoaded(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            return isLoadedInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public boolean isLoadedInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return SharedSecrets.getJavaNioAccess().isLoaded(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void load(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            loadInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void loadInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().load(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void unload(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            unloadInternal(scope, address, isSync, size);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void unloadInternal(Scope scope, long address, boolean isSync, long size) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().unload(address, isSync, size);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void force(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+        try {\n+            forceInternal(scope, fd, address, isSync, index, length);\n+        } catch (Scope.ScopedAccessError ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    public void forceInternal(Scope scope, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            SharedSecrets.getJavaNioAccess().force(fd, address, isSync, index, length);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":86,"deletions":0,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Path;\n-\n-\/**\n- * A mapped memory segment, that is, a memory segment backed by memory-mapped file.\n- *\n- * <p> Mapped memory segments are created via the {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}.\n- * Mapped memory segments behave like ordinary segments, but provide additional capabilities to manipulate memory-mapped\n- * memory regions, such as {@link #force()} and {@link #load()}.\n- * <p>\n- * All implementations of this interface must be <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>;\n- * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on\n- * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should\n- * be used for comparisons.\n- * <p>\n- * Non-platform classes should not implement {@linkplain MappedMemorySegment} directly.\n- *\n- * <p> The content of a mapped memory segment can change at any time, for example\n- * if the content of the corresponding region of the mapped file is changed by\n- * this (or another) program.  Whether or not such changes occur, and when they\n- * occur, is operating-system dependent and therefore unspecified.\n- *\n- * All or part of a mapped memory segment may become\n- * inaccessible at any time, for example if the backing mapped file is truncated.  An\n- * attempt to access an inaccessible region of a mapped memory segment will not\n- * change the segment's content and will cause an unspecified exception to be\n- * thrown either at the time of the access or at some later time.  It is\n- * therefore strongly recommended that appropriate precautions be taken to\n- * avoid the manipulation of a mapped file by this (or another) program, except to read or write\n- * the file's content.\n- *\n- * @apiNote In the future, if the Java language permits, {@link MemorySegment}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted subtypes.\n- *\/\n-public interface MappedMemorySegment extends MemorySegment {\n-\n-    @Override\n-    MappedMemorySegment withAccessModes(int accessModes);\n-\n-    @Override\n-    MappedMemorySegment asSlice(long offset, long newSize);\n-\n-    \/**\n-     * Forces any changes made to this segment's content to be written to the\n-     * storage device containing the mapped file.\n-     *\n-     * <p> If the file mapped into this segment resides on a local storage\n-     * device then when this method returns it is guaranteed that all changes\n-     * made to the segment since it was created, or since this method was last\n-     * invoked, will have been written to that device.\n-     *\n-     * <p> If the file does not reside on a local device then no such guarantee\n-     * is made.\n-     *\n-     * <p> If this segment was not mapped in read\/write mode ({@link\n-     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n-     * invoking this method may have no effect. In particular, the\n-     * method has no effect for segments mapped in read-only or private\n-     * mapping modes. This method may or may not have an effect for\n-     * implementation-specific mapping modes.\n-     * <\/p>\n-     *\/\n-    void force();\n-\n-    \/**\n-     * Loads this segment's content into physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that, when it returns,\n-     * this segment's contents is resident in physical memory.  Invoking this\n-     * method may cause some number of page faults and I\/O operations to\n-     * occur. <\/p>\n-     *\/\n-    void load();\n-\n-    \/**\n-     * Unloads this segment's content from physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that this segment's contents are\n-     * are no longer resident in physical memory. Accessing this segment's contents\n-     * after invoking this method may cause some number of page faults and I\/O operations to\n-     * occur (as this segment's contents might need to be paged back in). <\/p>\n-     *\/\n-    void unload();\n-\n-    \/**\n-     * Tells whether or not this segment's content is resident in physical\n-     * memory.\n-     *\n-     * <p> A return value of {@code true} implies that it is highly likely\n-     * that all of the data in this segment is resident in physical memory and\n-     * may therefore be accessed without incurring any virtual-memory page\n-     * faults or I\/O operations.  A return value of {@code false} does not\n-     * necessarily imply that the segment's content is not resident in physical\n-     * memory.\n-     *\n-     * <p> The returned value is a hint, rather than a guarantee, because the\n-     * underlying operating system may have paged out some of the segment's data\n-     * by the time that an invocation of this method returns.  <\/p>\n-     *\n-     * @return  {@code true} if it is likely that this segment's content\n-     *          is resident in physical memory\n-     *\/\n-    boolean isLoaded();\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegment.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.MappedMemorySegmentImpl;\n+\n+import java.nio.MappedByteBuffer;\n+\n+\/**\n+ * This class provides capabilities to manipulate mapped memory segments, such as {@link #force(MemorySegment)},\n+ * and {@link #load(MemorySegment)}. The methods in these class are suitable replacements for some of the\n+ * functionality in the {@link java.nio.MappedByteBuffer} class. Note that, while it is possible to map a segment\n+ * into a byte buffer (see {@link MemorySegment#asByteBuffer()}), and call e.g. {@link MappedByteBuffer#force()} that way,\n+ * this can only be done when the source segment is small enough, due to the size limitation inherent to the\n+ * ByteBuffer API.\n+ * <p>\n+ * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n+ * custom mapped memory segment factories; using JNI, e.g. on Linux, it is possible to call {@code mmap}\n+ * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)}.\n+ *\n+ * @implNote\n+ * The behavior of the methods in this class is highly platform-dependent; as a result, calling these methods might\n+ * be a no-op on certain platforms.\n+ *\/\n+public final class MappedMemorySegments {\n+    private MappedMemorySegments() {\n+        \/\/ no thanks\n+    }\n+\n+    \/**\n+     * Tells whether or not the contents of the given segment is resident in physical\n+     * memory.\n+     *\n+     * <p> A return value of {@code true} implies that it is highly likely\n+     * that all of the data in the given segment is resident in physical memory and\n+     * may therefore be accessed without incurring any virtual-memory page\n+     * faults or I\/O operations.  A return value of {@code false} does not\n+     * necessarily imply that the segment's content is not resident in physical\n+     * memory.\n+     *\n+     * <p> The returned value is a hint, rather than a guarantee, because the\n+     * underlying operating system may have paged out some of the segment's data\n+     * by the time that an invocation of this method returns.  <\/p>\n+     *\n+     * @param segment the segment whose contents are to be tested.\n+     * @return  {@code true} if it is likely that the contents of the given segment\n+     *          is resident in physical memory\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+     *\/\n+    public static boolean isLoaded(MemorySegment segment) {\n+        return toMappedSegment(segment).isLoaded();\n+    }\n+\n+    \/**\n+     * Loads the contents of the given segment into physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that, when it returns,\n+     * this contents of the given segment is resident in physical memory.  Invoking this\n+     * method may cause some number of page faults and I\/O operations to\n+     * occur. <\/p>\n+     *\n+     * @param segment the segment whose contents are to be loaded.\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+     *\/\n+    public static void load(MemorySegment segment) {\n+        toMappedSegment(segment).load();\n+    }\n+\n+    \/**\n+     * Unloads the contents of the given segment from physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that the contents of the given segment are\n+     * are no longer resident in physical memory. Accessing this segment's contents\n+     * after invoking this method may cause some number of page faults and I\/O operations to\n+     * occur (as this segment's contents might need to be paged back in). <\/p>\n+     *\n+     * @param segment the segment whose contents are to be unloaded.\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+     *\/\n+    public static void unload(MemorySegment segment) {\n+        toMappedSegment(segment).unload();\n+    }\n+\n+    \/**\n+     * Forces any changes made to the contents of the given segment to be written to the\n+     * storage device described by the segment's file descriptor (see {@link MemorySegment#fileDescriptor()}).\n+     *\n+     * <p> If this mapping's file descriptor resides on a local storage\n+     * device then when this method returns it is guaranteed that all changes\n+     * made to the segment since it was created, or since this method was last\n+     * invoked, will have been written to that device.\n+     *\n+     * <p> If this mapping's file descriptor does not reside on a local device then no such guarantee\n+     * is made.\n+     *\n+     * <p> If the given segment was not mapped in read\/write mode ({@link\n+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n+     * invoking this method may have no effect. In particular, the\n+     * method has no effect for segments mapped in read-only or private\n+     * mapping modes. This method may or may not have an effect for\n+     * implementation-specific mapping modes.\n+     * <\/p>\n+     *\n+     * @param segment the segment whose contents are to be written to the storage device described by the\n+     *                segment's file descriptor.\n+     *\n+     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n+     * and this method is called from a thread other than the segment's owner thread.\n+     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n+     * {@code segment.fileDescriptor().isEmpty()}.\n+     *\/\n+    public static void force(MemorySegment segment) {\n+        toMappedSegment(segment).force();\n+    }\n+\n+    static MappedMemorySegmentImpl toMappedSegment(MemorySegment segment) {\n+        if (segment instanceof MappedMemorySegmentImpl) {\n+            return (MappedMemorySegmentImpl)segment;\n+        } else {\n+            throw new UnsupportedOperationException(\"Not a mapped memory segment\");\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.FileDescriptor;\n@@ -42,0 +43,1 @@\n+import java.util.Optional;\n@@ -43,1 +45,0 @@\n-import java.util.function.Consumer;\n@@ -78,2 +79,4 @@\n- * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>\n- * (see {@link MappedMemorySegment}).\n+ * {@link MemorySegment#mapFromPath(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n+ * mapped memory segments are associated with a {@link FileDescriptor} instance which can be obtained calling the\n+ * {@link #fileDescriptor()} method. For more operations on mapped memory segments, please refer to the\n+ * {@link MappedMemorySegments} class.\n@@ -183,1 +186,1 @@\n-    int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n+    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n@@ -216,2 +219,1 @@\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * {@link MappedMemorySegment} and other explicitly permitted subtypes.\n+ * may become a {@code sealed} interface, which would prohibit subclassing except by other explicitly permitted subtypes.\n@@ -236,1 +238,1 @@\n-     * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},\n+     * Returns a spliterator for this memory segment. The returned spliterator reports {@link Spliterator#SIZED},\n@@ -240,1 +242,1 @@\n-     * The returned spliterator splits the segment according to the specified sequence layout; that is,\n+     * The returned spliterator splits this segment according to the specified sequence layout; that is,\n@@ -246,1 +248,1 @@\n-     * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then\n+     * The returned spliterator effectively allows to slice this segment into disjoint sub-segments, which can then\n@@ -248,5 +250,1 @@\n-     * While closing the segment (see {@link #close()}) during pending concurrent execution will generally\n-     * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread\n-     * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call\n-     * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.\n-     * @param segment the segment to be used for splitting.\n+     *\n@@ -254,1 +252,0 @@\n-     * @param <S> the memory segment type\n@@ -259,3 +256,1 @@\n-    static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout layout) {\n-        return AbstractMemorySegmentImpl.spliterator(segment, layout);\n-    }\n+    Spliterator<MemorySegment> spliterator(SequenceLayout layout);\n@@ -384,0 +379,8 @@\n+    \/**\n+     * Obtain the file descriptor with this memory segment, assuming this segment is a mapped memory segment,\n+     * created using the {@link #mapFromPath(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * @return the file descriptor associated with this memory segment (if any).\n+     *\/\n+    Optional<FileDescriptor> fileDescriptor();\n+\n@@ -399,1 +402,0 @@\n-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n@@ -805,0 +807,14 @@\n+     * <p>\n+     * The content of a mapped memory segment can change at any time, for example\n+     * if the content of the corresponding region of the mapped file is changed by\n+     * this (or another) program.  Whether or not such changes occur, and when they\n+     * occur, is operating-system dependent and therefore unspecified.\n+     * <p>\n+     * All or part of a mapped memory segment may become\n+     * inaccessible at any time, for example if the backing mapped file is truncated.  An\n+     * attempt to access an inaccessible region of a mapped memory segment will not\n+     * change the segment's content and will cause an unspecified exception to be\n+     * thrown either at the time of the access or at some later time.  It is\n+     * therefore strongly recommended that appropriate precautions be taken to\n+     * avoid the manipulation of a mapped file by this (or another) program, except to read or write\n+     * the file's content.\n@@ -813,1 +829,1 @@\n-     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).\n+     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegments#force(MemorySegment)}).\n@@ -820,1 +836,1 @@\n-    static MappedMemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    static MemorySegment mapFromPath(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n@@ -901,1 +917,0 @@\n-     * (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.io.FileDescriptor;\n@@ -42,5 +43,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Random;\n-import java.util.Spliterator;\n+import java.util.*;\n@@ -115,4 +112,4 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout sequenceLayout) {\n-        ((AbstractMemorySegmentImpl)segment).checkValidState();\n-        if (sequenceLayout.byteSize() != segment.byteSize()) {\n+    @Override\n+    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {\n+        checkValidState();\n+        if (sequenceLayout.byteSize() != byteSize()) {\n@@ -121,2 +118,2 @@\n-        return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n-                (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));\n+        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n+                withAccessModes(accessModes() & ~CLOSE));\n@@ -323,0 +320,5 @@\n+    @Override\n+    public Optional<FileDescriptor> fileDescriptor() {\n+        return Optional.empty();\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.MappedMemorySegment;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -30,0 +30,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -32,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -38,0 +40,1 @@\n+import java.util.Optional;\n@@ -45,1 +48,1 @@\n-public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl implements MappedMemorySegment {\n+public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n@@ -49,0 +52,2 @@\n+    static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -78,0 +83,10 @@\n+    public Optional<FileDescriptor> fileDescriptor() {\n+        return Optional.of(unmapper.fileDescriptor());\n+    }\n+\n+    \/\/ support for mapped segments\n+\n+    public MemorySegment segment() {\n+        return MappedMemorySegmentImpl.this;\n+    }\n+\n@@ -79,1 +94,1 @@\n-        nioAccess.load(min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.load(scope, min, unmapper.isSync(), length);\n@@ -82,1 +97,0 @@\n-    @Override\n@@ -84,1 +98,1 @@\n-        nioAccess.unload(min, unmapper.isSync(), length);\n+        SCOPED_MEMORY_ACCESS.unload(scope, min, unmapper.isSync(), length);\n@@ -87,1 +101,0 @@\n-    @Override\n@@ -89,1 +102,1 @@\n-        return nioAccess.isLoaded(min, unmapper.isSync(), length);\n+        return SCOPED_MEMORY_ACCESS.isLoaded(scope, min, unmapper.isSync(), length);\n@@ -92,1 +105,0 @@\n-    @Override\n@@ -94,1 +106,1 @@\n-        nioAccess.force(unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+        SCOPED_MEMORY_ACCESS.force(scope, unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n@@ -99,1 +111,1 @@\n-    public static MappedMemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,6 +32,1 @@\n-import jdk.incubator.foreign.MappedMemorySegment;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.*;\n@@ -39,1 +34,0 @@\n-import jdk.incubator.foreign.SequenceLayout;\n@@ -75,1 +69,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -230,1 +223,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n@@ -235,1 +228,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n+        try (MemorySegment segment = MemorySegment.mapFromPath(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n@@ -248,1 +241,1 @@\n-        try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n@@ -250,1 +243,1 @@\n-            segment.force();\n+            MappedMemorySegments.force(segment);\n@@ -259,0 +252,12 @@\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n+    public void testMappedSegmentOperations(MappedSegmentOp mappedBufferOp) throws Throwable {\n+        File f = new File(\"test3.out\");\n+        f.createNewFile();\n+        f.deleteOnExit();\n+\n+        MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n+        assertTrue(segment.fileDescriptor().isPresent());\n+        segment.close();\n+        mappedBufferOp.apply(segment);\n+    }\n+\n@@ -270,1 +275,1 @@\n-            try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+            try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n@@ -272,1 +277,1 @@\n-                segment.force();\n+                MappedMemorySegments.force(segment);\n@@ -712,0 +717,28 @@\n+\n+    enum MappedSegmentOp {\n+        LOAD(MappedMemorySegments::load),\n+        UNLOAD(MappedMemorySegments::unload),\n+        IS_LOADED(MappedMemorySegments::isLoaded),\n+        FORCE(MappedMemorySegments::force),\n+        BUFFER_LOAD(m -> ((MappedByteBuffer)m.asByteBuffer()).load()),\n+        BUFFER_IS_LOADED(m -> ((MappedByteBuffer)m.asByteBuffer()).isLoaded()),\n+        BUFFER_FORCE(m -> ((MappedByteBuffer)m.asByteBuffer()).force());\n+\n+\n+        private Consumer<MemorySegment> segmentOp;\n+\n+        MappedSegmentOp(Consumer<MemorySegment> segmentOp) {\n+            this.segmentOp = segmentOp;\n+        }\n+\n+        void apply(MemorySegment segment) {\n+            segmentOp.accept(segment);\n+        }\n+    }\n+\n+    @DataProvider(name = \"mappedOps\")\n+    public static Object[][] mappedOps() {\n+        return Stream.of(MappedSegmentOp.values())\n+                .map(op -> new Object[] { op })\n+                .toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":47,"deletions":14,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -331,0 +331,1 @@\n+                \"spliterator\",\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            spliterators.add(MemorySegment.spliterator(s, layout));\n+            spliterators.add(s.spliterator(layout));\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        long parallelCounted = new SumSegmentCounted(null, MemorySegment.spliterator(segment, layout), threshold).invoke();\n+        long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();\n@@ -75,1 +75,1 @@\n-        long parallelRecursive = new SumSegmentRecursive(MemorySegment.spliterator(segment, layout), threshold).invoke();\n+        long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();\n@@ -78,1 +78,1 @@\n-        long streamParallel = StreamSupport.stream(MemorySegment.spliterator(segment, layout), true)\n+        long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)\n@@ -96,1 +96,1 @@\n-        spliterator(segment.withAccessModes(MemorySegment.READ), layout)\n+        segment.withAccessModes(MemorySegment.READ).spliterator(layout)\n@@ -212,7 +212,7 @@\n-            () -> spliterator(mallocSegment.withAccessModes(ALL_ACCESS), layout), ALL_ACCESS,\n-            () -> spliterator(mallocSegment.withAccessModes(0), layout), 0,\n-            () -> spliterator(mallocSegment.withAccessModes(READ), layout), READ,\n-            () -> spliterator(mallocSegment.withAccessModes(CLOSE), layout), 0,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE), layout), READ|WRITE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE), layout), READ|WRITE| SHARE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF), layout), READ|WRITE| SHARE |HANDOFF\n+            () -> mallocSegment.withAccessModes(ALL_ACCESS).spliterator(layout), ALL_ACCESS,\n+            () -> mallocSegment.withAccessModes(0).spliterator(layout), 0,\n+            () -> mallocSegment.withAccessModes(READ).spliterator(layout), READ,\n+            () -> mallocSegment.withAccessModes(CLOSE).spliterator(layout), 0,\n+            () -> mallocSegment.withAccessModes(READ|WRITE).spliterator(layout), READ|WRITE,\n+            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE).spliterator(layout), READ|WRITE| SHARE,\n+            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF).spliterator(layout), READ|WRITE| SHARE |HANDOFF\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-            SpliteratorTestHelper.testSpliterator(() -> MemorySegment.spliterator(segment, layout),\n+            SpliteratorTestHelper.testSpliterator(() -> segment.spliterator(layout),\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();\n+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();\n@@ -125,1 +125,1 @@\n-        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n+        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n@@ -130,1 +130,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n@@ -136,1 +136,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n@@ -153,1 +153,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), false)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), false)\n@@ -160,1 +160,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n@@ -167,1 +167,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), false)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), false)\n@@ -174,1 +174,1 @@\n-        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)\n+        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}