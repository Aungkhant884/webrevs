{"files":[{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -1839,0 +1841,15 @@\n+    boolean bytesCompatible(Charset charset) {\n+        if (coder == LATIN1 && charset == ISO_8859_1.INSTANCE) {\n+            return true;\n+        } else if (coder == LATIN1 && (charset == UTF_8.INSTANCE || charset == US_ASCII.INSTANCE) &&\n+                !StringCoding.hasNegatives(value, 0, value.length)) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    void copyToSegmentRaw(MemorySegment segment, long offset) {\n+        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -90,1 +91,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -2668,0 +2668,10 @@\n+\n+            @Override\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+                string.copyToSegmentRaw(segment, offset);\n+            }\n+\n+            @Override\n+            public boolean bytesCompatible(String string, Charset charset) {\n+                return string.bytesCompatible(charset);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -128,3 +128,12 @@\n-        byte[] bytes = str.getBytes(charset);\n-        MemorySegment segment = allocateNoInit(bytes.length + termCharSize);\n-        MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        MemorySegment segment;\n+        int length;\n+        if (StringSupport.bytesCompatible(str, charset)) {\n+            length = str.length();\n+            segment = allocateNoInit(length + termCharSize);\n+            StringSupport.copyToSegmentRaw(str, segment, 0);\n+        } else {\n+            byte[] bytes = str.getBytes(charset);\n+            length = bytes.length;\n+            segment = allocateNoInit(bytes.length + termCharSize);\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        }\n@@ -132,1 +141,1 @@\n-            segment.set(ValueLayout.JAVA_BYTE, bytes.length + i, (byte)0);\n+            segment.set(ValueLayout.JAVA_BYTE, length + i, (byte)0);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -577,0 +578,10 @@\n+\n+    \/**\n+     * Copy the string bytes to an existing segment, avoiding intermediate copies.\n+     *\/\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+\n+    \/**\n+     * Are the string bytes compatible with the given charset?\n+     *\/\n+    boolean bytesCompatible(String string, Charset charset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -30,0 +32,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -33,0 +36,1 @@\n+import java.util.function.IntFunction;\n@@ -41,0 +45,4 @@\n+    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+    public static final boolean SKIP_STRING_COPY = Boolean.parseBoolean(\n+            GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.StringSupport.SKIP_STRING_COPY\", \"true\"));\n+\n@@ -67,3 +75,2 @@\n-        byte[] bytes = string.getBytes(charset);\n-        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n-        segment.set(JAVA_BYTE, offset + bytes.length, (byte)0);\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_BYTE, offset + bytes, (byte)0);\n@@ -80,3 +87,2 @@\n-        byte[] bytes = string.getBytes(charset);\n-        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n-        segment.set(JAVA_SHORT, offset + bytes.length, (short)0);\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_SHORT, offset + bytes, (short)0);\n@@ -93,3 +99,2 @@\n-        byte[] bytes = string.getBytes(charset);\n-        MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n-        segment.set(JAVA_INT, offset + bytes.length, 0);\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_INT, offset + bytes, 0);\n@@ -307,0 +312,19 @@\n+    public static boolean bytesCompatible(String string, Charset charset) {\n+        return SKIP_STRING_COPY && JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n+    }\n+\n+    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset) {\n+        if (bytesCompatible(string, charset)) {\n+            copyToSegmentRaw(string, segment, offset);\n+            return string.length();\n+        } else {\n+            byte[] bytes = string.getBytes(charset);\n+            MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+            return bytes.length;\n+        }\n+    }\n+\n+    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":33,"deletions":9,"binary":false,"changes":42,"status":"modified"}]}