{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n@@ -31,0 +29,1 @@\n+import java.nio.charset.Charset;\n@@ -33,1 +32,1 @@\n-import java.util.function.Function;\n+\n@@ -35,0 +34,1 @@\n+import jdk.internal.foreign.ArenaImpl;\n@@ -36,2 +36,2 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.foreign.StringSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -73,1 +73,1 @@\n- * @since 19\n+ * @since 22\n@@ -76,1 +76,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -80,0 +79,1 @@\n+<<<<<<< HEAD\n@@ -81,0 +81,22 @@\n+=======\n+     * Converts a Java string into a null-terminated C string using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset,\n+     * storing the result into a memory segment.\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * allocateFrom(str, StandardCharsets.UTF_8);\n+     *}\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native segment containing the converted C string.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str) {\n+        Objects.requireNonNull(str);\n+        return allocateFrom(str, sun.nio.cs.UTF_8.INSTANCE);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * and storing the result into a memory segment.\n@@ -89,1 +111,1 @@\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n@@ -92,0 +114,1 @@\n+<<<<<<< HEAD\n@@ -95,0 +118,14 @@\n+=======\n+     * @param str     the Java string to be converted into a C string.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @return a new native segment containing the converted C string.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     * @implSpec the default implementation for this method copies the contents of the provided Java string\n+     * into a new memory segment obtained by calling {@code this.allocate(B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -96,1 +133,3 @@\n-    default MemorySegment allocateUtf8String(String str) {\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n@@ -98,1 +137,17 @@\n-        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n+        MemorySegment segment;\n+        int length;\n+        if (StringSupport.bytesCompatible(str, charset)) {\n+            length = str.length();\n+            segment = allocateNoInit(length + termCharSize);\n+            StringSupport.copyToSegmentRaw(str, segment, 0);\n+        } else {\n+            byte[] bytes = str.getBytes(charset);\n+            length = bytes.length;\n+            segment = allocateNoInit(bytes.length + termCharSize);\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        }\n+        for (int i = 0 ; i < termCharSize ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, length + i, (byte)0);\n+        }\n+        return segment;\n@@ -115,1 +170,1 @@\n-    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfByte layout, byte value) {\n@@ -117,0 +172,1 @@\n+<<<<<<< HEAD\n@@ -121,0 +177,5 @@\n+=======\n+        MemorySegment addr = allocateNoInit(layout);\n+        addr.set(layout, 0, value);\n+        return addr;\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -137,1 +198,1 @@\n-    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfChar layout, char value) {\n@@ -139,0 +200,1 @@\n+<<<<<<< HEAD\n@@ -143,0 +205,5 @@\n+=======\n+        MemorySegment addr = allocateNoInit(layout);\n+        addr.set(layout, 0, value);\n+        return addr;\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -159,1 +226,1 @@\n-    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfShort layout, short value) {\n@@ -161,0 +228,1 @@\n+<<<<<<< HEAD\n@@ -165,0 +233,5 @@\n+=======\n+        MemorySegment addr = allocateNoInit(layout);\n+        addr.set(layout, 0, value);\n+        return addr;\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -181,1 +254,1 @@\n-    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfInt layout, int value) {\n@@ -183,0 +256,1 @@\n+<<<<<<< HEAD\n@@ -187,0 +261,5 @@\n+=======\n+        MemorySegment addr = allocateNoInit(layout);\n+        addr.set(layout, 0, value);\n+        return addr;\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -203,1 +282,1 @@\n-    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat layout, float value) {\n@@ -205,0 +284,1 @@\n+<<<<<<< HEAD\n@@ -209,0 +289,5 @@\n+=======\n+        MemorySegment addr = allocateNoInit(layout);\n+        addr.set(layout, 0, value);\n+        return addr;\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -225,1 +310,1 @@\n-    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfLong layout, long value) {\n@@ -227,0 +312,1 @@\n+<<<<<<< HEAD\n@@ -231,0 +317,5 @@\n+=======\n+        MemorySegment addr = allocateNoInit(layout);\n+        addr.set(layout, 0, value);\n+        return addr;\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -247,1 +338,1 @@\n-    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble layout, double value) {\n@@ -249,0 +340,1 @@\n+<<<<<<< HEAD\n@@ -253,0 +345,5 @@\n+=======\n+        MemorySegment addr = allocateNoInit(layout);\n+        addr.set(layout, 0, value);\n+        return addr;\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -272,1 +369,1 @@\n-    default MemorySegment allocate(AddressLayout layout, MemorySegment value) {\n+    default MemorySegment allocateFrom(AddressLayout layout, MemorySegment value) {\n@@ -275,0 +372,1 @@\n+<<<<<<< HEAD\n@@ -295,0 +393,28 @@\n+=======\n+        MemorySegment segment = allocateNoInit(layout);\n+        segment.set(layout, 0, value);\n+        return segment;\n+    }\n+\n+    \/**\n+     * Allocates a memory segment with the given layout and initializes it with the bytes in the provided\n+     * source memory segment.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(elementLayout, elementCount)}.\n+     * @param elementLayout the element layout of the allocated array.\n+     * @param source the source segment.\n+     * @param sourceElementLayout the element layout of the source segment.\n+     * @param sourceOffset the starting offset, in bytes, of the source segment.\n+     * @param elementCount the number of elements in the source segment to be copied.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() != sourceElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if the source segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     * in the source element layout.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code sourceElementLayout.byteAlignment() > sourceElementLayout.byteSize()}.\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated with {@code source} is not\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code source.isAccessibleBy(T) == false}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * sourceElementLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset > source.byteSize() - (elementCount * sourceElementLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if either {@code sourceOffset} or {@code elementCount} are {@code < 0}.\n@@ -296,2 +422,9 @@\n-    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source,\n+                                       ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n+        Objects.requireNonNull(source);\n+        Objects.requireNonNull(sourceElementLayout);\n+        Objects.requireNonNull(elementLayout);\n+        MemorySegment dest = allocateNoInit(elementLayout, elementCount);\n+        MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+        return dest;\n@@ -301,0 +434,20 @@\n+     * Allocates a memory segment with the given layout and initializes it with the given byte elements.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_BYTE, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements the byte elements to be copied to the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfByte elementLayout, byte... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_BYTE, 0, elements.length);\n+    }\n+\n+    \/**\n+<<<<<<< HEAD\n@@ -315,0 +468,12 @@\n+=======\n+     * Allocates a memory segment with the given layout and initializes it with the given short elements.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_SHORT, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements the short elements to be copied to the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -316,2 +481,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfShort elementLayout, short... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_SHORT, 0, elements.length);\n@@ -321,0 +488,1 @@\n+<<<<<<< HEAD\n@@ -335,0 +503,12 @@\n+=======\n+     * Allocates a memory segment with the given layout and initializes it with the given char elements.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_CHAR, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements the char elements to be copied to the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -336,2 +516,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfChar elementLayout, char... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_CHAR, 0, elements.length);\n@@ -341,0 +523,1 @@\n+<<<<<<< HEAD\n@@ -355,0 +538,12 @@\n+=======\n+     * Allocates a memory segment with the given layout and initializes it with the given int elements.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_INT, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements the int elements to be copied to the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -356,2 +551,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfInt elementLayout, int... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_INT, 0, elements.length);\n@@ -361,0 +558,1 @@\n+<<<<<<< HEAD\n@@ -375,0 +573,12 @@\n+=======\n+     * Allocates a memory segment with the given layout and initializes it with the given float elements.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_FLOAT, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements the float elements to be copied to the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -376,2 +586,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat elementLayout, float... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_FLOAT, 0, elements.length);\n@@ -381,0 +593,1 @@\n+<<<<<<< HEAD\n@@ -395,0 +608,12 @@\n+=======\n+     * Allocates a memory segment with the given layout and initializes it with the given long elements.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_LONG, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements the long elements to be copied to the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -396,2 +621,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfLong elementLayout, long... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_LONG, 0, elements.length);\n@@ -401,0 +628,1 @@\n+<<<<<<< HEAD\n@@ -429,0 +657,17 @@\n+=======\n+     * Allocates a memory segment with the given layout and initializes it with the given double elements.\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_DOUBLE, 0, array.length)\n+     *}\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param elements the double elements to be copied to the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble elementLayout, double... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_DOUBLE, 0, elements.length);\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -455,1 +700,1 @@\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+    default MemorySegment allocate(MemoryLayout elementLayout, long count) {\n@@ -528,0 +773,21 @@\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(long byteSize) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(byteSize, 1) :\n+                allocate(byteSize);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n+                allocate(layout);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout, long size) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n+                allocate(layout, size);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":297,"deletions":31,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -50,0 +48,2 @@\n+import static java.lang.foreign.ValueLayout.*;\n+\n@@ -105,1 +105,1 @@\n-            { Linker.Option.isTrivial() },\n+            { Linker.Option.critical() },\n@@ -131,0 +131,1 @@\n+<<<<<<< HEAD\n@@ -132,0 +133,3 @@\n+=======\n+                    \"Unsupported layout: 2%a\" + ADDRESS.byteSize()\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n@@ -159,1 +163,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(1,\n@@ -184,1 +188,1 @@\n-                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(1, C_INT.withOrder(nonNativeOrder())))),\n@@ -188,7 +192,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n-                            ValueLayout.JAVA_LONG,\n-                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n-                    NO_OPTIONS,\n-                    \"has unexpected size\"\n-            },\n@@ -202,0 +199,5 @@\n+            {\n+                    FunctionDescriptor.ofVoid(),\n+                    new Linker.Option[]{Linker.Option.critical(), Linker.Option.captureCallState(\"errno\")},\n+                    \"Incompatible linker options: captureCallState, critical\"\n+            },\n@@ -215,1 +217,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ C_INT.byteSize(),\n@@ -222,0 +224,9 @@\n+        if (ValueLayout.JAVA_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    NO_OPTIONS,\n+                    \"has unexpected size\"\n+            });\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+<<<<<<< HEAD\n@@ -60,0 +61,7 @@\n+=======\n+            Paths.get(Utils.TEST_JDK)\n+                    .resolve(\"bin\")\n+                    .resolve(\"java\")\n+                    .toAbsolutePath()\n+                    .toString(),\n+>>>>>>> 9e3252ed3e1f3b5a253b57e17080219feb64b5bd\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}