{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -323,0 +323,29 @@\n+    \/**\n+     * Returns a new memory segment that is the overlap of the two segments.\n+     *\n+     * <p>Two segments S1 and S2 are said to overlap if it is possible to find\n+     * at least two slices L1 (from S1) and L2 (from S2) such that L1 and L2 are\n+     * backed by the same memory region. As such, it is not possible for an\n+     * {@link #isNative() native} segment to overlap with a heap segment; in\n+     * this case, or when no overlap occurs, {@code null} is returned.\n+     *\n+     * @param other the segment to test for an overlap with this segment.\n+     * @return a new memory segment, or {@code null} if no overlap occurs.\n+     *\/\n+    MemorySegment overlap(MemorySegment other);\n+\n+    \/**\n+     * Returns the offset, in bytes, from this segment to the other segment.\n+     *\n+     * <p>The offset is relative to the {@linkplain #address() base address} of\n+     * this segment and will be in the range of 0 (inclusive) up to the\n+     * {@linkplain #byteSize() size} (in bytes) of this segment (exclusive). If\n+     * the two segments do not {@link #overlap(MemorySegment) overlap}, an\n+     * offset can not be retrieved and {@code -1L} is returned.\n+     *\n+     * @param other the segment to retrieve an offset to.\n+     * @return the relative offset, in bytes, from this segment to the other\n+     *         segment, or -1L if no overlap occurs.\n+     *\/\n+    long offsetOf(MemorySegment other);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -254,0 +254,31 @@\n+    @Override\n+    public final MemorySegment overlap(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n+        long offsetFromThis = this.offsetOf(that);\n+        if (offsetFromThis >= 0L) {  \/\/ this and that overlap\n+            long offsetFromThat = that.offsetOf(this);\n+            long newSize = Math.min(this.byteSize() - offsetFromThis, that.byteSize() - offsetFromThat);\n+            return dup(offsetFromThis, newSize, mask, scope);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public final long offsetOf(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n+        if (base() == that.base()) {  \/\/ both are either native or heap\n+            final long thisStart = this.min();\n+            final long thatStart = that.min();\n+            final long thisEnd = thisStart + this.byteSize() - 1L;\n+            final long thatEnd = thatStart + that.byteSize() - 1L;\n+\n+            if (thisStart <= thatStart && thisEnd >= thatStart) {\n+                return thatStart - thisStart;\n+            }\n+            if (thatStart <= thisStart && thatEnd >= thisStart) {\n+                return 0L;\n+            }\n+        }\n+        return -1L;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm TestSegmentOffsetOf\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentOffsetOf {\n+\n+    static Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"buffer\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+            Files.write(file.toPath(), new byte[16], StandardOpenOption.WRITE);\n+\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @DataProvider(name = \"segmentFactories\")\n+    public Object[][] segmentFactories() {\n+        List<Supplier<MemorySegment>> l = List.of(\n+                () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()),\n+                () -> {\n+                    try {\n+                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                },\n+                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 } ),\n+                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' } ),\n+                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),\n+                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f } ),\n+                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),\n+                () -> MemorySegment.ofArray(new long[] { 1L, 2L, 3L, 4L } ),\n+                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } )\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testBasic(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = segmentSupplier.get();\n+        var sOther = s1.isNative() ? OtherSegmentFactory.HEAP.factory.get()\n+                : OtherSegmentFactory.NATIVE.factory.get();\n+        out.format(\"testBasic s1:%s, s2:%s, sOther:%s\\n\", s1, s2, sOther);\n+        assertEquals(s1.offsetOf(s2), -1L);\n+        assertEquals(s2.offsetOf(s1), -1L);\n+        assertEquals(s1.offsetOf(sOther), -1L);\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testIdentical(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = s1.asReadOnly();\n+        out.format(\"testIdentical s1:%s, s2:%s\\n\", s1, s2);\n+        assertEquals(s1.offsetOf(s2), 0L);\n+        assertEquals(s2.offsetOf(s1), 0L);\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testSlices(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment s1 = segmentSupplier.get();\n+        MemorySegment s2 = segmentSupplier.get();\n+        for (int offset = 0 ; offset < 4 ; offset++) {\n+            MemorySegment slice = s1.asSlice(offset);\n+            out.format(\"testSlices s1:%s, s2:%s, slice:%s, offset:%d\\n\", s1, s2, slice, offset);\n+            assertEquals(s1.offsetOf(slice), offset);\n+            assertEquals(slice.offsetOf(s1), 0L);\n+\n+            assertEquals(s2.offsetOf(slice), -1L);\n+        }\n+    }\n+\n+    enum OtherSegmentFactory {\n+        NATIVE(() -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope())),\n+        HEAP(() -> MemorySegment.ofArray(new byte[]{16}));\n+\n+        final Supplier<MemorySegment> factory;\n+\n+        OtherSegmentFactory(Supplier<MemorySegment> segmentFactory) {\n+            this.factory = segmentFactory;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffsetOf.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm TestSegmentOverlap\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+import static java.lang.System.out;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentOverlap {\n+\n+    static Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"buffer\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+            Files.write(file.toPath(), new byte[16], StandardOpenOption.WRITE);\n+\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @DataProvider(name = \"segmentFactories\")\n+    public Object[][] segmentFactories() {\n+        List<Supplier<MemorySegment>> l = List.of(\n+                () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()),\n+                () -> {\n+                    try {\n+                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                },\n+                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 } ),\n+                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' } ),\n+                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),\n+                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f } ),\n+                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),\n+                () -> MemorySegment.ofArray(new long[] { 1L, 2L, 3L, 4L } ),\n+                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } )\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testBasic(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = segmentSupplier.get();\n+        var sOther = s1.isNative() ? OtherSegmentFactory.HEAP.factory.get()\n+                : OtherSegmentFactory.NATIVE.factory.get();\n+        out.format(\"testBasic s1:%s, s2:%s, sOther:%s\\n\", s1, s2, sOther);\n+        assertNull(s1.overlap(s2));\n+        assertNull(s2.overlap(s1));\n+        assertNull(s1.overlap(sOther));\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testIdentical(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = s1.asReadOnly();\n+        out.format(\"testIdentical s1:%s, s2:%s\\n\", s1, s2);\n+        assertEquals(s1.overlap(s2).byteSize(), s1.byteSize());\n+        assertEquals(s1.overlap(s2).scope(), s1.scope());\n+\n+        assertEquals(s2.overlap(s1).byteSize(), s2.byteSize());\n+        assertEquals(s2.overlap(s1).scope(), s2.scope());\n+\n+        if (s1.isNative()) {\n+            assertEquals(s1.overlap(s2).address(), s1.address());\n+            assertEquals(s2.overlap(s1).address(), s2.address());\n+        }\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testSlices(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment s1 = segmentSupplier.get();\n+        MemorySegment s2 = segmentSupplier.get();\n+        for (int offset = 0 ; offset < 4 ; offset++) {\n+            MemorySegment slice = s1.asSlice(offset);\n+            out.format(\"testSlices s1:%s, s2:%s, slice:%s, offset:%d\\n\", s1, s2, slice, offset);\n+            assertEquals(s1.overlap(slice).byteSize(), s1.byteSize() - offset);\n+            assertEquals(s1.overlap(slice).scope(), s1.scope());\n+\n+            assertEquals(slice.overlap(s1).byteSize(), slice.byteSize());\n+            assertEquals(slice.overlap(s1).scope(), slice.scope());\n+\n+            if (s1.isNative()) {\n+                assertEquals(s1.overlap(slice).address(), s1.address().addOffset(offset));\n+                assertEquals(slice.overlap(s1).address(), slice.address());\n+            }\n+            assertNull(s2.overlap(slice));\n+        }\n+    }\n+\n+    enum OtherSegmentFactory {\n+        NATIVE(() -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope())),\n+        HEAP(() -> MemorySegment.ofArray(new byte[]{16}));\n+\n+        final Supplier<MemorySegment> factory;\n+\n+        OtherSegmentFactory(Supplier<MemorySegment> segmentFactory) {\n+            this.factory = segmentFactory;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"}]}