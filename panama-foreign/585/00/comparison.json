{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -323,0 +323,14 @@\n+    \/**\n+     * Returns true if this segment overlaps the {@code other} segment.\n+     *\n+     * If the two segments are not either both backed by native or heap memory, {@code false} is returned.\n+     * Otherwise, their offset and {@linkplain #byteSize() size} (in bytes) are used to determine if an overlap occurs.\n+     *\n+     * @param other the segment to be tested for an overlap with this segment.\n+     * @return {@code true} if this segment overlaps the other segment.\n+     * @throws IllegalStateException if either the scope associated with this segment or the scope associated\n+     * with the {@code other} segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     *\/\n+    boolean isOverlapping(MemorySegment other);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,0 +256,24 @@\n+    @Override\n+    public boolean isOverlapping(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n+        if (base() == that.base()) {  \/\/ both are either native or heap\n+            this.checkAccess(0, this.length, true);\n+            that.checkAccess(0, that.length, true);\n+            this.checkValidState();\n+            that.checkValidState();\n+\n+            final long thisStart = this.min();\n+            final long thatStart = that.min();\n+            if (thisStart == thatStart) {\n+                return true;\n+            }\n+            final long thisEnd = thisStart + this.byteSize() - 1L;\n+            final long thatEnd = thatStart + that.byteSize() - 1L;\n+            if (thisStart < thatStart && thisEnd >= thatStart) {\n+                return true;\n+            }\n+            return thatStart < thisStart && thatEnd >= thisStart;\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.util.function.BiConsumer;\n@@ -129,3 +130,4 @@\n-        ScopedOperation.ofSegment(s -> s.copyFrom(s), \"MemorySegment::copyFrom\");\n-        ScopedOperation.ofSegment(s -> s.mismatch(s), \"MemorySegment::mismatch\");\n-        ScopedOperation.ofSegment(s -> s.fill((byte) 0), \"MemorySegment::fill\");\n+        ScopedOperation.ofSegments(MemorySegment::copyFrom, \"MemorySegment::copyFrom\");\n+        ScopedOperation.ofSegments(MemorySegment::mismatch, \"MemorySegment::mismatch\");\n+        ScopedOperation.ofSegments(MemorySegment::isOverlapping, \"MemorySegment::isOverlapping\");\n+\n@@ -202,0 +204,19 @@\n+        static void ofSegments(BiConsumer<MemorySegment, MemorySegment> segmentsConsumer, String name) {\n+            for (ScopedOperation.SegmentFactory segmentFactory : ScopedOperation.SegmentFactory.values()) {\n+                scopedOperations.add(new ScopedOperation(scope1 -> {\n+                    ResourceScope scope2 = ResourceScope.newConfinedScope();\n+                    MemorySegment segment2 = segmentFactory.segmentFactory.apply(scope2);\n+                    MemorySegment segment1 = segmentFactory.segmentFactory.apply(scope1);\n+                    scope1.close();\n+                    segmentsConsumer.accept(segment1, segment2);\n+                }, segmentFactory.name() + \"\/\" + name + \"1\"));\n+                scopedOperations.add(new ScopedOperation(scope1 -> {\n+                    ResourceScope scope2 = ResourceScope.newConfinedScope();\n+                    MemorySegment segment2 = segmentFactory.segmentFactory.apply(scope2);\n+                    MemorySegment segment1 = segmentFactory.segmentFactory.apply(scope1);\n+                    scope2.close();\n+                    segmentsConsumer.accept(segment1, segment2);\n+                }, segmentFactory.name() + \"\/\" + name + \"2\"));\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm TestSegmentsOverlap\n+ *\/\n+\n+import java.util.List;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentsOverlap {\n+\n+    \/\/ native\n+\n+    @Test\n+    public void testNativeBasic() {\n+        var s1 = MemorySegment.allocateNative(128, ResourceScope.newConfinedScope());\n+        var s2 = MemorySegment.allocateNative(128, ResourceScope.newConfinedScope());\n+        var s3 = MemorySegment.ofArray(new byte[]{});\n+        assertFalse(s1.isOverlapping(s2));\n+        assertFalse(s1.isOverlapping(s3));\n+    }\n+\n+    @Test\n+    public void testNativeIdentical() {\n+        var s1 = MemorySegment.allocateNative(128, ResourceScope.newConfinedScope());\n+        var s2 = s1.asReadOnly();\n+        assertTrue(s1.isOverlapping(s2));\n+    }\n+\n+    @Test\n+    public void testNativeSlices() {\n+        MemorySegment segment = MemorySegment.allocateNative(10, 1, ResourceScope.newConfinedScope());\n+        MemorySegment other = MemorySegment.allocateNative(10, 1, ResourceScope.newConfinedScope());\n+        for (int offset = 0 ; offset < 10 ; offset++) {\n+            MemorySegment slice = segment.asSlice(offset);\n+            assertTrue(segment.isOverlapping(slice));\n+            assertTrue(slice.isOverlapping(segment));\n+            assertFalse(other.isOverlapping(slice));\n+        }\n+    }\n+\n+    \/\/ heap\n+\n+    @DataProvider(name = \"segmentFactories\")\n+    public Object[][] segmentFactories() {\n+        List<Supplier<MemorySegment>> l = List.of(\n+                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 }),\n+                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' }),\n+                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),\n+                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f }),\n+                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),\n+                () -> MemorySegment.ofArray(new long[] { 1L, 2L, 3L, 4L } ),\n+                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } )\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testHeapBasic(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = segmentSupplier.get();\n+        var s3 = MemorySegment.allocateNative(128, ResourceScope.newConfinedScope());\n+        assertFalse(s1.isOverlapping(s2));\n+        assertFalse(s1.isOverlapping(s3));\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testHeapIdentical(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = s1.asReadOnly();\n+        assertTrue(s1.isOverlapping(s2));\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testHeapSlices(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment segment = segmentSupplier.get();\n+        MemorySegment other = segmentSupplier.get();\n+        for (int offset = 0 ; offset < 4 ; offset++) {\n+            MemorySegment slice = segment.asSlice(offset);\n+            assertTrue(segment.isOverlapping(slice));\n+            assertTrue(slice.isOverlapping(segment));\n+            assertFalse(other.isOverlapping(slice));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentsOverlap.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}