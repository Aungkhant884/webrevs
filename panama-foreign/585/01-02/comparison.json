{"files":[{"patch":"@@ -324,1 +324,2 @@\n-     * Returns a new memory segment that is the overlap of the two segments.\n+     * Returns a new slice of this segment that is the overlap of the two\n+     * segments.\n@@ -333,1 +334,1 @@\n-     * @return a new memory segment, or {@code null} if no overlap occurs.\n+     * @return a new slice of this segment, or {@code null} if no overlap occurs.\n@@ -335,1 +336,1 @@\n-    MemorySegment overlap(MemorySegment other);\n+    MemorySegment asOverlappingSlice(MemorySegment other);\n@@ -341,4 +342,2 @@\n-     * this segment and will be in the range of 0 (inclusive) up to the\n-     * {@linkplain #byteSize() size} (in bytes) of this segment (exclusive). If\n-     * the two segments do not {@link #overlap(MemorySegment) overlap}, an\n-     * offset can not be retrieved and {@code -1L} is returned.\n+     * this segment and can be a negative or positive value. If the segments\n+     * share the same base address, {@code 0} is returned.\n@@ -348,1 +347,1 @@\n-     *         segment, or -1L if no overlap occurs.\n+     *         segment.\n@@ -350,1 +349,1 @@\n-    long offsetOf(MemorySegment other);\n+    long offsetTo(MemorySegment other);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-    public final MemorySegment overlap(MemorySegment other) {\n+    public final MemorySegment asOverlappingSlice(MemorySegment other) {\n@@ -257,13 +257,1 @@\n-        long offsetFromThis = this.offsetOf(that);\n-        if (offsetFromThis >= 0L) {  \/\/ this and that overlap\n-            long offsetFromThat = that.offsetOf(this);\n-            long newSize = Math.min(this.byteSize() - offsetFromThis, that.byteSize() - offsetFromThat);\n-            return dup(offsetFromThis, newSize, mask, scope);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public final long offsetOf(MemorySegment other) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n-        if (base() == that.base()) {  \/\/ both are either native or heap\n+        if (base() == that.base()) {  \/\/ both either native or heap\n@@ -275,5 +263,4 @@\n-            if (thisStart <= thatStart && thisEnd >= thatStart) {\n-                return thatStart - thisStart;\n-            }\n-            if (thatStart <= thisStart && thatEnd >= thisStart) {\n-                return 0L;\n+            if (thisStart <= thatEnd && thisEnd >= thatStart) {  \/\/overlap occurs\n+                long offsetToThat = this.offsetTo(that);\n+                long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+                return asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat));\n@@ -282,1 +269,10 @@\n-        return -1L;\n+        return null;\n+    }\n+\n+    @Override\n+    public final long offsetTo(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n+        if (base() == that.base()) {\n+            return that.min() - this.min();\n+        }\n+        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestSegmentOffset\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+import static java.lang.System.out;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentOffset {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testOffset(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.contains(s2)) {\n+            \/\/ check that a segment and its overlapping segment point to same elements\n+            long offset = s1.segment.offsetTo(s2.segment);\n+            for (int i = 0; i < s2.size(); i++) {\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d, i:%s\\n\", s1, s2, offset, i);\n+                byte expected = s2.segment.get(JAVA_BYTE, i);\n+                byte found = s1.segment.get(JAVA_BYTE, i + offset);\n+                assertEquals(found, expected);\n+            }\n+        } else if (s1.kind != s2.kind) {\n+            \/\/ check that offset from s1 to s2 fails\n+            try {\n+                long offset = s1.segment.offsetTo(s2.segment);\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n+                fail(\"offset unexpectedly passed!\");\n+            } catch (UnsupportedOperationException ex) {\n+                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n+            }\n+        } else if (!s2.contains(s1)) {\n+            \/\/ disjoint segments - check that offset is out of bounds\n+            long offset = s1.segment.offsetTo(s2.segment);\n+            for (int i = 0; i < s2.size(); i++) {\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d, i:%s\\n\", s1, s2, offset, i);\n+                s2.segment.get(JAVA_BYTE, i);\n+                try {\n+                    s1.segment.get(JAVA_BYTE, i + offset);\n+                    fail(\"Offset on a disjoint segment is not out of bounds!\");\n+                } catch (IndexOutOfBoundsException ex) {\n+                    assertTrue(true);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        boolean contains(SegmentSlice other) {\n+            return kind == other.kind &&\n+                    first <= other.first &&\n+                    last >= other.last;\n+        }\n+\n+        int size() {\n+            return last - first + 1;\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] slices() {\n+        int[] sizes = { 16, 8, 4, 2, 1 };\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            \/\/ init root segment\n+            MemorySegment segment = kind.makeSegment(16);\n+            for (int i = 0 ; i < 16 ; i++) {\n+                segment.set(JAVA_BYTE, i, (byte)i);\n+            }\n+            \/\/ compute all slices\n+            for (int size : sizes) {\n+                for (int index = 0 ; index < 16 ; index += size) {\n+                    MemorySegment slice = segment.asSlice(index, size);\n+                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm TestSegmentOffsetOf\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.List;\n-import java.util.function.Supplier;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static java.lang.System.out;\n-import static org.testng.Assert.*;\n-\n-public class TestSegmentOffsetOf {\n-\n-    static Path tempPath;\n-\n-    static {\n-        try {\n-            File file = File.createTempFile(\"buffer\", \"txt\");\n-            file.deleteOnExit();\n-            tempPath = file.toPath();\n-            Files.write(file.toPath(), new byte[16], StandardOpenOption.WRITE);\n-\n-        } catch (IOException ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    @DataProvider(name = \"segmentFactories\")\n-    public Object[][] segmentFactories() {\n-        List<Supplier<MemorySegment>> l = List.of(\n-                () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()),\n-                () -> {\n-                    try {\n-                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n-                    } catch (IOException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                },\n-                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 } ),\n-                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' } ),\n-                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),\n-                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f } ),\n-                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),\n-                () -> MemorySegment.ofArray(new long[] { 1L, 2L, 3L, 4L } ),\n-                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } )\n-        );\n-        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n-    }\n-\n-    @Test(dataProvider=\"segmentFactories\")\n-    public void testBasic(Supplier<MemorySegment> segmentSupplier) {\n-        var s1 = segmentSupplier.get();\n-        var s2 = segmentSupplier.get();\n-        var sOther = s1.isNative() ? OtherSegmentFactory.HEAP.factory.get()\n-                : OtherSegmentFactory.NATIVE.factory.get();\n-        out.format(\"testBasic s1:%s, s2:%s, sOther:%s\\n\", s1, s2, sOther);\n-        assertEquals(s1.offsetOf(s2), -1L);\n-        assertEquals(s2.offsetOf(s1), -1L);\n-        assertEquals(s1.offsetOf(sOther), -1L);\n-    }\n-\n-    @Test(dataProvider=\"segmentFactories\")\n-    public void testIdentical(Supplier<MemorySegment> segmentSupplier) {\n-        var s1 = segmentSupplier.get();\n-        var s2 = s1.asReadOnly();\n-        out.format(\"testIdentical s1:%s, s2:%s\\n\", s1, s2);\n-        assertEquals(s1.offsetOf(s2), 0L);\n-        assertEquals(s2.offsetOf(s1), 0L);\n-    }\n-\n-    @Test(dataProvider=\"segmentFactories\")\n-    public void testSlices(Supplier<MemorySegment> segmentSupplier) {\n-        MemorySegment s1 = segmentSupplier.get();\n-        MemorySegment s2 = segmentSupplier.get();\n-        for (int offset = 0 ; offset < 4 ; offset++) {\n-            MemorySegment slice = s1.asSlice(offset);\n-            out.format(\"testSlices s1:%s, s2:%s, slice:%s, offset:%d\\n\", s1, s2, slice, offset);\n-            assertEquals(s1.offsetOf(slice), offset);\n-            assertEquals(slice.offsetOf(s1), 0L);\n-\n-            assertEquals(s2.offsetOf(slice), -1L);\n-        }\n-    }\n-\n-    enum OtherSegmentFactory {\n-        NATIVE(() -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope())),\n-        HEAP(() -> MemorySegment.ofArray(new byte[]{16}));\n-\n-        final Supplier<MemorySegment> factory;\n-\n-        OtherSegmentFactory(Supplier<MemorySegment> segmentFactory) {\n-            this.factory = segmentFactory;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffsetOf.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -89,3 +89,3 @@\n-        assertNull(s1.overlap(s2));\n-        assertNull(s2.overlap(s1));\n-        assertNull(s1.overlap(sOther));\n+        assertNull(s1.asOverlappingSlice(s2));\n+        assertNull(s2.asOverlappingSlice(s1));\n+        assertNull(s1.asOverlappingSlice(sOther));\n@@ -99,2 +99,2 @@\n-        assertEquals(s1.overlap(s2).byteSize(), s1.byteSize());\n-        assertEquals(s1.overlap(s2).scope(), s1.scope());\n+        assertEquals(s1.asOverlappingSlice(s2).byteSize(), s1.byteSize());\n+        assertEquals(s1.asOverlappingSlice(s2).scope(), s1.scope());\n@@ -102,2 +102,2 @@\n-        assertEquals(s2.overlap(s1).byteSize(), s2.byteSize());\n-        assertEquals(s2.overlap(s1).scope(), s2.scope());\n+        assertEquals(s2.asOverlappingSlice(s1).byteSize(), s2.byteSize());\n+        assertEquals(s2.asOverlappingSlice(s1).scope(), s2.scope());\n@@ -106,2 +106,2 @@\n-            assertEquals(s1.overlap(s2).address(), s1.address());\n-            assertEquals(s2.overlap(s1).address(), s2.address());\n+            assertEquals(s1.asOverlappingSlice(s2).address(), s1.address());\n+            assertEquals(s2.asOverlappingSlice(s1).address(), s2.address());\n@@ -118,2 +118,2 @@\n-            assertEquals(s1.overlap(slice).byteSize(), s1.byteSize() - offset);\n-            assertEquals(s1.overlap(slice).scope(), s1.scope());\n+            assertEquals(s1.asOverlappingSlice(slice).byteSize(), s1.byteSize() - offset);\n+            assertEquals(s1.asOverlappingSlice(slice).scope(), s1.scope());\n@@ -121,2 +121,2 @@\n-            assertEquals(slice.overlap(s1).byteSize(), slice.byteSize());\n-            assertEquals(slice.overlap(s1).scope(), slice.scope());\n+            assertEquals(slice.asOverlappingSlice(s1).byteSize(), slice.byteSize());\n+            assertEquals(slice.asOverlappingSlice(s1).scope(), slice.scope());\n@@ -125,2 +125,2 @@\n-                assertEquals(s1.overlap(slice).address(), s1.address().addOffset(offset));\n-                assertEquals(slice.overlap(s1).address(), slice.address());\n+                assertEquals(s1.asOverlappingSlice(slice).address(), s1.address().addOffset(offset));\n+                assertEquals(slice.asOverlappingSlice(s1).address(), slice.address());\n@@ -128,1 +128,1 @@\n-            assertNull(s2.overlap(slice));\n+            assertNull(s2.asOverlappingSlice(slice));\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"}]}