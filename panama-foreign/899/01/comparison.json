{"files":[{"patch":"@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -22,1 +22,1 @@\n-message=Merge\n+message=Merge .*\n@@ -30,3 +30,0 @@\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n","filename":".jcheck\/conf","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -13,0 +13,14 @@\n+\n+---\n+Foreign Function & Memory API\n+\n+This repository contains changes which aim at improving the interoperability between the Java programming language and native libraries, which is one of the main goals of [Project Panama](https:\/\/openjdk.java.net\/projects\/panama\/). This is done by introducing a new Java API, the Foreign Function & Memory API, which can be used to:\n+\n+* interact with different kinds of memory resources, including so-called off-heap or native memory, as shown [here](doc\/panama_memaccess.md);\n+* find native functions in a .dll\/.so\/.dylib and invoke them using method handles, as shown [here](doc\/panama_ffi.md).\n+\n+This API has been delivered, as incubating\/preview APIs, in official JDK releases, see [JEP 412](https:\/\/openjdk.java.net\/jeps\/412), [JEP 419](https:\/\/openjdk.java.net\/jeps\/419) and [JEP 424](https:\/\/openjdk.java.net\/jeps\/424) for more details.\n+\n+The Foreign Function & Memory API is best used in combination with a tool called `jextract`, which can be used to generate Java bindings to access functions and\/or structs in a native library described by a given header file. The tool is available in a standalone [repository](https:\/\/github.com\/openjdk\/jextract) which contains several [examples](https:\/\/github.com\/openjdk\/jextract\/tree\/master\/samples) which should help you getting started.\n+\n+Early acccess (EA) binary snapshots of this repository can be found at: http:\/\/jdk.java.net\/panama\/\n","filename":"README.md","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,693 @@\n+<!doctype html>\n+<html>\n+<head>\n+<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>\n+\n+<link href='https:\/\/fonts.loli.net\/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text\/css' \/><style type='text\/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:\"Lucida Console\",Consolas,\"Courier\",monospace; --title-bar-height:20px; }\n+.mac-os-11 { --title-bar-height:28px; }\n+html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: \"Helvetica Neue\", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }\n+body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }\n+iframe { margin: auto; }\n+a.url { word-break: break-all; }\n+a:active, a:hover { outline: 0px; }\n+.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }\n+#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }\n+#write.first-line-indent p { text-indent: 2em; }\n+#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }\n+#write.first-line-indent li { margin-left: 2em; }\n+.for-image #write { padding-left: 8px; padding-right: 8px; }\n+body.typora-export { padding-left: 30px; padding-right: 30px; }\n+.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }\n+.typora-export .task-list-item input { pointer-events: none; }\n+@media screen and (max-width: 500px) {\n+  body.typora-export { padding-left: 0px; padding-right: 0px; }\n+  #write { padding-left: 20px; padding-right: 20px; }\n+}\n+#write li > figure:last-child { margin-bottom: 0.5rem; }\n+#write ol, #write ul { position: relative; }\n+img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }\n+button, input, select, textarea { color: inherit; font: inherit; }\n+input[type=\"checkbox\"], input[type=\"radio\"] { line-height: normal; padding: 0px; }\n+*, ::after, ::before { box-sizing: border-box; }\n+#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }\n+#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }\n+p { line-height: inherit; }\n+h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }\n+p { orphans: 4; }\n+h1 { font-size: 2rem; }\n+h2 { font-size: 1.8rem; }\n+h3 { font-size: 1.6rem; }\n+h4 { font-size: 1.4rem; }\n+h5 { font-size: 1.2rem; }\n+h6 { font-size: 1rem; }\n+.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }\n+.hidden { display: none; }\n+.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }\n+a { cursor: pointer; }\n+sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }\n+sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }\n+#write input[type=\"checkbox\"] { cursor: pointer; width: inherit; height: inherit; }\n+figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }\n+figure > table { margin: 0px; }\n+thead, tr { break-inside: avoid; break-after: auto; }\n+thead { display: table-header-group; }\n+table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }\n+table.md-table td { min-width: 32px; }\n+.CodeMirror-gutters { border-right: 0px; background-color: inherit; }\n+.CodeMirror-linenumber { user-select: none; }\n+.CodeMirror { text-align: left; }\n+.CodeMirror-placeholder { opacity: 0.3; }\n+.CodeMirror pre { padding: 0px 4px; }\n+.CodeMirror-lines { padding: 0px; }\n+div.hr:focus { cursor: none; }\n+#write pre { white-space: pre-wrap; }\n+#write.fences-no-line-wrapping pre { white-space: pre; }\n+#write pre.ty-contain-cm { white-space: normal; }\n+.CodeMirror-gutters { margin-right: 4px; }\n+.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }\n+.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }\n+#write .md-fences.mock-cm { white-space: pre-wrap; }\n+.md-fences.md-fences-with-lineno { padding-left: 0px; }\n+#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }\n+.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }\n+.CodeMirror-line, twitterwidget { break-inside: avoid; }\n+svg { break-inside: avoid; }\n+.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }\n+.footnotes + .footnotes { margin-top: 0px; }\n+.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }\n+li div { padding-top: 0px; }\n+blockquote { margin: 1rem 0px; }\n+li .mathjax-block, li p { margin: 0.5rem 0px; }\n+li blockquote { margin: 1rem 0px; }\n+li { margin: 0px; position: relative; }\n+blockquote > :last-child { margin-bottom: 0px; }\n+blockquote > :first-child, li > :first-child { margin-top: 0px; }\n+.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }\n+#write .footnote-line { white-space: pre-wrap; }\n+@media print {\n+  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }\n+  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; padding-bottom: 0px !important; }\n+  .typora-export * { -webkit-print-color-adjust: exact; }\n+  .typora-export #write { break-after: avoid; }\n+  .typora-export #write::after { height: 0px; }\n+  .is-mac table { break-inside: avoid; }\n+  .typora-export-show-outline .typora-export-sidebar { display: none; }\n+}\n+.footnote-line { margin-top: 0.714em; font-size: 0.7em; }\n+a img, img a { cursor: pointer; }\n+pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }\n+p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }\n+#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }\n+p > .md-image:only-child { display: inline-block; width: 100%; }\n+#write .MathJax_Display { margin: 0.8em 0px 0px; }\n+.md-math-block { width: 100%; }\n+.md-math-block:not(:empty)::after { display: none; }\n+.MathJax_ref { fill: currentcolor; }\n+[contenteditable=\"true\"]:active, [contenteditable=\"true\"]:focus, [contenteditable=\"false\"]:active, [contenteditable=\"false\"]:focus { outline: 0px; box-shadow: none; }\n+.md-task-list-item { position: relative; list-style-type: none; }\n+.task-list-item.md-task-list-item { padding-left: 0px; }\n+.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }\n+.math { font-size: 1rem; }\n+.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }\n+.md-toc-content { position: relative; margin-left: 0px; }\n+.md-toc-content::after, .md-toc::after { display: none; }\n+.md-toc-item { display: block; color: rgb(65, 131, 196); }\n+.md-toc-item a { text-decoration: none; }\n+.md-toc-inner:hover { text-decoration: underline; }\n+.md-toc-inner { display: inline-block; cursor: pointer; }\n+.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }\n+.md-toc-h2 .md-toc-inner { margin-left: 2em; }\n+.md-toc-h3 .md-toc-inner { margin-left: 4em; }\n+.md-toc-h4 .md-toc-inner { margin-left: 6em; }\n+.md-toc-h5 .md-toc-inner { margin-left: 8em; }\n+.md-toc-h6 .md-toc-inner { margin-left: 10em; }\n+@media screen and (max-width: 48em) {\n+  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }\n+  .md-toc-h4 .md-toc-inner { margin-left: 5em; }\n+  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }\n+  .md-toc-h6 .md-toc-inner { margin-left: 8em; }\n+}\n+a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }\n+.footnote-line a:not(.reversefootnote) { color: inherit; }\n+.reversefootnote { font-family: ui-monospace, sans-serif; }\n+.md-attr { display: none; }\n+.md-fn-count::after { content: \".\"; }\n+code, pre, samp, tt { font-family: var(--monospace); }\n+kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }\n+.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }\n+code { text-align: left; vertical-align: initial; }\n+a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }\n+.os-windows.monocolor-emoji .md-emoji { font-family: \"Segoe UI Symbol\", sans-serif; }\n+.md-diagram-panel > svg { max-width: 100%; }\n+[lang=\"flow\"] svg, [lang=\"mermaid\"] svg { max-width: 100%; height: auto; }\n+[lang=\"mermaid\"] .node text { font-size: 1rem; }\n+table tr th { border-bottom: 0px; }\n+video { max-width: 100%; display: block; margin: 0px auto; }\n+iframe { max-width: 100%; width: 100%; border: none; }\n+.highlight td, .highlight tr { border: 0px; }\n+mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }\n+.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }\n+.md-expand mark .md-meta { opacity: 0.3 !important; }\n+mark .md-meta { color: rgb(0, 0, 0); }\n+@media print {\n+  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }\n+}\n+.md-diagram-panel .messageText { stroke: none !important; }\n+.md-diagram-panel .start-state { fill: var(--node-fill); }\n+.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }\n+.md-fences.md-fences-math { font-size: 1em; }\n+.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }\n+.md-fences-advanced:not(.md-focus) { background: inherit; }\n+.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }\n+.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }\n+.typora-export-show-outline #write { --webkit-flex:2; flex: 2 1 0%; }\n+.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }\n+@media screen and (max-width: 1024px) {\n+  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }\n+}\n+@media screen and (max-width: 800px) {\n+  .typora-export-sidebar { display: none; }\n+}\n+.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; }\n+.outline-content ul { margin-top: 0px; margin-bottom: 0px; }\n+.outline-content strong { font-weight: 400; }\n+.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }\n+.outline-expander::before { content: \"\"; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }\n+.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }\n+.outline-expander:hover::before { content: \"\"; }\n+.outline-h1 > .outline-item { padding-left: 0px; }\n+.outline-h2 > .outline-item { padding-left: 1em; }\n+.outline-h3 > .outline-item { padding-left: 2em; }\n+.outline-h4 > .outline-item { padding-left: 3em; }\n+.outline-h5 > .outline-item { padding-left: 4em; }\n+.outline-h6 > .outline-item { padding-left: 5em; }\n+.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }\n+.outline-label:hover { text-decoration: underline; }\n+.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }\n+.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }\n+.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }\n+.outline-item-open > .outline-item > .outline-expander::before { content: \"\"; }\n+.outline-children { display: none; }\n+.info-panel-tab-wrapper { display: none; }\n+.outline-item-open > .outline-children { display: block; }\n+.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }\n+.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }\n+.typora-export .outline-expander::before { content: \"+\"; font-family: inherit; top: -1px; }\n+.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: \"−\"; }\n+.typora-export-collapse-outline .outline-children { display: none; }\n+.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }\n+.typora-export-no-collapse-outline .outline-expander::before { content: \"\" !important; }\n+.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }\n+.md-inline-math-container mjx-container { zoom: 0.95; }\n+mjx-container { break-inside: avoid; }\n+\n+\n+.CodeMirror { height: auto; }\n+.CodeMirror.cm-s-inner { background: inherit; }\n+.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }\n+.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }\n+.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }\n+.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }\n+.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }\n+.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }\n+.cm-s-inner .cm-number { color: rgb(17, 102, 68); }\n+.cm-s-inner .cm-def { color: rgb(0, 0, 255); }\n+.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }\n+.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }\n+.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }\n+.cm-s-inner .cm-string { color: rgb(170, 17, 17); }\n+.cm-s-inner .cm-property { color: rgb(0, 0, 0); }\n+.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }\n+.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }\n+.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }\n+.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }\n+.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }\n+.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }\n+.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }\n+.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }\n+.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }\n+.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }\n+.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }\n+.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }\n+.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }\n+.cm-negative { color: rgb(221, 68, 68); }\n+.cm-positive { color: rgb(34, 153, 34); }\n+.cm-header, .cm-strong { font-weight: 700; }\n+.cm-del { text-decoration: line-through; }\n+.cm-em { font-style: italic; }\n+.cm-link { text-decoration: underline; }\n+.cm-error { color: red; }\n+.cm-invalidchar { color: red; }\n+.cm-constant { color: rgb(38, 139, 210); }\n+.cm-defined { color: rgb(181, 137, 0); }\n+div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }\n+div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }\n+.cm-s-inner .CodeMirror-activeline-background { background: inherit; }\n+.CodeMirror { position: relative; overflow: hidden; }\n+.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }\n+.CodeMirror-sizer { position: relative; }\n+.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }\n+.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }\n+.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }\n+.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }\n+.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }\n+.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }\n+.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }\n+.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }\n+.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }\n+.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }\n+.CodeMirror-lines { cursor: text; }\n+.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }\n+.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }\n+.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }\n+.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }\n+.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }\n+.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }\n+.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }\n+.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }\n+.CodeMirror-measure pre { position: static; }\n+.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }\n+.CodeMirror div.CodeMirror-cursor { visibility: hidden; }\n+.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }\n+.cm-searching { background: rgba(255, 255, 0, 0.4); }\n+span.cm-underlined { text-decoration: underline; }\n+span.cm-strikethrough { text-decoration: line-through; }\n+.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }\n+.cm-tw-deleted { text-decoration: line-through; }\n+.cm-tw-header5 { font-weight: 700; }\n+.cm-tw-listitem:first-child { padding-left: 10px; }\n+.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }\n+.cm-tw-underline { text-decoration: underline; }\n+@media print {\n+  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }\n+}\n+\n+\n+:root {\n+    --side-bar-bg-color: #fafafa;\n+    --control-text-color: #777;\n+}\n+\n+@include-when-export url(https:\/\/fonts.loli.net\/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);\n+\n+\/* open-sans-regular - latin-ext_latin *\/\n+  \/* open-sans-italic - latin-ext_latin *\/\n+    \/* open-sans-700 - latin-ext_latin *\/\n+    \/* open-sans-700italic - latin-ext_latin *\/\n+  html {\n+    font-size: 16px;\n+    -webkit-font-smoothing: antialiased;\n+}\n+\n+body {\n+    font-family: \"Open Sans\",\"Clear Sans\", \"Helvetica Neue\", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;\n+    color: rgb(51, 51, 51);\n+    line-height: 1.6;\n+}\n+\n+#write {\n+    max-width: 860px;\n+  \tmargin: 0 auto;\n+  \tpadding: 30px;\n+    padding-bottom: 100px;\n+}\n+\n+@media only screen and (min-width: 1400px) {\n+\t#write {\n+\t\tmax-width: 1024px;\n+\t}\n+}\n+\n+@media only screen and (min-width: 1800px) {\n+\t#write {\n+\t\tmax-width: 1200px;\n+\t}\n+}\n+\n+#write > ul:first-child,\n+#write > ol:first-child{\n+    margin-top: 30px;\n+}\n+\n+a {\n+    color: #4183C4;\n+}\n+h1,\n+h2,\n+h3,\n+h4,\n+h5,\n+h6 {\n+    position: relative;\n+    margin-top: 1rem;\n+    margin-bottom: 1rem;\n+    font-weight: bold;\n+    line-height: 1.4;\n+    cursor: text;\n+}\n+h1:hover a.anchor,\n+h2:hover a.anchor,\n+h3:hover a.anchor,\n+h4:hover a.anchor,\n+h5:hover a.anchor,\n+h6:hover a.anchor {\n+    text-decoration: none;\n+}\n+h1 tt,\n+h1 code {\n+    font-size: inherit;\n+}\n+h2 tt,\n+h2 code {\n+    font-size: inherit;\n+}\n+h3 tt,\n+h3 code {\n+    font-size: inherit;\n+}\n+h4 tt,\n+h4 code {\n+    font-size: inherit;\n+}\n+h5 tt,\n+h5 code {\n+    font-size: inherit;\n+}\n+h6 tt,\n+h6 code {\n+    font-size: inherit;\n+}\n+h1 {\n+    font-size: 2.25em;\n+    line-height: 1.2;\n+    border-bottom: 1px solid #eee;\n+}\n+h2 {\n+    font-size: 1.75em;\n+    line-height: 1.225;\n+    border-bottom: 1px solid #eee;\n+}\n+\n+\/*@media print {\n+    .typora-export h1,\n+    .typora-export h2 {\n+        border-bottom: none;\n+        padding-bottom: initial;\n+    }\n+\n+    .typora-export h1::after,\n+    .typora-export h2::after {\n+        content: \"\";\n+        display: block;\n+        height: 100px;\n+        margin-top: -96px;\n+        border-top: 1px solid #eee;\n+    }\n+}*\/\n+\n+h3 {\n+    font-size: 1.5em;\n+    line-height: 1.43;\n+}\n+h4 {\n+    font-size: 1.25em;\n+}\n+h5 {\n+    font-size: 1em;\n+}\n+h6 {\n+   font-size: 1em;\n+    color: #777;\n+}\n+p,\n+blockquote,\n+ul,\n+ol,\n+dl,\n+table{\n+    margin: 0.8em 0;\n+}\n+li>ol,\n+li>ul {\n+    margin: 0 0;\n+}\n+hr {\n+    height: 2px;\n+    padding: 0;\n+    margin: 16px 0;\n+    background-color: #e7e7e7;\n+    border: 0 none;\n+    overflow: hidden;\n+    box-sizing: content-box;\n+}\n+\n+li p.first {\n+    display: inline-block;\n+}\n+ul,\n+ol {\n+    padding-left: 30px;\n+}\n+ul:first-child,\n+ol:first-child {\n+    margin-top: 0;\n+}\n+ul:last-child,\n+ol:last-child {\n+    margin-bottom: 0;\n+}\n+blockquote {\n+    border-left: 4px solid #dfe2e5;\n+    padding: 0 15px;\n+    color: #777777;\n+}\n+blockquote blockquote {\n+    padding-right: 0;\n+}\n+table {\n+    padding: 0;\n+    word-break: initial;\n+}\n+table tr {\n+    border: 1px solid #dfe2e5;\n+    margin: 0;\n+    padding: 0;\n+}\n+table tr:nth-child(2n),\n+thead {\n+    background-color: #f8f8f8;\n+}\n+table th {\n+    font-weight: bold;\n+    border: 1px solid #dfe2e5;\n+    border-bottom: 0;\n+    margin: 0;\n+    padding: 6px 13px;\n+}\n+table td {\n+    border: 1px solid #dfe2e5;\n+    margin: 0;\n+    padding: 6px 13px;\n+}\n+table th:first-child,\n+table td:first-child {\n+    margin-top: 0;\n+}\n+table th:last-child,\n+table td:last-child {\n+    margin-bottom: 0;\n+}\n+\n+.CodeMirror-lines {\n+    padding-left: 4px;\n+}\n+\n+.code-tooltip {\n+    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);\n+    border-top: 1px solid #eef2f2;\n+}\n+\n+.md-fences,\n+code,\n+tt {\n+    border: 1px solid #e7eaed;\n+    background-color: #f8f8f8;\n+    border-radius: 3px;\n+    padding: 0;\n+    padding: 2px 4px 0px 4px;\n+    font-size: 0.9em;\n+}\n+\n+code {\n+    background-color: #f3f4f4;\n+    padding: 0 2px 0 2px;\n+}\n+\n+.md-fences {\n+    margin-bottom: 15px;\n+    margin-top: 15px;\n+    padding-top: 8px;\n+    padding-bottom: 6px;\n+}\n+\n+\n+.md-task-list-item > input {\n+  margin-left: -1.3em;\n+}\n+\n+@media print {\n+    html {\n+        font-size: 13px;\n+    }\n+    pre {\n+        page-break-inside: avoid;\n+        word-wrap: break-word;\n+    }\n+}\n+\n+.md-fences {\n+\tbackground-color: #f8f8f8;\n+}\n+#write pre.md-meta-block {\n+\tpadding: 1rem;\n+    font-size: 85%;\n+    line-height: 1.45;\n+    background-color: #f7f7f7;\n+    border: 0;\n+    border-radius: 3px;\n+    color: #777777;\n+    margin-top: 0 !important;\n+}\n+\n+.mathjax-block>.code-tooltip {\n+\tbottom: .375rem;\n+}\n+\n+.md-mathjax-midline {\n+    background: #fafafa;\n+}\n+\n+#write>h3.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .375rem;\n+}\n+#write>h4.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .285714286rem;\n+}\n+#write>h5.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .285714286rem;\n+}\n+#write>h6.md-focus:before{\n+\tleft: -1.5625rem;\n+\ttop: .285714286rem;\n+}\n+.md-image>.md-meta {\n+    \/*border: 1px solid #ddd;*\/\n+    border-radius: 3px;\n+    padding: 2px 0px 0px 4px;\n+    font-size: 0.9em;\n+    color: inherit;\n+}\n+\n+.md-tag {\n+    color: #a7a7a7;\n+    opacity: 1;\n+}\n+\n+.md-toc { \n+    margin-top:20px;\n+    padding-bottom:20px;\n+}\n+\n+.sidebar-tabs {\n+    border-bottom: none;\n+}\n+\n+#typora-quick-open {\n+    border: 1px solid #ddd;\n+    background-color: #f8f8f8;\n+}\n+\n+#typora-quick-open-item {\n+    background-color: #FAFAFA;\n+    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;\n+    border-style: solid;\n+    border-width: 1px;\n+}\n+\n+\/** focus mode *\/\n+.on-focus-mode blockquote {\n+    border-left-color: rgba(85, 85, 85, 0.12);\n+}\n+\n+header, .context-menu, .megamenu-content, footer{\n+    font-family: \"Segoe UI\", \"Arial\", sans-serif;\n+}\n+\n+.file-node-content:hover .file-node-icon,\n+.file-node-content:hover .file-node-open-state{\n+    visibility: visible;\n+}\n+\n+.mac-seamless-mode #typora-sidebar {\n+    background-color: #fafafa;\n+    background-color: var(--side-bar-bg-color);\n+}\n+\n+.md-lang {\n+    color: #b4654d;\n+}\n+\n+\/*.html-for-mac {\n+    --item-hover-bg-color: #E6F0FE;\n+}*\/\n+\n+#md-notification .btn {\n+    border: 0;\n+}\n+\n+.dropdown-menu .divider {\n+    border-color: #e5e5e5;\n+    opacity: 0.4;\n+}\n+\n+.ty-preferences .window-content {\n+    background-color: #fafafa;\n+}\n+\n+.ty-preferences .nav-group-item.active {\n+    color: white;\n+    background: #999;\n+}\n+\n+.menu-item-container a.menu-style-btn {\n+    background-color: #f5f8fa;\n+    background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); \n+}\n+\n+\n+\n+<\/style><title>panama_ffi<\/title>\n+<\/head>\n+<body class='typora-export'><div class='typora-export-content'>\n+<div id='write'  class=''><h2 id='state-of-foreign-function-support'><span>State of foreign function support<\/span><\/h2><p><strong><span>January 2023<\/span><\/strong><\/p><p><strong><span>Maurizio Cimadamore<\/span><\/strong><\/p><p><span>The Foreign Function &amp; Memory API (FFM API in short) provides access to foreign functions through the <\/span><code>Linker<\/code><span> interface, which has been available as an <\/span><a href='https:\/\/openjdk.java.net\/jeps\/11'><span>incubating<\/span><\/a><span> API since Java <\/span><a href='https:\/\/openjdk.java.net\/jeps\/389'><span>16<\/span><\/a><span>. A linker allows clients to construct <\/span><em><span>downcall<\/span><\/em><span> method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, FFM API&#39;s foreign function support is completely expressed in terms of Java code and no intermediate native code is required.<\/span><\/p><h3 id='zero-length-memory-segments'><span>Zero-length memory segments<\/span><\/h3><p><span>Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the <\/span><a href='panama_memaccess.md'><span>foreign memory access support<\/span><\/a><span>. The Foreign Memory Access API allows client to create and manipulate <\/span><em><span>memory segments<\/span><\/em><span>. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always <\/span><em><span>safe<\/span><\/em><span>, and can never result in a VM crash, or, worse, in silent memory corruption.<\/span><\/p><p><span>Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known <\/span><em><span>in full<\/span><\/em><span> when the segment is created. But when we interact with native libraries we often receive <\/span><em><span>raw<\/span><\/em><span> pointers; such pointers have no spatial bounds (does a <\/span><code>char*<\/code><span> in C refer to one <\/span><code>char<\/code><span>, or a <\/span><code>char<\/code><span> array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in the FFM API are modelled using <\/span><em><span>zero-length memory segments<\/span><\/em><span>.<\/span><\/p><p><span>If clients want to dereference a zero-length memory segment, they can do so <\/span><em><span>unsafely<\/span><\/em><span> in two ways. First, the client can create a new memory segment from the zero-length memory segment <\/span><em><span>unsafely<\/span><\/em><span>, using the <\/span><code>MemorySegment::ofAddress<\/code><span> factory. This method is <\/span><em><span>restricted<\/span><\/em><span> and will generate runtime warnings if called without specifying the <\/span><code>--enable-native-access<\/code><span> command-line flag. By calling <\/span><code>MemorySegment::ofAddress<\/code><span> a client inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 758.438px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">raw<\/span> <span class=\"cm-operator\">=<\/span> ... <span class=\"cm-comment\">\/\/obtain address from native code<\/span><\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">segment<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MemorySegment<\/span>.<span class=\"cm-variable\">ofAddress<\/span>(<span class=\"cm-variable\">raw<\/span>.<span class=\"cm-variable\">address<\/span>(), <span class=\"cm-number\">100<\/span>, <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">x<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">segment<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>Alternatively, clients can obtain an <\/span><em><span>unbounded<\/span><\/em><span> address value layout. This is done using the <\/span><code>ValueLayout.OfAddress::asUnbounded<\/code><span> method (which is also a restricted method). When an access operation uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments with <\/span><em><span>maximal<\/span><\/em><span> size (i.e. <\/span><code>Long.MAX_VALUE<\/code><span>). As such, these segments can be accessed directly, as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 1138.39px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">foreign<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">someSegment<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">ValueLayout<\/span>.<span class=\"cm-variable\">ADDRESS<\/span>.<span class=\"cm-variable\">asUnbounded<\/span>(), <span class=\"cm-number\">0<\/span>); <span class=\"cm-comment\">\/\/ wrap address into segment (size = Long.MAX_VALUE)<\/span><\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">x<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">ValueLayout<\/span>.<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>); <span class=\"cm-comment\">\/\/ok<\/span><\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 46px;\"><\/div><\/div><\/div><\/pre><p><span>Which approach is taken largely depends on the information that a client has available when obtaining a memory segment wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.<\/span><\/p><h3 id='segment-allocators'><span>Segment allocators<\/span><\/h3><p><span>Idiomatic C code implicitly relies on stack allocation to allow for concise variable declarations; consider this example:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 267.219px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 266.219px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">arr<\/span>[] <span class=\"cm-operator\">=<\/span> { <span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span> };<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>A variable initializer such as the one above can be implemented as follows, using the Foreign Memory Access API:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 957.078px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span> <span class=\"cm-def\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">arr<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MemorySegment<\/span>.<span class=\"cm-variable\">allocateNative<\/span>(<span class=\"cm-variable\">MemoryLayout<\/span>.<span class=\"cm-variable\">sequenceLayout<\/span>(<span class=\"cm-number\">5<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>), <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">for<\/span> (<span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-number\">0<\/span> ; <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">&lt;<\/span> <span class=\"cm-number\">5<\/span> ; <span class=\"cm-variable\">i<\/span><span class=\"cm-operator\">++<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">arr<\/span>.<span class=\"cm-variable\">setAtIndex<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">i<\/span>, <span class=\"cm-variable\">i<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 138px;\"><\/div><\/div><\/div><\/pre><p><span>There are a number of issues with the above code snippet:<\/span><\/p><ul><li><span>compared to the C code, it is more verbose — the native array has to be initialized <\/span><em><span>element by element<\/span><\/em><\/li><li><span>allocation is very slow compared to C; allocating the <\/span><code>arr<\/code><span> variable now takes a full <\/span><code>malloc<\/code><span>, while in C the variable was simply stack-allocated<\/span><\/li><li><span>when having multiple declarations like the one above, it might become increasingly harder to manage the lifecycle of the various segments<\/span><\/li><\/ul><p><span>To address these problems, the FFM API provides a <\/span><code>SegmentAllocator<\/code><span> abstraction, a functional interface which provides methods to allocate commonly used values. Since <\/span><code>Arena<\/code><span> implements the <\/span><code>SegmentAllocator<\/code><span> interface, the above code can be rewritten conveniently as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 55.6172px; left: 241.188px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 603.016px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">arr<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>);<\/span><\/pre><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">} <span class=\"cm-comment\">\/\/ 'arr' is released here<\/span><\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 69px;\"><\/div><\/div><\/div><\/pre><p><span>In the above code, the arena acts as a <\/span><em><span>native<\/span><\/em><span> allocator (that is, an allocator built on top of <\/span><code>MemorySegment::allocateNative<\/code><span>). The arena is then used to create a native array, initialized to the values <\/span><code>0, 1, 2, 3, 4<\/code><span>.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied <\/span><em><span>in bulk<\/span><\/em><span> into the memory region associated with the newly allocated memory segment. The returned segment is associated with the scope of the arena which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.<\/span><\/p><p><span>Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the <\/span><code>SegmentAllocator<\/code><span> interface. For example, the following code creates a <\/span><em><span>slicing<\/span><\/em><span> allocator and uses it to allocate a segment whose content is initialized from a Java <\/span><code>int<\/code><span> array:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 170.852px; left: 379.359px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 784.406px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">SegmentAllocator<\/span> <span class=\"cm-variable\">allocator<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">SegmentAllocator<\/span>.<span class=\"cm-variable\">slicingAllocator<\/span>(<span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocate<\/span>(<span class=\"cm-number\">1024<\/span>));<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">for<\/span> (<span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-number\">0<\/span> ; <span class=\"cm-variable\">i<\/span> <span class=\"cm-operator\">&lt;<\/span> <span class=\"cm-number\">10<\/span> ; <span class=\"cm-variable\">i<\/span><span class=\"cm-operator\">++<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">s<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">allocator<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>,  <span class=\"cm-keyword\">new<\/span> <span class=\"cm-variable-3\">int<\/span>[] { <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>, <span class=\"cm-number\">5<\/span> });<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        ...<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    ...<\/span><\/pre><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"> } <span class=\"cm-comment\">\/\/ all memory allocated is released here<\/span><\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 184px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 184px;\"><\/div><\/div><\/div><\/pre><p><span>This code creates a native segment whose size is 1024 bytes. The segment is then used to create a slicing allocator, which responds to  allocation requests by returning slices of that pre-allocated segment.  If the current segment does not have sufficient space to accommodate an  allocation request, an exception is thrown. All of the memory associated with the segments created by the allocator (i.e., in the body of the  for loop) is deallocated atomically when the arena is closed. This  technique combines the advantages of deterministic deallocation,  provided by the <\/span><code>Arena<\/code><span> abstraction, with a more flexible and scalable allocation scheme. It can be very useful when writing code  which manages a large number of off-heap segments.<\/span><\/p><p><span>All the methods in the FFM API which <\/span><em><span>produce<\/span><\/em><span> memory segments (see <\/span><code>VaList::nextVarg<\/code><span> and downcall method handles), allow for an allocator parameter to be provided — this is key in ensuring that an application using the FFM API achieves optimal allocation performances, especially in non-trivial use cases.<\/span><\/p><h3 id='symbol-lookups'><span>Symbol lookups<\/span><\/h3><p><span>The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the <\/span><code>System::loadLibrary<\/code><span> and <\/span><code>System::load<\/code><span> methods. Unfortunately, these methods do not provide a way for clients to obtain the <\/span><em><span>address<\/span><\/em><span> associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely <\/span><code>SymbolLookup<\/code><span> (similar in spirit to a method handle lookup), which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 3 different ways:<\/span><\/p><ul><li><code>SymbolLookup::libraryLookup(String, SegmentScope)<\/code><span> — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is not longer alive, the library referred to by the lookup will also be closed;<\/span><\/li><li><code>SymbolLookup::loaderLookup<\/code><span> — creates a symbol lookup which can be used to search symbols in all the libraries loaded by the caller&#39;s classloader (e.g. using <\/span><code>System::loadLibrary<\/code><span> or <\/span><code>System::load<\/code><span>)<\/span><\/li><li><code>Linker::defaultLookup<\/code><span> — returns the default symbol lookup associated with a <\/span><code>Linker<\/code><span> instance. For instance, the default lookup of the native linker (see <\/span><code>Linker::nativeLinker<\/code><span>) can be used to look up platform-specific symbols in the standard C library (such as <\/span><code>strlen<\/code><span>, or <\/span><code>getpid<\/code><span>).<\/span><\/li><\/ul><p><span>Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the <\/span><code>find(String)<\/code><span> method, which returns an <\/span><code>Optional&lt;MemorySegment&gt;<\/code><span>.  The memory segments returned by the <\/span><code>lookup<\/code><span> are zero-length segments, whose base address is the address of the function or variable in the library.<\/span><\/p><p><span>For instance, the following code can be used to look up the <\/span><code>clang_getClangVersion<\/code><span> function provided by the <\/span><code>clang<\/code><span> library; it does so by creating a <\/span><em><span>library lookup<\/span><\/em><span> whose lifecycle is associated to that of a confined arena.<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 741.141px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">SymbolLookup<\/span> <span class=\"cm-variable\">libclang<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">SymbolLookup<\/span>.<span class=\"cm-variable\">libraryLookup<\/span>(<span class=\"cm-string\">\"libclang.so\"<\/span>, <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">clangVersion<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">libclang<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"clang_getClangVersion\"<\/span>).<span class=\"cm-variable\">get<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 92px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 92px;\"><\/div><\/div><\/div><\/pre><h3 id='linker'><span>Linker<\/span><\/h3><p><span>At the core of the FFM API&#39;s foreign function support we find the <\/span><code>Linker<\/code><span> abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling foreign function calls as plain <\/span><code>MethodHandle<\/code><span> calls (see <\/span><code>Linker::downcallHandle<\/code><span>); second, for upcalls, it allows to convert an existing <\/span><code>MethodHandle<\/code><span> (which might point to some Java method) into a <\/span><code>MemorySegment<\/code><span> which could then be passed to foreign functions as a function pointer (see <\/span><code>Linker::upcallStub<\/code><span>):<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 862.062px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><span><span>​<\/span>x<\/span><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">interface<\/span> <span class=\"cm-def\">Linker<\/span> {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">downcallHandle<\/span>(<span class=\"cm-variable\">Addressable<\/span> <span class=\"cm-variable\">symbol<\/span>, <span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">function<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">upcallStub<\/span>(<span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">target<\/span>, <span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">function<\/span>, <span class=\"cm-variable\">SegmentScope<\/span> <span class=\"cm-variable\">scope<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    ... <span class=\"cm-comment\">\/\/ some overloads omitted here<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">nativeLinker<\/span>() { ... }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 161px;\"><\/div><\/div><\/div><\/pre><p><span>Both functions take a <\/span><code>FunctionDescriptor<\/code><span> instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are <\/span><em><span>value layouts<\/span><\/em><span> (for scalars and pointers) and <\/span><em><span>group layouts<\/span><\/em><span> (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java <\/span><code>MethodType<\/code><span>  — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.<\/span><\/p><p><span>The <\/span><code>Linker::nativeLinker<\/code><span> factory is used to obtain a <\/span><code>Linker<\/code><span> implementation for the ABI associated with the OS and processor where the Java runtime is currently executing. As such, the native linker can be used to call C functions. The following table shows the mapping between C types, layouts and Java carriers under the Linux\/macOS native linker implementation; note that the mappings can be platform dependent: on Windows\/x64, the C type <\/span><code>long<\/code><span> is 32-bit, so the <\/span><code>JAVA_INT<\/code><span> layout (and the Java carrier <\/span><code>int.class<\/code><span>) would have to be used instead:<\/span><\/p><figure><table><thead><tr><th><span>C type<\/span><\/th><th><span>Layout<\/span><\/th><th><span>Java carrier<\/span><\/th><\/tr><\/thead><tbody><tr><td><code>bool<\/code><\/td><td><code>JAVA_BOOLEAN<\/code><\/td><td><code>byte<\/code><\/td><\/tr><tr><td><code>char<\/code><\/td><td><code>JAVA_BYTE<\/code><\/td><td><code>byte<\/code><\/td><\/tr><tr><td><code>short<\/code><\/td><td><code>JAVA_SHORT<\/code><\/td><td><code>short<\/code><span>, <\/span><code>char<\/code><\/td><\/tr><tr><td><code>int<\/code><\/td><td><code>JAVA_INT<\/code><\/td><td><code>int<\/code><\/td><\/tr><tr><td><code>long<\/code><\/td><td><code>JAVA_LONG<\/code><\/td><td><code>long<\/code><\/td><\/tr><tr><td><code>long long<\/code><\/td><td><code>JAVA_LONG<\/code><\/td><td><code>long<\/code><\/td><\/tr><tr><td><code>float<\/code><\/td><td><code>JAVA_FLOAT<\/code><\/td><td><code>float<\/code><\/td><\/tr><tr><td><code>double<\/code><\/td><td><code>JAVA_DOUBLE<\/code><\/td><td><code>double<\/code><\/td><\/tr><tr><td><code>char*<\/code><br><code>int**<\/code><br><span> ...<\/span><\/td><td><code>ADDRESS<\/code><\/td><td><code>MemorySegment<\/code><\/td><\/tr><tr><td><code>struct Point { int x; int y; };<\/code><br><code>union Choice { float a; int b; };<\/code><br><span>...<\/span><\/td><td><code>MemoryLayout.structLayout(...)<\/code><br><code>MemoryLayout.unionLayout(...)<\/code><br><\/td><td><code>MemorySegment<\/code><\/td><\/tr><\/tbody><\/table><\/figure><p><span>Both C structs\/unions and pointers are modelled using the <\/span><code>MemorySegment<\/code><span> carrier type. However, C structs\/unions are modelled in function descriptors with memory layouts of type <\/span><code>GroupLayout<\/code><span>, whereas pointers are modelled using the <\/span><code>ADDRESS<\/code><span> value layout constant (whose size is platform-specific). Moreover, the behavior of a downcall method handle returning a struct\/union type is radically different from that of a downcall method handle returning a C pointer:<\/span><\/p><ul><li><span>downcall method handles returning C pointers will wrap the pointer address into a fresh zero-length memory segment (unless an unbounded address layout is specified);<\/span><\/li><li><span>downcall method handles returning a C struct\/union type will return a <\/span><em><span>new<\/span><\/em><span> segment, of given size (the size of the struct\/union). The segment is allocated using a user-provided <\/span><code>SegmentAllocator<\/code><span>, which is provided using an additional prefix parameter inserted in the downcall method handle signature.<\/span><\/li><\/ul><p><span>A tool, such as <\/span><code>jextract<\/code><span>, will generate all the required C layouts (for scalars and structs\/unions) <\/span><em><span>automatically<\/span><\/em><span>, so that clients do not have to worry about platform-dependent details such as sizes, alignment constraints and padding.<\/span><\/p><h3 id='downcalls'><span>Downcalls<\/span><\/h3><p><span>We will now look at how foreign functions can be called from Java using the native linker. Assume we wanted to call the following function from the standard C library:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 257.516px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">size_t<\/span> <span class=\"cm-def\">strlen<\/span>(<span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">char<\/span> <span class=\"cm-variable-3\">*<\/span><span class=\"cm-variable\">s<\/span>);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>In order to do that, we have to:<\/span><\/p><ul><li><span>lookup the <\/span><code>strlen<\/code><span> symbol<\/span><\/li><li><span>describe the signature of the C function using a function descriptor<\/span><\/li><li><span>create a <\/span><em><span>downcall<\/span><\/em><span> native method handle with the above information, using the native linker<\/span><\/li><\/ul><p><span>Here&#39;s an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the <\/span><a href='#appendix-full-source-code'><span>appendix<\/span><\/a><span>):<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 456.156px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">linker<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>Note that, since the function <\/span><code>strlen<\/code><span> is part of the standard C library, which is loaded with the VM, we can just use the default lookup of the native linker to look it up. The rest is pretty straightforward — the only tricky detail is how to model <\/span><code>size_t<\/code><span>: typically this type has the size of a pointer, so we can use <\/span><code>JAVA_LONG<\/code><span> both Linux and Windows. On the Java side, we model the <\/span><code>size_t<\/code><span> using a <\/span><code>long<\/code><span> and the pointer is modelled using an <\/span><code>Addressable<\/code><span> parameter.<\/span><\/p><p><span>Once we have obtained the downcall method handle, we can just use it as any other method handle<\/span><a href=\"#2\"><sup><span>1<\/span><\/sup><\/a><span>:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 602.984px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">strlen<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>)); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 69px;\"><\/div><\/div><\/div><\/pre><p><span>Here we are using a confined arena to convert a Java string into an off-heap memory segment which contains a <\/span><code>NULL<\/code><span> terminated C string. We then pass that segment to the method handle and retrieve our result in a Java <\/span><code>long<\/code><span>. Note how all this is possible <\/span><em><span>without<\/span><\/em><span> any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an arena to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.<\/span><\/p><p><span>The <\/span><code>Linker<\/code><span> interface also supports linking of native functions without an address known at link time; when that happens, an address (of type <\/span><code>MemorySegment<\/code><span>) must be provided when the method handle returned by the linker is invoked — this is very useful to support <\/span><em><span>virtual calls<\/span><\/em><span>. For instance, the above code can be rewritten as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 715.219px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen_virtual<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>( <span class=\"cm-comment\">\/\/ address parameter missing!<\/span><\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span> <span class=\"cm-def\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">strlen_virtual<\/span>.<span class=\"cm-variable\">invoke<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>() <span class=\"cm-comment\">\/\/ address provided here!<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    ); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 230px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 230px;\"><\/div><\/div><\/div><\/pre><p><span>It is important to note that, albeit the interop code is written in Java, the above code can <\/span><em><span>not<\/span><\/em><span> be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Java runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Java runtime has to <\/span><em><span>trust<\/span><\/em><span> the function descriptor passed in<\/span><a href=\"#2\"><sup><span>2<\/span><\/sup><\/a><span>; for this reason, the <\/span><code>Linker::nativeLinker<\/code><span> factory is also a restricted method.<\/span><\/p><p><span>When working with shared arenas, it is always possible for the arena associated with a memory segment passed <\/span><em><span>by reference<\/span><\/em><span> to a native function to be closed (by another thread) <\/span><em><span>while<\/span><\/em><span> the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the <\/span><code>Linker<\/code><span> API provides some basic temporal safety guarantees: any <\/span><code>MemorySegment<\/code><span> instance passed by reference to a downcall method handle will be <\/span><em><span>kept alive<\/span><\/em><span> for the entire duration of the call. In other words, it&#39;s as if the call to the downcall method handle occurred inside an invisible call to <\/span><code>SegmentScope::whileAlive<\/code><span>.<\/span><\/p><p><span>Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is <\/span><em><span>very<\/span><\/em><span>. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a <\/span><em><span>hot<\/span><\/em><span> loop), the JIT compiler might decide to generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.<\/span><\/p><h3 id='upcalls'><span>Upcalls<\/span><\/h3><p><span>Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let&#39;s consider the following function from the C standard library:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 473.469px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">void<\/span> <span class=\"cm-def\">qsort<\/span>(<span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable-3\">*<\/span><span class=\"cm-variable\">base<\/span>, <span class=\"cm-variable-3\">size_t<\/span> <span class=\"cm-variable\">nmemb<\/span>, <span class=\"cm-variable-3\">size_t<\/span> <span class=\"cm-variable\">size<\/span>,<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">           <span class=\"cm-variable-3\">int<\/span> (<span class=\"cm-operator\">*<\/span><span class=\"cm-variable\">compar<\/span>)(<span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable-3\">*<\/span>, <span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable-3\">*<\/span>));<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 46px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 46px;\"><\/div><\/div><\/div><\/pre><p><span>The <\/span><code>qsort<\/code><span> function can be used to sort the contents of an array, using a custom comparator function — <\/span><code>compar<\/code><span> — which is passed as a function pointer. To be able to call the <\/span><code>qsort<\/code><span> function from Java we have first to create a downcall method handle for it:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 637.516px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">linker<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">qsort<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">lookup<\/span>(<span class=\"cm-string\">\"qsort\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">ofVoid<\/span>(<span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>As before, we use <\/span><code>JAVA_LONG<\/code><span> and <\/span><code>long.class<\/code><span> to map the C <\/span><code>size_t<\/code><span> type, and <\/span><code>ADDRESS<\/code><span> for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).<\/span><\/p><p><span>This time, in order to invoke the <\/span><code>qsort<\/code><span> downcall handle, we need a <\/span><em><span>function pointer<\/span><\/em><span> to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let&#39;s write a function that can compare two int elements (passed as pointers):<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 620.25px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">class<\/span> <span class=\"cm-def\">Qsort<\/span> {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">qsortCompare<\/span>(<span class=\"cm-variable\">MemoryAddress<\/span> <span class=\"cm-variable\">addr1<\/span>, <span class=\"cm-variable\">MemoryAddress<\/span> <span class=\"cm-variable\">addr2<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-keyword\">return<\/span> <span class=\"cm-variable\">addr1<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>) <span class=\"cm-operator\">-<\/span> <span class=\"cm-variable\">addr2<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span>}<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 115px;\"><\/div><\/div><\/div><\/pre><p><span>Here we can see that the function is performing some <\/span><em><span>unsafe<\/span><\/em><span> dereference of the pointer contents.<\/span><\/p><p><span>Now let&#39;s create a method handle pointing to the comparator function above:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 741.078px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">comparDesc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>);<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">comparHandle<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MethodHandles<\/span>.<span class=\"cm-variable\">lookup<\/span>()<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                         .<span class=\"cm-variable\">findStatic<\/span>(<span class=\"cm-variable\">Qsort<\/span>.<span class=\"cm-keyword\">class<\/span>, <span class=\"cm-string\">\"qsortCompare\"<\/span>,<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                                     <span class=\"cm-variable\">CLinker<\/span>.<span class=\"cm-variable\">upcallType<\/span>(<span class=\"cm-variable\">comparDesc<\/span>));<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 92px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 92px;\"><\/div><\/div><\/div><\/pre><p><span>To do that, we first create a function descriptor for the function pointer type, and then we use the <\/span><code>CLinker::upcallType<\/code><span> to turn that function descriptor into a suitable <\/span><code>MethodType<\/code><span> instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the <\/span><code>qsort<\/code><span> downcall handle:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 732.5px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">comparFunc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">upcallStub<\/span>(<span class=\"cm-variable\">comparHandle<\/span>, <span class=\"cm-variable\">comparDesc<\/span>, <span class=\"cm-variable\">session<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">array<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">session<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">9<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>, <span class=\"cm-number\">6<\/span>, <span class=\"cm-number\">5<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">8<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">7<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">qsort<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">array<\/span>, <span class=\"cm-number\">10L<\/span>, <span class=\"cm-number\">4L<\/span>, <span class=\"cm-variable\">comparFunc<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable-3\">int<\/span>[] <span class=\"cm-variable\">sorted<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">array<\/span>.<span class=\"cm-variable\">toArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>); <span class=\"cm-comment\">\/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 138px;\"><\/div><\/div><\/div><\/pre><p><span>The above code creates an upcall stub — <\/span><code>comparFunc<\/code><span> — a function pointer that can be used to invoke our Java comparator function, of type <\/span><code>MemorySegment<\/code><span>. The upcall stub is associated with the provided segment scope instance; this means that the stub will be uninstalled when the arena is closed.<\/span><\/p><p><span>The snippet then creates an off-heap array from a Java array, which is then passed to the <\/span><code>qsort<\/code><span> handle, along with the comparator function we obtained from the foreign linker.  As a side effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.<\/span><\/p><h3 id='varargs'><span>Varargs<\/span><\/h3><p><span>Some C functions are <\/span><em><span>variadic<\/span><\/em><span> and can take an arbitrary number of arguments. Perhaps the most common example of this is the <\/span><code>printf<\/code><span> function, defined in the C standard library:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"c\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 317.969px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable-3\">int<\/span> <span class=\"cm-def\">printf<\/span>(<span class=\"cm-keyword\">const<\/span> <span class=\"cm-variable-3\">char<\/span> <span class=\"cm-variable-3\">*<\/span><span class=\"cm-variable\">format<\/span>, ...);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>This function takes a format string, which features zero or more <\/span><em><span>holes<\/span><\/em><span>, and then can take a number of additional arguments that is identical to the number of holes in the format string.<\/span><\/p><p><span>The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let&#39;s say we wanted to model the following C call:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"C\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"c\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 352.516px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">printf<\/span>(<span class=\"cm-string\">\"%d plus %d equals %d\"<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">4<\/span>);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 23px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 23px;\"><\/div><\/div><\/div><\/pre><p><span>To do this using the foreign function support provided by the FFM API we would have to build a <\/span><em><span>specialized<\/span><\/em><span> downcall handle for that call shape, using a linker option to specify the position of the first variadic layout, as follows:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 680.703px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">linker<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">printf<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-tab\" role=\"presentation\" cm-text=\"\t\">    <\/span><span class=\"cm-variable\">linker<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>().<span class=\"cm-variable\">lookup<\/span>(<span class=\"cm-string\">\"printf\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">Option<\/span>.<span class=\"cm-variable\">firstVariadicArg<\/span>(<span class=\"cm-number\">1<\/span>) <span class=\"cm-comment\">\/\/ first int is variadic<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">);<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 138px;\"><\/div><\/div><\/div><\/pre><p><span>Then we can call the specialized downcall handle as usual:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 922.547px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-variable\">printf<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"%d plus %d equals %d\"<\/span>), <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">4<\/span>); <span class=\"cm-comment\">\/\/prints \"2 plus 2 equals 4\"<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 69px;\"><\/div><\/div><\/div><\/pre><p><span>While this works, and provides optimal performance, it has some limitations<\/span><a href=\"#3\"><sup><span>3<\/span><\/sup><\/a><span>:<\/span><\/p><ul><li><span>If the variadic function needs to be called with many shapes, we have to create many downcall handles<\/span><\/li><li><span>while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.<\/span><\/li><\/ul><h3 id='appendix-full-source-code'><span>Appendix: full source code<\/span><\/h3><p><span>The full source code containing most of the code shown throughout this document can be seen below:<\/span><\/p><pre class=\"md-fences md-end-block ty-contain-cm modeLoaded\" spellcheck=\"false\" lang=\"java\" style=\"break-inside: unset;\"><div class=\"CodeMirror cm-s-inner cm-s-null-scroll\" lang=\"java\"><div style=\"overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.52344px; left: 8px;\"><textarea autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" tabindex=\"0\" style=\"position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;\"><\/textarea><\/div><div class=\"CodeMirror-scrollbar-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-gutter-filler\" cm-not-content=\"true\"><\/div><div class=\"CodeMirror-scroll\" tabindex=\"-1\"><div class=\"CodeMirror-sizer\" style=\"margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; min-width: 1026.14px; padding-right: 0px; padding-bottom: 0px;\"><div style=\"position: relative; top: 0px;\"><div class=\"CodeMirror-lines\" role=\"presentation\"><div role=\"presentation\" style=\"position: relative; outline: none;\"><div class=\"CodeMirror-measure\"><pre>x<\/pre><\/div><div class=\"CodeMirror-measure\"><\/div><div style=\"position: relative; z-index: 1;\"><\/div><div class=\"CodeMirror-code\" role=\"presentation\" style=\"\"><div class=\"CodeMirror-activeline\" style=\"position: relative;\"><div class=\"CodeMirror-activeline-background CodeMirror-linebackground\"><\/div><div class=\"CodeMirror-gutter-background CodeMirror-activeline-gutter\" style=\"left: 0px; width: 0px;\"><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">Arena<\/span>;<\/span><\/pre><\/div><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">Linker<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">FunctionDescriptor<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">SymbolLookup<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">MemorySegment<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">VaList<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">invoke<\/span>.<span class=\"cm-variable\">MethodHandle<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">invoke<\/span>.<span class=\"cm-variable\">MethodHandles<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">util<\/span>.<span class=\"cm-variable\">Arrays<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">import<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">java<\/span>.<span class=\"cm-variable\">lang<\/span>.<span class=\"cm-variable\">foreign<\/span>.<span class=\"cm-variable\">ValueLayout<\/span>.<span class=\"cm-operator\">*<\/span>;<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">class<\/span> <span class=\"cm-def\">Examples<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">Linker<\/span> <span class=\"cm-variable\">LINKER<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">nativeLinker<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable\">SymbolLookup<\/span> <span class=\"cm-variable\">STDLIB<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">defaultLookup<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">main<\/span>(<span class=\"cm-variable-3\">String<\/span>[] <span class=\"cm-variable\">args<\/span>) <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">strlen<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">strlen_virtual<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">qsort<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">printf<\/span>();<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">strlen<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">hello<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> (<span class=\"cm-variable-3\">long<\/span>) <span class=\"cm-variable\">strlen<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">hello<\/span>); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">System<\/span>.<span class=\"cm-variable\">out<\/span>.<span class=\"cm-variable\">println<\/span>(<span class=\"cm-variable\">len<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">strlen_virtual<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">strlen_virtual<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">hello<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"Hello\"<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable-3\">long<\/span> <span class=\"cm-variable\">len<\/span> <span class=\"cm-operator\">=<\/span> (<span class=\"cm-variable-3\">long<\/span>) <span class=\"cm-variable\">strlen_virtual<\/span>.<span class=\"cm-variable\">invoke<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"strlen\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">hello<\/span>); <span class=\"cm-comment\">\/\/ 5<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">System<\/span>.<span class=\"cm-variable\">out<\/span>.<span class=\"cm-variable\">println<\/span>(<span class=\"cm-variable\">len<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">static<\/span> <span class=\"cm-keyword\">class<\/span> <span class=\"cm-def\">Qsort<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">int<\/span> <span class=\"cm-variable\">qsortCompare<\/span>(<span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">addr1<\/span>, <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">addr2<\/span>) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-keyword\">return<\/span> <span class=\"cm-variable\">addr1<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>) <span class=\"cm-operator\">-<\/span> <span class=\"cm-variable\">addr2<\/span>.<span class=\"cm-variable\">get<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">qsort<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">qsort<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"qsort\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">ofVoid<\/span>(<span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">JAVA_LONG<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>)<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">FunctionDescriptor<\/span> <span class=\"cm-variable\">comparDesc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>.<span class=\"cm-variable\">asUnbounded<\/span>(), <span class=\"cm-variable\">ADDRESS<\/span>.<span class=\"cm-variable\">asUnbounded<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">comparHandle<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">MethodHandles<\/span>.<span class=\"cm-variable\">lookup<\/span>()<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                         .<span class=\"cm-variable\">findStatic<\/span>(<span class=\"cm-variable\">Qsort<\/span>.<span class=\"cm-keyword\">class<\/span>, <span class=\"cm-string\">\"qsortCompare\"<\/span>,<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                                                     <span class=\"cm-variable\">comparDesc<\/span>.<span class=\"cm-variable\">toMethodType<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">comparFunc<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">upcallStub<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">comparHandle<\/span>, <span class=\"cm-variable\">comparDesc<\/span>, <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">scope<\/span>());<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">array<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-number\">0<\/span>, <span class=\"cm-number\">9<\/span>, <span class=\"cm-number\">3<\/span>, <span class=\"cm-number\">4<\/span>, <span class=\"cm-number\">6<\/span>, <span class=\"cm-number\">5<\/span>, <span class=\"cm-number\">1<\/span>, <span class=\"cm-number\">8<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">7<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">qsort<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">array<\/span>, <span class=\"cm-number\">10L<\/span>, <span class=\"cm-number\">4L<\/span>, <span class=\"cm-variable\">comparFunc<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable-3\">int<\/span>[] <span class=\"cm-variable\">sorted<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">array<\/span>.<span class=\"cm-variable\">toArray<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>); <span class=\"cm-comment\">\/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">System<\/span>.<span class=\"cm-variable\">out<\/span>.<span class=\"cm-variable\">println<\/span>(<span class=\"cm-variable\">Arrays<\/span>.<span class=\"cm-variable\">toString<\/span>(<span class=\"cm-variable\">sorted<\/span>));<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\"><span cm-text=\"\" cm-zwsp=\"\">\n+<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    <span class=\"cm-keyword\">public<\/span> <span class=\"cm-keyword\">static<\/span> <span class=\"cm-variable-3\">void<\/span> <span class=\"cm-variable\">printf<\/span>() <span class=\"cm-keyword\">throws<\/span> <span class=\"cm-variable\">Throwable<\/span> {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-variable\">MethodHandle<\/span> <span class=\"cm-variable\">printf<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">LINKER<\/span>.<span class=\"cm-variable\">downcallHandle<\/span>(<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">STDLIB<\/span>.<span class=\"cm-variable\">find<\/span>(<span class=\"cm-string\">\"printf\"<\/span>).<span class=\"cm-variable\">get<\/span>(),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">FunctionDescriptor<\/span>.<span class=\"cm-variable\">of<\/span>(<span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">ADDRESS<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>, <span class=\"cm-variable\">JAVA_INT<\/span>),<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">                <span class=\"cm-variable\">Linker<\/span>.<span class=\"cm-variable\">Option<\/span>.<span class=\"cm-variable\">firstVariadicArg<\/span>(<span class=\"cm-number\">1<\/span>) <span class=\"cm-comment\">\/\/ first int is variadic<\/span><\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        );<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        <span class=\"cm-keyword\">try<\/span> (<span class=\"cm-variable\">Arena<\/span> <span class=\"cm-variable\">arena<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">Arena<\/span>.<span class=\"cm-variable\">openConfined<\/span>()) {<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">MemorySegment<\/span> <span class=\"cm-variable\">s<\/span> <span class=\"cm-operator\">=<\/span> <span class=\"cm-variable\">arena<\/span>.<span class=\"cm-variable\">allocateUtf8String<\/span>(<span class=\"cm-string\">\"%d plus %d equals %d\\n\"<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">            <span class=\"cm-variable\">printf<\/span>.<span class=\"cm-variable\">invoke<\/span>(<span class=\"cm-variable\">s<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">2<\/span>, <span class=\"cm-number\">4<\/span>);<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">        }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">    }<\/span><\/pre><pre class=\" CodeMirror-line \" role=\"presentation\"><span role=\"presentation\" style=\"padding-right: 0.1px;\">}<\/span><\/pre><\/div><\/div><\/div><\/div><\/div><div style=\"position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 2097px;\"><\/div><div class=\"CodeMirror-gutters\" style=\"display: none; height: 2097px;\"><\/div><\/div><\/div><\/pre><p>&nbsp;<\/p><ul><li><a id=\"1\"\/><span>(<\/span><sup><span>1<\/span><\/sup><span>):<\/span><small><span> For simplicity, the examples shown in this document use <\/span><code>MethodHandle::invoke<\/code><span> rather than <\/span><code>MethodHandle::invokeExact<\/code><span>; by doing so we avoid having to cast by-reference arguments back to <\/span><code>Addressable<\/code><span>. With <\/span><code>invokeExact<\/code><span> the method handle invocation should be rewritten as <\/span><code>strlen.invokeExact((Addressable)session.allocateUtf8String(&quot;Hello&quot;));<\/code><\/small><\/li><li><a id=\"2\"\/><span>(<\/span><sup><span>2<\/span><\/sup><span>):<\/span><small><span> In reality this is not entirely new; even in JNI, when you call a <\/span><code>native<\/code><span> method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/span><\/small><\/li><li><a id=\"3\"\/><span>(<\/span><sup><span>3<\/span><\/sup><span>):<\/span><small><span> Previous iterations of the FFM API provided a <\/span><code>VaList<\/code><span> class that could be used to model a C <\/span><code>va_list<\/code><span>. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the <\/span><code>jextract<\/code><span> tool might provide higher-level bindings for variadic calls. <\/span><\/small><\/li><\/ul><\/div><\/div>\n+<\/body>\n+<\/html>\n\\ No newline at end of file\n","filename":"doc\/panama_ffi.html","additions":693,"deletions":0,"binary":false,"changes":693,"status":"added"},{"patch":"@@ -0,0 +1,363 @@\n+## State of foreign function support\n+\n+**March 2023**\n+\n+**Maurizio Cimadamore**\n+\n+The Foreign Function & Memory API (FFM API in short) provides access to foreign functions through the `Linker` interface, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). A linker allows clients to construct *downcall* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, FFM API's foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+\n+### Zero-length memory segments\n+\n+Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the [foreign memory access support](panama_memaccess.md). The Foreign Memory Access API allows client to create and manipulate *memory segments*. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always *safe*, and can never result in a VM crash, or, worse, in silent memory corruption.\n+\n+Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we often receive *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in the FFM API are modelled using *zero-length memory segments*.\n+\n+To work with native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>. First, clients can unsafely resize a zero-length memory segment by obtaining a memory segment with the same base address as the zero-length memory segment, but with the desired size, so that the resulting segment can then be accessed directly, as follows:\n+\n+```java\n+MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ size = 0\n+                                   .reinterpret(4)               \/\/ size = 4\n+int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n+```\n+\n+In some cases, a client might additionally want to assign new temporal bounds to a zero-length memory segment. This can be done using another variant of the `MemorySegment::reinterpret` method, which returns a new native segment with the desired size and temporal bounds:\n+\n+```java\n+MemorySegment foreign = null;\n+try (Arena arena = Arena.ofConfined()) {\n+      foreign = someSegment.get(ValueLayout.ADDRESS, 0)           \/\/ size = 0, scope = always alive\n+                           .reinterpret(4, arena, null);          \/\/ size = 4, scope = arena.scope()\n+      int x = foreign.get(ValueLayout.JAVA_INT, 0);               \/\/ ok\n+}\n+int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ throws IllegalStateException\n+```\n+\n+Note how the new segment behaves as if it was allocated in the provided arena: when the arena is closed, the new segment is no longer accessible.\n+\n+Alternatively, if the size of the foreign segment is known statically, clients can associate a *target layout* with the address layout used to obtain the segment. When an access operation, or a function descriptor that is passed to a downcall method handle (see below), uses an address value layout with target layout `T`, the runtime will wrap any corresponding raw addresses as segments with size set to `T.byteSize()`:\n+```java\n+MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ size = 4\n+int x = foreign.get(ValueLayout.JAVA_INT, 0);                                               \/\/ ok\n+```\n+\n+Which approach is taken largely depends on the information that a client has available when obtaining a memory segment wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). If the size is known statically, using an address layout with the correct target layout might be preferable. In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n+\n+> Note: Memory segments created using `MemorySegment::reinterpret`, or `OfAddress::withTargetLayout` are completely *unsafe*. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size and temporal bounds of the memory region pointed by the address indeed conforms to the parameters provided by the client. For these reasons, these methods are *restricted method* in the FFM API. The first time a restricted method is invoked, a runtime warning is generated. Developers can get rid of warnings by specifying the set of modules that are allowed to call restricted methods. This is done by specifying the option `--enable-native-access=M`, where `M` is a module name. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. If the `--enable-native-access` option is specified, any attempt to call restricted operations from a module not listed in the option will fail with a runtime exception.\n+\n+### Symbol lookups\n+\n+The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the `System::loadLibrary` and `System::load` methods. Unfortunately, these methods do not provide a way for clients to obtain the *address* associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely `SymbolLookup` (similar in spirit to a method handle lookup), which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 3 different ways:\n+\n+* `SymbolLookup::libraryLookup(String, SegmentScope)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is no longer alive, the library referred to by the lookup will also be closed;\n+* `SymbolLookup::loaderLookup` — creates a symbol lookup which can be used to search symbols in all the libraries loaded by the caller's classloader (e.g. using `System::loadLibrary` or `System::load`)\n+* `Linker::defaultLookup` — returns the default symbol lookup associated with a `Linker` instance. For instance, the default lookup of the native linker (see `Linker::nativeLinker`) can be used to look up platform-specific symbols in the standard C library (such as `strlen`, or `getpid`).\n+\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `find(String)` method, which returns an `Optional<MemorySegment>`.  The memory segments returned by the `lookup` are zero-length segments, whose base address is the address of the function or variable in the library.\n+\n+For instance, the following code can be used to look up the `clang_getClangVersion` function provided by the `clang` library; it does so by creating a *library lookup* whose lifecycle is associated to that of a confined arena.\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    SymbolLookup libclang = SymbolLookup.libraryLookup(\"libclang.so\", arena);\n+    MemorySegment clangVersion = libclang.find(\"clang_getClangVersion\").get();\n+}\n+```\n+\n+### Linker\n+\n+At the core of the FFM API's foreign function support we find the `Linker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling foreign function calls as plain `MethodHandle` calls (see `Linker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to foreign functions as a function pointer (see `Linker::upcallStub`):\n+\n+```java\n+interface Linker {\n+    MethodHandle downcallHandle(MemorySegment symbol, FunctionDescriptor function);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope);\n+    ... \/\/ some overloads omitted here\n+\n+    static Linker nativeLinker() { ... }\n+}\n+```\n+\n+Both functions take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the argument and return types of a foreign function in full. Supported layouts are *value layouts* (for scalars and pointers) and *group layouts* (for structs\/unions). Each layout in a function descriptor is associated with a carrier Java type (see table below); together, all the carrier types associated with layouts in a function descriptor will determine a unique Java `MethodType` — that is, the Java signature that clients will be using when interacting with said downcall handles, or upcall stubs.\n+\n+The `Linker::nativeLinker` factory is used to obtain a `Linker` implementation for the ABI associated with the OS and processor where the Java runtime is currently executing. As such, the native linker can be used to call C functions. The following table shows the mapping between C types, layouts and Java carriers under the Linux\/macOS native linker implementation; note that the mappings can be platform dependent: on Windows\/x64, the C type `long` is 32-bit, so the `JAVA_INT` layout (and the Java carrier `int.class`) would have to be used instead:\n+\n+| C type                                                       | Layout                                                       | Java carrier    |\n+| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |\n+| `bool`                                                       | `JAVA_BOOLEAN`                                               | `byte`          |\n+| `char`                                                       | `JAVA_BYTE`                                                  | `byte`          |\n+| `short`                                                      | `JAVA_SHORT`                                                 | `short`, `char` |\n+| `int`                                                        | `JAVA_INT`                                                   | `int`           |\n+| `long`                                                       | `JAVA_LONG`                                                  | `long`          |\n+| `long long`                                                  | `JAVA_LONG`                                                  | `long`          |\n+| `float`                                                      | `JAVA_FLOAT`                                                 | `float`         |\n+| `double`                                                     | `JAVA_DOUBLE`                                                | `double`        |\n+| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`                                                    | `MemorySegment` |\n+| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `MemoryLayout.structLayout(...)`<br \/>`MemoryLayout.unionLayout(...)`<br \/> | `MemorySegment` |\n+\n+Both C structs\/unions and pointers are modelled using the `MemorySegment` carrier type. However, C structs\/unions are modelled in function descriptors with memory layouts of type `GroupLayout`, whereas pointers are modelled using the `ADDRESS` value layout constant (whose size is platform-specific). Moreover, the behavior of a downcall method handle returning a struct\/union type is radically different from that of a downcall method handle returning a C pointer:\n+\n+* downcall method handles returning C pointers will wrap the pointer address into a fresh zero-length memory segment (unless an unbounded address layout is specified);\n+* downcall method handles returning a C struct\/union type will return a *new* segment, of given size (the size of the struct\/union). The segment is allocated using a user-provided `SegmentAllocator`, which is provided using an additional prefix parameter inserted in the downcall method handle signature.\n+\n+A tool, such as `jextract`, will generate all the required C layouts (for scalars and structs\/unions) *automatically*, so that clients do not have to worry about platform-dependent details such as sizes, alignment constraints and padding.\n+\n+### Downcalls\n+\n+We will now look at how foreign functions can be called from Java using the native linker. Assume we wanted to call the following function from the standard C library:\n+\n+```c\n+size_t strlen(const char *s);\n+```\n+\n+In order to do that, we have to:\n+\n+* lookup the `strlen` symbol\n+* describe the signature of the C function using a function descriptor\n+\n+* create a *downcall* native method handle with the above information, using the native linker\n+\n+Here's an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the [appendix](#appendix-full-source-code)):\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle strlen = linker.downcallHandle(\n+        linker.defaultLookup().find(\"strlen\").get(),\n+        FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+);\n+```\n+\n+Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the default lookup of the native linker to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `JAVA_LONG` both Linux and Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modelled using an `MemorySegment` parameter.\n+\n+Once we have obtained the downcall method handle, we can just use it as any other method handle:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    long len = strlen.invokeExact(arena.allocateUtf8String(\"Hello\")); \/\/ 5\n+}\n+```\n+\n+Here we are using a confined arena to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this is possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an arena to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n+\n+The `Linker` interface also supports linking of native functions without an address known at link time; when that happens, an address (of type `MemorySegment`) must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n+\n+```java\n+MethodHandle strlen_virtual = linker.downcallHandle( \/\/ address parameter missing!\n+\t\tFunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+);\n+\n+try (Arena arena = Arena.ofConfined()) {\n+    long len = strlen_virtual.invokeExact(\n+        linker.defaultLookup().find(\"strlen\").get() \/\/ address provided here!\n+        arena.allocateUtf8String(\"Hello\")\n+    ); \/\/ 5\n+}\n+```\n+\n+It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Java runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Java runtime has to *trust* the function descriptor passed in<a href=\"#1\"><sup>1<\/sup><\/a>; for this reason, the `Linker::nativeLinker` factory is also a restricted method.\n+\n+When working with shared arenas, it is always possible for the arena associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `MemorySegment` instance passed by reference to a downcall method handle will be *kept alive* for the entire duration of the call.\n+\n+Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside a *hot* loop), the JIT compiler might decide to generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI.\n+\n+### Upcalls\n+\n+Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let's consider the following function from the C standard library:\n+\n+```c\n+void qsort(void *base, size_t nmemb, size_t size,\n+           int (*compar)(const void *, const void *));\n+```\n+\n+The `qsort` function can be used to sort the contents of an array, using a custom comparator function — `compar` — which is passed as a function pointer. To be able to call the `qsort` function from Java we have first to create a downcall method handle for it:\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle qsort = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"qsort\").get(),\n+        FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+);\n+```\n+\n+As before, we use `JAVA_LONG` and `long.class` to map the C `size_t` type, and `ADDRESS` for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n+\n+This time, in order to invoke the `qsort` downcall handle, we need a *function pointer* to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let's write a function that can compare two int elements (passed as pointers):\n+\n+```java\n+class Qsort {\n+    static int qsortCompare(MemorySegment elem1, MemorySegmet elem2) {\n+        return elem1.get(JAVA_INT, 0) - elem2.get(JAVA_INT, 0);\n+    }\n+}\n+```\n+\n+Here we can see that the function is performing some *unsafe* dereference of the pointer contents.\n+\n+Now let's create a method handle pointing to the comparator function above:\n+\n+```java\n+FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+                                                      ADDRESS.withTargetLayout(JAVA_INT),\n+                                                      ADDRESS.withTargetLayout(JAVA_INT));\n+MethodHandle comparHandle = MethodHandles.lookup()\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     comparDesc.toMethodType());\n+```\n+\n+To do that, we first create a function descriptor for the function pointer type. This descriptor uses address layouts that have a `JAVA_INT` target layout, to allow access operations inside the upcall method handle. We use the `FunctionDescriptor::toMethodType` to turn that function descriptor into a suitable `MethodType` instance to be used in a method handle lookup. Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall stub, and pass it to the `qsort` downcall handle:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, arena);\n+    MemorySegment array = session.allocateArray(0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+    qsort.invokeExact(array, 10L, 4L, comparFunc);\n+    int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+}\n+```\n+\n+The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function, of type `MemorySegment`. The upcall stub is associated with the provided segment scope instance; this means that the stub will be uninstalled when the arena is closed.\n+\n+The snippet then creates an off-heap array from a Java array, which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n+\n+### Variadic calls\n+\n+Some C functions are *variadic* and can take an arbitrary number of arguments. Perhaps the most common example of this is the `printf` function, defined in the C standard library:\n+\n+```c\n+int printf(const char *format, ...);\n+```\n+\n+This function takes a format string, which features zero or more *holes*, and then can take a number of additional arguments that is identical to the number of holes in the format string.\n+\n+The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let's say we wanted to model the following C call:\n+\n+```c\n+printf(\"%d plus %d equals %d\", 2, 2, 4);\n+```\n+\n+To do this using the foreign function support provided by the FFM API we would have to build a *specialized* downcall handle for that call shape, using a linker option to specify the position of the first variadic layout, as follows:\n+\n+```java\n+Linker linker = Linker.nativeLinker();\n+MethodHandle printf = linker.downcallHandle(\n+\t\tlinker.defaultLookup().lookup(\"printf\").get(),\n+        FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT)\n+        Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n+);\n+```\n+\n+Then we can call the specialized downcall handle as usual:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+}\n+```\n+\n+While this works, and provides optimal performance, it has some limitations<a href=\"#2\"><sup>2<\/sup><\/a>:\n+\n+* If the variadic function needs to be called with many shapes, we have to create many downcall handles\n+* while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.\n+\n+### Appendix: full source code\n+\n+The full source code containing most of the code shown throughout this document can be seen below:\n+\n+```java\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public class Examples {\n+\n+    static Linker LINKER = Linker.nativeLinker();\n+    static SymbolLookup STDLIB = LINKER.defaultLookup();\n+\n+    public static void main(String[] args) throws Throwable {\n+        strlen();\n+        strlen_virtual();\n+        qsort();\n+        printf();\n+    }\n+\n+    public static void strlen() throws Throwable {\n+        MethodHandle strlen = LINKER.downcallHandle(\n+                STDLIB.find(\"strlen\").get(),\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+        );\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment hello = arena.allocateFrom(\"Hello\");\n+            long len = (long) strlen.invokeExact(hello); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    public static void strlen_virtual() throws Throwable {\n+        MethodHandle strlen_virtual = LINKER.downcallHandle(\n+                FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+        );\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment hello = arena.allocateFrom(\"Hello\");\n+            long len = (long) strlen_virtual.invokeExact(\n+                    STDLIB.find(\"strlen\").get(),\n+                    hello); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    static class Qsort {\n+        static int qsortCompare(MemorySegment addr1, MemorySegment addr2) {\n+            return addr1.get(JAVA_INT, 0) - addr2.get(JAVA_INT, 0);\n+        }\n+    }\n+\n+    public static void qsort() throws Throwable {\n+        MethodHandle qsort = LINKER.downcallHandle(\n+                STDLIB.find(\"qsort\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+        );\n+        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+                ADDRESS.withTargetLayout(JAVA_INT),\n+                ADDRESS.withTargetLayout(JAVA_INT));\n+        MethodHandle comparHandle = MethodHandles.lookup()\n+                .findStatic(Qsort.class, \"qsortCompare\",\n+                        comparDesc.toMethodType());\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment comparFunc = LINKER.upcallStub(\n+                    comparHandle, comparDesc, arena);\n+\n+            MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+            qsort.invokeExact(array, 10L, 4L, comparFunc);\n+            int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+            System.out.println(Arrays.toString(sorted));\n+        }\n+    }\n+\n+    public static void printf() throws Throwable {\n+        MethodHandle printf = LINKER.downcallHandle(\n+                STDLIB.find(\"printf\").get(),\n+                FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT),\n+                Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n+        );\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocateFrom(\"%d plus %d equals %d\\n\");\n+            int res = (int) printf.invokeExact(s, 2, 2, 4);\n+        }\n+    }\n+}\n+```\n+\n+\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> Previous iterations of the FFM API provided a `VaList` class that could be used to model a C `va_list`. This class was later dropped from the FFM API as too implementation specific. It is possible that a future version of the `jextract` tool might provide higher-level bindings for variadic calls. <\/small>\n","filename":"doc\/panama_ffi.md","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+## State of foreign memory support\n+\n+**March 2023**\n+\n+**Maurizio Cimadamore**\n+\n+A crucial part of any native interop story lies in the ability of accessing off-heap memory efficiently and safely. Java achieves this goal through the Foreign Function & Memory API (FFM API in short), parts of which have been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [14](https:\/\/openjdk.java.net\/jeps\/370). The FFM API introduces abstractions to allocate and access flat memory regions (whether on- or off-heap), to manage the lifecycle of memory resources and to model native memory addresses.\n+\n+### Memory segments and arenas\n+\n+Memory segments are abstractions which can be used to model contiguous memory regions, located either on-heap (i.e. *heap segments*) or off- the Java heap (i.e. *native segments*). Memory segments provide *strong* spatial, temporal and thread-confinement guarantees which make memory dereference operation *safe* (more on that later), although in most simple cases some properties of memory segments can safely be ignored.\n+\n+For instance, the following snippet allocates 100 bytes off-heap:\n+\n+```java\n+MemorySegment segment = Arena.global().allocate(100);\n+```\n+\n+The above code allocates a 100-bytes long memory segment, using an *arena*. The FFM API provides several kinds of arena, which can be used to control the lifecycle of the allocated native segments in different ways. In this example, the segment is allocated with the *global* arena. Memory segments allocated with this arena are always *alive* and their backing regions of memory are never deallocated. In other words, we say that the above segment has an *unbounded* lifetime.\n+\n+> Note: the lifetime of a memory segment is modelled by a *scope* (see `MemorySegment.Scope`). A memory segment can be accessed as long as its associated scope is *alive* (see `Scope::isAlive`). In most cases, the scope of a memory segment is the scope of the arena which allocated that segment. Accessing the scope of a segment can be useful to perform lifetime queries (e.g. asking whether a segment has the same lifetime as that of another segment), creating custom arenas and unsafely assigning new temporal bounds to an existing native memory segments (these topics are explored in more details below).\n+\n+Most programs, though, require off-heap memory to be deallocated while the program is running, and thus need memory segments with *bounded* lifetimes. The simplest way to obtain a segment with bounded lifetime is to use an *automatic arena*:\n+\n+```java\n+MemorySegment segment = Arena.ofAuto().allocate(100);\n+```\n+\n+Segments allocated with an automatic arena are alive as long as they are determined to be reachable by the garbage collector. In other words, the above snippet creates a native segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory.\n+\n+There are cases, however, where automatic deallocation is not enough: consider the case where a large memory segment is mapped from a file (this is possible using `FileChannel::map`); in this case, an application would probably prefer to release (e.g. `unmap`) the memory associated with this segment in a *deterministic* fashion, to ensure that memory doesn't remain available for longer than it needs to.\n+\n+A *confined* arena allocates segment featuring a bounded *and* deterministic lifetime. A memory segment allocated with a confined arena is alive from the time when the arena is opened, until the time when the arena is closed (at which point the segments become inaccessible). Multiple segments allocated with the same arena enjoy the *same* bounded lifetime and can safely contain mutual references. For example, this code opens an arena and uses it to allocate several native segments:\n+\n+```java\n+try (Arena arena = Arena.ofConfined()) {\n+    MemorySegment segment1 = arena.allocate(100);\n+    MemorySegment segment2 = arena.allocate(100);\n+    ...\n+    MemorySegment segmentN = arena.allocate(100);\n+} \/\/ all segments are deallocated here\n+```\n+\n+When the arena is closed (above, this is done with the *try-with-resources* construct) the arena is no longer alive, all the segments associated with it are invalidated atomically, and the regions of memory backing the segments are deallocated.\n+\n+A confined arena's deterministic lifetime comes at a price: only one thread can access the memory segments allocated in a confined arena. If multiple threads need access to a segment, then a *shared* arena can be used (`Arena::ofShared`). The memory segments allocated in a shared arena can be accessed by multiple threads, and any thread (regardless of whether it was involved in access) can close the shared arena to deallocate the segments. The closure will atomically invalidate the segments, though deallocation of the regions of memory backing the segments might not occur immediately: an expensive synchronization operation<a href=\"#1\"><sup>1<\/sup><\/a> is needed to detect and cancel pending concurrent access operations on the segments.\n+\n+In summary, an arena controls *which* threads can access a memory segment and *when*, in order to provide both strong temporal safety and a predictable performance model. The FFM API offers a choice of arenas so that a client can trade off breadth-of-access against timeliness of deallocation.\n+\n+### Slicing segments\n+\n+Memory segments support *slicing* — that is, given a segment, it is possible to create a new segment whose spatial bounds are stricter than that of the original segment:\n+\n+```java\n+MemorySegment segment = Arena.ofAuto().allocate(10);\n+MemorySegment slice = segment.asSlice(4, 4);\n+```\n+\n+The above code creates a slice that starts at offset 4 and has a length of 4 bytes. Slices have the *same* temporal bounds (i.e. segment scope) as the parent segment. In the above example, the memory associated with the parent segment will not be released as long as there is at least one *reachable* slice derived from that segment.\n+\n+To process the contents of a memory segment in bulk, a memory segment can be turned into a stream of slices, using the `MemorySegment::stream` method:\n+\n+```java\n+SequenceLayout seq = MemoryLayout.sequenceLayout(1_000_000, JAVA_INT);\n+SequenceLayout bulk_element = MemoryLayout.sequenceLayout(100, JAVA_INT);\n+\n+try (Arena arena = Arena.ofShared()) {\n+    MemorySegment segment = arena.allocate(seq);\n+    int sum = segment.elements(bulk_element).parallel()\n+                       .mapToInt(slice -> {\n+                           int res = 0;\n+                           for (int i = 0; i < 100 ; i++) {\n+                               res += slice.getAtIndex(JAVA_INT, i);\n+                           }\n+                           return res;\n+                       }).sum();\n+}\n+```\n+\n+The `MemorySegment::elements` method takes an element layout and returns a new stream. The stream is built on top of a spliterator instance (see `MemorySegment::spliterator`) which splits the segment into chunks whose size match that of the provided layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes *exactly* one element would be inefficient, so instead we use a *bulk* element layout. The bulk element layout is a sequence layout containing a group of 100 elements — which should make it more amenable to parallel processing. Since we are using `Stream::parallel` to work on disjoint slices in parallel, here we use a *shared* arena, to ensure that the resulting segment can be accessed by multiple threads.\n+\n+### Accessing segments\n+\n+Memory segments can be dereferenced easily, by using *value layouts* (layouts are covered in greater details in the next section). A value layout captures information such as:\n+\n+- The number of bytes to be dereferenced;\n+- The alignment constraints of the address at which dereference occurs;\n+- The endianness with which bytes are stored in said memory region;\n+- The Java type to be used in the dereference operation (e.g. `int` vs `float`).\n+\n+For instance, the layout constant `ValueLayout.JAVA_INT` is four bytes wide, has no alignment constraints, uses the native platform endianness (e.g. little-endian on Linux\/x64) and is associated with the Java type `int`. The following example reads pairs of 32-bit values (as Java ints) and uses them to construct an array of points:\n+\n+```java\n+record Point(int x, int y);\n+MemorySegment segment = Arena.ofAuto().allocate(10 * 4 * 2);\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = segment.getAtIndex(JAVA_INT, i * 2);\n+    int y = segment.getAtIndex(JAVA_INT, (i * 2) + 1);\n+    values[i] = new Point(x, y);\n+}\n+```\n+\n+The above snippet allocates a flat array of 80 bytes using an automatic arena. Then, inside the loop, elements in the array are accessed using the `MemorySegment::getAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (under the hood, the segment offset being accessed is obtained by multiplying the logical index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n+\n+### Structured access\n+\n+Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, clients can use a `MemoryLayout` to describe the contents of a memory segment *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#2\"><sup>2<\/sup><\/a>:\n+\n+```java\n+MemoryLayout points = MemoryLayout.sequenceLayout(10,\n+    MemoryLayout.structLayout(\n+        JAVA_INT.withName(\"x\"),\n+        JAVA_INT.withName(\"y\")\n+    )\n+);            \n+```\n+\n+That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. Once defined, a memory layout can be queried — for instance we can compute the offset of the `y` coordinate in the 4th element of the `points` array:\n+\n+```java\n+long y3 = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\")); \/\/ 28\n+```\n+\n+To specify which nested layout element should be used for the offset calculation we use a *layout path*, a selection expression that navigates the layout, from the *root* layout, down to the leaf layout we wish to select; in this case we need to select the 4th layout element in the sequence, and then select the layout named `y` inside the selected group layout.\n+\n+One of the things that can be derived from a layout is a *memory access var handle*. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. With memory access var handles we can rewrite our example above as follows:\n+\n+```java\n+MemorySegment segment = Arena.ofAuto().allocate(points);\n+VarHandle xHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"x\"));\n+VarHandle yHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"y\"));\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = (int)xHandle.get(segment, (long)i);\n+    int y = (int)yHandle.get(segment, (long)i);\n+}\n+```\n+\n+In the above, `xHandle` and `yHandle` are two var handle instances whose type is `int` and which takes two access coordinates:\n+\n+1. a `MemorySegment` instance; the segment whose memory should be dereferenced\n+2. a *logical* index, which is used to select the element of the sequence we want to access (as the layout path used to construct these var handles contains one free dimension)\n+\n+Note that memory access var handles (as any other var handle) are *strongly* typed; and to get maximum efficiency, it is generally necessary to introduce casts to make sure that the access coordinates match the expected types — in this case we have to cast `i` into a `long`; similarly, since the signature polymorphic method `VarHandle::get` notionally returns `Object` a cast is necessary to force the right return type the var handle operation <a href=\"#3\"><sup>3<\/sup><\/a>.\n+\n+In other words, manual offset computation is no longer needed — offsets and strides can in fact be derived from the layout object; note how `yHandle` is able to compute the required offset of the `y` coordinate in the flat array without the need of any error-prone arithmetic computation.\n+\n+### Combining memory access handles\n+\n+We have seen in the previous sections how memory access var handles dramatically simplify user code when structured access is involved. While deriving memory access var handles from layout is the most convenient option, the FFM API also allows to create such memory access var handles in a standalone fashion, as demonstrated in the following code:\n+\n+```java\n+VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(JAVA_INT); \/\/ (MS, J) -> I\n+```\n+\n+The above code creates a memory access var handle which reads\/writes `int` values at a certain byte offset in a segment. To create this var handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user might want to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values. Of course, all this information can be succinctly derived from the provided value layout (`JAVA_INT` in the above example).\n+\n+The attentive reader might have noted how rich the var handles obtained from memory layouts are, compared to the simple memory access var handle we have constructed here. How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle *combinators*. Developers familiar with the method handles know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` class. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n+\n+The FFM API adds a rich set of var handle combinators in the `MethodHandles` class; with these tools, developers can express var handle transformations such as:\n+\n+* mapping a var handle carrier type into a different one, using an embedding\/projection method handle pairs\n+* filter one or more var handle access coordinates using unary filters\n+* permute var handle access coordinates\n+* bind concrete access coordinates to an existing var handle\n+\n+Without diving too deep, let's consider how we might want to take a basic memory access handle and turn it into a var handle which dereference a segment at a specific offset (again using the `points` layout defined previously):\n+\n+```java\n+VarHandle intHandle = MemoryHandles.memorySegmentViewVarHandle(JAVA_INT); \/\/ (MS, J) -> I\n+long offsetOfY = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\"));\n+VarHandle valueHandle = MethodHandles.insertCoordinates(intHandle, 1, offsetOfValue); \/\/ (MS) -> I\n+```\n+\n+We have been able to derive, from a basic memory access var handle, a new var handle that dereferences a segment at a given fixed offset. It is easy to see how other, richer, var handles obtained using a memory layout can also be constructed manually using the var handle combinators provided by the FFM API.\n+\n+### Segment allocators and custom arenas\n+\n+Memory allocation is often a bottleneck when clients use off-heap memory. The FFM API therefore includes a `SegmentAllocator` interface to define operations to allocate and initialize memory segments. As a convenience, the `Arena` interface extends the `SegmentAllocator` interface so that arenas can be used to allocate native segments. In other words, `Arena` is a \"one-stop shop\" for flexible allocation and timely deallocation of off-heap memory:\n+\n+```java\n+FileChannel channel = ...\n+try (Arena offHeap = Arena.ofConfined()) {\n+    MemorySegment nativeArray   = offHeap.allocateArray(ValueLayout.JAVA_INT, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n+    MemorySegment nativeString  = offHeap.allocateUtf8String(\"Hello!\");\n+\n+    MemorySegment mappedSegment = channel.map(MapMode.READ_WRITE, 0, 1000, arena);\n+   ...\n+} \/\/ memory released here\n+```\n+\n+Segment allocators can also be obtained via factories in the `SegmentAllocator` interface. For example, one factory creates a *slicing allocator* that responds to allocation requests by returning memory segments which are part of a previously allocated segment; thus, many requests can be satisfied without physically allocating more memory. The following code obtains a slicing allocator over an existing segment, then uses it to allocate a segment initialized from a Java array:\n+\n+```java\n+MemorySegment segment = ...\n+SegmentAllocator allocator = SegmentAllocator.slicingAllocator(segment);\n+for (int i = 0 ; i < 10 ; i++) {\n+    MemorySegment s = allocator.allocateArray(JAVA_INT, new int[] { 1, 2, 3, 4, 5 });\n+    ...\n+}\n+```\n+\n+A segment allocator can be used as a building block to create an arena that supports a custom allocation strategy. For example, if many segments share the same bounded lifetime, then an arena could use a slicing allocator to allocate the segments efficiently. This lets clients enjoy both scalable allocation (thanks to slicing) and deterministic deallocation (thanks to the arena).\n+\n+As an example, the following code defines a *slicing arena* that behaves like a confined arena (i.e., single-threaded access), but internally uses a slicing allocator to respond to allocation requests.  When the slicing arena is closed, the underlying confined arena is also closed; this will invalidate all segments allocated with the slicing arena:\n+\n+```java\n+class SlicingArena {\n+     final Arena arena = Arena.ofConfined();\n+     final SegmentAllocator slicingAllocator;\n+\n+     SlicingArena(long size) {\n+         slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+     }\n+\n+public void allocate(long byteSize, long byteAlignment) {\n+         return slicingAllocator.allocate(byteSize, byteAlignment);\n+     }\n+\n+     public MemorySegment.Scope scope() {\n+         return arena.scope();\n+     }\n+\n+     public void close() {\n+         return arena.close();\n+     }\n+}\n+```\n+\n+The earlier code which used a slicing allocator directly can now be written more succinctly, as follows:\n+\n+```java\n+try (Arena slicingArena = new SlicingArena(1000)) {\n+     for (int i = 0 ; i < 10 ; i++) {\n+         MemorySegment s = arena.allocateArray(JAVA_INT, new int[] { 1, 2, 3, 4, 5 });\n+         ...\n+     }\n+} \/\/ all memory allocated is released here\n+```\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> Shared arenas rely on VM thread-local handshakes (JEP [312](https:\/\/openjdk.java.net\/jeps\/312)) to implement lock-free, safe, shared memory access; that is, when it comes to memory access, there should be no difference in performance between a shared segment and a confined segment. On the other hand, `Arena::close` might be slower on shared arenas than on confined ones.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> In general, deriving a complete layout from a C `struct` declaration is no trivial matter, and it's one of those areas where tooling can help greatly.<\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> Clients can enforce stricter type checking when interacting with `VarHandle` instances, by obtaining an *exact* var handle, using the `VarHandle::withInvokeExactBehavior` method.<\/small>\n+\n","filename":"doc\/panama_memaccess.md","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -429,3 +429,8 @@\n-            dependencies: [\"devkit\", \"gtest\"],\n-            configure_args: concat(common.configure_args_32bit,\n-                \"--with-jvm-variants=minimal,server\", \"--with-zlib=system\"),\n+            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n+            configure_args: concat(common.configure_args_32bit, [\n+                \"--with-jvm-variants=minimal,server\",\n+                \"--with-zlib=system\",\n+                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n+                \"--enable-libffi-bundling\",\n+                \"--enable-fallback-linker\"\n+            ])\n","filename":"make\/conf\/jib-profiles.js","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        --add-exports java.base\/jdk.internal.foreign=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -1063,0 +1064,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-     * @since 20\n+     * @since 22\n@@ -277,1 +277,0 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -312,1 +311,1 @@\n-    void ensureNativeAccess(Class<?> owner, String methodName) {\n+    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass) {\n@@ -323,1 +322,1 @@\n-                String mod = isNamed() ? \"module \" + getName() : \"the unnamed module\";\n+                String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -325,0 +324,2 @@\n+                String caller = currentClass != null ?\n+                        \" by \" + currentClass.getName() : \"\";\n@@ -327,3 +328,4 @@\n-                        WARNING: %s has been called by %s\n-                        WARNING: Use --enable-native-access=%s to avoid a warning for this module\n-                        %n\"\"\", cls, mtd, mod, modflag);\n+                        WARNING: %s has been called%s in %s\n+                        WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n+                        WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                        %n\"\"\", cls, mtd, caller, mod, modflag);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -310,3 +310,1 @@\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain\n-         * from depending on restricted methods, and use safe and supported functionalities,\n-         * where possible.\n+         * the JVM or, worse, silently result in memory corruption.\n@@ -325,1 +323,1 @@\n-         * @since 20\n+         * @since 22\n@@ -327,1 +325,0 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n@@ -1839,0 +1841,15 @@\n+    boolean bytesCompatible(Charset charset) {\n+        if (isLatin1()) {\n+            if (charset == ISO_8859_1.INSTANCE) {\n+                return true; \/\/ ok, same encoding\n+            } else if (charset == UTF_8.INSTANCE || charset == US_ASCII.INSTANCE) {\n+                return !StringCoding.hasNegatives(value, 0, value.length); \/\/ ok, if ASCII-compatible\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void copyToSegmentRaw(MemorySegment segment, long offset) {\n+        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -91,1 +92,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -2457,2 +2457,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n-                m.ensureNativeAccess(owner, methodName);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n+                m.ensureNativeAccess(owner, methodName, currentClass);\n@@ -2672,0 +2672,10 @@\n+\n+            @Override\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+                string.copyToSegmentRaw(segment, offset);\n+            }\n+\n+            @Override\n+            public boolean bytesCompatible(String string, Charset charset) {\n+                return string.bytesCompatible(charset);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -54,0 +53,3 @@\n+ * @implSpec\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n@@ -56,1 +58,1 @@\n- * @since 19\n+ * @since 22\n@@ -58,1 +60,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -98,1 +99,1 @@\n-     *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+     *         MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -103,2 +104,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -187,1 +186,1 @@\n- *         MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+ *         MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -198,1 +197,1 @@\n- * @since 20\n+ * @since 22\n@@ -200,1 +199,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -224,1 +222,1 @@\n-            static final Arena GLOBAL = MemorySessionImpl.GLOBAL.asArena();\n+            static final Arena GLOBAL = MemorySessionImpl.createGlobal().asArena();\n@@ -272,3 +270,1 @@\n-    default MemorySegment allocate(long byteSize, long byteAlignment) {\n-        return ((MemorySessionImpl)scope()).allocate(byteSize, byteAlignment);\n-    }\n+    MemorySegment allocate(long byteSize, long byteAlignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -47,1 +46,1 @@\n- * @since 19\n+ * @since 22\n@@ -49,1 +48,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -41,1 +40,1 @@\n- * @since 19\n+ * @since 22\n@@ -43,1 +42,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -35,1 +34,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -39,0 +37,1 @@\n+import java.util.Map;\n@@ -40,1 +39,0 @@\n-import java.util.Optional;\n@@ -63,0 +61,6 @@\n+ * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * type names to canonical layouts.\n+ * <p>\n@@ -96,1 +100,1 @@\n- *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -99,1 +103,1 @@\n- * }\n+ *}\n@@ -107,5 +111,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -126,1 +127,27 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code wchar_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 (all the examples provided\n+ * here will assume these platform-dependent mappings):\n@@ -141,1 +168,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -144,1 +171,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -147,1 +174,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -150,1 +177,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -153,1 +180,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -204,14 +231,1 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n- * to one of the following layout constants:\n- * <ul>\n- * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n- * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n- * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n- * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n- * <li>{@link ValueLayout#JAVA_INT}<\/li>\n- * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n- * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n- * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n- * <\/ul><\/li>\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n- * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n@@ -297,1 +311,1 @@\n- *     MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -355,1 +369,1 @@\n- * returned segment is a fresh scope that is always alive. To provide safe access to the segment, we must,\n+ * returned segment is a scope that is always alive. To provide safe access to the segment, we must,\n@@ -394,9 +408,5 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n- * <ol>\n- * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n- * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n- * <\/ol>\n- * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n- * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n- * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n- * of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n+ * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}.\n+ * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n+ * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n+ * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n@@ -414,2 +424,2 @@\n- * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n- * type.\n+ * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form of a variadic\n+ * function will always have a promoted type.\n@@ -421,2 +431,1 @@\n- * function descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n- * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * function descriptor, are called <em>variadic argument layouts<\/em>.\n@@ -424,5 +433,7 @@\n- * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n- * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n- * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n- * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n- * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n+ * The native linker does not automatically perform default argument promotions. However, since passing an argument of a\n+ * non-promoted type as a variadic argument is not supported in C, the native linker will reject an attempt to link a\n+ * specialized function descriptor with any variadic argument value layouts corresponding to a non-promoted C type.\n+ * Since the size of the C {@code int} type is platform-specific, exactly which layouts will be rejected is\n+ * platform-specific as well. As an example: on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n+ * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others), will be rejected by the linker.\n+ * The {@link #canonicalLayouts()} method can be used to find which layout corresponds to a particular C type.\n@@ -464,2 +475,1 @@\n- *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n- * }\n+ *     int res = (int)printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -467,0 +477,1 @@\n+ *}\n@@ -486,1 +497,1 @@\n- * @since 19\n+ * @since 22\n@@ -488,1 +499,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -496,0 +506,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -499,2 +511,0 @@\n-     *\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n@@ -516,2 +526,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -563,2 +572,6 @@\n-     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address.\n-     * The returned method handle will additionally throw {@link NullPointerException} if any argument passed to it is {@code null}.\n+     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address. If an argument\n+     * is a {@link MemorySegment},whose corresponding layout is an {@linkplain GroupLayout group layout}, the linker might attempt to access the contents of the segment. As such, one of the exceptions specified by the\n+     * {@link MemorySegment#get(ValueLayout.OfByte, long)} or the\n+     * {@link MemorySegment#copy(MemorySegment, long, MemorySegment, long, long)} methods may be thrown.\n+     * The returned method handle will additionally throw {@link NullPointerException} if any argument\n+     * passed to it is {@code null}.\n@@ -568,2 +581,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -593,1 +605,1 @@\n-     * is a native segment associated with a fresh scope that is always alive.\n+     * is a native segment associated with a scope that is always alive.\n@@ -606,2 +618,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -642,0 +653,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n@@ -644,1 +671,1 @@\n-     * @since 20\n+     * @since 22\n@@ -646,1 +673,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -711,0 +737,2 @@\n+         * @apiNote This linker option can not be combined with {@link #critical}.\n+         *\n@@ -753,1 +781,1 @@\n-         * {@return a linker option used to mark a foreign function as <em>trivial<\/em>}\n+         * {@return a linker option used to mark a foreign function as <em>critical<\/em>}\n@@ -755,2 +783,2 @@\n-         * A trivial function is a function that has an extremely short running time\n-         * in all cases (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * A critical function is a function that has an extremely short running time in all cases\n+         * (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n@@ -759,1 +787,1 @@\n-         * optimizations that are only valid for trivial functions.\n+         * optimizations that are only valid for critical functions.\n@@ -761,1 +789,1 @@\n-         * Using this linker option when linking non trivial functions is likely to have adverse effects,\n+         * Using this linker option when linking non-critical functions is likely to have adverse effects,\n@@ -764,2 +792,2 @@\n-        static Option isTrivial() {\n-            return LinkerOptions.IsTrivial.INSTANCE;\n+        static Option critical() {\n+            return LinkerOptions.Critical.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":102,"deletions":74,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.invoke.MethodType;\n@@ -46,1 +47,1 @@\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -51,1 +52,1 @@\n- * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind (see\n+ * There are two leaves in the layout hierarchy, {@linkplain ValueLayout value layouts}, which are used to represent values of given size and kind\n@@ -234,0 +235,37 @@\n+ * <h2 id=\"access-mode-restrictions\">Access mode restrictions<\/h2>\n+ *\n+ * A var handle returned by {@link #varHandle(PathElement...)} or {@link ValueLayout#varHandle()} features certain\n+ * access characteristics, which are derived from the selected layout {@code L}:\n+ * <ul>\n+ * <li>A carrier type {@code T}, derived from {@code L.carrier()}<\/li>\n+ * <li>An alignment constraint {@code A}, derived from {@code L.byteAlignment()}<\/li>\n+ * <li>An access size {@code S}, derived from {@code L.byteSize()}<\/li>\n+ * <\/ul>\n+ * Depending on the above characteristics, the returned var handle might feature certain <i>access mode restrictions<\/i>.\n+ * We say that a var handle is <em>aligned<\/em> if its alignment constraint {@code A} is compatible with the access size\n+ * {@code S}, that is if {@code A >= S}. An aligned var handle is guaranteed to support the following access modes:\n+ * <ul>\n+ * <li>read write access modes for all {@code T}. On 32-bit platforms, access modes\n+ *     {@code get} and {@code set} for {@code long}, {@code double} and {@code MemorySegment}\n+ *     are supported but might lead to word tearing, as described in Section {@jls 17.7}.\n+ *     of <cite>The Java Language Specification<\/cite>.\n+ * <li>atomic update access modes for {@code int}, {@code long},\n+ *     {@code float}, {@code double} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     types for certain currently unsupported access modes.)\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <\/ul>\n+ * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic update access modes compare\n+ * values using their bitwise representation (see {@link Float#floatToRawIntBits}, {@link Double#doubleToRawLongBits}\n+ * and {@link MemorySegment#address()}, respectively).\n+ * <p>\n+ * Alternatively, a var handle is <em>unaligned<\/em> if its alignment constraint {@code A} is incompatible with the\n+ * access size {@code S}, that is, if {@code A < S}. An unaligned var handle only supports the {@code get} and {@code set}\n+ * access modes. All other access modes will result in {@link UnsupportedOperationException} being thrown. Moreover,\n+ * while supported, access modes {@code get} and {@code set} might lead to word tearing.\n+ *\n@@ -238,1 +276,1 @@\n- * @since 19\n+ * @since 22\n@@ -240,1 +278,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -295,0 +332,38 @@\n+    \/**\n+     * {@return {@code offset + (byteSize() * index)}}\n+     *\n+     * @param offset the base offset\n+     * @param index the index to be scaled by the byte size of this layout\n+     * @throws IllegalArgumentException if {@code offset} or {@code index} is negative\n+     * @throws ArithmeticException if either the addition or multiplication overflows\n+     *\/\n+    @ForceInline\n+    default long scale(long offset, long index) {\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n+        }\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"Negative index: \" + index);\n+        }\n+\n+        return Math.addExact(offset, Math.multiplyExact(byteSize(), index));\n+    }\n+\n+    \/**\n+     *{@return a method handle that can be used to invoke {@link #scale(long, long)} on this layout}\n+     *\/\n+    default MethodHandle scaleHandle() {\n+        class Holder {\n+            static final MethodHandle MH_SCALE;\n+            static {\n+                try {\n+                    MH_SCALE = MethodHandles.lookup().findVirtual(MemoryLayout.class, \"scale\",\n+                            MethodType.methodType(long.class, long.class, long.class));\n+                } catch (ReflectiveOperationException e) {\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            }\n+        }\n+        return Holder.MH_SCALE.bindTo(this);\n+    }\n+\n@@ -317,1 +392,2 @@\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has one leading {@code long} parameter representing the base offset;<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -325,1 +401,1 @@\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * offset = b + c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -328,4 +404,5 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * where {@code b} represents the base offset provided as a <em>dynamic<\/em> {@code long} argument, {@code x_1}, {@code x_2},\n+     * ... {@code x_n} represent indices into sequences provided as <em>dynamic<\/em> {@code long} arguments, whereas\n+     * {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants derived from the size of the element\n+     * layout of a sequence, and {@code c_1}, {@code c_2}, ... {@code c_m} are other <em>static<\/em> offset constants\n+     * (such as field offsets) which are derived from the layout path.\n@@ -354,4 +431,6 @@\n-     *     <li>it has as zero or more access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path. The order of these access\n-     *     coordinates corresponds to the order in which the open path elements occur in the provided\n-     *     layout path.\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n+     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n+     *     in which the open path elements occur in the provided layout path.\n@@ -360,14 +439,2 @@\n-     * The final address accessed by the returned var handle can be computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * address = base(segment) + offset\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed\n-     * memory segment. For native segments, this function just returns the native segment's\n-     * {@linkplain MemorySegment#address() address}. For heap segments, this function is more complex, as the address\n-     * of heap segments is virtualized. The {@code offset} value can be expressed in the following form:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n-     * }<\/pre><\/blockquote>\n+     * If the provided layout path {@code P} contains no dereference elements, then the offset of the access operation is\n+     * computed as follows:\n@@ -375,4 +442,3 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * {@snippet lang = \"java\":\n+     * offset = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * }\n@@ -380,2 +446,15 @@\n-     * Additionally, the provided dynamic values must conform to bounds which are derived from the layout path, that is,\n-     * {@code 0 <= x_i < b_i}, where {@code 1 <= i <= n}, or {@link IndexOutOfBoundsException} is thrown.\n+     * Accessing a memory segment using the var handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the accessed offset (computed as above), {@code A} is the size of the selected layout and {@code S}\n+     * is the size of the accessed memory segment.<\/li>\n+     *     <li>The accessed memory segment must be {@link MemorySegment#isAccessibleBy(Thread) accessible} from the\n+     * thread performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed segment must be\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}, or an {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -383,3 +462,13 @@\n-     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n-     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n-     * (but not less) than the alignment constraint of the selected value layout.\n+     * If the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#get(Object...)}\n+     * on the returned var handle will return a new memory segment. The segment is associated with a scope that is\n+     * always alive. Moreover, the size of the segment depends on whether the address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout}. More specifically:\n+     * <ul>\n+     *     <li>If the address layout has a target layout {@code T}, then the size of the returned segment\n+     *     is {@code T.byteSize()};<\/li>\n+     *     <li>Otherwise, the address layout has no target layout, and the size of the returned segment\n+     *     is <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.<\/li>\n+     * <\/ul>\n+     * Moreover, if the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#set(Object...)}\n+     * can throw {@link IllegalArgumentException} if the memory segment representing the address to be written is not a\n+     * {@linkplain MemorySegment#isNative() native} memory segment.\n@@ -387,5 +476,4 @@\n-     * Multiple paths can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n-     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n-     * read obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n-     * the dereference path element. In other words, if a layout path contains one or more dereference path elements,\n-     * the final address accessed by the returned var handle can be computed as follows:\n+     * If the provided layout path has size {@code m} and contains a dereference path element in position {@code k}\n+     * (where {@code k <= m}) then two layout paths {@code P} and {@code P'} are derived, where P contains all the path\n+     * elements from 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1} to\n+     * {@code m} (if any). Then, the returned var handle is computed as follows:\n@@ -393,6 +481,8 @@\n-     * <blockquote><pre>{@code\n-     * address_1 = base(segment) + offset_1\n-     * address_2 = base(segment_1) + offset_2\n-     * ...\n-     * address_k = base(segment_k-1) + offset_k\n-     * }<\/pre><\/blockquote>\n+     * {@snippet lang = \"java\":\n+     * VarHandle baseHandle = this.varHandle(P);\n+     * MemoryLayout target = ((AddressLayout)this.select(P)).targetLayout().get();\n+     * VarHandle targetHandle = target.varHandle(P');\n+     * targetHandle = MethodHandles.insertCoordinates(targetHandle, 1, 0L); \/\/ always access nested targets at offset 0\n+     * targetHandle = MethodHandles.collectCoordinates(targetHandle, 0,\n+     *         baseHandle.toMethodHandle(VarHandle.AccessMode.GET));\n+     * }\n@@ -400,8 +490,14 @@\n-     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n-     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n-     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n-     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n-     * the path elements after a given dereference operation (these offsets are obtained using the computation described\n-     * above). In these more complex access operations, all memory accesses immediately preceding a dereference operation\n-     * (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1} are performed using the\n-     * {@link VarHandle.AccessMode#GET} access mode.\n+     * (The above can be trivially generalized to cases where the provided layout path contains more than one dereference\n+     * path elements).\n+     * <p>\n+     * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n+     * {@snippet lang = \"java\":\n+     *     GroupLayout grp = java.lang.foreign.MemoryLayout.structLayout(\n+     *             MemoryLayout.paddingLayout(4),\n+     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n+     *     );\n+     * }\n+     * To access the member layout named {@code value}, we can construct a var handle as follows:\n+     * {@snippet lang = \"java\":\n+     *     VarHandle handle = grp.varHandle(PathElement.groupElement(\"value\")); \/\/(MemorySegment, long) -> int\n+     * }\n@@ -409,2 +505,2 @@\n-     * @apiNote The resulting var handle features certain <em>access mode restrictions<\/em>, which are common to all\n-     * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view handles}.\n+     * @apiNote The resulting var handle features certain <a href=\"#access-mode-restrictions\"><em>access mode restrictions<\/em><\/a>,\n+     * which are common to all var handles derived from memory layouts.\n@@ -416,1 +512,0 @@\n-     * @see MethodHandles#memorySegmentViewVarHandle(ValueLayout)\n@@ -419,0 +514,4 @@\n+        Objects.requireNonNull(elements);\n+        if (this instanceof ValueLayout vl && elements.length == 0) {\n+            return vl.varHandle(); \/\/ fast path\n+        }\n@@ -430,3 +529,3 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment}, corresponding to the memory segment\n-     *     to be sliced;<\/li>\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to the memory segment to be sliced<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -437,6 +536,2 @@\n-     * The offset of the returned segment is computed as follows:\n-     * {@snippet lang=java :\n-     * long offset = byteOffset(elements);\n-     * long size = select(elements).byteSize();\n-     * MemorySegment slice = segment.asSlice(offset, size);\n-     * }\n+     * The offset of the returned segment is computed as if by a call to a\n+     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using the given path elements.\n@@ -444,3 +539,11 @@\n-     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n-     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n-     * strict (but not less) than the alignment constraint of the selected value layout.\n+     * Computing a slice of a memory segment using the method handle returned by this method is subject to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout), or\n+     * an {@link IllegalArgumentException} will be issued. Note that the alignment constraint of the root layout\n+     * can be more strict (but not less) than the alignment constraint of the selected layout.<\/li>\n+     *     <li>The start offset of the slicing operation (computed as above) must fall fall inside the spatial bounds of the\n+     * accessed memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case when {@code O + A <= S},\n+     * where {@code O} is the start offset of the slicing operation (computed as above), {@code A} is the size of the\n+     * selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     * <\/ul>\n@@ -504,1 +607,1 @@\n-     * @since 19\n+     * @since 22\n@@ -506,1 +609,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -672,18 +774,0 @@\n-    \/**\n-     * Creates a sequence layout with the given element layout and the maximum element\n-     * count such that it does not overflow a {@code long}.\n-     *\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-     * }\n-     *\n-     * @param elementLayout the sequence element layout.\n-     * @return a new sequence layout with the given element layout and maximum element count.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize() % elementLayout.byteAlignment() != 0}.\n-     *\/\n-    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n-        Objects.requireNonNull(elementLayout);\n-        return sequenceLayout(Long.MAX_VALUE \/ elementLayout.byteSize(), elementLayout);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":175,"deletions":91,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.Linker.Option;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n@@ -37,1 +34,2 @@\n-import java.nio.channels.FileChannel.*;\n+import java.nio.channels.FileChannel.MapMode;\n+import java.nio.charset.Charset;\n@@ -49,0 +47,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -50,3 +49,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.layout.ValueLayouts;\n-import jdk.internal.javac.PreviewFeature;\n@@ -131,5 +127,6 @@\n- * For more complex access operations (e.g. structured memory access), clients can obtain a\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n- * that accepts a segment and a {@code long} offset. More complex var handles\n- * can be obtained by adapting a segment var handle view using the var handle combinator functions defined in the\n- * {@link java.lang.invoke.MethodHandles} class:\n+ * More complex access operations can be implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout on a memory segment.\n+ * A var handle obtained from a layout supports several additional <a href=MemoryLayout.html#access-mode-restrictions>\n+ * access modes<\/a>. More importantly, var handles can be <em>combined<\/em> with method handles to express complex access\n+ * operations. For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -137,1 +134,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang=java:\n@@ -139,7 +136,5 @@\n- * VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n- * MethodHandle multiplyExact = MethodHandles.lookup()\n- *                                           .findStatic(Math.class, \"multiplyExact\",\n- *                                                                   MethodType.methodType(long.class, long.class, long.class));\n- * intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n- *                                             MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * VarHandle intHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle(); \/\/ <base offset> + <index> * JAVA_INT.byteSize()\n+ *\n+ * intHandle = MethodHandles.filterCoordinates(intHandle, 1, scale);\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + 3 * 4 = 12\n@@ -148,3 +143,5 @@\n- * Alternatively, complex var handles can can be obtained\n- * from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n- * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>:\n+ * To make the process of creating these var handles easier, the method\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)} can be used, by providing it a so called\n+ * <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>. A layout path, consisting of several <em>layout\n+ * path elements<\/em>, selects a value layout to be accessed, which can be nested inside another memory layout. For example,\n+ * we can express the access to an element of an {@code int} array using layout paths like so:\n@@ -154,2 +151,7 @@\n- * VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"size\"),\n+ *     MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+ * );\n+ * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElemenet.groupElement(\"data\"),\n+ *                                               MemoryLayout.PathElement.sequenceElement());\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -157,0 +159,9 @@\n+ * Where {@code offsetof(data)} is the offset of the {@code data} element layout of the {@code segmentLayout} layout\n+ *\n+ * Both the var handle returned by {@link ValueLayout#varHandle()} and\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)}, as well as the method handle returned by\n+ * {@link MemoryLayout#byteOffsetHandle(MemoryLayout.PathElement...)} and {@link MemoryLayout#sliceHandle(MemoryLayout.PathElement...)}\n+ * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This\n+ * parameter allows a client to combine these handles further with additional offset computations. This is demonstrated\n+ * in the first of the two examples above, where {@code intHandle} is combined with a\n+ * {@linkplain MemoryLayout#scaleHandle() scale handle} obtained from {@code ValueLayout.JAVA_INT}.\n@@ -375,1 +386,1 @@\n- *     <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length\n+ *     <li>The segment is associated with a scope that is always alive. Thus, while zero-length\n@@ -437,1 +448,1 @@\n- * @since 19\n+ * @since 22\n@@ -439,1 +450,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -600,2 +610,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -629,1 +638,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -634,2 +643,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -669,1 +677,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -674,2 +682,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -742,24 +749,0 @@\n-    \/**\n-     * Returns the offset, in bytes, of the provided segment, relative to this\n-     * segment.\n-     *\n-     * <p>The offset is relative to the address of this segment and can be\n-     * a negative or positive value. For instance, if both segments are native\n-     * segments, or heap segments backed by the same array, the resulting offset\n-     * can be computed as follows:\n-     *\n-     * {@snippet lang=java :\n-     * other.address() - address()\n-     * }\n-     *\n-     * If the segments share the same address, {@code 0} is returned. If\n-     * {@code other} is a slice of this segment, the offset is always\n-     * {@code 0 <= x < this.byteSize()}.\n-     *\n-     * @param other the segment to retrieve an offset to.\n-     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n-     * different kinds, or because they are backed by different Java arrays.\n-     * @return the relative offset, in bytes, of the provided segment.\n-     *\/\n-    long segmentOffset(MemorySegment other);\n-\n@@ -774,1 +757,1 @@\n-     *     byteHandle.set(ValueLayout.JAVA_BYTE, offset, value);\n+     *     segment.set(ValueLayout.JAVA_BYTE, offset, value);\n@@ -1075,1 +1058,2 @@\n-     * Reads a UTF-8 encoded, null-terminated string from this segment at the given offset.\n+     * Reads a null-terminated string from this segment at the given offset, using the\n+     * {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1077,4 +1061,5 @@\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * getString(offset, StandardCharsets.UTF_8);\n+     *}\n+     *\n@@ -1084,3 +1069,4 @@\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - S}, where {@code S} is the size of the UTF-8\n-     * string (including the terminator character).\n+     * @throws IllegalArgumentException if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1092,2 +1078,2 @@\n-    default String getUtf8String(long offset) {\n-        return SharedUtils.toJavaStringInternal(this, offset);\n+    default String getString(long offset) {\n+        return getString(offset, sun.nio.cs.UTF_8.INSTANCE);\n@@ -1097,1 +1083,1 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * Reads a null-terminated string from this segment at the given offset, using the provided charset.\n@@ -1103,0 +1089,28 @@\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the string bytes.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException      if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default String getString(long offset, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset);\n+    }\n+\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1104,4 +1118,4 @@\n-     * If the given string contains any {@code '\\0'} characters, they will be\n-     * copied as well. This means that, depending on the method used to read\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n-     * will appear truncated when read again.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * setString(offset, str, StandardCharsets.UTF_8);\n+     *}\n@@ -1111,1 +1125,3 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - str.getBytes().length() + 1}.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1117,2 +1133,3 @@\n-    default void setUtf8String(long offset, String str) {\n-        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    default void setString(long offset, String str) {\n+        Objects.requireNonNull(str);\n+        setString(offset, str, sun.nio.cs.UTF_8.INSTANCE);\n@@ -1121,0 +1138,37 @@\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     *                the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param str     the Java string to be written into this segment.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default void setString(long offset, String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        StringSupport.write(this, offset, charset, str);\n+    }\n@@ -1284,2 +1338,3 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes} or if\n-     * {@code dstOffset > dstSegment.byteSize() - bytes}, or if either {@code srcOffset}, {@code dstOffset}\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstOffset}\n@@ -1323,1 +1378,3 @@\n-     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n+     * (resp. destination) element layout.\n+     * @throws IllegalArgumentException if {@code srcElementLayout.byteAlignment() > srcElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code dstElementLayout.byteAlignment() > dstElementLayout.byteSize()}.\n@@ -1327,1 +1384,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -1331,1 +1388,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -1333,1 +1390,3 @@\n-     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} or {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - (elementCount * srcLayout.byteSize())}.\n@@ -1364,1 +1423,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n+        return (byte) layout.varHandle().get(this, offset);\n@@ -1384,1 +1443,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1403,1 +1462,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n+        return (boolean) layout.varHandle().get(this, offset);\n@@ -1423,1 +1482,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1442,1 +1501,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n+        return (char) layout.varHandle().get(this, offset);\n@@ -1462,1 +1521,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1481,1 +1540,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n+        return (short) layout.varHandle().get(this, offset);\n@@ -1501,1 +1560,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1520,1 +1579,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n+        return (int) layout.varHandle().get(this, offset);\n@@ -1540,1 +1599,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1559,1 +1618,1 @@\n-        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n+        return (float)layout.varHandle().get(this, offset);\n@@ -1579,1 +1638,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1598,1 +1657,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n+        return (long) layout.varHandle().get(this, offset);\n@@ -1618,1 +1677,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1637,1 +1696,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n+        return (double) layout.varHandle().get(this, offset);\n@@ -1657,1 +1716,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1662,1 +1721,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -1682,1 +1741,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n+        return (MemorySegment) layout.varHandle().get(this, offset);\n@@ -1703,1 +1762,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1718,2 +1777,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1727,1 +1786,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (byte) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1742,2 +1801,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1751,1 +1810,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (boolean) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1766,2 +1825,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1775,1 +1834,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (char) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1790,2 +1849,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1800,1 +1859,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1815,2 +1874,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1824,1 +1883,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (short) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1839,2 +1898,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1849,1 +1908,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1865,2 +1924,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1875,1 +1934,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1890,2 +1949,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1900,1 +1959,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1915,2 +1974,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1924,1 +1983,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (int) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1939,2 +1998,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1949,1 +2008,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1964,2 +2023,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1973,1 +2032,1 @@\n-        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (float) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1988,2 +2047,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1998,1 +2057,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2013,2 +2072,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2022,1 +2081,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (long) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2037,2 +2096,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2047,1 +2106,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2062,2 +2121,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2071,1 +2130,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (double) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2086,2 +2145,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2096,1 +2155,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2101,1 +2160,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -2114,2 +2173,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2126,1 +2185,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2141,2 +2200,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2152,1 +2211,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2201,1 +2260,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -2240,1 +2299,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -2314,0 +2373,20 @@\n+     * <p>\n+     * If two memory segments are obtained from the same {@linkplain #ofBuffer(Buffer) buffer}\n+     * or {@linkplain #ofArray(int[]) array}, the scopes associated with said segments are considered\n+     * {@linkplain #equals(Object) equal}, as the two segments have the same lifetime:\n+     * {@snippet lang=java :\n+     * byte[] arr = new byte[10];\n+     * MemorySegment segment1 = MemorySegment.ofArray(arr);\n+     * MemorySegment segment2 = MemorySegment.ofArray(arr);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n+     * <p>\n+     * If two distinct memory segments are <a href=\"#wrapping-addresses\">zero-length memory segments<\/a>, their scopes\n+     * are always considered {@linkplain #equals(Object) equal}:\n+     * {@snippet lang=java :\n+     * MemorySegment segment1 = MemorySegment.ofAddress(42L);\n+     * MemorySegment segment2 = MemorySegment.ofAddress(1000L);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n+     * The scope of a zero-length memory segment can always be overridden using the\n+     * {@link MemorySegment#reinterpret(Arena, Consumer)} method.\n@@ -2315,1 +2394,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":240,"deletions":162,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -38,1 +37,1 @@\n- * @since 20\n+ * @since 22\n@@ -40,1 +39,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n@@ -31,0 +29,1 @@\n+import java.nio.charset.Charset;\n@@ -33,1 +32,1 @@\n-import java.util.function.Function;\n+\n@@ -35,0 +34,1 @@\n+import jdk.internal.foreign.ArenaImpl;\n@@ -36,2 +36,2 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.foreign.StringSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -73,1 +73,1 @@\n- * @since 19\n+ * @since 22\n@@ -76,1 +76,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -80,1 +79,20 @@\n-     * {@return a new memory segment with a Java string converted into a UTF-8 encoded, null-terminated C string}\n+     * Converts a Java string into a null-terminated C string using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset,\n+     * storing the result into a memory segment.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * allocateFrom(str, StandardCharsets.UTF_8);\n+     *}\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native segment containing the converted C string.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str) {\n+        Objects.requireNonNull(str);\n+        return allocateFrom(str, StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * and storing the result into a memory segment.\n@@ -89,1 +107,1 @@\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n@@ -92,0 +110,4 @@\n+     * @param str     the Java string to be converted into a C string.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @return a new native segment containing the converted C string.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n@@ -93,2 +115,7 @@\n-     * into a new memory segment obtained by calling {@code this.allocate(str.length() + 1)}.\n-     * @param str the Java string to be converted into a C string.\n+     * into a new memory segment obtained by calling {@code this.allocate(B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n@@ -96,1 +123,3 @@\n-    default MemorySegment allocateUtf8String(String str) {\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n@@ -98,1 +127,8 @@\n-        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n+        byte[] bytes = str.getBytes(charset);\n+        MemorySegment segment = allocateNoInit(bytes.length + termCharSize);\n+        MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        for (int i = 0 ; i < termCharSize ; i++) {\n+            segment.set(ValueLayout.JAVA_BYTE, bytes.length + i, (byte)0);\n+        }\n+        return segment;\n@@ -115,1 +151,1 @@\n-    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfByte layout, byte value) {\n@@ -117,3 +153,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -137,1 +172,1 @@\n-    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfChar layout, char value) {\n@@ -139,3 +174,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -159,1 +193,1 @@\n-    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfShort layout, short value) {\n@@ -161,3 +195,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -181,1 +214,1 @@\n-    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfInt layout, int value) {\n@@ -183,3 +216,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -203,1 +235,1 @@\n-    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat layout, float value) {\n@@ -205,3 +237,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -225,1 +256,1 @@\n-    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfLong layout, long value) {\n@@ -227,3 +258,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -247,1 +277,1 @@\n-    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble layout, double value) {\n@@ -249,3 +279,2 @@\n-        VarHandle handle = layout.varHandle();\n-        MemorySegment seg = allocate(layout);\n-        handle.set(seg, value);\n+        MemorySegment seg = allocateNoInit(layout);\n+        seg.set(layout, 0, value);\n@@ -272,1 +301,1 @@\n-    default MemorySegment allocate(AddressLayout layout, MemorySegment value) {\n+    default MemorySegment allocateFrom(AddressLayout layout, MemorySegment value) {\n@@ -275,3 +304,43 @@\n-        MemorySegment seg = allocate(layout);\n-        layout.varHandle().set(seg, value);\n-        return seg;\n+        MemorySegment segment = allocateNoInit(layout);\n+        segment.set(layout, 0, value);\n+        return segment;\n+    }\n+\n+    \/**\n+     * {@return a new memory segment with a {@linkplain MemorySegment#byteSize() byteSize()} of\n+     * {@code elementCount*elementLayout.byteSize()} initialized with the contents of the provided {@code source} segment\n+     * as specified by the provided {@code elementLayout} (i.e. byte ordering, alignment and size)}\n+     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * MemorySegment dest = this.allocate(elementLayout, elementCount);\n+     * MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+     * return dest;\n+     * }\n+     * @param elementLayout the element layout of the allocated array.\n+     * @param source the source segment.\n+     * @param sourceElementLayout the element layout of the source segment.\n+     * @param sourceOffset the starting offset, in bytes, of the source segment.\n+     * @param elementCount the number of elements in the source segment to be copied.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize() != sourceElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if the source segment\/offset are <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a>\n+     * in the source element layout.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code sourceElementLayout.byteAlignment() > sourceElementLayout.byteSize()}.\n+     * @throws IllegalStateException if the {@linkplain MemorySegment#scope() scope} associated with {@code source} is not\n+     * {@linkplain MemorySegment.Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code source.isAccessibleBy(T) == false}.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * sourceElementLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code sourceOffset > source.byteSize() - (elementCount * sourceElementLayout.byteSize())}.\n+     * @throws IndexOutOfBoundsException if either {@code sourceOffset} or {@code elementCount} are {@code < 0}.\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source,\n+                                       ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n+        Objects.requireNonNull(source);\n+        Objects.requireNonNull(sourceElementLayout);\n+        Objects.requireNonNull(elementLayout);\n+        MemorySegment dest = allocateNoInit(elementLayout, elementCount);\n+        MemorySegment.copy(source, sourceElementLayout, sourceOffset, dest, elementLayout, 0, elementCount);\n+        return dest;\n@@ -285,8 +354,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_BYTE, 0, array.length)\n+     *}\n@@ -294,1 +360,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the byte elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -296,2 +363,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfByte elementLayout, byte... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_BYTE, 0, elements.length);\n@@ -305,8 +374,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_SHORT, 0, array.length)\n+     *}\n@@ -315,0 +381,1 @@\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -316,2 +383,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfShort elementLayout, short... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_SHORT, 0, elements.length);\n@@ -325,8 +394,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_CHAR, 0, array.length)\n+     *}\n@@ -334,1 +400,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the char elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -336,2 +403,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfChar elementLayout, char... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_CHAR, 0, elements.length);\n@@ -345,8 +414,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_INT, 0, array.length)\n+     *}\n@@ -354,1 +420,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the int elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -356,2 +423,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfInt elementLayout, int... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_INT, 0, elements.length);\n@@ -365,8 +434,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_FLOAT, 0, array.length)\n+     *}\n@@ -374,1 +440,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the float elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -376,2 +443,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfFloat elementLayout, float... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_FLOAT, 0, elements.length);\n@@ -385,8 +454,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_LONG, 0, array.length)\n+     *}\n@@ -394,1 +460,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements the long elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -396,2 +463,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfLong elementLayout, long... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_LONG, 0, elements.length);\n@@ -405,8 +474,5 @@\n-     * @implSpec The default implementation is equivalent to:\n-     * {@snippet lang=java :\n-     *  int size = Objects.requireNonNull(elements).length;\n-     *  MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-     *  MemorySegment.copy(elements, 0, seg, elementLayout, 0, size);\n-     *  return seg;\n-     * }\n-     *\n+     * @implSpec the default implementation for this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * this.allocateFrom(layout, MemorySegment.ofArray(array),\n+     *                   ValueLayout.JAVA_DOUBLE, 0, array.length)\n+     *}\n@@ -414,1 +480,2 @@\n-     * @param elements      the short elements to be copied to the newly allocated memory block.\n+     * @param elements      the double elements to be copied to the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteAlignment() > elementLayout.byteSize()}.\n@@ -416,13 +483,4 @@\n-    default MemorySegment allocateArray(ValueLayout.OfDouble elementLayout, double... elements) {\n-        return copyArrayWithSwapIfNeeded(elements, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n-        int size = Array.getLength(Objects.requireNonNull(array));\n-        MemorySegment seg = allocateArray(Objects.requireNonNull(elementLayout), size);\n-        if (size > 0) {\n-            MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n-                    seg, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n-        }\n-        return seg;\n+    @ForceInline\n+    default MemorySegment allocateFrom(ValueLayout.OfDouble elementLayout, double... elements) {\n+        return allocateFrom(elementLayout, MemorySegment.ofArray(elements),\n+                ValueLayout.JAVA_DOUBLE, 0, elements.length);\n@@ -455,1 +513,1 @@\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+    default MemorySegment allocate(MemoryLayout elementLayout, long count) {\n@@ -528,0 +586,21 @@\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(long byteSize) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(byteSize, 1) :\n+                allocate(byteSize);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n+                allocate(layout);\n+    }\n+\n+    @ForceInline\n+    private MemorySegment allocateNoInit(MemoryLayout layout, long size) {\n+        return this instanceof ArenaImpl arenaImpl ?\n+                arenaImpl.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n+                allocate(layout, size);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":212,"deletions":133,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -53,1 +52,1 @@\n- * @since 19\n+ * @since 22\n@@ -55,1 +54,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -123,1 +122,1 @@\n- * @since 19\n+ * @since 22\n@@ -125,1 +124,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -170,1 +168,1 @@\n-     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * returned by this method is associated with a {@linkplain MemorySegment.Scope scope} which keeps the caller's\n@@ -194,1 +192,1 @@\n-            MemorySessionImpl session = MemorySessionImpl.heapSession(loader);\n+            MemorySessionImpl session = MemorySessionImpl.createHeap(loader);\n@@ -219,2 +217,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -254,2 +251,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -37,1 +36,1 @@\n- * @since 20\n+ * @since 22\n@@ -39,1 +38,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -31,1 +30,0 @@\n-\n@@ -33,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -54,1 +51,1 @@\n- * @since 19\n+ * @since 22\n@@ -56,1 +53,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -79,60 +75,0 @@\n-    \/**\n-     * Creates a <em>strided<\/em> var handle that can be used to access a memory segment as multi-dimensional\n-     * array. This array has a notional sequence layout featuring {@code shape.length} nested sequence layouts. The element\n-     * layout of the innermost sequence layout in the notional sequence layout is this value layout. The resulting var handle\n-     * is obtained as if calling the {@link #varHandle(PathElement...)} method on the notional layout, with a layout\n-     * path containing exactly {@code shape.length + 1} {@linkplain PathElement#sequenceElement() open sequence layout path elements}.\n-     * <p>\n-     * For instance, the following method call:\n-     *\n-     * {@snippet lang=java :\n-     * VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-     * }\n-     *\n-     * Is equivalent to the following code:\n-     *\n-     * {@snippet lang = java:\n-     * SequenceLayout notionalLayout = MemoryLayout.sequenceLayout(\n- *                                         MemoryLayout.sequenceLayout(10, MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-     * VarHandle arrayHandle = notionalLayout.varHandle(PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement());\n-     *}\n-     *\n-     * The resulting var handle {@code arrayHandle} will feature 3 coordinates of type {@code long}; each coordinate\n-     * is interpreted as an index into the corresponding sequence layout. If we refer to the var handle coordinates, from left\n-     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset accessed by the var handle can be\n-     * computed with the following formula:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = (10 * 20 * 4 * x) + (20 * 4 * y) + (4 * z)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Additionally, the values of {@code x}, {@code y} and {@code z} are constrained as follows:\n-     * <ul>\n-     *     <li>{@code 0 <= x < notionalLayout.elementCount() }<\/li>\n-     *     <li>{@code 0 <= y < 10 }<\/li>\n-     *     <li>{@code 0 <= z < 20 }<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Consider the following access expressions:\n-     * {@snippet lang=java :\n-     * int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-     * int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-     * }\n-     * In the first case, access is well-formed, as the values for {@code x}, {@code y} and {@code z} conform to\n-     * the bounds specified above. In the second case, access fails with {@link IndexOutOfBoundsException},\n-     * as the value for {@code z} is outside its specified bounds.\n-     *\n-     * @param shape the size of each nested array dimension.\n-     * @return a var handle which can be used to access a memory segment as a multi-dimensional array,\n-     * featuring {@code shape.length + 1}\n-     * {@code long} coordinates.\n-     * @throws IllegalArgumentException if {@code shape[i] < 0}, for at least one index {@code i}.\n-     * @throws UnsupportedOperationException if {@code byteAlignment() > byteSize()}.\n-     * @see MethodHandles#memorySegmentViewVarHandle\n-     * @see MemoryLayout#varHandle(PathElement...)\n-     * @see SequenceLayout\n-     *\/\n-    VarHandle arrayElementVarHandle(int... shape);\n-\n@@ -152,0 +88,1 @@\n+     *\n@@ -157,0 +94,21 @@\n+    \/**\n+     * {@return a var handle which can be used to access values described by this value layout, in a given memory segment.}\n+     * <p>\n+     * The returned var handle's {@linkplain VarHandle#varType() var type} is the {@linkplain ValueLayout#carrier() carrier type} of\n+     * this value layout, and the list of coordinate types is {@code (MemorySegment, long)}, where the memory segment coordinate\n+     * corresponds to the memory segment to be accessed, and the {@code long} coordinate corresponds to the byte offset\n+     * into the accessed memory segment at which the access occurs.\n+     * <p>\n+     * The returned var handle checks that accesses are aligned according to this value layout's\n+     * {@linkplain MemoryLayout#byteAlignment() alignment constraint}.\n+     *\n+     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n+     * with an empty path element array, as it avoids the creation of the var args array.\n+     *\n+     * @apiNote The returned var handle features certain <a href=\"MemoryLayout.html#access-mode-restrictions\">access mode\n+     * restrictions<\/a> common to all memory access var handles derived from memory layouts.\n+     *\n+     * @see MemoryLayout#varHandle(PathElement...)\n+     *\/\n+    VarHandle varHandle();\n+\n@@ -161,1 +119,1 @@\n-     * @since 19\n+     * @since 22\n@@ -163,2 +121,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n+        sealed interface OfBoolean extends ValueLayout permits ValueLayouts.OfBooleanImpl {\n@@ -197,1 +154,1 @@\n-     * @since 19\n+     * @since 22\n@@ -199,2 +156,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n+        sealed interface OfByte extends ValueLayout permits ValueLayouts.OfByteImpl {\n@@ -234,1 +190,1 @@\n-     * @since 19\n+     * @since 22\n@@ -236,2 +192,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n+        sealed interface OfChar extends ValueLayout permits ValueLayouts.OfCharImpl {\n@@ -271,1 +226,1 @@\n-     * @since 19\n+     * @since 22\n@@ -273,2 +228,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n+        sealed interface OfShort extends ValueLayout permits ValueLayouts.OfShortImpl {\n@@ -308,1 +262,1 @@\n-     * @since 19\n+     * @since 22\n@@ -310,2 +264,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n+        sealed interface OfInt extends ValueLayout permits ValueLayouts.OfIntImpl {\n@@ -345,1 +298,1 @@\n-     * @since 19\n+     * @since 22\n@@ -347,2 +300,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n+        sealed interface OfFloat extends ValueLayout permits ValueLayouts.OfFloatImpl {\n@@ -381,1 +333,1 @@\n-     * @since 19\n+     * @since 22\n@@ -383,2 +335,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n+        sealed interface OfLong extends ValueLayout permits ValueLayouts.OfLongImpl {\n@@ -418,1 +369,1 @@\n-     * @since 19\n+     * @since 22\n@@ -420,2 +371,1 @@\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n+        sealed interface OfDouble extends ValueLayout permits ValueLayouts.OfDoubleImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":39,"deletions":89,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n- *     MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -112,1 +112,1 @@\n- * {@linkplain java.lang.foreign.SegmentAllocator#allocateUtf8String(java.lang.String) converting} Java strings into\n+ * {@linkplain java.lang.foreign.SegmentAllocator#allocateFrom(java.lang.String) converting} Java strings into\n@@ -150,1 +150,1 @@\n- * @since 19\n+ * @since 22\n@@ -152,1 +152,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -155,1 +154,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-                    MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+                    MemorySegment s = slicingArena.allocateFrom(JAVA_INT, 1, 2, 3, 4, 5);\n@@ -151,1 +151,1 @@\n-                    sequenceLayout(ValueLayout.JAVA_BYTE));\n+                    sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -171,1 +171,1 @@\n-                MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -200,1 +200,1 @@\n-                MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+                MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -291,1 +291,1 @@\n-                int res = (int) printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+                int res = (int) printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -316,1 +316,1 @@\n-                int errno = (int) errnoHandle.get(capturedState);\n+                int errno = (int) errnoHandle.get(capturedState, 0L);\n@@ -354,2 +354,2 @@\n-            long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n-            long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+            long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 8\n+            long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 16\n@@ -399,1 +399,1 @@\n-                VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+                VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -411,2 +411,7 @@\n-                VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-                int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+                MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withName(\"size\"),\n+                    MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+                );\n+                VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+                                                              MemoryLayout.PathElement.sequenceElement());\n+                int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -527,2 +532,0 @@\n-            var byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n-                    .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -530,1 +533,1 @@\n-                byteHandle.set(segment.address(), l, value);\n+                segment.set(JAVA_BYTE, l, value);\n@@ -573,1 +576,1 @@\n-                MemorySegment cString = arena.allocateUtf8String(\"Hello\");\n+                MemorySegment cString = arena.allocateFrom(\"Hello\");\n@@ -657,11 +660,0 @@\n-        void arrayElementVarHandle() {\n-            VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-\n-            SequenceLayout arrayLayout = MemoryLayout.sequenceLayout(\n-                    MemoryLayout.sequenceLayout(10,\n-                            MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT)));\n-\n-            int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-            int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -7981,79 +7981,0 @@\n-    \/**\n-     * Creates a var handle object, which can be used to dereference a {@linkplain java.lang.foreign.MemorySegment memory segment}\n-     * at a given byte offset, using the provided value layout.\n-     *\n-     * <p>The provided layout specifies the {@linkplain ValueLayout#carrier() carrier type},\n-     * the {@linkplain ValueLayout#byteSize() byte size},\n-     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n-     * associated with the returned var handle.\n-     *\n-     * <p>The list of coordinate types associated with the returned var handle is {@code (MemorySegment, long)},\n-     * where the {@code long} coordinate type corresponds to byte offset into the given memory segment coordinate.\n-     * Thus, the returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from\n-     * a value of the var handle type. Moreover, the access operation will honor the endianness and the\n-     * alignment constraints expressed in the provided layout.\n-     *\n-     * <p>As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n-     * {@snippet lang=\"java\" :\n-     *     GroupLayout seq = java.lang.foreign.MemoryLayout.structLayout(\n-     *             MemoryLayout.paddingLayout(4),\n-     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n-     *     );\n-     * }\n-     * To access the member layout named {@code value}, we can construct a memory segment view var handle as follows:\n-     * {@snippet lang=\"java\" :\n-     *     VarHandle handle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n-     *     handle = MethodHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n-     * }\n-     *\n-     * @apiNote The resulting var handle features certain <i>access mode restrictions<\/i>,\n-     * which are common to all memory segment view var handles. A memory segment view var handle is associated\n-     * with an access size {@code S} and an alignment constraint {@code B}\n-     * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n-     * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n-     * If access is fully aligned then following access modes are supported and are\n-     * guaranteed to support atomic access:\n-     * <ul>\n-     * <li>read write access modes for all {@code T}, with the exception of\n-     *     access modes {@code get} and {@code set} for {@code long} and\n-     *     {@code double} on 32-bit platforms.\n-     * <li>atomic update access modes for {@code int}, {@code long},\n-     *     {@code float}, {@code double} or {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     types for certain currently unsupported access modes.)\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <\/ul>\n-     *\n-     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n-     * update access modes compare values using their bitwise representation\n-     * (see {@link Float#floatToRawIntBits},\n-     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n-     * <p>\n-     * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n-     * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n-     * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n-     * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n-     * <p>\n-     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n-     * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n-     * <p>\n-     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n-     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n-     *\n-     * @param layout the value layout for which a memory access handle is to be obtained.\n-     * @return the new memory segment view var handle.\n-     * @throws NullPointerException if {@code layout} is {@code null}.\n-     * @see MemoryLayout#varHandle(MemoryLayout.PathElement...)\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static VarHandle memorySegmentViewVarHandle(ValueLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return Utils.makeSegmentViewVarHandle(layout);\n-    }\n-\n@@ -8090,1 +8011,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8092,1 +8013,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8126,1 +8046,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8128,1 +8048,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8158,1 +8077,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8160,1 +8079,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8201,1 +8119,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8203,1 +8121,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8245,1 +8162,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8247,1 +8164,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -8271,1 +8187,1 @@\n-     * @since 19\n+     * @since 22\n@@ -8273,1 +8189,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":6,"deletions":91,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.foreign.Utils;\n+\n@@ -57,1 +59,5 @@\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + Utils.toHexString(address));\n+    }\n+\n+    static UnsupportedOperationException newUnsupportedAccessModeForAlignment(long alignment) {\n+        return new UnsupportedOperationException(\"Unsupported access mode for alignment: \" + alignment);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static final int VM_ALIGN = $BoxType$.BYTES - 1;\n+    static final int NON_PLAIN_ACCESS_MIN_ALIGN_MASK = $BoxType$.BYTES - 1;\n@@ -107,4 +107,3 @@\n-    static long offset(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n-        if ((address & VM_ALIGN) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        if ((alignmentMask & NON_PLAIN_ACCESS_MIN_ALIGN_MASK) != NON_PLAIN_ACCESS_MIN_ALIGN_MASK) {\n+            throw VarHandleSegmentViewBase.newUnsupportedAccessModeForAlignment(alignmentMask + 1);\n@@ -112,1 +111,1 @@\n-        return address;\n+        return offsetPlain(bb, offset, alignmentMask);\n@@ -116,1 +115,1 @@\n-    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n@@ -133,1 +132,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -140,1 +139,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n+                offsetPlain(bb, base, handle.alignmentMask));\n@@ -144,1 +143,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -157,1 +156,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -164,1 +163,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -169,1 +168,1 @@\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base, handle.alignmentMask),\n@@ -183,1 +182,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -192,1 +191,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -203,1 +202,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -212,1 +211,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -223,1 +222,1 @@\n-                                  offset(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n@@ -232,1 +231,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -243,1 +242,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -254,1 +253,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -265,1 +264,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -276,1 +275,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -286,1 +285,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -296,1 +295,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -306,1 +305,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -316,1 +315,1 @@\n-                offset(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -327,1 +326,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -338,1 +337,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -349,1 +348,1 @@\n-                                  offset(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -362,1 +361,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -365,1 +364,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -376,1 +375,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -379,1 +378,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -390,1 +389,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -393,1 +392,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n@@ -418,1 +417,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -421,1 +420,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -432,1 +431,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -435,1 +434,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -446,1 +445,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -449,1 +448,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -472,1 +471,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -475,1 +474,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -486,1 +485,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -489,1 +488,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -500,1 +499,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -503,1 +502,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -527,1 +526,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -530,1 +529,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -541,1 +540,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -544,1 +543,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n@@ -555,1 +554,1 @@\n-                    offset(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, handle.alignmentMask),\n@@ -558,1 +557,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":53,"deletions":54,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-     * @since   19\n+     * @since   22\n@@ -1093,1 +1093,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -718,1 +718,1 @@\n-                \/\/ JDK internal attributes\n+                \/\/ JDK specific attributes\n@@ -721,0 +721,1 @@\n+                addName(names, new Name(\"Enable-Native-Access\"));\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/Attributes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -276,1 +277,1 @@\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n@@ -577,0 +578,10 @@\n+\n+    \/**\n+     * Copy the string bytes to an existing segment, avoiding intermediate copies.\n+     *\/\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+\n+    \/**\n+     * Are the string bytes compatible with the given charset?\n+     *\/\n+    boolean bytesCompatible(String string, Charset charset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -57,0 +56,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -267,1 +267,1 @@\n-                long offsetToThat = this.segmentOffset(that);\n+                long offsetToThat = that.address() - this.address();\n@@ -275,9 +275,0 @@\n-    @Override\n-    public final long segmentOffset(MemorySegment other) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n-        if (unsafeGetBase() == that.unsafeGetBase()) {\n-            return that.unsafeGetOffset() - this.unsafeGetOffset();\n-        }\n-        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n-    }\n-\n@@ -549,1 +540,1 @@\n-            bufferScope = MemorySessionImpl.heapSession(bb);\n+            bufferScope = MemorySessionImpl.createHeap(bufferRef(bb));\n@@ -552,17 +543,17 @@\n-            if (base instanceof byte[]) {\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof short[]) {\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof char[]) {\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof int[]) {\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof float[]) {\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof long[]) {\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof double[]) {\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else {\n-                throw new AssertionError(\"Cannot get here\");\n-            }\n+            return switch (base) {\n+                case byte[] __ ->\n+                        new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case short[] __ ->\n+                        new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case char[] __ ->\n+                        new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case int[] __ ->\n+                        new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case float[] __ ->\n+                        new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case long[] __ ->\n+                        new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case double[] __ ->\n+                        new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                default -> throw new AssertionError(\"Cannot get here\");\n+            };\n@@ -577,15 +568,5 @@\n-    private static int getScaleFactor(Buffer buffer) {\n-        if (buffer instanceof ByteBuffer) {\n-            return 0;\n-        } else if (buffer instanceof CharBuffer) {\n-            return 1;\n-        } else if (buffer instanceof ShortBuffer) {\n-            return 1;\n-        } else if (buffer instanceof IntBuffer) {\n-            return 2;\n-        } else if (buffer instanceof FloatBuffer) {\n-            return 2;\n-        } else if (buffer instanceof LongBuffer) {\n-            return 3;\n-        } else if (buffer instanceof DoubleBuffer) {\n-            return 3;\n+    private static Object bufferRef(Buffer buffer) {\n+        if (buffer instanceof DirectBuffer directBuffer) {\n+            \/\/ direct buffer, return either the buffer attachment (for slices and views), or the buffer itself\n+            return directBuffer.attachment() != null ?\n+                    directBuffer.attachment() : directBuffer;\n@@ -593,1 +574,2 @@\n-            throw new AssertionError(\"Cannot get here\");\n+            \/\/ heap buffer, return the underlying array\n+            return NIO_ACCESS.getBufferBase(buffer);\n@@ -634,1 +616,1 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        var dstInfo = Utils.BaseAndScale.of(dstArray);\n@@ -638,2 +620,0 @@\n-        int dstBase = (int)baseAndScale;\n-        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -645,1 +625,1 @@\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        srcImpl.checkAccess(srcOffset, elementCount * dstInfo.scale(), true);\n@@ -647,1 +627,1 @@\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+        if (dstInfo.scale() == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n@@ -650,1 +630,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale());\n@@ -654,1 +634,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale(), dstInfo.scale());\n@@ -663,1 +643,1 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        var srcInfo = Utils.BaseAndScale.of(srcArray);\n@@ -667,2 +647,0 @@\n-        int srcBase = (int)baseAndScale;\n-        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -675,2 +653,2 @@\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+        destImpl.checkAccess(dstOffset, elementCount * srcInfo.scale(), false);\n+        if (srcInfo.scale() == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n@@ -678,2 +656,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale());\n@@ -682,2 +660,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale(), srcInfo.scale());\n@@ -725,18 +703,10 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long) Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+    private static int getScaleFactor(Buffer buffer) {\n+        return switch (buffer) {\n+            case ByteBuffer   __ -> 0;\n+            case CharBuffer   __ -> 1;\n+            case ShortBuffer  __ -> 1;\n+            case IntBuffer    __ -> 2;\n+            case FloatBuffer  __ -> 2;\n+            case LongBuffer   __ -> 3;\n+            case DoubleBuffer __ -> 3;\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":49,"deletions":79,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+\n+public final class ArenaImpl implements Arena {\n+\n+    private final MemorySessionImpl session;\n+    private final boolean shouldReserveMemory;\n+    ArenaImpl(MemorySessionImpl session) {\n+        this.session = session;\n+        shouldReserveMemory = session instanceof ImplicitSession;\n+    }\n+\n+    @Override\n+    public Scope scope() {\n+        return session;\n+    }\n+\n+    @Override\n+    public void close() {\n+        session.close();\n+    }\n+\n+    public MemorySegment allocateNoInit(long byteSize, long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, session, shouldReserveMemory);\n+    }\n+\n+    @Override\n+    public MemorySegment allocate(long byteSize, long byteAlignment) {\n+        MemorySegment segment = allocateNoInit(byteSize, byteAlignment);\n+        return segment.fill((byte)0);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.ref.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -29,0 +31,4 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import java.nio.Buffer;\n+import java.util.Objects;\n@@ -35,3 +41,1 @@\n-final class GlobalSession extends MemorySessionImpl {\n-\n-    final Object ref;\n+non-sealed class GlobalSession extends MemorySessionImpl {\n@@ -39,1 +43,1 @@\n-    public GlobalSession(Object ref) {\n+    public GlobalSession() {\n@@ -41,1 +45,0 @@\n-        this.ref = ref;\n@@ -70,0 +73,28 @@\n+\n+    \/**\n+     * This is a global session that wraps a heap object. Possible objects are: Java arrays, buffers and\n+     * class loaders. Objects of two heap sessions are compared by identity. That is, if the wrapped object is the same,\n+     * then the resulting heap sessions are also considered equals. We do not compare the objects using\n+     * {@link Object#equals(Object)}, as that would be problematic when comparing buffers, whose equality and\n+     * hash codes are content-dependent.\n+     *\/\n+    static class HeapSession extends GlobalSession {\n+\n+        final Object ref;\n+\n+        public HeapSession(Object ref) {\n+            super();\n+            this.ref = Objects.requireNonNull(ref);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof HeapSession session &&\n+                    ref == session.ref;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(ref);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -44,1 +43,1 @@\n- * of {@link HeapMemorySegmentImpl} are defined (e.g. {@link OfFloat}, so that each subclass can override the\n+ * of {@link HeapMemorySegmentImpl} are defined (e.g. {@link OfFloat}), so that each subclass can override the\n@@ -53,2 +52,4 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-    private static final int BYTE_ARR_BASE = UNSAFE.arrayBaseOffset(byte[].class);\n+    \/\/ Constants defining the maximum alignment supported by various kinds of heap arrays.\n+    \/\/ While for most arrays, the maximum alignment is constant (the size, in bytes, of the array elements),\n+    \/\/ note that the alignment of a long[]\/double[] depends on the platform: it's 4-byte on x86, but 8 bytes on x64\n+    \/\/ (as specified by the JAVA_LONG layout constant).\n@@ -56,4 +57,4 @@\n-    private static final long MAX_ALIGN_1 = ValueLayout.JAVA_BYTE.byteAlignment();\n-    private static final long MAX_ALIGN_2 = ValueLayout.JAVA_SHORT.byteAlignment();\n-    private static final long MAX_ALIGN_4 = ValueLayout.JAVA_INT.byteAlignment();\n-    private static final long MAX_ALIGN_8 = ValueLayout.JAVA_LONG.byteAlignment();\n+    private static final long MAX_ALIGN_BYTE_ARRAY = ValueLayout.JAVA_BYTE.byteAlignment();\n+    private static final long MAX_ALIGN_SHORT_ARRAY = ValueLayout.JAVA_SHORT.byteAlignment();\n+    private static final long MAX_ALIGN_INT_ARRAY = ValueLayout.JAVA_INT.byteAlignment();\n+    private static final long MAX_ALIGN_LONG_ARRAY = ValueLayout.JAVA_LONG.byteAlignment();\n@@ -92,1 +93,1 @@\n-        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - Utils.BaseAndScale.BYTE.base(), (int) byteSize(), null);\n@@ -115,3 +116,3 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.BYTE.scale();\n+            return new OfByte(Utils.BaseAndScale.BYTE.base(), arr, byteSize, false,\n+                    MemorySessionImpl.createHeap(arr));\n@@ -122,1 +123,1 @@\n-            return MAX_ALIGN_1;\n+            return MAX_ALIGN_BYTE_ARRAY;\n@@ -127,1 +128,1 @@\n-            return offset - Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.BYTE.base();\n@@ -149,3 +150,3 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.CHAR.scale();\n+            return new OfChar(Utils.BaseAndScale.CHAR.base(), arr, byteSize, false,\n+                    MemorySessionImpl.createHeap(arr));\n@@ -156,1 +157,1 @@\n-            return MAX_ALIGN_2;\n+            return MAX_ALIGN_SHORT_ARRAY;\n@@ -161,1 +162,1 @@\n-            return offset - Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.CHAR.base();\n@@ -183,3 +184,3 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.SHORT.scale();\n+            return new OfShort(Utils.BaseAndScale.SHORT.base(), arr, byteSize, false,\n+                    MemorySessionImpl.createHeap(arr));\n@@ -190,1 +191,1 @@\n-            return MAX_ALIGN_2;\n+            return MAX_ALIGN_SHORT_ARRAY;\n@@ -195,1 +196,1 @@\n-            return offset - Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.SHORT.base();\n@@ -217,3 +218,3 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.INT.scale();\n+            return new OfInt(Utils.BaseAndScale.INT.base(), arr, byteSize, false,\n+                    MemorySessionImpl.createHeap(arr));\n@@ -224,1 +225,1 @@\n-            return MAX_ALIGN_4;\n+            return MAX_ALIGN_INT_ARRAY;\n@@ -229,1 +230,1 @@\n-            return offset - Unsafe.ARRAY_INT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.INT.base();\n@@ -251,3 +252,3 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.LONG.scale();\n+            return new OfLong(Utils.BaseAndScale.LONG.base(), arr, byteSize, false,\n+                    MemorySessionImpl.createHeap(arr));\n@@ -258,1 +259,1 @@\n-            return MAX_ALIGN_8;\n+            return MAX_ALIGN_LONG_ARRAY;\n@@ -263,1 +264,1 @@\n-            return offset - Unsafe.ARRAY_LONG_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.LONG.base();\n@@ -285,3 +286,3 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.FLOAT.scale();\n+            return new OfFloat(Utils.BaseAndScale.FLOAT.base(), arr, byteSize, false,\n+                    MemorySessionImpl.createHeap(arr));\n@@ -292,1 +293,1 @@\n-            return MAX_ALIGN_4;\n+            return MAX_ALIGN_INT_ARRAY;\n@@ -297,1 +298,1 @@\n-            return offset - Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.FLOAT.base();\n@@ -319,3 +320,3 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.DOUBLE.scale();\n+            return new OfDouble(Utils.BaseAndScale.DOUBLE.base(), arr, byteSize, false,\n+                    MemorySessionImpl.createHeap(arr));\n@@ -326,1 +327,1 @@\n-            return MAX_ALIGN_8;\n+            return MAX_ALIGN_LONG_ARRAY;\n@@ -331,1 +332,1 @@\n-            return offset - Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.DOUBLE.base();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\n@@ -42,0 +41,1 @@\n+import java.util.List;\n@@ -44,0 +44,4 @@\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n@@ -46,1 +50,1 @@\n- * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)},\n+ * This class provide support for constructing layout paths; that is, starting from a root path (see {@link #rootPath(MemoryLayout)}),\n@@ -64,0 +68,1 @@\n+    private static final MethodHandle MH_ADD;\n@@ -75,1 +80,1 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n+                    MethodType.methodType(void.class, MemorySegment.class, long.class, MemoryLayout.class));\n@@ -78,0 +83,2 @@\n+            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(long.class, long.class, long.class));\n@@ -87,1 +94,0 @@\n-\n@@ -103,2 +109,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -110,2 +115,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -120,1 +124,1 @@\n-                                     addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n+                addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n@@ -124,2 +128,1 @@\n-        check(SequenceLayout.class, \"attempting to select a sequence element from a non-sequence layout\");\n-        SequenceLayout seq = (SequenceLayout)layout;\n+        SequenceLayout seq = requireSequenceLayout();\n@@ -129,1 +132,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters,this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters, this);\n@@ -133,2 +136,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -148,1 +150,2 @@\n-            throw badLayoutPath(\"cannot resolve '\" + name + \"' in layout \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"cannot resolve '%s' in layout %s\", name, breadcrumbs()));\n@@ -154,2 +157,1 @@\n-        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n-        GroupLayout g = (GroupLayout)layout;\n+        GroupLayout g = requireGroupLayout();\n@@ -161,1 +163,2 @@\n-                throw badLayoutPath(\"cannot resolve element \" + index + \" in layout \" + layout);\n+                throw badLayoutPath(\n+                        String.format(\"cannot resolve element %d in layout: %s\", index, breadcrumbs()));\n@@ -174,1 +177,2 @@\n-            throw badLayoutPath(\"Cannot dereference layout: \" + layout);\n+            throw badLayoutPath(\n+                    String.format(\"Cannot dereference layout: %s\", breadcrumbs()));\n@@ -199,1 +203,2 @@\n-            throw new IllegalArgumentException(\"Path does not select a value layout\");\n+            throw new IllegalArgumentException(\n+                    String.format(\"Path does not select a value layout: %s\", breadcrumbs()));\n@@ -205,1 +210,1 @@\n-        VarHandle handle = Utils.makeSegmentViewVarHandle(accessedLayout);\n+        VarHandle handle = accessedLayout.varHandle();\n@@ -212,2 +217,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            handle = MethodHandles.filterCoordinates(handle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n+            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n@@ -217,0 +226,4 @@\n+            if (derefAdapters.length > 0) {\n+                \/\/ plug up the base offset if we have at least 1 enclosing dereference\n+                handle = MethodHandles.insertCoordinates(handle, 1, 0);\n+            }\n@@ -218,1 +231,7 @@\n-                handle = MethodHandles.collectCoordinates(handle, 0, derefAdapters[i - 1]);\n+                MethodHandle adapter = derefAdapters[i - 1];\n+                \/\/ the first\/outermost adapter will have a base offset coordinate, the rest are constant 0\n+                if (i > 1) {\n+                    \/\/ plug in a constant 0 base offset for all but the outermost access in a deref chain\n+                    adapter = MethodHandles.insertArguments(adapter, 1, 0);\n+                }\n+                handle = MethodHandles.collectCoordinates(handle, 0, adapter);\n@@ -231,2 +250,2 @@\n-        MethodHandle mh = MethodHandles.identity(long.class);\n-        for (int i = strides.length - 1; i >=0; i--) {\n+        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        for (int i = strides.length - 1; i >= 0; i--) {\n@@ -238,1 +257,1 @@\n-        mh = MethodHandles.insertArguments(mh, 0, offset);\n+\n@@ -256,1 +275,1 @@\n-        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, ...) -> MS\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, long, ...) -> MS\n@@ -259,2 +278,6 @@\n-            MethodHandle checkHandle = MethodHandles.insertArguments(MH_CHECK_ALIGN, 1, rootLayout());\n-            sliceHandle = MethodHandles.filterArguments(sliceHandle, 0, checkHandle);\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            MethodType oldType = sliceHandle.type();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            sliceHandle = MethodHandles.collectArguments(sliceHandle, 0, alignCheck); \/\/ (MS, long, MS, long) -> MS\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, oldType.parameterCount())).toArray();\n+            sliceHandle = MethodHandles.permuteArguments(sliceHandle, oldType, reorder); \/\/ (MS, long, ...) -> MS\n@@ -266,3 +289,5 @@\n-    private static MemorySegment checkAlign(MemorySegment segment, MemoryLayout constraint) {\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(0, constraint)) {\n-            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n+    private static void checkAlign(MemorySegment segment, long offset, MemoryLayout constraint) {\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, constraint)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, constraint.byteAlignment(), constraint, segment));\n@@ -270,1 +295,0 @@\n-        return segment;\n@@ -295,1 +319,9 @@\n-    private void check(Class<?> layoutClass, String msg) {\n+    private SequenceLayout requireSequenceLayout() {\n+        return requireLayoutType(SequenceLayout.class, \"sequence\");\n+    }\n+\n+    private GroupLayout requireGroupLayout() {\n+        return requireLayoutType(GroupLayout.class, \"group\");\n+    }\n+\n+    private <T extends MemoryLayout> T requireLayoutType(Class<T> layoutClass, String name) {\n@@ -297,1 +329,3 @@\n-            throw badLayoutPath(msg);\n+            throw badLayoutPath(\n+                    String.format(\"attempting to select a %s element from a non-%s layout: %s\",\n+                            name, name, breadcrumbs()));\n@@ -299,0 +333,1 @@\n+        return layoutClass.cast(layout);\n@@ -303,1 +338,2 @@\n-            throw badLayoutPath(String.format(\"Sequence index out of bound; found: %d, size: %d\", index, seq.elementCount()));\n+            throw badLayoutPath(String.format(\"sequence index out of bounds; index: %d, elementCount is %d for layout %s\",\n+                    index, seq.elementCount(), breadcrumbs()));\n@@ -323,0 +359,7 @@\n+    private String breadcrumbs() {\n+        return Stream.iterate(this, Objects::nonNull, lp -> lp.enclosing)\n+                .map(LayoutPath::layout)\n+                .map(Object::toString)\n+                .collect(joining(\", selected from: \"));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":80,"deletions":37,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null, this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.Buffer;\n+import java.util.function.BiFunction;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.foreign.MemoryInspectionUtil.*;\n+\n+\/**\n+ * Class that supports inspection of MemorySegments through MemoryLayouts.\n+ * <p>\n+ * Memory abstractions such as ByteBuffers and byte arrays can be inspected via wrapping methods\n+ * such as {@link MemorySegment#ofArray(byte[])} and {@link MemorySegment#ofBuffer(Buffer)}.\n+ *\n+ * @since 20\n+ *\/\n+public final class MemoryInspection {\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspection() {\n+    }\n+\n+    \/**\n+     * Returns a human-readable view of the provided {@linkplain MemorySegment memory} viewed\n+     * through the provided {@linkplain MemoryLayout layout} using the provided {@code renderer}.\n+     * <p>\n+     * The exact format of the returned view is unspecified and should not\n+     * be acted upon programmatically.\n+     * <p>\n+     * As an example, a MemorySegment viewed though the following memory layout\n+     * {@snippet lang = java:\n+     * var layout = MemoryLayout.structLayout(\n+     *         ValueLayout.JAVA_INT.withName(\"x\"),\n+     *         ValueLayout.JAVA_INT.withName(\"y\")\n+     * ).withName(\"Point\");\n+     *\n+     * MemoryInspection.inspect(segment, layout, ValueLayoutRenderer.standard())\n+     *     .forEach(System.out::println);\n+     *\n+     *}\n+     * might be rendered to something like this:\n+     * {@snippet lang = text:\n+     * Point {\n+     *   x=1,\n+     *   y=2\n+     * }\n+     *}\n+     * <p>\n+     * This method is intended to view memory segments through small and medium-sized memory layouts.\n+     *\n+     * @param segment  to be viewed\n+     * @param layout   to use as a layout when viewing the memory segment\n+     * @param renderer to apply when rendering value layouts\n+     * @return a view of the memory abstraction viewed through the memory layout\n+     *\/\n+    public static Stream<String> inspect(MemorySegment segment,\n+                                         MemoryLayout layout,\n+                                         BiFunction<ValueLayout, Object, String> renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+        return MemoryInspectionUtil.inspect(segment, layout, renderer);\n+    }\n+\n+    \/**\n+     * {@return a standard value layout renderer that will render numeric values into decimal form and where\n+     * other value types are rendered to a reasonable \"natural\" form}\n+     * <p>\n+     * More specifically, values types are rendered as follows:\n+     * <ul>\n+     *     <li>Numeric values are rendered in decimal form (e.g 1 or 1.2).<\/li>\n+     *     <li>Boolean values are rendered as {@code true} or {@code false}.<\/li>\n+     *     <li>Character values are rendered as {@code char}.<\/li>\n+     *     <li>Address values are rendered in hexadecimal form e.g. {@code 0x0000000000000000} (on 64-bit platforms) or\n+     *     {@code 0x00000000} (on 32-bit platforms)<\/li>\n+     * <\/ul>\n+     *\/\n+    public static BiFunction<ValueLayout, Object, String> standardRenderer() {\n+        return STANDARD_VALUE_LAYOUT_RENDERER;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspection.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Internal class to support inspection MemorySegments into various formats.\n+ *\/\n+final class MemoryInspectionUtil {\n+\n+    static final BiFunction<ValueLayout, Object, String> STANDARD_VALUE_LAYOUT_RENDERER = new StandardValueLayoutRenderer();\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private MemoryInspectionUtil() {\n+    }\n+\n+    static Stream<String> inspect(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  BiFunction<ValueLayout, Object, String> renderer) {\n+        requireNonNull(segment);\n+        requireNonNull(layout);\n+        requireNonNull(renderer);\n+\n+        final var builder = Stream.<String>builder();\n+        toString0(segment, layout, renderer, builder::add, new ViewState(), \"\");\n+        return builder.build();\n+    }\n+\n+    private static void toString0(MemorySegment segment,\n+                                  MemoryLayout layout,\n+                                  BiFunction<ValueLayout, Object, String> renderer,\n+                                  Consumer<String> action,\n+                                  ViewState state,\n+                                  String suffix) {\n+\n+        switch (layout) {\n+            case ValueLayout.OfBoolean ofBoolean ->\n+                    action.accept(renderValueLayout(state, ofBoolean, renderer.apply(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            case ValueLayout.OfByte ofByte ->\n+                    action.accept(renderValueLayout(state, ofByte, renderer.apply(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            case ValueLayout.OfShort ofShort ->\n+                    action.accept(renderValueLayout(state, ofShort, renderer.apply(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            case ValueLayout.OfChar ofChar ->\n+                    action.accept(renderValueLayout(state, ofChar, renderer.apply(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n+            case ValueLayout.OfInt ofInt ->\n+                    action.accept(renderValueLayout(state, ofInt, renderer.apply(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            case ValueLayout.OfLong ofLong ->\n+                    action.accept(renderValueLayout(state, ofLong, renderer.apply(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            case ValueLayout.OfFloat ofFloat ->\n+                    action.accept(renderValueLayout(state, ofFloat, renderer.apply(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            case ValueLayout.OfDouble ofDouble ->\n+                    action.accept(renderValueLayout(state, ofDouble, renderer.apply(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            case AddressLayout addressLayout ->\n+                    action.accept(renderValueLayout(state, addressLayout, renderer.apply(addressLayout, segment.get(addressLayout, state.indexAndAdd(addressLayout))), suffix));\n+            case PaddingLayout paddingLayout -> {\n+                action.accept(state.indentSpaces() + paddingLayout.byteSize() + \" padding bytes\");\n+                state.indexAndAdd(paddingLayout);\n+            }\n+            case GroupLayout groupLayout -> {\n+                \/* Strictly, we should provide all permutations of unions.\n+                 * So, if we have a union U =  (A|B),(C|D) then we should present:\n+                 * (A,C), (A,D), (B,C) and (B,D)\n+                 *\/\n+\n+                final var separator = groupLayout instanceof StructLayout\n+                        ? \",\"  \/\/ Struct separator\n+                        : \"|\"; \/\/ Union separator\n+\n+                action.accept(indentedLabel(state, groupLayout) + \" {\");\n+                state.incrementIndent();\n+                final var members = groupLayout.memberLayouts();\n+                final long initialIndex = state.index();\n+                long maxIndex = initialIndex;\n+                for (int i = 0; i < members.size(); i++) {\n+                    if (groupLayout instanceof UnionLayout) {\n+                        \/\/ If it is a union, we need to reset the index for each member\n+                        state.index(initialIndex);\n+                        \/\/ We record the max index used for any union member so that we can leave off from there\n+                        maxIndex = Math.max(maxIndex, state.index());\n+                    }\n+                    toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n+                    if (groupLayout instanceof UnionLayout) {\n+                        \/\/ This is the best we can do.\n+                        state.index(maxIndex);\n+                    }\n+                }\n+                state.decrementIndent();\n+                action.accept(state.indentSpaces() + \"}\" + suffix);\n+            }\n+            case SequenceLayout sequenceLayout -> {\n+                action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n+                state.incrementIndent();\n+                final long elementCount = sequenceLayout.elementCount();\n+                for (long i = 0; i < elementCount; i++) {\n+                    toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+                }\n+                state.decrementIndent();\n+                action.accept(state.indentSpaces() + \"]\" + suffix);\n+            }\n+        }\n+    }\n+\n+    static String renderValueLayout(ViewState state,\n+                                    ValueLayout layout,\n+                                    String value,\n+                                    String suffix) {\n+        return indentedLabel(state, layout) + \"=\" + value + suffix;\n+    }\n+\n+    static String indentedLabel(ViewState state,\n+                                MemoryLayout layout) {\n+        return state.indentSpaces() + layout.name()\n+                .orElseGet(layout::toString);\n+    }\n+\n+    static final class ViewState {\n+\n+        private static final int SPACES_PER_INDENT = 4;\n+\n+        \/\/ Holding a non-static indents allows simple thread-safe use\n+        private final StringBuilder indents = new StringBuilder();\n+\n+        private int indent;\n+        private long index;\n+\n+        void incrementIndent() {\n+            indent++;\n+        }\n+\n+        void decrementIndent() {\n+            indent--;\n+        }\n+\n+        String indentSpaces() {\n+            final int spaces = indent * SPACES_PER_INDENT;\n+            while (indents.length() < spaces) {\n+                \/\/ Expand as needed\n+                indents.append(\" \");\n+            }\n+            return indents.substring(0, spaces);\n+        }\n+\n+        long index() {\n+            return index;\n+        }\n+\n+        void index(long index) {\n+            this.index = index;\n+        }\n+\n+        long indexAndAdd(long delta) {\n+            final long val = index;\n+            index += delta;\n+            return val;\n+        }\n+\n+        long indexAndAdd(MemoryLayout layout) {\n+            return indexAndAdd(layout.byteSize());\n+        }\n+    }\n+\n+    private static final class StandardValueLayoutRenderer implements BiFunction<ValueLayout, Object, String> {\n+\n+        @Override\n+        public String apply(ValueLayout layout, Object o) {\n+            requireNonNull(layout);\n+            requireNonNull(o);\n+\n+            return switch (layout) {\n+                case ValueLayout.OfBoolean __ when o instanceof Boolean b -> Boolean.toString(b);\n+                case ValueLayout.OfByte __ when o instanceof Byte b -> Byte.toString(b);\n+                case ValueLayout.OfShort __ when o instanceof Short s -> Short.toString(s);\n+                case ValueLayout.OfChar __ when o instanceof Character c -> Character.toString(c);\n+                case ValueLayout.OfInt __ when o instanceof Integer i -> Integer.toString(i);\n+                case ValueLayout.OfLong __ when o instanceof Long l -> Long.toString(l);\n+                case ValueLayout.OfFloat __ when o instanceof Float f -> Float.toString(f);\n+                case ValueLayout.OfDouble __ when o instanceof Double d -> Double.toString(d);\n+                case AddressLayout __ when o instanceof MemorySegment m ->\n+                        String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", m.address());\n+                default ->\n+                        throw new UnsupportedOperationException(\"layout \" + layout + \" for \" + o.getClass().getName() + \" not supported\");\n+            };\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return singletonToString(StandardValueLayoutRenderer.class);\n+        }\n+    }\n+\n+    private static String singletonToString(Class<?> implementingClass) {\n+        return \"The \" + implementingClass.getName() + \" singleton\";\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -36,0 +36,2 @@\n+\n+import jdk.internal.foreign.GlobalSession.HeapSession;\n@@ -62,2 +64,0 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSession(null);\n-\n@@ -66,0 +66,2 @@\n+    \/\/ This is the session of all zero-length memory segments\n+    static final GlobalSession NATIVE_SESSION = new GlobalSession();\n@@ -80,11 +82,1 @@\n-        return new Arena() {\n-            @Override\n-            public Scope scope() {\n-                return MemorySessionImpl.this;\n-            }\n-\n-            @Override\n-            public void close() {\n-                MemorySessionImpl.this.close();\n-            }\n-        };\n+        return new ArenaImpl(this);\n@@ -94,1 +86,1 @@\n-    public static final MemorySessionImpl toMemorySession(Arena arena) {\n+    public static MemorySessionImpl toMemorySession(Arena arena) {\n@@ -110,1 +102,1 @@\n-     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n+     * Add a cleanup action. If a failure occurred (because of an add vs. close race), call the cleanup action.\n@@ -113,1 +105,1 @@\n-     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n+     * clean up memory. From the perspective of the client, such a failure would manifest as a factory\n@@ -156,3 +148,6 @@\n-    public MemorySegment allocate(long byteSize, long byteAlignment) {\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, this);\n+    public static MemorySessionImpl createGlobal() {\n+        return new GlobalSession();\n+    }\n+\n+    public static MemorySessionImpl createHeap(Object ref) {\n+        return new HeapSession(ref);\n@@ -213,1 +208,1 @@\n-     * a confined session and this method is called outside of the owner thread.\n+     * a confined session and this method is called outside the owner thread.\n@@ -223,1 +218,1 @@\n-    public static final void checkValidState(MemorySegment segment) {\n+    public static void checkValidState(MemorySegment segment) {\n@@ -239,1 +234,1 @@\n-     * a confined session and this method is called outside of the owner thread.\n+     * a confined session and this method is called outside the owner thread.\n@@ -248,4 +243,0 @@\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSession(ref);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -49,1 +48,0 @@\n-    private static final boolean SKIP_ZERO_MEMORY = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.skipZeroMemory\");\n@@ -70,1 +68,1 @@\n-        super(0L, false, new GlobalSession(null));\n+        super(0L, false, MemorySessionImpl.NATIVE_SESSION);\n@@ -92,2 +90,1 @@\n-        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null, this);\n@@ -118,1 +115,2 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl) {\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl,\n+                                                  boolean shouldReserve) {\n@@ -127,5 +125,2 @@\n-        NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n-\n-        long buf = UNSAFE.allocateMemory(alignedSize);\n-        if (!SKIP_ZERO_MEMORY) {\n-            UNSAFE.setMemory(buf, alignedSize, (byte)0);\n+        if (shouldReserve) {\n+            NIO_ACCESS.reserveMemory(alignedSize, byteSize);\n@@ -133,0 +128,2 @@\n+\n+        long buf = allocateMemoryWrapper(alignedSize);\n@@ -140,1 +137,3 @@\n-                NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                if (shouldReserve) {\n+                    NIO_ACCESS.unreserveMemory(alignedSize, byteSize);\n+                }\n@@ -150,0 +149,8 @@\n+    private static long allocateMemoryWrapper(long size) {\n+        try {\n+            return UNSAFE.allocateMemory(size);\n+        } catch (IllegalArgumentException ex) {\n+            throw new OutOfMemoryError();\n+        }\n+    }\n+\n@@ -171,1 +178,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.NATIVE_SESSION);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.ref.Cleaner;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    private final long maxAlign;\n@@ -40,1 +39,0 @@\n-        this.maxAlign = ((AbstractMemorySegmentImpl)segment).maxAlignMask();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.util.ArraysSupport;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.charset.Charset;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+\/**\n+ * Miscellaneous functions to read and write strings, in various charsets.\n+ *\/\n+public final class StringSupport {\n+\n+    static final JavaLangAccess JAVA_LANG_ACCESS = SharedSecrets.getJavaLangAccess();\n+\n+    private StringSupport() {}\n+\n+    public static String read(MemorySegment segment, long offset, Charset charset) {\n+        return switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> readByte(segment, offset, charset);\n+            case DOUBLE_BYTE -> readShort(segment, offset, charset);\n+            case QUAD_BYTE -> readInt(segment, offset, charset);\n+        };\n+    }\n+\n+    public static void write(MemorySegment segment, long offset, Charset charset, String string) {\n+        switch (CharsetKind.of(charset)) {\n+            case SINGLE_BYTE -> writeByte(segment, offset, charset, string);\n+            case DOUBLE_BYTE -> writeShort(segment, offset, charset, string);\n+            case QUAD_BYTE -> writeInt(segment, offset, charset, string);\n+        }\n+    }\n+\n+    private static String readByte(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenByte(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeByte(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_BYTE, offset + bytes, (byte)0);\n+    }\n+\n+    private static String readShort(MemorySegment segment, long offset, Charset charset) {\n+        long len = chunkedStrlenShort(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeShort(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_SHORT, offset + bytes, (short)0);\n+    }\n+\n+    private static String readInt(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlenInt(segment, offset);\n+        byte[] bytes = new byte[(int)len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int)len);\n+        return new String(bytes, charset);\n+    }\n+\n+    private static void writeInt(MemorySegment segment, long offset, Charset charset, String string) {\n+        int bytes = copyBytes(string, segment, charset, offset);\n+        segment.set(JAVA_INT, offset + bytes, 0);\n+    }\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero byte in the provided {@code segment}}\n+     * <p>\n+     * The method divides the region of interest into three distinct regions:\n+     * <ul>\n+     *     <li>head (access made on a byte-by-byte basis) (if any)<\/li>\n+     *     <li>body (access made with eight bytes at a time at physically 64-bit-aligned memory) (if any)<\/li>\n+     *     <li>tail (access made on a byte-by-byte basis) (if any)<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The body is using a heuristic method to determine if a long word\n+     * contains a zero byte. The method might have false positives but\n+     * never false negatives.\n+     * <p>\n+     * This method is inspired by the `glibc\/string\/strlen.c` implementation\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero bytes\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenByte(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroByte(curr)) {\n+                for (int j = 0; j < 8; j++) {\n+                    if (segment.get(JAVA_BYTE, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenByte(segment, start + offset));\n+    }\n+\n+    \/* Bits 63 and N * 8 (N = 1..7) of this number are zero.  Call these bits\n+       the \"holes\".  Note that there is a hole just to the left of\n+       each byte, with an extra at the end:\n+\n+       bits:  01111110 11111110 11111110 11111110 11111110 11111110 11111110 11111111\n+       bytes: AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD EEEEEEEE FFFFFFFF GGGGGGGG HHHHHHHH\n+\n+       The 1-bits make sure that carries propagate to the next 0-bit.\n+       The 0-bits provide holes for carries to fall into.\n+    *\/\n+    private static final long HIMAGIC_FOR_BYTES = 0x8080_8080_8080_8080L;\n+    private static final long LOMAGIC_FOR_BYTES = 0x0101_0101_0101_0101L;\n+\n+    static boolean mightContainZeroByte(long l) {\n+        return ((l - LOMAGIC_FOR_BYTES) & (~l) & HIMAGIC_FOR_BYTES) != 0;\n+    }\n+\n+    private static final long HIMAGIC_FOR_SHORTS = 0x8000_8000_8000_8000L;\n+    private static final long LOMAGIC_FOR_SHORTS = 0x0001_0001_0001_0001L;\n+\n+    static boolean mightContainZeroShort(long l) {\n+        return ((l - LOMAGIC_FOR_SHORTS) & (~l) & HIMAGIC_FOR_SHORTS) != 0;\n+    }\n+\n+    static int requireWithinArraySize(long size) {\n+        if (size > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n+        }\n+        return (int) size;\n+    }\n+\n+    static int bodyCount(long remaining) {\n+        return (int) Math.min(\n+                \/\/ Make sure we do not wrap around\n+                Integer.MAX_VALUE - Long.BYTES,\n+                \/\/ Remaining bytes to consider\n+                remaining)\n+                & -Long.BYTES; \/\/ Mask 0xFFFFFFF8\n+    }\n+\n+    private static int strlenByte(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += 1) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/**\n+     * {@return the shortest distance beginning at the provided {@code start}\n+     *  to the encountering of a zero short in the provided {@code segment}}\n+     * <p>\n+     * Note: The inspected region must be short aligned.\n+     *\n+     * @see #chunkedStrlenByte(MemorySegment, long) for more information\n+     *\n+     * @param segment to examine\n+     * @param start   from where examination shall begin\n+     * @throws IllegalArgumentException if the examined region contains no zero shorts\n+     *                                  within a length that can be accepted by a String\n+     *\/\n+    public static int chunkedStrlenShort(MemorySegment segment, long start) {\n+\n+        \/\/ Handle the first unaligned \"head\" bytes separately\n+        int headCount = (int)SharedUtils.remainsToAlignment(segment.address() + start, Long.BYTES);\n+\n+        int offset = 0;\n+        for (; offset < headCount; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+\n+        \/\/ We are now on a long-aligned boundary so this is the \"body\"\n+        int bodyCount = bodyCount(segment.byteSize() - start - headCount);\n+\n+        for (; offset < bodyCount; offset += Long.BYTES) {\n+            \/\/ We know we are `long` aligned so, we can save on alignment checking here\n+            long curr = segment.get(JAVA_LONG_UNALIGNED, start + offset);\n+            \/\/ Is this a candidate?\n+            if (mightContainZeroShort(curr)) {\n+                for (int j = 0; j < Long.BYTES; j += Short.BYTES) {\n+                    if (segment.get(JAVA_SHORT_UNALIGNED, start + offset + j) == 0) {\n+                        return offset + j;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Handle the \"tail\"\n+        return requireWithinArraySize((long) offset + strlenShort(segment, start + offset));\n+    }\n+\n+    private static int strlenShort(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Short.BYTES) {\n+            short curr = segment.get(JAVA_SHORT_UNALIGNED, start + offset);\n+            if (curr == (short)0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    \/\/ The gain of using `long` wide operations for `int` is lower than for the two other `byte` and `short` variants\n+    \/\/ so, there is only one method for ints.\n+    public static int strlenInt(MemorySegment segment, long start) {\n+        for (int offset = 0; offset < ArraysSupport.SOFT_MAX_ARRAY_LENGTH; offset += Integer.BYTES) {\n+            \/\/ We are guaranteed to be aligned here so, we can use unaligned access.\n+            int curr = segment.get(JAVA_INT_UNALIGNED, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw newIaeStringTooLarge();\n+    }\n+\n+    public enum CharsetKind {\n+        SINGLE_BYTE(1),\n+        DOUBLE_BYTE(2),\n+        QUAD_BYTE(4);\n+\n+        final int terminatorCharSize;\n+\n+        CharsetKind(int terminatorCharSize) {\n+            this.terminatorCharSize = terminatorCharSize;\n+        }\n+\n+        public int terminatorCharSize() {\n+            return terminatorCharSize;\n+        }\n+\n+        public static CharsetKind of(Charset charset) {\n+            \/\/ Comparing the charset to specific internal implementations avoids loading the class `StandardCharsets`\n+            if        (charset == sun.nio.cs.UTF_8.INSTANCE ||\n+                       charset == sun.nio.cs.ISO_8859_1.INSTANCE ||\n+                       charset == sun.nio.cs.US_ASCII.INSTANCE) {\n+                return SINGLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_16LE ||\n+                       charset instanceof sun.nio.cs.UTF_16BE ||\n+                       charset instanceof sun.nio.cs.UTF_16) {\n+                return DOUBLE_BYTE;\n+            } else if (charset instanceof sun.nio.cs.UTF_32LE ||\n+                       charset instanceof sun.nio.cs.UTF_32BE ||\n+                       charset instanceof sun.nio.cs.UTF_32) {\n+                return QUAD_BYTE;\n+            } else {\n+                throw new UnsupportedOperationException(\"Unsupported charset: \" + charset);\n+            }\n+        }\n+    }\n+\n+    public static boolean bytesCompatible(String string, Charset charset) {\n+        return JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n+    }\n+\n+    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset) {\n+        if (bytesCompatible(string, charset)) {\n+            copyToSegmentRaw(string, segment, offset);\n+            return string.length();\n+        } else {\n+            byte[] bytes = string.getBytes(charset);\n+            MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+            return bytes.length;\n+        }\n+    }\n+\n+    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n+    }\n+\n+    private static IllegalArgumentException newIaeStringTooLarge() {\n+        return new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -78,1 +78,1 @@\n-        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<String>() {\n+        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<>() {\n@@ -89,1 +89,1 @@\n-        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<>() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentAllocator;\n@@ -47,0 +46,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -50,1 +50,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -101,0 +100,11 @@\n+\n+            static VarHandle get(ValueLayout layout) {\n+                return HANDLE_MAP.get(layout);\n+            }\n+        }\n+        layout = layout.withoutName(); \/\/ name doesn't matter\n+        \/\/ keep the addressee layout as it's used below\n+\n+        VarHandle handle = VarHandleCache.get(layout);\n+        if (handle != null) {\n+            return handle;\n@@ -102,0 +112,1 @@\n+\n@@ -113,1 +124,1 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n+        handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n@@ -139,1 +150,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n@@ -147,1 +158,1 @@\n-            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + toHexString(addr));\n@@ -152,12 +163,0 @@\n-    public static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n-    }\n-\n-    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n-\n@@ -281,0 +280,32 @@\n+    public record BaseAndScale(int base, long scale) {\n+\n+        public static final BaseAndScale BYTE =\n+                new BaseAndScale(Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);\n+        public static final BaseAndScale CHAR =\n+                new BaseAndScale(Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+        public static final BaseAndScale SHORT =\n+                new BaseAndScale(Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+        public static final BaseAndScale INT =\n+                new BaseAndScale(Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);\n+        public static final BaseAndScale FLOAT =\n+                new BaseAndScale(Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);\n+        public static final BaseAndScale LONG =\n+                new BaseAndScale(Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE);\n+        public static final BaseAndScale DOUBLE =\n+                new BaseAndScale(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);\n+\n+        public static BaseAndScale of(Object array) {\n+            return switch (array) {\n+                case byte[]   __ -> BaseAndScale.BYTE;\n+                case char[]   __ -> BaseAndScale.CHAR;\n+                case short[]  __ -> BaseAndScale.SHORT;\n+                case int[]    __ -> BaseAndScale.INT;\n+                case float[]  __ -> BaseAndScale.FLOAT;\n+                case long[]   __ -> BaseAndScale.LONG;\n+                case double[] __ -> BaseAndScale.DOUBLE;\n+                default -> throw new IllegalArgumentException(\"Not a supported array class: \" + array.getClass().getSimpleName());\n+            };\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":48,"deletions":17,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.util.HashSet;\n@@ -76,0 +77,1 @@\n+    private final Set<MemoryLayout> CANONICAL_LAYOUTS_CACHE = new HashSet<>(canonicalLayouts().values());\n@@ -92,1 +94,1 @@\n-    private final MethodHandle downcallHandle0(FunctionDescriptor function, Option... options) {\n+    private MethodHandle downcallHandle0(FunctionDescriptor function, Option... options) {\n@@ -216,1 +218,1 @@\n-    private static void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+    private void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n@@ -226,1 +228,1 @@\n-    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+    private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n@@ -235,1 +237,1 @@\n-    private static void checkSupported(ValueLayout valueLayout) {\n+    private void checkSupported(ValueLayout valueLayout) {\n@@ -240,1 +242,1 @@\n-        if (!SUPPORTED_LAYOUTS.contains(valueLayout.withoutName())) {\n+        if (!CANONICAL_LAYOUTS_CACHE.contains(valueLayout.withoutName())) {\n@@ -245,1 +247,1 @@\n-    private static void checkHasNaturalAlignment(MemoryLayout layout) {\n+    private void checkHasNaturalAlignment(MemoryLayout layout) {\n@@ -276,12 +278,0 @@\n-\n-    private static final Set<MemoryLayout> SUPPORTED_LAYOUTS = Set.of(\n-            ValueLayout.JAVA_BOOLEAN,\n-            ValueLayout.JAVA_BYTE,\n-            ValueLayout.JAVA_CHAR,\n-            ValueLayout.JAVA_SHORT,\n-            ValueLayout.JAVA_INT,\n-            ValueLayout.JAVA_FLOAT,\n-            ValueLayout.JAVA_LONG,\n-            ValueLayout.JAVA_DOUBLE,\n-            ValueLayout.ADDRESS\n-    );\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.nio.ByteOrder;\n@@ -60,1 +59,1 @@\n- * ABI-specific). Note that each argument has it's own recipe, which is indicated by '[number]:' (though, the only\n+ * ABI-specific). Note that each argument has its own recipe, which is indicated by '[number]:' (though, the only\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    interface StoreFunc {\n+    public interface StoreFunc {\n@@ -57,1 +57,1 @@\n-    interface LoadFunc {\n+    public interface LoadFunc {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        return !linkerOptions.isTrivial();\n+        return !linkerOptions.isCritical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,5 @@\n-        return new LinkerOptions(optionMap);\n+        LinkerOptions linkerOptions = new LinkerOptions(optionMap);\n+        if (linkerOptions.hasCapturedCallState() && linkerOptions.isCritical()) {\n+            throw new IllegalArgumentException(\"Incompatible linker options: captureCallState, critical\");\n+        }\n+        return linkerOptions;\n@@ -100,3 +104,3 @@\n-    public boolean isTrivial() {\n-        IsTrivial it = getOption(IsTrivial.class);\n-        return it != null;\n+    public boolean isCritical() {\n+        Critical c = getOption(Critical.class);\n+        return c != null;\n@@ -118,1 +122,1 @@\n-            permits CaptureCallState, FirstVariadicArg, IsTrivial {\n+            permits CaptureCallState, FirstVariadicArg, Critical {\n@@ -144,2 +148,2 @@\n-    public record IsTrivial() implements LinkerOptionImpl {\n-        public static IsTrivial INSTANCE = new IsTrivial();\n+    public record Critical() implements LinkerOptionImpl {\n+        public static Critical INSTANCE = new Critical();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -60,1 +59,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -86,1 +84,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n@@ -95,1 +93,1 @@\n-        public MemorySegment allocate(long byteSize) {\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n@@ -132,0 +130,4 @@\n+    public static long remainsToAlignment(long addr, long alignment) {\n+        return alignUp(addr, alignment) - addr;\n+    }\n+\n@@ -179,1 +181,1 @@\n-            \/\/ adjust return type so it matches the inferred type of the effective\n+            \/\/ adjust return type so that it matches the inferred type of the effective\n@@ -254,18 +256,0 @@\n-    public static String toJavaStringInternal(MemorySegment segment, long start) {\n-        int len = strlen(segment, start);\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n-        return new String(bytes, StandardCharsets.UTF_8);\n-    }\n-\n-    private static int strlen(MemorySegment segment, long start) {\n-        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n-            if (curr == 0) {\n-                return offset;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"String too large\");\n-    }\n-\n@@ -437,14 +421,0 @@\n-    public static final class SimpleVaArg {\n-        public final MemoryLayout layout;\n-        public final Object value;\n-\n-        public SimpleVaArg(MemoryLayout layout, Object value) {\n-            this.layout = layout;\n-            this.value = value;\n-        }\n-\n-        public VarHandle varHandle() {\n-            return layout.varHandle();\n-        }\n-    }\n-\n@@ -518,0 +488,31 @@\n+\n+    public static Map<String, MemoryLayout> canonicalLayouts(ValueLayout longLayout, ValueLayout sizetLayout, ValueLayout wchartLayout) {\n+        return Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int\", ValueLayout.JAVA_INT),\n+                Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"long\", longLayout),\n+                Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+                Map.entry(\"void*\", ValueLayout.ADDRESS),\n+                Map.entry(\"size_t\", sizetLayout),\n+                Map.entry(\"wchar_t\", wchartLayout),\n+                \/\/ unspecified size-dependent layouts\n+                Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n+                Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n+                \/\/ unspecified JNI layouts\n+                Map.entry(\"jboolean\", ValueLayout.JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", ValueLayout.JAVA_CHAR),\n+                Map.entry(\"jbyte\", ValueLayout.JAVA_BYTE),\n+                Map.entry(\"jshort\", ValueLayout.JAVA_SHORT),\n+                Map.entry(\"jint\", ValueLayout.JAVA_INT),\n+                Map.entry(\"jlong\", ValueLayout.JAVA_LONG),\n+                Map.entry(\"jfloat\", ValueLayout.JAVA_FLOAT),\n+                Map.entry(\"jdouble\", ValueLayout.JAVA_DOUBLE)\n+        );\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":38,"deletions":37,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -39,1 +40,1 @@\n-            throw new IllegalStateException(\"Not a stub address: \" + stubAddress);\n+            throw new IllegalStateException(\"Not a stub address: \" + Utils.toHexString(stubAddress));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -249,2 +248,2 @@\n-        MacOs, non-VA   | FW in regs       | FW on the stack                 | FW on the stack\n-        MacOs, VA       | FW in regs       | CW on the stack                 | CW on the stack\n+        macOS, non-VA   | FW in regs       | FW on the stack                 | FW on the stack\n+        macOS, VA       | FW in regs       | CW on the stack                 | CW on the stack\n@@ -260,1 +259,1 @@\n-        MacOs           | CW in regs       | CW on the stack                 | CW on the stack\n+        macOS           | CW in regs       | CW on the stack                 | CW on the stack\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -38,1 +42,1 @@\n- * ABI implementation for macOS on Apple silicon. Based on AAPCS with\n+ * ABI implementation for macOS on Apple Silicon. Based on AAPCS with\n@@ -43,0 +47,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -69,0 +76,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    \/\/ r2-7 and v4-7 so they are omitted here.\n+    \/\/ r2-7 and v4-7 so, they are omitted here.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -34,0 +35,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -37,0 +40,1 @@\n+import java.util.Map;\n@@ -43,0 +47,3 @@\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.Comparator;\n@@ -47,0 +46,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -61,5 +61,1 @@\n-    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.byteSize()) {\n-            case 8 -> JAVA_LONG;\n-            case 4 -> JAVA_INT;\n-            default -> throw new IllegalStateException(\"Address size not supported: \" + ADDRESS.byteSize());\n-        };\n+    static final ValueLayout SIZE_T = layoutFor((int)ADDRESS.byteSize());\n@@ -72,1 +68,1 @@\n-    private static final VarHandle VH_SIZE_T_ARRAY = SIZE_T.arrayElementVarHandle();\n+    private static final VarHandle VH_SIZE_T = SIZE_T.varHandle();\n@@ -86,2 +82,2 @@\n-        VH_TYPE.set(ffiType, LibFallback.structTag());\n-        VH_ELEMENTS.set(ffiType, elementsSeg);\n+        VH_TYPE.set(ffiType, 0L, LibFallback.structTag());\n+        VH_ELEMENTS.set(ffiType, 0L, elementsSeg);\n@@ -135,1 +131,1 @@\n-                    long ffiOffset = (long) VH_SIZE_T_ARRAY.get(offsetsOut, offsetIdx++);\n+                    long ffiOffset = sizeTAtIndex(offsetsOut, offsetIdx++);\n@@ -146,0 +142,19 @@\n+\n+    static ValueLayout layoutFor(int byteSize) {\n+        return switch (byteSize) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new IllegalStateException(\"Unsupported size: \" + byteSize);\n+        };\n+    }\n+\n+    private static long sizeTAtIndex(MemorySegment segment, int index) {\n+        long offset = SIZE_T.scale(0, index);\n+        if (VH_SIZE_T.varType() == long.class) {\n+            return (long) VH_SIZE_T.get(segment, offset);\n+        } else {\n+            return (int) VH_SIZE_T.get(segment, offset); \/\/ 'erase' to long\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.HashMap;\n@@ -49,0 +50,1 @@\n+import java.util.Map;\n@@ -52,0 +54,8 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n+import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n+import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -234,24 +244,19 @@\n-        if (layout instanceof ValueLayout.OfBoolean bl) {\n-            argSeg.set(bl, 0, (Boolean) arg);\n-        } else if (layout instanceof ValueLayout.OfByte bl) {\n-            argSeg.set(bl, 0, (Byte) arg);\n-        } else if (layout instanceof ValueLayout.OfShort sl) {\n-            argSeg.set(sl, 0, (Short) arg);\n-        } else if (layout instanceof ValueLayout.OfChar cl) {\n-            argSeg.set(cl, 0, (Character) arg);\n-        } else if (layout instanceof ValueLayout.OfInt il) {\n-            argSeg.set(il, 0, (Integer) arg);\n-        } else if (layout instanceof ValueLayout.OfLong ll) {\n-            argSeg.set(ll, 0, (Long) arg);\n-        } else if (layout instanceof ValueLayout.OfFloat fl) {\n-            argSeg.set(fl, 0, (Float) arg);\n-        } else if (layout instanceof ValueLayout.OfDouble dl) {\n-            argSeg.set(dl, 0, (Double) arg);\n-        } else if (layout instanceof AddressLayout al) {\n-            MemorySegment addrArg = (MemorySegment) arg;\n-            acquireCallback.accept(addrArg);\n-            argSeg.set(al, 0, addrArg);\n-        } else if (layout instanceof GroupLayout) {\n-            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n-        } else {\n-            assert layout == null;\n+        switch (layout) {\n+            case ValueLayout.OfBoolean bl -> argSeg.set(bl, 0, (Boolean) arg);\n+            case ValueLayout.OfByte    bl -> argSeg.set(bl, 0, (Byte) arg);\n+            case ValueLayout.OfShort   sl -> argSeg.set(sl, 0, (Short) arg);\n+            case ValueLayout.OfChar    cl -> argSeg.set(cl, 0, (Character) arg);\n+            case ValueLayout.OfInt     il -> argSeg.set(il, 0, (Integer) arg);\n+            case ValueLayout.OfLong    ll -> argSeg.set(ll, 0, (Long) arg);\n+            case ValueLayout.OfFloat   fl -> argSeg.set(fl, 0, (Float) arg);\n+            case ValueLayout.OfDouble  dl -> argSeg.set(dl, 0, (Double) arg);\n+            case AddressLayout         al -> {\n+                MemorySegment addrArg = (MemorySegment) arg;\n+                acquireCallback.accept(addrArg);\n+                argSeg.set(al, 0, addrArg);\n+            }\n+            case GroupLayout           __ ->\n+                    MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n+            case null, default -> {\n+                assert layout == null;\n+            }\n@@ -286,0 +291,37 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n+\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS = new HashMap<>();\n+\n+    static {\n+        CANONICAL_LAYOUTS.put(\"bool\", JAVA_BOOLEAN);\n+        CANONICAL_LAYOUTS.put(\"char\", JAVA_BYTE);\n+        CANONICAL_LAYOUTS.put(\"float\", JAVA_FLOAT);\n+        CANONICAL_LAYOUTS.put(\"double\", JAVA_DOUBLE);\n+        CANONICAL_LAYOUTS.put(\"long long\", JAVA_LONG);\n+        CANONICAL_LAYOUTS.put(\"void*\", ADDRESS);\n+        \/\/ platform-dependent sizes\n+        CANONICAL_LAYOUTS.put(\"size_t\", FFIType.SIZE_T);\n+        CANONICAL_LAYOUTS.put(\"short\", FFIType.layoutFor(LibFallback.shortSize()));\n+        CANONICAL_LAYOUTS.put(\"int\", FFIType.layoutFor(LibFallback.intSize()));\n+        CANONICAL_LAYOUTS.put(\"long\", FFIType.layoutFor(LibFallback.longSize()));\n+        int wchar_size = LibFallback.wcharSize();\n+        if (wchar_size == 2) {\n+            \/\/ prefer JAVA_CHAR\n+            CANONICAL_LAYOUTS.put(\"wchar_t\", JAVA_CHAR);\n+        } else {\n+            CANONICAL_LAYOUTS.put(\"wchar_t\", FFIType.layoutFor(wchar_size));\n+        }\n+        \/\/ JNI types\n+        CANONICAL_LAYOUTS.put(\"jboolean\", JAVA_BOOLEAN);\n+        CANONICAL_LAYOUTS.put(\"jchar\", JAVA_CHAR);\n+        CANONICAL_LAYOUTS.put(\"jbyte\", JAVA_BYTE);\n+        CANONICAL_LAYOUTS.put(\"jshort\", JAVA_SHORT);\n+        CANONICAL_LAYOUTS.put(\"jint\", JAVA_INT);\n+        CANONICAL_LAYOUTS.put(\"jlong\", JAVA_LONG);\n+        CANONICAL_LAYOUTS.put(\"jfloat\", JAVA_FLOAT);\n+        CANONICAL_LAYOUTS.put(\"jdouble\", JAVA_DOUBLE);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":66,"deletions":24,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -68,0 +68,6 @@\n+    \/\/ platform-dependent types\n+    static int shortSize() { return NativeConstants.SIZEOF_SHORT; }\n+    static int intSize() { return NativeConstants.SIZEOF_INT; }\n+    static int longSize() {return NativeConstants.SIZEOF_LONG; }\n+    static int wcharSize() {return NativeConstants.SIZEOF_WCHAR; }\n+\n@@ -225,0 +231,4 @@\n+    private static native int ffi_sizeof_short();\n+    private static native int ffi_sizeof_int();\n+    private static native int ffi_sizeof_long();\n+    private static native int ffi_sizeof_wchar();\n@@ -242,0 +252,5 @@\n+        static final int SIZEOF_SHORT = ffi_sizeof_short();\n+        static final int SIZEOF_INT = ffi_sizeof_int();\n+        static final int SIZEOF_LONG = ffi_sizeof_long();\n+        static final int SIZEOF_WCHAR = ffi_sizeof_wchar();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+        SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,0 +34,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -36,0 +39,1 @@\n+import java.util.Map;\n@@ -39,0 +43,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -65,0 +72,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.abi.riscv64.linux.TypeClass;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/RISCV64Architecture.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -48,1 +47,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -153,1 +151,1 @@\n-        \/\/ Aggregates or scalars passed on the stack are aligned to the greater of\n+        \/\/ Aggregates or scalars passed on the stack are aligned to the greatest of\n@@ -256,2 +254,2 @@\n-    static class UnboxBindingCalculator extends BindingCalculator {\n-        boolean forArguments;\n+    static final class UnboxBindingCalculator extends BindingCalculator {\n+        final boolean forArguments;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -35,0 +36,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    private static record FieldCounter(long integerCnt, long floatCnt, long pointerCnt) {\n+    private record FieldCounter(long integerCnt, long floatCnt, long pointerCnt) {\n@@ -131,3 +131,1 @@\n-    public static record FlattenedFieldDesc(TypeClass typeClass, long offset, ValueLayout layout) {\n-\n-    }\n+    public record FlattenedFieldDesc(TypeClass typeClass, long offset, ValueLayout layout) { }\n@@ -136,10 +134,16 @@\n-        if (layout instanceof ValueLayout valueLayout) {\n-            TypeClass typeClass = classifyValueType(valueLayout);\n-            return List.of(switch (typeClass) {\n-                case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n-                default -> throw new IllegalStateException(\"Should not reach here.\");\n-            });\n-        } else if (layout instanceof GroupLayout groupLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n-                if (memberLayout instanceof PaddingLayout) {\n+        return switch (layout) {\n+            case ValueLayout valueLayout -> {\n+                TypeClass typeClass = classifyValueType(valueLayout);\n+                yield List.of(switch (typeClass) {\n+                    case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n+                    default -> throw new IllegalStateException(\"Should not reach here.\");\n+                });\n+            }\n+            case GroupLayout groupLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                    if (memberLayout instanceof PaddingLayout) {\n+                        offset += memberLayout.byteSize();\n+                        continue;\n+                    }\n+                    fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n@@ -147,1 +151,0 @@\n-                    continue;\n@@ -149,2 +152,1 @@\n-                fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n-                offset += memberLayout.byteSize();\n+                yield fields;\n@@ -152,7 +154,8 @@\n-            return fields;\n-        } else if (layout instanceof SequenceLayout sequenceLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            MemoryLayout elementLayout = sequenceLayout.elementLayout();\n-            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n-                fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n-                offset += elementLayout.byteSize();\n+            case SequenceLayout sequenceLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                MemoryLayout elementLayout = sequenceLayout.elementLayout();\n+                for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                    fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n+                    offset += elementLayout.byteSize();\n+                }\n+                yield fields;\n@@ -160,4 +163,2 @@\n-            return fields;\n-        } else {\n-            throw new IllegalStateException(\"Cannot get here: \" + layout);\n-        }\n+            case null, default -> throw new IllegalStateException(\"Cannot get here: \" + layout);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -49,1 +47,0 @@\n-import java.util.Map;\n@@ -52,1 +49,0 @@\n-import static jdk.internal.foreign.abi.s390.linux.TypeClass.*;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390CallArranger.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -38,0 +42,3 @@\n+    private static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -64,0 +71,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,4 +99,1 @@\n-        if (baseArgClass != FLOAT)\n-            return false;\n-\n-        return true;\n+        return baseArgClass == FLOAT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/TypeClass.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -211,1 +210,1 @@\n-            \/\/ok, let's pass pass on registers\n+            \/\/ok, let's pass on registers\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -32,0 +33,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -35,0 +38,1 @@\n+import java.util.Map;\n@@ -41,0 +45,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG, ValueLayout.JAVA_INT);\n+\n@@ -67,0 +74,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+        @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \/\/ rawtypes warnings need to be suppressed\n@@ -211,6 +211,10 @@\n-    private static void groupByEightBytes(MemoryLayout l, long offset, List<ArgumentClassImpl>[] groups) {\n-        if (l instanceof GroupLayout group) {\n-            for (MemoryLayout m : group.memberLayouts()) {\n-                groupByEightBytes(m, offset, groups);\n-                if (group instanceof StructLayout) {\n-                    offset += m.byteSize();\n+    private static void groupByEightBytes(MemoryLayout layout,\n+                                          long offset,\n+                                          List<ArgumentClassImpl>[] groups) {\n+        switch (layout) {\n+            case GroupLayout group -> {\n+                for (MemoryLayout m : group.memberLayouts()) {\n+                    groupByEightBytes(m, offset, groups);\n+                    if (group instanceof StructLayout) {\n+                        offset += m.byteSize();\n+                    }\n@@ -219,7 +223,1 @@\n-        } else if (l instanceof PaddingLayout) {\n-            return;\n-        } else if (l instanceof SequenceLayout seq) {\n-            MemoryLayout elem = seq.elementLayout();\n-            for (long i = 0 ; i < seq.elementCount() ; i++) {\n-                groupByEightBytes(elem, offset, groups);\n-                offset += elem.byteSize();\n+            case PaddingLayout __ -> {\n@@ -227,5 +225,6 @@\n-        } else if (l instanceof ValueLayout vl) {\n-            List<ArgumentClassImpl> layouts = groups[(int)offset \/ 8];\n-            if (layouts == null) {\n-                layouts = new ArrayList<>();\n-                groups[(int)offset \/ 8] = layouts;\n+            case SequenceLayout seq -> {\n+                MemoryLayout elem = seq.elementLayout();\n+                for (long i = 0; i < seq.elementCount(); i++) {\n+                    groupByEightBytes(elem, offset, groups);\n+                    offset += elem.byteSize();\n+                }\n@@ -233,7 +232,13 @@\n-            \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n-            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n-                    argumentClassFor(vl) :\n-                    ArgumentClassImpl.MEMORY;\n-            layouts.add(argumentClass);\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + l);\n+            case ValueLayout vl -> {\n+                List<ArgumentClassImpl> layouts = groups[(int) offset \/ 8];\n+                if (layouts == null) {\n+                    layouts = new ArrayList<>();\n+                    groups[(int) offset \/ 8] = layouts;\n+                }\n+                \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n+                ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                        argumentClassFor(vl) :\n+                        ArgumentClassImpl.MEMORY;\n+                layouts.add(argumentClass);\n+            }\n+            case null, default -> throw new IllegalStateException(\"Unexpected layout: \" + layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallLinker;\n@@ -45,1 +44,0 @@\n-import java.lang.foreign.ValueLayout;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but they act just\n+        \/\/ No 128-bit integers in the Windows C ABI. There are __m128(i|d) intrinsic types but, they act just\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -31,0 +32,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -34,0 +37,1 @@\n+import java.util.Map;\n@@ -40,0 +44,3 @@\n+    static final Map<String, MemoryLayout> CANONICAL_LAYOUTS =\n+            SharedUtils.canonicalLayouts(ValueLayout.JAVA_INT, ValueLayout.JAVA_LONG, ValueLayout.JAVA_CHAR);\n+\n@@ -66,0 +73,5 @@\n+\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -57,1 +58,1 @@\n-        return dup(byteAlignment(), Optional.empty());\n+        return name.isPresent() ? dup(byteAlignment(), Optional.empty()) : (L) this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -36,0 +35,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -38,1 +38,0 @@\n-import java.lang.foreign.AddressLayout;\n@@ -42,2 +41,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -118,18 +115,0 @@\n-        public final VarHandle arrayElementVarHandle(int... shape) {\n-            Objects.requireNonNull(shape);\n-            if (!Utils.isElementAligned((ValueLayout) this)) {\n-                throw new UnsupportedOperationException(\"Layout alignment greater than its size\");\n-            }\n-            MemoryLayout layout = self();\n-            List<MemoryLayout.PathElement> path = new ArrayList<>();\n-            for (int i = shape.length; i > 0; i--) {\n-                int size = shape[i - 1];\n-                if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n-                layout = MemoryLayout.sequenceLayout(size, layout);\n-                path.add(MemoryLayout.PathElement.sequenceElement());\n-            }\n-            layout = MemoryLayout.sequenceLayout(layout);\n-            path.add(MemoryLayout.PathElement.sequenceElement());\n-            return layout.varHandle(path.toArray(new MemoryLayout.PathElement[0]));\n-        }\n-\n@@ -180,1 +159,1 @@\n-        public final VarHandle accessHandle() {\n+        public final VarHandle varHandle() {\n@@ -396,1 +375,1 @@\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n+     *     <li>{@link AddressLayout}, for {@code MemorySegment.class}<\/li>\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        \/\/ not used\n+        \/\/ not used, but required for interim javac to not warn.\n@@ -69,1 +69,0 @@\n-        @JEP(number=442, title=\"Foreign Function & Memory API\", status=\"Third Preview\")\n@@ -71,0 +70,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,0 +137,7 @@\n+    \/**\n+     * Adds native access to all unnamed modules.\n+     *\/\n+    public static void addEnableNativeAccessToAllUnnamed() {\n+        JLA.addEnableNativeAccessToAllUnnamed();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -118,1 +119,4 @@\n-        SharedSecrets.getJavaLangAccess().ensureNativeAccess(module, owner, methodName);\n+        class Holder {\n+            static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+        }\n+        Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private static final String ENABLE_NATIVE_ACCESS = \"Enable-Native-Access\";\n@@ -635,0 +636,7 @@\n+            String enableNativeAccess = mainAttrs.getValue(ENABLE_NATIVE_ACCESS);\n+            if (enableNativeAccess != null) {\n+                if (!enableNativeAccess.equals(\"ALL-UNNAMED\")) {\n+                    throw new IllegalArgumentException(\"Only ALL-UNNAMED allowed as value for \" + ENABLE_NATIVE_ACCESS);\n+                }\n+                Modules.addEnableNativeAccessToAllUnnamed();\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <wchar.h>\n@@ -209,0 +210,20 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1short(JNIEnv* env, jclass cls) {\n+  return sizeof(short);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1int(JNIEnv* env, jclass cls) {\n+  return sizeof(int);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1long(JNIEnv* env, jclass cls) {\n+  return sizeof(long);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1sizeof_1wchar(JNIEnv* env, jclass cls) {\n+  return sizeof(wchar_t);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * @compile --enable-preview -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n- * @run main\/othervm --enable-preview compiler.rangechecks.TestRangeCheckHoistingScaledIV\n+ * @compile -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n+ * @run main\/othervm compiler.rangechecks.TestRangeCheckHoistingScaledIV\n@@ -86,1 +86,1 @@\n-                \"--enable-preview\", \"--add-modules\", \"jdk.incubator.vector\",\n+                \"--add-modules\", \"jdk.incubator.vector\",\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -46,1 +46,1 @@\n-                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -51,1 +51,1 @@\n-                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -57,1 +57,1 @@\n-                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -62,1 +62,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\")\n@@ -69,1 +69,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -76,1 +76,1 @@\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\", \"--enable-preview\")\n+                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorErgonomics.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n- * @enablePreview\n@@ -51,1 +50,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512BW.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"--enable-preview\");\n+        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private static final Class<?> PREVIEW_API = java.lang.foreign.MemorySegment.class;\n+    private static final Class<?> PREVIEW_API = java.lang.ScopedValue.class;\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/CompositeLookupTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+    public static final Linker LINKER = Linker.nativeLinker();\n+\n@@ -94,1 +96,1 @@\n-    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) LINKER.canonicalLayouts().get(\"bool\");\n@@ -98,1 +100,1 @@\n-    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    public static final ValueLayout.OfByte C_CHAR = (ValueLayout.OfByte) LINKER.canonicalLayouts().get(\"char\");\n@@ -102,1 +104,1 @@\n-    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) LINKER.canonicalLayouts().get(\"short\");\n@@ -106,1 +108,1 @@\n-    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) LINKER.canonicalLayouts().get(\"int\");\n@@ -111,1 +113,1 @@\n-    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"long long\");\n@@ -115,1 +117,1 @@\n-    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) LINKER.canonicalLayouts().get(\"float\");\n@@ -119,1 +121,1 @@\n-    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) LINKER.canonicalLayouts().get(\"double\");\n@@ -123,4 +125,21 @@\n-    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n-\n-    public static final Linker LINKER = Linker.nativeLinker();\n+    public static final AddressLayout C_POINTER = ((AddressLayout) LINKER.canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+    \/**\n+     * The layout for the {@code size_t} C type\n+     *\/\n+    public static final ValueLayout C_SIZE_T = (ValueLayout) LINKER.canonicalLayouts().get(\"size_t\");\n+\n+    \/\/ Common layout shared by some tests\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    public static final MemoryLayout S_PDI_LAYOUT = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+        case 8 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"),\n+            MemoryLayout.paddingLayout(4));\n+        case 4 -> MemoryLayout.structLayout(\n+            C_POINTER.withName(\"p0\"),\n+            C_DOUBLE.withName(\"p1\"),\n+            C_INT.withName(\"p2\"));\n+        default -> throw new UnsupportedOperationException(\"Unsupported address size\");\n+    };\n@@ -251,2 +270,2 @@\n-            accessor.set(container, fieldValue.value());\n-            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual));\n+            accessor.set(container, 0L, fieldValue.value());\n+            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual, 0L));\n@@ -260,1 +279,1 @@\n-                return (MemorySegment) slicer.invokeExact(container);\n+                return (MemorySegment) slicer.invokeExact(container, 0L);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-@Test\n@@ -124,2 +121,5 @@\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n+        String javaFormatArgs = args.stream()\n+                .map(a -> a.javaFormat)\n+                .collect(Collectors.joining(\",\"));\n+        String nativeFormatArgs = args.stream()\n+                .map(a -> a.nativeFormat)\n@@ -128,1 +128,2 @@\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+        String javaFormatString = \"hello(\" + javaFormatArgs + \")\\n\";\n+        String nativeFormatString = \"hello(\" + nativeFormatArgs + \")\\n\";\n@@ -130,1 +131,1 @@\n-        String expected = String.format(formatString, args.stream()\n+        String expected = String.format(javaFormatString, args.stream()\n@@ -133,1 +134,1 @@\n-        int found = stdLibHelper.printf(formatString, args);\n+        int found = stdLibHelper.printf(nativeFormatString, args);\n@@ -159,0 +160,1 @@\n+        \/\/ void qsort( void *ptr, size_t count, size_t size, int (*comp)(const void *, const void *) );\n@@ -160,1 +162,1 @@\n-                FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER, C_SIZE_T, C_SIZE_T, C_POINTER));\n@@ -190,3 +192,3 @@\n-                buf.setUtf8String(0, s1);\n-                MemorySegment other = arena.allocateUtf8String(s2);\n-                return ((MemorySegment)strcat.invokeExact(buf, other)).getUtf8String(0);\n+                buf.setString(0, s1);\n+                MemorySegment other = arena.allocateFrom(s2);\n+                return ((MemorySegment)strcat.invokeExact(buf, other)).getString(0);\n@@ -198,2 +200,2 @@\n-                MemorySegment ns1 = arena.allocateUtf8String(s1);\n-                MemorySegment ns2 = arena.allocateUtf8String(s2);\n+                MemorySegment ns1 = arena.allocateFrom(s1);\n+                MemorySegment ns2 = arena.allocateFrom(s2);\n@@ -206,1 +208,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -213,1 +215,1 @@\n-                MemorySegment s = arena.allocateUtf8String(msg);\n+                MemorySegment s = arena.allocateFrom(msg);\n@@ -280,1 +282,1 @@\n-                MemorySegment nativeArr = arena.allocateArray(C_INT, arr);\n+                MemorySegment nativeArr = arena.allocateFrom(C_INT, arr);\n@@ -285,1 +287,5 @@\n-                qsort.invokeExact(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                \/\/ both of these fit in an int\n+                \/\/ automatically widen them to long on x64\n+                int count = arr.length;\n+                int size = (int) C_INT.byteSize();\n+                qsort.invoke(nativeArr, count, size, qsortUpcallStub);\n@@ -303,1 +309,1 @@\n-                MemorySegment formatStr = arena.allocateUtf8String(format);\n+                MemorySegment formatStr = arena.allocateFrom(format);\n@@ -381,4 +387,4 @@\n-        INT(int.class, C_INT, \"%d\", arena -> 42, 42),\n-        LONG(long.class, C_LONG_LONG, \"%d\", arena -> 84L, 84L),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena -> 1.2345d, 1.2345d),\n-        STRING(MemorySegment.class, C_POINTER, \"%s\", arena -> arena.allocateUtf8String(\"str\"), \"str\");\n+        INT(int.class, C_INT, \"%d\", \"%d\", arena -> 42, 42),\n+        LONG(long.class, C_LONG_LONG, \"%lld\", \"%d\", arena -> 84L, 84L),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", \"%.4f\", arena -> 1.2345d, 1.2345d),\n+        STRING(MemorySegment.class, C_POINTER, \"%s\", \"%s\", arena -> arena.allocateFrom(\"str\"), \"str\");\n@@ -388,1 +394,2 @@\n-        final String format;\n+        final String nativeFormat;\n+        final String javaFormat;\n@@ -392,1 +399,2 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String nativeFormat, String javaFormat,\n+                                             Function<Arena, Z> nativeValueFactory, Object javaValue) {\n@@ -395,1 +403,2 @@\n-            this.format = format;\n+            this.nativeFormat = nativeFormat;\n+            this.javaFormat = javaFormat;\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":35,"deletions":26,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ *\/\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.VarHandle.AccessMode;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+public class TestAccessModes {\n+\n+    @Test(dataProvider = \"segmentsAndLayoutsAndModes\")\n+    public void testAccessModes(MemorySegment segment, ValueLayout layout, AccessMode mode) throws Throwable {\n+        VarHandle varHandle = layout.varHandle();\n+        MethodHandle methodHandle = varHandle.toMethodHandle(mode);\n+        boolean compatible = AccessModeKind.supportedModes(layout).contains(AccessModeKind.of(mode));\n+        try {\n+            Object o = methodHandle.invokeWithArguments(makeArgs(segment, varHandle.accessModeType(mode)));\n+            assertTrue(compatible);\n+        } catch (UnsupportedOperationException ex) {\n+            assertFalse(compatible);\n+        } catch (IllegalArgumentException ex) {\n+            \/\/ access is unaligned, but access mode is supported\n+            assertTrue(compatible);\n+        }\n+    }\n+\n+    Object[] makeArgs(MemorySegment segment, MethodType type) throws Throwable {\n+        List<Object> args = new ArrayList<>();\n+        args.add(segment);\n+        for (Class argType : type.dropParameterTypes(0, 1).parameterList()) {\n+            args.add(defaultValue(argType));\n+        }\n+        return args.toArray();\n+    }\n+\n+    Object defaultValue(Class<?> clazz) throws Throwable {\n+        if (clazz == MemorySegment.class) {\n+            return MemorySegment.NULL;\n+        } else if (clazz.isPrimitive()) {\n+            return MethodHandles.zero(clazz).invoke();\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    \/*\n+     * See the javadoc of MemoryLayout::varHandle.\n+     *\/\n+    enum AccessModeKind {\n+        PLAIN,\n+        READ_WRITE,\n+        ATOMIC_UPDATE,\n+        ATOMIC_NUMERIC_UPDATE,\n+        ATOMIC_BITWISE_UPDATE;\n+\n+        static AccessModeKind of(AccessMode mode) {\n+            return switch (mode) {\n+                case GET, SET -> PLAIN;\n+                case GET_ACQUIRE, GET_OPAQUE, GET_VOLATILE, SET_VOLATILE,\n+                        SET_OPAQUE, SET_RELEASE -> READ_WRITE;\n+                case GET_AND_SET, GET_AND_SET_ACQUIRE, GET_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET, WEAK_COMPARE_AND_SET_RELEASE,\n+                        WEAK_COMPARE_AND_SET_ACQUIRE, WEAK_COMPARE_AND_SET_PLAIN,\n+                        COMPARE_AND_EXCHANGE, COMPARE_AND_EXCHANGE_ACQUIRE,\n+                        COMPARE_AND_EXCHANGE_RELEASE, COMPARE_AND_SET -> ATOMIC_UPDATE;\n+                case GET_AND_ADD, GET_AND_ADD_ACQUIRE, GET_AND_ADD_RELEASE -> ATOMIC_NUMERIC_UPDATE;\n+                default -> ATOMIC_BITWISE_UPDATE;\n+            };\n+        }\n+\n+        static Set<AccessModeKind> supportedModes(ValueLayout layout) {\n+            Set<AccessModeKind> supportedModes = EnumSet.noneOf(AccessModeKind.class);\n+            supportedModes.add(PLAIN);\n+            if (layout.byteAlignment() >= layout.byteSize()) {\n+                supportedModes.add(READ_WRITE);\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof ValueLayout.OfFloat || layout instanceof ValueLayout.OfDouble ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_UPDATE);\n+                }\n+                if (layout instanceof ValueLayout.OfInt || layout instanceof ValueLayout.OfLong ||\n+                        layout instanceof AddressLayout) {\n+                    supportedModes.add(ATOMIC_NUMERIC_UPDATE);\n+                    supportedModes.add(ATOMIC_BITWISE_UPDATE);\n+                }\n+            }\n+            return supportedModes;\n+        }\n+    }\n+\n+    static MemoryLayout[] layouts() {\n+        MemoryLayout[] valueLayouts = {\n+                ValueLayout.JAVA_BOOLEAN,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_SHORT,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_FLOAT,\n+                ValueLayout.JAVA_LONG,\n+                ValueLayout.JAVA_DOUBLE,\n+                ValueLayout.ADDRESS\n+        };\n+        List<MemoryLayout> layouts = new ArrayList<>();\n+        for (MemoryLayout layout : valueLayouts) {\n+            for (int align : new int[] { 1, 2, 4, 8 }) {\n+                layouts.add(layout.withByteAlignment(align));\n+            }\n+        }\n+        return layouts.toArray(new MemoryLayout[0]);\n+    }\n+\n+    static MemorySegment[] segments() {\n+        return new MemorySegment[]{\n+                Arena.ofAuto().allocate(8),\n+                MemorySegment.ofArray(new byte[8]),\n+                MemorySegment.ofArray(new char[4]),\n+                MemorySegment.ofArray(new short[4]),\n+                MemorySegment.ofArray(new int[2]),\n+                MemorySegment.ofArray(new float[2]),\n+                MemorySegment.ofArray(new long[1]),\n+                MemorySegment.ofArray(new double[1])\n+        };\n+    }\n+\n+    @DataProvider(name = \"segmentsAndLayoutsAndModes\")\n+    static Object[][] segmentsAndLayoutsAndModes() {\n+        List<Object[]> segmentsAndLayouts = new ArrayList<>();\n+        for (MemorySegment segment : segments()) {\n+            for (MemoryLayout layout : layouts()) {\n+                for (AccessMode mode : AccessMode.values()) {\n+                    segmentsAndLayouts.add(new Object[]{segment, layout, mode});\n+                }\n+            }\n+        }\n+        return segmentsAndLayouts.toArray(new Object[0][]);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -86,1 +85,2 @@\n-    static final VarHandle intHandleIndexed = ValueLayout.JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle intHandleIndexed = MethodHandles.collectCoordinates(ValueLayout.JAVA_INT.varHandle(),\n+            1, MethodHandles.insertArguments(ValueLayout.JAVA_INT.scaleHandle(), 0, 0L));\n@@ -88,1 +88,1 @@\n-    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle intHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_INT.varHandle(), 1, 0L);\n@@ -90,1 +90,1 @@\n-    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n+    static final VarHandle floatHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_FLOAT.varHandle(), 1, 0L);\n@@ -99,2 +99,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -102,1 +102,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -104,1 +104,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -106,1 +106,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -108,1 +108,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -120,3 +120,3 @@\n-        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 1, \"a\", \"b\");\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 2, \"a\", \"b\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -124,1 +124,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -126,1 +126,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -128,1 +128,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -130,1 +130,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -141,2 +141,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -144,1 +144,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -146,1 +146,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -148,1 +148,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -150,1 +150,1 @@\n-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -197,2 +197,2 @@\n-            vh.set(seg, \"42\");\n-            String x = (String) vh.get(seg); \/\/ should throw\n+            vh.set(seg, 0L, \"42\");\n+            String x = (String) vh.get(seg, 0L); \/\/ should throw\n@@ -208,1 +208,1 @@\n-            vh.set(seg, \"42\"); \/\/ should throw\n+            vh.set(seg, 0L, \"42\"); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -187,0 +187,2 @@\n+        private static final Pattern LAYOUT_PATTERN = Pattern.compile(\"^(?<align>\\\\d+%)?(?<char>[azcsifjdAZCSIFJD])\\\\d+$\");\n+\n@@ -188,11 +190,14 @@\n-            return switch (layoutString.charAt(0)) {\n-                case 'A','a' -> ADDRESS;\n-                case 'z','Z' -> BOOL;\n-                case 'c','C' -> CHAR;\n-                case 's','S' -> SHORT;\n-                case 'i','I' -> INT;\n-                case 'f','F' -> FLOAT;\n-                case 'j','J' -> LONG;\n-                case 'd','D' -> DOUBLE;\n-                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n-            };\n+            Matcher matcher = LAYOUT_PATTERN.matcher(layoutString);\n+            if (matcher.matches()) {\n+                switch (matcher.group(\"char\")) {\n+                    case \"A\",\"a\": return ADDRESS;\n+                    case \"z\",\"Z\": return BOOL;\n+                    case \"c\",\"C\": return CHAR;\n+                    case \"s\",\"S\": return SHORT;\n+                    case \"i\",\"I\": return INT;\n+                    case \"f\",\"F\": return FLOAT;\n+                    case \"j\",\"J\": return LONG;\n+                    case \"d\",\"D\": return DOUBLE;\n+                };\n+            }\n+            throw new AssertionError(\"Invalid layout string: \" + layoutString);\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -30,0 +29,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -32,0 +32,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -291,0 +294,5 @@\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+                1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n+\n@@ -292,2 +300,2 @@\n-        VarHandle indexedHandleNO = helper.elementLayout.withOrder(NATIVE_ORDER).arrayElementVarHandle();\n-        VarHandle indexedHandleNNO = helper.elementLayout.withOrder(NON_NATIVE_ORDER).arrayElementVarHandle();\n+        VarHandle indexedHandleNO = arrayVarHandle(helper.elementLayout.withOrder(NATIVE_ORDER));\n+        VarHandle indexedHandleNNO = arrayVarHandle(helper.elementLayout.withOrder(NON_NATIVE_ORDER));\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,0 +33,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -147,1 +149,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -149,1 +151,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -151,1 +153,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -153,1 +155,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -155,1 +157,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -157,1 +159,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -159,1 +161,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -162,1 +164,1 @@\n-                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, 0L, pos));\n@@ -164,1 +166,1 @@\n-                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, 0L, pos));\n@@ -166,1 +168,1 @@\n-                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, 0L, pos));\n@@ -168,1 +170,1 @@\n-                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, 0L, pos));\n@@ -170,1 +172,1 @@\n-                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, 0L, pos));\n@@ -172,1 +174,1 @@\n-                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, 0L, pos));\n@@ -174,1 +176,1 @@\n-                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, 0L, pos));\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -125,2 +124,2 @@\n-            indexHandle.set(base, i, (int)i);\n-            valueHandle.set(base, i, (float)(i \/ 500f));\n+            indexHandle.set(base, 0L, i, (int)i);\n+            valueHandle.set(base, 0L, i, (float)(i \/ 500f));\n@@ -134,2 +133,2 @@\n-            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));\n-            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));\n+            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, 0L, i));\n+            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, 0L, i));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -76,1 +75,1 @@\n-            int val = (int) abcx.get(a);\n+            int val = (int) abcx.get(a, 0L);\n@@ -101,2 +100,2 @@\n-            MemorySegment b = arena.allocateArray(B, 2);\n-            MemorySegment c = arena.allocateArray(C, 4);\n+            MemorySegment b = arena.allocate(B, 2);\n+            MemorySegment c = arena.allocate(C, 4);\n@@ -112,1 +111,1 @@\n-            int val00 = (int) abcx_multi.get(a, 0, 0); \/\/ a->b[0]->c[0] = 1\n+            int val00 = (int) abcx_multi.get(a, 0L, 0, 0); \/\/ a->b[0]->c[0] = 1\n@@ -114,1 +113,1 @@\n-            int val10 = (int) abcx_multi.get(a, 1, 0); \/\/ a->b[1]->c[0] = 3\n+            int val10 = (int) abcx_multi.get(a, 0L, 1, 0); \/\/ a->b[1]->c[0] = 3\n@@ -116,1 +115,1 @@\n-            int val01 = (int) abcx_multi.get(a, 0, 1); \/\/ a->b[0]->c[1] = 2\n+            int val01 = (int) abcx_multi.get(a, 0L, 0, 1); \/\/ a->b[0]->c[1] = 2\n@@ -118,1 +117,1 @@\n-            int val11 = (int) abcx_multi.get(a, 1, 1); \/\/ a->b[1]->c[1] = 4\n+            int val11 = (int) abcx_multi.get(a, 0L, 1, 1); \/\/ a->b[1]->c[1] = 4\n@@ -155,1 +154,1 @@\n-            vhX.set(segment, 42); \/\/ should throw\n+            vhX.set(segment, 0L, 42); \/\/ should throw\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFallbackLookup.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -42,1 +41,1 @@\n-        assertEquals(str, addr.getUtf8String(0));\n+        assertEquals(str, addr.getString(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestHFA.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,2 @@\n-        assertAligned(align, layout, () -> layout.varHandle().get(segment));\n-        assertAligned(align, layout, () -> layout.varHandle().set(segment, val));\n+        assertAligned(align, layout, () -> layout.varHandle().get(segment, 0L));\n+        assertAligned(align, layout, () -> layout.varHandle().set(segment, 0L, val));\n@@ -51,2 +49,2 @@\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, 0L, val));\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -50,0 +48,2 @@\n+import static java.lang.foreign.ValueLayout.*;\n+\n@@ -105,1 +105,1 @@\n-            { Linker.Option.isTrivial() },\n+            { Linker.Option.critical() },\n@@ -131,1 +131,1 @@\n-                    IS_LE ? \"Unsupported layout: 2%a8\" : \"Unsupported layout: 2%A8\"\n+                    (IS_LE ? \"Unsupported layout: 2%a\" : \"Unsupported layout: 2%A\") + ADDRESS.byteSize()\n@@ -159,1 +159,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(1,\n@@ -184,1 +184,1 @@\n-                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(1, C_INT.withOrder(nonNativeOrder())))),\n@@ -188,7 +188,0 @@\n-            {\n-                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n-                            ValueLayout.JAVA_LONG,\n-                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n-                    NO_OPTIONS,\n-                    \"has unexpected size\"\n-            },\n@@ -202,0 +195,5 @@\n+            {\n+                    FunctionDescriptor.ofVoid(),\n+                    new Linker.Option[]{Linker.Option.critical(), Linker.Option.captureCallState(\"errno\")},\n+                    \"Incompatible linker options: captureCallState, critical\"\n+            },\n@@ -215,1 +213,1 @@\n-                            MemoryLayout.sequenceLayout(\n+                            MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ C_INT.byteSize(),\n@@ -222,0 +220,9 @@\n+        if (ValueLayout.JAVA_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    NO_OPTIONS,\n+                    \"has unexpected size\"\n+            });\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -38,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -45,0 +45,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -139,1 +140,1 @@\n-    public void testBadAlignmentOfRoot() throws Throwable {\n+    public void testBadAlignmentOfRoot() {\n@@ -150,1 +151,1 @@\n-            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+            String expectedMessage = \"Target offset 0 is incompatible with alignment constraint \" + struct.byteAlignment() + \" (of [i4s2(x)]) for segment MemorySegment\";\n@@ -154,1 +155,1 @@\n-                vhX.set(seg, (short) 42);\n+                vhX.set(seg, 0L, (short) 42);\n@@ -156,1 +157,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -160,1 +161,1 @@\n-                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg);\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg, 0L);\n@@ -162,1 +163,1 @@\n-            assertEquals(iae.getMessage(), expectedMessage);\n+            assertTrue(iae.getMessage().startsWith(expectedMessage));\n@@ -166,0 +167,36 @@\n+    @Test\n+    public void testWrongTypeRoot() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)\n+        );\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: [i4i4]\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n+    @Test\n+    public void testWrongTypeEnclosing() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(2, MemoryLayout.structLayout(\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3a\"),\n+                                JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"3b\")\n+                        ).withName(\"2\")\n+                ).withName(\"1\")\n+        ).withName(\"0\");\n+\n+        var expectedMessage = \"Bad layout path: attempting to select a sequence element from a non-sequence layout: \" +\n+                \"[i4(3a)i4(3b)](2), selected from: \" +\n+                \"[2:[i4(3a)i4(3b)](2)](1), selected from: \" +\n+                \"[[2:[i4(3a)i4(3b)](2)](1)](0)\";\n+\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () ->\n+                struct.select(PathElement.groupElement(\"1\"),\n+                        PathElement.sequenceElement(),\n+                        PathElement.sequenceElement()));\n+        assertEquals(iae.getMessage(), expectedMessage);\n+    }\n+\n@@ -274,1 +311,1 @@\n-        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(0L, indexes);\n@@ -363,1 +400,1 @@\n-            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, indexes);\n+            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, 0L, indexes);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -101,1 +100,1 @@\n-                indexHandle.set(segment, (long)i, i);\n+                indexHandle.set(segment, 0L, (long)i, i);\n@@ -106,2 +105,2 @@\n-                int expected = (int)indexHandle.get(segment, (long)i);\n-                int found = (int)preindexHandle.get(segment);\n+                int expected = (int)indexHandle.get(segment, 0L, (long)i);\n+                int found = (int)preindexHandle.get(segment, 0L);\n@@ -204,6 +203,1 @@\n-    @Test(dataProvider = \"basicLayouts\")\n-    public void testSequenceInferredCount(MemoryLayout layout) {\n-        assertEquals(MemoryLayout.sequenceLayout(layout),\n-                     MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.byteSize(), layout));\n-    }\n-\n+    @Test\n@@ -303,1 +297,1 @@\n-        MemoryLayout.sequenceLayout(layout);\n+        MemoryLayout.sequenceLayout(1, layout);\n@@ -310,1 +304,1 @@\n-            MemoryLayout.sequenceLayout(layout);\n+            MemoryLayout.sequenceLayout(1, layout);\n@@ -341,8 +335,0 @@\n-    @Test(dataProvider=\"layoutsAndAlignments\")\n-    public void testArrayElementVarHandleBadAlignment(MemoryLayout layout, long byteAlign) {\n-        if (layout instanceof ValueLayout) {\n-            assertThrows(UnsupportedOperationException.class, () ->\n-                    ((ValueLayout) layout).withByteAlignment(byteAlign * 2).arrayElementVarHandle());\n-        }\n-    }\n-\n@@ -362,0 +348,31 @@\n+    @Test\n+    public void testVarHandleCaching() {\n+        assertSame(JAVA_INT.varHandle(), JAVA_INT.varHandle());\n+        assertSame(JAVA_INT.withName(\"foo\").varHandle(), JAVA_INT.varHandle());\n+\n+        assertNotSame(JAVA_INT_UNALIGNED.varHandle(), JAVA_INT.varHandle());\n+        assertNotSame(ADDRESS.withTargetLayout(JAVA_INT).varHandle(), ADDRESS.varHandle());\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative offset.*\")\n+    public void testScaleNegativeOffset() {\n+        JAVA_INT.scale(-1, 0);\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative index.*\")\n+    public void testScaleNegativeIndex() {\n+        JAVA_INT.scale(0, -1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleAddOverflow() {\n+        JAVA_INT.scale(Long.MAX_VALUE, 1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleMultiplyOverflow() {\n+        JAVA_INT.scale(0, Long.MAX_VALUE);\n+    }\n+\n@@ -499,1 +516,0 @@\n-                MemoryLayout.sequenceLayout(JAVA_INT),\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,0 +38,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -48,0 +48,1 @@\n+import static org.testng.Assert.assertNotNull;\n@@ -50,0 +51,1 @@\n+import static org.testng.Assert.assertTrue;\n@@ -94,4 +96,0 @@\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) },\n-            { FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n-                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) },\n@@ -116,0 +114,6 @@\n+        if (C_LONG_LONG.byteAlignment() == 8) {\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG.withName(\"x\"))) });\n+            cases.add(new Object[]{ FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4), C_LONG_LONG)),\n+                    FunctionDescriptor.ofVoid(structLayout(C_INT, paddingLayout(4).withName(\"x\"), C_LONG_LONG)) });\n+        }\n@@ -143,0 +147,23 @@\n+    @Test(dataProvider = \"canonicalTypeNames\")\n+    public void testCanonicalLayouts(String typeName) {\n+        MemoryLayout layout = LINKER.canonicalLayouts().get(typeName);\n+        assertNotNull(layout);\n+        assertTrue(layout instanceof ValueLayout);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] canonicalTypeNames() {\n+        return new Object[][]{\n+                { \"bool\" },\n+                { \"char\" },\n+                { \"short\" },\n+                { \"int\" },\n+                { \"long\" },\n+                { \"long long\" },\n+                { \"float\" },\n+                { \"double\" },\n+                { \"void*\" },\n+                { \"size_t\" },\n+                { \"wchar_t\" },\n+        };\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -48,2 +46,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -61,2 +57,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -74,2 +68,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -87,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -99,2 +89,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -111,2 +99,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -123,2 +109,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -135,2 +119,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -148,2 +130,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -161,2 +141,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -174,2 +152,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -187,2 +163,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -200,2 +174,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -213,2 +185,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -226,2 +196,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -239,2 +207,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -252,2 +218,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -265,2 +229,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -278,2 +240,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -292,2 +252,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -69,6 +68,0 @@\n-    @Test(dataProvider = \"arrayElements\")\n-    public void testArrayAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, ArrayChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\"));\n-        testArrayAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(), checker);\n-    }\n-\n@@ -161,7 +154,0 @@\n-    @Test(dataProvider = \"matrixElements\")\n-    public void testMatrixAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, MatrixChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n-                MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\")));\n-        testMatrixAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(10), checker);\n-    }\n-\n@@ -270,2 +256,2 @@\n-            handle.set(segment, (byte)42);\n-            assertEquals(42, (byte)handle.get(segment));\n+            handle.set(segment, 0L, (byte)42);\n+            assertEquals(42, (byte)handle.get(segment, 0L));\n@@ -275,2 +261,2 @@\n-            handle.set(segment, (short)42);\n-            assertEquals(42, (short)handle.get(segment));\n+            handle.set(segment, 0L, (short)42);\n+            assertEquals(42, (short)handle.get(segment, 0L));\n@@ -280,2 +266,2 @@\n-            handle.set(segment, (char)42);\n-            assertEquals(42, (char)handle.get(segment));\n+            handle.set(segment, 0L, (char)42);\n+            assertEquals(42, (char)handle.get(segment, 0L));\n@@ -285,2 +271,2 @@\n-            handle.set(segment, 42);\n-            assertEquals(42, (int)handle.get(segment));\n+            handle.set(segment, 0L, 42);\n+            assertEquals(42, (int)handle.get(segment, 0L));\n@@ -290,2 +276,2 @@\n-            handle.set(segment, (long)42);\n-            assertEquals(42, (long)handle.get(segment));\n+            handle.set(segment, 0L, (long)42);\n+            assertEquals(42, (long)handle.get(segment, 0L));\n@@ -295,2 +281,2 @@\n-            handle.set(segment, (float)42);\n-            assertEquals((float)42, (float)handle.get(segment));\n+            handle.set(segment, 0L, (float)42);\n+            assertEquals((float)42, (float)handle.get(segment, 0L));\n@@ -300,2 +286,2 @@\n-            handle.set(segment, (double)42);\n-            assertEquals((double)42, (double)handle.get(segment));\n+            handle.set(segment, 0L, (double)42);\n+            assertEquals((double)42, (double)handle.get(segment, 0L));\n@@ -347,2 +333,2 @@\n-            handle.set(segment, i, (byte)i);\n-            assertEquals(i, (byte)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (byte)i);\n+            assertEquals(i, (byte)handle.get(segment, 0L, i));\n@@ -352,2 +338,2 @@\n-            handle.set(segment, i, (short)i);\n-            assertEquals(i, (short)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (short)i);\n+            assertEquals(i, (short)handle.get(segment, 0L, i));\n@@ -357,2 +343,2 @@\n-            handle.set(segment, i, (char)i);\n-            assertEquals(i, (char)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (char)i);\n+            assertEquals(i, (char)handle.get(segment, 0L, i));\n@@ -362,2 +348,2 @@\n-            handle.set(segment, i, (int)i);\n-            assertEquals(i, (int)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (int)i);\n+            assertEquals(i, (int)handle.get(segment, 0L, i));\n@@ -367,2 +353,2 @@\n-            handle.set(segment, i, (long)i);\n-            assertEquals(i, (long)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (long)i);\n+            assertEquals(i, (long)handle.get(segment, 0L, i));\n@@ -372,2 +358,2 @@\n-            handle.set(segment, i, (float)i);\n-            assertEquals((float)i, (float)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (float)i);\n+            assertEquals((float)i, (float)handle.get(segment, 0L, i));\n@@ -377,2 +363,2 @@\n-            handle.set(segment, i, (double)i);\n-            assertEquals((double)i, (double)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (double)i);\n+            assertEquals((double)i, (double)handle.get(segment, 0L, i));\n@@ -432,2 +418,2 @@\n-            handle.set(segment, r, c, (byte)(r + c));\n-            assertEquals(r + c, (byte)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (byte)(r + c));\n+            assertEquals(r + c, (byte)handle.get(segment, 0L, r, c));\n@@ -437,2 +423,2 @@\n-            handle.set(segment, r, c, (r + c) != 0);\n-            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, 0L, r, c));\n@@ -442,2 +428,2 @@\n-            handle.set(segment, r, c, (short)(r + c));\n-            assertEquals(r + c, (short)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (short)(r + c));\n+            assertEquals(r + c, (short)handle.get(segment, 0L, r, c));\n@@ -447,2 +433,2 @@\n-            handle.set(segment, r, c, (char)(r + c));\n-            assertEquals(r + c, (char)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (char)(r + c));\n+            assertEquals(r + c, (char)handle.get(segment, 0L, r, c));\n@@ -452,2 +438,2 @@\n-            handle.set(segment, r, c, (int)(r + c));\n-            assertEquals(r + c, (int)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (int)(r + c));\n+            assertEquals(r + c, (int)handle.get(segment, 0L, r, c));\n@@ -457,2 +443,2 @@\n-            handle.set(segment, r, c, r + c);\n-            assertEquals(r + c, (long)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, r + c);\n+            assertEquals(r + c, (long)handle.get(segment, 0L, r, c));\n@@ -462,2 +448,2 @@\n-            handle.set(segment, r, c, MemorySegment.ofAddress(r + c));\n-            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, MemorySegment.ofAddress(r + c));\n+            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, 0L, r, c));\n@@ -467,2 +453,2 @@\n-            handle.set(segment, r, c, (float)(r + c));\n-            assertEquals((float)(r + c), (float)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (float)(r + c));\n+            assertEquals((float)(r + c), (float)handle.get(segment, 0L, r, c));\n@@ -472,2 +458,2 @@\n-            handle.set(segment, r, c, (double)(r + c));\n-            assertEquals((double)(r + c), (double)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (double)(r + c));\n+            assertEquals((double)(r + c), (double)handle.get(segment, 0L, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":46,"deletions":60,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -51,2 +50,2 @@\n-            vh.set(segment, -42);\n-            int val = (int)vh.get(segment);\n+            vh.set(segment, 0L, -42);\n+            int val = (int)vh.get(segment, 0L);\n@@ -68,1 +67,1 @@\n-            vh.set(segment.asSlice(1L), -42);\n+            vh.set(segment.asSlice(1L), 0L, -42);\n@@ -96,1 +95,1 @@\n-                    vh.set(segment, i, -42);\n+                    vh.set(segment, 0L, i, -42);\n@@ -119,6 +118,6 @@\n-            vh_c.set(segment, Byte.MIN_VALUE);\n-            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);\n-            vh_s.set(segment, Short.MIN_VALUE);\n-            assertEquals(vh_s.get(segment), Short.MIN_VALUE);\n-            vh_i.set(segment, Integer.MIN_VALUE);\n-            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);\n+            vh_c.set(segment, 0L, Byte.MIN_VALUE);\n+            assertEquals(vh_c.get(segment, 0L), Byte.MIN_VALUE);\n+            vh_s.set(segment, 0L, Short.MIN_VALUE);\n+            assertEquals(vh_s.get(segment, 0L), Short.MIN_VALUE);\n+            vh_i.set(segment, 0L, Integer.MIN_VALUE);\n+            assertEquals(vh_i.get(segment, 0L), Integer.MIN_VALUE);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,301 @@\n+\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryInspection\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.VarHandle;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.MemoryInspection;\n+import org.testng.annotations.*;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.util.stream.Collectors.joining;\n+import static org.testng.Assert.*;\n+import static java.util.Objects.requireNonNull;\n+\n+@Test\n+public class TestMemoryInspection {\n+\n+    private static final String EXPECT_ADDRESS = \"0x\" + \"00\".repeat((int) ValueLayout.ADDRESS.byteSize());\n+\n+    @Test\n+    public void valueLayouts() {\n+\n+        record TestInput(ValueLayout layout, String stringValue) {\n+        }\n+\n+        List.of(\n+                new TestInput(ValueLayout.JAVA_BYTE, \"0\"),\n+                new TestInput(ValueLayout.JAVA_SHORT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_INT, \"0\"),\n+                new TestInput(ValueLayout.JAVA_LONG, \"0\"),\n+                new TestInput(ValueLayout.JAVA_FLOAT, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_DOUBLE, \"0.0\"),\n+                new TestInput(ValueLayout.JAVA_CHAR, \"\" + (char) 0),\n+                new TestInput(JAVA_BOOLEAN, \"false\"),\n+                new TestInput(ValueLayout.ADDRESS, EXPECT_ADDRESS)\n+        ).forEach(ti -> {\n+            var expect = ti.layout() + \"=\" + ti.stringValue();\n+            var actual = testWithFreshMemorySegment(ti.layout().byteSize(), s -> jdk.internal.foreign.MemoryInspection.inspect(s, ti.layout(), jdk.internal.foreign.MemoryInspection.standardRenderer()))\n+                    .collect(joining(System.lineSeparator()));\n+            assertEquals(actual, expect);\n+        });\n+    }\n+\n+    @Test\n+    public void point() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=1,\n+                    y=2\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, Point.LAYOUT, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void pointCustomRenderer() {\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Point {\n+                    x=0x0001,\n+                    y=0x0002\n+                }\"\"\");\n+\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2, segment -> {\n+            final Point point = new Point(segment);\n+            point.x(1);\n+            point.y(2);\n+            return MemoryInspection.inspect(segment, Point.LAYOUT, new BiFunction<ValueLayout, Object, String>() {\n+\n+                        @Override\n+                        public String apply(ValueLayout layout, Object o) {\n+                            return String.format(\"0x%04x\", (int)o);\n+                        }\n+                    })\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    @Test\n+    public void standardCustomRenderer() {\n+\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+                \/\/ These are in bit alignment order (descending) for all platforms\n+                \/\/ in order for each element to be aligned to its type's bit alignment.\n+                Stream.of(\n+                                JAVA_LONG,\n+                                JAVA_DOUBLE,\n+                                ADDRESS,\n+                                JAVA_INT,\n+                                JAVA_FLOAT,\n+                                JAVA_SHORT,\n+                                JAVA_CHAR,\n+                                JAVA_BOOLEAN,\n+                                JAVA_BYTE\n+                        )\n+                        .map(vl -> vl.withName(vl.carrier().getSimpleName()))\n+                        .toArray(MemoryLayout[]::new)\n+        ).withName(\"struct\");\n+\n+        System.out.println(\"layout = \" + layout);\n+        var expect = platformLineSeparated(\"\"\"\n+                struct {\n+                    long=0,\n+                    double=0.0,\n+                    MemorySegment=$1,\n+                    int=0,\n+                    float=0.0,\n+                    short=0,\n+                    char=\\u0000,\n+                    boolean=false,\n+                    byte=0\n+                }\"\"\").replace(\"$1\", EXPECT_ADDRESS);\n+\n+\n+        var actual = testWithFreshMemorySegment(layout.byteSize(), segment ->\n+                jdk.internal.foreign.MemoryInspection.inspect(segment, layout, jdk.internal.foreign.MemoryInspection.standardRenderer()))\n+                .collect(joining(System.lineSeparator()));\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void sequence() {\n+        final int arraySize = 4;\n+        var sequenceLayout = MemoryLayout.sequenceLayout(arraySize,\n+                MemoryLayout.structLayout(\n+                        ValueLayout.JAVA_INT.withName(\"x\"),\n+                        ValueLayout.JAVA_INT.withName(\"y\")\n+                ).withName(\"Point\")\n+        ).withName(\"PointArrayOfElements\");\n+\n+        var xh = sequenceLayout.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"x\"));\n+        var yh = sequenceLayout.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"y\"));\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                PointArrayOfElements [\n+                    Point {\n+                        x=1,\n+                        y=0\n+                    },\n+                    Point {\n+                        x=1,\n+                        y=1\n+                    },\n+                    Point {\n+                        x=1,\n+                        y=2\n+                    },\n+                    Point {\n+                        x=1,\n+                        y=3\n+                    }\n+                ]\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 2 * arraySize, segment -> {\n+            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                xh.set(segment, 0L, i, 1);\n+                yh.set(segment, 0L, i, (int) i);\n+            }\n+\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, sequenceLayout, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                .collect(joining(System.lineSeparator()));}\n+        );\n+        assertEquals(actual, expect);\n+    }\n+\n+\n+    @Test\n+    public void union() {\n+        var u0 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                MemoryLayout.paddingLayout(Integer.BYTES)\n+        ).withName(\"Point\");\n+\n+        var u1 = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\"),\n+                ValueLayout.JAVA_INT.withName(\"z\")\n+        ).withName(\"3D-Point\");\n+\n+        var union = MemoryLayout.unionLayout(u0, u1).withName(\"Union\");\n+\n+        var expect = platformLineSeparated(\"\"\"\n+                Union {\n+                    Point {\n+                        x=1,\n+                        y=2,\n+                        4 padding bytes\n+                    }|\n+                    3D-Point {\n+                        x=1,\n+                        y=2,\n+                        z=3\n+                    }\n+                }\"\"\");\n+        var actual = testWithFreshMemorySegment(Integer.BYTES * 3, segment -> {\n+            u0.varHandle(PathElement.groupElement(\"x\")).set(segment, 0L, 1);\n+            u1.varHandle(PathElement.groupElement(\"y\")).set(segment, 0L, 2);\n+            u1.varHandle(PathElement.groupElement(\"z\")).set(segment, 0L, 3);\n+            return jdk.internal.foreign.MemoryInspection.inspect(segment, union, jdk.internal.foreign.MemoryInspection.standardRenderer())\n+                    .collect(joining(System.lineSeparator()));\n+        });\n+\n+        assertEquals(actual, expect);\n+    }\n+\n+    static final class Point {\n+\n+        static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                ValueLayout.JAVA_INT.withName(\"x\"),\n+                ValueLayout.JAVA_INT.withName(\"y\")\n+        ).withName(\"Point\");\n+\n+        static final VarHandle xVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        static final VarHandle yVH = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+\n+        private final MemorySegment memorySegment;\n+\n+        Point(MemorySegment memorySegment) {\n+            this.memorySegment = requireNonNull(memorySegment);\n+        }\n+\n+        int x() {\n+            return (int) xVH.get(memorySegment, 0L);\n+        }\n+\n+        int y() {\n+            return (int) yVH.get(memorySegment, 0L);\n+        }\n+\n+        void x(int x) {\n+            xVH.set(memorySegment, 0L, x);\n+        }\n+\n+        void y(int y) {\n+            yVH.set(memorySegment, 0L, y);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Point {x=\" + x() + \", y=\" + y() + \"}\";\n+        }\n+    }\n+\n+    private static String platformLineSeparated(String s) {\n+        return s.lines()\n+                .collect(joining(System.lineSeparator()));\n+    }\n+\n+    private static <T> T testWithFreshMemorySegment(long size,\n+                                                    Function<MemorySegment, T> mapper) {\n+        try (final Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n+            return mapper.apply(segment);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":301,"deletions":0,"binary":false,"changes":301,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -211,1 +209,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -213,1 +211,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -215,1 +213,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -217,1 +215,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -219,1 +217,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -221,1 +219,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -223,1 +221,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -226,1 +224,1 @@\n-                (base) -> checkBytes(base, bytes, byteHandle::get, bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n+                (base) -> checkBytes(base, bytes, (addr, pos) -> byteHandle.get(addr, 0L, pos), bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n@@ -228,1 +226,1 @@\n-                (base) -> checkBytes(base, chars, charHandle::get, ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n+                (base) -> checkBytes(base, chars, (addr, pos) -> charHandle.get(addr, 0L, pos), ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n@@ -230,1 +228,1 @@\n-                (base) -> checkBytes(base, shorts, shortHandle::get, ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n+                (base) -> checkBytes(base, shorts, (addr, pos) -> shortHandle.get(addr, 0L, pos), ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n@@ -232,1 +230,1 @@\n-                (base) -> checkBytes(base, ints, intHandle::get, ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n+                (base) -> checkBytes(base, ints, (addr, pos) -> intHandle.get(addr, 0L, pos), ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n@@ -234,1 +232,1 @@\n-                (base) -> checkBytes(base, floats, floatHandle::get, ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n+                (base) -> checkBytes(base, floats, (addr, pos) -> floatHandle.get(addr, 0L, pos), ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n@@ -236,1 +234,1 @@\n-                (base) -> checkBytes(base, longs, longHandle::get, ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n+                (base) -> checkBytes(base, longs, (addr, pos) -> longHandle.get(addr, 0L, pos), ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n@@ -238,1 +236,1 @@\n-                (base) -> checkBytes(base, doubles, doubleHandle::get, ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n+                (base) -> checkBytes(base, doubles, (addr, pos) -> doubleHandle.get(addr, 0L, pos), ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -147,1 +145,1 @@\n-        addDefaultMapping(VarHandle.class, MethodHandles.memorySegmentViewVarHandle(JAVA_INT));\n+        addDefaultMapping(VarHandle.class, JAVA_INT.varHandle());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestOfBufferIssue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestScope\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestScope {\n+\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n+    }\n+\n+    @Test\n+    public void testDifferentArrayScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofArray(new byte[10]).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofArray(new byte[10]).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentBufferScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentArenaScope() {\n+        MemorySegment.Scope scope1 = Arena.ofAuto().allocate(10).scope();\n+        MemorySegment.Scope scope2 = Arena.ofAuto().allocate(10).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testSameArrayScope() {\n+        byte[] arr = new byte[10];\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofArray(arr).scope());\n+        ByteBuffer buf = ByteBuffer.wrap(arr);\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofArray(arr));\n+    }\n+\n+    @Test\n+    public void testSameBufferScope() {\n+        ByteBuffer buf = ByteBuffer.allocateDirect(10);\n+        assertEquals(MemorySegment.ofBuffer(buf).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofBuffer(buf));\n+    }\n+\n+    @Test\n+    public void testSameArenaScope() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment1 = arena.allocate(10);\n+            MemorySegment segment2 = arena.allocate(10);\n+            assertEquals(segment1.scope(), segment2.scope());\n+            testDerivedBufferScope(segment1);\n+        }\n+    }\n+\n+    @Test\n+    public void testSameNativeScope() {\n+        MemorySegment segment1 = MemorySegment.ofAddress(42);\n+        MemorySegment segment2 = MemorySegment.ofAddress(43);\n+        assertEquals(segment1.scope(), segment2.scope());\n+        assertEquals(segment1.scope(), segment2.reinterpret(10).scope());\n+        assertNotEquals(segment1.scope(), Arena.global().scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    @Test\n+    public void testSameLookupScope() {\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        MemorySegment segment1 = loaderLookup.find(\"f\").get();\n+        MemorySegment segment2 = loaderLookup.find(\"c\").get();\n+        assertEquals(segment1.scope(), segment2.scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    void testDerivedBufferScope(MemorySegment segment) {\n+        ByteBuffer buffer = segment.asByteBuffer();\n+        MemorySegment.Scope expectedScope = segment.scope();\n+        assertEquals(MemorySegment.ofBuffer(buffer).scope(), expectedScope);\n+        \/\/ buffer slices should have same scope\n+        ByteBuffer slice = buffer.slice(0, 2);\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(slice).scope());\n+        \/\/ buffer views should have same scope\n+        IntBuffer view = buffer.asIntBuffer();\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(view).scope());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestScope.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -125,15 +123,15 @@\n-        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n-        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, 1L), \"Arena::allocateArray\/size\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"Arena::allocateArray\/byte\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateArray\/char\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateArray\/short\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateArray\/int\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateArray\/float\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateArray\/long\");\n-        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateArray\/double\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, 1L), \"Arena::allocate\/size\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(JAVA_BYTE, new byte[]{0}), \"Arena::allocateFrom\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateFrom\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateFrom\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateFrom\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateFrom\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateFrom\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateFrom(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateFrom\/double\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n@@ -85,1 +83,1 @@\n-                        assertEquals(value, handle.get(address));\n+                        assertEquals(value, handle.get(address, 0L));\n@@ -151,1 +149,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE, -1);\n+        allocator.allocate(ValueLayout.JAVA_BYTE, -1);\n@@ -156,1 +154,1 @@\n-        allocator.allocateArray(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n+        allocator.allocate(ValueLayout.JAVA_LONG,  Long.MAX_VALUE);\n@@ -172,1 +170,1 @@\n-                return null;\n+                return MemorySegment.NULL;\n@@ -176,1 +174,1 @@\n-            public MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+            public MemorySegment allocateFrom(ValueLayout elementLayout, MemorySegment source, ValueLayout sourceElementLayout, long sourceOffset, long elementCount) {\n@@ -178,2 +176,2 @@\n-                return null;\n-            };\n+                return MemorySegment.NULL;\n+            }\n@@ -181,7 +179,7 @@\n-        allocator.allocateArray(ValueLayout.JAVA_BYTE);\n-        allocator.allocateArray(ValueLayout.JAVA_SHORT);\n-        allocator.allocateArray(ValueLayout.JAVA_CHAR);\n-        allocator.allocateArray(ValueLayout.JAVA_INT);\n-        allocator.allocateArray(ValueLayout.JAVA_FLOAT);\n-        allocator.allocateArray(ValueLayout.JAVA_LONG);\n-        allocator.allocateArray(ValueLayout.JAVA_DOUBLE);\n+        allocator.allocateFrom(ValueLayout.JAVA_BYTE);\n+        allocator.allocateFrom(ValueLayout.JAVA_SHORT);\n+        allocator.allocateFrom(ValueLayout.JAVA_CHAR);\n+        allocator.allocateFrom(ValueLayout.JAVA_INT);\n+        allocator.allocateFrom(ValueLayout.JAVA_FLOAT);\n+        allocator.allocateFrom(ValueLayout.JAVA_LONG);\n+        allocator.allocateFrom(ValueLayout.JAVA_DOUBLE);\n@@ -196,1 +194,0 @@\n-\n@@ -207,1 +204,1 @@\n-        allocator.allocateUtf8String(\"Hello\");\n+        allocator.allocateFrom(\"Hello\");\n@@ -255,1 +252,1 @@\n-                    (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfByte) SegmentAllocator::allocateFrom,\n@@ -258,1 +255,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -261,1 +258,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -265,1 +262,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -268,1 +265,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -271,1 +268,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -274,1 +271,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -277,1 +274,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -281,1 +278,1 @@\n-                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocateFrom,\n@@ -284,1 +281,1 @@\n-                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocateFrom,\n@@ -288,1 +285,1 @@\n-                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocateFrom,\n@@ -291,1 +288,1 @@\n-                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocateFrom,\n@@ -294,1 +291,1 @@\n-                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocateFrom,\n@@ -297,1 +294,1 @@\n-                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocateFrom,\n@@ -300,1 +297,1 @@\n-                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocateFrom,\n@@ -311,1 +308,1 @@\n-                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateFrom,\n@@ -314,1 +311,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -317,1 +314,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -321,1 +318,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -324,1 +321,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -327,1 +324,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -330,1 +327,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n@@ -334,1 +331,1 @@\n-                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateFrom,\n@@ -337,1 +334,1 @@\n-                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateFrom,\n@@ -341,1 +338,1 @@\n-                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateFrom,\n@@ -344,1 +341,1 @@\n-                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateFrom,\n@@ -347,1 +344,1 @@\n-                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateFrom,\n@@ -350,1 +347,1 @@\n-                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateFrom,\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":43,"deletions":46,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-            return MethodHandles.memorySegmentViewVarHandle(layout);\n+            return layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -33,0 +32,1 @@\n+import org.testng.SkipException;\n@@ -47,0 +47,3 @@\n+        if (s1.kind != s2.kind) {\n+            throw new SkipException(\"Slices of different segment kinds\");\n+        }\n@@ -49,1 +52,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -56,9 +59,0 @@\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that offset from s1 to s2 fails\n-            try {\n-                long offset = s1.segment.segmentOffset(s2.segment);\n-                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n-                fail(\"offset unexpectedly passed!\");\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n-            }\n@@ -67,1 +61,1 @@\n-            long offset = s1.segment.segmentOffset(s2.segment);\n+            long offset = s1.offset(s2);\n@@ -119,0 +113,4 @@\n+\n+        long offset(SegmentSlice that) {\n+            return that.segment.address() - segment.address();\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @requires vm.bits == 64\n@@ -87,1 +86,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -98,1 +97,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -266,1 +265,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -154,1 +153,1 @@\n-        return (int)intHandle.getVolatile(base);\n+        return (int)intHandle.getVolatile(base, 0L);\n@@ -158,1 +157,1 @@\n-        intHandle.setVolatile(base, value);\n+        intHandle.setVolatile(base, 0L, value);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n- * @enablePreview\n@@ -56,1 +55,1 @@\n-                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));\n+                    VH_ALL.set(segment, 0L, i, j, (int)j + 1 + ((int)i * 5));\n@@ -68,2 +67,2 @@\n-            assertThrows(() -> handle.get(segment, lo, 0));\n-            assertThrows(() -> handle.get(segment, 0, hi));\n+            assertThrows(() -> handle.get(segment, 0L, lo, 0));\n+            assertThrows(() -> handle.get(segment, 0L, 0, hi));\n@@ -77,1 +76,1 @@\n-                int x = (int) handle.get(segment, i, j);\n+                int x = (int) handle.get(segment, 0L, i, j);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -47,2 +46,0 @@\n-    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-\n@@ -59,1 +56,1 @@\n-                INT_HANDLE.set(segment, (long) i, i);\n+                segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -86,1 +83,1 @@\n-            INT_HANDLE.set(segment, (long) i, i);\n+            segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -163,1 +160,1 @@\n-        return acc + (int)INT_HANDLE.get(segment, 0L);\n+        return acc + segment.getAtIndex(ValueLayout.JAVA_INT, 0);\n@@ -170,1 +167,1 @@\n-            sum += (int)INT_HANDLE.get(segment, (long)i);\n+            sum += segment.getAtIndex(ValueLayout.JAVA_INT, i);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n@@ -26,0 +28,3 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n@@ -27,0 +32,15 @@\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.reflect.Field;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n@@ -28,0 +48,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -29,0 +50,2 @@\n+\n+import static java.lang.foreign.ValueLayout.*;\n@@ -33,2 +56,1 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @modules java.base\/jdk.internal.foreign\n@@ -41,3 +63,251 @@\n-    public void testStrings(String testString, int expectedByteLength) {\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment text = arena.allocateUtf8String(testString);\n+    public void testStrings(String testString) {\n+        for (Charset charset : Charset.availableCharsets().values()) {\n+            if (isStandard(charset)) {\n+                for (Arena arena : arenas()) {\n+                    try (arena) {\n+                        MemorySegment text = arena.allocateFrom(testString, charset);\n+\n+                        int terminatorSize = \"\\0\".getBytes(charset).length;\n+                        if (charset == StandardCharsets.UTF_16) {\n+                            terminatorSize -= 2; \/\/ drop BOM\n+                        }\n+                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+\n+                        int expectedByteLength =\n+                                testString.getBytes(charset).length +\n+                                        terminatorSize;\n+\n+                        assertEquals(text.byteSize(), expectedByteLength);\n+\n+                        String roundTrip = text.getString(0, charset);\n+                        if (charset.newEncoder().canEncode(testString)) {\n+                            assertEquals(roundTrip, testString);\n+                        }\n+                    }\n+                }\n+            } else {\n+                assertThrows(UnsupportedOperationException.class, () -> Arena.global().allocateFrom(testString, charset));\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsHeap(String testString) {\n+        for (Charset charset : singleByteCharsets()) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset);\n+                    text = toHeapSegment(text);\n+\n+                    int expectedByteLength =\n+                            testString.getBytes(charset).length + 1;\n+\n+                    assertEquals(text.byteSize(), expectedByteLength);\n+\n+                    String roundTrip = text.getString(0, charset);\n+                    if (charset.newEncoder().canEncode(testString)) {\n+                        assertEquals(roundTrip, testString);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    MemorySegment toHeapSegment(MemorySegment segment) {\n+        var heapArray = segment.toArray(JAVA_BYTE);\n+        return MemorySegment.ofArray(heapArray);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unboundedSegment(String testString) {\n+        testModifyingSegment(testString,\n+                standardCharsets(),\n+                s -> s.reinterpret(Long.MAX_VALUE),\n+                UnaryOperator.identity());\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unalignedSegmentSingleByte(String testString) {\n+        testModifyingSegment(testString,\n+                singleByteCharsets(),\n+                s -> s.byteSize() > 1 ? s.asSlice(1) : s,\n+                s -> s.length() > 0 ? s.substring(1) : s);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expandedSegment(String testString) {\n+        try (var arena = Arena.ofConfined()) {\n+            for (int i = 0; i < Long.BYTES; i++) {\n+                int extra = i;\n+                testModifyingSegment(testString,\n+                        \/\/ Single byte charsets\n+                        standardCharsets(),\n+                        s -> {\n+                            var s2 = arena.allocate(s.byteSize() + extra);\n+                            MemorySegment.copy(s, 0, s2, 0, s.byteSize());\n+                            return s2;\n+                        },\n+                        UnaryOperator.identity());\n+            }\n+        }\n+    }\n+\n+    public void testModifyingSegment(String testString,\n+                                     List<Charset> charsets,\n+                                     UnaryOperator<MemorySegment> segmentMapper,\n+                                     UnaryOperator<String> stringMapper) {\n+        for (var charset : charsets) {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment text = arena.allocateFrom(testString, charset);\n+                text = segmentMapper.apply(text);\n+                String roundTrip = text.getString(0, charset);\n+                String expected = stringMapper.apply(testString);\n+                if (charset.newEncoder().canEncode(testString)) {\n+                    assertEquals(roundTrip, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test()\n+    public void testPeculiarContentSingleByte() {\n+        Random random = new Random(42);\n+        for (int len = 7; len < 71; len++) {\n+            for (var arena : arenas()) {\n+                try (arena) {\n+                    var segment = arena.allocate(len, 1);\n+                    var arr = new byte[len];\n+                    random.nextBytes(arr);\n+                    segment.copyFrom(MemorySegment.ofArray(arr));\n+                    int terminatorIndex = random.nextInt(len);\n+                    segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n+                    for (Charset charset : singleByteCharsets()) {\n+                        var s = segment.getString(0, charset);\n+                        var ref = referenceImpl(segment, 0, charset);\n+                        assertEquals(s, ref);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testOffset(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment inSegment = arena.allocateFrom(testString, charset);\n+                    for (int i = 0; i < 3; i++) {\n+                        String actual = inSegment.getString(i, charset);\n+                        assertEquals(actual, testString.substring(i));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test()\n+    public void testJumboSegment() {\n+        testWithJumboSegment(\"testJumboSegment\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            String big = segment.getString(100);\n+        });\n+    }\n+\n+    @Test()\n+    public void testStringLargerThanMaxInt() {\n+        testWithJumboSegment(\"testStringLargerThanMaxInt\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            assertThrows(IllegalArgumentException.class, () -> {\n+                segment.getString(0);\n+            });\n+        });\n+    }\n+\n+    private static void testWithJumboSegment(String testName, Consumer<MemorySegment> tester) {\n+        Path path = Paths.get(\"mapped_file\");\n+        try {\n+            \/\/ Relly try to make sure the file is deleted after use\n+            path.toFile().deleteOnExit();\n+            deleteIfExistsOrThrow(path);\n+            try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"rw\")) {\n+                FileChannel fc = raf.getChannel();\n+                try (Arena arena = Arena.ofConfined()) {\n+                    var segment = fc.map(FileChannel.MapMode.READ_WRITE, 0L, (long) Integer.MAX_VALUE + 100, arena);\n+                    tester.accept(segment);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        } catch (OutOfMemoryError oome) {\n+            \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n+            System.out.println(\"Skipping test because of insufficient memory: \" + testName);\n+        } finally {\n+            deleteIfExistsOrThrow(path);\n+        }\n+    }\n+\n+    private static void deleteIfExistsOrThrow(Path file) {\n+        try {\n+            Files.deleteIfExists(file);\n+        } catch (IOException ioe) {\n+            throw new AssertionError(\"Unable to delete mapped file: \" + file);\n+        }\n+    }\n+\n+    private static final MemoryLayout CHAR_POINTER = ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final MethodHandle STRCAT = LINKER.downcallHandle(\n+            LINKER.defaultLookup().find(\"strcat\").orElseThrow(),\n+            FunctionDescriptor.of(CHAR_POINTER, CHAR_POINTER, CHAR_POINTER));\n+\n+    @Test(dataProvider = \"strings\")\n+    public void nativeSegFromNativeCall(String testString) {\n+        String addition = \"123\";\n+        try (var arena = Arena.ofConfined()) {\n+            try {\n+                var testStringSegment = arena.allocateFrom(testString);\n+                var additionSegment = arena.allocateFrom(addition);\n+                var destination = arena.allocate(testStringSegment.byteSize() + additionSegment.byteSize() - 1);\n+                destination.copyFrom(testStringSegment);\n+\n+                MemorySegment concatenation = (MemorySegment) STRCAT.invokeExact(destination, arena.allocateFrom(addition));\n+                var actual = concatenation.getString(0);\n+                assertEquals(actual, testString + addition);\n+            } catch (Throwable t) {\n+                throw new AssertionError(t);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void segmentationFault() {\n+        for (int i = 1; i < 18; i++) {\n+            var size = 1 << i;\n+            try (var arena = Arena.ofConfined()) {\n+                var seg = arena.allocate(size, size);\n+                seg.fill((byte) 1);\n+                try {\n+                    var s = seg.getString(0);\n+                    System.out.println(\"s.length() = \" + s.length());\n+                } catch (IndexOutOfBoundsException e) {\n+                    \/\/ we will end up here if strlen finds a zero outside the MS\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final int TEST_LENGTH_MAX = 277;\n+\n+    private Random deterministicRandom() {\n+        return new Random(42);\n+    }\n@@ -45,1 +315,47 @@\n-            assertEquals(text.byteSize(), expectedByteLength);\n+    @Test\n+    public void chunked_strlen_byte() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew++) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate(len + 1 + skew)\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        byte value;\n+                        while ((value = (byte) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_BYTE, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_BYTE, len, (byte) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenByte(segment, j);\n+                        assertEquals(actual, len - j);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void chunked_strlen_short() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Short.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Short.BYTES + skew, JAVA_SHORT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        short value;\n+                        while ((value = (short) random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_SHORT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_SHORT, len, (short) 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.chunkedStrlenShort(segment, j * Short.BYTES);\n+                        assertEquals(actual, (len - j) * Short.BYTES);\n+                    }\n+                }\n+            }\n+        }\n+    }\n@@ -47,2 +363,21 @@\n-            String roundTrip = text.getUtf8String(0);\n-            assertEquals(roundTrip, testString);\n+    @Test\n+    public void strlen_int() {\n+        Random random = deterministicRandom();\n+        for (int skew = 0; skew < Long.BYTES; skew += Integer.BYTES) {\n+            for (int len = 0; len < TEST_LENGTH_MAX; len++) {\n+                try (var arena = Arena.ofConfined()) {\n+                    var segment = arena.allocate((len + 1) * Integer.BYTES + skew, JAVA_INT.byteAlignment())\n+                            .asSlice(skew);\n+                    for (int i = 0; i < len; i++) {\n+                        int value;\n+                        while ((value = random.nextInt()) == 0) {\n+                        }\n+                        segment.setAtIndex(JAVA_INT, i, value);\n+                    }\n+                    segment.setAtIndex(JAVA_INT, len, 0);\n+                    for (int j = 0; j < len; j++) {\n+                        int actual = StringSupport.strlenInt(segment, j * Integer.BYTES);\n+                        assertEquals(actual, (len - j) * Integer.BYTES);\n+                    }\n+                }\n+            }\n@@ -54,8 +389,18 @@\n-        return new Object[][] {\n-            { \"testing\",               8 },\n-            { \"\",                      1 },\n-            { \"X\",                     2 },\n-            { \"12345\",                 6 },\n-            { \"yen \\u00A5\",            7 }, \/\/ in UTF-8 2 bytes: 0xC2 0xA5\n-            { \"snowman \\u26C4\",       12 }, \/\/ in UTF-8 three bytes: 0xE2 0x9B 0x84\n-            { \"rainbow \\uD83C\\uDF08\", 13 }  \/\/ in UTF-8 four bytes: 0xF0 0x9F 0x8C 0x88\n+        return new Object[][]{\n+                {\"testing\"},\n+                {\"\"},\n+                {\"X\"},\n+                {\"12345\"},\n+                {\"yen \\u00A5\"},\n+                {\"snowman \\u26C4\"},\n+                {\"rainbow \\uD83C\\uDF08\"},\n+                {\"0\"},\n+                {\"01\"},\n+                {\"012\"},\n+                {\"0123\"},\n+                {\"01234\"},\n+                {\"012345\"},\n+                {\"0123456\"},\n+                {\"01234567\"},\n+                {\"012345678\"},\n+                {\"0123456789\"}\n@@ -64,0 +409,101 @@\n+\n+    public static boolean containsOnlyRegularCharacters(String s) {\n+        return s.chars()\n+                .allMatch(c -> Character.isLetterOrDigit((char) c));\n+    }\n+\n+    boolean isStandard(Charset charset) {\n+        for (Field standardCharset : StandardCharsets.class.getDeclaredFields()) {\n+            try {\n+                if (standardCharset.get(null) == charset) {\n+                    return true;\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    List<Charset> standardCharsets() {\n+        return Charset.availableCharsets().values().stream()\n+                .filter(this::isStandard)\n+                .toList();\n+    }\n+\n+    List<Charset> singleByteCharsets() {\n+        return Arrays.asList(StandardCharsets.UTF_8, StandardCharsets.ISO_8859_1, StandardCharsets.US_ASCII);\n+    }\n+\n+    static String referenceImpl(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n+        byte[] bytes = new byte[(int) len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int) len);\n+        return new String(bytes, charset);\n+    }\n+\n+    \/\/ Reference implementation\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static List<Arena> arenas() {\n+        return Arrays.asList(\n+                Arena.ofConfined(),          \/\/ Native memory\n+                new HeapArena(byte.class),   \/\/ Heap memory backed by a byte array\n+                new HeapArena(short.class),  \/\/ Heap memory backed by a short array\n+                new HeapArena(int.class),    \/\/ Heap memory backed by an int array\n+                new HeapArena(long.class));  \/\/ Heap memory backed by a long array\n+    }\n+\n+    private static final class HeapArena implements Arena {\n+\n+        private static final int ELEMENT_SIZE = 1_000;\n+\n+        private final MemorySegment backingSegment;\n+        private final SegmentAllocator allocator;\n+\n+        public HeapArena(Class<?> type) {\n+            backingSegment = switch (type) {\n+                case Class<?> c when byte.class.equals(c) -> MemorySegment.ofArray(new byte[ELEMENT_SIZE]);\n+                case Class<?> c when short.class.equals(c) ->\n+                        MemorySegment.ofArray(new short[ELEMENT_SIZE]);\n+                case Class<?> c when int.class.equals(c) ->\n+                        MemorySegment.ofArray(new int[ELEMENT_SIZE]);\n+                case Class<?> c when long.class.equals(c) ->\n+                        MemorySegment.ofArray(new long[ELEMENT_SIZE]);\n+                default -> throw new IllegalArgumentException(type.toString());\n+            };\n+            allocator = SegmentAllocator.slicingAllocator(backingSegment);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return allocator.allocate(byteSize, byteAlignment);\n+        }\n+\n+        @Override\n+        public MemorySegment.Scope scope() {\n+            return backingSegment.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ Do nothing\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"HeapArena{\" +\n+                    \"type=\" + backingSegment.heapBase().orElseThrow().getClass().getName() +\n+                    '}';\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":462,"deletions":16,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -46,1 +45,1 @@\n-        int v = (int)INT_HANDLE.get(\"string\");\n+        int v = (int)INT_HANDLE.get(\"string\", 0L);\n@@ -57,2 +56,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            String address = (String)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            String address = (String)ADDR_HANDLE.get(s, 0L);\n@@ -66,1 +65,1 @@\n-            ADDR_HANDLE.set(s, \"string\");\n+            ADDR_HANDLE.set(s, 0L, \"string\");\n@@ -73,2 +72,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            int address = (int)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            int address = (int)ADDR_HANDLE.get(s, 0L);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -51,9 +49,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n-\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -54,1 +52,0 @@\n-    static final Linker LINKER = Linker.nativeLinker();\n@@ -57,8 +54,0 @@\n-    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n-        C_POINTER.withName(\"p0\"),\n-        C_DOUBLE.withName(\"p1\"),\n-        C_INT.withName(\"p2\"),\n-        MemoryLayout.paddingLayout(4)\n-    );\n-\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -43,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -54,1 +53,0 @@\n-    static final VarHandle VH_IntArray = C_INT.arrayElementVarHandle();\n@@ -85,1 +83,1 @@\n-                VH_IntArray.set(argIDs, (long) i, args.get(i).id.ordinal());\n+                argIDs.setAtIndex(ValueLayout.JAVA_INT, i, args.get(i).id.ordinal());\n@@ -200,1 +198,1 @@\n-            VH_writeback.set(seg, addr);\n+            VH_writeback.set(seg, 0L, addr);\n@@ -203,1 +201,1 @@\n-            VH_argIDs.set(seg, addr);\n+            VH_argIDs.set(seg, 0L, addr);\n@@ -222,1 +220,3 @@\n-            return new Arg(id, layout, value, layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET));\n+            MethodHandle getterHandle = layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET);\n+            getterHandle = MethodHandles.insertArguments(getterHandle, 1, 0L); \/\/ align signature with getter for structs\n+            return new Arg(id, layout, value, getterHandle);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n@@ -47,1 +46,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE);\n+        VarHandle vh = ValueLayout.JAVA_BYTE.varHandle();\n@@ -56,1 +55,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(4));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(4).varHandle();\n@@ -66,1 +65,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(2));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(2).varHandle();\n@@ -76,2 +75,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.LITTLE_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN).varHandle();\n@@ -87,2 +85,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.BIG_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN).varHandle();\n@@ -103,1 +100,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+        VarHandle vh = ValueLayout.JAVA_INT.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-            \"--enable-preview\",\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,1 +38,0 @@\n- * @enablePreview\n@@ -42,1 +39,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/TestArrayStructs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -66,1 +64,1 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, boolean trivial, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n@@ -70,6 +68,2 @@\n-        List<Linker.Option> options = new ArrayList<>();\n-        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n-        if (testCase.trivial()) {\n-            options.add(Linker.Option.isTrivial());\n-        }\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), options.toArray(Linker.Option[]::new));\n+        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n@@ -88,1 +82,1 @@\n-            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            int savedErrno = (int) errnoHandle.get(saveSeg, 0L);\n@@ -108,4 +102,0 @@\n-    interface CaseAdder {\n-      void addCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck);\n-    }\n-\n@@ -115,4 +105,0 @@\n-        CaseAdder adder = (nativeTarget, nativeDesc, threadLocalName, resultCheck) -> {\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, false, threadLocalName, resultCheck));\n-          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, true, threadLocalName, resultCheck));\n-        };\n@@ -120,16 +106,16 @@\n-        adder.addCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {});\n-        adder.addCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42));\n-        adder.addCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0));\n-\n-        structCase(adder, \"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L));\n-        structCase(adder, \"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L));\n-        structCase(adder, \"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                         JAVA_LONG.withName(\"y\"), 42L,\n-                                         JAVA_LONG.withName(\"z\"), 42L));\n-        structCase(adder, \"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D));\n-        structCase(adder, \"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D));\n-        structCase(adder, \"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                         JAVA_DOUBLE.withName(\"z\"), 42D));\n+        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n+        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n+        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n+\n+        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n+        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                           JAVA_LONG.withName(\"y\"), 42L)));\n+        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                            JAVA_LONG.withName(\"y\"), 42L,\n+                                            JAVA_LONG.withName(\"z\"), 42L)));\n+        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n+        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n+        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n+                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n@@ -138,2 +124,2 @@\n-            adder.addCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {});\n-            adder.addCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {});\n+            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n+            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n@@ -145,1 +131,1 @@\n-    static void structCase(CaseAdder adder, String name, Map<MemoryLayout, Object> fields) {\n+    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n@@ -153,1 +139,1 @@\n-            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+            check = check.andThen(o -> assertEquals(fieldHandle.get(o, 0L), value));\n@@ -156,1 +142,1 @@\n-        adder.addCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":25,"deletions":39,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -29,1 +28,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -33,1 +31,1 @@\n- *        org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ *        org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\n@@ -38,1 +36,0 @@\n-import java.util.ArrayList;\n@@ -60,69 +57,1 @@\n-public class TestEnableNativeAccess {\n-\n-    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n-\n-    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n-    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n-    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n-    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n-    static final String UNNAMED = \"org.openjdk.foreigntest.PanamaMainUnnamedModule\";\n-\n-    \/**\n-     * Represents the expected result of a test.\n-     *\/\n-    static final class Result {\n-        private final boolean success;\n-        private final List<String> expectedOutput = new ArrayList<>();\n-        private final List<String> notExpectedOutput = new ArrayList<>();\n-\n-        Result(boolean success) {\n-            this.success = success;\n-        }\n-\n-        Result expect(String msg) {\n-            expectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        Result doNotExpect(String msg) {\n-            notExpectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        boolean shouldSucceed() {\n-            return success;\n-        }\n-\n-        Stream<String> expectedOutput() {\n-            return expectedOutput.stream();\n-        }\n-\n-        Stream<String> notExpectedOutput() {\n-            return notExpectedOutput.stream();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = (success) ? \"success\" : \"failure\";\n-            for (String msg : expectedOutput) {\n-                s += \"\/\" + msg;\n-            }\n-            return s;\n-        }\n-    }\n-\n-    static Result success() {\n-        return new Result(true);\n-    }\n-\n-    static Result successNoWarning() {\n-        return success().doNotExpect(\"WARNING\");\n-    }\n-\n-    static Result successWithWarning(String moduleName) {\n-        return success().expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n-    }\n-\n-    static Result failWithWarning(String expectedOutput) {\n-        return new Result(false).expect(expectedOutput).expect(\"WARNING\");\n-    }\n+public class TestEnableNativeAccess extends TestEnableNativeAccessBase {\n@@ -153,15 +82,0 @@\n-    \/**\n-     * Checks an expected result with the output captured by the given\n-     * OutputAnalyzer.\n-     *\/\n-    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n-        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n-        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n-        int exitValue = outputAnalyzer.getExitValue();\n-        if (expectedResult.shouldSucceed()) {\n-            assertTrue(exitValue == 0);\n-        } else {\n-            assertTrue(exitValue != 0);\n-        }\n-    }\n-\n@@ -179,2 +93,2 @@\n-        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, cls, action)\n-                : Stream.of(\"--enable-preview\", \"-p\", MODULE_PATH, \"-m\", cls, action);\n+        Stream<String> s2 = cls.equals(UNNAMED) ? Stream.of(\"-p\", MODULE_PATH, cls, action)\n+                : Stream.of(\"-p\", MODULE_PATH, \"-m\", cls, action);\n@@ -202,1 +116,1 @@\n-        assertTrue(count(output1, \"WARNING\") == 3);  \/\/ 3 on first access, none on subsequent access\n+        assertTrue(count(output1, \"WARNING\") == 4);  \/\/ 4 on first access, none on subsequent access\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":5,"deletions":91,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestEnableNativeAccessBase {\n+    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n+\n+    static final String PANAMA_MAIN_CLS = \"org.openjdk.foreigntest.PanamaMainDirect\";\n+    static final String PANAMA_MAIN = \"panama_module\/\" + PANAMA_MAIN_CLS;\n+    static final String PANAMA_REFLECTION_CLS = \"org.openjdk.foreigntest.PanamaMainReflection\";\n+    static final String PANAMA_REFLECTION = \"panama_module\/\" + PANAMA_REFLECTION_CLS;\n+    static final String PANAMA_INVOKE_CLS = \"org.openjdk.foreigntest.PanamaMainInvoke\";\n+    static final String PANAMA_INVOKE = \"panama_module\/\" + PANAMA_INVOKE_CLS;\n+    static final String PANAMA_JNI_CLS = \"org.openjdk.foreigntest.PanamaMainJNI\";\n+    static final String PANAMA_JNI = \"panama_module\/\" + PANAMA_JNI_CLS;\n+    static final String UNNAMED = \"org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\";\n+\n+    \/**\n+     * Represents the expected result of a test.\n+     *\/\n+    static final class Result {\n+        private final boolean success;\n+        private final List<String> expectedOutput = new ArrayList<>();\n+        private final List<String> notExpectedOutput = new ArrayList<>();\n+\n+        Result(boolean success) {\n+            this.success = success;\n+        }\n+\n+        Result expect(String msg) {\n+            expectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        Result doNotExpect(String msg) {\n+            notExpectedOutput.add(msg);\n+            return this;\n+        }\n+\n+        boolean shouldSucceed() {\n+            return success;\n+        }\n+\n+        Stream<String> expectedOutput() {\n+            return expectedOutput.stream();\n+        }\n+\n+        Stream<String> notExpectedOutput() {\n+            return notExpectedOutput.stream();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String s = (success) ? \"success\" : \"failure\";\n+            for (String msg : expectedOutput) {\n+                s += \"\/\" + msg;\n+            }\n+            return s;\n+        }\n+\n+    }\n+\n+    static Result success() {\n+        return new Result(true);\n+    }\n+\n+    static Result successNoWarning() {\n+        return success().doNotExpect(\"WARNING\");\n+    }\n+\n+    static Result successWithWarning(String moduleName) {\n+        return success().expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n+    }\n+\n+    static Result failWithWarning(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput).expect(\"WARNING\");\n+    }\n+\n+    static Result failWithError(String expectedOutput) {\n+        return new Result(false).expect(expectedOutput);\n+    }\n+\n+    \/**\n+     * Checks an expected result with the output captured by the given\n+     * OutputAnalyzer.\n+     *\/\n+    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n+        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n+        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n+        int exitValue = outputAnalyzer.getExitValue();\n+        if (expectedResult.shouldSucceed()) {\n+            assertTrue(exitValue == 0);\n+        } else {\n+            assertTrue(exitValue != 0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessBase.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -40,1 +38,0 @@\n-import java.util.stream.Stream;\n@@ -47,1 +44,0 @@\n-import static org.testng.Assert.*;\n@@ -50,64 +46,1 @@\n-public class TestEnableNativeAccessDynamic {\n-\n-    static final String MODULE_PATH = System.getProperty(\"jdk.module.path\");\n-\n-    static final String PANAMA_MAIN = \"panama_module\/org.openjdk.foreigntest.PanamaMainDirect\";\n-    static final String PANAMA_REFLECTION = \"panama_module\/org.openjdk.foreigntest.PanamaMainReflection\";\n-    static final String PANAMA_INVOKE = \"panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\";\n-    static final String PANAMA_JNI = \"panama_module\/org.openjdk.foreigntest.PanamaMainJNI\";\n-\n-    \/**\n-     * Represents the expected result of a test.\n-     *\/\n-    static final class Result {\n-        private final boolean success;\n-        private final List<String> expectedOutput = new ArrayList<>();\n-        private final List<String> notExpectedOutput = new ArrayList<>();\n-\n-        Result(boolean success) {\n-            this.success = success;\n-        }\n-\n-        Result expect(String msg) {\n-            expectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        Result doNotExpect(String msg) {\n-            notExpectedOutput.add(msg);\n-            return this;\n-        }\n-\n-        boolean shouldSucceed() {\n-            return success;\n-        }\n-\n-        Stream<String> expectedOutput() {\n-            return expectedOutput.stream();\n-        }\n-\n-        Stream<String> notExpectedOutput() {\n-            return notExpectedOutput.stream();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String s = (success) ? \"success\" : \"failure\";\n-            for (String msg : expectedOutput) {\n-                s += \"\/\" + msg;\n-            }\n-            return s;\n-        }\n-    }\n-\n-    static Result success() {\n-        return new Result(true);\n-    }\n-\n-    static Result successNoWarning() {\n-        return success().doNotExpect(\"WARNING\");\n-    }\n-\n-    static Result failWithError(String expectedOutput) {\n-        return new Result(false).expect(expectedOutput);\n-    }\n+public class TestEnableNativeAccessDynamic extends TestEnableNativeAccessBase {\n@@ -134,15 +67,0 @@\n-    \/**\n-     * Checks an expected result with the output captured by the given\n-     * OutputAnalyzer.\n-     *\/\n-    void checkResult(Result expectedResult, OutputAnalyzer outputAnalyzer) {\n-        expectedResult.expectedOutput().forEach(outputAnalyzer::shouldContain);\n-        expectedResult.notExpectedOutput().forEach(outputAnalyzer::shouldNotContain);\n-        int exitValue = outputAnalyzer.getExitValue();\n-        if (expectedResult.shouldSucceed()) {\n-            assertTrue(exitValue == 0);\n-        } else {\n-            assertTrue(exitValue != 0);\n-        }\n-    }\n-\n@@ -158,1 +76,0 @@\n-        list.add(\"--enable-preview\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":1,"deletions":84,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic test for Enable-Native-Access attribute in the\n+ *          manifest of a main application JAR\n+ * @library \/test\/lib\n+ * @requires !vm.musl\n+ *\n+ * @build TestEnableNativeAccessJarManifest\n+ *        panama_module\/*\n+ *        org.openjdk.foreigntest.unnamed.PanamaMainUnnamedModule\n+ * @run testng\/othervm TestEnableNativeAccessJarManifest\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+public class TestEnableNativeAccessJarManifest extends TestEnableNativeAccessBase {\n+\n+    private static final String REINVOKER = \"TestEnableNativeAccessJarManifest$Reinvoker\";\n+\n+    static record Attribute(String name, String value) {}\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testEnableNativeAccessInJarManifest(String action, String cls, Result expectedResult,\n+                                                    List<Attribute> attributes, List<String> vmArgs, List<String> programArgs) throws Exception {\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+        attrs.put(Attributes.Name.MAIN_CLASS, cls);\n+\n+        for (Attribute attrib : attributes) {\n+            attrs.put(new Attributes.Name(attrib.name()), attrib.value());\n+        }\n+\n+        \/\/ create the JAR file with Test1 and Test2\n+        Path jarfile = Paths.get(action + \".jar\");\n+        Files.deleteIfExists(jarfile);\n+\n+        Path classes = Paths.get(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(jarfile, man, classes, Paths.get(cls.replace('.', '\/') + \".class\"));\n+\n+        \/\/ java -jar test.jar\n+        List<String> command = new ArrayList<>(List.of(\n+            \"-Djava.library.path=\" + System.getProperty(\"java.library.path\")\n+        ));\n+        command.addAll(vmArgs);\n+        command.add(\"-jar\");\n+        command.add(jarfile.toString());\n+        command.addAll(programArgs);\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(command.toArray(String[]::new))\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        checkResult(expectedResult, outputAnalyzer);\n+    }\n+\n+    @DataProvider\n+    public Object[][] cases() {\n+        return new Object[][] {\n+            \/\/ simple cases where a jar contains a single main class with no dependencies\n+            { \"panama_no_unnamed_module_native_access\", UNNAMED, successWithWarning(\"ALL-UNNAMED\"),\n+                    List.of(), List.of(), List.of() },\n+            { \"panama_unnamed_module_native_access\", UNNAMED, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")), List.of(), List.of() },\n+            { \"panama_unnamed_module_native_access_invalid\", UNNAMED, failWithError(\"Only ALL-UNNAMED allowed as value for Enable-Native-Access\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"asdf\")), List.of(), List.of() },\n+\n+            \/\/ more complex cases where a jar invokes a module on the module path that does native access\n+            { \"panama_enable_native_access_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_MAIN_CLS) },\n+            { \"panama_enable_native_access_reflection_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_REFLECTION_CLS) },\n+            { \"panama_enable_native_access_invoke_false\", REINVOKER, successWithWarning(\"panama_module\"),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\"),\n+                    List.of(PANAMA_INVOKE_CLS) },\n+\n+            { \"panama_enable_native_access_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_MAIN_CLS) },\n+            { \"panama_enable_native_access_reflection_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_REFLECTION_CLS) },\n+            { \"panama_enable_native_access_invoke_true\", REINVOKER, successNoWarning(),\n+                    List.of(new Attribute(\"Enable-Native-Access\", \"ALL-UNNAMED\")),\n+                    List.of(\"-p\", MODULE_PATH, \"--add-modules=panama_module\", \"--enable-native-access=panama_module\"),\n+                    List.of(PANAMA_INVOKE_CLS) }\n+        };\n+    }\n+\n+    public class Reinvoker {\n+        public static void main(String[] args) throws Throwable {\n+            Class<?> realMainClass = Class.forName(args[0]);\n+            realMainClass.getMethod(\"main\", String[].class).invoke(null, (Object) new String[0]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessJarManifest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.foreigntest;\n+package org.openjdk.foreigntest.unnamed;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/unnamed\/PanamaMainUnnamedModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","status":"renamed"},{"patch":"@@ -39,1 +39,1 @@\n-    Java_org_openjdk_foreigntest_PanamaMainUnnamedModule_nativeLinker0(JNIEnv *env, jclass cls) {\n+    Java_org_openjdk_foreigntest_unnamed_PanamaMainUnnamedModule_nativeLinker0(JNIEnv *env, jclass cls) {\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/unnamed\/libLinkerInvokerUnnamed.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/libLinkerInvokerUnnamed.cpp","status":"renamed"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.foreigntest;\n-\n-import java.lang.foreign.*;\n-\n-public class PanamaMain {\n-   public static void main(String[] args) {\n-       System.out.println(\"Trying to obtain a downcall handle\");\n-       Linker.nativeLinker().downcallHandle(FunctionDescriptor.ofVoid());\n-       System.out.println(\"Got downcall handle\");\n-   }\n-}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+   jthrowable exception;\n@@ -42,0 +43,2 @@\n+    context->exception = (jthrowable) env->NewGlobalRef(env->ExceptionOccurred());\n+    env->ExceptionClear();\n@@ -54,0 +57,3 @@\n+        if (context.exception != nullptr) {\n+            env->Throw(context.exception); \/\/ transfer exception to this thread\n+        }\n@@ -57,0 +63,1 @@\n+        env->DeleteGlobalRef(context.exception);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookupJNI.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/passheapsegment\/TestPassHeapSegment.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestReentrantUpcalls.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -45,2 +43,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -65,2 +61,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -85,2 +79,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCritical\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestCritical extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"Critical\");\n+    }\n+\n+    @Test\n+    public void testEmpty() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.critical());\n+        handle.invokeExact();\n+    }\n+\n+    @Test\n+    public void testIdentity() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.critical());\n+        int result = (int) handle.invokeExact(42);\n+        assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    public void testWithReturnBuffer() throws Throwable {\n+        StructLayout bigLayout = MemoryLayout.structLayout(\n+                C_LONG_LONG.withName(\"x\"),\n+                C_LONG_LONG.withName(\"y\"));\n+\n+        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.critical());\n+        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n+            long x = (long) vhX.get(result, 0L);\n+            assertEquals(x, 10);\n+            long y = (long) vhY.get(result, 0L);\n+            assertEquals(y, 11);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCritical.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library ..\/ \/test\/lib\n+ * @requires jdk.foreign.linker != \"FALLBACK\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestCriticalUpcall\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestCriticalUpcall extends UpcallTestHelper {\n+\n+    @Test\n+    public void testUpcallFailure() throws IOException, InterruptedException {\n+        \/\/ test to see if we catch a trivial downcall doing an upcall\n+        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n+    }\n+\n+    public static class Runner extends NativeTestHelper {\n+        public static void main(String[] args) throws Throwable {\n+            System.loadLibrary(\"Critical\");\n+\n+            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.critical());\n+            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n+            mh.invokeExact(stub);\n+        }\n+\n+        public static void target() {\n+            fail(\"Should not get here\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestCriticalUpcall.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivial\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestTrivial extends NativeTestHelper {\n-\n-    static {\n-        System.loadLibrary(\"Trivial\");\n-    }\n-\n-    @Test\n-    public void testEmpty() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.isTrivial());\n-        handle.invokeExact();\n-    }\n-\n-    @Test\n-    public void testIdentity() throws Throwable {\n-        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.isTrivial());\n-        int result = (int) handle.invokeExact(42);\n-        assertEquals(result, 42);\n-    }\n-\n-    @Test\n-    public void testWithReturnBuffer() throws Throwable {\n-        StructLayout bigLayout = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\"));\n-\n-        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.isTrivial());\n-        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n-        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n-            long x = (long) vhX.get(result);\n-            assertEquals(x, 10);\n-            long y = (long) vhY.get(result);\n-            assertEquals(y, 11);\n-        }\n-    }\n-\n-    @Test\n-    public void testCaptureErrno() throws Throwable {\n-        Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n-        MethodHandle handle = downcallHandle(\"capture_errno\", FunctionDescriptor.ofVoid(C_INT), Linker.Option.isTrivial(), ccs);\n-        StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n-        VarHandle errnoHandle = capturedStateLayout.varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n-        try (Arena arena = Arena.ofConfined()) {\n-            MemorySegment captureSeg = arena.allocate(capturedStateLayout);\n-            handle.invokeExact(captureSeg, 42);\n-            int capturedErrno = (int) errnoHandle.get(captureSeg);\n-            assertEquals(capturedErrno, 42);\n-        }\n-    }\n-\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/ \/test\/lib\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n- * @requires jdk.foreign.linker != \"FALLBACK\"\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivialUpcall\n- *\/\n-\n-import org.testng.annotations.Test;\n-\n-import java.io.IOException;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandle;\n-\n-import static org.testng.Assert.fail;\n-\n-public class TestTrivialUpcall extends UpcallTestHelper {\n-\n-    @Test\n-    public void testUpcallFailure() throws IOException, InterruptedException {\n-        \/\/ test to see if we catch a trivial downcall doing an upcall\n-        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n-    }\n-\n-    public static class Runner extends NativeTestHelper {\n-        public static void main(String[] args) throws Throwable {\n-            System.loadLibrary(\"Trivial\");\n-\n-            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.isTrivial());\n-            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n-            mh.invokeExact(stub);\n-        }\n-\n-        public static void target() {\n-            fail(\"Should not get here\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivialUpcall.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -51,4 +51,0 @@\n-EXPORT void capture_errno(int value) {\n-    errno = value;\n-}\n-\n","filename":"test\/jdk\/java\/foreign\/trivial\/libCritical.c","additions":0,"deletions":4,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/foreign\/trivial\/libTrivial.c","status":"renamed"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -28,1 +27,0 @@\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,4 +41,4 @@\n- * @compile --enable-preview -source ${jdk.version} ImplicitAttach.java\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n- * @run main AttachTest --enable-preview --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n+ * @compile -source ${jdk.version} ImplicitAttach.java\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 1\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 2\n+ * @run main AttachTest --enable-native-access=ALL-UNNAMED ImplicitAttach 4\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/AttachTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n@@ -174,1 +173,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()).varHandle();\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapToMemorySegmentTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -9,3 +9,0 @@\n-\n-# To compile and run tests that use the foreign memory access API\n-enablePreview=true\n","filename":"test\/jdk\/java\/util\/stream\/test\/TEST.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @enablePreview\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromSliceTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public int start;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[1024];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+        start = random.nextInt(1024 - size);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined_slice() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n+        arena.close();\n+        return segment;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromSliceTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocFromTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    SlicingPool pool = new SlicingPool();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+    public byte[] arr;\n+\n+    @Setup\n+    public void setup() {\n+        arr = new byte[size];\n+        Random random = new Random(0);\n+        random.nextBytes(arr);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_malloc_arena() {\n+        MallocArena arena = new MallocArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_pool_arena() {\n+        Arena arena = pool.acquire();\n+        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static class SlicingPool {\n+        final MemorySegment pool = Arena.ofAuto().allocate(1024);\n+        boolean isAcquired = false;\n+\n+        public Arena acquire() {\n+            if (isAcquired) {\n+                throw new IllegalStateException(\"An allocator is already in use\");\n+            }\n+            isAcquired = true;\n+            return new SlicingPoolAllocator();\n+        }\n+\n+        class SlicingPoolAllocator implements Arena {\n+\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicing = SegmentAllocator.slicingAllocator(pool);\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicing.allocate(byteSize, byteAlignment)\n+                        .reinterpret(arena, null);\n+            }\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                isAcquired = false;\n+                arena.close();\n+            }\n+        }\n+    }\n+\n+    public static class MallocArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return CLayouts.allocateMemory(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize))\n+                    .reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(ms.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class AllocTest extends CLayouts {\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    @Param({\"5\", \"20\", \"100\", \"500\", \"1000\"})\n+    public int size;\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public MemorySegment alloc_confined() {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    @Benchmark\n+    public long alloc_calloc_arena() {\n+        CallocArena arena = new CallocArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    @Benchmark\n+    public long alloc_unsafe_arena() {\n+        UnsafeArena arena = new UnsafeArena();\n+        MemorySegment segment = arena.allocate(size);\n+        arena.close();\n+        return segment.address();\n+    }\n+\n+    public static class CallocArena implements Arena {\n+\n+        static final MethodHandle CALLOC = Linker.nativeLinker()\n+                .downcallHandle(\n+                        Linker.nativeLinker().defaultLookup().find(\"calloc\").get(),\n+                        FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG, ValueLayout.JAVA_LONG));\n+\n+        static MemorySegment calloc(long size) {\n+            try {\n+                return (MemorySegment)CALLOC.invokeExact(size, 1L);\n+            } catch (Throwable ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return calloc(byteSize)\n+                    .reinterpret(byteSize, arena, CLayouts::freeMemory);\n+        }\n+    }\n+\n+    public static class UnsafeArena implements Arena {\n+\n+        final Arena arena = Arena.ofConfined();\n+\n+        @Override\n+        public Scope scope() {\n+            return arena.scope();\n+        }\n+\n+        @Override\n+        public void close() {\n+            arena.close();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            MemorySegment segment = MemorySegment.ofAddress(Utils.unsafe.allocateMemory(byteSize));\n+            Utils.unsafe.setMemory(segment.address(), byteSize, (byte)0);\n+            return segment.reinterpret(byteSize, arena, ms -> Utils.unsafe.freeMemory(segment.address()));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical.invokeExact();\n@@ -73,2 +73,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical.invokeExact(10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    static final MethodHandle func_trivial;\n+    static final MethodHandle func_critical;\n@@ -39,1 +39,1 @@\n-    static final MethodHandle func_trivial_v;\n+    static final MethodHandle func_critical_v;\n@@ -42,1 +42,1 @@\n-    static final MethodHandle identity_trivial;\n+    static final MethodHandle identity_critical;\n@@ -44,1 +44,1 @@\n-    static final MethodHandle identity_trivial_v;\n+    static final MethodHandle identity_critical_v;\n@@ -116,1 +116,1 @@\n-            func_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            func_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -118,1 +118,1 @@\n-            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n+            func_critical = insertArguments(func_critical_v, 0, func_addr);\n@@ -124,1 +124,1 @@\n-            identity_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n+            identity_critical_v = abi.downcallHandle(fd, Linker.Option.critical());\n@@ -126,1 +126,1 @@\n-            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n+            identity_critical = insertArguments(identity_critical_v, 0, identity_addr);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -58,2 +58,2 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial_v.invokeExact(func_addr);\n+    public void panama_blank_critical() throws Throwable {\n+        func_critical_v.invokeExact(func_addr);\n@@ -112,2 +112,2 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    public int panama_identity_critical() throws Throwable {\n+        return (int) identity_critical_v.invokeExact(identity_addr, 10);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static jdk.internal.foreign.StringSupport.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\", \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class InternalStrLen {\n+\n+    private MemorySegment singleByteSegment;\n+    private MemorySegment singleByteSegmentMisaligned;\n+    private MemorySegment doubleByteSegment;\n+    private MemorySegment quadByteSegment;\n+\n+    @Param({\"1\", \"4\", \"16\", \"251\", \"1024\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        singleByteSegment = arena.allocate((size + 1L) * Byte.BYTES);\n+        singleByteSegmentMisaligned = arena.allocate((size + 1L) * Byte.BYTES);\n+        doubleByteSegment = arena.allocate((size + 1L) * Short.BYTES);\n+        quadByteSegment = arena.allocate((size + 1L) * Integer.BYTES);\n+        Stream.of(singleByteSegment, doubleByteSegment, quadByteSegment)\n+                .forEach(s -> IntStream.range(0, (int) s.byteSize() - 1)\n+                        .forEach(i -> s.set(\n+                                ValueLayout.JAVA_BYTE,\n+                                i,\n+                                (byte) ThreadLocalRandom.current().nextInt(1, 254)\n+                        )));\n+        singleByteSegment.set(ValueLayout.JAVA_BYTE, singleByteSegment.byteSize() - Byte.BYTES, (byte) 0);\n+        doubleByteSegment.set(ValueLayout.JAVA_SHORT, doubleByteSegment.byteSize() - Short.BYTES, (short) 0);\n+        quadByteSegment.set(ValueLayout.JAVA_INT, quadByteSegment.byteSize() - Integer.BYTES, 0);\n+        singleByteSegmentMisaligned = arena.allocate(singleByteSegment.byteSize() + 1).\n+                asSlice(1);\n+        MemorySegment.copy(singleByteSegment, 0, singleByteSegmentMisaligned, 0, singleByteSegment.byteSize());\n+    }\n+\n+    @Benchmark\n+    public int elementSingle() {\n+        return legacy_strlen_byte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementByteMisaligned() {\n+        return legacy_strlen_byte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementDouble() {\n+        return legacy_strlen_short(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int elementQuad() {\n+        return legacy_strlen_int(quadByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingle() {\n+        return chunkedStrlenByte(singleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedSingleMisaligned() {\n+        return chunkedStrlenByte(singleByteSegmentMisaligned, 0);\n+    }\n+\n+    @Benchmark\n+    public int chunkedDouble() {\n+        return chunkedStrlenShort(doubleByteSegment, 0);\n+    }\n+\n+    @Benchmark\n+    public int changedElementQuad() {\n+        return strlenInt(quadByteSegment, 0);\n+    }\n+\n+    \/\/ These are the legacy methods\n+\n+    private static int legacy_strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_short(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+    private static int legacy_strlen_int(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset += 4) {\n+            int curr = segment.get(JAVA_INT, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/InternalStrLen.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,4 @@\n-import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG_UNALIGNED;\n@@ -32,1 +36,1 @@\n- * Some useful Java {@link ValueLayout} and associated {@link ValueLayout#arrayElementVarHandle(int...)} var handles.\n+ * Some useful Java {@link ValueLayout} and associated array var handles.\n@@ -36,1 +40,2 @@\n-    static final VarHandle VH_INT_UNALIGNED = JAVA_INT_UNALIGNED.arrayElementVarHandle();\n+    static final VarHandle VH_INT_UNALIGNED = arrayVarHandle(JAVA_INT_UNALIGNED);\n+    static final VarHandle VH_INT = arrayVarHandle(JAVA_INT);\n@@ -38,1 +43,7 @@\n-    static final VarHandle VH_INT = JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle VH_LONG_UNALIGNED = arrayVarHandle(JAVA_LONG_UNALIGNED);\n+    static final VarHandle VH_LONG = arrayVarHandle(JAVA_LONG);\n+\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+            1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentCopyUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+\n+    long src;\n+    long dst;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        src = Arena.global().allocate(JAVA_INT).address();\n+        dst = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public void panama() {\n+        MemorySegment srcSeg = MemorySegment.ofAddress(src).reinterpret(JAVA_INT.byteSize());\n+        MemorySegment dstSeg = MemorySegment.ofAddress(dst).reinterpret(JAVA_INT.byteSize());\n+        dstSeg.copyFrom(srcSeg);\n+    }\n+\n+    @Benchmark\n+    public void unsafe() {\n+        UNSAFE.copyMemory(src, dst, JAVA_INT.byteSize());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentCopyUnsafe.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentGetUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    static final MethodHandle OF_ADDRESS_UNSAFE;\n+\n+    static {\n+        try {\n+            OF_ADDRESS_UNSAFE = MethodHandles.lookup().findStatic(MemorySegmentGetUnsafe.class,\n+                    \"ofAddressUnsafe\", MethodType.methodType(MemorySegment.class, long.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    static final VarHandle INT_HANDLE = adaptSegmentHandle(JAVA_INT.varHandle());\n+\n+    static VarHandle adaptSegmentHandle(VarHandle handle) {\n+        handle = MethodHandles.insertCoordinates(handle, 1, 0L);\n+        handle = MethodHandles.filterCoordinates(handle, 0, OF_ADDRESS_UNSAFE);\n+        return handle;\n+    }\n+\n+    static MemorySegment ofAddressUnsafe(long address) {\n+        return MemorySegment.ofAddress(address).reinterpret(JAVA_INT.byteSize());\n+    }\n+\n+    long addr;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        addr = Arena.global().allocate(JAVA_INT).address();\n+    }\n+\n+    @Benchmark\n+    public int panama() {\n+        return (int) INT_HANDLE.get(addr);\n+    }\n+\n+    @Benchmark\n+    public int unsafe() {\n+        return UNSAFE.getInt(addr);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentGetUnsafe.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -61,1 +61,1 @@\n-@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentVsBits.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -95,1 +95,1 @@\n-            MemorySegment segment = arena.allocateUtf8String(str);\n+            MemorySegment segment = arena.allocateFrom(str);\n@@ -102,1 +102,1 @@\n-        return (int)STRLEN.invokeExact(arenaAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(arenaAllocator.allocateFrom(str));\n@@ -108,1 +108,1 @@\n-        int l = (int) STRLEN.invokeExact(arena.allocateUtf8String(str));\n+        int l = (int) STRLEN.invokeExact(arena.allocateFrom(str));\n@@ -115,1 +115,1 @@\n-        return (int)STRLEN.invokeExact(segmentAllocator.allocateUtf8String(str));\n+        return (int)STRLEN.invokeExact(segmentAllocator.allocateFrom(str));\n@@ -165,1 +165,1 @@\n-            long lastOffset = segment.segmentOffset(res) + res.byteSize();\n+            long lastOffset = res.address() - segment.address() + res.byteSize();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestAdaptVarHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-        \"--enable-native-access\", \"ALL-UNNAMED\",\n-        \"--enable-preview\"})\n+        \"--enable-native-access\", \"ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySegment.Scope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n+public class ToCStringTest extends CLayouts {\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"ToCString\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+\n+    static {\n+        Linker abi = Linker.nativeLinker();\n+        STRLEN = abi.downcallHandle(abi.defaultLookup().find(\"strlen\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+    }\n+\n+    @Benchmark\n+    public long jni_writeString() throws Throwable {\n+        return writeString(str);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_writeString() throws Throwable {\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocateFrom(str);\n+        arena.close();\n+        return segment;\n+    }\n+\n+    static native long writeString(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class ToJavaStringTest {\n+\n+    private MemorySegment strSegment;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\"})\n+    int size;\n+\n+    static {\n+        System.loadLibrary(\"ToJavaString\");\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n+    }\n+\n+    @Benchmark\n+    public String panama_readString() {\n+        return strSegment.getString(0);\n+    }\n+\n+    @Benchmark\n+    public String jni_readString() {\n+        return readString(strSegment.address());\n+    }\n+\n+    static native String readString(long addr);\n+\n+    static String LOREM = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-preview\", \"--enable-native-access=ALL-UNNAMED\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -48,4 +48,0 @@\n-    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -57,1 +57,1 @@\n-        generic = MethodHandles.memorySegmentViewVarHandle(JAVA_INT);\n+        generic = JAVA_INT.varHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_java_lang_foreign_ToCStringTest_writeString(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    jlong addr = (jlong)(void*)str;\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return addr;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToCString.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jstring JNICALL Java_org_openjdk_bench_java_lang_foreign_ToJavaStringTest_readString(JNIEnv *const env, const jclass cls, jlong addr) {\n+    return (*env)->NewStringUTF(env, (char*)(void*)addr);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libToJavaString.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        MemorySegment segment = allocator.allocateArray(type.layout(), size);\n+        MemorySegment segment = allocator.allocate(type.layout(), size);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/Pointer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+@Fork(3)\n@@ -63,1 +63,1 @@\n-            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        VH_x.set(segment, x);\n+        VH_x.set(segment, 0L, x);\n@@ -75,1 +75,1 @@\n-        return (int) VH_x.get(segment);\n+        return (int) VH_x.get(segment, 0L);\n@@ -79,1 +79,1 @@\n-        VH_y.set(segment, y);\n+        VH_y.set(segment, 0L, y);\n@@ -83,1 +83,1 @@\n-        return (int) VH_y.get(segment);\n+        return (int) VH_y.get(segment, 0L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-    \"--enable-preview\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}