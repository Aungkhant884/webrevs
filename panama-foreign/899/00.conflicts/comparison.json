{"files":[{"patch":"@@ -29,0 +29,1 @@\n+<<<<<<< HEAD\n@@ -31,0 +32,2 @@\n+=======\n+>>>>>>> fedc5fa5d92a17d3f1446af955ca4cee01447ca5\n@@ -54,0 +57,3 @@\n+ * @implSpec\n+ * This class is immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\n@@ -56,1 +62,1 @@\n- * @since 19\n+ * @since 22\n@@ -58,1 +64,0 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n@@ -98,1 +103,1 @@\n-     *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+     *         MemoryLayout.sequenceLayout(Long.MAX_VALUE, ValueLayout.JAVA_BYTE));\n@@ -103,2 +108,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -34,0 +35,2 @@\n+=======\n+>>>>>>> fedc5fa5d92a17d3f1446af955ca4cee01447ca5\n@@ -35,1 +38,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -39,0 +41,1 @@\n+import java.util.Map;\n@@ -40,1 +43,0 @@\n-import java.util.Optional;\n@@ -63,0 +65,6 @@\n+ * A linker provides a way to look up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * type names to canonical layouts.\n+ * <p>\n@@ -96,1 +104,1 @@\n- *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     MemorySegment str = arena.allocateFrom(\"Hello\");\n@@ -99,1 +107,1 @@\n- * }\n+ *}\n@@ -107,5 +115,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -126,1 +131,27 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code wchar_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 (all the examples provided\n+ * here will assume these platform-dependent mappings):\n@@ -141,1 +172,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -144,1 +175,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -147,1 +178,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -150,1 +181,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -153,1 +184,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -204,14 +235,1 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is {@linkplain MemoryLayout#equals(Object) equal}\n- * to one of the following layout constants:\n- * <ul>\n- * <li>{@link ValueLayout#JAVA_BOOLEAN}<\/li>\n- * <li>{@link ValueLayout#JAVA_BYTE}<\/li>\n- * <li>{@link ValueLayout#JAVA_CHAR}<\/li>\n- * <li>{@link ValueLayout#JAVA_SHORT}<\/li>\n- * <li>{@link ValueLayout#JAVA_INT}<\/li>\n- * <li>{@link ValueLayout#JAVA_LONG}<\/li>\n- * <li>{@link ValueLayout#JAVA_FLOAT}<\/li>\n- * <li>{@link ValueLayout#JAVA_DOUBLE}<\/li>\n- * <\/ul><\/li>\n- * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is\n- * {@linkplain MemoryLayout#equals(Object) equal} to {@link ValueLayout#ADDRESS}<\/li>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n@@ -297,1 +315,1 @@\n- *     MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -355,1 +373,1 @@\n- * returned segment is a fresh scope that is always alive. To provide safe access to the segment, we must,\n+ * returned segment is a scope that is always alive. To provide safe access to the segment, we must,\n@@ -394,9 +412,5 @@\n- * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared:\n- * <ol>\n- * <li>With a trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}<\/li>\n- * <li>With an empty formal parameter list, called a prototype-less function, such as: {@code void foo();}<\/li>\n- * <\/ol>\n- * The arguments passed in place of the ellipsis, or the arguments passed to a prototype-less function are called\n- * <em>variadic arguments<\/em>. Variadic functions are, essentially, templates that can be <em>specialized<\/em> into multiple\n- * non-variadic functions by replacing the {@code ...} or empty formal parameter list with a list of <em>variadic parameters<\/em>\n- * of a fixed number and type.\n+ * Variadic functions are C functions which can accept a variable number and type of arguments. They are declared with a\n+ * trailing ellipsis ({@code ...}) at the end of the formal parameter list, such as: {@code void foo(int x, ...);}.\n+ * The arguments passed in place of the ellipsis are called <em>variadic arguments<\/em>. Variadic functions are,\n+ * essentially, templates that can be <em>specialized<\/em> into multiple non-variadic functions by replacing the\n+ * {@code ...} with a list of <em>variadic parameters<\/em> of a fixed number and type.\n@@ -414,2 +428,2 @@\n- * specialized form of a variadic function, as the variadic parameters of the specialized form will always have a promoted\n- * type.\n+ * types that can be used to replace the {@code ...}, as the variadic parameters of the specialized form of a variadic\n+ * function will always have a promoted type.\n@@ -421,2 +435,1 @@\n- * function descriptor, are called <em>variadic argument layouts<\/em>. For a prototype-less function, the index passed to\n- * {@link Linker.Option#firstVariadicArg(int)} should always be {@code 0}.\n+ * function descriptor, are called <em>variadic argument layouts<\/em>.\n@@ -424,5 +437,7 @@\n- * The native linker will reject an attempt to link a specialized function descriptor with any variadic argument layouts\n- * corresponding to a C type that would be subject to default argument promotion (as described above). Exactly which layouts\n- * will be rejected is platform specific, but as an example: on Linux\/x64 the layouts {@link ValueLayout#JAVA_BOOLEAN},\n- * {@link ValueLayout#JAVA_BYTE}, {@link ValueLayout#JAVA_CHAR}, {@link ValueLayout#JAVA_SHORT}, and\n- * {@link ValueLayout#JAVA_FLOAT} will be rejected.\n+ * The native linker does not automatically perform default argument promotions. However, since passing an argument of a\n+ * non-promoted type as a variadic argument is not supported in C, the native linker will reject an attempt to link a\n+ * specialized function descriptor with any variadic argument value layouts corresponding to a non-promoted C type.\n+ * Since the size of the C {@code int} type is platform-specific, exactly which layouts will be rejected is\n+ * platform-specific as well. As an example: on Linux\/x64 the layouts corresponding to the C types {@code _Bool},\n+ * {@code (unsigned) char}, {@code (unsigned) short}, and {@code float} (among others), will be rejected by the linker.\n+ * The {@link #canonicalLayouts()} method can be used to find which layout corresponds to a particular C type.\n@@ -464,2 +479,1 @@\n- *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n- * }\n+ *     int res = (int)printf.invokeExact(arena.allocateFrom(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -467,0 +481,1 @@\n+ *}\n@@ -486,1 +501,1 @@\n- * @since 19\n+ * @since 22\n@@ -488,1 +503,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -496,0 +510,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -499,2 +515,0 @@\n-     *\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n@@ -516,2 +530,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -563,2 +576,6 @@\n-     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address.\n-     * The returned method handle will additionally throw {@link NullPointerException} if any argument passed to it is {@code null}.\n+     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address. If an argument\n+     * is a {@link MemorySegment},whose corresponding layout is an {@linkplain GroupLayout group layout}, the linker might attempt to access the contents of the segment. As such, one of the exceptions specified by the\n+     * {@link MemorySegment#get(ValueLayout.OfByte, long)} or the\n+     * {@link MemorySegment#copy(MemorySegment, long, MemorySegment, long, long)} methods may be thrown.\n+     * The returned method handle will additionally throw {@link NullPointerException} if any argument\n+     * passed to it is {@code null}.\n@@ -568,2 +585,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -593,1 +609,1 @@\n-     * is a native segment associated with a fresh scope that is always alive.\n+     * is a native segment associated with a scope that is always alive.\n@@ -606,2 +622,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -642,0 +657,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n@@ -644,1 +675,1 @@\n-     * @since 20\n+     * @since 22\n@@ -646,1 +677,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -711,0 +741,2 @@\n+         * @apiNote This linker option can not be combined with {@link #critical}.\n+         *\n@@ -753,1 +785,1 @@\n-         * {@return a linker option used to mark a foreign function as <em>trivial<\/em>}\n+         * {@return a linker option used to mark a foreign function as <em>critical<\/em>}\n@@ -755,2 +787,2 @@\n-         * A trivial function is a function that has an extremely short running time\n-         * in all cases (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * A critical function is a function that has an extremely short running time in all cases\n+         * (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n@@ -759,1 +791,1 @@\n-         * optimizations that are only valid for trivial functions.\n+         * optimizations that are only valid for critical functions.\n@@ -761,1 +793,1 @@\n-         * Using this linker option when linking non trivial functions is likely to have adverse effects,\n+         * Using this linker option when linking non-critical functions is likely to have adverse effects,\n@@ -764,2 +796,2 @@\n-        static Option isTrivial() {\n-            return LinkerOptions.IsTrivial.INSTANCE;\n+        static Option critical() {\n+            return LinkerOptions.Critical.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":105,"deletions":73,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.Linker.Option;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n@@ -37,1 +34,2 @@\n-import java.nio.channels.FileChannel.*;\n+import java.nio.channels.FileChannel.MapMode;\n+import java.nio.charset.Charset;\n@@ -49,0 +47,1 @@\n+import jdk.internal.foreign.StringSupport;\n@@ -50,0 +49,1 @@\n+<<<<<<< HEAD\n@@ -54,0 +54,2 @@\n+=======\n+>>>>>>> fedc5fa5d92a17d3f1446af955ca4cee01447ca5\n@@ -131,5 +133,6 @@\n- * For more complex access operations (e.g. structured memory access), clients can obtain a\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n- * that accepts a segment and a {@code long} offset. More complex var handles\n- * can be obtained by adapting a segment var handle view using the var handle combinator functions defined in the\n- * {@link java.lang.invoke.MethodHandles} class:\n+ * More complex access operations can be implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout on a memory segment.\n+ * A var handle obtained from a layout supports several additional <a href=MemoryLayout.html#access-mode-restrictions>\n+ * access modes<\/a>. More importantly, var handles can be <em>combined<\/em> with method handles to express complex access\n+ * operations. For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -137,1 +140,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang=java:\n@@ -139,7 +142,5 @@\n- * VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n- * MethodHandle multiplyExact = MethodHandles.lookup()\n- *                                           .findStatic(Math.class, \"multiplyExact\",\n- *                                                                   MethodType.methodType(long.class, long.class, long.class));\n- * intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n- *                                             MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * VarHandle intHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle(); \/\/ <base offset> + <index> * JAVA_INT.byteSize()\n+ *\n+ * intHandle = MethodHandles.filterCoordinates(intHandle, 1, scale);\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + 3 * 4 = 12\n@@ -148,3 +149,5 @@\n- * Alternatively, complex var handles can can be obtained\n- * from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n- * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>:\n+ * To make the process of creating these var handles easier, the method\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)} can be used, by providing it a so called\n+ * <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>. A layout path, consisting of several <em>layout\n+ * path elements<\/em>, selects a value layout to be accessed, which can be nested inside another memory layout. For example,\n+ * we can express the access to an element of an {@code int} array using layout paths like so:\n@@ -154,2 +157,7 @@\n- * VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"size\"),\n+ *     MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+ * );\n+ * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElemenet.groupElement(\"data\"),\n+ *                                               MemoryLayout.PathElement.sequenceElement());\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -157,0 +165,9 @@\n+ * Where {@code offsetof(data)} is the offset of the {@code data} element layout of the {@code segmentLayout} layout\n+ *\n+ * Both the var handle returned by {@link ValueLayout#varHandle()} and\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)}, as well as the method handle returned by\n+ * {@link MemoryLayout#byteOffsetHandle(MemoryLayout.PathElement...)} and {@link MemoryLayout#sliceHandle(MemoryLayout.PathElement...)}\n+ * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This\n+ * parameter allows a client to combine these handles further with additional offset computations. This is demonstrated\n+ * in the first of the two examples above, where {@code intHandle} is combined with a\n+ * {@linkplain MemoryLayout#scaleHandle() scale handle} obtained from {@code ValueLayout.JAVA_INT}.\n@@ -375,1 +392,1 @@\n- *     <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length\n+ *     <li>The segment is associated with a scope that is always alive. Thus, while zero-length\n@@ -437,1 +454,1 @@\n- * @since 19\n+ * @since 22\n@@ -439,1 +456,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -600,2 +616,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -629,1 +644,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -634,2 +649,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -669,1 +683,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -674,2 +688,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -742,24 +755,0 @@\n-    \/**\n-     * Returns the offset, in bytes, of the provided segment, relative to this\n-     * segment.\n-     *\n-     * <p>The offset is relative to the address of this segment and can be\n-     * a negative or positive value. For instance, if both segments are native\n-     * segments, or heap segments backed by the same array, the resulting offset\n-     * can be computed as follows:\n-     *\n-     * {@snippet lang=java :\n-     * other.address() - address()\n-     * }\n-     *\n-     * If the segments share the same address, {@code 0} is returned. If\n-     * {@code other} is a slice of this segment, the offset is always\n-     * {@code 0 <= x < this.byteSize()}.\n-     *\n-     * @param other the segment to retrieve an offset to.\n-     * @throws UnsupportedOperationException if the two segments cannot be compared, e.g. because they are of\n-     * different kinds, or because they are backed by different Java arrays.\n-     * @return the relative offset, in bytes, of the provided segment.\n-     *\/\n-    long segmentOffset(MemorySegment other);\n-\n@@ -774,1 +763,1 @@\n-     *     byteHandle.set(ValueLayout.JAVA_BYTE, offset, value);\n+     *     segment.set(ValueLayout.JAVA_BYTE, offset, value);\n@@ -1075,1 +1064,2 @@\n-     * Reads a UTF-8 encoded, null-terminated string from this segment at the given offset.\n+     * Reads a null-terminated string from this segment at the given offset, using the\n+     * {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1077,4 +1067,5 @@\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * getString(offset, StandardCharsets.UTF_8);\n+     *}\n+     *\n@@ -1084,3 +1075,4 @@\n-     * @throws IllegalArgumentException if the size of the UTF-8 string is greater than the largest string supported by the platform.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - S}, where {@code S} is the size of the UTF-8\n-     * string (including the terminator character).\n+     * @throws IllegalArgumentException if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1092,2 +1084,2 @@\n-    default String getUtf8String(long offset) {\n-        return SharedUtils.toJavaStringInternal(this, offset);\n+    default String getString(long offset) {\n+        return getString(offset, sun.nio.cs.UTF_8.INSTANCE);\n@@ -1097,1 +1089,1 @@\n-     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * Reads a null-terminated string from this segment at the given offset, using the provided charset.\n@@ -1103,0 +1095,28 @@\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the string bytes.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException      if the size of the string is greater than the largest string supported by the platform.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default String getString(long offset, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset);\n+    }\n+\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the {@linkplain StandardCharsets#UTF_8 UTF-8} charset.\n@@ -1104,4 +1124,4 @@\n-     * If the given string contains any {@code '\\0'} characters, they will be\n-     * copied as well. This means that, depending on the method used to read\n-     * the string, such as {@link MemorySegment#getUtf8String(long)}, the string\n-     * will appear truncated when read again.\n+     * Calling this method is equivalent to the following code:\n+     * {@snippet lang = java:\n+     * setString(offset, str, StandardCharsets.UTF_8);\n+     *}\n@@ -1111,1 +1131,3 @@\n-     * @throws IndexOutOfBoundsException if {@code offset < 0} or {@code offset > byteSize() - str.getBytes().length() + 1}.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + 1)}, where {@code B} is the size,\n+     * in bytes, of the string encoded using UTF-8 charset {@code str.getBytes(StandardCharsets.UTF_8).length}).\n@@ -1117,2 +1139,3 @@\n-    default void setUtf8String(long offset, String str) {\n-        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    default void setString(long offset, String str) {\n+        Objects.requireNonNull(str);\n+        setString(offset, str, sun.nio.cs.UTF_8.INSTANCE);\n@@ -1121,0 +1144,37 @@\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a null-terminated byte sequence\n+     * using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this access operation will occur.\n+     *                the final address of this write operation can be expressed as {@code address() + offset}.\n+     * @param str     the Java string to be written into this segment.\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the string bytes.\n+     * @throws IndexOutOfBoundsException     if {@code offset < 0}.\n+     * @throws IndexOutOfBoundsException     if {@code offset > byteSize() - (B + N)}, where:\n+     * <ul>\n+     *     <li>{@code B} is the size, in bytes, of the string encoded using the provided charset\n+     *     (e.g. {@code str.getBytes(charset).length});<\/li>\n+     *     <li>{@code N} is the size (in bytes) of the terminator char according to the provided charset. For instance,\n+     *     this is 1 for {@link StandardCharsets#US_ASCII} and 2 for {@link StandardCharsets#UTF_16}.<\/li>\n+     * <\/ul>\n+     * @throws IllegalStateException         if the {@linkplain #scope() scope} associated with this segment is not\n+     *                                       {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException          if this method is called from a thread {@code T},\n+     *                                       such that {@code isAccessibleBy(T) == false}.\n+     * @throws UnsupportedOperationException if {@code charset} is not a {@linkplain StandardCharsets standard charset}.\n+     *\/\n+    default void setString(long offset, String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        StringSupport.write(this, offset, charset, str);\n+    }\n@@ -1284,2 +1344,3 @@\n-     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes} or if\n-     * {@code dstOffset > dstSegment.byteSize() - bytes}, or if either {@code srcOffset}, {@code dstOffset}\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - bytes}.\n+     * @throws IndexOutOfBoundsException if either {@code srcOffset}, {@code dstOffset}\n@@ -1323,1 +1384,3 @@\n-     * (resp. destination) element layout, or if the source (resp. destination) element layout alignment is greater than its size.\n+     * (resp. destination) element layout.\n+     * @throws IllegalArgumentException if {@code srcElementLayout.byteAlignment() > srcElementLayout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code dstElementLayout.byteAlignment() > dstElementLayout.byteSize()}.\n@@ -1327,1 +1390,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -1331,1 +1394,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -1333,1 +1396,3 @@\n-     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} or {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * srcLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code elementCount * dtsLayout.byteSize()} overflows.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset > srcSegment.byteSize() - (elementCount * srcLayout.byteSize())}.\n@@ -1364,1 +1429,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n+        return (byte) layout.varHandle().get(this, offset);\n@@ -1384,1 +1449,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1403,1 +1468,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n+        return (boolean) layout.varHandle().get(this, offset);\n@@ -1423,1 +1488,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1442,1 +1507,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n+        return (char) layout.varHandle().get(this, offset);\n@@ -1462,1 +1527,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1481,1 +1546,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n+        return (short) layout.varHandle().get(this, offset);\n@@ -1501,1 +1566,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1520,1 +1585,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n+        return (int) layout.varHandle().get(this, offset);\n@@ -1540,1 +1605,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1559,1 +1624,1 @@\n-        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n+        return (float)layout.varHandle().get(this, offset);\n@@ -1579,1 +1644,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1598,1 +1663,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n+        return (long) layout.varHandle().get(this, offset);\n@@ -1618,1 +1683,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1637,1 +1702,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n+        return (double) layout.varHandle().get(this, offset);\n@@ -1657,1 +1722,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1662,1 +1727,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -1682,1 +1747,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n+        return (MemorySegment) layout.varHandle().get(this, offset);\n@@ -1703,1 +1768,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1718,2 +1783,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1727,1 +1792,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (byte) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1742,2 +1807,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1751,1 +1816,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (boolean) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1766,2 +1831,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1775,1 +1840,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (char) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1790,2 +1855,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1800,1 +1865,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1815,2 +1880,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1824,1 +1889,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (short) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1839,2 +1904,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1849,1 +1914,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1865,2 +1930,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1875,1 +1940,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1890,2 +1955,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1900,1 +1965,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1915,2 +1980,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1924,1 +1989,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (int) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1939,2 +2004,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1949,1 +2014,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1964,2 +2029,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1973,1 +2038,1 @@\n-        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (float) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1988,2 +2053,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -1998,1 +2063,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2013,2 +2078,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2022,1 +2087,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (long) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2037,2 +2102,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2047,1 +2112,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2062,2 +2127,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2071,1 +2136,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (double) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2086,2 +2151,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2096,1 +2161,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2101,1 +2166,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -2114,2 +2179,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2126,1 +2191,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2141,2 +2206,2 @@\n-     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n-     * or if the layout alignment is greater than its size.\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout.\n+     * @throws IllegalArgumentException if {@code layout.byteAlignment() > layout.byteSize()}.\n@@ -2152,1 +2217,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2201,1 +2266,1 @@\n-     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -2240,1 +2305,1 @@\n-     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -2314,0 +2379,20 @@\n+     * <p>\n+     * If two memory segments are obtained from the same {@linkplain #ofBuffer(Buffer) buffer}\n+     * or {@linkplain #ofArray(int[]) array}, the scopes associated with said segments are considered\n+     * {@linkplain #equals(Object) equal}, as the two segments have the same lifetime:\n+     * {@snippet lang=java :\n+     * byte[] arr = new byte[10];\n+     * MemorySegment segment1 = MemorySegment.ofArray(arr);\n+     * MemorySegment segment2 = MemorySegment.ofArray(arr);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n+     * <p>\n+     * If two distinct memory segments are <a href=\"#wrapping-addresses\">zero-length memory segments<\/a>, their scopes\n+     * are always considered {@linkplain #equals(Object) equal}:\n+     * {@snippet lang=java :\n+     * MemorySegment segment1 = MemorySegment.ofAddress(42L);\n+     * MemorySegment segment2 = MemorySegment.ofAddress(1000L);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n+     * The scope of a zero-length memory segment can always be overridden using the\n+     * {@link MemorySegment#reinterpret(Arena, Consumer)} method.\n@@ -2315,1 +2400,0 @@\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":243,"deletions":159,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -34,0 +35,2 @@\n+=======\n+>>>>>>> fedc5fa5d92a17d3f1446af955ca4cee01447ca5\n@@ -123,1 +126,1 @@\n- * @since 19\n+ * @since 22\n@@ -125,1 +128,0 @@\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n@@ -170,1 +172,1 @@\n-     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * returned by this method is associated with a {@linkplain MemorySegment.Scope scope} which keeps the caller's\n@@ -194,1 +196,1 @@\n-            MemorySessionImpl session = MemorySessionImpl.heapSession(loader);\n+            MemorySessionImpl session = MemorySessionImpl.createHeap(loader);\n@@ -219,2 +221,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n@@ -254,2 +255,1 @@\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * the JVM or, worse, silently result in memory corruption.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}