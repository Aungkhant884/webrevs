{"files":[{"patch":"@@ -163,1 +163,1 @@\n-# Setup a rule for generating a memory access var handle helper classes\n+# Setup a rule for generating a memory segment var handle view class\n@@ -166,1 +166,1 @@\n-define GenerateVarHandleMemoryAccess\n+define GenerateVarHandleMemorySegment\n@@ -170,1 +170,1 @@\n-  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)\/MemoryAccessVarHandle$$($1_Type)Helper.java\n+  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)\/VarHandleSegmentAs$$($1_Type)s.java\n@@ -251,1 +251,1 @@\n-  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)\/X-VarHandleMemoryAccess.java.template $(BUILD_TOOLS_JDK)\n+  $$($1_FILENAME): $(VARHANDLES_SRC_DIR)\/X-VarHandleSegmentView.java.template $(BUILD_TOOLS_JDK)\n@@ -275,3 +275,3 @@\n-VARHANDLES_MEMORY_ADDRESS_TYPES := Byte Short Char Int Long Float Double\n-$(foreach t, $(VARHANDLES_MEMORY_ADDRESS_TYPES), \\\n-  $(eval $(call GenerateVarHandleMemoryAccess,VAR_HANDLE_MEMORY_ADDRESS_$t,$t)))\n+VARHANDLES_MEMORY_SEGMENT_TYPES := Byte Short Char Int Long Float Double\n+$(foreach t, $(VARHANDLES_MEMORY_SEGMENT_TYPES), \\\n+  $(eval $(call GenerateVarHandleMemorySegment,VAR_HANDLE_MEMORY_SEGMENT_$t,$t)))\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * <h2>Dereference<\/h2>\n+ * <h2>Dereferencing memory addresses<\/h2>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryAddress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,2 @@\n- * This is important when obtaining memory access var handle from layouts, as in the following code:\n+ * This is important when obtaining a {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view var handle}\n+ * from layouts, as in the following code:\n@@ -169,1 +170,1 @@\n- * it follows that the memory access var handle {@code valueHandle} will feature an <em>additional<\/em> {@code long}\n+ * it follows that the var handle {@code valueHandle} will feature an <em>additional<\/em> {@code long}\n@@ -385,1 +386,1 @@\n-     * Creates a memory access var handle that can be used to dereference memory at the layout selected by a given layout path,\n+     * Creates an access var handle that can be used to dereference memory at the layout selected by a given layout path,\n@@ -388,1 +389,1 @@\n-     * The final memory location accessed by the returned memory access var handle can be computed as follows:\n+     * The final memory location accessed by the returned var handle can be computed as follows:\n@@ -409,1 +410,1 @@\n-     * features certain <a href=\"MemoryHandles.html#memaccess-mode\">access mode restrictions<\/a>, which are common to all memory access var handles.\n+     * features certain <em>access mode restrictions<\/em>, which are common to all memory segment view handles.\n@@ -415,0 +416,1 @@\n+     * @see MethodHandles#memorySegmentViewVarHandle(ValueLayout)\n@@ -422,1 +424,1 @@\n-     * Creates a <em>strided<\/em> memory access var handle that can be used to dereference memory at the layout selected by a given layout path,\n+     * Creates a <em>strided<\/em> access var handle that can be used to dereference memory at the layout selected by a given layout path,\n@@ -435,0 +437,1 @@\n+     * @see MethodHandles#memorySegmentViewVarHandle\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n- * <h2>Dereference<\/h2>\n+ * <h2><a id = \"segment-deref\">Dereferencing memory segments<\/a><\/h2>\n@@ -134,7 +134,26 @@\n- * For more complex dereference operations (e.g. structured memory access), clients can obtain a <em>memory access var handle<\/em>,\n- * that is, a var handle that accepts a segment and, optionally, one or more additional {@code long} coordinates. Memory\n- * access var handles can be obtained from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n- * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>.\n- * Alternatively, clients can obtain raw memory access var handles from a given\n- * {@linkplain MethodHandles#memoryAccessVarHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n- * functions defined in the {@link java.lang.invoke.MethodHandles} class.\n+ * For more complex dereference operations (e.g. structured memory access), clients can obtain a\n+ * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view var handle},\n+ * that is, a var handle that accepts a segment and a {@code long} offset. More complex access var handles\n+ * can be obtained by adapt a segment var handle view using the var handle combinator functions defined in the\n+ * {@link java.lang.invoke.MethodHandles} class:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment segment = ...\n+ * VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+ * MethodHandle multiplyExact = MethodHandles.lookup()\n+ *                                           .findStatic(Math.class, \"multiplyExact\",\n+ *                                                                   MethodType.methodType(long.class, long.class, long.class));\n+ * intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n+ *                                             MethodHandles.insertArguments(multiplyExact, 0, 4L));\n+ * intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * }\n+ *\n+ * Alternatively, complex access var handles can can be obtained\n+ * from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n+ * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>:\n+ *\n+ * {@snippet lang=java :\n+ * MemorySegment segment = ...\n+ * VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n+ * intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-            handle = Utils.makeMemoryAccessVarHandle(this);\n+            handle = Utils.makeSegmentViewVarHandle(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,8 +34,6 @@\n- * models a contiguous memory region, which can reside either inside or outside the Java heap.\n- * A memory segment represents the main access coordinate of a memory access var handle, which can be obtained\n- * using the combinator methods defined in the {@link java.lang.invoke.MethodHandles} class; a set of\n- * common dereference and copy operations is provided also by the {@link java.lang.foreign.MemorySegment} class, which can\n- * be useful for simple, non-structured access. Finally, the {@link java.lang.foreign.MemoryLayout} class\n- * hierarchy enables description of <em>memory layouts<\/em> and basic operations such as computing the size in bytes of a given\n- * layout, obtain its alignment requirements, and so on. Memory layouts also provide an alternate, more abstract way, to produce\n- * memory access var handles, e.g. using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n+ * models a contiguous memory region, which can reside either inside or outside the Java heap. Moreover,\n+ * the {@link java.lang.foreign.MemoryLayout} class hierarchy enables description of <em>memory layouts<\/em>\n+ * and basic operations such as computing the size in bytes of a given layout, obtain its alignment requirements.\n+ * Memory layouts also provide an alternate, more abstract way, to <a href=MemorySegment.html#segment-deref>dereference memory segments<\/a>\n+ * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) access var handles},\n+ * which can be computed using <a href=\"MemoryLayout.html#layout-paths\"><em>layout paths<\/em><\/a>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.invoke;\n-\n-\/**\n- * Base class for memory access var handle implementations.\n- *\/\n-abstract class MemoryAccessVarHandleBase extends VarHandle {\n-\n-    \/** endianness **\/\n-    final boolean be;\n-\n-    \/** access size (in bytes, computed from var handle carrier type) **\/\n-    final long length;\n-\n-    \/** alignment constraint (in bytes, expressed as a bit mask) **\/\n-    final long alignmentMask;\n-\n-    MemoryAccessVarHandleBase(VarForm form, boolean be, long length, long alignmentMask, boolean exact) {\n-        super(form, exact);\n-        this.be = be;\n-        this.length = length;\n-        this.alignmentMask = alignmentMask;\n-    }\n-\n-    static IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemoryAccessVarHandleBase.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1583,2 +1583,2 @@\n-            public VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask, ByteOrder order) {\n-                return VarHandles.makeMemoryAddressViewHandle(carrier, alignmentMask, order);\n+            public VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask, ByteOrder order) {\n+                return VarHandles.memorySegmentViewHandle(carrier, alignmentMask, order);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7870,1 +7870,2 @@\n-     * Creates a <i>memory access var handle<\/i> from the given value layout.\n+     * Creates a var handle object, which can be used to dereference a {@linkplain java.lang.foreign.MemorySegment memory segment}\n+     * by viewing its contents as a sequence of the provided value layout.\n@@ -7881,1 +7882,1 @@\n-     * the alignment constraint (in bytes) for the resulting memory access var handle is given by {@code alignmentBytes}.\n+     * the alignment constraint (in bytes) for the resulting var handle is given by {@code alignmentBytes}.\n@@ -7890,1 +7891,1 @@\n-     * To access the member layout named {@code value}, we can construct a memory access var handle as follows:\n+     * To access the member layout named {@code value}, we can construct a memory segment view var handle as follows:\n@@ -7892,1 +7893,1 @@\n-     *     VarHandle handle = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n+     *     VarHandle handle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n@@ -7897,1 +7898,1 @@\n-     * which are common to all memory access var handles. A memory access var handle is associated\n+     * which are common to all memory segment view var handles. A memory segment view var handle is associated\n@@ -7933,1 +7934,1 @@\n-     * @return the new memory access var handle.\n+     * @return the new memory segment view var handle.\n@@ -7939,1 +7940,1 @@\n-    public static VarHandle memoryAccessVarHandle(ValueLayout layout) {\n+    public static VarHandle memorySegmentViewVarHandle(ValueLayout layout) {\n@@ -7941,1 +7942,1 @@\n-        return Utils.makeMemoryAccessVarHandle(layout);\n+        return Utils.makeSegmentViewVarHandle(layout);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+\/**\n+ * Base class for memory segment var handle view implementations.\n+ *\/\n+abstract class VarHandleSegmentViewBase extends VarHandle {\n+\n+    \/** endianness **\/\n+    final boolean be;\n+\n+    \/** access size (in bytes, computed from var handle carrier type) **\/\n+    final long length;\n+\n+    \/** alignment constraint (in bytes, expressed as a bit mask) **\/\n+    final long alignmentMask;\n+\n+    VarHandleSegmentViewBase(VarForm form, boolean be, long length, long alignmentMask, boolean exact) {\n+        super(form, exact);\n+        this.be = be;\n+        this.length = length;\n+        this.alignmentMask = alignmentMask;\n+    }\n+\n+    static IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n+        return new IllegalArgumentException(\"Misaligned access at address: \" + address);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -303,1 +303,1 @@\n-     * Creates a memory access VarHandle.\n+     * Creates a memory segment view var handle.\n@@ -305,6 +305,2 @@\n-     * Resulting VarHandle will take a memory address as first argument,\n-     * and a certain number of coordinate {@code long} parameters, depending on the length\n-     * of the {@code strides} argument array.\n-     *\n-     * Coordinates are multiplied with corresponding scale factors ({@code strides}) and added\n-     * to a single fixed offset to compute an effective offset from the given MemoryAddress for the access.\n+     * Resulting var handle will take a memory segment as first argument (the segment to be dereferenced),\n+     * and a {@code long} as second argument (the offset into the segment).\n@@ -317,2 +313,2 @@\n-    static VarHandle makeMemoryAddressViewHandle(Class<?> carrier, long alignmentMask,\n-                                                 ByteOrder byteOrder) {\n+    static VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask,\n+                                             ByteOrder byteOrder) {\n@@ -327,1 +323,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleByteHelper(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsBytes(be, size, alignmentMask, exact));\n@@ -329,1 +325,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleCharHelper(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsChars(be, size, alignmentMask, exact));\n@@ -331,1 +327,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleShortHelper(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsShorts(be, size, alignmentMask, exact));\n@@ -333,1 +329,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleIntHelper(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsInts(be, size, alignmentMask, exact));\n@@ -335,1 +331,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleFloatHelper(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsFloats(be, size, alignmentMask, exact));\n@@ -337,1 +333,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleLongHelper(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsLongs(be, size, alignmentMask, exact));\n@@ -339,1 +335,1 @@\n-            return maybeAdapt(new MemoryAccessVarHandleDoubleHelper(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsDoubles(be, size, alignmentMask, exact));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,574 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.invoke;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.ref.Reference;\n-\n-import java.util.Objects;\n-\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n-\n-#warn\n-\n-final class MemoryAccessVarHandle$Type$Helper extends MemoryAccessVarHandleBase {\n-\n-    static final boolean BE = UNSAFE.isBigEndian();\n-\n-    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n-    static final int VM_ALIGN = $BoxType$.BYTES - 1;\n-\n-    static final VarForm FORM = new VarForm(MemoryAccessVarHandle$Type$Helper.class, MemorySegment.class, $type$.class, long.class);\n-\n-    MemoryAccessVarHandle$Type$Helper(boolean be, long length, long alignmentMask, boolean exact) {\n-        super(FORM, be, length, alignmentMask, exact);\n-    }\n-\n-    @Override\n-    final MethodType accessModeTypeUncached(VarHandle.AccessType accessType) {\n-        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n-    }\n-\n-    @Override\n-    public MemoryAccessVarHandle$Type$Helper withInvokeExactBehavior() {\n-        return hasInvokeExactBehavior() ?\n-                this :\n-                new MemoryAccessVarHandle$Type$Helper(be, length, alignmentMask, true);\n-    }\n-\n-    @Override\n-    public MemoryAccessVarHandle$Type$Helper withInvokeBehavior() {\n-        return !hasInvokeExactBehavior() ?\n-                this :\n-                new MemoryAccessVarHandle$Type$Helper(be, length, alignmentMask, false);\n-    }\n-\n-#if[floatingPoint]\n-    @ForceInline\n-    static $rawType$ convEndian(boolean big, $type$ v) {\n-        $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);\n-        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n-    }\n-\n-    @ForceInline\n-    static $type$ convEndian(boolean big, $rawType$ rv) {\n-        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n-        return $Type$.$rawType$BitsTo$Type$(rv);\n-    }\n-#else[floatingPoint]\n-#if[byte]\n-    @ForceInline\n-    static $type$ convEndian(boolean big, $type$ n) {\n-        return n;\n-    }\n-#else[byte]\n-    @ForceInline\n-    static $type$ convEndian(boolean big, $type$ n) {\n-        return big == BE ? n : $BoxType$.reverseBytes(n);\n-    }\n-#end[byte]\n-#end[floatingPoint]\n-\n-    @ForceInline\n-    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n-        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl)Objects.requireNonNull(obb);\n-        oo.checkAccess(offset, length, ro);\n-        return oo;\n-    }\n-\n-    @ForceInline\n-    static long offset(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n-        if ((address & VM_ALIGN) != 0) {\n-            throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-        }\n-        return address;\n-    }\n-\n-    @ForceInline\n-    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n-        long base = bb.unsafeGetOffset();\n-        long address = base + offset;\n-        long maxAlignMask = bb.maxAlignMask();\n-        if (((address | maxAlignMask) & alignmentMask) != 0) {\n-            throw MemoryAccessVarHandleBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-        }\n-        return address;\n-    }\n-\n-    @ForceInline\n-    static $type$ get(VarHandle ob, Object obb, long base) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n-#if[floatingPoint]\n-        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n-                handle.be);\n-        return $Type$.$rawType$BitsTo$Type$(rawValue);\n-#else[floatingPoint]\n-#if[byte]\n-        return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n-#else[byte]\n-        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n-                handle.be);\n-#end[byte]\n-#end[floatingPoint]\n-    }\n-\n-    @ForceInline\n-    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-#if[floatingPoint]\n-        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n-                $Type$.$type$ToRaw$RawType$Bits(value),\n-                handle.be);\n-#else[floatingPoint]\n-#if[byte]\n-        SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n-                value);\n-#else[byte]\n-        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n-                value,\n-                handle.be);\n-#end[byte]\n-#end[floatingPoint]\n-    }\n-\n-    @ForceInline\n-    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask)));\n-    }\n-\n-    @ForceInline\n-    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, value));\n-    }\n-\n-    @ForceInline\n-    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask)));\n-    }\n-\n-    @ForceInline\n-    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, value));\n-    }\n-\n-    @ForceInline\n-    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask)));\n-    }\n-\n-    @ForceInline\n-    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, value));\n-    }\n-#if[CAS]\n-\n-    @ForceInline\n-    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n-\n-    @ForceInline\n-    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask),\n-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n-    }\n-\n-    @ForceInline\n-    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask),\n-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n-    }\n-\n-    @ForceInline\n-    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask),\n-                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n-    }\n-\n-    @ForceInline\n-    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n-\n-    @ForceInline\n-    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n-\n-    @ForceInline\n-    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n-\n-    @ForceInline\n-    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n-                bb.unsafeGetBase(),\n-                offset(bb, base, handle.alignmentMask),\n-                convEndian(handle.be, expected), convEndian(handle.be, value));\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask),\n-                                  convEndian(handle.be, value)));\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask),\n-                                  convEndian(handle.be, value)));\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        return convEndian(handle.be,\n-                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n-                                  bb.unsafeGetBase(),\n-                                  offset(bb, base, handle.alignmentMask),\n-                                  convEndian(handle.be, value)));\n-    }\n-#end[CAS]\n-#if[AtomicAdd]\n-\n-    @ForceInline\n-    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    delta);\n-        } else {\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    delta);\n-        } else {\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    delta);\n-        } else {\n-            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndAddConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ delta) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));\n-        return expectedValue;\n-    }\n-#end[AtomicAdd]\n-#if[Bitwise]\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseOrConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));\n-        return expectedValue;\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseAndConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue & value)));\n-        return expectedValue;\n-    }\n-\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n-        MemoryAccessVarHandleBase handle = (MemoryAccessVarHandleBase)ob;\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n-        if (handle.be == BE) {\n-            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n-                    bb.unsafeGetBase(),\n-                    offset(bb, base, handle.alignmentMask),\n-                    value);\n-        } else {\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n-        }\n-    }\n-\n-    @ForceInline\n-    static $type$ getAndBitwiseXorConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n-        $type$ nativeExpectedValue, expectedValue;\n-        Object base = bb.unsafeGetBase();\n-        do {\n-            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n-            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n-        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n-                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));\n-        return expectedValue;\n-    }\n-#end[Bitwise]\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":0,"deletions":574,"binary":false,"changes":574,"status":"deleted"},{"patch":"@@ -0,0 +1,574 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.invoke;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.ref.Reference;\n+\n+import java.util.Objects;\n+\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n+\n+#warn\n+\n+final class VarHandleSegmentAs$Type$s extends VarHandleSegmentViewBase {\n+\n+    static final boolean BE = UNSAFE.isBigEndian();\n+\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    static final int VM_ALIGN = $BoxType$.BYTES - 1;\n+\n+    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+\n+    VarHandleSegmentAs$Type$s(boolean be, long length, long alignmentMask, boolean exact) {\n+        super(FORM, be, length, alignmentMask, exact);\n+    }\n+\n+    @Override\n+    final MethodType accessModeTypeUncached(VarHandle.AccessType accessType) {\n+        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n+    }\n+\n+    @Override\n+    public VarHandleSegmentAs$Type$s withInvokeExactBehavior() {\n+        return hasInvokeExactBehavior() ?\n+                this :\n+                new VarHandleSegmentAs$Type$s(be, length, alignmentMask, true);\n+    }\n+\n+    @Override\n+    public VarHandleSegmentAs$Type$s withInvokeBehavior() {\n+        return !hasInvokeExactBehavior() ?\n+                this :\n+                new VarHandleSegmentAs$Type$s(be, length, alignmentMask, false);\n+    }\n+\n+#if[floatingPoint]\n+    @ForceInline\n+    static $rawType$ convEndian(boolean big, $type$ v) {\n+        $rawType$ rv = $Type$.$type$ToRaw$RawType$Bits(v);\n+        return big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n+    }\n+\n+    @ForceInline\n+    static $type$ convEndian(boolean big, $rawType$ rv) {\n+        rv = big == BE ? rv : $RawBoxType$.reverseBytes(rv);\n+        return $Type$.$rawType$BitsTo$Type$(rv);\n+    }\n+#else[floatingPoint]\n+#if[byte]\n+    @ForceInline\n+    static $type$ convEndian(boolean big, $type$ n) {\n+        return n;\n+    }\n+#else[byte]\n+    @ForceInline\n+    static $type$ convEndian(boolean big, $type$ n) {\n+        return big == BE ? n : $BoxType$.reverseBytes(n);\n+    }\n+#end[byte]\n+#end[floatingPoint]\n+\n+    @ForceInline\n+    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n+        AbstractMemorySegmentImpl oo = (AbstractMemorySegmentImpl)Objects.requireNonNull(obb);\n+        oo.checkAccess(offset, length, ro);\n+        return oo;\n+    }\n+\n+    @ForceInline\n+    static long offset(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        long address = offsetNoVMAlignCheck(bb, offset, alignmentMask);\n+        if ((address & VM_ALIGN) != 0) {\n+            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n+        }\n+        return address;\n+    }\n+\n+    @ForceInline\n+    static long offsetNoVMAlignCheck(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+        long base = bb.unsafeGetOffset();\n+        long address = base + offset;\n+        long maxAlignMask = bb.maxAlignMask();\n+        if (((address | maxAlignMask) & alignmentMask) != 0) {\n+            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n+        }\n+        return address;\n+    }\n+\n+    @ForceInline\n+    static $type$ get(VarHandle ob, Object obb, long base) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+#if[floatingPoint]\n+        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                handle.be);\n+        return $Type$.$rawType$BitsTo$Type$(rawValue);\n+#else[floatingPoint]\n+#if[byte]\n+        return SCOPED_MEMORY_ACCESS.get$Type$(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask));\n+#else[byte]\n+        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                handle.be);\n+#end[byte]\n+#end[floatingPoint]\n+    }\n+\n+    @ForceInline\n+    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+#if[floatingPoint]\n+        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                $Type$.$type$ToRaw$RawType$Bits(value),\n+                handle.be);\n+#else[floatingPoint]\n+#if[byte]\n+        SCOPED_MEMORY_ACCESS.put$Type$(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                value);\n+#else[byte]\n+        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offsetNoVMAlignCheck(bb, base, handle.alignmentMask),\n+                value,\n+                handle.be);\n+#end[byte]\n+#end[floatingPoint]\n+    }\n+\n+    @ForceInline\n+    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask)));\n+    }\n+\n+    @ForceInline\n+    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, value));\n+    }\n+\n+    @ForceInline\n+    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask)));\n+    }\n+\n+    @ForceInline\n+    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, value));\n+    }\n+\n+    @ForceInline\n+    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask)));\n+    }\n+\n+    @ForceInline\n+    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, value));\n+    }\n+#if[CAS]\n+\n+    @ForceInline\n+    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, expected), convEndian(handle.be, value));\n+    }\n+\n+    @ForceInline\n+    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask),\n+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n+    }\n+\n+    @ForceInline\n+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask),\n+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n+    }\n+\n+    @ForceInline\n+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask),\n+                                  convEndian(handle.be, expected), convEndian(handle.be, value)));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, expected), convEndian(handle.be, value));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, expected), convEndian(handle.be, value));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, expected), convEndian(handle.be, value));\n+    }\n+\n+    @ForceInline\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.sessionImpl(),\n+                bb.unsafeGetBase(),\n+                offset(bb, base, handle.alignmentMask),\n+                convEndian(handle.be, expected), convEndian(handle.be, value));\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask),\n+                                  convEndian(handle.be, value)));\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask),\n+                                  convEndian(handle.be, value)));\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        return convEndian(handle.be,\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.sessionImpl(),\n+                                  bb.unsafeGetBase(),\n+                                  offset(bb, base, handle.alignmentMask),\n+                                  convEndian(handle.be, value)));\n+    }\n+#end[CAS]\n+#if[AtomicAdd]\n+\n+    @ForceInline\n+    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    delta);\n+        } else {\n+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    delta);\n+        } else {\n+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    delta);\n+        } else {\n+            return getAndAddConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), delta);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndAddConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ delta) {\n+        $type$ nativeExpectedValue, expectedValue;\n+        Object base = bb.unsafeGetBase();\n+        do {\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue + delta)));\n+        return expectedValue;\n+    }\n+#end[AtomicAdd]\n+#if[Bitwise]\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseOrConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n+        $type$ nativeExpectedValue, expectedValue;\n+        Object base = bb.unsafeGetBase();\n+        do {\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue | value)));\n+        return expectedValue;\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseAndConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n+        $type$ nativeExpectedValue, expectedValue;\n+        Object base = bb.unsafeGetBase();\n+        do {\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue & value)));\n+        return expectedValue;\n+    }\n+\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+        VarHandleSegmentViewBase handle = (VarHandleSegmentViewBase)ob;\n+        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        if (handle.be == BE) {\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.sessionImpl(),\n+                    bb.unsafeGetBase(),\n+                    offset(bb, base, handle.alignmentMask),\n+                    value);\n+        } else {\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offset(bb, base, handle.alignmentMask), value);\n+        }\n+    }\n+\n+    @ForceInline\n+    static $type$ getAndBitwiseXorConvEndianWithCAS(AbstractMemorySegmentImpl  bb, long offset, $type$ value) {\n+        $type$ nativeExpectedValue, expectedValue;\n+        Object base = bb.unsafeGetBase();\n+        do {\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.sessionImpl(),base, offset);\n+            expectedValue = $RawBoxType$.reverseBytes(nativeExpectedValue);\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.sessionImpl(),base, offset,\n+                nativeExpectedValue, $RawBoxType$.reverseBytes(expectedValue ^ value)));\n+        return expectedValue;\n+    }\n+#end[Bitwise]\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -85,1 +85,1 @@\n-     * Returns a var handle view of a given memory address.\n+     * Returns a var handle view of a given memory segment.\n@@ -89,1 +89,1 @@\n-    VarHandle memoryAccessVarHandle(Class<?> carrier, long alignmentMask, ByteOrder order);\n+    VarHandle memorySegmentViewHandle(Class<?> carrier, long alignmentMask, ByteOrder order);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * by the path (see {@link #offset}), or obtain a memory access var handle to access the selected layout element\n+ * by the path (see {@link #offset}), or obtain var handle to access the selected layout element\n@@ -162,1 +162,1 @@\n-        VarHandle handle = Utils.makeMemoryAccessVarHandle(valueLayout);\n+        VarHandle handle = Utils.makeSegmentViewVarHandle(valueLayout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout) {\n+    public static VarHandle makeSegmentViewVarHandle(ValueLayout layout) {\n@@ -121,1 +121,1 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier,\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,3 +45,1 @@\n-import static java.lang.invoke.MethodHandles.collectArguments;\n-import static java.lang.invoke.MethodHandles.filterArguments;\n-import static java.lang.invoke.MethodHandles.insertArguments;\n+\n@@ -598,1 +596,1 @@\n-            return MethodHandles.insertCoordinates(MethodHandles.memoryAccessVarHandle(layout), 1, offset);\n+            return MethodHandles.insertCoordinates(MethodHandles.memorySegmentViewVarHandle(layout), 1, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-        addDefaultMapping(VarHandle.class, MethodHandles.memoryAccessVarHandle(JAVA_INT));\n+        addDefaultMapping(VarHandle.class, MethodHandles.memorySegmentViewVarHandle(JAVA_INT));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-            return MethodHandles.memoryAccessVarHandle(layout);\n+            return MethodHandles.memorySegmentViewVarHandle(layout);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import org.testng.annotations.DataProvider;\n+\n@@ -47,1 +47,1 @@\n-        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_BYTE);\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE);\n@@ -56,1 +56,1 @@\n-        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n@@ -66,1 +66,1 @@\n-        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n@@ -75,1 +75,1 @@\n-        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_SHORT\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT\n@@ -86,1 +86,1 @@\n-        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_SHORT\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT\n@@ -102,1 +102,1 @@\n-        VarHandle vh = MethodHandles.memoryAccessVarHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        VarHandle vh = MethodHandles.memoryAccessVarHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.nio.ByteOrder;\n@@ -57,1 +56,1 @@\n-        generic = MethodHandles.memoryAccessVarHandle(JAVA_INT);\n+        generic = MethodHandles.memorySegmentViewVarHandle(JAVA_INT);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}