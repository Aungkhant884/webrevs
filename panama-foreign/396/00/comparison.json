{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n@@ -37,1 +39,0 @@\n-import java.util.List;\n@@ -340,3 +341,0 @@\n-     * @apiNote if the layout path has one (or more) free dimensions,\n-     * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.\n-     *\n@@ -353,1 +351,24 @@\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset, EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offset,\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);\n+    }\n+\n+    \/**\n+     * Creates a method handle that can be used to compute the offset, in bits, of the layout selected\n+     * by a given layout path, where the path is considered rooted in this layout.\n+     *\n+     * <p>This is like {@link #bitOffset(PathElement...)}, except that free dimensions\n+     * ({@link PathElement#sequenceElement()}) are accepted, and translated into {@code long} parameters\n+     * of the returned method handle, to be specified later.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a method handle that can be used to compute the bit offset of the layout element\n+     * specified by the given layout path elements, when supplied with the missing sequence element indexes.\n+     * @throws IllegalArgumentException if the layout path contains one or more path elements that select\n+     * multiple sequence element indices (see {@link PathElement#sequenceElement(long, long)}).\n+     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n+     *\/\n+    default MethodHandle bitOffsetHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::offsetHandle,\n+                EnumSet.of(PathKind.SEQUENCE_RANGE), elements);\n@@ -360,3 +381,0 @@\n-     * @apiNote if the layout path has one (or more) free dimensions,\n-     * the offset is computed as if all the indices corresponding to such dimensions were set to {@code 0}.\n-     *\n@@ -374,2 +392,27 @@\n-        return Utils.bitsToBytesOrThrow(bitOffset(elements),\n-                () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\"));\n+        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.bitsToBytesThrowOffset);\n+    }\n+\n+    \/**\n+     * Creates a method handle that can be used to compute the offset, in bytes, of the layout selected\n+     * by a given layout path, where the path is considered rooted in this layout.\n+     *\n+     * <p>This is like {@link #byteOffset(PathElement...)}, except that free dimensions\n+     * ({@link PathElement#sequenceElement()}) are accepted, and translated into {@code long} parameters\n+     * of the returned method handle, to be specified later.\n+     *\n+     * <p>The returned method handle will throw an {@link UnsupportedOperationException} if the computed\n+     * offset in bits is not a multiple of 8.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a method handle that can be used to compute the byte offset of the layout element\n+     * specified by the given layout path elements, when supplied with the missing sequence element indexes.\n+     * @throws IllegalArgumentException if the layout path contains one or more path elements that select\n+     * multiple sequence element indices (see {@link PathElement#sequenceElement(long, long)}).\n+     * @throws UnsupportedOperationException if one of the layouts traversed by the layout path has unspecified size.\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n+     *\/\n+    default MethodHandle byteOffsetHandle(PathElement... elements) {\n+        MethodHandle mh = bitOffsetHandle(elements);\n+        mh = MethodHandles.filterReturnValue(mh, Utils.MH_bitsToBytesOrThrowForOffset);\n+        return mh;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":53,"deletions":10,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+    private static final MethodHandle MH_ADD_SCALED_OFFSET;\n+\n+    private static final int UNSPECIFIED_ELEM_INDEX = -1;\n@@ -67,1 +70,2 @@\n-            ADD_STRIDE = MethodHandles.lookup().findStatic(LayoutPath.class, \"addStride\",\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            ADD_STRIDE = lookup.findStatic(LayoutPath.class, \"addStride\",\n@@ -69,0 +73,2 @@\n+            MH_ADD_SCALED_OFFSET = lookup.findStatic(LayoutPath.class, \"addScaledOffset\",\n+                    MethodType.methodType(long.class, long.class, long.class, long.class));\n@@ -96,1 +102,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(sizeFunc.applyAsLong(elem)), -1, this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(sizeFunc.applyAsLong(elem)), UNSPECIFIED_ELEM_INDEX, this);\n@@ -105,1 +111,2 @@\n-        return LayoutPath.nestedPath(elem, offset + (start * elemSize), addStride(elemSize * step), -1, this);\n+        return LayoutPath.nestedPath(elem, offset + (start * elemSize), addStride(elemSize * step),\n+                UNSPECIFIED_ELEM_INDEX, this);\n@@ -188,0 +195,21 @@\n+    private static long addScaledOffset(long base, long index, long stride) {\n+        return base + (stride * index);\n+    }\n+\n+    public MethodHandle offsetHandle() {\n+        MethodHandle mh = MethodHandles.identity(long.class);\n+        LayoutPath cur = this;\n+        while (cur.enclosing != null) {\n+            if (cur.enclosing.layout instanceof SequenceLayout\n+                && cur.elementIndex == UNSPECIFIED_ELEM_INDEX) { \/\/ sequenceElement()\n+                MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2, cur.layout.bitSize());\n+                \/\/ (J, ...) -> J to (J, J, ...) -> J\n+                \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n+                mh = MethodHandles.collectArguments(mh, 0, collector);\n+            }\n+            cur = cur.enclosing;\n+        }\n+        mh = MethodHandles.insertArguments(mh, 0, offset);\n+        return mh;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -50,0 +51,4 @@\n+    public static final MethodHandle MH_bitsToBytesOrThrowForOffset;\n+\n+    public static final Supplier<RuntimeException> bitsToBytesThrowOffset\n+        = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n@@ -53,1 +58,2 @@\n-            SEGMENT_FILTER = MethodHandles.lookup().findStatic(Utils.class, \"filterSegment\",\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            SEGMENT_FILTER = lookup.findStatic(Utils.class, \"filterSegment\",\n@@ -55,0 +61,5 @@\n+            MH_bitsToBytesOrThrowForOffset = MethodHandles.insertArguments(\n+                lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n+                    MethodType.methodType(long.class, long.class, Supplier.class)),\n+                1,\n+                bitsToBytesThrowOffset);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -40,0 +41,3 @@\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n@@ -46,1 +50,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n@@ -52,1 +56,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n@@ -58,2 +62,2 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.bitOffset(PathElement.sequenceElement());\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n+        g.bitOffset(sequenceElement());\n@@ -64,2 +68,2 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.byteOffset(PathElement.sequenceElement());\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n+        g.byteOffset(sequenceElement());\n@@ -70,2 +74,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(), PathElement.sequenceElement());\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n+        seq.bitOffset(sequenceElement(), sequenceElement());\n@@ -76,2 +80,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(), PathElement.sequenceElement());\n+        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n+        seq.byteOffset(sequenceElement(), sequenceElement());\n@@ -82,1 +86,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n@@ -88,1 +92,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n@@ -99,1 +103,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n@@ -105,1 +109,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n@@ -111,2 +115,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(6));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(6));\n@@ -117,2 +121,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(6));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.byteOffset(sequenceElement(6));\n@@ -123,1 +127,1 @@\n-       PathElement.sequenceElement(-2);\n+       sequenceElement(-2);\n@@ -128,2 +132,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(-2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(-2));\n@@ -134,2 +138,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(-2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.byteOffset(sequenceElement(-2));\n@@ -140,2 +144,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(6, 2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(6, 2));\n@@ -146,1 +150,1 @@\n-        PathElement.sequenceElement(-2, 2);\n+        sequenceElement(-2, 2);\n@@ -151,2 +155,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.bitOffset(PathElement.sequenceElement(-2, 2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.bitOffset(sequenceElement(-2, 2));\n@@ -157,2 +161,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT);\n-        seq.byteOffset(PathElement.sequenceElement(-2, 2));\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        seq.byteOffset(sequenceElement(-2, 2));\n@@ -163,2 +167,14 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT));\n-        seq.varHandle(int.class, PathElement.sequenceElement());\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        seq.varHandle(int.class, sequenceElement());\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBitOffsetHandleBadRange() {\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        seq.bitOffsetHandle(sequenceElement(0, 1)); \/\/ ranges not accepted\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testByteOffsetHandleBadRange() {\n+        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        seq.byteOffsetHandle(sequenceElement(0, 1)); \/\/ ranges not accepted\n@@ -169,1 +185,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(3), MemoryLayouts.JAVA_INT.withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(3), JAVA_INT.withName(\"foo\"));\n@@ -173,0 +189,37 @@\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBitOffsetBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.bitOffset(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testByteOffsetBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.byteOffset(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBitOffsetHandleBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.bitOffsetHandle(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testByteOffsetHandleBadUnboundedSequenceTraverse() {\n+        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        layout.byteOffsetHandle(sequenceElement(1), sequenceElement(0));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBadByteOffsetNoMultipleOf8() {\n+        MemoryLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(7), JAVA_INT.withName(\"x\"));\n+        layout.byteOffset(groupElement(\"x\"));\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testBadByteOffsetHandleNoMultipleOf8() throws Throwable {\n+        MemoryLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(7), JAVA_INT.withName(\"x\"));\n+        MethodHandle handle = layout.byteOffsetHandle(groupElement(\"x\"));\n+        handle.invoke();\n+    }\n+\n@@ -175,1 +228,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n+        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n@@ -194,1 +247,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, MemoryLayouts.JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n@@ -213,1 +266,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n@@ -215,1 +268,1 @@\n-        for (PathElement e : List.of( PathElement.sequenceElement(), PathElement.sequenceElement(0, 2) )) {\n+        for (PathElement e : List.of( sequenceElement(), sequenceElement(0, 2) )) {\n@@ -233,2 +286,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n-        for (PathElement e : List.of( PathElement.sequenceElement(0), PathElement.sequenceElement(0, 2) )) {\n+        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n+        for (PathElement e : List.of( sequenceElement(0), sequenceElement(0, 2) )) {\n@@ -246,2 +299,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n-        for (PathElement e : List.of( PathElement.sequenceElement(0), PathElement.sequenceElement(0, 2) )) {\n+        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n+        for (PathElement e : List.of( sequenceElement(0), sequenceElement(0, 2) )) {\n@@ -346,1 +399,1 @@\n-        MemoryLayout selected = g.select(PathElement.sequenceElement());\n+        MemoryLayout selected = g.select(sequenceElement());\n@@ -352,1 +405,1 @@\n-            long bitOffset = g.bitOffset(PathElement.sequenceElement(i));\n+            long bitOffset = g.bitOffset(sequenceElement(i));\n@@ -354,1 +407,1 @@\n-            long byteOffset = g.byteOffset(PathElement.sequenceElement(i));\n+            long byteOffset = g.byteOffset(sequenceElement(i));\n@@ -360,1 +413,1 @@\n-        SequenceLayout seq2 = (SequenceLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, PathElement.sequenceElement());\n+        SequenceLayout seq2 = (SequenceLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, sequenceElement());\n@@ -363,0 +416,54 @@\n+\n+    @Test(dataProvider =  \"offsetHandleCases\")\n+    public void testOffsetHandle(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                 long expectedBitOffset) throws Throwable {\n+        MethodHandle bitOffsetHandle = layout.bitOffsetHandle(pathElements);\n+        bitOffsetHandle = bitOffsetHandle.asSpreader(long[].class, indexes.length);\n+        long actualBitOffset = (long) bitOffsetHandle.invokeExact(indexes);\n+        assertEquals(actualBitOffset, expectedBitOffset);\n+        if (expectedBitOffset % 8 == 0) {\n+            MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+            byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+            long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+            assertEquals(actualByteOffset, expectedBitOffset \/ 8);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] offsetHandleCases() {\n+        return new Object[][]{\n+            {\n+                MemoryLayout.ofSequence(10, JAVA_INT),\n+                new PathElement[] { sequenceElement() },\n+                new long[] { 4 },\n+                JAVA_INT.bitSize() * 4\n+            },\n+            {\n+                MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(JAVA_INT, JAVA_INT.withName(\"y\"))),\n+                new PathElement[] { sequenceElement(), groupElement(\"y\") },\n+                new long[] { 4 },\n+                (JAVA_INT.bitSize() * 2) * 4 + JAVA_INT.bitSize()\n+            },\n+            {\n+                MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(5), JAVA_INT.withName(\"y\"))),\n+                new PathElement[] { sequenceElement(), groupElement(\"y\") },\n+                new long[] { 4 },\n+                (JAVA_INT.bitSize() + 5) * 4 + 5\n+            },\n+            {\n+                MemoryLayout.ofSequence(10, MemoryLayout.ofUnion(JAVA_INT, JAVA_INT.withName(\"y\"))),\n+                new PathElement[] { sequenceElement(), groupElement(\"y\") },\n+                new long[] { 4 },\n+                JAVA_INT.bitSize() * 4\n+            },\n+            {\n+                MemoryLayout.ofStruct(\n+                    MemoryLayout.ofSequence(10, JAVA_INT).withName(\"data\")\n+                ),\n+                new PathElement[] { groupElement(\"data\"), sequenceElement() },\n+                new long[] { 4 },\n+                JAVA_INT.bitSize() * 4\n+            },\n+        };\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":152,"deletions":45,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -291,0 +291,10 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testBitOffsetHandleWithNullPathElement() {\n+        MemoryLayouts.BITS_8_BE.bitOffsetHandle(new MemoryLayout.PathElement[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testBitOffsetHandleWithNullElements() {\n+        MemoryLayouts.BITS_8_BE.bitOffsetHandle(null);\n+    }\n+\n@@ -301,0 +311,10 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testByteOffsetHandleWithNullPathElement() {\n+        MemoryLayouts.BITS_8_BE.byteOffsetHandle(new MemoryLayout.PathElement[] { null });\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testByteOffsetHandleWithNullElements() {\n+        MemoryLayouts.BITS_8_BE.byteOffsetHandle(null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}