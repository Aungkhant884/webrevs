{"files":[{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Type;\n+import java.util.stream.Collectors;\n+\n+public class AnnotationWriter implements Type.Visitor<String, Void> {\n+    @Override\n+    public String visitPrimitive(Type.Primitive t, Void aVoid) {\n+        if (t.kind().layout().isEmpty()) {\n+            return \"void\"; \/\/skip for now\n+        } else {\n+            return t.kind().typeName();\n+        }\n+    }\n+\n+    @Override\n+    public String visitDelegated(Type.Delegated t, Void aVoid) {\n+        if (t.kind() == Type.Delegated.Kind.TYPEDEF) {\n+            return t.name().get();\n+        } else if (t.kind() == Type.Delegated.Kind.POINTER) {\n+            String typeStr = t.type().accept(this, null);\n+            \/\/ FIXME Revisit this logic for pointer to function types\n+            if (t.type() instanceof Type.Function) {\n+                return typeStr.replace(\"(\", \"(*)(\");\n+            } else {\n+                return typeStr + \"*\";\n+            }\n+        } else {\n+            String prefix = switch (t.kind()) {\n+                case ATOMIC -> \"_Atomic\";\n+                case COMPLEX -> \"complex\";\n+                case SIGNED -> \"signed\";\n+                case UNSIGNED -> \"unsigned\";\n+                case VOLATILE -> \"volatile\";\n+                default -> throw new IllegalStateException(\"Invalid input\" + t);\n+            };\n+            return prefix + \" \" + t.type().accept(this, null);\n+        }\n+    }\n+\n+    @Override\n+    public String visitFunction(Type.Function t, Void aVoid) {\n+        String ret = t.returnType().accept(this, null);\n+        String args = t.argumentTypes().stream().map(p -> p.accept(this, null))\n+                .collect(Collectors.joining(\",\", \"(\", \")\"));\n+        return ret + args;\n+    }\n+\n+    @Override\n+    public String visitDeclared(Type.Declared t, Void aVoid) {\n+        String name = t.tree().name();\n+        return switch (t.tree().kind()) {\n+            case STRUCT -> \"struct \" + name;\n+            case UNION -> \"union \" + name;\n+            case ENUM -> \"enum \" + name;\n+            default -> name;\n+        };\n+    }\n+\n+    @Override\n+    public String visitArray(Type.Array t, Void aVoid) {\n+        if (t.kind() == Type.Array.Kind.VECTOR) {\n+            return \"\"; \/\/skip for now\n+        } else {\n+            return t.elementType().accept(this, null) + \"[]\";\n+        }\n+    }\n+\n+    @Override\n+    public String visitType(Type t, Void aVoid) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    String getCAnnotation(Type t) {\n+        return \"@C(\\\"\" + t.accept(this, null) + \"\\\")\";\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/AnnotationWriter.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -91,1 +91,1 @@\n-    void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor fDesc) {\n+    void addFunctionalInterface(String name, MethodType mtype, FunctionDescriptor fDesc, String anno) {\n@@ -104,1 +104,1 @@\n-        addFunctionalFactory(name, mtype, fDesc);\n+        addFunctionalFactory(name, mtype, fDesc, anno);\n@@ -112,1 +112,2 @@\n-    void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc, boolean varargs, List<String> paramNames) {\n+    void addStaticFunctionWrapper(String javaName, String nativeName, MethodType mtype, FunctionDescriptor desc,\n+                                  boolean varargs, List<String> paramNames, List<String> annos, String returnAnno) {\n@@ -115,1 +116,6 @@\n-        append(PUB_MODS + mtype.returnType().getName() + \" \" + javaName + \" (\");\n+        append(PUB_MODS);\n+        if (mtype.returnType() != void.class) {\n+            append(returnAnno);\n+            append(' ');\n+        }\n+        append(mtype.returnType().getSimpleName() + \" \" + javaName + \" (\");\n@@ -133,1 +139,1 @@\n-            append(delim + pType.getName() + \" \" + pName);\n+            append(delim + annos.get(i) + \" \" + pType.getSimpleName() + \" \" + pName);\n@@ -169,1 +175,1 @@\n-    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n+    void emitPrimitiveTypedef(Type.Primitive primType, String name, String anno) {\n@@ -175,1 +181,1 @@\n-            append(\"ValueLayout \");\n+            append(anno + \" ValueLayout \");\n@@ -213,1 +219,1 @@\n-    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc) {\n+    private void addFunctionalFactory(String className, MethodType mtype, FunctionDescriptor fDesc, String anno) {\n@@ -215,1 +221,1 @@\n-        append(PUB_MODS + \"MemorySegment allocate(\" + className + \" fi) {\\n\");\n+        append(PUB_MODS + \" \" + anno + \" MemorySegment allocate(\" + className + \" fi) {\\n\");\n@@ -225,1 +231,1 @@\n-        append(PUB_MODS + \"MemorySegment allocate(\" + className + \" fi, NativeScope scope) {\\n\");\n+        append(PUB_MODS + \" \" + anno + \" MemorySegment allocate(\" + className + \" fi, NativeScope scope) {\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderBuilder.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        emitForwardGetter(constantHelper.addLayout(javaName, layout));\n+        emitForwardGetter(constantHelper.addLayout(javaName, layout), \"\");\n@@ -110,1 +110,1 @@\n-        emitForwardGetter(constantHelper.addGlobalVarHandle(javaName, nativeName, layout, type));\n+        emitForwardGetter(constantHelper.addGlobalVarHandle(javaName, nativeName, layout, type), \"\");\n@@ -114,1 +114,1 @@\n-        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs));\n+        emitForwardGetter(constantHelper.addMethodHandle(javaName, nativeName, mtype, desc, varargs), \"\");\n@@ -118,1 +118,1 @@\n-        emitForwardGetter(constantHelper.addSegment(javaName, nativeName, layout));\n+        emitForwardGetter(constantHelper.addSegment(javaName, nativeName, layout), \"\");\n@@ -121,2 +121,2 @@\n-    void addConstantGetter(String javaName, Class<?> type, Object value) {\n-        emitForwardGetter(constantHelper.addConstant(javaName, type, value));\n+    void addConstantGetter(String javaName, Class<?> type, Object value, String anno) {\n+        emitForwardGetter(constantHelper.addConstant(javaName, type, value), anno);\n@@ -125,1 +125,1 @@\n-    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n@@ -128,1 +128,1 @@\n-        append(PUB_MODS + type.getName() + \" \" + javaName + \"$get() {\\n\");\n+        append(PUB_MODS + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n@@ -140,1 +140,1 @@\n-    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n@@ -143,1 +143,1 @@\n-        append(PUB_MODS + \"void \" + javaName + \"$set(\" + type.getName() + \" x) {\\n\");\n+        append(PUB_MODS + \"void \" + javaName + \"$set(\" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n@@ -176,1 +176,1 @@\n-    protected void emitForwardGetter(DirectMethodHandleDesc desc) {\n+    protected void emitForwardGetter(DirectMethodHandleDesc desc, String anno) {\n@@ -179,1 +179,1 @@\n-        append(PUB_MODS + displayName(desc.invocationType().returnType()) + \" \" + desc.methodName() + \"() {\\n\");\n+        append(PUB_MODS + anno + \" \" + displayName(desc.invocationType().returnType()) + \" \" + desc.methodName() + \"() {\\n\");\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    protected final AnnotationWriter annotationWriter = new AnnotationWriter();\n@@ -145,0 +146,1 @@\n+            files.add(jfoFromString(pkgName,\"C\", getCAnnotationSource()));\n@@ -160,0 +162,6 @@\n+    private String getCAnnotationSource() throws URISyntaxException, IOException {\n+        URL cAnnotation = OutputFactory.class.getResource(\"resources\/C.java.template\");\n+        return (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n+                String.join(\"\\n\", Files.readAllLines(Paths.get(cAnnotation.toURI())));\n+    }\n+\n@@ -188,0 +196,1 @@\n+        String anno = annotationWriter.getCAnnotation(constant.type());\n@@ -190,1 +199,1 @@\n-                typeTranslator.getJavaType(constant.type()), constant.value());\n+                typeTranslator.getJavaType(constant.type()), constant.value(), anno);\n@@ -210,1 +219,3 @@\n-                    currentBuilder = new StructBuilder(currentBuilder, className, parentLayoutFieldName, parentLayout, pkgName, constantHelper);\n+                    String anno = annotationWriter.getCAnnotation(Type.declared(d));\n+                    String arrayAnno = annotationWriter.getCAnnotation(Type.array(Type.declared(d)));\n+                    currentBuilder = new StructBuilder(currentBuilder, className, parentLayoutFieldName, parentLayout, pkgName, constantHelper, anno, arrayAnno);\n@@ -298,0 +309,6 @@\n+        List<String> annos = funcTree.parameters()\n+                .stream()\n+                .map(Declaration.Variable::type)\n+                .map(annotationWriter::getCAnnotation)\n+                .collect(Collectors.toList());\n+        String returnAnno = annotationWriter.getCAnnotation(funcTree.type().returnType());\n@@ -299,1 +316,1 @@\n-                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames);\n+                Type.descriptorFor(funcTree.type()).orElseThrow(), funcTree.type().varargs(), paramNames, annos, returnAnno);\n@@ -311,1 +328,2 @@\n-                toplevelBuilder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow());\n+                String anno = annotationWriter.getCAnnotation(param.type());\n+                toplevelBuilder.addFunctionalInterface(name, fitype, Type.descriptorFor(f).orElseThrow(), anno);\n@@ -374,1 +392,2 @@\n-             toplevelBuilder.emitPrimitiveTypedef((Type.Primitive)type, tree.name());\n+             String anno = annotationWriter.getCAnnotation(type);\n+             toplevelBuilder.emitPrimitiveTypedef((Type.Primitive)type, tree.name(), anno);\n@@ -406,0 +425,1 @@\n+        String anno = annotationWriter.getCAnnotation(type);\n@@ -430,2 +450,2 @@\n-                currentBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz);\n-                currentBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz);\n+                currentBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, anno);\n+                currentBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, anno);\n@@ -441,2 +461,2 @@\n-                    toplevelBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz);\n-                    toplevelBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz);\n+                    toplevelBuilder.addGetter(fieldName, tree.name(), treeLayout, clazz, anno);\n+                    toplevelBuilder.addSetter(fieldName, tree.name(), treeLayout, clazz, anno);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    private final String structAnno;\n+    private final String structArrayAnno;\n@@ -39,1 +41,2 @@\n-    StructBuilder(JavaSourceBuilder prev, String className, String parentLayoutFieldName, MemoryLayout layout, String pkgName, ConstantHelper constantHelper) {\n+    StructBuilder(JavaSourceBuilder prev, String className, String parentLayoutFieldName, MemoryLayout parentLayout, String pkgName,\n+            ConstantHelper constantHelper, String structAnno, String structArrayAnno) {\n@@ -43,2 +46,3 @@\n-        this.parentLayout = layout;\n-\n+        this.parentLayout = parentLayout;\n+        this.structAnno = structAnno;\n+        this.structArrayAnno = structArrayAnno;\n@@ -141,1 +145,1 @@\n-    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+    void addGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n@@ -144,1 +148,1 @@\n-        append(PUB_MODS + type.getName() + \" \" + javaName + \"$get(MemorySegment seg) {\\n\");\n+        append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + this.structAnno + \" MemorySegment seg) {\\n\");\n@@ -148,1 +152,1 @@\n-                + fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type, parentLayoutFieldName, parentLayout) + \".get(seg);\\n\");\n+                + fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) + \".get(seg);\\n\");\n@@ -154,1 +158,1 @@\n-        addIndexGetter(javaName, nativeName, layout, type, parentLayoutFieldName, parentLayout);\n+        addIndexGetter(javaName, nativeName, layout, type, anno);\n@@ -158,1 +162,1 @@\n-    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+    void addSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n@@ -161,2 +165,2 @@\n-        String param = MemorySegment.class.getName() + \" seg\";\n-        append(PUB_MODS + \"void \" + javaName + \"$set(\" + param + \", \" + type.getName() + \" x) {\\n\");\n+        String param = MemorySegment.class.getSimpleName() + \" seg\";\n+        append(PUB_MODS + \"void \" + javaName + \"$set(\" + this.structAnno + \" \" + param + \", \" + anno + \" \" + type.getSimpleName() + \" x) {\\n\");\n@@ -165,1 +169,1 @@\n-        append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type, parentLayoutFieldName, parentLayout) + \".set(seg, x);\\n\");\n+        append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) + \".set(seg, x);\\n\");\n@@ -171,1 +175,1 @@\n-        addIndexSetter(javaName, nativeName, layout, type, parentLayoutFieldName, parentLayout);\n+        addIndexSetter(javaName, nativeName, layout, type, anno);\n@@ -204,1 +208,1 @@\n-        append(\"MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n+        append(structAnno + \" MemorySegment allocate() { return MemorySegment.allocateNative($LAYOUT()); }\\n\");\n@@ -212,1 +216,1 @@\n-        append(\"MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n+        append(structAnno + \" MemorySegment allocate(NativeScope scope) { return scope.allocate($LAYOUT()); }\\n\");\n@@ -220,1 +224,1 @@\n-        append(\"MemorySegment allocateArray(int len) {\\n\");\n+        append(structArrayAnno + \" MemorySegment allocateArray(int len) {\\n\");\n@@ -233,1 +237,1 @@\n-        append(\"MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n+        append(structArrayAnno + \" MemorySegment allocateArray(int len, NativeScope scope) {\\n\");\n@@ -242,1 +246,1 @@\n-    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String parentJavaName, MemoryLayout parentLayout) {\n+    private void addIndexGetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n@@ -245,2 +249,2 @@\n-        String params = MemorySegment.class.getName() + \" addr, long index\";\n-        append(PUB_MODS + type.getName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n+        String params = this.structAnno + \" \" + MemorySegment.class.getSimpleName() + \" seg, long index\";\n+        append(PUB_MODS + \" \" + anno + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n@@ -250,2 +254,2 @@\n-                + fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type, parentJavaName, parentLayout) +\n-                \".get(addr.asSlice(index*sizeof()));\\n\");\n+                + fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) +\n+                \".get(seg.asSlice(index*sizeof()));\\n\");\n@@ -258,1 +262,1 @@\n-    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String parentJavaName, MemoryLayout parentLayout) {\n+    private void addIndexSetter(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String anno) {\n@@ -261,1 +265,1 @@\n-        String params = MemorySegment.class.getName() + \" addr, long index, \" + type.getName() + \" x\";\n+        String params = this.structAnno + \" \" + MemorySegment.class.getSimpleName() + \" seg, long index, \" + anno + \" \" + type.getSimpleName() + \" x\";\n@@ -265,2 +269,2 @@\n-        append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type, parentJavaName, parentLayout) +\n-                \".set(addr.asSlice(index*sizeof()), x);\\n\");\n+        append(fieldVarHandleGetCallString(getQualifiedName(javaName), nativeName, layout, type) +\n+                \".set(seg.asSlice(index*sizeof()), x);\\n\");\n@@ -273,2 +277,2 @@\n-    private String fieldVarHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type, String parentJavaName, MemoryLayout parentLayout) {\n-        return getCallString(constantHelper.addFieldVarHandle(javaName, nativeName, layout, type, parentJavaName, parentLayout));\n+    private String fieldVarHandleGetCallString(String javaName, String nativeName, MemoryLayout layout, Class<?> type) {\n+        return getCallString(constantHelper.addFieldVarHandle(javaName, nativeName, layout, type, parentLayoutFieldName, parentLayout));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,21 @@\n+\/\/ Generated by jextract\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Annotation to indicate C types\n+ *\/\n+@Target({ ElementType.TYPE_USE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@Documented\n+public @interface C {\n+    \/**\n+     * The C type associated with a given Java type\n+     * @return The C type associated with a given Java type\n+     *\/\n+    String value();\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/C.java.template","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Parameter;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8252634\n+ * @summary jextract should generate type annotations for C types\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @run testng\/othervm -Dforeign.restricted=permit Test8252634\n+ *\/\n+public class Test8252634 extends JextractToolRunner {\n+    private Class<? extends Annotation> cAnnoClass;\n+    private Method cValueMethod;\n+\n+    @Test\n+    public void test() throws Throwable {\n+        Path outputPath = getOutputFilePath(\"output8252634\");\n+        Path headerFile = getInputFilePath(\"test8252634.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            this.cAnnoClass = (Class<? extends Annotation>)loader.loadClass(\"C\");\n+            this.cValueMethod = findMethod(cAnnoClass, \"value\");\n+\n+            Class<?> headerClass = loader.loadClass(\"test8252634_h\");\n+            checkGlobalFunctions(headerClass);\n+            checkGlobalVariables(headerClass);\n+\n+            Class<?> pointClass = loader.loadClass(\"test8252634_h$Point\");\n+            checkPointGetters(pointClass);\n+            checkPointSetters(pointClass);\n+            checkPointAllocate(pointClass);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    private void checkGlobalFunctions(Class<?> headerClass) throws Throwable {\n+        Method make = findMethod(headerClass, \"make\", int.class, int.class);\n+        Parameter[] params = make.getParameters();\n+        checkAnnotation(params[0].getAnnotatedType(), \"int\");\n+        checkAnnotation(params[1].getAnnotatedType(), \"int\");\n+        checkAnnotation(make.getAnnotatedReturnType(), \"struct Point*\");\n+        Method func = findFirstMethod(headerClass, \"func\");\n+        params = func.getParameters();\n+        checkAnnotation(params[0].getAnnotatedType(), \"int(*)(int)\");\n+    }\n+\n+    private void checkGlobalVariables(Class<?> headerClass) throws Throwable {\n+        Method pGetter = findMethod(headerClass, \"p$get\");\n+        checkAnnotation(pGetter.getAnnotatedReturnType(), \"int_ptr\");\n+        Method pSetter = findMethod(headerClass, \"p$set\", MemoryAddress.class);\n+        checkAnnotation(pSetter.getParameters()[0].getAnnotatedType(), \"int_ptr\");\n+    }\n+\n+    private void checkPointGetters(Class<?> pointClass) throws Throwable {\n+        Method xGetter = findMethod(pointClass, \"x$get\", MemorySegment.class);\n+        checkAnnotation(xGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(xGetter.getAnnotatedReturnType(), \"int\");\n+        Method yGetter = findMethod(pointClass, \"y$get\", MemorySegment.class);\n+        checkAnnotation(yGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(yGetter.getAnnotatedReturnType(), \"int\");\n+        Method xIndexedGetter = findMethod(pointClass, \"x$get\", MemorySegment.class, long.class);\n+        checkAnnotation(xIndexedGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(xIndexedGetter.getAnnotatedReturnType(), \"int\");\n+        Method yIndexedGetter = findMethod(pointClass, \"y$get\", MemorySegment.class, long.class);\n+        checkAnnotation(yIndexedGetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(yIndexedGetter.getAnnotatedReturnType(), \"int\");\n+    }\n+\n+    private void checkPointSetters(Class<?> pointClass) throws Throwable {\n+        Method xSetter = findMethod(pointClass, \"x$set\", MemorySegment.class, int.class);\n+        checkAnnotation(xSetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(xSetter.getParameters()[1].getAnnotatedType(), \"int\");\n+        Method ySetter = findMethod(pointClass, \"y$set\", MemorySegment.class, int.class);\n+        checkAnnotation(ySetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(ySetter.getParameters()[1].getAnnotatedType(), \"int\");\n+        Method xIndexedSetter = findMethod(pointClass, \"x$set\", MemorySegment.class, long.class, int.class);\n+        checkAnnotation(xIndexedSetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(xIndexedSetter.getParameters()[2].getAnnotatedType(), \"int\");\n+        Method yIndexedSetter = findMethod(pointClass, \"y$set\", MemorySegment.class, long.class, int.class);\n+        checkAnnotation(yIndexedSetter.getParameters()[0].getAnnotatedType(), \"struct Point\");\n+        checkAnnotation(yIndexedSetter.getParameters()[2].getAnnotatedType(), \"int\");\n+    }\n+\n+    private void checkPointAllocate(Class<?> pointClass) throws Throwable {\n+        Method allocate = findMethod(pointClass, \"allocate\");\n+        checkAnnotation(allocate.getAnnotatedReturnType(), \"struct Point\");\n+        Method allocateArray = findMethod(pointClass, \"allocateArray\", int.class);\n+        checkAnnotation(allocateArray.getAnnotatedReturnType(), \"struct Point[]\");\n+    }\n+\n+    private void checkAnnotation(AnnotatedElement ae, String expected) throws Throwable {\n+        Object anno = ae.getAnnotation(cAnnoClass);\n+        assertEquals(cValueMethod.invoke(anno).toString(), expected);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8252634.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+struct Point {\n+    int x; int y;\n+};\n+\n+struct Point* make(int x, int y);\n+\n+void func(int (*callback)(int));\n+\n+typedef int* int_ptr;\n+int_ptr p;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8252634.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}