{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.reflect.Array;\n@@ -49,3 +50,3 @@\n- * Multiple values can be read and written in bulk from and to Java arrays, using accessors like {@link #copy(int[], int, MemorySegment, long, int)},\n- * and {@link #copy(MemorySegment, long, int[], int, int)}. These accessors all accept the following parameters\n- * (source parameters are laid out before destination parameters, similarly to {@link System#arraycopy(Object, int, Object, int, int)}):\n+ * Multiple values can be read and written in bulk from and to Java arrays, using accessors like {@link #copy(MemorySegment, long, Object, int, int)}.\n+ * These accessors all accept the following parameters (source parameters are laid out before destination parameters, similarly to\n+ * {@link System#arraycopy(Object, int, Object, int, int)}):\n@@ -79,0 +80,2 @@\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n@@ -80,14 +83,0 @@\n-    private final static ByteOrder NON_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n-            ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n-    private final static ValueLayout JAVA_SHORT_NO = MemoryLayouts.JAVA_SHORT.withBitAlignment(8);\n-    private final static ValueLayout JAVA_SHORT_NNO = JAVA_SHORT_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_CHAR_NO = MemoryLayouts.JAVA_CHAR.withBitAlignment(8);\n-    private final static ValueLayout JAVA_CHAR_NNO = JAVA_CHAR_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_INT_NO = MemoryLayouts.JAVA_INT.withBitAlignment(8);\n-    private final static ValueLayout JAVA_INT_NNO = JAVA_INT_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_FLOAT_NO = MemoryLayouts.JAVA_FLOAT.withBitAlignment(8);\n-    private final static ValueLayout JAVA_FLOAT_NNO = JAVA_FLOAT_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_LONG_NO = MemoryLayouts.JAVA_LONG.withBitAlignment(8);\n-    private final static ValueLayout JAVA_LONG_NNO = JAVA_LONG_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_DOUBLE_NO = MemoryLayouts.JAVA_DOUBLE.withBitAlignment(8);\n-    private final static ValueLayout JAVA_DOUBLE_NNO = JAVA_DOUBLE_NO.withOrder(NON_NATIVE_ORDER);\n@@ -636,6 +625,0 @@\n-    private static ValueLayout pick(ByteOrder order, ValueLayout nativeLayout, ValueLayout nonNativeLayout) {\n-        Objects.requireNonNull(order);\n-        return order == ByteOrder.nativeOrder() ?\n-                nativeLayout : nonNativeLayout;\n-    }\n-\n@@ -643,82 +626,1 @@\n-     * Copies a number of byte elements from a source byte array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source byte array.\n-     * @param srcIndex the starting index of the source byte array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of byte elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            byte[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, elementCount,\n-                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of byte elements from a source segment to a destination byte array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination byte array.\n-     * @param dstIndex the starting index of the destination byte array.\n-     * @param elementCount the number of byte elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            byte[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source char array.\n-     * @param srcIndex the starting index of the source char array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of char elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source char array.\n-     * @param srcIndex the starting index of the source char array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of char elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount, ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndex the starting index of the destination char array.\n-     * @param elementCount the number of char elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            char[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n+     * Copies a number of double elements from a source segment to a destination array,\n@@ -728,4 +630,5 @@\n-     * @param dstArray the destination char array.\n-     * @param dstIndex the starting index of the destination char array.\n-     * @param elementCount the number of char elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -736,121 +639,1 @@\n-            char[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source short array.\n-     * @param srcIndex the starting index of the source short array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of short elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source short array.\n-     * @param srcIndex the starting index of the source short array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of short elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndex the starting index of the destination short array.\n-     * @param elementCount the number of short elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            short[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndex the starting index of the destination short array.\n-     * @param elementCount the number of short elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            short[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source int array.\n-     * @param srcIndex the starting index of the source int array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of int elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source int array.\n-     * @param srcIndex the starting index of the source int array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of int elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndex the starting index of the destination int array.\n-     * @param elementCount the number of int elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            int[] dstArray, int dstIndex, int elementCount) {\n+            Object dstArray, int dstIndex, int elementCount) {\n@@ -861,1 +644,1 @@\n-     * Copies a number of int elements from a source segment to a destination int array,\n+     * Copies a number of double elements from a source segment to a destination array,\n@@ -865,3 +648,3 @@\n-     * @param dstArray the destination int array.\n-     * @param dstIndex the starting index of the destination int array.\n-     * @param elementCount the number of int elements to be copied.\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n@@ -870,0 +653,2 @@\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -874,88 +659,18 @@\n-            int[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source float array.\n-     * @param srcIndex the starting index of the source float array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of float elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source float array.\n-     * @param srcIndex the starting index of the source float array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of float elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndex the starting index of the destination float array.\n-     * @param elementCount the number of float elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            float[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndex the starting index of the destination float array.\n-     * @param elementCount the number of float elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a float swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            float[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source long array.\n-     * @param srcIndex the starting index of the source long array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of long elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n+            Object dstArray, int dstIndex, int elementCount, ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        int dstBase = UNSAFE.arrayBaseOffset(dstArray.getClass());\n+        int dstWidth = UNSAFE.arrayIndexScale(dstArray.getClass());\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n@@ -965,1 +680,1 @@\n-     * Copies a number of long elements from a source long array to a destination segment,\n+     * Copies a number of double elements from a source array to a destination segment,\n@@ -967,2 +682,2 @@\n-     * @param srcArray the source long array.\n-     * @param srcIndex the starting index of the source long array.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n@@ -971,19 +686,3 @@\n-     * @param elementCount the number of long elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndex the starting index of the destination long array.\n-     * @param elementCount the number of long elements to be copied.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -993,37 +692,2 @@\n-            MemorySegment srcSegment, long srcOffset,\n-            long[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndex the starting index of the destination long array.\n-     * @param elementCount the number of long elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            long[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source double array.\n-     * @param srcIndex the starting index of the source double array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of double elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, long dstOffset, int elementCount) {\n@@ -1034,1 +698,1 @@\n-     * Copies a number of double elements from a source double array to a destination segment,\n+     * Copies a number of double elements from a source array to a destination segment,\n@@ -1036,2 +700,2 @@\n-     * @param srcArray the source double array.\n-     * @param srcIndex the starting index of the source double array.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n@@ -1040,35 +704,1 @@\n-     * @param elementCount the number of double elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndex the starting index of the destination double array.\n-     * @param elementCount the number of double elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            double[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndex the starting index of the destination double array.\n-     * @param elementCount the number of double elements to be copied.\n+     * @param elementCount the number of array elements to be copied.\n@@ -1077,0 +707,2 @@\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -1080,37 +712,0 @@\n-            MemorySegment srcSegment, long srcOffset,\n-            double[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    @ForceInline\n-    private static void copy(\n-            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n-            Object dstArray, int dstIndex, int elementCount,\n-            int dstBase, int dstWidth, int dstLength) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(srcElementLayout);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstLength);\n-        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Source offset incompatible with alignment constraints\");\n-        }\n-        if (srcElementLayout.byteSize() != dstWidth) {\n-            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n-        }\n-        if (srcElementLayout.order() == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n-        }\n-    }\n-\n-    @ForceInline\n-    private static void copy(\n@@ -1118,2 +713,1 @@\n-            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount,\n-            int srcBase, int srcWidth, int srcLength) {\n+            MemorySegment dstSegment, long dstOffset, int elementCount, ByteOrder order) {\n@@ -1122,8 +716,4 @@\n-        Objects.requireNonNull(dstElementLayout);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcLength);\n-        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Destination offset incompatible with alignment constraints\");\n-        }\n-        if (dstElementLayout.byteSize() != srcWidth) {\n-            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n-        }\n+        Objects.requireNonNull(order);\n+        int srcBase = UNSAFE.arrayBaseOffset(srcArray.getClass());\n+        int srcWidth = UNSAFE.arrayIndexScale(srcArray.getClass());\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n@@ -1132,1 +722,1 @@\n-        if (dstElementLayout.order() == ByteOrder.nativeOrder()) {\n+        if (srcWidth == 1 || order == ByteOrder.nativeOrder()) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":57,"deletions":467,"binary":false,"changes":524,"status":"modified"},{"patch":"@@ -531,54 +531,0 @@\n-    \/**\n-     * Copy the contents of this memory segment into a fresh short array.\n-     * @return a fresh short array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link short[]} instance,\n-     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}\n-     *\/\n-    short[] toShortArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh char array.\n-     * @return a fresh char array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link char[]} instance,\n-     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n-     *\/\n-    char[] toCharArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh int array.\n-     * @return a fresh int array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link int[]} instance,\n-     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n-     *\/\n-    int[] toIntArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh float array.\n-     * @return a fresh float array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link float[]} instance,\n-     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n-     *\/\n-    float[] toFloatArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh long array.\n-     * @return a fresh long array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link long[]} instance,\n-     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n-     *\/\n-    long[] toLongArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh double array.\n-     * @return a fresh double array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link double[]} instance,\n-     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n-     *\/\n-    double[] toDoubleArray();\n-\n@@ -605,67 +551,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(byte[] arr) {\n-        return HeapMemorySegmentImpl.OfByte.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(char[] arr) {\n-        return HeapMemorySegmentImpl.OfChar.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(short[] arr) {\n-        return HeapMemorySegmentImpl.OfShort.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(int[] arr) {\n-        return HeapMemorySegmentImpl.OfInt.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(float[] arr) {\n-        return HeapMemorySegmentImpl.OfFloat.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(long[] arr) {\n-        return HeapMemorySegmentImpl.OfLong.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated array.\n@@ -675,0 +555,2 @@\n+     * @throws  IllegalArgumentException if {@code arr} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -677,2 +559,20 @@\n-    static MemorySegment ofArray(double[] arr) {\n-        return HeapMemorySegmentImpl.OfDouble.fromArray(arr);\n+    @ForceInline\n+    static MemorySegment ofArray(Object arr) {\n+        Objects.requireNonNull(arr);\n+        if (arr.getClass().equals(byte[].class)) {\n+            return HeapMemorySegmentImpl.OfByte.fromArray((byte[])arr);\n+        } else if (arr.getClass().equals(char[].class)) {\n+            return HeapMemorySegmentImpl.OfChar.fromArray((char[])arr);\n+        } else if (arr.getClass().equals(short[].class)) {\n+            return HeapMemorySegmentImpl.OfShort.fromArray((short[]) arr);\n+        } else if (arr.getClass().equals(int[].class)) {\n+            return HeapMemorySegmentImpl.OfInt.fromArray((int[]) arr);\n+        } else if (arr.getClass().equals(float[].class)) {\n+            return HeapMemorySegmentImpl.OfFloat.fromArray((float[]) arr);\n+        } else if (arr.getClass().equals(long[].class)) {\n+            return HeapMemorySegmentImpl.OfLong.fromArray((long[]) arr);\n+        } else if (arr.getClass().equals(double[].class)) {\n+            return HeapMemorySegmentImpl.OfDouble.fromArray((double[]) arr);\n+        } else {\n+            throw new IllegalArgumentException(\"Bad carrier\");\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":23,"deletions":123,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -274,37 +274,3 @@\n-        return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final short[] toShortArray() {\n-        return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final char[] toCharArray() {\n-        return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final int[] toIntArray() {\n-        return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final float[] toFloatArray() {\n-        return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final long[] toLongArray() {\n-        return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final double[] toDoubleArray() {\n-        return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);\n-    }\n-\n-    private <Z> Z toArray(Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n-        int size = checkArraySize(arrayClass.getSimpleName(), elemSize);\n-        Z arr = arrayFactory.apply(size);\n-        segmentFactory.apply(arr).copyFrom(this);\n+        int size = checkArraySize(byte[].class.getSimpleName(), 1);\n+        byte[] arr = new byte[(int)byteSize()];\n+        MemoryAccess.copy(this, 0, arr, 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -106,3 +106,2 @@\n-            int[] sorted = stdLibHelper.qsort(input);\n-            Arrays.sort(input);\n-            assertEquals(sorted, input);\n+            stdLibHelper.qsort(input);\n+            assertEquals(input, ints.stream().mapToInt(i -> i).sorted().toArray());\n@@ -293,1 +292,1 @@\n-        int[] qsort(int[] arr) throws Throwable {\n+        void qsort(int[] arr) throws Throwable {\n@@ -296,2 +295,3 @@\n-                SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-                MemorySegment nativeArr = allocator.allocateArray(C_INT, arr);\n+                MemorySegment nativeArr = MemorySegment.allocateNative(arr.length * C_INT.byteSize(), scope);\n+                \/\/copy into native array\n+                MemoryAccess.copy(arr, 0, nativeArr, 0, arr.length);\n@@ -303,3 +303,2 @@\n-\n-                \/\/convert back to Java array\n-                return nativeArr.toIntArray();\n+                \/\/copy back into Java array\n+                MemoryAccess.copy(nativeArr, 0, arr, 0, arr.length);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.Array;\n@@ -36,0 +37,1 @@\n+import java.util.function.IntFunction;\n@@ -75,1 +77,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -77,1 +79,1 @@\n-        helper.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+        MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -82,1 +84,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -85,2 +87,2 @@\n-        helper.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-        MemorySegment result = helper.fromArray(dstArr);\n+        MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemorySegment result = MemorySegment.ofArray(dstArr);\n@@ -100,1 +102,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -102,1 +104,1 @@\n-        helper.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+        MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -106,1 +108,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -109,1 +111,1 @@\n-        helper.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -118,1 +120,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -120,1 +122,1 @@\n-            helper.copy(srcArr, 0, dstSeg, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcArr, 0, dstSeg, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n@@ -127,1 +129,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -129,1 +131,1 @@\n-            helper.copy(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n@@ -142,1 +144,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -144,1 +146,1 @@\n-            helper.copy(srcArr, -1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcArr, -1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -151,1 +153,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -153,1 +155,1 @@\n-            helper.copy(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -166,1 +168,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -168,1 +170,1 @@\n-            helper.copy(srcArr, 0, dstSeg, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcArr, 0, dstSeg, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -175,1 +177,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -177,1 +179,1 @@\n-            helper.copy(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -190,1 +192,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -192,1 +194,1 @@\n-            helper.copy(srcArr, 0, dstSeg, -1, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcArr, 0, dstSeg, -1, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -199,1 +201,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -201,1 +203,1 @@\n-            helper.copy(srcSeg, -1, dstArr, 0, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcSeg, -1, dstArr, 0, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -214,1 +216,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -216,1 +218,1 @@\n-            helper.copy(srcArr, helper.length(srcArr) + 1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcArr, helper.length(srcArr) + 1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -223,1 +225,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -225,1 +227,1 @@\n-            helper.copy(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -238,1 +240,1 @@\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n@@ -240,1 +242,1 @@\n-            helper.copy(srcArr, 0, dstSeg, SEG_LENGTH_BYTES + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcArr, 0, dstSeg, SEG_LENGTH_BYTES + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -247,1 +249,1 @@\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n@@ -249,1 +251,1 @@\n-            helper.copy(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            MemoryAccess.copy(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -271,1 +273,3 @@\n-        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toByteArray());\n+        byte[] bytes = new byte[(int)srcSeg.byteSize()];\n+        MemoryAccess.copy(srcSeg, 0, bytes, 0, bytes.length);\n+        MemorySegment dstSeg = MemorySegment.ofArray(bytes);\n@@ -316,1 +320,1 @@\n-    abstract static class CopyHelper<X> {\n+    static class CopyHelper<X> {\n@@ -320,0 +324,1 @@\n+        final IntFunction<X> arrayFactory;\n@@ -321,1 +326,1 @@\n-        public CopyHelper(ValueLayout elementLayout, Class<X> carrier) {\n+        public CopyHelper(ValueLayout elementLayout, Class<X> carrier, IntFunction<X> arrayFactory) {\n@@ -324,0 +329,1 @@\n+            this.arrayFactory = arrayFactory;\n@@ -326,5 +332,10 @@\n-        abstract void copy(X srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo);\n-        abstract void copy(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n-        abstract X toArray(MemorySegment segment);\n-        abstract MemorySegment fromArray(X array);\n-        abstract int length(X arr);\n+        final int length(X arr) {\n+            return Array.getLength(arr);\n+        }\n+\n+        final X toArray(MemorySegment segment) {\n+            int size = (int)(segment.byteSize() \/ elementLayout.byteSize());\n+            X arr = arrayFactory.apply(size);\n+            MemoryAccess.copy(segment, 0, arr, 0, size, ByteOrder.nativeOrder());\n+            return arr;\n+        }\n@@ -340,188 +351,7 @@\n-        static final CopyHelper<byte[]> BYTE = new CopyHelper<>(MemoryLayouts.JAVA_BYTE, byte[].class) {\n-            @Override\n-            void copy(byte[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen);\n-            }\n-\n-            @Override\n-            void copy(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n-            }\n-\n-            @Override\n-            byte[] toArray(MemorySegment segment) {\n-                return segment.toByteArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(byte[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(byte[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<char[]> CHAR = new CopyHelper<>(MemoryLayouts.JAVA_CHAR, char[].class) {\n-            @Override\n-            void copy(char[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n-            }\n-\n-            @Override\n-            void copy(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            char[] toArray(MemorySegment segment) {\n-                return segment.toCharArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(char[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(char[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<short[]> SHORT = new CopyHelper<>(MemoryLayouts.JAVA_SHORT, short[].class) {\n-            @Override\n-            void copy(short[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n-            }\n-\n-            @Override\n-            void copy(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            short[] toArray(MemorySegment segment) {\n-                return segment.toShortArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(short[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(short[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<int[]> INT = new CopyHelper<>(MemoryLayouts.JAVA_INT, int[].class) {\n-            @Override\n-            void copy(int[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n-            }\n-\n-            @Override\n-            void copy(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            int[] toArray(MemorySegment segment) {\n-                return segment.toIntArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(int[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(int[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<float[]> FLOAT = new CopyHelper<>(MemoryLayouts.JAVA_FLOAT, float[].class) {\n-            @Override\n-            void copy(float[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n-            }\n-\n-            @Override\n-            void copy(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            float[] toArray(MemorySegment segment) {\n-                return segment.toFloatArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(float[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(float[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<long[]> LONG = new CopyHelper<>(MemoryLayouts.JAVA_LONG, long[].class) {\n-            @Override\n-            void copy(long[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n-            }\n-\n-            @Override\n-            void copy(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            long[] toArray(MemorySegment segment) {\n-                return segment.toLongArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(long[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(long[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<double[]> DOUBLE = new CopyHelper<>(MemoryLayouts.JAVA_DOUBLE, double[].class) {\n-            @Override\n-            void copy(double[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n-            }\n-\n-            @Override\n-            void copy(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            double[] toArray(MemorySegment segment) {\n-                return segment.toDoubleArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(double[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(double[] arr) {\n-                return arr.length;\n-            }\n-        };\n+        static final CopyHelper<byte[]> BYTE = new CopyHelper<>(MemoryLayouts.JAVA_BYTE, byte[].class, byte[]::new);\n+        static final CopyHelper<char[]> CHAR = new CopyHelper<>(MemoryLayouts.JAVA_CHAR, char[].class, char[]::new);\n+        static final CopyHelper<short[]> SHORT = new CopyHelper<>(MemoryLayouts.JAVA_SHORT, short[].class, short[]::new);\n+        static final CopyHelper<int[]> INT = new CopyHelper<>(MemoryLayouts.JAVA_INT, int[].class, int[]::new);\n+        static final CopyHelper<float[]> FLOAT = new CopyHelper<>(MemoryLayouts.JAVA_FLOAT, float[].class, float[]::new);\n+        static final CopyHelper<long[]> LONG = new CopyHelper<>(MemoryLayouts.JAVA_LONG, long[].class, long[]::new);\n+        static final CopyHelper<double[]> DOUBLE = new CopyHelper<>(MemoryLayouts.JAVA_DOUBLE, double[].class, double[]::new);\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":59,"deletions":229,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -43,0 +44,1 @@\n+import java.util.function.IntFunction;\n@@ -92,1 +94,1 @@\n-    static void checkBytes(MemorySegment base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {\n+    static <Z> void checkBytes(MemorySegment base, SequenceLayout layout, IntFunction<Z> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {\n@@ -94,1 +96,2 @@\n-        Object arr = arrayFactory.apply(base);\n+        Z arr = arrayFactory.apply(nelems);\n+        MemorySegment.ofArray(arr).copyFrom(base);\n@@ -110,4 +113,2 @@\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testTooBigForArray(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        MemoryLayout seq = MemoryLayout.sequenceLayout((Integer.MAX_VALUE * layout.byteSize()) + 1, layout);\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testTooBigForArray() {\n@@ -115,2 +116,2 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize(), ResourceScope.globalScope());\n-        arrayFactory.apply(segment);\n+        MemorySegment segment = MemoryAddress.NULL.asSegment((long)Integer.MAX_VALUE + 1, ResourceScope.globalScope());\n+        segment.toByteArray();\n@@ -119,14 +120,3 @@\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testBadSize(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        if (layout.byteSize() == 1) throw new IllegalStateException(); \/\/make it fail\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), scope);\n-            arrayFactory.apply(segment);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testArrayFromClosedSegment(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testArrayFromClosedSegment() {\n+        MemorySegment segment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n@@ -134,1 +124,1 @@\n-        arrayFactory.apply(segment);\n+        segment.toByteArray();\n@@ -155,1 +145,1 @@\n-                (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, byte[]::new, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n@@ -157,1 +147,1 @@\n-                (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, short[]::new, (addr, pos) -> (short)shortHandle.get(addr, pos));\n@@ -159,1 +149,1 @@\n-                (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, char[]::new, (addr, pos) -> (char)charHandle.get(addr, pos));\n@@ -161,1 +151,1 @@\n-                (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, int[]::new, (addr, pos) -> (int)intHandle.get(addr, pos));\n@@ -163,1 +153,1 @@\n-                (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, float[]::new, (addr, pos) -> (float)floatHandle.get(addr, pos));\n@@ -165,1 +155,1 @@\n-                (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, long[]::new, (addr, pos) -> (long)longHandle.get(addr, pos));\n@@ -167,1 +157,1 @@\n-                (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, double[]::new, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n@@ -179,13 +169,0 @@\n-\n-    @DataProvider(name = \"elemLayouts\")\n-    public Object[][] elemLayouts() {\n-        return new Object[][] {\n-                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegment::toByteArray },\n-                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegment::toShortArray },\n-                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegment::toCharArray },\n-                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegment::toIntArray },\n-                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegment::toFloatArray },\n-                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegment::toLongArray },\n-                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegment::toDoubleArray }\n-        };\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":20,"deletions":43,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -126,6 +126,0 @@\n-        ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -40,0 +42,1 @@\n+import java.nio.ByteOrder;\n@@ -125,0 +128,13 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static() {\n+        MemoryAccess.copy(bytes, 0, segment, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_dontinline() {\n+        MemoryAccess.copy(bytes, 0, segment, 0, bytes.length);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+public class LoopOverNewHeap {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+\n+    @Param(value = {\"false\", \"true\"})\n+    boolean polluteProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (polluteProfile) {\n+            for (int i = 0 ; i < 10000 ; i++) {\n+                MemorySegment intB = MemorySegment.ofArray(new byte[ELEM_SIZE]);\n+                MemorySegment intI = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+                MemorySegment intD = MemorySegment.ofArray(new double[ELEM_SIZE]);\n+                MemorySegment intF = MemorySegment.ofArray(new float[ELEM_SIZE]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unsafe_loop() {\n+        int[] elems = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(elems, Unsafe.ARRAY_INT_BASE_OFFSET + (i * CARRIER_SIZE) , i);\n+        }\n+    }\n+    \n+\n+    @Benchmark\n+    public void segment_loop() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public void segment_loop_dontinline() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void buffer_loop() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            buffer.put(i , i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNewHeap.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}