{"files":[{"patch":"@@ -43,1 +43,0 @@\n-import java.nio.charset.Charset;\n@@ -375,1 +374,1 @@\n-        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n+        MemoryAccess.setByte(addr, bytes.length, (byte)0);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n@@ -36,1 +38,1 @@\n- * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.\n+ * This class defines convenient static methods which can be used to read\/write Java values from\/to memory segments.\n@@ -38,3 +40,8 @@\n- * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long, ByteOrder)}) take a segment, an offset\n- * (expressed in bytes) and a byte order. The final address at which the dereference will occur will be computed by offsetting\n- * the base address by the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n+ * Single values can be read and written using accessors like {@link #getInt(MemorySegment, long)}, and\n+ * {@link #setInt(MemorySegment, long, int)}. These accessors all accept the following parameters:\n+ * <ul>\n+ *     <li>the memory segment to be read (resp. written)<\/li>\n+ *     <li>the offset, in bytes, at which the read (resp. write) operation should occur<\/li>\n+ *     <li>the offset, in bytes, at which the read (resp. write) operation should occur<\/li>\n+ *     <li>an optional {@linkplain ByteOrder byte order}<\/li>\n+ * <\/ul>\n@@ -42,2 +49,14 @@\n- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment, ByteOrder)}) so that\n- * clients can omit the offset coordinate.\n+ * Multiple values can be read and written in bulk from and to Java arrays, using accessors like {@link #copy(int[], int, MemorySegment, long, int)},\n+ * and {@link #copy(MemorySegment, long, int[], int, int)}. These accessors all accept the following parameters\n+ * (source parameters are laid out before destination parameters, similarly to {@link System#arraycopy(Object, int, Object, int, int)}):\n+ <ul>\n+ *     <li>the memory segment to be read (resp. written)<\/li>\n+ *     <li>the offset, in bytes, at which elements should be read (resp. written) from (resp. to) the segment<\/li>\n+ *     <li>the Java array to be written (resp. read)<\/li>\n+ *     <li>the array index at which elements should be written (resp. read) to (resp. from) the array<\/li>\n+ *     <li>an optional {@linkplain ByteOrder byte order}<\/li>\n+ * <\/ul>\n+ * If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.\n@@ -45,10 +64,1 @@\n- * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long, ByteOrder)}),\n- * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n- * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n- * be dereferenced.\n- * <p>\n- * In cases where native byte order is preferred, overloads are provided (see {@link #getIntAtOffset(MemorySegment, long)})\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n@@ -60,1 +70,2 @@\n- * causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n+ * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n+ * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n@@ -65,2 +76,18 @@\n-        \/\/ just the one\n-    }\n+        \/\/ just the one!\n+    }\n+\n+    static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n+    private final static ByteOrder NON_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n+            ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n+    private final static ValueLayout JAVA_SHORT_NO = MemoryLayouts.JAVA_SHORT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_SHORT_NNO = JAVA_SHORT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_CHAR_NO = MemoryLayouts.JAVA_CHAR.withBitAlignment(8);\n+    private final static ValueLayout JAVA_CHAR_NNO = JAVA_CHAR_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_INT_NO = MemoryLayouts.JAVA_INT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_INT_NNO = JAVA_INT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_FLOAT_NO = MemoryLayouts.JAVA_FLOAT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_FLOAT_NNO = JAVA_FLOAT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_LONG_NO = MemoryLayouts.JAVA_LONG.withBitAlignment(8);\n+    private final static ValueLayout JAVA_LONG_NNO = JAVA_LONG_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_DOUBLE_NO = MemoryLayouts.JAVA_DOUBLE.withBitAlignment(8);\n+    private final static ValueLayout JAVA_DOUBLE_NNO = JAVA_DOUBLE_NO.withOrder(NON_NATIVE_ORDER);\n@@ -82,10 +109,1 @@\n-    private static final VarHandle address_handle;\n-\n-    static {\n-        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n-            case 4 -> int.class;\n-            case 8 -> long.class;\n-            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n-        };\n-        address_handle = MemoryHandles.asAddressVarHandle(unalignedHandle(MemoryLayouts.ADDRESS, carrier));\n-    }\n+    private static final VarHandle address_handle = unalignedHandle(MemoryLayouts.ADDRESS, MemoryAddress.class);\n@@ -93,1 +111,1 @@\n-    private static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n+    static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n@@ -97,4 +115,0 @@\n-    \/\/ Note: all the accessor methods defined below take advantage of argument type profiling\n-    \/\/ (see src\/hotspot\/share\/oops\/methodData.cpp) which greatly enhances performance when the same accessor\n-    \/\/ method is used repeatedly with different segment kinds (e.g. on-heap vs. off-heap).\n-\n@@ -109,1 +123,1 @@\n-    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n+    public static byte getByte(MemorySegment segment, long offset) {\n@@ -122,1 +136,1 @@\n-    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n+    public static void setByte(MemorySegment segment, long offset, byte value) {\n@@ -135,1 +149,1 @@\n-    public static boolean getBooleanAtOffset(MemorySegment segment, long offset) {\n+    public static boolean getBoolean(MemorySegment segment, long offset) {\n@@ -148,1 +162,1 @@\n-    public static void setBooleanAtOffset(MemorySegment segment, long offset, boolean value) {\n+    public static void setBoolean(MemorySegment segment, long offset, boolean value) {\n@@ -165,2 +179,2 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset) {\n-        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static char getChar(MemorySegment segment, long offset) {\n+        return getChar(segment, offset, ByteOrder.nativeOrder());\n@@ -181,2 +195,2 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n-        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setChar(MemorySegment segment, long offset, char value) {\n+        setChar(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -197,2 +211,2 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset) {\n-        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static short getShort(MemorySegment segment, long offset) {\n+        return getShort(segment, offset, ByteOrder.nativeOrder());\n@@ -213,2 +227,2 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n-        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setShort(MemorySegment segment, long offset, short value) {\n+        setShort(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -229,2 +243,2 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset) {\n-        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static int getInt(MemorySegment segment, long offset) {\n+        return getInt(segment, offset, ByteOrder.nativeOrder());\n@@ -245,2 +259,2 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n-        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setInt(MemorySegment segment, long offset, int value) {\n+        setInt(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -261,2 +275,2 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n-        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static float getFloat(MemorySegment segment, long offset) {\n+        return getFloat(segment, offset, ByteOrder.nativeOrder());\n@@ -277,2 +291,2 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n-        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setFloat(MemorySegment segment, long offset, float value) {\n+        setFloat(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -293,2 +307,2 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset) {\n-        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static long getLong(MemorySegment segment, long offset) {\n+        return getLong(segment, offset, ByteOrder.nativeOrder());\n@@ -309,2 +323,2 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n-        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setLong(MemorySegment segment, long offset, long value) {\n+        setLong(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -325,2 +339,2 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n-        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static double getDouble(MemorySegment segment, long offset) {\n+        return getDouble(segment, offset, ByteOrder.nativeOrder());\n@@ -341,2 +355,2 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n-        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setDouble(MemorySegment segment, long offset, double value) {\n+        setDouble(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -358,1 +372,1 @@\n-    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n+    public static MemoryAddress getAddress(MemorySegment segment, long offset) {\n@@ -376,1 +390,1 @@\n-    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n+    public static void setAddress(MemorySegment segment, long offset, Addressable value) {\n@@ -396,1 +410,1 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static char getChar(MemorySegment segment, long offset, ByteOrder order) {\n@@ -416,1 +430,1 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n+    public static void setChar(MemorySegment segment, long offset, ByteOrder order, char value) {\n@@ -436,1 +450,1 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static short getShort(MemorySegment segment, long offset, ByteOrder order) {\n@@ -456,1 +470,1 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n+    public static void setShort(MemorySegment segment, long offset, ByteOrder order, short value) {\n@@ -476,1 +490,1 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static int getInt(MemorySegment segment, long offset, ByteOrder order) {\n@@ -496,1 +510,1 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n+    public static void setInt(MemorySegment segment, long offset, ByteOrder order, int value) {\n@@ -516,1 +530,1 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static float getFloat(MemorySegment segment, long offset, ByteOrder order) {\n@@ -536,1 +550,1 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n+    public static void setFloat(MemorySegment segment, long offset, ByteOrder order, float value) {\n@@ -556,1 +570,1 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static long getLong(MemorySegment segment, long offset, ByteOrder order) {\n@@ -576,1 +590,1 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n+    public static void setLong(MemorySegment segment, long offset, ByteOrder order, long value) {\n@@ -596,1 +610,1 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static double getDouble(MemorySegment segment, long offset, ByteOrder order) {\n@@ -616,1 +630,1 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n+    public static void setDouble(MemorySegment segment, long offset, ByteOrder order, double value) {\n@@ -622,135 +636,4 @@\n-    \/**\n-     * Reads a byte from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    byte value = getByteAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByte(MemorySegment segment) {\n-        return getByteAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByte(MemorySegment segment, byte value) {\n-        setByteAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a boolean from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    boolean value = getBooleanAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a boolean value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static boolean getBoolean(MemorySegment segment) {\n-        return getBooleanAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a boolean at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setBooleanAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the boolean value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setBoolean(MemorySegment segment, boolean value) {\n-        setBooleanAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment) {\n-        return getCharAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, char value) {\n-        setCharAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment) {\n-        return getShortAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, short value) {\n-        setShortAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment) {\n-        return getIntAtOffset(segment, 0L);\n+    private static ValueLayout pick(ByteOrder order, ValueLayout nativeLayout, ValueLayout nonNativeLayout) {\n+        Objects.requireNonNull(order);\n+        return order == ByteOrder.nativeOrder() ?\n+                nativeLayout : nonNativeLayout;\n@@ -760,8 +643,7 @@\n-     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the int value to be written.\n+     * Copies a number of byte elements from a source byte array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source byte array.\n+     * @param srcIndex the starting index of the source byte array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of byte elements to be copied.\n@@ -770,2 +652,4 @@\n-    public static void setInt(MemorySegment segment, int value) {\n-        setIntAtOffset(segment, 0L, value);\n+    public static void copy(\n+            byte[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, srcArray.length);\n@@ -775,8 +659,7 @@\n-     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a float value read from {@code segment}.\n+     * Copies a number of byte elements from a source segment to a destination byte array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination byte array.\n+     * @param dstIndex the starting index of the destination byte array.\n+     * @param elementCount the number of byte elements to be copied.\n@@ -785,2 +668,5 @@\n-    public static float getFloat(MemorySegment segment) {\n-        return getFloatAtOffset(segment, 0L);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            byte[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, dstArray.length);\n@@ -790,8 +676,7 @@\n-     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the float value to be written.\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source char array.\n+     * @param srcIndex the starting index of the source char array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of char elements to be copied.\n@@ -800,2 +685,3 @@\n-    public static void setFloat(MemorySegment segment, float value) {\n-        setFloatAtOffset(segment, 0L, value);\n+    public static void copy(\n+            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -805,8 +691,8 @@\n-     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a long value read from {@code segment}.\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source char array.\n+     * @param srcIndex the starting index of the source char array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of char elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -815,2 +701,4 @@\n-    public static long getLong(MemorySegment segment) {\n-        return getLongAtOffset(segment, 0L);\n+    public static void copy(\n+            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount, ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, srcArray.length);\n@@ -820,8 +708,7 @@\n-     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the long value to be written.\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndex the starting index of the destination char array.\n+     * @param elementCount the number of char elements to be copied.\n@@ -830,2 +717,4 @@\n-    public static void setLong(MemorySegment segment, long value) {\n-        setLongAtOffset(segment, 0L, value);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            char[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -835,8 +724,8 @@\n-     * Reads a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a double value read from {@code segment}.\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndex the starting index of the destination char array.\n+     * @param elementCount the number of char elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -845,2 +734,6 @@\n-    public static double getDouble(MemorySegment segment) {\n-        return getDoubleAtOffset(segment, 0L);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            char[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, dstArray.length);\n@@ -850,8 +743,7 @@\n-     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the double value to be written.\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source short array.\n+     * @param srcIndex the starting index of the source short array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of short elements to be copied.\n@@ -860,2 +752,3 @@\n-    public static void setDouble(MemorySegment segment, double value) {\n-        setDoubleAtOffset(segment, 0L, value);\n+    public static void copy(\n+            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -865,8 +758,8 @@\n-     * Reads a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemoryAddress value = getAddressAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a memory address read from {@code segment}.\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source short array.\n+     * @param srcIndex the starting index of the source short array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of short elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -875,2 +768,5 @@\n-    public static MemoryAddress getAddress(MemorySegment segment) {\n-        return getAddressAtOffset(segment, 0L);\n+    public static void copy(\n+            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, srcArray.length);\n@@ -880,8 +776,7 @@\n-     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndex the starting index of the destination short array.\n+     * @param elementCount the number of short elements to be copied.\n@@ -890,2 +785,4 @@\n-    public static void setAddress(MemorySegment segment, Addressable value) {\n-        setAddressAtOffset(segment, 0L, value);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            short[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -895,9 +792,9 @@\n-     * Reads a char from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndex the starting index of the destination short array.\n+     * @param elementCount the number of short elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -906,2 +803,6 @@\n-    public static char getChar(MemorySegment segment, ByteOrder order) {\n-        return getCharAtOffset(segment, 0L, order);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            short[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, dstArray.length);\n@@ -911,9 +812,7 @@\n-     * Writes a char at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source int array.\n+     * @param srcIndex the starting index of the source int array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of int elements to be copied.\n@@ -922,2 +821,3 @@\n-    public static void setChar(MemorySegment segment, ByteOrder order, char value) {\n-        setCharAtOffset(segment, 0L, order, value);\n+    public static void copy(\n+            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -927,9 +827,8 @@\n-     * Reads a short from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source int array.\n+     * @param srcIndex the starting index of the source int array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of int elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -938,2 +837,5 @@\n-    public static short getShort(MemorySegment segment, ByteOrder order) {\n-        return getShortAtOffset(segment, 0L, order);\n+    public static void copy(\n+            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, srcArray.length);\n@@ -943,9 +845,7 @@\n-     * Writes a short at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndex the starting index of the destination int array.\n+     * @param elementCount the number of int elements to be copied.\n@@ -954,2 +854,4 @@\n-    public static void setShort(MemorySegment segment, ByteOrder order, short value) {\n-        setShortAtOffset(segment, 0L, order, value);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            int[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -959,9 +861,9 @@\n-     * Reads an int from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndex the starting index of the destination int array.\n+     * @param elementCount the number of int elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -970,2 +872,6 @@\n-    public static int getInt(MemorySegment segment, ByteOrder order) {\n-        return getIntAtOffset(segment, 0L, order);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            int[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, dstArray.length);\n@@ -975,9 +881,7 @@\n-     * Writes an int at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source float array.\n+     * @param srcIndex the starting index of the source float array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of float elements to be copied.\n@@ -986,2 +890,3 @@\n-    public static void setInt(MemorySegment segment, ByteOrder order, int value) {\n-        setIntAtOffset(segment, 0L, order, value);\n+    public static void copy(\n+            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -991,9 +896,8 @@\n-     * Reads a float from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source float array.\n+     * @param srcIndex the starting index of the source float array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of float elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -1002,2 +906,5 @@\n-    public static float getFloat(MemorySegment segment, ByteOrder order) {\n-        return getFloatAtOffset(segment, 0L, order);\n+    public static void copy(\n+            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, srcArray.length);\n@@ -1007,9 +914,7 @@\n-     * Writes a float at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndex the starting index of the destination float array.\n+     * @param elementCount the number of float elements to be copied.\n@@ -1018,2 +923,4 @@\n-    public static void setFloat(MemorySegment segment, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, 0L, order, value);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            float[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -1023,9 +930,9 @@\n-     * Reads a long from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndex the starting index of the destination float array.\n+     * @param elementCount the number of float elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a float swap operation will be performed on each array element.\n@@ -1034,2 +941,6 @@\n-    public static long getLong(MemorySegment segment, ByteOrder order) {\n-        return getLongAtOffset(segment, 0L, order);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            float[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, dstArray.length);\n@@ -1039,9 +950,7 @@\n-     * Writes a long at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source long array.\n+     * @param srcIndex the starting index of the source long array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of long elements to be copied.\n@@ -1050,2 +959,3 @@\n-    public static void setLong(MemorySegment segment, ByteOrder order, long value) {\n-        setLongAtOffset(segment, 0L, order, value);\n+    public static void copy(\n+            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -1055,9 +965,8 @@\n-     * Reads a double from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source long array.\n+     * @param srcIndex the starting index of the source long array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of long elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -1066,2 +975,5 @@\n-    public static double getDouble(MemorySegment segment, ByteOrder order) {\n-        return getDoubleAtOffset(segment, 0L, order);\n+    public static void copy(\n+            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, srcArray.length);\n@@ -1071,9 +983,7 @@\n-     * Writes a double at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndex the starting index of the destination long array.\n+     * @param elementCount the number of long elements to be copied.\n@@ -1082,2 +992,4 @@\n-    public static void setDouble(MemorySegment segment, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, 0L, order, value);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            long[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -1087,9 +999,9 @@\n-     * Reads a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndex the starting index of the destination long array.\n+     * @param elementCount the number of long elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -1098,2 +1010,6 @@\n-    public static char getCharAtIndex(MemorySegment segment, long index) {\n-        return getCharAtOffset(segment, scale(segment, index, 2));\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            long[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, dstArray.length);\n@@ -1103,9 +1019,7 @@\n-     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the char value to be written.\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source double array.\n+     * @param srcIndex the starting index of the source double array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of double elements to be copied.\n@@ -1114,403 +1028,113 @@\n-    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index) {\n-        return getShortAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index) {\n-        return getIntAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index) {\n-        return getLongAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getCharAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, ByteOrder order, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getShortAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, ByteOrder order, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getIntAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, ByteOrder order, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getLongAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, ByteOrder order, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    @ForceInline\n-    private static long scale(MemorySegment address, long index, int size) {\n-        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);\n+    public static void copy(\n+            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source double array.\n+     * @param srcIndex the starting index of the source double array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of double elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     *\/\n+    @ForceInline\n+    public static void copy(\n+            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, srcArray.length);\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndex the starting index of the destination double array.\n+     * @param elementCount the number of double elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            double[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndex the starting index of the destination double array.\n+     * @param elementCount the number of double elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            double[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, dstArray.length);\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount,\n+            int dstBase, int dstWidth, int dstLength) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(srcElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, dstLength);\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source offset incompatible with alignment constraints\");\n+        }\n+        if (srcElementLayout.byteSize() != dstWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        if (srcElementLayout.order() == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount,\n+            int srcBase, int srcWidth, int srcLength) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        Objects.checkFromIndexSize(srcIndex, elementCount, srcLength);\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Destination offset incompatible with alignment constraints\");\n+        }\n+        if (dstElementLayout.byteSize() != srcWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (dstElementLayout.order() == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":482,"deletions":858,"binary":false,"changes":1340,"status":"modified"},{"patch":"@@ -1,713 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * This class provides convenient methods for copying data between primitive arrays and memory segments.\n- *\n- * <p>If the source (destination) segment is actually a view of the destination (source) array,\n- * and if the copy region of the source overlaps with the copy region of the destination,\n- * the copy of the overlapping region is performed as if the data in the overlapping region\n- * were first copied into a temporary segment before being copied to the destination.<\/p>\n- *\n- * <p>\n- * Copy operations defined in this class accept a <em>byte order<\/em> parameter. If the specified byte order is different\n- * from the <em>native<\/em> byte order, a byte swap operation is performed on each array elements\n- * as they are copied from the source (destination) segment to the destination (source) array.\n- * Additional overloads are provided (see {@link #copyFromArray(double[], int, int, MemorySegment, long)}),\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException} to be thrown. Moreover,\n- * attempting to copy to\/from a segment whose {@linkplain MemorySegment#scope() scope} has already been closed,\n- * or from a thread other than the thread owning the scope causes an {@link IllegalStateException} to be thrown.\n- * Finally, attempting to copy to\/from a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n- * {@linkplain MemorySegment#byteSize() size} {@code S}) at addresses that are {@code < B}, or {@code >= B + S},\n- * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n- * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n- *\/\n-public final class MemoryCopy {\n-\n-    private static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    private static final int BYTE_BASE = unsafe.arrayBaseOffset(byte[].class);\n-    private static final int CHAR_BASE = unsafe.arrayBaseOffset(char[].class);\n-    private static final int SHORT_BASE = unsafe.arrayBaseOffset(short[].class);\n-    private static final int INT_BASE = unsafe.arrayBaseOffset(int[].class);\n-    private static final int FLOAT_BASE = unsafe.arrayBaseOffset(float[].class);\n-    private static final int LONG_BASE = unsafe.arrayBaseOffset(long[].class);\n-    private static final int DOUBLE_BASE = unsafe.arrayBaseOffset(double[].class);\n-\n-    private MemoryCopy() { \/* singleton *\/ }\n-\n-    \/\/BYTE\n-    \/**\n-     * Copies a number of byte elements from a source byte array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source byte array.\n-     * @param srcIndexBytes the starting index of the source byte array.\n-     * @param srcCopyLengthBytes the number of byte elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            byte[] srcArray, int srcIndexBytes, int srcCopyLengthBytes,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.checkFromIndexSize(srcIndexBytes, srcCopyLengthBytes, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthBytes, false);\n-        scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                srcArray, BYTE_BASE + srcIndexBytes,\n-                destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthBytes);\n-    }\n-\n-    \/**\n-     * Copies a number of byte elements from a source segment to a destination byte array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination byte array.\n-     * @param dstIndexBytes the starting index of the destination byte array.\n-     * @param dstCopyLengthBytes the number of byte elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            byte[] dstArray, int dstIndexBytes, int dstCopyLengthBytes) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthBytes, true);\n-        Objects.checkFromIndexSize(dstIndexBytes, dstCopyLengthBytes, dstArray.length);\n-        scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                dstArray, BYTE_BASE + dstIndexBytes, dstCopyLengthBytes);\n-    }\n-\n-    \/\/CHAR\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source char array.\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexChars, srcCopyLengthChars, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source char array.\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexChars, srcCopyLengthChars, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthChars << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1, 2);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexChars, dstCopyLengthChars, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthChars << 1, true);\n-        Objects.checkFromIndexSize(dstIndexChars, dstCopyLengthChars, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1, 2);\n-        }\n-    }\n-\n-    \/\/SHORT\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source short array.\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexShorts, srcCopyLengthShorts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source short array.\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexShorts, srcCopyLengthShorts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthShorts << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1, 2);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexShorts, dstCopyLengthShorts, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthShorts << 1, true);\n-        Objects.checkFromIndexSize(dstIndexShorts, dstCopyLengthShorts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1, 2);\n-        }\n-    }\n-\n-    \/\/INT\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source int array.\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexInts, srcCopyLengthInts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source int array.\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexInts, srcCopyLengthInts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthInts << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2, 4);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexInts, dstCopyLengthInts, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthInts << 2, true);\n-        Objects.checkFromIndexSize(dstIndexInts, dstCopyLengthInts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2, 4);\n-        }\n-    }\n-\n-    \/\/FLOAT\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source float array.\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexFloats, srcCopyLengthFloats, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source float array.\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexFloats, srcCopyLengthFloats, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthFloats << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2, 4);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexFloats, dstCopyLengthFloats, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a float swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthFloats << 2, true);\n-        Objects.checkFromIndexSize(dstIndexFloats, dstCopyLengthFloats, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2, 4);\n-        }\n-    }\n-\n-    \/\/LONG\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source long array.\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexLongs, srcCopyLengthLongs, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source long array.\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexLongs, srcCopyLengthLongs, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthLongs << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3, 8);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexLongs, dstCopyLengthLongs, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthLongs << 3, true);\n-        Objects.checkFromIndexSize(dstIndexLongs, dstCopyLengthLongs, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3, 8);\n-        }\n-    }\n-\n-    \/\/DOUBLE\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source double array.\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexDoubles, srcCopyLengthDoubles, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source double array.\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexDoubles, srcCopyLengthDoubles, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthDoubles << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3, 8);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexDoubles, dstCopyLengthDoubles, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthDoubles << 3, true);\n-        Objects.checkFromIndexSize(dstIndexDoubles, dstCopyLengthDoubles, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3, 8);\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":0,"deletions":713,"binary":false,"changes":713,"status":"deleted"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -41,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -367,1 +367,5 @@\n-     *\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copyFrom(0, src, 0, src.byteSize());\n+     * }<\/pre><\/blockquote>\n@@ -374,0 +378,1 @@\n+     * @return this segment.\n@@ -375,1 +380,3 @@\n-    void copyFrom(MemorySegment src);\n+    default MemorySegment copyFrom(MemorySegment src) {\n+        return copyFrom(0, src, 0, src.byteSize());\n+    }\n@@ -378,3 +385,38 @@\n-     * Performs an element-wise bulk copy from given source segment to this segment. More specifically, the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment\n-     * at offset {@code 0} through {@code src.byteSize() - 1}.\n+     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into this\n+     * segment at offsets {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copyFrom(MemoryLayouts.JAVA_BYTE, dstOffset, src, MemoryLayouts.JAVA_BYTE, srcOffset, src.byteSize());\n+     * }<\/pre><\/blockquote>\n+     * @param src the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     * @return this segment.\n+     *\/\n+    default MemorySegment copyFrom(long dstOffset, MemorySegment src, long srcOffset, long bytes) {\n+        return copyFrom(MemoryLayouts.JAVA_BYTE, dstOffset, src, MemoryLayouts.JAVA_BYTE, srcOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from given source segment to this segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into this segment at offsets {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n@@ -382,1 +424,1 @@\n-     * The copy occurs in an element-wise fashion: the source bytes are interpreted as a sequence of elements\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n@@ -384,4 +426,3 @@\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S} and\n-     * alignment {@code A}, and the size of the source segment must be a multiple of {@code S} for the copy operation\n-     * to be correctly specified. If the byte order of the two element layouts differ, the bytes corresponding to each\n-     * element to be copied are swapped accordingly during the copy operation.\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n@@ -390,1 +431,1 @@\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n@@ -392,1 +433,1 @@\n-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n@@ -397,6 +438,0 @@\n-     *\n-     * @implSpec\n-     * If {@code srcElementLayout.byteSize() == 1}, or if {@code srcElementLayout.order() == dstElementLayout.order()}, calling\n-     * this method must be equivalent to calling {@link #copyFrom(MemorySegment)} with the same source segment.\n-     *\n-     * @param dstElementLayout the element layout associated with this segment.\n@@ -405,5 +440,7 @@\n-     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment size is not\n-     * a multiple of the source element layout size, if the source segment is incompatible with the alignment constraints\n-     * in the source element layout, or if this segment is incompatible with the alignment constraints\n-     * in the destination element layout.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n@@ -411,5 +448,12 @@\n-     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout);\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     * @return this segment.\n+     *\/\n+    default MemorySegment copyFrom(ValueLayout dstElementLayout, long dstOffset, MemorySegment src, ValueLayout srcElementLayout, long srcOffset, long elementCount) {\n+        MemorySegment.copy(src, srcElementLayout, srcOffset, this, dstElementLayout, dstOffset, elementCount);\n+        return this;\n+    }\n@@ -862,0 +906,33 @@\n+\n+    \/\/ primitive copy method\n+    @ForceInline\n+    private static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            MemoryAccess.scopedMemoryAccess.copyMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            MemoryAccess.scopedMemoryAccess.copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":106,"deletions":29,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -316,2 +316,3 @@\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(Array.getLength(array), elementLayout));\n-        addr.copyFrom(elementLayout, heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()));\n+        int size = Array.getLength(array);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout)).copyFrom(elementLayout, 0,\n+                heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * common dereference and copy operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n@@ -50,1 +50,1 @@\n-   MemoryAccess.setIntAtIndex(segment, i, 42);\n+   MemoryAccess.setInt(segment, i * 4, 42);\n@@ -57,1 +57,1 @@\n- * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n+ * {@link jdk.incubator.foreign.MemoryAccess#setInt(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n@@ -75,1 +75,1 @@\n-        MemoryAccess.setIntAtIndex(segment, i, 42);\n+        MemoryAccess.setInt(segment, i * 4, 42);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,36 +143,0 @@\n-    public void copyFrom(MemorySegment src) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n-                that.base(), that.min(),\n-                base(), min(), size);\n-    }\n-\n-    public void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout) {\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n-        }\n-        if (((AbstractMemorySegmentImpl)src).min() % srcElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (min() % dstElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n-        }\n-        long size = src.byteSize();\n-        if (size % srcElementLayout.byteSize() != 0) {\n-            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n-        }\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            copyFrom(src);\n-        } else {\n-            AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) src;\n-            checkAccess(0, size, false);\n-            that.checkAccess(0, size, true);\n-            SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                    that.base(), that.min(),\n-                    base(), min(), size, srcElementLayout.byteSize());\n-        }\n-    }\n-\n@@ -194,1 +158,1 @@\n-            if (MemoryAccess.getByte(this) != MemoryAccess.getByte(that)) {\n+            if (MemoryAccess.getByte(this, 0) != MemoryAccess.getByte(that, 0)) {\n@@ -209,1 +173,1 @@\n-            if (MemoryAccess.getByteAtOffset(this, i) != MemoryAccess.getByteAtOffset(that, i)) {\n+            if (MemoryAccess.getByte(this, i) != MemoryAccess.getByte(that, i)) {\n@@ -346,2 +310,2 @@\n-        MemorySegment arrSegment = segmentFactory.apply(arr);\n-        arrSegment.copyFrom(this);\n+        segmentFactory.apply(arr)\n+                .copyFrom(0, this, 0, byteSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayouts;\n@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +79,1 @@\n-                .map(symbol -> MemoryAccess.getAddressAtIndex(funcs, symbol.ordinal()));\n+                .map(symbol -> MemoryAccess.getAddress(funcs, symbol.ordinal() * MemoryLayouts.ADDRESS.byteSize()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -743,3 +743,2 @@\n-            MemorySegment copy = context.allocator().allocate(size, alignment);\n-            copy.copyFrom(operand.asSlice(0, size));\n-            return copy;\n+            return context.allocator().allocate(size, alignment)\n+                            .copyFrom(0, operand, 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -56,1 +55,0 @@\n-import java.nio.charset.Charset;\n@@ -71,1 +69,0 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n@@ -292,2 +289,1 @@\n-        MemorySegment.ofArray(bytes)\n-                .copyFrom(segment.asSlice(start, len));\n+        MemoryAccess.copy(segment, start, bytes, 0, len);\n@@ -300,1 +296,1 @@\n-            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);\n+            byte curr = MemoryAccess.getByte(segment, start + offset);\n@@ -614,1 +610,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            MemoryAccess.setLong(ptr, 0, (long) o);\n@@ -616,1 +612,1 @@\n-            MemoryAccess.setLong(ptr, (int) o);\n+            MemoryAccess.setLong(ptr, 0, (int) o);\n@@ -618,1 +614,1 @@\n-            MemoryAccess.setLong(ptr, (short) o);\n+            MemoryAccess.setLong(ptr, 0, (short) o);\n@@ -620,1 +616,1 @@\n-            MemoryAccess.setLong(ptr, (char) o);\n+            MemoryAccess.setLong(ptr, 0, (char) o);\n@@ -622,1 +618,1 @@\n-            MemoryAccess.setLong(ptr, (byte) o);\n+            MemoryAccess.setLong(ptr, 0, (byte) o);\n@@ -624,1 +620,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            MemoryAccess.setFloat(ptr, 0, (float) o);\n@@ -626,1 +622,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            MemoryAccess.setDouble(ptr, 0, (double) o);\n@@ -628,1 +624,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            MemoryAccess.setBoolean(ptr, 0, (boolean) o);\n@@ -636,1 +632,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            MemoryAccess.setLong(ptr, 0, (long) o);\n@@ -638,1 +634,1 @@\n-            MemoryAccess.setInt(ptr, (int) o);\n+            MemoryAccess.setInt(ptr, 0, (int) o);\n@@ -640,1 +636,1 @@\n-            MemoryAccess.setShort(ptr, (short) o);\n+            MemoryAccess.setShort(ptr, 0, (short) o);\n@@ -642,1 +638,1 @@\n-            MemoryAccess.setChar(ptr, (char) o);\n+            MemoryAccess.setChar(ptr, 0, (char) o);\n@@ -644,1 +640,1 @@\n-            MemoryAccess.setByte(ptr, (byte) o);\n+            MemoryAccess.setByte(ptr, 0, (byte) o);\n@@ -646,1 +642,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            MemoryAccess.setFloat(ptr, 0, (float) o);\n@@ -648,1 +644,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            MemoryAccess.setDouble(ptr, 0, (double) o);\n@@ -650,1 +646,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            MemoryAccess.setBoolean(ptr, 0, (boolean) o);\n@@ -658,1 +654,1 @@\n-            return MemoryAccess.getLong(ptr);\n+            return MemoryAccess.getLong(ptr, 0);\n@@ -660,1 +656,1 @@\n-            return MemoryAccess.getInt(ptr);\n+            return MemoryAccess.getInt(ptr, 0);\n@@ -662,1 +658,1 @@\n-            return MemoryAccess.getShort(ptr);\n+            return MemoryAccess.getShort(ptr, 0);\n@@ -664,1 +660,1 @@\n-            return MemoryAccess.getChar(ptr);\n+            return MemoryAccess.getChar(ptr, 0);\n@@ -666,1 +662,1 @@\n-            return MemoryAccess.getByte(ptr);\n+            return MemoryAccess.getByte(ptr, 0);\n@@ -668,1 +664,1 @@\n-            return MemoryAccess.getFloat(ptr);\n+            return MemoryAccess.getFloat(ptr, 0);\n@@ -670,1 +666,1 @@\n-            return MemoryAccess.getDouble(ptr);\n+            return MemoryAccess.getDouble(ptr, 0);\n@@ -672,1 +668,1 @@\n-            return MemoryAccess.getBoolean(ptr);\n+            return MemoryAccess.getBoolean(ptr, 0);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -282,2 +282,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));\n+                        value.copyFrom(offset, gpRegsArea, currentGPOffset(), copy);\n@@ -298,2 +297,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));\n+                        value.copyFrom(offset, gpRegsArea, currentFPOffset(), copy);\n@@ -459,2 +457,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            gpRegs.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                            gpRegs.copyFrom(currentGPOffset, valueSegment, offset, copy);\n@@ -474,2 +471,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            fpRegs.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                            gpRegs.copyFrom(currentFPOffset, valueSegment, offset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(0, segment, 0, layout.byteSize());\n@@ -240,4 +240,3 @@\n-                        case STRUCT_REGISTER, STRUCT_HFA -> {\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n-                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor.copyFrom(0, msArg, 0, arg.layout.byteSize())\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -258,1 +258,0 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n@@ -260,1 +259,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));\n+                            value.copyFrom(offset, regSaveArea, currentFPOffset(), copy);\n@@ -263,1 +262,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));\n+                            value.copyFrom(offset, regSaveArea, currentGPOffset(), copy);\n@@ -397,1 +396,0 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n@@ -399,1 +397,1 @@\n-                                reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                                reg_save_area.copyFrom(currentFPOffset, valueSegment, offset, copy);\n@@ -402,1 +400,1 @@\n-                                reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                                reg_save_area.copyFrom(currentGPOffset, valueSegment, offset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -126,5 +126,3 @@\n-                case STRUCT_REGISTER -> {\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n-                    yield struct;\n-                }\n+                case STRUCT_REGISTER ->\n+                    allocator.allocate(layout)\n+                                    .copyFrom(0, segment, 0, layout.byteSize());\n@@ -237,4 +235,2 @@\n-                        case STRUCT_REGISTER -> {\n-                            MemorySegment slice = cursor.asSlice(0, VA_SLOT_SIZE_BYTES);\n-                            slice.copyFrom(msArg);\n-                        }\n+                        case STRUCT_REGISTER ->\n+                            cursor.copyFrom(0, msArg, 0, VA_SLOT_SIZE_BYTES);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Optional;\n@@ -216,1 +215,1 @@\n-                    setByteAtOffset(buf, i, (byte)chars[(int)i]);\n+                    setByte(buf, i, (byte)chars[(int)i]);\n@@ -218,1 +217,1 @@\n-                setByteAtOffset(buf, chars.length, (byte)'\\0');\n+                setByte(buf, chars.length, (byte)'\\0');\n@@ -248,1 +247,1 @@\n-                setLong(time, arg);\n+                setLong(time, 0, arg);\n@@ -265,1 +264,1 @@\n-                return getIntAtOffset(base, 0);\n+                return getInt(base, 0);\n@@ -268,1 +267,1 @@\n-                return getIntAtOffset(base, 4);\n+                return getInt(base, 4);\n@@ -271,1 +270,1 @@\n-                return getIntAtOffset(base, 8);\n+                return getInt(base, 8);\n@@ -274,1 +273,1 @@\n-                return getIntAtOffset(base, 12);\n+                return getInt(base, 12);\n@@ -277,1 +276,1 @@\n-                return getIntAtOffset(base, 16);\n+                return getInt(base, 16);\n@@ -280,1 +279,1 @@\n-                return getIntAtOffset(base, 20);\n+                return getInt(base, 20);\n@@ -283,1 +282,1 @@\n-                return getIntAtOffset(base, 24);\n+                return getInt(base, 24);\n@@ -286,1 +285,1 @@\n-                return getIntAtOffset(base, 28);\n+                return getInt(base, 28);\n@@ -289,1 +288,1 @@\n-                byte b = getByteAtOffset(base, 32);\n+                byte b = getByte(base, 32);\n@@ -311,2 +310,2 @@\n-            return getIntAtOffset(base, addr1.segmentOffset(base)) -\n-                   getIntAtOffset(base, addr2.segmentOffset(base));\n+            return getInt(base, addr1.segmentOffset(base)) -\n+                   getInt(base, addr2.segmentOffset(base));\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -37,0 +36,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -517,1 +517,1 @@\n-                MemoryAccess.setByteAtOffset(segment, offset, offset);\n+                MemoryAccess.setByte(segment, offset, offset);\n@@ -525,1 +525,1 @@\n-                assertEquals(MemoryAccess.getByte(segment), offset);\n+                assertEquals(MemoryAccess.getByte(segment, 0), offset);\n@@ -648,1 +648,1 @@\n-        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n+        MemoryAccess.setInt(s2, 0, 10); \/\/ Dead access!\n@@ -660,1 +660,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                MemoryAccess.setByte(segment, i, (byte) i);\n@@ -680,1 +680,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                MemoryAccess.setByte(segment, i, (byte) i);\n@@ -818,1 +818,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtOffset(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByte(addr, pos, (byte)(long)pos));\n@@ -820,1 +820,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setChar(addr, pos << 1, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n@@ -822,1 +822,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShort(addr, pos << 1, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n@@ -824,1 +824,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setInt(addr, pos << 2, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n@@ -826,1 +826,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloat(addr, pos << 2, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n@@ -828,1 +828,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLong(addr, pos << 3, ByteOrder.BIG_ENDIAN, (long)pos));\n@@ -830,1 +830,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDouble(addr, pos << 3, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n@@ -833,1 +833,1 @@\n-                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtOffset(addr, pos), ByteBuffer::get);\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByte(addr, pos), ByteBuffer::get);\n@@ -835,1 +835,1 @@\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getChar(addr, pos << 1, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n@@ -837,1 +837,1 @@\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShort(addr, pos << 1, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n@@ -839,1 +839,1 @@\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getInt(addr, pos << 2, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n@@ -841,1 +841,1 @@\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloat(addr, pos << 2, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n@@ -843,1 +843,1 @@\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLong(addr, pos << 3, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n@@ -845,1 +845,1 @@\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDouble(addr, pos << 3, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -58,1 +58,1 @@\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n+        s2.segment.copyFrom(0, s1.segment, 0, size);\n@@ -77,1 +77,1 @@\n-        s2.segment.copyFrom(s2.type.layout, s1.segment.asSlice(0, size * s1.type.size()), s1.type.layout);\n+        s2.segment.copyFrom(s2.type.layout, 0, s1.segment, s1.type.layout, 0, size);\n@@ -94,1 +94,1 @@\n-        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByteAtOffset(s, i), (s, i, o, v) -> MemoryAccess.setByteAtOffset(s, i, v), i -> (byte)i),\n+        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByte(s, i), (s, i, o, v) -> MemoryAccess.setByte(s, i, v), i -> (byte)i),\n@@ -96,6 +96,6 @@\n-        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i),\n+        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShort, MemoryAccess::setShort, i -> (short)i),\n+        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getChar, MemoryAccess::setChar, i -> (char)i),\n+        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getInt, MemoryAccess::setInt, i -> i),\n+        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloat, MemoryAccess::setFloat, i -> (float)i),\n+        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLong, MemoryAccess::setLong, i -> (long)i),\n+        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDouble, MemoryAccess::setDouble, i -> (double)i),\n@@ -103,6 +103,6 @@\n-        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i);\n+        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShort, MemoryAccess::setShort, i -> (short)i),\n+        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getChar, MemoryAccess::setChar, i -> (char)i),\n+        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getInt, MemoryAccess::setInt, i -> i),\n+        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloat, MemoryAccess::setFloat, i -> (float)i),\n+        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLong, MemoryAccess::setLong, i -> (long)i),\n+        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDouble, MemoryAccess::setDouble, i -> (double)i);\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -36,0 +35,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -51,1 +51,1 @@\n-        MemoryAccess.setByteAtOffset(seg, str.length(), (byte)0);\n+        MemoryAccess.setByte(seg, str.length(), (byte)0);\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -48,0 +47,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -153,1 +153,1 @@\n-                sum += MemoryAccess.getByteAtOffset(segment, i);\n+                sum += MemoryAccess.getByte(segment, i);\n@@ -196,1 +196,1 @@\n-            MemoryAccess.setByteAtOffset(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+            MemoryAccess.setByte(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -34,3 +33,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -40,0 +36,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -108,72 +105,0 @@\n-                {\"byte\", new Accessor<>((byte) 42,\n-                        MemoryAccess::getByte, MemoryAccess::setByte,\n-                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n-                },\n-                {\"bool\", new Accessor<>(false,\n-                        MemoryAccess::getBoolean, MemoryAccess::setBoolean,\n-                        (bb) -> bb.get(0) != 0, (bb, v) -> bb.put(0, v ? (byte)1 : (byte)0))\n-                },\n-                {\"char\", new Accessor<>((char) 42,\n-                        MemoryAccess::getChar, MemoryAccess::setChar,\n-                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n-                },\n-                {\"char\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n-                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n-                },\n-                {\"char\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n-                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n-                },\n-                {\"short\", new Accessor<>((short) 42,\n-                        MemoryAccess::getShort, MemoryAccess::setShort,\n-                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n-                },\n-                {\"short\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n-                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n-                },\n-                {\"short\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n-                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n-                },\n-                {\"int\", new Accessor<>(42,\n-                        MemoryAccess::getInt, MemoryAccess::setInt,\n-                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n-                },\n-                {\"int\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n-                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n-                },\n-                {\"int\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n-                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n-                },\n-                \/\/ float, no offset\n-                {\"float\", new Accessor<>(42f,\n-                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n-                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n-                },\n-                {\"float\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n-                },\n-                {\"float\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n-                },\n-                \/\/ double, no offset\n-                {\"double\", new Accessor<>(42d,\n-                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n-                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n-                },\n-                {\"double\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n-                },\n-                {\"double\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n-                },\n-\n-\n@@ -182,1 +107,1 @@\n-                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getByte(s, 4), (s, x) -> MemoryAccess.setByte(s, 4, x),\n@@ -187,1 +112,1 @@\n-                        s -> MemoryAccess.getBooleanAtOffset(s, 4), (s, x) -> MemoryAccess.setBooleanAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getBoolean(s, 4), (s, x) -> MemoryAccess.setBoolean(s, 4, x),\n@@ -192,1 +117,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getChar(s, 4), (s, x) -> MemoryAccess.setChar(s, 4, x),\n@@ -196,1 +121,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getChar(s, 4, LE), (s, x) -> MemoryAccess.setChar(s, 4, LE, x),\n@@ -200,1 +125,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getChar(s, 4, BE), (s, x) -> MemoryAccess.setChar(s, 4, BE, x),\n@@ -205,1 +130,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getShort(s, 4), (s, x) -> MemoryAccess.setShort(s, 4, x),\n@@ -209,1 +134,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getShort(s, 4, LE), (s, x) -> MemoryAccess.setShort(s, 4, LE, x),\n@@ -213,1 +138,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getShort(s, 4, BE), (s, x) -> MemoryAccess.setShort(s, 4, BE, x),\n@@ -218,1 +143,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getInt(s, 4), (s, x) -> MemoryAccess.setInt(s, 4, x),\n@@ -222,1 +147,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getInt(s, 4, LE), (s, x) -> MemoryAccess.setInt(s, 4, LE, x),\n@@ -226,1 +151,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getInt(s, 4, BE), (s, x) -> MemoryAccess.setInt(s, 4, BE, x),\n@@ -231,1 +156,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getFloat(s, 4), (s, x) -> MemoryAccess.setFloat(s, 4, x),\n@@ -235,1 +160,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getFloat(s, 4, LE), (s, x) -> MemoryAccess.setFloat(s, 4, LE, x),\n@@ -239,1 +164,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getFloat(s, 4, BE), (s, x) -> MemoryAccess.setFloat(s, 4, BE, x),\n@@ -244,1 +169,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getDouble(s, 4), (s, x) -> MemoryAccess.setDouble(s, 4, x),\n@@ -248,1 +173,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getDouble(s, 4, LE), (s, x) -> MemoryAccess.setDouble(s, 4, LE, x),\n@@ -252,1 +177,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getDouble(s, 4, BE), (s, x) -> MemoryAccess.setDouble(s, 4, BE, x),\n@@ -255,82 +180,0 @@\n-\n-\n-                \/\/ char, index\n-                {\"char\/index\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n-                },\n-                \/\/ short, index\n-                {\"short\/index\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n-                },\n-                {\"int\/index\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n-                },\n-                {\"float\/index\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n-                },\n-                {\"double\/index\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n-                },\n-\n-                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(0) : nb.getInt(0);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(0, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(0, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n@@ -338,1 +181,1 @@\n-                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getAddress(s, 4), (s, x) -> MemoryAccess.setAddress(s, 4, x),\n@@ -354,17 +197,0 @@\n-                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.asLongBuffer().put(2, v.toRawLongValue());\n-                            } else {\n-                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":19,"deletions":193,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.foreign.MemoryCopy;\n@@ -42,0 +41,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -47,1 +47,1 @@\n- * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n+ * These tests exercise the bulk accessors in the MemoryAccess class.\n@@ -77,1 +77,1 @@\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        helper.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -85,1 +85,1 @@\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        helper.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -102,1 +102,1 @@\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        helper.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -109,1 +109,1 @@\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        helper.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -120,1 +120,1 @@\n-            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, 0, dstSeg, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n@@ -129,1 +129,1 @@\n-            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n@@ -144,1 +144,1 @@\n-            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, -1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -153,1 +153,1 @@\n-            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -168,1 +168,1 @@\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, 0, dstSeg, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -177,1 +177,25 @@\n-            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeLengths(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copy(srcArr, 0, dstSeg, -1, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copy(srcSeg, -1, dstArr, 0, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -192,1 +216,1 @@\n-            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, helper.length(srcArr) + 1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -201,1 +225,1 @@\n-            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -216,1 +240,1 @@\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, 0, dstSeg, SEG_LENGTH_BYTES + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -225,1 +249,1 @@\n-            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -302,2 +326,2 @@\n-        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n-        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n+        abstract void copy(X srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo);\n+        abstract void copy(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n@@ -318,2 +342,2 @@\n-            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes);\n+            void copy(byte[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen);\n@@ -323,2 +347,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n@@ -345,2 +369,2 @@\n-            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(char[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -350,2 +374,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -372,2 +396,2 @@\n-            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(short[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -377,2 +401,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -399,2 +423,2 @@\n-            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(int[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -404,2 +428,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -426,2 +450,2 @@\n-            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(float[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -431,2 +455,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -453,2 +477,2 @@\n-            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(long[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -458,2 +482,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -480,2 +504,2 @@\n-            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(double[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -485,2 +509,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":70,"deletions":46,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -39,0 +38,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -208,2 +208,2 @@\n-        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);\n-        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);\n+        MemoryAccess.setInt(everything, addr.toRawLongValue(), 42);\n+        assertEquals(MemoryAccess.getInt(everything, addr.toRawLongValue()), 42);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-            MemoryAccess.class,\n@@ -97,1 +96,1 @@\n-            MemoryCopy.class\n+            MemoryAccess.class\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -52,2 +52,2 @@\n-                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);\n-                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n+                int expected = MemoryAccess.getByte(s2.segment, i);\n+                int found = (int) MemoryAccess.getByte(s1.segment, i + offset);\n@@ -69,1 +69,1 @@\n-                MemoryAccess.getByteAtOffset(s2.segment, i);\n+                MemoryAccess.getByte(s2.segment, i);\n@@ -71,1 +71,1 @@\n-                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n+                    MemoryAccess.getByte(s1.segment, i + offset);\n@@ -128,1 +128,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte)i);\n+                MemoryAccess.setByte(segment, i, (byte)i);\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -110,1 +110,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemoryAccess.getInt(memorySegment, offset);\n@@ -117,1 +117,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemoryAccess.getInt(memorySegment, offset);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.SymbolLookup;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -65,1 +65,1 @@\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n+        assertEquals(MemoryAccess.getInt(segment, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +79,1 @@\n-            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+            MemoryAccess.setByte(segment, i, ((byte)RANDOM.nextInt()));\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -53,0 +53,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -165,1 +166,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.setByte(segment1, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -104,1 +105,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.setByte(segment1, i, (byte) i);\n@@ -122,1 +123,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.setByte(segment1, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -35,0 +34,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -63,2 +63,2 @@\n-        MemoryAccess.setInt(seg, 42);\n-        assertEquals(MemoryAccess.getInt(seg), 42);\n+        MemoryAccess.setInt(seg, 0, 42);\n+        assertEquals(MemoryAccess.getInt(seg, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import static jdk.incubator.foreign.CLinker.C_LONG;\n@@ -64,1 +63,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -226,1 +224,1 @@\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n+                    return MemoryAccess.getInt(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n@@ -244,1 +242,1 @@\n-            MemoryAccess.setInt(msInt, 10);\n+            MemoryAccess.setInt(msInt, 0, 10);\n@@ -493,1 +491,1 @@\n-                    MemoryAccess.setLong(longSum, lSum);\n+                    MemoryAccess.setLong(longSum, 0, lSum);\n@@ -498,1 +496,1 @@\n-                    MemoryAccess.setDouble(doubleSum, dSum);\n+                    MemoryAccess.setDouble(doubleSum, 0, dSum);\n@@ -524,2 +522,2 @@\n-            MemoryAccess.setLong(longSum, 0L);\n-            MemoryAccess.setDouble(doubleSum, 0D);\n+            MemoryAccess.setLong(longSum, 0, 0L);\n+            MemoryAccess.setDouble(doubleSum, 0, 0D);\n@@ -542,2 +540,2 @@\n-            long lSum = MemoryAccess.getLong(longSum);\n-            double dSum = MemoryAccess.getDouble(doubleSum);\n+            long lSum = MemoryAccess.getLong(longSum, 0);\n+            double dSum = MemoryAccess.getDouble(doubleSum, 0);\n@@ -755,1 +753,1 @@\n-                    int x = MemoryAccess.getInt(ms);\n+                    int x = MemoryAccess.getInt(ms, 0);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -123,1 +123,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -27,0 +26,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +78,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentIn, i, i);\n+            MemoryAccess.setDouble(segmentIn, i * CARRIER_SIZE, i);\n@@ -81,1 +81,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i, i);\n+            MemoryAccess.setDouble(segmentOut, i * CARRIER_SIZE, i);\n@@ -115,3 +115,3 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i,\n-                    MemoryAccess.getDoubleAtIndex(segmentIn, i) +\n-                    MemoryAccess.getDoubleAtIndex(segmentOut, i));\n+            MemoryAccess.setDouble(segmentOut, i * CARRIER_SIZE,\n+                    MemoryAccess.getDouble(segmentIn, i * CARRIER_SIZE) +\n+                    MemoryAccess.getDouble(segmentOut, i * CARRIER_SIZE));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -84,5 +84,5 @@\n-                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                MemoryAccess.setIntAtIndex(intI, i, i);\n-                MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                MemoryAccess.setFloatAtIndex(intF, i, i);\n-                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n+                MemoryAccess.setByte(intB, i, (byte)i);\n+                MemoryAccess.setInt(intI, i * 4, i);\n+                MemoryAccess.setDouble(intD, i * 8, i);\n+                MemoryAccess.setFloat(intF, i * 4, i);\n+                MemoryAccess.setByte(s, i, (byte) i);\n@@ -140,1 +140,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -149,1 +149,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -123,1 +123,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -82,2 +82,2 @@\n-                MemoryAccess.setIntAtIndex(nativeSegment, i, i);\n-                MemoryAccess.setFloatAtIndex(nativeSegment, i, i);\n+                MemoryAccess.setInt(nativeSegment, i * CARRIER_SIZE, i);\n+                MemoryAccess.setFloat(nativeSegment, i * CARRIER_SIZE, i);\n@@ -85,2 +85,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentBytes, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentBytes, i, i);\n+                MemoryAccess.setInt(heapSegmentBytes, i * CARRIER_SIZE, i);\n+                MemoryAccess.setFloat(heapSegmentBytes, i * CARRIER_SIZE, i);\n@@ -88,2 +88,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentFloats, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentFloats, i, i);\n+                MemoryAccess.setInt(heapSegmentFloats, i * CARRIER_SIZE, i);\n+                MemoryAccess.setFloat(heapSegmentFloats, i * CARRIER_SIZE, i);\n@@ -119,2 +119,2 @@\n-            MemoryAccess.setIntAtOffset(nativeSegment, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(nativeSegment, k);\n+            MemoryAccess.setInt(nativeSegment, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.getInt(nativeSegment, k * CARRIER_SIZE);\n@@ -141,2 +141,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentBytes, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentBytes, k);\n+            MemoryAccess.setInt(heapSegmentBytes, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.getInt(heapSegmentBytes, k * CARRIER_SIZE);\n@@ -163,2 +163,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentFloats, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentFloats, k);\n+            MemoryAccess.setInt(heapSegmentFloats, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.getInt(heapSegmentFloats, k * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -128,1 +128,1 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+        return MemoryAccess.getInt(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -152,1 +152,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        MemoryAccess.setByte(str, len, (byte)0);\n@@ -162,1 +162,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        MemoryAccess.setByte(str, len, (byte)0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -30,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -31,3 +29,0 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorSpecies;\n@@ -47,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -122,1 +116,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = MemoryAccess.getByte(srcSegmentImplicit, i);\n@@ -132,1 +126,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = MemoryAccess.getByte(srcSegmentImplicit, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,4 +104,4 @@\n-            setLongAtIndex(os, i,getLongAtIndex(is, i) + MemoryAccess.getLongAtIndex(os, i));\n-            setLongAtIndex(os, i+1,getLongAtIndex(is, i+1) + getLongAtIndex(os, i+1));\n-            setLongAtIndex(os, i+2,getLongAtIndex(is, i+2) + getLongAtIndex(os, i+2));\n-            setLongAtIndex(os, i+3,getLongAtIndex(is, i+3) + getLongAtIndex(os, i+3));\n+            setLong(os, i * 8, getLong(is, i * 8) + getLong(os, i * 8));\n+            setLong(os, (i+1) * 8, getLong(is, (i+1) * 8) + getLong(os, (i+1) * 8));\n+            setLong(os, (i+2) * 8, getLong(is, (i+2) * 8) + getLong(os, (i+2) * 8));\n+            setLong(os, (i+3) * 8, getLong(is, (i+3)* 8) + getLong(os, (i+3) * 8));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -235,2 +235,2 @@\n-      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n-      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+      var v = MemoryAccess.getByte(srcSegmentImplicit, i);\n+      MemoryAccess.setByte(dstSegmentImplicit, i, v);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}