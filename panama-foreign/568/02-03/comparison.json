{"files":[{"patch":"@@ -64,1 +64,1 @@\n-    private static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n+    static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -544,110 +544,0 @@\n-    \/**\n-     * Copies a number of bytes from a source segment to a destination segment.\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * @param srcSegment the source segment.\n-     * @param dstSegment  the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(MemorySegment srcSegment, MemorySegment dstSegment, long bytes) {\n-        copy(srcSegment, 0, dstSegment, 0, bytes);\n-    }\n-\n-    \/**\n-     * Copies a number of bytes from a source segment to a destination segment.\n-     * starting at a given source and destination offsets (expressed in bytes).\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n-        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n-    }\n-\n-    \/**\n-     * Copies a number of elements (whose size is specified by the corresponding layout parameters) from a source segment\n-     * to a destination segment, starting at a given source and destination offsets (expressed in bytes).\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * @param srcSegment the source segment.\n-     * @param srcElementLayout the element layout associated with the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstElementLayout the element layout associated with the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of elements to be copied.\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n-     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n-     * alignment constraints in the destination element layout.\n-     *\/\n-    @ForceInline\n-    public static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n-                                        ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(srcElementLayout);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(dstElementLayout);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n-        }\n-        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n-        }\n-        long size = elementCount * srcElementLayout.byteSize();\n-        if (size % srcElementLayout.byteSize() != 0) {\n-            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n-        }\n-        srcImpl.checkAccess(srcOffset, size, true);\n-        dstImpl.checkAccess(dstOffset, size, false);\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), dstImpl.scope(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of elements from a source segment to a destination array, starting at a given segment offset\n-     * (expressed in bytes), and a given array index, and using the given source element layout.\n-     * @param srcSegment the source segment.\n-     * @param srcElementLayout the element layout associated with the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination array.\n-     * @param dstIndex the starting index of the destination array.\n-     * @param elementCount the number of array elements to be copied.\n-     * @throws IllegalArgumentException if {@code dstArray} is not an array, or if the source\n-     * element layout has a size that does not match that of the array elements, or if its alignment constraints\n-     * are incompatible with the source offset.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n-            Object dstArray, int dstIndex, int elementCount) {\n-        Objects.requireNonNull(dstArray);\n-        int length = Array.getLength(dstArray); \/\/ throws if not an array\n-        copy(srcSegment, srcElementLayout, srcOffset, dstArray, dstIndex, elementCount,\n-                unsafe.arrayBaseOffset(dstArray.getClass()), unsafe.arrayIndexScale(dstArray.getClass()), length);\n-    }\n-\n@@ -682,23 +572,0 @@\n-    \/**\n-     * Copies a number of elements from a source array to a destination segment, starting at a given array index, and a\n-     * given segment offset (expressed in bytes), using the given destination element layout.\n-     * @param srcArray the source array.\n-     * @param srcIndex the starting index of the source array.\n-     * @param dstSegment the destination segment.\n-     * @param dstElementLayout the element layout associated with the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of array elements to be copied.\n-     * @throws IllegalArgumentException if {@code srcArray} is not an array, or if the destination\n-     * element layout has a size that does not match that of the array elements, or if its alignment constraints\n-     * are incompatible with the destination offset.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            Object srcArray, int srcIndex,\n-            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount) {\n-        Objects.requireNonNull(srcArray);\n-        int length = Array.getLength(srcArray); \/\/ throws if not an array\n-        copy(srcArray, srcIndex, dstSegment, dstElementLayout, dstOffset, elementCount,\n-                unsafe.arrayBaseOffset(srcArray.getClass()), unsafe.arrayIndexScale(srcArray.getClass()), length);\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":1,"deletions":134,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -367,1 +368,5 @@\n-     *\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+     * }<\/pre><\/blockquote>\n@@ -375,1 +380,3 @@\n-    void copyFrom(MemorySegment src);\n+    default void copyFrom(MemorySegment src) {\n+        MemorySegment.copy(src, this, src.byteSize());\n+    }\n@@ -822,0 +829,146 @@\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code 0} through {@code bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code 0} through {@code bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, 0, dstSegment, 0, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code bytes > srcSegment.byteSize()} or if\n+     * {@code bytes > dstSegment.byteSize()}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, MemorySegment dstSegment, long bytes) {\n+        copy(srcSegment, 0, dstSegment, 0, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        if (size % srcElementLayout.byteSize() != 0) {\n+            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n+        }\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            MemoryCopy.scopedMemoryAccess.copyMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            MemoryCopy.scopedMemoryAccess.copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":155,"deletions":2,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-        MemoryCopy.copy(heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()), 0, addr, elementLayout, 0, size);\n+        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()), 0, addr, elementLayout, 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,4 +143,0 @@\n-    public void copyFrom(MemorySegment src) {\n-        MemoryCopy.copy(src, this, src.byteSize());\n-    }\n-\n@@ -315,1 +311,1 @@\n-        MemoryCopy.copy(this, arrSegment, byteSize());\n+        MemorySegment.copy(this, arrSegment, byteSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryCopy;\n@@ -745,1 +744,1 @@\n-            MemoryCopy.copy(operand, copy, size);\n+            MemorySegment.copy(operand, copy, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.nio.charset.Charset;\n@@ -293,1 +292,1 @@\n-        MemoryCopy.copy(segment, start, MemorySegment.ofArray(bytes), 0, len);\n+        MemoryCopy.copy(segment, start, bytes, 0, len);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                        MemoryCopy.copy(gpRegsArea, currentGPOffset(), slice, 0, copy);\n+                        MemorySegment.copy(gpRegsArea, currentGPOffset(), slice, 0, copy);\n@@ -300,1 +300,1 @@\n-                        MemoryCopy.copy(fpRegsArea, currentFPOffset(), slice, 0, copy);\n+                        MemorySegment.copy(fpRegsArea, currentFPOffset(), slice, 0, copy);\n@@ -462,1 +462,1 @@\n-                            MemoryCopy.copy(slice, 0, gpRegs, currentGPOffset, copy);\n+                            MemorySegment.copy(slice, 0, gpRegs, currentGPOffset, copy);\n@@ -477,1 +477,1 @@\n-                            MemoryCopy.copy(slice, 0, fpRegs, currentFPOffset, copy);\n+                            MemorySegment.copy(slice, 0, fpRegs, currentFPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                    MemoryCopy.copy(segment, struct, layout.byteSize());\n+                    MemorySegment.copy(segment, struct, layout.byteSize());\n@@ -241,1 +241,1 @@\n-                            MemoryCopy.copy(msArg, cursor, arg.layout.byteSize());\n+                            MemorySegment.copy(msArg, cursor, arg.layout.byteSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-                            MemoryCopy.copy(regSaveArea, currentFPOffset(), slice, 0, copy);\n+                            MemorySegment.copy(regSaveArea, currentFPOffset(), slice, 0, copy);\n@@ -264,1 +264,1 @@\n-                            MemoryCopy.copy(regSaveArea, currentGPOffset(), slice, 0, copy);\n+                            MemorySegment.copy(regSaveArea, currentGPOffset(), slice, 0, copy);\n@@ -400,1 +400,1 @@\n-                                MemoryCopy.copy(slice, 0, reg_save_area, currentFPOffset, copy);\n+                                MemorySegment.copy(slice, 0, reg_save_area, currentFPOffset, copy);\n@@ -403,1 +403,1 @@\n-                                MemoryCopy.copy(slice, 0, reg_save_area, currentGPOffset, copy);\n+                                MemorySegment.copy(slice, 0, reg_save_area, currentGPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                    MemoryCopy.copy(segment, struct, layout.byteSize());\n+                    MemorySegment.copy(segment, struct, layout.byteSize());\n@@ -238,1 +238,1 @@\n-                            MemoryCopy.copy(msArg, cursor, VA_SLOT_SIZE_BYTES);\n+                            MemorySegment.copy(msArg, cursor, VA_SLOT_SIZE_BYTES);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        MemoryCopy.copy(s1.segment, 0, s2.segment, 0, size);\n+        MemorySegment.copy(s1.segment, 0, s2.segment, 0, size);\n@@ -78,1 +78,1 @@\n-        MemoryCopy.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n+        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}