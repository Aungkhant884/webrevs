{"files":[{"patch":"@@ -370,1 +370,1 @@\n-    MemorySegment.copyFrom(0, src, 0, src.byteSize());\n+    MemorySegment.copy(src, 0, this, 0, src.byteSize);\n@@ -381,77 +381,1 @@\n-        return copyFrom(0, src, 0, src.byteSize());\n-    }\n-\n-    \/**\n-     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at offset\n-     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into this\n-     * segment at offsets {@code dstOffset} through {@code dstOffset + bytes - 1}.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemorySegment.copyFrom(MemoryLayouts.JAVA_BYTE, dstOffset, src, MemoryLayouts.JAVA_BYTE, srcOffset, src.byteSize());\n-     * }<\/pre><\/blockquote>\n-     * @param src the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n-     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n-     * or {@code bytes} are {@code < 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     * @return this segment.\n-     *\/\n-    default MemorySegment copyFrom(long dstOffset, MemorySegment src, long srcOffset, long bytes) {\n-        return copyFrom(MemoryLayouts.JAVA_BYTE, dstOffset, src, MemoryLayouts.JAVA_BYTE, srcOffset, bytes);\n-    }\n-\n-    \/**\n-     * Performs a bulk copy from given source segment to this segment. More specifically, if {@code S} is the byte size\n-     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n-     * in the source segment are copied into this segment at offsets {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n-     * <p>\n-     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n-     * whose layout is {@code srcElementLayout}, whereas the bytes in this segment are interpreted as a sequence of\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n-     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n-     * are swapped accordingly during the copy operation.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * @param src the source segment.\n-     * @param srcElementLayout the element layout associated with the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstElementLayout the element layout associated with the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of elements to be copied.\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n-     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n-     * alignment constraints in the destination element layout.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n-     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n-     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     * @return this segment.\n-     *\/\n-    default MemorySegment copyFrom(ValueLayout dstElementLayout, long dstOffset, MemorySegment src, ValueLayout srcElementLayout, long srcOffset, long elementCount) {\n-        MemorySegment.copy(src, srcElementLayout, srcOffset, this, dstElementLayout, dstOffset, elementCount);\n+        MemorySegment.copy(src, 0, this, 0, src.byteSize());\n@@ -907,1 +831,106 @@\n-    \/\/ primitive copy method\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code 0} through {@code bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code 0} through {@code bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, 0, dstSegment, 0, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code bytes > srcSegment.byteSize()} or if\n+     * {@code bytes > dstSegment.byteSize()}, or if {@code bytes <= 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, MemorySegment dstSegment, long bytes) {\n+        copy(srcSegment, 0, dstSegment, 0, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n@@ -909,1 +938,1 @@\n-    private static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":109,"deletions":80,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -317,2 +317,3 @@\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout)).copyFrom(elementLayout, 0,\n-                heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout));\n+        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n+                addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -310,2 +310,1 @@\n-        segmentFactory.apply(arr)\n-                .copyFrom(0, this, 0, byteSize());\n+        segmentFactory.apply(arr).copyFrom(this);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-                            .copyFrom(0, operand, 0, size);\n+                            .copyFrom(operand.asSlice(0, size));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-                        value.copyFrom(offset, gpRegsArea, currentGPOffset(), copy);\n+                        MemorySegment.copy(gpRegsArea, currentGPOffset(), value, offset, copy);\n@@ -297,1 +297,1 @@\n-                        value.copyFrom(offset, gpRegsArea, currentFPOffset(), copy);\n+                        MemorySegment.copy(gpRegsArea, currentFPOffset(), value, offset, copy);\n@@ -457,1 +457,1 @@\n-                            gpRegs.copyFrom(currentGPOffset, valueSegment, offset, copy);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentGPOffset, copy);\n@@ -471,1 +471,1 @@\n-                            gpRegs.copyFrom(currentFPOffset, valueSegment, offset, copy);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentFPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                            .copyFrom(0, segment, 0, layout.byteSize());\n+                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -241,1 +241,1 @@\n-                            cursor.copyFrom(0, msArg, 0, arg.layout.byteSize())\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-                            value.copyFrom(offset, regSaveArea, currentFPOffset(), copy);\n+                            MemorySegment.copy(regSaveArea, currentFPOffset(), value, offset, copy);\n@@ -262,1 +262,1 @@\n-                            value.copyFrom(offset, regSaveArea, currentGPOffset(), copy);\n+                            MemorySegment.copy(regSaveArea, currentGPOffset(), value, offset, copy);\n@@ -397,1 +397,1 @@\n-                                reg_save_area.copyFrom(currentFPOffset, valueSegment, offset, copy);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentFPOffset, copy);\n@@ -400,1 +400,1 @@\n-                                reg_save_area.copyFrom(currentGPOffset, valueSegment, offset, copy);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentGPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -127,2 +127,1 @@\n-                    allocator.allocate(layout)\n-                                    .copyFrom(0, segment, 0, layout.byteSize());\n+                    allocator.allocate(layout).copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -236,1 +235,1 @@\n-                            cursor.copyFrom(0, msArg, 0, VA_SLOT_SIZE_BYTES);\n+                            cursor.copyFrom(msArg.asSlice(0, VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run testng TestMemoryCopy\n+ * @run testng TestArrayCopy\n@@ -56,1 +56,1 @@\n-public class TestMemoryCopy {\n+public class TestArrayCopy {\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng TestCopyFrom\n+ * @run testng TestSegmentCopy\n@@ -45,1 +45,1 @@\n-public class TestCopyFrom {\n+public class TestSegmentCopy {\n@@ -58,1 +58,1 @@\n-        s2.segment.copyFrom(0, s1.segment, 0, size);\n+        MemorySegment.copy(s1.segment, s2.segment, size);\n@@ -77,1 +77,1 @@\n-        s2.segment.copyFrom(s2.type.layout, 0, s1.segment, s1.type.layout, 0, size);\n+        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","status":"renamed"}]}