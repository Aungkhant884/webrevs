{"files":[{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.Array;\n@@ -35,1 +36,1 @@\n- * This class provides convenient methods for copying data between primitive arrays and memory segments.\n+ * This class provides convenient methods for copying data between to and from memory segments.\n@@ -46,4 +47,5 @@\n- * Additional overloads are provided (see {@link #copyFromArray(double[], int, int, MemorySegment, long)}),\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * <p>\n+ * Generally, the arguments of the copy methods roughly follow the convention for {@link System#arraycopy}.\n+ * The optional trailing argument controls byte order, which by default is the current {@linkplain ByteOrder#nativeOrder() native byte order}.\n+ * <p>\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n@@ -53,1 +55,1 @@\n- * Finally, attempting to copy to\/from a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n+ * Moreover, attempting to copy to\/from a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n@@ -56,1 +58,3 @@\n- * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n+ * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.\n+ * Finally, attempting to copy data into a {@linkplain MemorySegment#isReadOnly() read-only} segment always causes an\n+ * {@link UnsupportedOperationException} to be thrown.\n@@ -60,1 +64,1 @@\n-    private static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n+    static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -63,7 +67,22 @@\n-    private static final int BYTE_BASE = unsafe.arrayBaseOffset(byte[].class);\n-    private static final int CHAR_BASE = unsafe.arrayBaseOffset(char[].class);\n-    private static final int SHORT_BASE = unsafe.arrayBaseOffset(short[].class);\n-    private static final int INT_BASE = unsafe.arrayBaseOffset(int[].class);\n-    private static final int FLOAT_BASE = unsafe.arrayBaseOffset(float[].class);\n-    private static final int LONG_BASE = unsafe.arrayBaseOffset(long[].class);\n-    private static final int DOUBLE_BASE = unsafe.arrayBaseOffset(double[].class);\n+    private final static ByteOrder NON_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n+            ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n+\n+    private final static ValueLayout JAVA_SHORT_NO = MemoryLayouts.JAVA_SHORT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_CHAR_NO = MemoryLayouts.JAVA_CHAR.withBitAlignment(8);\n+    private final static ValueLayout JAVA_INT_NO = MemoryLayouts.JAVA_INT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_FLOAT_NO = MemoryLayouts.JAVA_FLOAT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_LONG_NO = MemoryLayouts.JAVA_LONG.withBitAlignment(8);\n+    private final static ValueLayout JAVA_DOUBLE_NO = MemoryLayouts.JAVA_DOUBLE.withBitAlignment(8);\n+\n+    private final static ValueLayout JAVA_SHORT_NNO = JAVA_SHORT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_CHAR_NNO = JAVA_CHAR_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_INT_NNO = JAVA_INT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_FLOAT_NNO = JAVA_FLOAT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_LONG_NNO = JAVA_LONG_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_DOUBLE_NNO = JAVA_DOUBLE_NO.withOrder(NON_NATIVE_ORDER);\n+\n+    private static ValueLayout pick(ByteOrder order, ValueLayout nativeLayout, ValueLayout nonNativeLayout) {\n+        Objects.requireNonNull(order);\n+        return order == ByteOrder.nativeOrder() ?\n+                nativeLayout : nonNativeLayout;\n+    }\n@@ -78,2 +97,1 @@\n-     * @param srcIndexBytes the starting index of the source byte array.\n-     * @param srcCopyLengthBytes the number of byte elements to be copied.\n+     * @param srcIndex the starting index of the source byte array.\n@@ -81,1 +99,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of byte elements to be copied.\n@@ -84,11 +103,4 @@\n-    public static void copyFromArray(\n-            byte[] srcArray, int srcIndexBytes, int srcCopyLengthBytes,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.checkFromIndexSize(srcIndexBytes, srcCopyLengthBytes, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthBytes, false);\n-        scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                srcArray, BYTE_BASE + srcIndexBytes,\n-                destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthBytes);\n+    public static void copy(\n+            byte[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, srcArray.length);\n@@ -101,1 +113,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -103,2 +115,2 @@\n-     * @param dstIndexBytes the starting index of the destination byte array.\n-     * @param dstCopyLengthBytes the number of byte elements to be copied.\n+     * @param dstIndex the starting index of the destination byte array.\n+     * @param elementCount the number of byte elements to be copied.\n@@ -107,11 +119,5 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            byte[] dstArray, int dstIndexBytes, int dstCopyLengthBytes) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthBytes, true);\n-        Objects.checkFromIndexSize(dstIndexBytes, dstCopyLengthBytes, dstArray.length);\n-        scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                dstArray, BYTE_BASE + dstIndexBytes, dstCopyLengthBytes);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            byte[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, dstArray.length);\n@@ -125,2 +131,1 @@\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n+     * @param srcIndex the starting index of the source char array.\n@@ -128,1 +133,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of char elements to be copied.\n@@ -131,4 +137,3 @@\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexChars, srcCopyLengthChars, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    public static void copy(\n+            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -141,2 +146,1 @@\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n+     * @param srcIndex the starting index of the source char array.\n@@ -144,1 +148,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of char elements to be copied.\n@@ -146,1 +151,0 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -149,19 +153,4 @@\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexChars, srcCopyLengthChars, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthChars << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1, 2);\n-        }\n+    public static void copy(\n+            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount, ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, srcArray.length);\n@@ -174,1 +163,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -176,2 +165,2 @@\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n+     * @param dstIndex the starting index of the destination char array.\n+     * @param elementCount the number of char elements to be copied.\n@@ -180,4 +169,4 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexChars, dstCopyLengthChars, ByteOrder.nativeOrder());\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            char[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -190,1 +179,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -192,2 +181,2 @@\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n+     * @param dstIndex the starting index of the destination char array.\n+     * @param elementCount the number of char elements to be copied.\n@@ -195,1 +184,0 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -198,3 +186,3 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars,\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            char[] dstArray, int dstIndex, int elementCount,\n@@ -202,15 +190,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthChars << 1, true);\n-        Objects.checkFromIndexSize(dstIndexChars, dstCopyLengthChars, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1, 2);\n-        }\n+        copy(srcSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, dstArray.length);\n@@ -224,2 +199,1 @@\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n+     * @param srcIndex the starting index of the source short array.\n@@ -227,1 +201,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of short elements to be copied.\n@@ -230,4 +205,3 @@\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexShorts, srcCopyLengthShorts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    public static void copy(\n+            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -240,2 +214,1 @@\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n+     * @param srcIndex the starting index of the source short array.\n@@ -243,1 +216,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of short elements to be copied.\n@@ -245,1 +219,0 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -248,3 +221,2 @@\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n+    public static void copy(\n+            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n@@ -252,15 +224,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexShorts, srcCopyLengthShorts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthShorts << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1, 2);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, srcArray.length);\n@@ -273,1 +232,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -275,2 +234,2 @@\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n+     * @param dstIndex the starting index of the destination short array.\n+     * @param elementCount the number of short elements to be copied.\n@@ -279,4 +238,4 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexShorts, dstCopyLengthShorts, ByteOrder.nativeOrder());\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            short[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -289,1 +248,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -291,2 +250,2 @@\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n+     * @param dstIndex the starting index of the destination short array.\n+     * @param elementCount the number of short elements to be copied.\n@@ -297,3 +256,3 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts,\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            short[] dstArray, int dstIndex, int elementCount,\n@@ -301,15 +260,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthShorts << 1, true);\n-        Objects.checkFromIndexSize(dstIndexShorts, dstCopyLengthShorts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1, 2);\n-        }\n+        copy(srcSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, dstArray.length);\n@@ -323,2 +269,1 @@\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n+     * @param srcIndex the starting index of the source int array.\n@@ -326,1 +271,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of int elements to be copied.\n@@ -329,4 +275,3 @@\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexInts, srcCopyLengthInts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    public static void copy(\n+            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -339,2 +284,1 @@\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n+     * @param srcIndex the starting index of the source int array.\n@@ -342,1 +286,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of int elements to be copied.\n@@ -344,1 +289,0 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -347,3 +291,2 @@\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n+    public static void copy(\n+            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n@@ -351,15 +294,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexInts, srcCopyLengthInts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthInts << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2, 4);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, srcArray.length);\n@@ -372,1 +302,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -374,2 +304,2 @@\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n+     * @param dstIndex the starting index of the destination int array.\n+     * @param elementCount the number of int elements to be copied.\n@@ -378,4 +308,4 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexInts, dstCopyLengthInts, ByteOrder.nativeOrder());\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            int[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -388,1 +318,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -390,2 +320,2 @@\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n+     * @param dstIndex the starting index of the destination int array.\n+     * @param elementCount the number of int elements to be copied.\n@@ -396,3 +326,3 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts,\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            int[] dstArray, int dstIndex, int elementCount,\n@@ -400,15 +330,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthInts << 2, true);\n-        Objects.checkFromIndexSize(dstIndexInts, dstCopyLengthInts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2, 4);\n-        }\n+        copy(srcSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, dstArray.length);\n@@ -422,2 +339,1 @@\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n+     * @param srcIndex the starting index of the source float array.\n@@ -425,1 +341,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of float elements to be copied.\n@@ -428,4 +345,3 @@\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexFloats, srcCopyLengthFloats, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    public static void copy(\n+            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -438,2 +354,1 @@\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n+     * @param srcIndex the starting index of the source float array.\n@@ -441,1 +356,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of float elements to be copied.\n@@ -443,1 +359,0 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -446,3 +361,2 @@\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n+    public static void copy(\n+            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n@@ -450,15 +364,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexFloats, srcCopyLengthFloats, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthFloats << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2, 4);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, srcArray.length);\n@@ -471,1 +372,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -473,2 +374,2 @@\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n+     * @param dstIndex the starting index of the destination float array.\n+     * @param elementCount the number of float elements to be copied.\n@@ -477,4 +378,4 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexFloats, dstCopyLengthFloats, ByteOrder.nativeOrder());\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            float[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -487,1 +388,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -489,2 +390,2 @@\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n+     * @param dstIndex the starting index of the destination float array.\n+     * @param elementCount the number of float elements to be copied.\n@@ -495,3 +396,3 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats,\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            float[] dstArray, int dstIndex, int elementCount,\n@@ -499,15 +400,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthFloats << 2, true);\n-        Objects.checkFromIndexSize(dstIndexFloats, dstCopyLengthFloats, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2, 4);\n-        }\n+        copy(srcSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, dstArray.length);\n@@ -521,2 +409,1 @@\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n+     * @param srcIndex the starting index of the source long array.\n@@ -524,1 +411,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of long elements to be copied.\n@@ -527,4 +415,3 @@\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexLongs, srcCopyLengthLongs, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    public static void copy(\n+            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -537,2 +424,1 @@\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n+     * @param srcIndex the starting index of the source long array.\n@@ -540,1 +426,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of long elements to be copied.\n@@ -542,1 +429,0 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -545,3 +431,2 @@\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n+    public static void copy(\n+            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n@@ -549,15 +434,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexLongs, srcCopyLengthLongs, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthLongs << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3, 8);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, srcArray.length);\n@@ -570,1 +442,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -572,2 +444,2 @@\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n+     * @param dstIndex the starting index of the destination long array.\n+     * @param elementCount the number of long elements to be copied.\n@@ -576,4 +448,4 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexLongs, dstCopyLengthLongs, ByteOrder.nativeOrder());\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            long[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -586,1 +458,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -588,2 +460,2 @@\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n+     * @param dstIndex the starting index of the destination long array.\n+     * @param elementCount the number of long elements to be copied.\n@@ -594,3 +466,3 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs,\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            long[] dstArray, int dstIndex, int elementCount,\n@@ -598,15 +470,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthLongs << 3, true);\n-        Objects.checkFromIndexSize(dstIndexLongs, dstCopyLengthLongs, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3, 8);\n-        }\n+        copy(srcSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, dstArray.length);\n@@ -620,2 +479,1 @@\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n+     * @param srcIndex the starting index of the source double array.\n@@ -623,1 +481,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of double elements to be copied.\n@@ -626,4 +485,3 @@\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexDoubles, srcCopyLengthDoubles, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    public static void copy(\n+            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -636,2 +494,1 @@\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n+     * @param srcIndex the starting index of the source double array.\n@@ -639,1 +496,2 @@\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of double elements to be copied.\n@@ -641,1 +499,0 @@\n-     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -644,3 +501,2 @@\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n+    public static void copy(\n+            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n@@ -648,15 +504,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexDoubles, srcCopyLengthDoubles, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthDoubles << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3, 8);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, srcArray.length);\n@@ -669,1 +512,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -671,2 +514,2 @@\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n+     * @param dstIndex the starting index of the destination double array.\n+     * @param elementCount the number of double elements to be copied.\n@@ -675,4 +518,4 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexDoubles, dstCopyLengthDoubles, ByteOrder.nativeOrder());\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            double[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -685,1 +528,1 @@\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n@@ -687,2 +530,2 @@\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n+     * @param dstIndex the starting index of the destination double array.\n+     * @param elementCount the number of double elements to be copied.\n@@ -693,3 +536,3 @@\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles,\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            double[] dstArray, int dstIndex, int elementCount,\n@@ -697,0 +540,9 @@\n+        copy(srcSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, dstArray.length);\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount,\n+            int dstBase, int dstWidth, int dstLength) {\n@@ -699,1 +551,1 @@\n-        Objects.requireNonNull(order);\n+        Objects.requireNonNull(srcElementLayout);\n@@ -701,3 +553,9 @@\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthDoubles << 3, true);\n-        Objects.checkFromIndexSize(dstIndexDoubles, dstCopyLengthDoubles, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, dstLength);\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source offset incompatible with alignment constraints\");\n+        }\n+        if (srcElementLayout.byteSize() != dstWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        if (srcElementLayout.order() == ByteOrder.nativeOrder()) {\n@@ -705,2 +563,2 @@\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3);\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n@@ -709,2 +567,30 @@\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3, 8);\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount,\n+            int srcBase, int srcWidth, int srcLength) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        Objects.checkFromIndexSize(srcIndex, elementCount, srcLength);\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Destination offset incompatible with alignment constraints\");\n+        }\n+        if (dstElementLayout.byteSize() != srcWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (dstElementLayout.order() == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":266,"deletions":380,"binary":false,"changes":646,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -367,26 +368,0 @@\n-     *\n-     * @param src the source segment.\n-     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    void copyFrom(MemorySegment src);\n-\n-    \/**\n-     * Performs an element-wise bulk copy from given source segment to this segment. More specifically, the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment\n-     * at offset {@code 0} through {@code src.byteSize() - 1}.\n-     * <p>\n-     * The copy occurs in an element-wise fashion: the source bytes are interpreted as a sequence of elements\n-     * whose layout is {@code srcElementLayout}, whereas the bytes in this segment are interpreted as a sequence of\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S} and\n-     * alignment {@code A}, and the size of the source segment must be a multiple of {@code S} for the copy operation\n-     * to be correctly specified. If the byte order of the two element layouts differ, the bytes corresponding to each\n-     * element to be copied are swapped accordingly during the copy operation.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n@@ -394,9 +369,4 @@\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     *\n-     * @implSpec\n-     * If {@code srcElementLayout.byteSize() == 1}, or if {@code srcElementLayout.order() == dstElementLayout.order()}, calling\n-     * this method must be equivalent to calling {@link #copyFrom(MemorySegment)} with the same source segment.\n-     *\n-     * @param dstElementLayout the element layout associated with this segment.\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+     * }<\/pre><\/blockquote>\n@@ -404,1 +374,0 @@\n-     * @param srcElementLayout the element layout associated with the source segment.\n@@ -406,4 +375,0 @@\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment size is not\n-     * a multiple of the source element layout size, if the source segment is incompatible with the alignment constraints\n-     * in the source element layout, or if this segment is incompatible with the alignment constraints\n-     * in the destination element layout.\n@@ -415,1 +380,3 @@\n-    void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout);\n+    default void copyFrom(MemorySegment src) {\n+        MemorySegment.copy(src, this, src.byteSize());\n+    }\n@@ -862,0 +829,146 @@\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code 0} through {@code bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code 0} through {@code bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, 0, dstSegment, 0, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code bytes > srcSegment.byteSize()} or if\n+     * {@code bytes > dstSegment.byteSize()}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, MemorySegment dstSegment, long bytes) {\n+        copy(srcSegment, 0, dstSegment, 0, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        if (size % srcElementLayout.byteSize() != 0) {\n+            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n+        }\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            MemoryCopy.scopedMemoryAccess.copyMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            MemoryCopy.scopedMemoryAccess.copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":154,"deletions":41,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -316,2 +316,3 @@\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(Array.getLength(array), elementLayout));\n-        addr.copyFrom(elementLayout, heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()));\n+        int size = Array.getLength(array);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout));\n+        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()), 0, addr, elementLayout, 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,36 +143,0 @@\n-    public void copyFrom(MemorySegment src) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n-                that.base(), that.min(),\n-                base(), min(), size);\n-    }\n-\n-    public void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout) {\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n-        }\n-        if (((AbstractMemorySegmentImpl)src).min() % srcElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (min() % dstElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n-        }\n-        long size = src.byteSize();\n-        if (size % srcElementLayout.byteSize() != 0) {\n-            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n-        }\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            copyFrom(src);\n-        } else {\n-            AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) src;\n-            checkAccess(0, size, false);\n-            that.checkAccess(0, size, true);\n-            SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                    that.base(), that.min(),\n-                    base(), min(), size, srcElementLayout.byteSize());\n-        }\n-    }\n-\n@@ -347,1 +311,1 @@\n-        arrSegment.copyFrom(this);\n+        MemorySegment.copy(this, arrSegment, byteSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-            copy.copyFrom(operand.asSlice(0, size));\n+            MemorySegment.copy(operand, copy, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryCopy;\n@@ -56,1 +57,0 @@\n-import java.nio.charset.Charset;\n@@ -292,2 +292,1 @@\n-        MemorySegment.ofArray(bytes)\n-                .copyFrom(segment.asSlice(start, len));\n+        MemoryCopy.copy(segment, start, bytes, 0, len);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-                        slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));\n+                        MemorySegment.copy(gpRegsArea, currentGPOffset(), slice, 0, copy);\n@@ -300,1 +300,1 @@\n-                        slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));\n+                        MemorySegment.copy(fpRegsArea, currentFPOffset(), slice, 0, copy);\n@@ -462,1 +462,1 @@\n-                            gpRegs.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(slice, 0, gpRegs, currentGPOffset, copy);\n@@ -477,1 +477,1 @@\n-                            fpRegs.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(slice, 0, fpRegs, currentFPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    MemorySegment.copy(segment, struct, layout.byteSize());\n@@ -241,1 +241,1 @@\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n+                            MemorySegment.copy(msArg, cursor, arg.layout.byteSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentFPOffset(), slice, 0, copy);\n@@ -264,1 +264,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentGPOffset(), slice, 0, copy);\n@@ -400,1 +400,1 @@\n-                                reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(slice, 0, reg_save_area, currentFPOffset, copy);\n@@ -403,1 +403,1 @@\n-                                reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(slice, 0, reg_save_area, currentGPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    MemorySegment.copy(segment, struct, layout.byteSize());\n@@ -238,2 +238,1 @@\n-                            MemorySegment slice = cursor.asSlice(0, VA_SLOT_SIZE_BYTES);\n-                            slice.copyFrom(msArg);\n+                            MemorySegment.copy(msArg, cursor, VA_SLOT_SIZE_BYTES);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.MemoryCopy;\n@@ -58,1 +59,1 @@\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n+        MemorySegment.copy(s1.segment, s2.segment, size);\n@@ -77,1 +78,1 @@\n-        s2.segment.copyFrom(s2.type.layout, s1.segment.asSlice(0, size * s1.type.size()), s1.type.layout);\n+        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        helper.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -85,1 +85,1 @@\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        helper.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -102,1 +102,1 @@\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        helper.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -109,1 +109,1 @@\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        helper.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -120,1 +120,1 @@\n-            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, 0, dstSeg, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n@@ -129,1 +129,1 @@\n-            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n@@ -144,1 +144,1 @@\n-            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, -1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -153,1 +153,1 @@\n-            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -168,1 +168,1 @@\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, 0, dstSeg, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -177,1 +177,1 @@\n-            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -192,1 +192,1 @@\n-            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, helper.length(srcArr) + 1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -201,1 +201,1 @@\n-            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -216,1 +216,1 @@\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n+            helper.copy(srcArr, 0, dstSeg, SEG_LENGTH_BYTES + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -225,1 +225,1 @@\n-            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            helper.copy(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n@@ -302,2 +302,2 @@\n-        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n-        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n+        abstract void copy(X srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo);\n+        abstract void copy(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n@@ -318,2 +318,2 @@\n-            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes);\n+            void copy(byte[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen);\n@@ -323,2 +323,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n@@ -345,2 +345,2 @@\n-            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(char[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -350,2 +350,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -372,2 +372,2 @@\n-            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(short[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -377,2 +377,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -399,2 +399,2 @@\n-            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(int[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -404,2 +404,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -426,2 +426,2 @@\n-            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(float[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -431,2 +431,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -453,2 +453,2 @@\n-            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(long[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -458,2 +458,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -480,2 +480,2 @@\n-            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            void copy(double[] srcArr, int srcIndex, MemorySegment dstSeg, long dstOffsetBytes, int srcCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -485,2 +485,2 @@\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            void copy(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -109,1 +109,5 @@\n-            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,java.lang.Object,int,int)\/0\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,java.lang.Object,int,int)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(java.lang.Object,int,jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,int)\/2\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(java.lang.Object,int,jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,int)\/3\/0\"\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}