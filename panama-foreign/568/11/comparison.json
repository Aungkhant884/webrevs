{"files":[{"patch":"@@ -43,1 +43,0 @@\n-import java.nio.charset.Charset;\n@@ -375,1 +374,1 @@\n-        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n+        MemoryAccess.setByte(addr, bytes.length, (byte)0);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n@@ -32,0 +34,1 @@\n+import java.lang.reflect.Array;\n@@ -36,1 +39,1 @@\n- * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.\n+ * This class defines convenient static methods which can be used to read\/write Java values from\/to memory segments.\n@@ -38,3 +41,8 @@\n- * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long, ByteOrder)}) take a segment, an offset\n- * (expressed in bytes) and a byte order. The final address at which the dereference will occur will be computed by offsetting\n- * the base address by the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n+ * Single values can be read and written using accessors like {@link #getInt(MemorySegment, long)}, and\n+ * {@link #setInt(MemorySegment, long, int)}. These accessors all accept the following parameters:\n+ * <ul>\n+ *     <li>the memory segment to be read (resp. written)<\/li>\n+ *     <li>the offset, in bytes, at which the read (resp. write) operation should occur<\/li>\n+ *     <li>the offset, in bytes, at which the read (resp. write) operation should occur<\/li>\n+ *     <li>an optional {@linkplain ByteOrder byte order}<\/li>\n+ * <\/ul>\n@@ -42,2 +50,14 @@\n- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment, ByteOrder)}) so that\n- * clients can omit the offset coordinate.\n+ * Multiple values can be read and written in bulk from and to Java arrays, using accessors like {@link #copy(MemorySegment, long, Object, int, int)}.\n+ * These accessors all accept the following parameters (source parameters are laid out before destination parameters, similarly to\n+ * {@link System#arraycopy(Object, int, Object, int, int)}):\n+ <ul>\n+ *     <li>the memory segment to be read (resp. written)<\/li>\n+ *     <li>the offset, in bytes, at which elements should be read (resp. written) from (resp. to) the segment<\/li>\n+ *     <li>the Java array to be written (resp. read)<\/li>\n+ *     <li>the array index at which elements should be written (resp. read) to (resp. from) the array<\/li>\n+ *     <li>an optional {@linkplain ByteOrder byte order}<\/li>\n+ * <\/ul>\n+ * If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.\n@@ -45,10 +65,1 @@\n- * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long, ByteOrder)}),\n- * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n- * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n- * be dereferenced.\n- * <p>\n- * In cases where native byte order is preferred, overloads are provided (see {@link #getIntAtOffset(MemorySegment, long)})\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n@@ -60,1 +71,2 @@\n- * causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n+ * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n+ * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n@@ -65,1 +77,1 @@\n-        \/\/ just the one\n+        \/\/ just the one!\n@@ -68,0 +80,4 @@\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -82,1 +98,1 @@\n-    private static final VarHandle address_handle;\n+    private static final VarHandle address_handle = unalignedHandle(MemoryLayouts.ADDRESS, MemoryAddress.class);\n@@ -84,10 +100,1 @@\n-    static {\n-        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n-            case 4 -> int.class;\n-            case 8 -> long.class;\n-            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n-        };\n-        address_handle = MemoryHandles.asAddressVarHandle(unalignedHandle(MemoryLayouts.ADDRESS, carrier));\n-    }\n-\n-    private static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n+    static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n@@ -97,4 +104,0 @@\n-    \/\/ Note: all the accessor methods defined below take advantage of argument type profiling\n-    \/\/ (see src\/hotspot\/share\/oops\/methodData.cpp) which greatly enhances performance when the same accessor\n-    \/\/ method is used repeatedly with different segment kinds (e.g. on-heap vs. off-heap).\n-\n@@ -109,1 +112,1 @@\n-    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n+    public static byte getByte(MemorySegment segment, long offset) {\n@@ -122,1 +125,1 @@\n-    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n+    public static void setByte(MemorySegment segment, long offset, byte value) {\n@@ -135,1 +138,1 @@\n-    public static boolean getBooleanAtOffset(MemorySegment segment, long offset) {\n+    public static boolean getBoolean(MemorySegment segment, long offset) {\n@@ -148,1 +151,1 @@\n-    public static void setBooleanAtOffset(MemorySegment segment, long offset, boolean value) {\n+    public static void setBoolean(MemorySegment segment, long offset, boolean value) {\n@@ -165,2 +168,2 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset) {\n-        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static char getChar(MemorySegment segment, long offset) {\n+        return getChar(segment, offset, ByteOrder.nativeOrder());\n@@ -181,2 +184,2 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n-        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setChar(MemorySegment segment, long offset, char value) {\n+        setChar(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -197,2 +200,2 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset) {\n-        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static short getShort(MemorySegment segment, long offset) {\n+        return getShort(segment, offset, ByteOrder.nativeOrder());\n@@ -213,2 +216,2 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n-        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setShort(MemorySegment segment, long offset, short value) {\n+        setShort(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -229,2 +232,2 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset) {\n-        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static int getInt(MemorySegment segment, long offset) {\n+        return getInt(segment, offset, ByteOrder.nativeOrder());\n@@ -245,2 +248,2 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n-        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setInt(MemorySegment segment, long offset, int value) {\n+        setInt(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -261,2 +264,2 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n-        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static float getFloat(MemorySegment segment, long offset) {\n+        return getFloat(segment, offset, ByteOrder.nativeOrder());\n@@ -277,2 +280,2 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n-        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setFloat(MemorySegment segment, long offset, float value) {\n+        setFloat(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -293,2 +296,2 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset) {\n-        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static long getLong(MemorySegment segment, long offset) {\n+        return getLong(segment, offset, ByteOrder.nativeOrder());\n@@ -309,2 +312,2 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n-        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setLong(MemorySegment segment, long offset, long value) {\n+        setLong(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -325,2 +328,2 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n-        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static double getDouble(MemorySegment segment, long offset) {\n+        return getDouble(segment, offset, ByteOrder.nativeOrder());\n@@ -341,2 +344,2 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n-        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void setDouble(MemorySegment segment, long offset, double value) {\n+        setDouble(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -358,1 +361,1 @@\n-    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n+    public static MemoryAddress getAddress(MemorySegment segment, long offset) {\n@@ -376,1 +379,1 @@\n-    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n+    public static void setAddress(MemorySegment segment, long offset, Addressable value) {\n@@ -396,1 +399,1 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static char getChar(MemorySegment segment, long offset, ByteOrder order) {\n@@ -416,1 +419,1 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n+    public static void setChar(MemorySegment segment, long offset, ByteOrder order, char value) {\n@@ -436,1 +439,1 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static short getShort(MemorySegment segment, long offset, ByteOrder order) {\n@@ -456,1 +459,1 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n+    public static void setShort(MemorySegment segment, long offset, ByteOrder order, short value) {\n@@ -476,1 +479,1 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static int getInt(MemorySegment segment, long offset, ByteOrder order) {\n@@ -496,1 +499,1 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n+    public static void setInt(MemorySegment segment, long offset, ByteOrder order, int value) {\n@@ -516,1 +519,1 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static float getFloat(MemorySegment segment, long offset, ByteOrder order) {\n@@ -536,1 +539,1 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n+    public static void setFloat(MemorySegment segment, long offset, ByteOrder order, float value) {\n@@ -556,1 +559,1 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static long getLong(MemorySegment segment, long offset, ByteOrder order) {\n@@ -576,1 +579,1 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n+    public static void setLong(MemorySegment segment, long offset, ByteOrder order, long value) {\n@@ -596,1 +599,1 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static double getDouble(MemorySegment segment, long offset, ByteOrder order) {\n@@ -616,1 +619,1 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n+    public static void setDouble(MemorySegment segment, long offset, ByteOrder order, double value) {\n@@ -623,313 +626,9 @@\n-     * Reads a byte from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    byte value = getByteAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByte(MemorySegment segment) {\n-        return getByteAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByte(MemorySegment segment, byte value) {\n-        setByteAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a boolean from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    boolean value = getBooleanAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a boolean value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static boolean getBoolean(MemorySegment segment) {\n-        return getBooleanAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a boolean at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setBooleanAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the boolean value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setBoolean(MemorySegment segment, boolean value) {\n-        setBooleanAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment) {\n-        return getCharAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, char value) {\n-        setCharAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment) {\n-        return getShortAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, short value) {\n-        setShortAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment) {\n-        return getIntAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, int value) {\n-        setIntAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment) {\n-        return getFloatAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, float value) {\n-        setFloatAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment) {\n-        return getLongAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, long value) {\n-        setLongAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment) {\n-        return getDoubleAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, double value) {\n-        setDoubleAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemoryAddress value = getAddressAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a memory address read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddress(MemorySegment segment) {\n-        return getAddressAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddress(MemorySegment segment, Addressable value) {\n-        setAddressAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment, ByteOrder order) {\n-        return getCharAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, ByteOrder order, char value) {\n-        setCharAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n+     * Copies a number of double elements from a source segment to a destination array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -938,2 +637,4 @@\n-    public static short getShort(MemorySegment segment, ByteOrder order) {\n-        return getShortAtOffset(segment, 0L, order);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -943,9 +644,11 @@\n-     * Writes a short at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n+     * Copies a number of double elements from a source segment to a destination array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -954,563 +657,74 @@\n-    public static void setShort(MemorySegment segment, ByteOrder order, short value) {\n-        setShortAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment, ByteOrder order) {\n-        return getIntAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, ByteOrder order, int value) {\n-        setIntAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment, ByteOrder order) {\n-        return getFloatAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment, ByteOrder order) {\n-        return getLongAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, ByteOrder order, long value) {\n-        setLongAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment, ByteOrder order) {\n-        return getDoubleAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index) {\n-        return getCharAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index) {\n-        return getShortAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index) {\n-        return getIntAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index) {\n-        return getLongAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getCharAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, ByteOrder order, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getShortAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, ByteOrder order, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getIntAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, ByteOrder order, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getLongAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, ByteOrder order, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    @ForceInline\n-    private static long scale(MemorySegment address, long index, int size) {\n-        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);\n+    public static void copy(\n+            MemorySegment srcSegment, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount, ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        int dstBase = UNSAFE.arrayBaseOffset(dstArray.getClass());\n+        int dstWidth = UNSAFE.arrayIndexScale(dstArray.getClass());\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+     *\/\n+    @ForceInline\n+    public static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of array elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n+     *\/\n+    @ForceInline\n+    public static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, long dstOffset, int elementCount, ByteOrder order) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(order);\n+        int srcBase = UNSAFE.arrayBaseOffset(srcArray.getClass());\n+        int srcWidth = UNSAFE.arrayIndexScale(srcArray.getClass());\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":178,"deletions":964,"binary":false,"changes":1142,"status":"modified"},{"patch":"@@ -1,713 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * This class provides convenient methods for copying data between primitive arrays and memory segments.\n- *\n- * <p>If the source (destination) segment is actually a view of the destination (source) array,\n- * and if the copy region of the source overlaps with the copy region of the destination,\n- * the copy of the overlapping region is performed as if the data in the overlapping region\n- * were first copied into a temporary segment before being copied to the destination.<\/p>\n- *\n- * <p>\n- * Copy operations defined in this class accept a <em>byte order<\/em> parameter. If the specified byte order is different\n- * from the <em>native<\/em> byte order, a byte swap operation is performed on each array elements\n- * as they are copied from the source (destination) segment to the destination (source) array.\n- * Additional overloads are provided (see {@link #copyFromArray(double[], int, int, MemorySegment, long)}),\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException} to be thrown. Moreover,\n- * attempting to copy to\/from a segment whose {@linkplain MemorySegment#scope() scope} has already been closed,\n- * or from a thread other than the thread owning the scope causes an {@link IllegalStateException} to be thrown.\n- * Finally, attempting to copy to\/from a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n- * {@linkplain MemorySegment#byteSize() size} {@code S}) at addresses that are {@code < B}, or {@code >= B + S},\n- * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n- * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n- *\/\n-public final class MemoryCopy {\n-\n-    private static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    private static final int BYTE_BASE = unsafe.arrayBaseOffset(byte[].class);\n-    private static final int CHAR_BASE = unsafe.arrayBaseOffset(char[].class);\n-    private static final int SHORT_BASE = unsafe.arrayBaseOffset(short[].class);\n-    private static final int INT_BASE = unsafe.arrayBaseOffset(int[].class);\n-    private static final int FLOAT_BASE = unsafe.arrayBaseOffset(float[].class);\n-    private static final int LONG_BASE = unsafe.arrayBaseOffset(long[].class);\n-    private static final int DOUBLE_BASE = unsafe.arrayBaseOffset(double[].class);\n-\n-    private MemoryCopy() { \/* singleton *\/ }\n-\n-    \/\/BYTE\n-    \/**\n-     * Copies a number of byte elements from a source byte array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source byte array.\n-     * @param srcIndexBytes the starting index of the source byte array.\n-     * @param srcCopyLengthBytes the number of byte elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            byte[] srcArray, int srcIndexBytes, int srcCopyLengthBytes,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.checkFromIndexSize(srcIndexBytes, srcCopyLengthBytes, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthBytes, false);\n-        scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                srcArray, BYTE_BASE + srcIndexBytes,\n-                destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthBytes);\n-    }\n-\n-    \/**\n-     * Copies a number of byte elements from a source segment to a destination byte array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination byte array.\n-     * @param dstIndexBytes the starting index of the destination byte array.\n-     * @param dstCopyLengthBytes the number of byte elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            byte[] dstArray, int dstIndexBytes, int dstCopyLengthBytes) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthBytes, true);\n-        Objects.checkFromIndexSize(dstIndexBytes, dstCopyLengthBytes, dstArray.length);\n-        scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                dstArray, BYTE_BASE + dstIndexBytes, dstCopyLengthBytes);\n-    }\n-\n-    \/\/CHAR\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source char array.\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexChars, srcCopyLengthChars, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source char array.\n-     * @param srcIndexChars the starting index of the source char array.\n-     * @param srcCopyLengthChars the number of char elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexChars, srcCopyLengthChars, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthChars << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1, 2);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexChars, dstCopyLengthChars, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndexChars the starting index of the destination char array.\n-     * @param dstCopyLengthChars the number of char elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            char[] dstArray, int dstIndexChars, int dstCopyLengthChars,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthChars << 1, true);\n-        Objects.checkFromIndexSize(dstIndexChars, dstCopyLengthChars, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1, 2);\n-        }\n-    }\n-\n-    \/\/SHORT\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source short array.\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexShorts, srcCopyLengthShorts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source short array.\n-     * @param srcIndexShorts the starting index of the source short array.\n-     * @param srcCopyLengthShorts the number of short elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexShorts, srcCopyLengthShorts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthShorts << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1, 2);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexShorts, dstCopyLengthShorts, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndexShorts the starting index of the destination short array.\n-     * @param dstCopyLengthShorts the number of short elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthShorts << 1, true);\n-        Objects.checkFromIndexSize(dstIndexShorts, dstCopyLengthShorts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1, 2);\n-        }\n-    }\n-\n-    \/\/INT\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source int array.\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexInts, srcCopyLengthInts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source int array.\n-     * @param srcIndexInts the starting index of the source int array.\n-     * @param srcCopyLengthInts the number of int elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexInts, srcCopyLengthInts, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthInts << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndexInts << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2, 4);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexInts, dstCopyLengthInts, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndexInts the starting index of the destination int array.\n-     * @param dstCopyLengthInts the number of int elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            int[] dstArray, int dstIndexInts, int dstCopyLengthInts,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthInts << 2, true);\n-        Objects.checkFromIndexSize(dstIndexInts, dstCopyLengthInts, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2, 4);\n-        }\n-    }\n-\n-    \/\/FLOAT\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source float array.\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexFloats, srcCopyLengthFloats, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source float array.\n-     * @param srcIndexFloats the starting index of the source float array.\n-     * @param srcCopyLengthFloats the number of float elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexFloats, srcCopyLengthFloats, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthFloats << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2, 4);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexFloats, dstCopyLengthFloats, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndexFloats the starting index of the destination float array.\n-     * @param dstCopyLengthFloats the number of float elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a float swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthFloats << 2, true);\n-        Objects.checkFromIndexSize(dstIndexFloats, dstCopyLengthFloats, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2, 4);\n-        }\n-    }\n-\n-    \/\/LONG\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source long array.\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexLongs, srcCopyLengthLongs, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source long array.\n-     * @param srcIndexLongs the starting index of the source long array.\n-     * @param srcCopyLengthLongs the number of long elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexLongs, srcCopyLengthLongs, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthLongs << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3, 8);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexLongs, dstCopyLengthLongs, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndexLongs the starting index of the destination long array.\n-     * @param dstCopyLengthLongs the number of long elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthLongs << 3, true);\n-        Objects.checkFromIndexSize(dstIndexLongs, dstCopyLengthLongs, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3, 8);\n-        }\n-    }\n-\n-    \/\/DOUBLE\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source double array.\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes) {\n-        copyFromArray(srcArray, srcIndexDoubles, srcCopyLengthDoubles, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source double array.\n-     * @param srcIndexDoubles the starting index of the source double array.\n-     * @param srcCopyLengthDoubles the number of double elements to be copied.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyFromArray(\n-            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n-            MemorySegment dstSegment, long dstOffsetBytes,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndexDoubles, srcCopyLengthDoubles, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthDoubles << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3, 8);\n-        }\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles) {\n-        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexDoubles, dstCopyLengthDoubles, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndexDoubles the starting index of the destination double array.\n-     * @param dstCopyLengthDoubles the number of double elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copyToArray(\n-            MemorySegment srcSegment, long srcOffsetBytes,\n-            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles,\n-            ByteOrder order) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthDoubles << 3, true);\n-        Objects.checkFromIndexSize(dstIndexDoubles, dstCopyLengthDoubles, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n-                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3, 8);\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":0,"deletions":713,"binary":false,"changes":713,"status":"deleted"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -41,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -72,1 +72,1 @@\n- * using one of the provided factory methods (e.g. {@link MemorySegment#ofArray(int[])}). Memory segments obtained\n+ * using one of the provided factory methods (e.g. {@link MemorySegment#ofArray(Object)}). Memory segments obtained\n@@ -367,21 +367,0 @@\n-     *\n-     * @param src the source segment.\n-     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    void copyFrom(MemorySegment src);\n-\n-    \/**\n-     * Performs an element-wise bulk copy from given source segment to this segment. More specifically, the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment\n-     * at offset {@code 0} through {@code src.byteSize() - 1}.\n-     * <p>\n-     * The copy occurs in an element-wise fashion: the source bytes are interpreted as a sequence of elements\n-     * whose layout is {@code srcElementLayout}, whereas the bytes in this segment are interpreted as a sequence of\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S} and\n-     * alignment {@code A}, and the size of the source segment must be a multiple of {@code S} for the copy operation\n-     * to be correctly specified. If the byte order of the two element layouts differ, the bytes corresponding to each\n-     * element to be copied are swapped accordingly during the copy operation.\n@@ -389,14 +368,4 @@\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     *\n-     * @implSpec\n-     * If {@code srcElementLayout.byteSize() == 1}, or if {@code srcElementLayout.order() == dstElementLayout.order()}, calling\n-     * this method must be equivalent to calling {@link #copyFrom(MemorySegment)} with the same source segment.\n-     *\n-     * @param dstElementLayout the element layout associated with this segment.\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(src, 0, this, 0, src.byteSize);\n+     * }<\/pre><\/blockquote>\n@@ -404,1 +373,0 @@\n-     * @param srcElementLayout the element layout associated with the source segment.\n@@ -406,4 +374,0 @@\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment size is not\n-     * a multiple of the source element layout size, if the source segment is incompatible with the alignment constraints\n-     * in the source element layout, or if this segment is incompatible with the alignment constraints\n-     * in the destination element layout.\n@@ -414,0 +378,1 @@\n+     * @return this segment.\n@@ -415,1 +380,4 @@\n-    void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout);\n+    default MemorySegment copyFrom(MemorySegment src) {\n+        MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+        return this;\n+    }\n@@ -563,54 +531,0 @@\n-    \/**\n-     * Copy the contents of this memory segment into a fresh short array.\n-     * @return a fresh short array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link short[]} instance,\n-     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}\n-     *\/\n-    short[] toShortArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh char array.\n-     * @return a fresh char array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link char[]} instance,\n-     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n-     *\/\n-    char[] toCharArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh int array.\n-     * @return a fresh int array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link int[]} instance,\n-     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n-     *\/\n-    int[] toIntArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh float array.\n-     * @return a fresh float array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link float[]} instance,\n-     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n-     *\/\n-    float[] toFloatArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh long array.\n-     * @return a fresh long array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link long[]} instance,\n-     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n-     *\/\n-    long[] toLongArray();\n-\n-    \/**\n-     * Copy the contents of this memory segment into a fresh double array.\n-     * @return a fresh double array copy of this memory segment.\n-     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n-     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link double[]} instance,\n-     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n-     *\/\n-    double[] toDoubleArray();\n-\n@@ -637,45 +551,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(byte[] arr) {\n-        return HeapMemorySegmentImpl.OfByte.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(char[] arr) {\n-        return HeapMemorySegmentImpl.OfChar.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(short[] arr) {\n-        return HeapMemorySegmentImpl.OfShort.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(int[] arr) {\n-        return HeapMemorySegmentImpl.OfInt.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated array.\n@@ -685,0 +555,2 @@\n+     * @throws  IllegalArgumentException if {@code arr} is not an array, or if it is an array but whose type is not supported.\n+     * Supported array types are {@code byte[]}, {@code char[]},{@code short[]},{@code int[]},{@code float[]},{@code long[]} and {@code double[]}.\n@@ -687,24 +559,20 @@\n-    static MemorySegment ofArray(float[] arr) {\n-        return HeapMemorySegmentImpl.OfFloat.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(long[] arr) {\n-        return HeapMemorySegmentImpl.OfLong.fromArray(arr);\n-    }\n-\n-    \/**\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n-     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     *\n-     * @param arr the primitive array backing the array memory segment.\n-     * @return a new array memory segment.\n-     *\/\n-    static MemorySegment ofArray(double[] arr) {\n-        return HeapMemorySegmentImpl.OfDouble.fromArray(arr);\n+    @ForceInline\n+    static MemorySegment ofArray(Object arr) {\n+        Objects.requireNonNull(arr);\n+        if (arr.getClass().equals(byte[].class)) {\n+            return HeapMemorySegmentImpl.OfByte.fromArray((byte[])arr);\n+        } else if (arr.getClass().equals(char[].class)) {\n+            return HeapMemorySegmentImpl.OfChar.fromArray((char[])arr);\n+        } else if (arr.getClass().equals(short[].class)) {\n+            return HeapMemorySegmentImpl.OfShort.fromArray((short[]) arr);\n+        } else if (arr.getClass().equals(int[].class)) {\n+            return HeapMemorySegmentImpl.OfInt.fromArray((int[]) arr);\n+        } else if (arr.getClass().equals(float[].class)) {\n+            return HeapMemorySegmentImpl.OfFloat.fromArray((float[]) arr);\n+        } else if (arr.getClass().equals(long[].class)) {\n+            return HeapMemorySegmentImpl.OfLong.fromArray((long[]) arr);\n+        } else if (arr.getClass().equals(double[].class)) {\n+            return HeapMemorySegmentImpl.OfDouble.fromArray((double[]) arr);\n+        } else {\n+            throw new IllegalArgumentException(\"Bad carrier\");\n+        }\n@@ -862,0 +730,138 @@\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code 0} through {@code bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code 0} through {@code bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, 0, dstSegment, 0, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code bytes > srcSegment.byteSize()} or if\n+     * {@code bytes > dstSegment.byteSize()}, or if {@code bytes <= 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, MemorySegment dstSegment, long bytes) {\n+        copy(srcSegment, 0, dstSegment, 0, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            MemoryAccess.scopedMemoryAccess.copyMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            MemoryAccess.scopedMemoryAccess.copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":172,"deletions":166,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -316,2 +316,4 @@\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(Array.getLength(array), elementLayout));\n-        addr.copyFrom(elementLayout, heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()));\n+        int size = Array.getLength(array);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout));\n+        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n+                addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * common dereference and copy operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n@@ -50,1 +50,1 @@\n-   MemoryAccess.setIntAtIndex(segment, i, 42);\n+   MemoryAccess.setInt(segment, i * 4, 42);\n@@ -57,1 +57,1 @@\n- * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n+ * {@link jdk.incubator.foreign.MemoryAccess#setInt(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n@@ -75,1 +75,1 @@\n-        MemoryAccess.setIntAtIndex(segment, i, 42);\n+        MemoryAccess.setInt(segment, i * 4, 42);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -143,36 +143,0 @@\n-    public void copyFrom(MemorySegment src) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n-                that.base(), that.min(),\n-                base(), min(), size);\n-    }\n-\n-    public void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout) {\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n-        }\n-        if (((AbstractMemorySegmentImpl)src).min() % srcElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (min() % dstElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n-        }\n-        long size = src.byteSize();\n-        if (size % srcElementLayout.byteSize() != 0) {\n-            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n-        }\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            copyFrom(src);\n-        } else {\n-            AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) src;\n-            checkAccess(0, size, false);\n-            that.checkAccess(0, size, true);\n-            SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                    that.base(), that.min(),\n-                    base(), min(), size, srcElementLayout.byteSize());\n-        }\n-    }\n-\n@@ -194,1 +158,1 @@\n-            if (MemoryAccess.getByte(this) != MemoryAccess.getByte(that)) {\n+            if (MemoryAccess.getByte(this, 0) != MemoryAccess.getByte(that, 0)) {\n@@ -209,1 +173,1 @@\n-            if (MemoryAccess.getByteAtOffset(this, i) != MemoryAccess.getByteAtOffset(that, i)) {\n+            if (MemoryAccess.getByte(this, i) != MemoryAccess.getByte(that, i)) {\n@@ -310,38 +274,3 @@\n-        return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final short[] toShortArray() {\n-        return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final char[] toCharArray() {\n-        return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final int[] toIntArray() {\n-        return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final float[] toFloatArray() {\n-        return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final long[] toLongArray() {\n-        return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);\n-    }\n-\n-    @Override\n-    public final double[] toDoubleArray() {\n-        return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);\n-    }\n-\n-    private <Z> Z toArray(Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n-        int size = checkArraySize(arrayClass.getSimpleName(), elemSize);\n-        Z arr = arrayFactory.apply(size);\n-        MemorySegment arrSegment = segmentFactory.apply(arr);\n-        arrSegment.copyFrom(this);\n+        int size = checkArraySize(byte[].class.getSimpleName(), 1);\n+        byte[] arr = new byte[(int)byteSize()];\n+        MemoryAccess.copy(this, 0, arr, 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":5,"deletions":76,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayouts;\n@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +79,1 @@\n-                .map(symbol -> MemoryAccess.getAddressAtIndex(funcs, symbol.ordinal()));\n+                .map(symbol -> MemoryAccess.getAddress(funcs, symbol.ordinal() * MemoryLayouts.ADDRESS.byteSize()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -743,3 +743,2 @@\n-            MemorySegment copy = context.allocator().allocate(size, alignment);\n-            copy.copyFrom(operand.asSlice(0, size));\n-            return copy;\n+            return context.allocator().allocate(size, alignment)\n+                            .copyFrom(operand.asSlice(0, size));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -56,1 +55,0 @@\n-import java.nio.charset.Charset;\n@@ -71,1 +69,0 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n@@ -292,2 +289,1 @@\n-        MemorySegment.ofArray(bytes)\n-                .copyFrom(segment.asSlice(start, len));\n+        MemoryAccess.copy(segment, start, bytes, 0, len);\n@@ -300,1 +296,1 @@\n-            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);\n+            byte curr = MemoryAccess.getByte(segment, start + offset);\n@@ -614,1 +610,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            MemoryAccess.setLong(ptr, 0, (long) o);\n@@ -616,1 +612,1 @@\n-            MemoryAccess.setLong(ptr, (int) o);\n+            MemoryAccess.setLong(ptr, 0, (int) o);\n@@ -618,1 +614,1 @@\n-            MemoryAccess.setLong(ptr, (short) o);\n+            MemoryAccess.setLong(ptr, 0, (short) o);\n@@ -620,1 +616,1 @@\n-            MemoryAccess.setLong(ptr, (char) o);\n+            MemoryAccess.setLong(ptr, 0, (char) o);\n@@ -622,1 +618,1 @@\n-            MemoryAccess.setLong(ptr, (byte) o);\n+            MemoryAccess.setLong(ptr, 0, (byte) o);\n@@ -624,1 +620,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            MemoryAccess.setFloat(ptr, 0, (float) o);\n@@ -626,1 +622,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            MemoryAccess.setDouble(ptr, 0, (double) o);\n@@ -628,1 +624,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            MemoryAccess.setBoolean(ptr, 0, (boolean) o);\n@@ -636,1 +632,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            MemoryAccess.setLong(ptr, 0, (long) o);\n@@ -638,1 +634,1 @@\n-            MemoryAccess.setInt(ptr, (int) o);\n+            MemoryAccess.setInt(ptr, 0, (int) o);\n@@ -640,1 +636,1 @@\n-            MemoryAccess.setShort(ptr, (short) o);\n+            MemoryAccess.setShort(ptr, 0, (short) o);\n@@ -642,1 +638,1 @@\n-            MemoryAccess.setChar(ptr, (char) o);\n+            MemoryAccess.setChar(ptr, 0, (char) o);\n@@ -644,1 +640,1 @@\n-            MemoryAccess.setByte(ptr, (byte) o);\n+            MemoryAccess.setByte(ptr, 0, (byte) o);\n@@ -646,1 +642,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            MemoryAccess.setFloat(ptr, 0, (float) o);\n@@ -648,1 +644,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            MemoryAccess.setDouble(ptr, 0, (double) o);\n@@ -650,1 +646,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            MemoryAccess.setBoolean(ptr, 0, (boolean) o);\n@@ -658,1 +654,1 @@\n-            return MemoryAccess.getLong(ptr);\n+            return MemoryAccess.getLong(ptr, 0);\n@@ -660,1 +656,1 @@\n-            return MemoryAccess.getInt(ptr);\n+            return MemoryAccess.getInt(ptr, 0);\n@@ -662,1 +658,1 @@\n-            return MemoryAccess.getShort(ptr);\n+            return MemoryAccess.getShort(ptr, 0);\n@@ -664,1 +660,1 @@\n-            return MemoryAccess.getChar(ptr);\n+            return MemoryAccess.getChar(ptr, 0);\n@@ -666,1 +662,1 @@\n-            return MemoryAccess.getByte(ptr);\n+            return MemoryAccess.getByte(ptr, 0);\n@@ -668,1 +664,1 @@\n-            return MemoryAccess.getFloat(ptr);\n+            return MemoryAccess.getFloat(ptr, 0);\n@@ -670,1 +666,1 @@\n-            return MemoryAccess.getDouble(ptr);\n+            return MemoryAccess.getDouble(ptr, 0);\n@@ -672,1 +668,1 @@\n-            return MemoryAccess.getBoolean(ptr);\n+            return MemoryAccess.getBoolean(ptr, 0);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -282,2 +282,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));\n+                        MemorySegment.copy(gpRegsArea, currentGPOffset(), value, offset, copy);\n@@ -298,2 +297,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));\n+                        MemorySegment.copy(gpRegsArea, currentFPOffset(), value, offset, copy);\n@@ -459,2 +457,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            gpRegs.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentGPOffset, copy);\n@@ -474,2 +471,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            fpRegs.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentFPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -240,4 +240,3 @@\n-                        case STRUCT_REGISTER, STRUCT_HFA -> {\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n-                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -258,1 +258,0 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n@@ -260,1 +259,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentFPOffset(), value, offset, copy);\n@@ -263,1 +262,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentGPOffset(), value, offset, copy);\n@@ -397,1 +396,0 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n@@ -399,1 +397,1 @@\n-                                reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentFPOffset, copy);\n@@ -402,1 +400,1 @@\n-                                reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentGPOffset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -126,5 +126,2 @@\n-                case STRUCT_REGISTER -> {\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n-                    yield struct;\n-                }\n+                case STRUCT_REGISTER ->\n+                    allocator.allocate(layout).copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -237,4 +234,2 @@\n-                        case STRUCT_REGISTER -> {\n-                            MemorySegment slice = cursor.asSlice(0, VA_SLOT_SIZE_BYTES);\n-                            slice.copyFrom(msArg);\n-                        }\n+                        case STRUCT_REGISTER ->\n+                            cursor.copyFrom(msArg.asSlice(0, VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Optional;\n@@ -107,3 +106,2 @@\n-            int[] sorted = stdLibHelper.qsort(input);\n-            Arrays.sort(input);\n-            assertEquals(sorted, input);\n+            stdLibHelper.qsort(input);\n+            assertEquals(input, ints.stream().mapToInt(i -> i).sorted().toArray());\n@@ -216,1 +214,1 @@\n-                    setByteAtOffset(buf, i, (byte)chars[(int)i]);\n+                    setByte(buf, i, (byte)chars[(int)i]);\n@@ -218,1 +216,1 @@\n-                setByteAtOffset(buf, chars.length, (byte)'\\0');\n+                setByte(buf, chars.length, (byte)'\\0');\n@@ -248,1 +246,1 @@\n-                setLong(time, arg);\n+                setLong(time, 0, arg);\n@@ -265,1 +263,1 @@\n-                return getIntAtOffset(base, 0);\n+                return getInt(base, 0);\n@@ -268,1 +266,1 @@\n-                return getIntAtOffset(base, 4);\n+                return getInt(base, 4);\n@@ -271,1 +269,1 @@\n-                return getIntAtOffset(base, 8);\n+                return getInt(base, 8);\n@@ -274,1 +272,1 @@\n-                return getIntAtOffset(base, 12);\n+                return getInt(base, 12);\n@@ -277,1 +275,1 @@\n-                return getIntAtOffset(base, 16);\n+                return getInt(base, 16);\n@@ -280,1 +278,1 @@\n-                return getIntAtOffset(base, 20);\n+                return getInt(base, 20);\n@@ -283,1 +281,1 @@\n-                return getIntAtOffset(base, 24);\n+                return getInt(base, 24);\n@@ -286,1 +284,1 @@\n-                return getIntAtOffset(base, 28);\n+                return getInt(base, 28);\n@@ -289,1 +287,1 @@\n-                byte b = getByteAtOffset(base, 32);\n+                byte b = getByte(base, 32);\n@@ -294,1 +292,1 @@\n-        int[] qsort(int[] arr) throws Throwable {\n+        void qsort(int[] arr) throws Throwable {\n@@ -297,2 +295,3 @@\n-                SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-                MemorySegment nativeArr = allocator.allocateArray(C_INT, arr);\n+                MemorySegment nativeArr = MemorySegment.allocateNative(arr.length * C_INT.byteSize(), scope);\n+                \/\/copy into native array\n+                MemoryAccess.copy(arr, 0, nativeArr, 0, arr.length);\n@@ -304,3 +303,2 @@\n-\n-                \/\/convert back to Java array\n-                return nativeArr.toIntArray();\n+                \/\/copy back into Java array\n+                MemoryAccess.copy(nativeArr, 0, arr, 0, arr.length);\n@@ -311,2 +309,2 @@\n-            return getIntAtOffset(base, addr1.segmentOffset(base)) -\n-                   getIntAtOffset(base, addr2.segmentOffset(base));\n+            return getInt(base, addr1.segmentOffset(base)) -\n+                   getInt(base, addr2.segmentOffset(base));\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,372 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCopy\n+ *\/\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * These tests exercise the bulk accessors in the MemoryAccess class.\n+ * To make these tests more challenging the segment is a view of the given array,\n+ * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\/\n+public class TestArrayCopy {\n+    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n+    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n+            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n+\n+    private static final int SEG_LENGTH_BYTES = 32;\n+    private static final int SEG_OFFSET_BYTES = 8;\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testSelfCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n+        MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+        assertEquals(truth.mismatch(dstSeg), -1);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemorySegment result = MemorySegment.ofArray(dstArr);\n+        assertEquals(truth.mismatch(result), -1);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testUnalignedCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? (SEG_OFFSET_BYTES - 1) : 0;\n+        MemoryAccess.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : (SEG_OFFSET_BYTES - 1);\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        MemoryAccess.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobLength(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        try {\n+            MemoryAccess.copy(srcArr, 0, dstSeg, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        try {\n+            MemoryAccess.copy(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        try {\n+            MemoryAccess.copy(srcArr, -1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        try {\n+            MemoryAccess.copy(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        try {\n+            MemoryAccess.copy(srcArr, 0, dstSeg, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        try {\n+            MemoryAccess.copy(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeLengths(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        try {\n+            MemoryAccess.copy(srcArr, 0, dstSeg, -1, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        try {\n+            MemoryAccess.copy(srcSeg, -1, dstArr, 0, -SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        try {\n+            MemoryAccess.copy(srcArr, helper.length(srcArr) + 1, dstSeg, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        try {\n+            MemoryAccess.copy(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcArr);\n+        try {\n+            MemoryAccess.copy(srcArr, 0, dstSeg, SEG_LENGTH_BYTES + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = MemorySegment.ofArray(dstArr).asReadOnly();\n+        try {\n+            MemoryAccess.copy(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    \/***** Utilities *****\/\n+\n+    public static MemorySegment srcSegment(int bytesLength) {\n+        byte[] arr = new byte[bytesLength];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte)i;\n+        }\n+        return MemorySegment.ofArray(arr);\n+    }\n+\n+    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?> helper, int indexShifts, CopyMode mode) {\n+        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n+                                                .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n+        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n+                                                 .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n+        byte[] bytes = new byte[(int)srcSeg.byteSize()];\n+        MemoryAccess.copy(srcSeg, 0, bytes, 0, bytes.length);\n+        MemorySegment dstSeg = MemorySegment.ofArray(bytes);\n+        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n+        if (mode.direction) {\n+            if (mode.swap) {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            } else {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            }\n+        } else { \/\/down\n+            if (mode.swap) {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            } else {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            }\n+        }\n+        return dstSeg;\n+    }\n+\n+    enum CopyMode {\n+        UP_NO_SWAP(true, false),\n+        UP_SWAP(true, true),\n+        DOWN_NO_SWAP(false, false),\n+        DOWN_SWAP(false, true);\n+\n+        final boolean direction;\n+        final boolean swap;\n+\n+        CopyMode(boolean direction, boolean swap) {\n+            this.direction = direction;\n+            this.swap = swap;\n+        }\n+    }\n+\n+    static class CopyHelper<X> {\n+\n+        final ValueLayout elementLayout;\n+        final Class<?> carrier;\n+        final IntFunction<X> arrayFactory;\n+\n+        public CopyHelper(ValueLayout elementLayout, Class<X> carrier, IntFunction<X> arrayFactory) {\n+            this.elementLayout = elementLayout;\n+            this.carrier = carrier;\n+            this.arrayFactory = arrayFactory;\n+        }\n+\n+        final int length(X arr) {\n+            return Array.getLength(arr);\n+        }\n+\n+        final X toArray(MemorySegment segment) {\n+            int size = (int)(segment.byteSize() \/ elementLayout.byteSize());\n+            X arr = arrayFactory.apply(size);\n+            MemoryAccess.copy(segment, 0, arr, 0, size, ByteOrder.nativeOrder());\n+            return arr;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"CopyHelper{\" +\n+                    \"elementLayout=\" + elementLayout +\n+                    \", carrier=\" + carrier.getName() +\n+                    '}';\n+        }\n+\n+        static final CopyHelper<byte[]> BYTE = new CopyHelper<>(MemoryLayouts.JAVA_BYTE, byte[].class, byte[]::new);\n+        static final CopyHelper<char[]> CHAR = new CopyHelper<>(MemoryLayouts.JAVA_CHAR, char[].class, char[]::new);\n+        static final CopyHelper<short[]> SHORT = new CopyHelper<>(MemoryLayouts.JAVA_SHORT, short[].class, short[]::new);\n+        static final CopyHelper<int[]> INT = new CopyHelper<>(MemoryLayouts.JAVA_INT, int[].class, int[]::new);\n+        static final CopyHelper<float[]> FLOAT = new CopyHelper<>(MemoryLayouts.JAVA_FLOAT, float[].class, float[]::new);\n+        static final CopyHelper<long[]> LONG = new CopyHelper<>(MemoryLayouts.JAVA_LONG, long[].class, long[]::new);\n+        static final CopyHelper<double[]> DOUBLE = new CopyHelper<>(MemoryLayouts.JAVA_DOUBLE, double[].class, double[]::new);\n+    }\n+\n+    @DataProvider\n+    Object[][] copyModesAndHelpers() {\n+        CopyHelper<?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n+                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n+        List<Object[]> results = new ArrayList<>();\n+        for (CopyHelper<?> helper : helpers) {\n+            for (CopyMode mode : CopyMode.values()) {\n+                results.add(new Object[] { mode, helper, helper.toString() });\n+            }\n+        }\n+        return results.stream().toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":372,"deletions":0,"binary":false,"changes":372,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -43,0 +44,1 @@\n+import java.util.function.IntFunction;\n@@ -92,1 +94,1 @@\n-    static void checkBytes(MemorySegment base, SequenceLayout layout, Function<MemorySegment, Object> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {\n+    static <Z> void checkBytes(MemorySegment base, SequenceLayout layout, IntFunction<Z> arrayFactory, BiFunction<MemorySegment, Long, Object> handleGetter) {\n@@ -94,1 +96,2 @@\n-        Object arr = arrayFactory.apply(base);\n+        Z arr = arrayFactory.apply(nelems);\n+        MemorySegment.ofArray(arr).copyFrom(base);\n@@ -110,4 +113,2 @@\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testTooBigForArray(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        MemoryLayout seq = MemoryLayout.sequenceLayout((Integer.MAX_VALUE * layout.byteSize()) + 1, layout);\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testTooBigForArray() {\n@@ -115,2 +116,2 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize(), ResourceScope.globalScope());\n-        arrayFactory.apply(segment);\n+        MemorySegment segment = MemoryAddress.NULL.asSegment((long)Integer.MAX_VALUE + 1, ResourceScope.globalScope());\n+        segment.toByteArray();\n@@ -119,14 +120,3 @@\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testBadSize(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        if (layout.byteSize() == 1) throw new IllegalStateException(); \/\/make it fail\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), scope);\n-            arrayFactory.apply(segment);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testArrayFromClosedSegment(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testArrayFromClosedSegment() {\n+        MemorySegment segment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n@@ -134,1 +124,1 @@\n-        arrayFactory.apply(segment);\n+        segment.toByteArray();\n@@ -155,1 +145,1 @@\n-                (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, byte[]::new, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n@@ -157,1 +147,1 @@\n-                (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, short[]::new, (addr, pos) -> (short)shortHandle.get(addr, pos));\n@@ -159,1 +149,1 @@\n-                (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, char[]::new, (addr, pos) -> (char)charHandle.get(addr, pos));\n@@ -161,1 +151,1 @@\n-                (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, int[]::new, (addr, pos) -> (int)intHandle.get(addr, pos));\n@@ -163,1 +153,1 @@\n-                (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, float[]::new, (addr, pos) -> (float)floatHandle.get(addr, pos));\n@@ -165,1 +155,1 @@\n-                (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, long[]::new, (addr, pos) -> (long)longHandle.get(addr, pos));\n@@ -167,1 +157,1 @@\n-                (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, double[]::new, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n@@ -179,13 +169,0 @@\n-\n-    @DataProvider(name = \"elemLayouts\")\n-    public Object[][] elemLayouts() {\n-        return new Object[][] {\n-                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegment::toByteArray },\n-                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegment::toShortArray },\n-                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegment::toCharArray },\n-                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegment::toIntArray },\n-                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegment::toFloatArray },\n-                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegment::toLongArray },\n-                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegment::toDoubleArray }\n-        };\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":20,"deletions":43,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -37,0 +36,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -517,1 +517,1 @@\n-                MemoryAccess.setByteAtOffset(segment, offset, offset);\n+                MemoryAccess.setByte(segment, offset, offset);\n@@ -525,1 +525,1 @@\n-                assertEquals(MemoryAccess.getByte(segment), offset);\n+                assertEquals(MemoryAccess.getByte(segment, 0), offset);\n@@ -648,1 +648,1 @@\n-        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n+        MemoryAccess.setInt(s2, 0, 10); \/\/ Dead access!\n@@ -660,1 +660,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                MemoryAccess.setByte(segment, i, (byte) i);\n@@ -680,1 +680,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                MemoryAccess.setByte(segment, i, (byte) i);\n@@ -818,1 +818,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtOffset(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByte(addr, pos, (byte)(long)pos));\n@@ -820,1 +820,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setChar(addr, pos << 1, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n@@ -822,1 +822,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShort(addr, pos << 1, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n@@ -824,1 +824,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setInt(addr, pos << 2, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n@@ -826,1 +826,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloat(addr, pos << 2, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n@@ -828,1 +828,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLong(addr, pos << 3, ByteOrder.BIG_ENDIAN, (long)pos));\n@@ -830,1 +830,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDouble(addr, pos << 3, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n@@ -833,1 +833,1 @@\n-                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtOffset(addr, pos), ByteBuffer::get);\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByte(addr, pos), ByteBuffer::get);\n@@ -835,1 +835,1 @@\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getChar(addr, pos << 1, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n@@ -837,1 +837,1 @@\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShort(addr, pos << 1, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n@@ -839,1 +839,1 @@\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getInt(addr, pos << 2, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n@@ -841,1 +841,1 @@\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloat(addr, pos << 2, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n@@ -843,1 +843,1 @@\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLong(addr, pos << 3, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n@@ -845,1 +845,1 @@\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDouble(addr, pos << 3, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,214 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestCopyFrom\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestCopyFrom {\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.byteSize(), s2.byteSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s2, i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.set(s1, i, i);\n-        }\n-        \/\/perform copy\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            Type.BYTE.check(s2, i, i);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n-        if (s1.type.carrier != s2.type.carrier) return;\n-        int size = Math.min(s1.elementSize(), s2.elementSize());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            s2.set(i, 0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            s1.set(i, i);\n-        }\n-        \/\/perform copy\n-        s2.segment.copyFrom(s2.type.layout, s1.segment.asSlice(0, size * s1.type.size()), s1.type.layout);\n-        \/\/check that copy actually worked\n-        for (int i = 0; i < size; i++) {\n-            s2.check(i, i);\n-        }\n-    }\n-\n-    interface Getter<X> {\n-        X get(MemorySegment segment, long index, ByteOrder order);\n-    }\n-\n-    interface Setter<X> {\n-        void set(MemorySegment segment, long index, ByteOrder order, X val);\n-    }\n-\n-    enum Type {\n-        \/\/ Byte\n-        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByteAtOffset(s, i), (s, i, o, v) -> MemoryAccess.setByteAtOffset(s, i, v), i -> (byte)i),\n-        \/\/LE\n-        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i),\n-        \/\/BE\n-        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i);\n-\n-        final ValueLayout layout;\n-        final Getter<Object> getter;\n-        final Setter<Object> setter;\n-        final IntFunction<Object> valueConverter;\n-        final Class<?> carrier;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        <Z> Type(Class<Z> carrier, ValueLayout layout, Getter<Z> getter, Setter<Z> setter, IntFunction<Z> valueConverter) {\n-            this.carrier = carrier;\n-            this.layout = layout;\n-            this.getter = (Getter<Object>)getter;\n-            this.setter = (Setter<Object>)setter;\n-            this.valueConverter = (IntFunction<Object>)valueConverter;\n-        }\n-\n-        int size() {\n-            return (int)layout.byteSize();\n-        }\n-\n-        void set(SegmentSlice slice, int index, int val) {\n-            setter.set(slice.segment, index * size(), layout.order(), valueConverter.apply(val));\n-        }\n-\n-        void check(SegmentSlice slice, int index, int val) {\n-            assertEquals(getter.get(slice.segment, index * size(), layout.order()), valueConverter.apply(val));\n-        }\n-    }\n-\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n-\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final Type type;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.type = type;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n-\n-        void set(int index, int val) {\n-            type.set(this, index, val);\n-        }\n-\n-        void check(int index, int val) {\n-            type.check(this, index, val);\n-        }\n-\n-        int byteSize() {\n-            return last - first + 1;\n-        }\n-\n-        int elementSize() {\n-            return byteSize() \/ type.size();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n-        }\n-    }\n-\n-    @DataProvider(name = \"slices\")\n-    static Object[][] elementSlices() {\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (Type type : Type.values()) {\n-                for (int index = 0; index < 16; index += type.size()) {\n-                    MemorySegment first = segment.asSlice(0, index);\n-                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n-                    MemorySegment second = segment.asSlice(index);\n-                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n-                }\n-            }\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -36,0 +35,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -51,1 +51,1 @@\n-        MemoryAccess.setByteAtOffset(seg, str.length(), (byte)0);\n+        MemoryAccess.setByte(seg, str.length(), (byte)0);\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -48,0 +47,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -153,1 +153,1 @@\n-                sum += MemoryAccess.getByteAtOffset(segment, i);\n+                sum += MemoryAccess.getByte(segment, i);\n@@ -196,1 +196,1 @@\n-            MemoryAccess.setByteAtOffset(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+            MemoryAccess.setByte(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -34,3 +33,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -40,0 +36,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -108,72 +105,0 @@\n-                {\"byte\", new Accessor<>((byte) 42,\n-                        MemoryAccess::getByte, MemoryAccess::setByte,\n-                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n-                },\n-                {\"bool\", new Accessor<>(false,\n-                        MemoryAccess::getBoolean, MemoryAccess::setBoolean,\n-                        (bb) -> bb.get(0) != 0, (bb, v) -> bb.put(0, v ? (byte)1 : (byte)0))\n-                },\n-                {\"char\", new Accessor<>((char) 42,\n-                        MemoryAccess::getChar, MemoryAccess::setChar,\n-                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n-                },\n-                {\"char\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n-                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n-                },\n-                {\"char\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n-                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n-                },\n-                {\"short\", new Accessor<>((short) 42,\n-                        MemoryAccess::getShort, MemoryAccess::setShort,\n-                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n-                },\n-                {\"short\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n-                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n-                },\n-                {\"short\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n-                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n-                },\n-                {\"int\", new Accessor<>(42,\n-                        MemoryAccess::getInt, MemoryAccess::setInt,\n-                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n-                },\n-                {\"int\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n-                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n-                },\n-                {\"int\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n-                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n-                },\n-                \/\/ float, no offset\n-                {\"float\", new Accessor<>(42f,\n-                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n-                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n-                },\n-                {\"float\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n-                },\n-                {\"float\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n-                },\n-                \/\/ double, no offset\n-                {\"double\", new Accessor<>(42d,\n-                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n-                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n-                },\n-                {\"double\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n-                },\n-                {\"double\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n-                },\n-\n-\n@@ -182,1 +107,1 @@\n-                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getByte(s, 4), (s, x) -> MemoryAccess.setByte(s, 4, x),\n@@ -187,1 +112,1 @@\n-                        s -> MemoryAccess.getBooleanAtOffset(s, 4), (s, x) -> MemoryAccess.setBooleanAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getBoolean(s, 4), (s, x) -> MemoryAccess.setBoolean(s, 4, x),\n@@ -192,1 +117,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getChar(s, 4), (s, x) -> MemoryAccess.setChar(s, 4, x),\n@@ -196,1 +121,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getChar(s, 4, LE), (s, x) -> MemoryAccess.setChar(s, 4, LE, x),\n@@ -200,1 +125,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getChar(s, 4, BE), (s, x) -> MemoryAccess.setChar(s, 4, BE, x),\n@@ -205,1 +130,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getShort(s, 4), (s, x) -> MemoryAccess.setShort(s, 4, x),\n@@ -209,1 +134,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getShort(s, 4, LE), (s, x) -> MemoryAccess.setShort(s, 4, LE, x),\n@@ -213,1 +138,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getShort(s, 4, BE), (s, x) -> MemoryAccess.setShort(s, 4, BE, x),\n@@ -218,1 +143,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getInt(s, 4), (s, x) -> MemoryAccess.setInt(s, 4, x),\n@@ -222,1 +147,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getInt(s, 4, LE), (s, x) -> MemoryAccess.setInt(s, 4, LE, x),\n@@ -226,1 +151,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getInt(s, 4, BE), (s, x) -> MemoryAccess.setInt(s, 4, BE, x),\n@@ -231,1 +156,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getFloat(s, 4), (s, x) -> MemoryAccess.setFloat(s, 4, x),\n@@ -235,1 +160,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getFloat(s, 4, LE), (s, x) -> MemoryAccess.setFloat(s, 4, LE, x),\n@@ -239,1 +164,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getFloat(s, 4, BE), (s, x) -> MemoryAccess.setFloat(s, 4, BE, x),\n@@ -244,1 +169,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getDouble(s, 4), (s, x) -> MemoryAccess.setDouble(s, 4, x),\n@@ -248,1 +173,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.getDouble(s, 4, LE), (s, x) -> MemoryAccess.setDouble(s, 4, LE, x),\n@@ -252,1 +177,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.getDouble(s, 4, BE), (s, x) -> MemoryAccess.setDouble(s, 4, BE, x),\n@@ -255,82 +180,0 @@\n-\n-\n-                \/\/ char, index\n-                {\"char\/index\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n-                },\n-                \/\/ short, index\n-                {\"short\/index\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n-                },\n-                {\"int\/index\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n-                },\n-                {\"float\/index\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n-                },\n-                {\"double\/index\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n-                },\n-\n-                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(0) : nb.getInt(0);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(0, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(0, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n@@ -338,1 +181,1 @@\n-                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n+                        s -> MemoryAccess.getAddress(s, 4), (s, x) -> MemoryAccess.setAddress(s, 4, x),\n@@ -354,17 +197,0 @@\n-                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.asLongBuffer().put(2, v.toRawLongValue());\n-                            } else {\n-                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":19,"deletions":193,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -1,518 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestMemoryCopy\n- *\/\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.incubator.foreign.MemoryCopy;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-\/**\n- * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n- * To make these tests more challenging the segment is a view of the given array,\n- * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n- *\n- * <p>If the source (destination) segment is actually a view of the destination (source) array,\n- * and if the copy region of the source overlaps with the copy region of the destination,\n- * the copy of the overlapping region is performed as if the data in the overlapping region\n- * were first copied into a temporary segment before being copied to the destination.<\/p>\n- *\/\n-public class TestMemoryCopy {\n-    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n-    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n-            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n-\n-    private static final int SEG_LENGTH_BYTES = 32;\n-    private static final int SEG_OFFSET_BYTES = 8;\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testSelfCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n-        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        int srcIndex = mode.direction ? 0 : indexShifts;\n-        int srcCopyLen = helper.length(srcArr) - indexShifts;\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-        assertEquals(truth.mismatch(dstSeg), -1);\n-        \/\/CopyTo\n-        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        int dstIndex = mode.direction ? indexShifts : 0;\n-        int dstCopyLen = helper.length(dstArr) - indexShifts;\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-        MemorySegment result = helper.fromArray(dstArr);\n-        assertEquals(truth.mismatch(result), -1);\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testUnalignedCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        int srcIndex = mode.direction ? 0 : indexShifts;\n-        int srcCopyLen = helper.length(srcArr) - indexShifts;\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        long dstOffsetBytes = mode.direction ? (SEG_OFFSET_BYTES - 1) : 0;\n-        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-        \/\/CopyTo\n-        long srcOffsetBytes = mode.direction ? 0 : (SEG_OFFSET_BYTES - 1);\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        int dstIndex = mode.direction ? indexShifts : 0;\n-        int dstCopyLen = helper.length(dstArr) - indexShifts;\n-        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyOobLength(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyNegativeIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyNegativeOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyOobIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copyModesAndHelpers\")\n-    public void testCopyOobOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n-        int bytesPerElement = (int)helper.elementLayout.byteSize();\n-        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n-        \/\/CopyFrom\n-        Object srcArr = helper.toArray(base);\n-        MemorySegment dstSeg = helper.fromArray(srcArr);\n-        try {\n-            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-        \/\/CopyTo\n-        Object dstArr = helper.toArray(base);\n-        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n-        try {\n-            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n-            fail();\n-        } catch (IndexOutOfBoundsException ex) {\n-            \/\/ok\n-        }\n-    }\n-\n-    \/***** Utilities *****\/\n-\n-    public static MemorySegment srcSegment(int bytesLength) {\n-        byte[] arr = new byte[bytesLength];\n-        for (int i = 0; i < arr.length; i++) {\n-            arr[i] = (byte)i;\n-        }\n-        return MemorySegment.ofArray(arr);\n-    }\n-\n-    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?> helper, int indexShifts, CopyMode mode) {\n-        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n-                                                .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n-        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n-                                                 .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n-        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toByteArray());\n-        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n-        if (mode.direction) {\n-            if (mode.swap) {\n-                for (int i = indexLength - 1; i >= indexShifts; i--) {\n-                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n-                    indexedHandleNO.set(dstSeg, i, v);\n-                }\n-            } else {\n-                for (int i = indexLength - 1; i >= indexShifts; i--) {\n-                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n-                    indexedHandleNO.set(dstSeg, i, v);\n-                }\n-            }\n-        } else { \/\/down\n-            if (mode.swap) {\n-                for (int i = indexShifts; i < indexLength; i++) {\n-                    Object v = indexedHandleNNO.get(dstSeg, i);\n-                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n-                }\n-            } else {\n-                for (int i = indexShifts; i < indexLength; i++) {\n-                    Object v = indexedHandleNO.get(dstSeg, i);\n-                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n-                }\n-            }\n-        }\n-        return dstSeg;\n-    }\n-\n-    enum CopyMode {\n-        UP_NO_SWAP(true, false),\n-        UP_SWAP(true, true),\n-        DOWN_NO_SWAP(false, false),\n-        DOWN_SWAP(false, true);\n-\n-        final boolean direction;\n-        final boolean swap;\n-\n-        CopyMode(boolean direction, boolean swap) {\n-            this.direction = direction;\n-            this.swap = swap;\n-        }\n-    }\n-\n-    abstract static class CopyHelper<X> {\n-\n-        final ValueLayout elementLayout;\n-        final Class<?> carrier;\n-\n-        public CopyHelper(ValueLayout elementLayout, Class<X> carrier) {\n-            this.elementLayout = elementLayout;\n-            this.carrier = carrier;\n-        }\n-\n-        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n-        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n-        abstract X toArray(MemorySegment segment);\n-        abstract MemorySegment fromArray(X array);\n-        abstract int length(X arr);\n-\n-        @Override\n-        public String toString() {\n-            return \"CopyHelper{\" +\n-                    \"elementLayout=\" + elementLayout +\n-                    \", carrier=\" + carrier.getName() +\n-                    '}';\n-        }\n-\n-        static final CopyHelper<byte[]> BYTE = new CopyHelper<>(MemoryLayouts.JAVA_BYTE, byte[].class) {\n-            @Override\n-            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n-            }\n-\n-            @Override\n-            byte[] toArray(MemorySegment segment) {\n-                return segment.toByteArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(byte[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(byte[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<char[]> CHAR = new CopyHelper<>(MemoryLayouts.JAVA_CHAR, char[].class) {\n-            @Override\n-            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            char[] toArray(MemorySegment segment) {\n-                return segment.toCharArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(char[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(char[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<short[]> SHORT = new CopyHelper<>(MemoryLayouts.JAVA_SHORT, short[].class) {\n-            @Override\n-            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            short[] toArray(MemorySegment segment) {\n-                return segment.toShortArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(short[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(short[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<int[]> INT = new CopyHelper<>(MemoryLayouts.JAVA_INT, int[].class) {\n-            @Override\n-            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            int[] toArray(MemorySegment segment) {\n-                return segment.toIntArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(int[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(int[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<float[]> FLOAT = new CopyHelper<>(MemoryLayouts.JAVA_FLOAT, float[].class) {\n-            @Override\n-            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            float[] toArray(MemorySegment segment) {\n-                return segment.toFloatArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(float[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(float[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<long[]> LONG = new CopyHelper<>(MemoryLayouts.JAVA_LONG, long[].class) {\n-            @Override\n-            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            long[] toArray(MemorySegment segment) {\n-                return segment.toLongArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(long[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(long[] arr) {\n-                return arr.length;\n-            }\n-        };\n-\n-        static final CopyHelper<double[]> DOUBLE = new CopyHelper<>(MemoryLayouts.JAVA_DOUBLE, double[].class) {\n-            @Override\n-            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n-                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n-            }\n-\n-            @Override\n-            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n-                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n-            }\n-\n-            @Override\n-            double[] toArray(MemorySegment segment) {\n-                return segment.toDoubleArray();\n-            }\n-\n-            @Override\n-            MemorySegment fromArray(double[] array) {\n-                return MemorySegment.ofArray(array);\n-            }\n-\n-            @Override\n-            int length(double[] arr) {\n-                return arr.length;\n-            }\n-        };\n-    }\n-\n-    @DataProvider\n-    Object[][] copyModesAndHelpers() {\n-        CopyHelper<?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n-                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n-        List<Object[]> results = new ArrayList<>();\n-        for (CopyHelper<?> helper : helpers) {\n-            for (CopyMode mode : CopyMode.values()) {\n-                results.add(new Object[] { mode, helper, helper.toString() });\n-            }\n-        }\n-        return results.stream().toArray(Object[][]::new);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":0,"deletions":518,"binary":false,"changes":518,"status":"deleted"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -39,0 +38,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -208,2 +208,2 @@\n-        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);\n-        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);\n+        MemoryAccess.setInt(everything, addr.toRawLongValue(), 42);\n+        assertEquals(MemoryAccess.getInt(everything, addr.toRawLongValue()), 42);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-            MemoryAccess.class,\n@@ -97,1 +96,1 @@\n-            MemoryCopy.class\n+            MemoryAccess.class\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -52,2 +52,2 @@\n-                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);\n-                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n+                int expected = MemoryAccess.getByte(s2.segment, i);\n+                int found = (int) MemoryAccess.getByte(s1.segment, i + offset);\n@@ -69,1 +69,1 @@\n-                MemoryAccess.getByteAtOffset(s2.segment, i);\n+                MemoryAccess.getByte(s2.segment, i);\n@@ -71,1 +71,1 @@\n-                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n+                    MemoryAccess.getByte(s1.segment, i + offset);\n@@ -128,1 +128,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte)i);\n+                MemoryAccess.setByte(segment, i, (byte)i);\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -126,6 +126,0 @@\n-        ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestSegmentCopy\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentCopy {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n+        int size = Math.min(s1.byteSize(), s2.byteSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s2, i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s1, i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, s2.segment, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.check(s2, i, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.type.carrier != s2.type.carrier) return;\n+        int size = Math.min(s1.elementSize(), s2.elementSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            s2.set(i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            s1.set(i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0; i < size; i++) {\n+            s2.check(i, i);\n+        }\n+    }\n+\n+    interface Getter<X> {\n+        X get(MemorySegment segment, long index, ByteOrder order);\n+    }\n+\n+    interface Setter<X> {\n+        void set(MemorySegment segment, long index, ByteOrder order, X val);\n+    }\n+\n+    enum Type {\n+        \/\/ Byte\n+        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByte(s, i), (s, i, o, v) -> MemoryAccess.setByte(s, i, v), i -> (byte)i),\n+        \/\/LE\n+        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShort, MemoryAccess::setShort, i -> (short)i),\n+        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getChar, MemoryAccess::setChar, i -> (char)i),\n+        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getInt, MemoryAccess::setInt, i -> i),\n+        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloat, MemoryAccess::setFloat, i -> (float)i),\n+        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLong, MemoryAccess::setLong, i -> (long)i),\n+        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDouble, MemoryAccess::setDouble, i -> (double)i),\n+        \/\/BE\n+        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShort, MemoryAccess::setShort, i -> (short)i),\n+        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getChar, MemoryAccess::setChar, i -> (char)i),\n+        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getInt, MemoryAccess::setInt, i -> i),\n+        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloat, MemoryAccess::setFloat, i -> (float)i),\n+        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLong, MemoryAccess::setLong, i -> (long)i),\n+        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDouble, MemoryAccess::setDouble, i -> (double)i);\n+\n+        final ValueLayout layout;\n+        final Getter<Object> getter;\n+        final Setter<Object> setter;\n+        final IntFunction<Object> valueConverter;\n+        final Class<?> carrier;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <Z> Type(Class<Z> carrier, ValueLayout layout, Getter<Z> getter, Setter<Z> setter, IntFunction<Z> valueConverter) {\n+            this.carrier = carrier;\n+            this.layout = layout;\n+            this.getter = (Getter<Object>)getter;\n+            this.setter = (Setter<Object>)setter;\n+            this.valueConverter = (IntFunction<Object>)valueConverter;\n+        }\n+\n+        int size() {\n+            return (int)layout.byteSize();\n+        }\n+\n+        void set(SegmentSlice slice, int index, int val) {\n+            setter.set(slice.segment, index * size(), layout.order(), valueConverter.apply(val));\n+        }\n+\n+        void check(SegmentSlice slice, int index, int val) {\n+            assertEquals(getter.get(slice.segment, index * size(), layout.order()), valueConverter.apply(val));\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final Type type;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.type = type;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        void set(int index, int val) {\n+            type.set(this, index, val);\n+        }\n+\n+        void check(int index, int val) {\n+            type.check(this, index, val);\n+        }\n+\n+        int byteSize() {\n+            return last - first + 1;\n+        }\n+\n+        int elementSize() {\n+            return byteSize() \/ type.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] elementSlices() {\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            MemorySegment segment = kind.makeSegment(16);\n+            \/\/compute all slices\n+            for (Type type : Type.values()) {\n+                for (int index = 0; index < 16; index += type.size()) {\n+                    MemorySegment first = segment.asSlice(0, index);\n+                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n+                    MemorySegment second = segment.asSlice(index);\n+                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -110,1 +110,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemoryAccess.getInt(memorySegment, offset);\n@@ -117,1 +117,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemoryAccess.getInt(memorySegment, offset);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.SymbolLookup;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -65,1 +65,1 @@\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n+        assertEquals(MemoryAccess.getInt(segment, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +79,1 @@\n-            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+            MemoryAccess.setByte(segment, i, ((byte)RANDOM.nextInt()));\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -53,0 +53,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -165,1 +166,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.setByte(segment1, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -104,1 +105,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.setByte(segment1, i, (byte) i);\n@@ -122,1 +123,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.setByte(segment1, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -35,0 +34,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -63,2 +63,2 @@\n-        MemoryAccess.setInt(seg, 42);\n-        assertEquals(MemoryAccess.getInt(seg), 42);\n+        MemoryAccess.setInt(seg, 0, 42);\n+        assertEquals(MemoryAccess.getInt(seg, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import static jdk.incubator.foreign.CLinker.C_LONG;\n@@ -64,1 +63,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -226,1 +224,1 @@\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n+                    return MemoryAccess.getInt(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n@@ -244,1 +242,1 @@\n-            MemoryAccess.setInt(msInt, 10);\n+            MemoryAccess.setInt(msInt, 0, 10);\n@@ -493,1 +491,1 @@\n-                    MemoryAccess.setLong(longSum, lSum);\n+                    MemoryAccess.setLong(longSum, 0, lSum);\n@@ -498,1 +496,1 @@\n-                    MemoryAccess.setDouble(doubleSum, dSum);\n+                    MemoryAccess.setDouble(doubleSum, 0, dSum);\n@@ -524,2 +522,2 @@\n-            MemoryAccess.setLong(longSum, 0L);\n-            MemoryAccess.setDouble(doubleSum, 0D);\n+            MemoryAccess.setLong(longSum, 0, 0L);\n+            MemoryAccess.setDouble(doubleSum, 0, 0D);\n@@ -542,2 +540,2 @@\n-            long lSum = MemoryAccess.getLong(longSum);\n-            double dSum = MemoryAccess.getDouble(doubleSum);\n+            long lSum = MemoryAccess.getLong(longSum, 0);\n+            double dSum = MemoryAccess.getDouble(doubleSum, 0);\n@@ -755,1 +753,1 @@\n-                    int x = MemoryAccess.getInt(ms);\n+                    int x = MemoryAccess.getInt(ms, 0);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -40,0 +42,1 @@\n+import java.nio.ByteOrder;\n@@ -125,0 +128,13 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static() {\n+        MemoryAccess.copy(bytes, 0, segment, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_dontinline() {\n+        MemoryAccess.copy(bytes, 0, segment, 0, bytes.length);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+public class LoopOverNewHeap {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+\n+    @Param(value = {\"false\", \"true\"})\n+    boolean polluteProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (polluteProfile) {\n+            for (int i = 0 ; i < 10000 ; i++) {\n+                MemorySegment intB = MemorySegment.ofArray(new byte[ELEM_SIZE]);\n+                MemorySegment intI = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+                MemorySegment intD = MemorySegment.ofArray(new double[ELEM_SIZE]);\n+                MemorySegment intF = MemorySegment.ofArray(new float[ELEM_SIZE]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unsafe_loop() {\n+        int[] elems = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(elems, Unsafe.ARRAY_INT_BASE_OFFSET + (i * CARRIER_SIZE) , i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void segment_loop() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public void segment_loop_dontinline() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void buffer_loop() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            buffer.put(i , i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNewHeap.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -123,1 +123,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -27,0 +26,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +78,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentIn, i, i);\n+            MemoryAccess.setDouble(segmentIn, i * CARRIER_SIZE, i);\n@@ -81,1 +81,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i, i);\n+            MemoryAccess.setDouble(segmentOut, i * CARRIER_SIZE, i);\n@@ -115,3 +115,3 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i,\n-                    MemoryAccess.getDoubleAtIndex(segmentIn, i) +\n-                    MemoryAccess.getDoubleAtIndex(segmentOut, i));\n+            MemoryAccess.setDouble(segmentOut, i * CARRIER_SIZE,\n+                    MemoryAccess.getDouble(segmentIn, i * CARRIER_SIZE) +\n+                    MemoryAccess.getDouble(segmentOut, i * CARRIER_SIZE));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -84,5 +84,5 @@\n-                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                MemoryAccess.setIntAtIndex(intI, i, i);\n-                MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                MemoryAccess.setFloatAtIndex(intF, i, i);\n-                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n+                MemoryAccess.setByte(intB, i, (byte)i);\n+                MemoryAccess.setInt(intI, i * 4, i);\n+                MemoryAccess.setDouble(intD, i * 8, i);\n+                MemoryAccess.setFloat(intF, i * 4, i);\n+                MemoryAccess.setByte(s, i, (byte) i);\n@@ -140,1 +140,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -149,1 +149,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -123,1 +123,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.getInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -82,2 +82,2 @@\n-                MemoryAccess.setIntAtIndex(nativeSegment, i, i);\n-                MemoryAccess.setFloatAtIndex(nativeSegment, i, i);\n+                MemoryAccess.setInt(nativeSegment, i * CARRIER_SIZE, i);\n+                MemoryAccess.setFloat(nativeSegment, i * CARRIER_SIZE, i);\n@@ -85,2 +85,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentBytes, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentBytes, i, i);\n+                MemoryAccess.setInt(heapSegmentBytes, i * CARRIER_SIZE, i);\n+                MemoryAccess.setFloat(heapSegmentBytes, i * CARRIER_SIZE, i);\n@@ -88,2 +88,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentFloats, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentFloats, i, i);\n+                MemoryAccess.setInt(heapSegmentFloats, i * CARRIER_SIZE, i);\n+                MemoryAccess.setFloat(heapSegmentFloats, i * CARRIER_SIZE, i);\n@@ -119,2 +119,2 @@\n-            MemoryAccess.setIntAtOffset(nativeSegment, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(nativeSegment, k);\n+            MemoryAccess.setInt(nativeSegment, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.getInt(nativeSegment, k * CARRIER_SIZE);\n@@ -141,2 +141,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentBytes, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentBytes, k);\n+            MemoryAccess.setInt(heapSegmentBytes, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.getInt(heapSegmentBytes, k * CARRIER_SIZE);\n@@ -163,2 +163,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentFloats, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentFloats, k);\n+            MemoryAccess.setInt(heapSegmentFloats, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.getInt(heapSegmentFloats, k * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -128,1 +128,1 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+        return MemoryAccess.getInt(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -152,1 +152,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        MemoryAccess.setByte(str, len, (byte)0);\n@@ -162,1 +162,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        MemoryAccess.setByte(str, len, (byte)0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -30,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -31,3 +29,0 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorSpecies;\n@@ -47,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -122,1 +116,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = MemoryAccess.getByte(srcSegmentImplicit, i);\n@@ -132,1 +126,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = MemoryAccess.getByte(srcSegmentImplicit, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,4 +104,4 @@\n-            setLongAtIndex(os, i,getLongAtIndex(is, i) + MemoryAccess.getLongAtIndex(os, i));\n-            setLongAtIndex(os, i+1,getLongAtIndex(is, i+1) + getLongAtIndex(os, i+1));\n-            setLongAtIndex(os, i+2,getLongAtIndex(is, i+2) + getLongAtIndex(os, i+2));\n-            setLongAtIndex(os, i+3,getLongAtIndex(is, i+3) + getLongAtIndex(os, i+3));\n+            setLong(os, i * 8, getLong(is, i * 8) + getLong(os, i * 8));\n+            setLong(os, (i+1) * 8, getLong(is, (i+1) * 8) + getLong(os, (i+1) * 8));\n+            setLong(os, (i+2) * 8, getLong(is, (i+2) * 8) + getLong(os, (i+2) * 8));\n+            setLong(os, (i+3) * 8, getLong(is, (i+3)* 8) + getLong(os, (i+3) * 8));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -235,2 +235,2 @@\n-      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n-      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+      var v = MemoryAccess.getByte(srcSegmentImplicit, i);\n+      MemoryAccess.setByte(dstSegmentImplicit, i, v);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}