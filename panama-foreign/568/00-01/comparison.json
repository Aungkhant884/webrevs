{"files":[{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.reflect.Array;\n@@ -46,4 +47,5 @@\n- * Additional overloads are provided (see {@link #copy(double[], int, MemorySegment, long, int)}),\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * <p>\n+ * Generally, the arguments of the copy methods roughly follow the convention for {@link System#arraycopy}.\n+ * The optional trailing argument controls byte order, which by default is the current {@linkplain ByteOrder#nativeOrder() native byte order}.\n+ * <p>\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n@@ -57,1 +59,1 @@\n- * Finally, attempting to copy data into a see {@linkplain MemorySegment#isReadOnly() read-only} always causes an\n+ * Finally, attempting to copy data into a {@linkplain MemorySegment#isReadOnly() read-only} segment always causes an\n@@ -64,8 +66,23 @@\n-\n-    private static final int BYTE_BASE = unsafe.arrayBaseOffset(byte[].class);\n-    private static final int CHAR_BASE = unsafe.arrayBaseOffset(char[].class);\n-    private static final int SHORT_BASE = unsafe.arrayBaseOffset(short[].class);\n-    private static final int INT_BASE = unsafe.arrayBaseOffset(int[].class);\n-    private static final int FLOAT_BASE = unsafe.arrayBaseOffset(float[].class);\n-    private static final int LONG_BASE = unsafe.arrayBaseOffset(long[].class);\n-    private static final int DOUBLE_BASE = unsafe.arrayBaseOffset(double[].class);\n+    \n+    private final static ByteOrder NON_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n+            ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n+\n+    private final static ValueLayout JAVA_SHORT_NO = MemoryLayouts.JAVA_SHORT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_CHAR_NO = MemoryLayouts.JAVA_CHAR.withBitAlignment(8);\n+    private final static ValueLayout JAVA_INT_NO = MemoryLayouts.JAVA_INT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_FLOAT_NO = MemoryLayouts.JAVA_FLOAT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_LONG_NO = MemoryLayouts.JAVA_LONG.withBitAlignment(8);\n+    private final static ValueLayout JAVA_DOUBLE_NO = MemoryLayouts.JAVA_DOUBLE.withBitAlignment(8);\n+\n+    private final static ValueLayout JAVA_SHORT_NNO = JAVA_SHORT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_CHAR_NNO = JAVA_CHAR_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_INT_NNO = JAVA_INT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_FLOAT_NNO = JAVA_FLOAT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_LONG_NNO = JAVA_LONG_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_DOUBLE_NNO = JAVA_DOUBLE_NO.withOrder(NON_NATIVE_ORDER);\n+    \n+    private static ValueLayout pick(ByteOrder order, ValueLayout nativeLayout, ValueLayout nonNativeLayout) {\n+        Objects.requireNonNull(order);\n+        return order == ByteOrder.nativeOrder() ?\n+                nativeLayout : nonNativeLayout;\n+    }\n@@ -88,8 +105,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount, false);\n-        scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                srcArray, BYTE_BASE + srcIndex,\n-                destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount);\n+        copy(srcArray, srcIndex, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, srcArray.length);\n@@ -111,8 +122,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstArray.length);\n-        scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                dstArray, BYTE_BASE + dstIndex, elementCount);\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, dstArray.length);\n@@ -150,15 +155,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndex << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, CHAR_BASE + (srcIndex << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 1, 2);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, srcArray.length);\n@@ -198,15 +190,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount << 1, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, CHAR_BASE + (dstIndex << 1), elementCount << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, CHAR_BASE + (dstIndex << 1), elementCount << 1, 2);\n-        }\n+        copy(srcSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, dstArray.length);\n@@ -245,15 +224,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount << 1, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndex << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, SHORT_BASE + (srcIndex << 1),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 1, 2);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, srcArray.length);\n@@ -294,15 +260,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount << 1, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, SHORT_BASE + (dstIndex << 1), elementCount << 1);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, SHORT_BASE + (dstIndex << 1), elementCount << 1, 2);\n-        }\n+        copy(srcSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, dstArray.length);\n@@ -341,15 +294,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndex << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, INT_BASE + (srcIndex << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 2, 4);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, srcArray.length);\n@@ -390,15 +330,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount << 2, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, INT_BASE + (dstIndex << 2), elementCount << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, INT_BASE + (dstIndex << 2), elementCount << 2, 4);\n-        }\n+        copy(srcSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, dstArray.length);\n@@ -437,15 +364,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount << 2, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndex << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, FLOAT_BASE + (srcIndex << 2),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 2, 4);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, srcArray.length);\n@@ -486,15 +400,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount << 2, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, FLOAT_BASE + (dstIndex << 2), elementCount << 2);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, FLOAT_BASE + (dstIndex << 2), elementCount << 2, 4);\n-        }\n+        copy(srcSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, dstArray.length);\n@@ -533,15 +434,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndex << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, LONG_BASE + (srcIndex << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 3, 8);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, srcArray.length);\n@@ -582,15 +470,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount << 3, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, LONG_BASE + (dstIndex << 3), elementCount << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, LONG_BASE + (dstIndex << 3), elementCount << 3, 8);\n-        }\n+        copy(srcSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, dstArray.length);\n@@ -629,15 +504,2 @@\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(order);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcArray.length);\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount << 3, false);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndex << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, DOUBLE_BASE + (srcIndex << 3),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount << 3, 8);\n-        }\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, srcArray.length);\n@@ -678,15 +540,2 @@\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(order);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount << 3, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstArray.length);\n-        if (order == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, DOUBLE_BASE + (dstIndex << 3), elementCount << 3);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, DOUBLE_BASE + (dstIndex << 3), elementCount << 3, 8);\n-        }\n+        copy(srcSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, dstArray.length);\n@@ -781,0 +630,102 @@\n+\n+    \/**\n+     * Copies a number of elements from a source segment to a destination array, starting at a given segment offset\n+     * (expressed in bytes), and a given array index, and using the given source element layout.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws IllegalArgumentException if {@code dstArray} is not an array, or if the source\n+     * element layout has a size that does not match that of the array elements, or if its alignment constraints\n+     * are incompatible with the source offset.\n+     *\/\n+    @ForceInline\n+    public static void copy(\n+            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount) {\n+        Objects.requireNonNull(dstArray);\n+        int length = Array.getLength(dstArray); \/\/ throws if not an array\n+        copy(srcSegment, srcElementLayout, srcOffset, dstArray, dstIndex, elementCount,\n+                unsafe.arrayBaseOffset(dstArray.getClass()), unsafe.arrayIndexScale(dstArray.getClass()), length);\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount,\n+            int dstBase, int dstWidth, int dstLength) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(srcElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;        \n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, dstLength);\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source offset incompatible with alignment constraints\");\n+        }\n+        if (srcElementLayout.byteSize() != dstWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        if (srcElementLayout.order() == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of elements from a source array to a destination segment, starting at a given array index, and a\n+     * given segment offset (expressed in bytes), using the given destination element layout.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws IllegalArgumentException if {@code srcArray} is not an array, or if the destination\n+     * element layout has a size that does not match that of the array elements, or if its alignment constraints\n+     * are incompatible with the destination offset.\n+     *\/\n+    @ForceInline\n+    public static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount) {\n+        Objects.requireNonNull(srcArray);\n+        int length = Array.getLength(srcArray); \/\/ throws if not an array\n+        copy(srcArray, srcIndex, dstSegment, dstElementLayout, dstOffset, elementCount,\n+                unsafe.arrayBaseOffset(srcArray.getClass()), unsafe.arrayIndexScale(srcArray.getClass()), length);\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount,\n+            int srcBase, int srcWidth, int srcLength) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        Objects.checkFromIndexSize(srcIndex, elementCount, srcLength);\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Destination offset incompatible with alignment constraints\");\n+        }\n+        if (dstElementLayout.byteSize() != srcWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (dstElementLayout.order() == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":160,"deletions":209,"binary":false,"changes":369,"status":"modified"},{"patch":"@@ -109,1 +109,5 @@\n-            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,java.lang.Object,int,int)\/0\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,java.lang.Object,int,int)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(java.lang.Object,int,jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,int)\/2\/0\",\n+            \"jdk.incubator.foreign.MemoryCopy\/copy(java.lang.Object,int,jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.ValueLayout,long,int)\/3\/0\"\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}