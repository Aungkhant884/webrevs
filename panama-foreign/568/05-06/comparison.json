{"files":[{"patch":"@@ -43,1 +43,0 @@\n-import java.nio.charset.Charset;\n@@ -375,1 +374,1 @@\n-        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n+        MemoryAccess.writeByte(addr, bytes.length, (byte)0);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n@@ -36,1 +38,1 @@\n- * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.\n+ * This class defines convenient static methods which can be used to read\/write Java values from\/to memory segments.\n@@ -38,3 +40,8 @@\n- * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long, ByteOrder)}) take a segment, an offset\n- * (expressed in bytes) and a byte order. The final address at which the dereference will occur will be computed by offsetting\n- * the base address by the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n+ * Single values can be read and written using accessors like {@link #readInt(MemorySegment, long)}, and\n+ * {@link #writeInt(MemorySegment, long, int)}. These accessors all accept the following parameters:\n+ * <ul>\n+ *     <li>the memory segment to be read (resp. written)<\/li>\n+ *     <li>the offset, in bytes, at which the read (resp. write) operation should occur<\/li>\n+ *     <li>the offset, in bytes, at which the read (resp. write) operation should occur<\/li>\n+ *     <li>an optional {@linkplain ByteOrder byte order}<\/li>\n+ * <\/ul>\n@@ -42,2 +49,14 @@\n- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment, ByteOrder)}) so that\n- * clients can omit the offset coordinate.\n+ * Multiple values can be read and written in bulk from and to Java arrays, using accessors like {@link #writeInts(int[], int, MemorySegment, long, int)},\n+ * and {@link #readInts(MemorySegment, long, int[], int, int)}. These accessors all accept the following parameters\n+ * (source parameters are laid out before destination parameters, similarly to {@link System#arraycopy(Object, int, Object, int, int)}):\n+ <ul>\n+ *     <li>the memory segment to be read (resp. written)<\/li>\n+ *     <li>the offset, in bytes, at which elements should be read (resp. written) from (resp. to) the segment<\/li>\n+ *     <li>the Java array to be written (resp. read)<\/li>\n+ *     <li>the array index at which elements should be written (resp. read) to (resp. from) the array<\/li>\n+ *     <li>an optional {@linkplain ByteOrder byte order}<\/li>\n+ * <\/ul>\n+ * If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.\n@@ -45,10 +64,1 @@\n- * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long, ByteOrder)}),\n- * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n- * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n- * be dereferenced.\n- * <p>\n- * In cases where native byte order is preferred, overloads are provided (see {@link #getIntAtOffset(MemorySegment, long)})\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n@@ -60,1 +70,2 @@\n- * causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n+ * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n+ * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n@@ -65,2 +76,18 @@\n-        \/\/ just the one\n-    }\n+        \/\/ just the one!\n+    }\n+\n+    static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n+    private final static ByteOrder NON_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n+            ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n+    private final static ValueLayout JAVA_SHORT_NO = MemoryLayouts.JAVA_SHORT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_SHORT_NNO = JAVA_SHORT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_CHAR_NO = MemoryLayouts.JAVA_CHAR.withBitAlignment(8);\n+    private final static ValueLayout JAVA_CHAR_NNO = JAVA_CHAR_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_INT_NO = MemoryLayouts.JAVA_INT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_INT_NNO = JAVA_INT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_FLOAT_NO = MemoryLayouts.JAVA_FLOAT.withBitAlignment(8);\n+    private final static ValueLayout JAVA_FLOAT_NNO = JAVA_FLOAT_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_LONG_NO = MemoryLayouts.JAVA_LONG.withBitAlignment(8);\n+    private final static ValueLayout JAVA_LONG_NNO = JAVA_LONG_NO.withOrder(NON_NATIVE_ORDER);\n+    private final static ValueLayout JAVA_DOUBLE_NO = MemoryLayouts.JAVA_DOUBLE.withBitAlignment(8);\n+    private final static ValueLayout JAVA_DOUBLE_NNO = JAVA_DOUBLE_NO.withOrder(NON_NATIVE_ORDER);\n@@ -82,10 +109,1 @@\n-    private static final VarHandle address_handle;\n-\n-    static {\n-        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n-            case 4 -> int.class;\n-            case 8 -> long.class;\n-            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n-        };\n-        address_handle = MemoryHandles.asAddressVarHandle(unalignedHandle(MemoryLayouts.ADDRESS, carrier));\n-    }\n+    private static final VarHandle address_handle = unalignedHandle(MemoryLayouts.ADDRESS, MemoryAddress.class);\n@@ -93,1 +111,1 @@\n-    private static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n+    static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n@@ -97,4 +115,0 @@\n-    \/\/ Note: all the accessor methods defined below take advantage of argument type profiling\n-    \/\/ (see src\/hotspot\/share\/oops\/methodData.cpp) which greatly enhances performance when the same accessor\n-    \/\/ method is used repeatedly with different segment kinds (e.g. on-heap vs. off-heap).\n-\n@@ -109,1 +123,1 @@\n-    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n+    public static byte readByte(MemorySegment segment, long offset) {\n@@ -122,1 +136,1 @@\n-    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n+    public static void writeByte(MemorySegment segment, long offset, byte value) {\n@@ -135,1 +149,1 @@\n-    public static boolean getBooleanAtOffset(MemorySegment segment, long offset) {\n+    public static boolean readBoolean(MemorySegment segment, long offset) {\n@@ -148,1 +162,1 @@\n-    public static void setBooleanAtOffset(MemorySegment segment, long offset, boolean value) {\n+    public static void writeBoolean(MemorySegment segment, long offset, boolean value) {\n@@ -165,2 +179,2 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset) {\n-        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static char readChar(MemorySegment segment, long offset) {\n+        return readChar(segment, offset, ByteOrder.nativeOrder());\n@@ -181,2 +195,2 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n-        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void writeChar(MemorySegment segment, long offset, char value) {\n+        writeChar(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -197,2 +211,2 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset) {\n-        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static short readShort(MemorySegment segment, long offset) {\n+        return readShort(segment, offset, ByteOrder.nativeOrder());\n@@ -213,2 +227,2 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n-        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void writeShort(MemorySegment segment, long offset, short value) {\n+        writeShort(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -229,2 +243,2 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset) {\n-        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static int readInt(MemorySegment segment, long offset) {\n+        return readInt(segment, offset, ByteOrder.nativeOrder());\n@@ -245,2 +259,2 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n-        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void writeInt(MemorySegment segment, long offset, int value) {\n+        writeInt(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -261,2 +275,2 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n-        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static float readFloat(MemorySegment segment, long offset) {\n+        return readFloat(segment, offset, ByteOrder.nativeOrder());\n@@ -277,2 +291,2 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n-        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void writeFloat(MemorySegment segment, long offset, float value) {\n+        writeFloat(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -293,2 +307,2 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset) {\n-        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static long readLong(MemorySegment segment, long offset) {\n+        return readLong(segment, offset, ByteOrder.nativeOrder());\n@@ -309,2 +323,2 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n-        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void writeLong(MemorySegment segment, long offset, long value) {\n+        writeLong(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -325,2 +339,2 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n-        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n+    public static double readDouble(MemorySegment segment, long offset) {\n+        return readDouble(segment, offset, ByteOrder.nativeOrder());\n@@ -341,2 +355,2 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n-        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n+    public static void writeDouble(MemorySegment segment, long offset, double value) {\n+        writeDouble(segment, offset, ByteOrder.nativeOrder(), value);\n@@ -358,1 +372,1 @@\n-    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n+    public static MemoryAddress readAddress(MemorySegment segment, long offset) {\n@@ -376,1 +390,1 @@\n-    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n+    public static void writeAddress(MemorySegment segment, long offset, Addressable value) {\n@@ -396,1 +410,1 @@\n-    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static char readChar(MemorySegment segment, long offset, ByteOrder order) {\n@@ -416,1 +430,1 @@\n-    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n+    public static void writeChar(MemorySegment segment, long offset, ByteOrder order, char value) {\n@@ -436,1 +450,1 @@\n-    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static short readShort(MemorySegment segment, long offset, ByteOrder order) {\n@@ -456,1 +470,1 @@\n-    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n+    public static void writeShort(MemorySegment segment, long offset, ByteOrder order, short value) {\n@@ -476,1 +490,1 @@\n-    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static int readInt(MemorySegment segment, long offset, ByteOrder order) {\n@@ -496,1 +510,1 @@\n-    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n+    public static void writeInt(MemorySegment segment, long offset, ByteOrder order, int value) {\n@@ -516,1 +530,1 @@\n-    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static float readFloat(MemorySegment segment, long offset, ByteOrder order) {\n@@ -536,1 +550,1 @@\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n+    public static void writeFloat(MemorySegment segment, long offset, ByteOrder order, float value) {\n@@ -556,1 +570,1 @@\n-    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static long readLong(MemorySegment segment, long offset, ByteOrder order) {\n@@ -576,1 +590,1 @@\n-    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n+    public static void writeLong(MemorySegment segment, long offset, ByteOrder order, long value) {\n@@ -596,1 +610,1 @@\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n+    public static double readDouble(MemorySegment segment, long offset, ByteOrder order) {\n@@ -616,1 +630,1 @@\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n+    public static void writeDouble(MemorySegment segment, long offset, ByteOrder order, double value) {\n@@ -622,135 +636,4 @@\n-    \/**\n-     * Reads a byte from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    byte value = getByteAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByte(MemorySegment segment) {\n-        return getByteAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByte(MemorySegment segment, byte value) {\n-        setByteAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a boolean from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    boolean value = getBooleanAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a boolean value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static boolean getBoolean(MemorySegment segment) {\n-        return getBooleanAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a boolean at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setBooleanAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the boolean value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setBoolean(MemorySegment segment, boolean value) {\n-        setBooleanAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment) {\n-        return getCharAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, char value) {\n-        setCharAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment) {\n-        return getShortAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, short value) {\n-        setShortAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment) {\n-        return getIntAtOffset(segment, 0L);\n+    private static ValueLayout pick(ByteOrder order, ValueLayout nativeLayout, ValueLayout nonNativeLayout) {\n+        Objects.requireNonNull(order);\n+        return order == ByteOrder.nativeOrder() ?\n+                nativeLayout : nonNativeLayout;\n@@ -760,8 +643,7 @@\n-     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the int value to be written.\n+     * Copies a number of byte elements from a source byte array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source byte array.\n+     * @param srcIndex the starting index of the source byte array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of byte elements to be copied.\n@@ -770,2 +652,4 @@\n-    public static void setInt(MemorySegment segment, int value) {\n-        setIntAtOffset(segment, 0L, value);\n+    public static void writeBytes(\n+            byte[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        copy(srcArray, srcIndex, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, srcArray.length);\n@@ -775,8 +659,7 @@\n-     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a float value read from {@code segment}.\n+     * Copies a number of byte elements from a source segment to a destination byte array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination byte array.\n+     * @param dstIndex the starting index of the destination byte array.\n+     * @param elementCount the number of byte elements to be copied.\n@@ -785,2 +668,5 @@\n-    public static float getFloat(MemorySegment segment) {\n-        return getFloatAtOffset(segment, 0L);\n+    public static void readBytes(\n+            MemorySegment srcSegment, long srcOffset,\n+            byte[] dstArray, int dstIndex, int elementCount) {\n+        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, dstArray.length);\n@@ -790,8 +676,7 @@\n-     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the float value to be written.\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source char array.\n+     * @param srcIndex the starting index of the source char array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of char elements to be copied.\n@@ -800,2 +685,3 @@\n-    public static void setFloat(MemorySegment segment, float value) {\n-        setFloatAtOffset(segment, 0L, value);\n+    public static void writeChars(\n+            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        writeChars(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -805,8 +691,8 @@\n-     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a long value read from {@code segment}.\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source char array.\n+     * @param srcIndex the starting index of the source char array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of char elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -815,2 +701,4 @@\n-    public static long getLong(MemorySegment segment) {\n-        return getLongAtOffset(segment, 0L);\n+    public static void writeChars(\n+            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount, ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, srcArray.length);\n@@ -820,8 +708,7 @@\n-     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the long value to be written.\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndex the starting index of the destination char array.\n+     * @param elementCount the number of char elements to be copied.\n@@ -830,2 +717,4 @@\n-    public static void setLong(MemorySegment segment, long value) {\n-        setLongAtOffset(segment, 0L, value);\n+    public static void readChars(\n+            MemorySegment srcSegment, long srcOffset,\n+            char[] dstArray, int dstIndex, int elementCount) {\n+        readChars(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -835,8 +724,8 @@\n-     * Reads a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a double value read from {@code segment}.\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndex the starting index of the destination char array.\n+     * @param elementCount the number of char elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -845,2 +734,6 @@\n-    public static double getDouble(MemorySegment segment) {\n-        return getDoubleAtOffset(segment, 0L);\n+    public static void readChars(\n+            MemorySegment srcSegment, long srcOffset,\n+            char[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, dstArray.length);\n@@ -850,8 +743,7 @@\n-     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the double value to be written.\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source short array.\n+     * @param srcIndex the starting index of the source short array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of short elements to be copied.\n@@ -860,2 +752,3 @@\n-    public static void setDouble(MemorySegment segment, double value) {\n-        setDoubleAtOffset(segment, 0L, value);\n+    public static void writeShorts(\n+            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        writeShorts(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -865,8 +758,8 @@\n-     * Reads a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemoryAddress value = getAddressAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a memory address read from {@code segment}.\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source short array.\n+     * @param srcIndex the starting index of the source short array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of short elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -875,2 +768,5 @@\n-    public static MemoryAddress getAddress(MemorySegment segment) {\n-        return getAddressAtOffset(segment, 0L);\n+    public static void writeShorts(\n+            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, srcArray.length);\n@@ -880,8 +776,7 @@\n-     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndex the starting index of the destination short array.\n+     * @param elementCount the number of short elements to be copied.\n@@ -890,2 +785,4 @@\n-    public static void setAddress(MemorySegment segment, Addressable value) {\n-        setAddressAtOffset(segment, 0L, value);\n+    public static void readShorts(\n+            MemorySegment srcSegment, long srcOffset,\n+            short[] dstArray, int dstIndex, int elementCount) {\n+        readShorts(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -895,9 +792,9 @@\n-     * Reads a char from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndex the starting index of the destination short array.\n+     * @param elementCount the number of short elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -906,2 +803,6 @@\n-    public static char getChar(MemorySegment segment, ByteOrder order) {\n-        return getCharAtOffset(segment, 0L, order);\n+    public static void readShorts(\n+            MemorySegment srcSegment, long srcOffset,\n+            short[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, dstArray.length);\n@@ -911,9 +812,7 @@\n-     * Writes a char at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source int array.\n+     * @param srcIndex the starting index of the source int array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of int elements to be copied.\n@@ -922,2 +821,3 @@\n-    public static void setChar(MemorySegment segment, ByteOrder order, char value) {\n-        setCharAtOffset(segment, 0L, order, value);\n+    public static void writeInts(\n+            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        writeInts(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -927,9 +827,8 @@\n-     * Reads a short from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source int array.\n+     * @param srcIndex the starting index of the source int array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of int elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -938,2 +837,5 @@\n-    public static short getShort(MemorySegment segment, ByteOrder order) {\n-        return getShortAtOffset(segment, 0L, order);\n+    public static void writeInts(\n+            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, srcArray.length);\n@@ -943,9 +845,7 @@\n-     * Writes a short at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndex the starting index of the destination int array.\n+     * @param elementCount the number of int elements to be copied.\n@@ -954,2 +854,4 @@\n-    public static void setShort(MemorySegment segment, ByteOrder order, short value) {\n-        setShortAtOffset(segment, 0L, order, value);\n+    public static void readInts(\n+            MemorySegment srcSegment, long srcOffset,\n+            int[] dstArray, int dstIndex, int elementCount) {\n+        readInts(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -959,9 +861,9 @@\n-     * Reads an int from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndex the starting index of the destination int array.\n+     * @param elementCount the number of int elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -970,2 +872,6 @@\n-    public static int getInt(MemorySegment segment, ByteOrder order) {\n-        return getIntAtOffset(segment, 0L, order);\n+    public static void readInts(\n+            MemorySegment srcSegment, long srcOffset,\n+            int[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, dstArray.length);\n@@ -975,9 +881,7 @@\n-     * Writes an int at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source float array.\n+     * @param srcIndex the starting index of the source float array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of float elements to be copied.\n@@ -986,2 +890,3 @@\n-    public static void setInt(MemorySegment segment, ByteOrder order, int value) {\n-        setIntAtOffset(segment, 0L, order, value);\n+    public static void writeFloats(\n+            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        writeFloats(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -991,9 +896,8 @@\n-     * Reads a float from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source float array.\n+     * @param srcIndex the starting index of the source float array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of float elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -1002,2 +906,5 @@\n-    public static float getFloat(MemorySegment segment, ByteOrder order) {\n-        return getFloatAtOffset(segment, 0L, order);\n+    public static void writeFloats(\n+            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, srcArray.length);\n@@ -1007,9 +914,7 @@\n-     * Writes a float at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndex the starting index of the destination float array.\n+     * @param elementCount the number of float elements to be copied.\n@@ -1018,2 +923,4 @@\n-    public static void setFloat(MemorySegment segment, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, 0L, order, value);\n+    public static void readFloats(\n+            MemorySegment srcSegment, long srcOffset,\n+            float[] dstArray, int dstIndex, int elementCount) {\n+        readFloats(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -1023,9 +930,9 @@\n-     * Reads a long from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndex the starting index of the destination float array.\n+     * @param elementCount the number of float elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a float swap operation will be performed on each array element.\n@@ -1034,2 +941,6 @@\n-    public static long getLong(MemorySegment segment, ByteOrder order) {\n-        return getLongAtOffset(segment, 0L, order);\n+    public static void readFloats(\n+            MemorySegment srcSegment, long srcOffset,\n+            float[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, dstArray.length);\n@@ -1039,9 +950,7 @@\n-     * Writes a long at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source long array.\n+     * @param srcIndex the starting index of the source long array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of long elements to be copied.\n@@ -1050,2 +959,3 @@\n-    public static void setLong(MemorySegment segment, ByteOrder order, long value) {\n-        setLongAtOffset(segment, 0L, order, value);\n+    public static void writeLongs(\n+            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        writeLongs(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n@@ -1055,9 +965,8 @@\n-     * Reads a double from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source long array.\n+     * @param srcIndex the starting index of the source long array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of long elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n@@ -1066,2 +975,5 @@\n-    public static double getDouble(MemorySegment segment, ByteOrder order) {\n-        return getDoubleAtOffset(segment, 0L, order);\n+    public static void writeLongs(\n+            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, srcArray.length);\n@@ -1071,9 +983,7 @@\n-     * Writes a double at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndex the starting index of the destination long array.\n+     * @param elementCount the number of long elements to be copied.\n@@ -1082,2 +992,4 @@\n-    public static void setDouble(MemorySegment segment, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, 0L, order, value);\n+    public static void readLongs(\n+            MemorySegment srcSegment, long srcOffset,\n+            long[] dstArray, int dstIndex, int elementCount) {\n+        readLongs(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n@@ -1087,9 +999,9 @@\n-     * Reads a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndex the starting index of the destination long array.\n+     * @param elementCount the number of long elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -1098,2 +1010,6 @@\n-    public static char getCharAtIndex(MemorySegment segment, long index) {\n-        return getCharAtOffset(segment, scale(segment, index, 2));\n+    public static void readLongs(\n+            MemorySegment srcSegment, long srcOffset,\n+            long[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, dstArray.length);\n@@ -1103,9 +1019,7 @@\n-     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the char value to be written.\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source double array.\n+     * @param srcIndex the starting index of the source double array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of double elements to be copied.\n@@ -1114,403 +1028,113 @@\n-    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index) {\n-        return getShortAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index) {\n-        return getIntAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index) {\n-        return getLongAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getCharAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, ByteOrder order, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getShortAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, ByteOrder order, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getIntAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, ByteOrder order, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getLongAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, ByteOrder order, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    @ForceInline\n-    private static long scale(MemorySegment address, long index, int size) {\n-        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);\n+    public static void writeDoubles(\n+            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n+        writeDoubles(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source double array.\n+     * @param srcIndex the starting index of the source double array.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of double elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     *\/\n+    @ForceInline\n+    public static void writeDoubles(\n+            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n+            ByteOrder order) {\n+        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), dstOffset, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, srcArray.length);\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndex the starting index of the destination double array.\n+     * @param elementCount the number of double elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void readDoubles(\n+            MemorySegment srcSegment, long srcOffset,\n+            double[] dstArray, int dstIndex, int elementCount) {\n+        readDoubles(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndex the starting index of the destination double array.\n+     * @param elementCount the number of double elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void readDoubles(\n+            MemorySegment srcSegment, long srcOffset,\n+            double[] dstArray, int dstIndex, int elementCount,\n+            ByteOrder order) {\n+        copy(srcSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), srcOffset, dstArray, dstIndex, elementCount,\n+                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, dstArray.length);\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount,\n+            int dstBase, int dstWidth, int dstLength) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(srcElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, dstLength);\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source offset incompatible with alignment constraints\");\n+        }\n+        if (srcElementLayout.byteSize() != dstWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        if (srcElementLayout.order() == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount,\n+            int srcBase, int srcWidth, int srcLength) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        Objects.checkFromIndexSize(srcIndex, elementCount, srcLength);\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Destination offset incompatible with alignment constraints\");\n+        }\n+        if (dstElementLayout.byteSize() != srcWidth) {\n+            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n+        }\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (dstElementLayout.order() == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":482,"deletions":858,"binary":false,"changes":1340,"status":"modified"},{"patch":"@@ -1,598 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import java.lang.reflect.Array;\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * This class provides convenient methods for copying data between to and from memory segments.\n- *\n- * <p>If the source (destination) segment is actually a view of the destination (source) array,\n- * and if the copy region of the source overlaps with the copy region of the destination,\n- * the copy of the overlapping region is performed as if the data in the overlapping region\n- * were first copied into a temporary segment before being copied to the destination.<\/p>\n- *\n- * <p>\n- * Copy operations defined in this class accept a <em>byte order<\/em> parameter. If the specified byte order is different\n- * from the <em>native<\/em> byte order, a byte swap operation is performed on each array elements\n- * as they are copied from the source (destination) segment to the destination (source) array.\n- * <p>\n- * Generally, the arguments of the copy methods roughly follow the convention for {@link System#arraycopy}.\n- * The optional trailing argument controls byte order, which by default is the current {@linkplain ByteOrder#nativeOrder() native byte order}.\n- * <p>\n- * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException} to be thrown. Moreover,\n- * attempting to copy to\/from a segment whose {@linkplain MemorySegment#scope() scope} has already been closed,\n- * or from a thread other than the thread owning the scope causes an {@link IllegalStateException} to be thrown.\n- * Moreover, attempting to copy to\/from a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n- * {@linkplain MemorySegment#byteSize() size} {@code S}) at addresses that are {@code < B}, or {@code >= B + S},\n- * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n- * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.\n- * Finally, attempting to copy data into a {@linkplain MemorySegment#isReadOnly() read-only} segment always causes an\n- * {@link UnsupportedOperationException} to be thrown.\n- *\/\n-public final class MemoryCopy {\n-\n-    static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n-    private final static ByteOrder NON_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n-            ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN;\n-\n-    private final static ValueLayout JAVA_SHORT_NO = MemoryLayouts.JAVA_SHORT.withBitAlignment(8);\n-    private final static ValueLayout JAVA_CHAR_NO = MemoryLayouts.JAVA_CHAR.withBitAlignment(8);\n-    private final static ValueLayout JAVA_INT_NO = MemoryLayouts.JAVA_INT.withBitAlignment(8);\n-    private final static ValueLayout JAVA_FLOAT_NO = MemoryLayouts.JAVA_FLOAT.withBitAlignment(8);\n-    private final static ValueLayout JAVA_LONG_NO = MemoryLayouts.JAVA_LONG.withBitAlignment(8);\n-    private final static ValueLayout JAVA_DOUBLE_NO = MemoryLayouts.JAVA_DOUBLE.withBitAlignment(8);\n-\n-    private final static ValueLayout JAVA_SHORT_NNO = JAVA_SHORT_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_CHAR_NNO = JAVA_CHAR_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_INT_NNO = JAVA_INT_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_FLOAT_NNO = JAVA_FLOAT_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_LONG_NNO = JAVA_LONG_NO.withOrder(NON_NATIVE_ORDER);\n-    private final static ValueLayout JAVA_DOUBLE_NNO = JAVA_DOUBLE_NO.withOrder(NON_NATIVE_ORDER);\n-\n-    private static ValueLayout pick(ByteOrder order, ValueLayout nativeLayout, ValueLayout nonNativeLayout) {\n-        Objects.requireNonNull(order);\n-        return order == ByteOrder.nativeOrder() ?\n-                nativeLayout : nonNativeLayout;\n-    }\n-\n-    private MemoryCopy() { \/* singleton *\/ }\n-\n-    \/\/BYTE\n-    \/**\n-     * Copies a number of byte elements from a source byte array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source byte array.\n-     * @param srcIndex the starting index of the source byte array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of byte elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            byte[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, elementCount,\n-                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of byte elements from a source segment to a destination byte array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination byte array.\n-     * @param dstIndex the starting index of the destination byte array.\n-     * @param elementCount the number of byte elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            byte[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/\/CHAR\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source char array.\n-     * @param srcIndex the starting index of the source char array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of char elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source char array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source char array.\n-     * @param srcIndex the starting index of the source char array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of char elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            char[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount, ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndex the starting index of the destination char array.\n-     * @param elementCount the number of char elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            char[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of char elements from a source segment to a destination char array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination char array.\n-     * @param dstIndex the starting index of the destination char array.\n-     * @param elementCount the number of char elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            char[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_CHAR_NO, JAVA_CHAR_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/\/SHORT\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source short array.\n-     * @param srcIndex the starting index of the source short array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of short elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source short array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source short array.\n-     * @param srcIndex the starting index of the source short array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of short elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            short[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndex the starting index of the destination short array.\n-     * @param elementCount the number of short elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            short[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of short elements from a source segment to a destination short array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination short array.\n-     * @param dstIndex the starting index of the destination short array.\n-     * @param elementCount the number of short elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            short[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_SHORT_NO, JAVA_SHORT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/\/INT\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source int array.\n-     * @param srcIndex the starting index of the source int array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of int elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source int array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source int array.\n-     * @param srcIndex the starting index of the source int array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of int elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            int[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndex the starting index of the destination int array.\n-     * @param elementCount the number of int elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            int[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of int elements from a source segment to a destination int array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination int array.\n-     * @param dstIndex the starting index of the destination int array.\n-     * @param elementCount the number of int elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            int[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_INT_NO, JAVA_INT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/\/FLOAT\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source float array.\n-     * @param srcIndex the starting index of the source float array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of float elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source float array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source float array.\n-     * @param srcIndex the starting index of the source float array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of float elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            float[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndex the starting index of the destination float array.\n-     * @param elementCount the number of float elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            float[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of float elements from a source segment to a destination float array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination float array.\n-     * @param dstIndex the starting index of the destination float array.\n-     * @param elementCount the number of float elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a float swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            float[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_FLOAT_NO, JAVA_FLOAT_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/\/LONG\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source long array.\n-     * @param srcIndex the starting index of the source long array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of long elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source long array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source long array.\n-     * @param srcIndex the starting index of the source long array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of long elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            long[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndex the starting index of the destination long array.\n-     * @param elementCount the number of long elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            long[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of long elements from a source segment to a destination long array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination long array.\n-     * @param dstIndex the starting index of the destination long array.\n-     * @param elementCount the number of long elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            long[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_LONG_NO, JAVA_LONG_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    \/\/DOUBLE\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes).\n-     * @param srcArray the source double array.\n-     * @param srcIndex the starting index of the source double array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of double elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount) {\n-        copy(srcArray, srcIndex, dstSegment, dstOffset, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source double array to a destination segment,\n-     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n-     * @param srcArray the source double array.\n-     * @param srcIndex the starting index of the source double array.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of double elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            double[] srcArray, int srcIndex, MemorySegment dstSegment, long dstOffset, int elementCount,\n-            ByteOrder order) {\n-        copy(srcArray, srcIndex, dstSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), dstOffset, elementCount,\n-                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, srcArray.length);\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndex the starting index of the destination double array.\n-     * @param elementCount the number of double elements to be copied.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            double[] dstArray, int dstIndex, int elementCount) {\n-        copy(srcSegment, srcOffset, dstArray, dstIndex, elementCount, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Copies a number of double elements from a source segment to a destination double array,\n-     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstArray the destination double array.\n-     * @param dstIndex the starting index of the destination double array.\n-     * @param elementCount the number of double elements to be copied.\n-     * @param order the byte order to be used for the copy operation. If the specified byte order is\n-     * different from the native order, a byte swap operation will be performed on each array element.\n-     *\/\n-    @ForceInline\n-    public static void copy(\n-            MemorySegment srcSegment, long srcOffset,\n-            double[] dstArray, int dstIndex, int elementCount,\n-            ByteOrder order) {\n-        copy(srcSegment, pick(order, JAVA_DOUBLE_NO, JAVA_DOUBLE_NNO), srcOffset, dstArray, dstIndex, elementCount,\n-                Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE, dstArray.length);\n-    }\n-\n-    @ForceInline\n-    private static void copy(\n-            MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n-            Object dstArray, int dstIndex, int elementCount,\n-            int dstBase, int dstWidth, int dstLength) {\n-        Objects.requireNonNull(srcSegment);\n-        Objects.requireNonNull(dstArray);\n-        Objects.requireNonNull(srcElementLayout);\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, dstLength);\n-        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Source offset incompatible with alignment constraints\");\n-        }\n-        if (srcElementLayout.byteSize() != dstWidth) {\n-            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n-        }\n-        if (srcElementLayout.order() == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n-        }\n-    }\n-\n-    @ForceInline\n-    private static void copy(\n-            Object srcArray, int srcIndex,\n-            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset, int elementCount,\n-            int srcBase, int srcWidth, int srcLength) {\n-        Objects.requireNonNull(srcArray);\n-        Objects.requireNonNull(dstSegment);\n-        Objects.requireNonNull(dstElementLayout);\n-        Objects.checkFromIndexSize(srcIndex, elementCount, srcLength);\n-        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Destination offset incompatible with alignment constraints\");\n-        }\n-        if (dstElementLayout.byteSize() != srcWidth) {\n-            throw new IllegalArgumentException(\"Array element size incompatible with segment element layout size\");\n-        }\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (dstElementLayout.order() == ByteOrder.nativeOrder()) {\n-            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n-        } else {\n-            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":0,"deletions":598,"binary":false,"changes":598,"status":"deleted"},{"patch":"@@ -42,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -371,1 +370,1 @@\n-    MemorySegment.copy(src, this, src.byteSize());\n+    MemorySegment.copyFrom(0, src, 0, src.byteSize());\n@@ -379,0 +378,1 @@\n+     * @return this segment.\n@@ -380,2 +380,79 @@\n-    default void copyFrom(MemorySegment src) {\n-        MemorySegment.copy(src, this, src.byteSize());\n+    default MemorySegment copyFrom(MemorySegment src) {\n+        return copyFrom(0, src, 0, src.byteSize());\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from given source segment to this segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into this\n+     * segment at offsets {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copyFrom(MemoryLayouts.JAVA_BYTE, dstOffset, src, MemoryLayouts.JAVA_BYTE, srcOffset, src.byteSize());\n+     * }<\/pre><\/blockquote>\n+     * @param src the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     * @return this segment.\n+     *\/\n+    default MemorySegment copyFrom(long dstOffset, MemorySegment src, long srcOffset, long bytes) {\n+        return copyFrom(MemoryLayouts.JAVA_BYTE, dstOffset, src, MemoryLayouts.JAVA_BYTE, srcOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from given source segment to this segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into this segment at offsets {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in this segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param src the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     * @return this segment.\n+     *\/\n+    default MemorySegment copyFrom(ValueLayout dstElementLayout, long dstOffset, MemorySegment src, ValueLayout srcElementLayout, long srcOffset, long elementCount) {\n+        MemorySegment.copy(src, srcElementLayout, srcOffset, this, dstElementLayout, dstOffset, elementCount);\n+        return this;\n@@ -830,106 +907,1 @@\n-    \/**\n-     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n-     * {@code 0} through {@code bytes - 1} in the source segment are copied into the destination\n-     * segment at offset {@code 0} through {@code bytes - 1}.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code bytes - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code dstOffset} through {@code bytes - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemorySegment.copy(srcSegment, 0, dstSegment, 0, bytes);\n-     * }<\/pre><\/blockquote>\n-     * @param srcSegment the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n-     * @throws IndexOutOfBoundsException if {@code bytes > srcSegment.byteSize()} or if\n-     * {@code bytes > dstSegment.byteSize()}, or if {@code bytes <= 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    @ForceInline\n-    static void copy(MemorySegment srcSegment, MemorySegment dstSegment, long bytes) {\n-        copy(srcSegment, 0, dstSegment, 0, bytes);\n-    }\n-\n-    \/**\n-     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n-     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n-     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemorySegment.copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n-     * }<\/pre><\/blockquote>\n-     * @param srcSegment the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n-     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n-     * or {@code bytes} are {@code < 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    @ForceInline\n-    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n-        copy(srcSegment, MemoryLayouts.JAVA_BYTE, srcOffset, dstSegment, MemoryLayouts.JAVA_BYTE, dstOffset, bytes);\n-    }\n-\n-    \/**\n-     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n-     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n-     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n-     * <p>\n-     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n-     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n-     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n-     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n-     * are swapped accordingly during the copy operation.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * @param srcSegment the source segment.\n-     * @param srcElementLayout the element layout associated with the source segment.\n-     * @param srcOffset the starting offset, in bytes, of the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param dstElementLayout the element layout associated with the destination segment.\n-     * @param dstOffset the starting offset, in bytes, of the destination segment.\n-     * @param elementCount the number of elements to be copied.\n-     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n-     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n-     * alignment constraints in the destination element layout.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n-     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n-     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n-     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n+    \/\/ primitive copy method\n@@ -937,1 +909,1 @@\n-    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+    private static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n@@ -958,1 +930,1 @@\n-            MemoryCopy.scopedMemoryAccess.copyMemory(srcImpl.scope(), dstImpl.scope(),\n+            MemoryAccess.scopedMemoryAccess.copyMemory(srcImpl.scope(), dstImpl.scope(),\n@@ -962,1 +934,1 @@\n-            MemoryCopy.scopedMemoryAccess.copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+            MemoryAccess.scopedMemoryAccess.copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":85,"deletions":113,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -317,2 +317,2 @@\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout));\n-        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()), 0, addr, elementLayout, 0, size);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout)).copyFrom(elementLayout, 0,\n+                heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * common dereference and copy operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n@@ -50,1 +50,1 @@\n-   MemoryAccess.setIntAtIndex(segment, i, 42);\n+   MemoryAccess.setInt(segment, i * 4, 42);\n@@ -57,1 +57,1 @@\n- * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n+ * {@link jdk.incubator.foreign.MemoryAccess#writeInt(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n@@ -75,1 +75,1 @@\n-        MemoryAccess.setIntAtIndex(segment, i, 42);\n+        MemoryAccess.setInt(segment, i * 4, 42);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-            if (MemoryAccess.getByte(this) != MemoryAccess.getByte(that)) {\n+            if (MemoryAccess.readByte(this, 0) != MemoryAccess.readByte(that, 0)) {\n@@ -173,1 +173,1 @@\n-            if (MemoryAccess.getByteAtOffset(this, i) != MemoryAccess.getByteAtOffset(that, i)) {\n+            if (MemoryAccess.readByte(this, i) != MemoryAccess.readByte(that, i)) {\n@@ -310,2 +310,2 @@\n-        MemorySegment arrSegment = segmentFactory.apply(arr);\n-        MemorySegment.copy(this, arrSegment, byteSize());\n+        segmentFactory.apply(arr)\n+                .copyFrom(0, this, 0, byteSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayouts;\n@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +79,1 @@\n-                .map(symbol -> MemoryAccess.getAddressAtIndex(funcs, symbol.ordinal()));\n+                .map(symbol -> MemoryAccess.readAddress(funcs, symbol.ordinal() * MemoryLayouts.ADDRESS.byteSize()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -743,3 +743,2 @@\n-            MemorySegment copy = context.allocator().allocate(size, alignment);\n-            MemorySegment.copy(operand, copy, size);\n-            return copy;\n+            return context.allocator().allocate(size, alignment)\n+                            .copyFrom(0, operand, 0, size);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,2 +31,0 @@\n-import jdk.incubator.foreign.MemoryCopy;\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -36,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -71,1 +69,0 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n@@ -292,1 +289,1 @@\n-        MemoryCopy.copy(segment, start, bytes, 0, len);\n+        MemoryAccess.readBytes(segment, start, bytes, 0, len);\n@@ -299,1 +296,1 @@\n-            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);\n+            byte curr = MemoryAccess.readByte(segment, start + offset);\n@@ -613,1 +610,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            MemoryAccess.writeLong(ptr, 0, (long) o);\n@@ -615,1 +612,1 @@\n-            MemoryAccess.setLong(ptr, (int) o);\n+            MemoryAccess.writeLong(ptr, 0, (int) o);\n@@ -617,1 +614,1 @@\n-            MemoryAccess.setLong(ptr, (short) o);\n+            MemoryAccess.writeLong(ptr, 0, (short) o);\n@@ -619,1 +616,1 @@\n-            MemoryAccess.setLong(ptr, (char) o);\n+            MemoryAccess.writeLong(ptr, 0, (char) o);\n@@ -621,1 +618,1 @@\n-            MemoryAccess.setLong(ptr, (byte) o);\n+            MemoryAccess.writeLong(ptr, 0, (byte) o);\n@@ -623,1 +620,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            MemoryAccess.writeFloat(ptr, 0, (float) o);\n@@ -625,1 +622,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            MemoryAccess.writeDouble(ptr, 0, (double) o);\n@@ -627,1 +624,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            MemoryAccess.writeBoolean(ptr, 0, (boolean) o);\n@@ -635,1 +632,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            MemoryAccess.writeLong(ptr, 0, (long) o);\n@@ -637,1 +634,1 @@\n-            MemoryAccess.setInt(ptr, (int) o);\n+            MemoryAccess.writeInt(ptr, 0, (int) o);\n@@ -639,1 +636,1 @@\n-            MemoryAccess.setShort(ptr, (short) o);\n+            MemoryAccess.writeShort(ptr, 0, (short) o);\n@@ -641,1 +638,1 @@\n-            MemoryAccess.setChar(ptr, (char) o);\n+            MemoryAccess.writeChar(ptr, 0, (char) o);\n@@ -643,1 +640,1 @@\n-            MemoryAccess.setByte(ptr, (byte) o);\n+            MemoryAccess.writeByte(ptr, 0, (byte) o);\n@@ -645,1 +642,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            MemoryAccess.writeFloat(ptr, 0, (float) o);\n@@ -647,1 +644,1 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            MemoryAccess.writeDouble(ptr, 0, (double) o);\n@@ -649,1 +646,1 @@\n-            MemoryAccess.setBoolean(ptr, (boolean) o);\n+            MemoryAccess.writeBoolean(ptr, 0, (boolean) o);\n@@ -657,1 +654,1 @@\n-            return MemoryAccess.getLong(ptr);\n+            return MemoryAccess.readLong(ptr, 0);\n@@ -659,1 +656,1 @@\n-            return MemoryAccess.getInt(ptr);\n+            return MemoryAccess.readInt(ptr, 0);\n@@ -661,1 +658,1 @@\n-            return MemoryAccess.getShort(ptr);\n+            return MemoryAccess.readShort(ptr, 0);\n@@ -663,1 +660,1 @@\n-            return MemoryAccess.getChar(ptr);\n+            return MemoryAccess.readChar(ptr, 0);\n@@ -665,1 +662,1 @@\n-            return MemoryAccess.getByte(ptr);\n+            return MemoryAccess.readByte(ptr, 0);\n@@ -667,1 +664,1 @@\n-            return MemoryAccess.getFloat(ptr);\n+            return MemoryAccess.readFloat(ptr, 0);\n@@ -669,1 +666,1 @@\n-            return MemoryAccess.getDouble(ptr);\n+            return MemoryAccess.readDouble(ptr, 0);\n@@ -671,1 +668,1 @@\n-            return MemoryAccess.getBoolean(ptr);\n+            return MemoryAccess.readBoolean(ptr, 0);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":27,"deletions":30,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -282,2 +282,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        MemorySegment.copy(gpRegsArea, currentGPOffset(), slice, 0, copy);\n+                        value.copyFrom(offset, gpRegsArea, currentGPOffset(), copy);\n@@ -298,2 +297,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        MemorySegment.copy(fpRegsArea, currentFPOffset(), slice, 0, copy);\n+                        value.copyFrom(offset, gpRegsArea, currentFPOffset(), copy);\n@@ -459,2 +457,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            MemorySegment.copy(slice, 0, gpRegs, currentGPOffset, copy);\n+                            gpRegs.copyFrom(currentGPOffset, valueSegment, offset, copy);\n@@ -474,2 +471,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            MemorySegment.copy(slice, 0, fpRegs, currentFPOffset, copy);\n+                            gpRegs.copyFrom(currentFPOffset, valueSegment, offset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    MemorySegment.copy(segment, struct, layout.byteSize());\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(0, segment, 0, layout.byteSize());\n@@ -240,4 +240,3 @@\n-                        case STRUCT_REGISTER, STRUCT_HFA -> {\n-                            MemorySegment.copy(msArg, cursor, arg.layout.byteSize());\n-                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor.copyFrom(0, msArg, 0, arg.layout.byteSize())\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -258,1 +258,0 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n@@ -260,1 +259,1 @@\n-                            MemorySegment.copy(regSaveArea, currentFPOffset(), slice, 0, copy);\n+                            value.copyFrom(offset, regSaveArea, currentFPOffset(), copy);\n@@ -263,1 +262,1 @@\n-                            MemorySegment.copy(regSaveArea, currentGPOffset(), slice, 0, copy);\n+                            value.copyFrom(offset, regSaveArea, currentGPOffset(), copy);\n@@ -397,1 +396,0 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n@@ -399,1 +397,1 @@\n-                                MemorySegment.copy(slice, 0, reg_save_area, currentFPOffset, copy);\n+                                reg_save_area.copyFrom(currentFPOffset, valueSegment, offset, copy);\n@@ -402,1 +400,1 @@\n-                                MemorySegment.copy(slice, 0, reg_save_area, currentGPOffset, copy);\n+                                reg_save_area.copyFrom(currentGPOffset, valueSegment, offset, copy);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -126,5 +126,3 @@\n-                case STRUCT_REGISTER -> {\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    MemorySegment.copy(segment, struct, layout.byteSize());\n-                    yield struct;\n-                }\n+                case STRUCT_REGISTER ->\n+                    allocator.allocate(layout)\n+                                    .copyFrom(0, segment, 0, layout.byteSize());\n@@ -237,3 +235,2 @@\n-                        case STRUCT_REGISTER -> {\n-                            MemorySegment.copy(msArg, cursor, VA_SLOT_SIZE_BYTES);\n-                        }\n+                        case STRUCT_REGISTER ->\n+                            cursor.copyFrom(0, msArg, 0, VA_SLOT_SIZE_BYTES);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Optional;\n@@ -216,1 +215,1 @@\n-                    setByteAtOffset(buf, i, (byte)chars[(int)i]);\n+                    writeByte(buf, i, (byte)chars[(int)i]);\n@@ -218,1 +217,1 @@\n-                setByteAtOffset(buf, chars.length, (byte)'\\0');\n+                writeByte(buf, chars.length, (byte)'\\0');\n@@ -248,1 +247,1 @@\n-                setLong(time, arg);\n+                writeLong(time, 0, arg);\n@@ -265,1 +264,1 @@\n-                return getIntAtOffset(base, 0);\n+                return readInt(base, 0);\n@@ -268,1 +267,1 @@\n-                return getIntAtOffset(base, 4);\n+                return readInt(base, 4);\n@@ -271,1 +270,1 @@\n-                return getIntAtOffset(base, 8);\n+                return readInt(base, 8);\n@@ -274,1 +273,1 @@\n-                return getIntAtOffset(base, 12);\n+                return readInt(base, 12);\n@@ -277,1 +276,1 @@\n-                return getIntAtOffset(base, 16);\n+                return readInt(base, 16);\n@@ -280,1 +279,1 @@\n-                return getIntAtOffset(base, 20);\n+                return readInt(base, 20);\n@@ -283,1 +282,1 @@\n-                return getIntAtOffset(base, 24);\n+                return readInt(base, 24);\n@@ -286,1 +285,1 @@\n-                return getIntAtOffset(base, 28);\n+                return readInt(base, 28);\n@@ -289,1 +288,1 @@\n-                byte b = getByteAtOffset(base, 32);\n+                byte b = readByte(base, 32);\n@@ -311,2 +310,2 @@\n-            return getIntAtOffset(base, addr1.segmentOffset(base)) -\n-                   getIntAtOffset(base, addr2.segmentOffset(base));\n+            return readInt(base, addr1.segmentOffset(base)) -\n+                   readInt(base, addr2.segmentOffset(base));\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -37,0 +36,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -517,1 +517,1 @@\n-                MemoryAccess.setByteAtOffset(segment, offset, offset);\n+                MemoryAccess.writeByte(segment, offset, offset);\n@@ -525,1 +525,1 @@\n-                assertEquals(MemoryAccess.getByte(segment), offset);\n+                assertEquals(MemoryAccess.readByte(segment, 0), offset);\n@@ -648,1 +648,1 @@\n-        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n+        MemoryAccess.writeInt(s2, 0, 10); \/\/ Dead access!\n@@ -660,1 +660,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                MemoryAccess.writeByte(segment, i, (byte) i);\n@@ -680,1 +680,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                MemoryAccess.writeByte(segment, i, (byte) i);\n@@ -818,1 +818,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtOffset(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.writeByte(addr, pos, (byte)(long)pos));\n@@ -820,1 +820,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.writeChar(addr, pos << 1, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n@@ -822,1 +822,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.writeShort(addr, pos << 1, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n@@ -824,1 +824,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.writeInt(addr, pos << 2, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n@@ -826,1 +826,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.writeFloat(addr, pos << 2, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n@@ -828,1 +828,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.writeLong(addr, pos << 3, ByteOrder.BIG_ENDIAN, (long)pos));\n@@ -830,1 +830,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.writeDouble(addr, pos << 3, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n@@ -833,1 +833,1 @@\n-                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtOffset(addr, pos), ByteBuffer::get);\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.readByte(addr, pos), ByteBuffer::get);\n@@ -835,1 +835,1 @@\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.readChar(addr, pos << 1, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n@@ -837,1 +837,1 @@\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.readShort(addr, pos << 1, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n@@ -839,1 +839,1 @@\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.readInt(addr, pos << 2, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n@@ -841,1 +841,1 @@\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.readFloat(addr, pos << 2, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n@@ -843,1 +843,1 @@\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.readLong(addr, pos << 3, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n@@ -845,1 +845,1 @@\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.readDouble(addr, pos << 3, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryCopy;\n@@ -34,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -59,1 +58,1 @@\n-        MemorySegment.copy(s1.segment, s2.segment, size);\n+        s2.segment.copyFrom(0, s1.segment, 0, size);\n@@ -78,1 +77,1 @@\n-        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n+        s2.segment.copyFrom(s2.type.layout, 0, s1.segment, s1.type.layout, 0, size);\n@@ -95,1 +94,1 @@\n-        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByteAtOffset(s, i), (s, i, o, v) -> MemoryAccess.setByteAtOffset(s, i, v), i -> (byte)i),\n+        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.readByte(s, i), (s, i, o, v) -> MemoryAccess.writeByte(s, i, v), i -> (byte)i),\n@@ -97,6 +96,6 @@\n-        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i),\n+        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::readShort, MemoryAccess::writeShort, i -> (short)i),\n+        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::readChar, MemoryAccess::writeChar, i -> (char)i),\n+        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::readInt, MemoryAccess::writeInt, i -> i),\n+        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::readFloat, MemoryAccess::writeFloat, i -> (float)i),\n+        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::readLong, MemoryAccess::writeLong, i -> (long)i),\n+        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::readDouble, MemoryAccess::writeDouble, i -> (double)i),\n@@ -104,6 +103,6 @@\n-        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n-        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n-        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n-        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n-        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n-        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i);\n+        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::readShort, MemoryAccess::writeShort, i -> (short)i),\n+        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::readChar, MemoryAccess::writeChar, i -> (char)i),\n+        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::readInt, MemoryAccess::writeInt, i -> i),\n+        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::readFloat, MemoryAccess::writeFloat, i -> (float)i),\n+        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::readLong, MemoryAccess::writeLong, i -> (long)i),\n+        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::readDouble, MemoryAccess::writeDouble, i -> (double)i);\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -36,0 +35,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -51,1 +51,1 @@\n-        MemoryAccess.setByteAtOffset(seg, str.length(), (byte)0);\n+        MemoryAccess.writeByte(seg, str.length(), (byte)0);\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -48,0 +47,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -153,1 +153,1 @@\n-                sum += MemoryAccess.getByteAtOffset(segment, i);\n+                sum += MemoryAccess.readByte(segment, i);\n@@ -196,1 +196,1 @@\n-            MemoryAccess.setByteAtOffset(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+            MemoryAccess.writeByte(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -34,3 +33,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -40,0 +36,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -108,72 +105,0 @@\n-                {\"byte\", new Accessor<>((byte) 42,\n-                        MemoryAccess::getByte, MemoryAccess::setByte,\n-                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n-                },\n-                {\"bool\", new Accessor<>(false,\n-                        MemoryAccess::getBoolean, MemoryAccess::setBoolean,\n-                        (bb) -> bb.get(0) != 0, (bb, v) -> bb.put(0, v ? (byte)1 : (byte)0))\n-                },\n-                {\"char\", new Accessor<>((char) 42,\n-                        MemoryAccess::getChar, MemoryAccess::setChar,\n-                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n-                },\n-                {\"char\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n-                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n-                },\n-                {\"char\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n-                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n-                },\n-                {\"short\", new Accessor<>((short) 42,\n-                        MemoryAccess::getShort, MemoryAccess::setShort,\n-                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n-                },\n-                {\"short\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n-                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n-                },\n-                {\"short\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n-                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n-                },\n-                {\"int\", new Accessor<>(42,\n-                        MemoryAccess::getInt, MemoryAccess::setInt,\n-                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n-                },\n-                {\"int\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n-                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n-                },\n-                {\"int\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n-                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n-                },\n-                \/\/ float, no offset\n-                {\"float\", new Accessor<>(42f,\n-                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n-                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n-                },\n-                {\"float\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n-                },\n-                {\"float\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n-                },\n-                \/\/ double, no offset\n-                {\"double\", new Accessor<>(42d,\n-                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n-                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n-                },\n-                {\"double\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n-                },\n-                {\"double\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n-                },\n-\n-\n@@ -182,1 +107,1 @@\n-                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readByte(s, 4), (s, x) -> MemoryAccess.writeByte(s, 4, x),\n@@ -187,1 +112,1 @@\n-                        s -> MemoryAccess.getBooleanAtOffset(s, 4), (s, x) -> MemoryAccess.setBooleanAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readBoolean(s, 4), (s, x) -> MemoryAccess.writeBoolean(s, 4, x),\n@@ -192,1 +117,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readChar(s, 4), (s, x) -> MemoryAccess.writeChar(s, 4, x),\n@@ -196,1 +121,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.readChar(s, 4, LE), (s, x) -> MemoryAccess.writeChar(s, 4, LE, x),\n@@ -200,1 +125,1 @@\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.readChar(s, 4, BE), (s, x) -> MemoryAccess.writeChar(s, 4, BE, x),\n@@ -205,1 +130,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readShort(s, 4), (s, x) -> MemoryAccess.writeShort(s, 4, x),\n@@ -209,1 +134,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.readShort(s, 4, LE), (s, x) -> MemoryAccess.writeShort(s, 4, LE, x),\n@@ -213,1 +138,1 @@\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.readShort(s, 4, BE), (s, x) -> MemoryAccess.writeShort(s, 4, BE, x),\n@@ -218,1 +143,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readInt(s, 4), (s, x) -> MemoryAccess.writeInt(s, 4, x),\n@@ -222,1 +147,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.readInt(s, 4, LE), (s, x) -> MemoryAccess.writeInt(s, 4, LE, x),\n@@ -226,1 +151,1 @@\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.readInt(s, 4, BE), (s, x) -> MemoryAccess.writeInt(s, 4, BE, x),\n@@ -231,1 +156,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readFloat(s, 4), (s, x) -> MemoryAccess.writeFloat(s, 4, x),\n@@ -235,1 +160,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.readFloat(s, 4, LE), (s, x) -> MemoryAccess.writeFloat(s, 4, LE, x),\n@@ -239,1 +164,1 @@\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.readFloat(s, 4, BE), (s, x) -> MemoryAccess.writeFloat(s, 4, BE, x),\n@@ -244,1 +169,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readDouble(s, 4), (s, x) -> MemoryAccess.writeDouble(s, 4, x),\n@@ -248,1 +173,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n+                        s -> MemoryAccess.readDouble(s, 4, LE), (s, x) -> MemoryAccess.writeDouble(s, 4, LE, x),\n@@ -252,1 +177,1 @@\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n+                        s -> MemoryAccess.readDouble(s, 4, BE), (s, x) -> MemoryAccess.writeDouble(s, 4, BE, x),\n@@ -255,82 +180,0 @@\n-\n-\n-                \/\/ char, index\n-                {\"char\/index\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n-                },\n-                \/\/ short, index\n-                {\"short\/index\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n-                },\n-                {\"int\/index\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n-                },\n-                {\"float\/index\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n-                },\n-                {\"double\/index\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n-                },\n-\n-                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(0) : nb.getInt(0);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(0, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(0, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n@@ -338,1 +181,1 @@\n-                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n+                        s -> MemoryAccess.readAddress(s, 4), (s, x) -> MemoryAccess.writeAddress(s, 4, x),\n@@ -354,17 +197,0 @@\n-                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.asLongBuffer().put(2, v.toRawLongValue());\n-                            } else {\n-                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":19,"deletions":193,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.foreign.MemoryCopy;\n@@ -42,0 +41,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -47,1 +47,1 @@\n- * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n+ * These tests exercise the bulk accessors in the MemoryAccess class.\n@@ -343,1 +343,1 @@\n-                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen);\n+                MemoryAccess.writeBytes(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen);\n@@ -348,1 +348,1 @@\n-                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+                MemoryAccess.readBytes(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n@@ -370,1 +370,1 @@\n-                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+                MemoryAccess.writeChars(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -375,1 +375,1 @@\n-                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+                MemoryAccess.readChars(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -397,1 +397,1 @@\n-                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+                MemoryAccess.writeShorts(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -402,1 +402,1 @@\n-                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+                MemoryAccess.readShorts(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -424,1 +424,1 @@\n-                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+                MemoryAccess.writeInts(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -429,1 +429,1 @@\n-                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+                MemoryAccess.readInts(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -451,1 +451,1 @@\n-                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+                MemoryAccess.writeFloats(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -456,1 +456,1 @@\n-                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+                MemoryAccess.readFloats(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -478,1 +478,1 @@\n-                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+                MemoryAccess.writeLongs(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -483,1 +483,1 @@\n-                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+                MemoryAccess.readLongs(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n@@ -505,1 +505,1 @@\n-                MemoryCopy.copy(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n+                MemoryAccess.writeDoubles(srcArr, srcIndex, dstSeg, dstOffsetBytes, srcCopyLen, bo);\n@@ -510,1 +510,1 @@\n-                MemoryCopy.copy(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+                MemoryAccess.readDoubles(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -39,0 +38,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -208,2 +208,2 @@\n-        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);\n-        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);\n+        MemoryAccess.writeInt(everything, addr.toRawLongValue(), 42);\n+        assertEquals(MemoryAccess.readInt(everything, addr.toRawLongValue()), 42);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-            MemoryAccess.class,\n@@ -97,1 +96,1 @@\n-            MemoryCopy.class\n+            MemoryAccess.class\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -52,2 +52,2 @@\n-                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);\n-                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n+                int expected = MemoryAccess.readByte(s2.segment, i);\n+                int found = (int) MemoryAccess.readByte(s1.segment, i + offset);\n@@ -69,1 +69,1 @@\n-                MemoryAccess.getByteAtOffset(s2.segment, i);\n+                MemoryAccess.readByte(s2.segment, i);\n@@ -71,1 +71,1 @@\n-                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n+                    MemoryAccess.readByte(s1.segment, i + offset);\n@@ -128,1 +128,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte)i);\n+                MemoryAccess.writeByte(segment, i, (byte)i);\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -110,1 +110,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemoryAccess.readInt(memorySegment, offset);\n@@ -117,1 +117,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        MemoryAccess.readInt(memorySegment, offset);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.SymbolLookup;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -65,1 +65,1 @@\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n+        assertEquals(MemoryAccess.readInt(segment, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +79,1 @@\n-            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+            MemoryAccess.writeByte(segment, i, ((byte)RANDOM.nextInt()));\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -53,0 +53,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -165,1 +166,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.writeByte(segment1, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -104,1 +105,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.writeByte(segment1, i, (byte) i);\n@@ -122,1 +123,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                MemoryAccess.writeByte(segment1, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -35,0 +34,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -63,2 +63,2 @@\n-        MemoryAccess.setInt(seg, 42);\n-        assertEquals(MemoryAccess.getInt(seg), 42);\n+        MemoryAccess.writeInt(seg, 0, 42);\n+        assertEquals(MemoryAccess.readInt(seg, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import static jdk.incubator.foreign.CLinker.C_LONG;\n@@ -64,1 +63,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -226,1 +224,1 @@\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n+                    return MemoryAccess.readInt(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n@@ -244,1 +242,1 @@\n-            MemoryAccess.setInt(msInt, 10);\n+            MemoryAccess.writeInt(msInt, 0, 10);\n@@ -493,1 +491,1 @@\n-                    MemoryAccess.setLong(longSum, lSum);\n+                    MemoryAccess.writeLong(longSum, 0, lSum);\n@@ -498,1 +496,1 @@\n-                    MemoryAccess.setDouble(doubleSum, dSum);\n+                    MemoryAccess.writeDouble(doubleSum, 0, dSum);\n@@ -524,2 +522,2 @@\n-            MemoryAccess.setLong(longSum, 0L);\n-            MemoryAccess.setDouble(doubleSum, 0D);\n+            MemoryAccess.writeLong(longSum, 0, 0L);\n+            MemoryAccess.writeDouble(doubleSum, 0, 0D);\n@@ -542,2 +540,2 @@\n-            long lSum = MemoryAccess.getLong(longSum);\n-            double dSum = MemoryAccess.getDouble(doubleSum);\n+            long lSum = MemoryAccess.readLong(longSum, 0);\n+            double dSum = MemoryAccess.readDouble(doubleSum, 0);\n@@ -755,1 +753,1 @@\n-                    int x = MemoryAccess.getInt(ms);\n+                    int x = MemoryAccess.readInt(ms, 0);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -123,1 +123,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.readInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -27,0 +26,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -78,1 +78,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentIn, i, i);\n+            MemoryAccess.writeDouble(segmentIn, i * CARRIER_SIZE, i);\n@@ -81,1 +81,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i, i);\n+            MemoryAccess.writeDouble(segmentOut, i * CARRIER_SIZE, i);\n@@ -115,3 +115,3 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i,\n-                    MemoryAccess.getDoubleAtIndex(segmentIn, i) +\n-                    MemoryAccess.getDoubleAtIndex(segmentOut, i));\n+            MemoryAccess.writeDouble(segmentOut, i * CARRIER_SIZE,\n+                    MemoryAccess.readDouble(segmentIn, i * CARRIER_SIZE) +\n+                    MemoryAccess.readDouble(segmentOut, i * CARRIER_SIZE));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -84,5 +84,5 @@\n-                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                MemoryAccess.setIntAtIndex(intI, i, i);\n-                MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                MemoryAccess.setFloatAtIndex(intF, i, i);\n-                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n+                MemoryAccess.writeByte(intB, i, (byte)i);\n+                MemoryAccess.writeInt(intI, i * 4, i);\n+                MemoryAccess.writeDouble(intD, i * 8, i);\n+                MemoryAccess.writeFloat(intF, i * 4, i);\n+                MemoryAccess.writeByte(s, i, (byte) i);\n@@ -140,1 +140,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.readInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -149,1 +149,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.readInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -123,1 +123,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += MemoryAccess.readInt(segment, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -82,2 +82,2 @@\n-                MemoryAccess.setIntAtIndex(nativeSegment, i, i);\n-                MemoryAccess.setFloatAtIndex(nativeSegment, i, i);\n+                MemoryAccess.writeInt(nativeSegment, i * CARRIER_SIZE, i);\n+                MemoryAccess.writeFloat(nativeSegment, i * CARRIER_SIZE, i);\n@@ -85,2 +85,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentBytes, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentBytes, i, i);\n+                MemoryAccess.writeInt(heapSegmentBytes, i * CARRIER_SIZE, i);\n+                MemoryAccess.writeFloat(heapSegmentBytes, i * CARRIER_SIZE, i);\n@@ -88,2 +88,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentFloats, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentFloats, i, i);\n+                MemoryAccess.writeInt(heapSegmentFloats, i * CARRIER_SIZE, i);\n+                MemoryAccess.writeFloat(heapSegmentFloats, i * CARRIER_SIZE, i);\n@@ -119,2 +119,2 @@\n-            MemoryAccess.setIntAtOffset(nativeSegment, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(nativeSegment, k);\n+            MemoryAccess.writeInt(nativeSegment, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.readInt(nativeSegment, k * CARRIER_SIZE);\n@@ -141,2 +141,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentBytes, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentBytes, k);\n+            MemoryAccess.writeInt(heapSegmentBytes, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.readInt(heapSegmentBytes, k * CARRIER_SIZE);\n@@ -163,2 +163,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentFloats, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentFloats, k);\n+            MemoryAccess.writeInt(heapSegmentFloats, k * CARRIER_SIZE, k + 1);\n+            int v = MemoryAccess.readInt(heapSegmentFloats, k * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -128,1 +128,1 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+        return MemoryAccess.readInt(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -152,1 +152,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        MemoryAccess.writeByte(str, len, (byte)0);\n@@ -162,1 +162,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        MemoryAccess.writeByte(str, len, (byte)0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -30,0 +27,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -31,3 +29,0 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorSpecies;\n@@ -47,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -122,1 +116,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = MemoryAccess.readByte(srcSegmentImplicit, i);\n@@ -132,1 +126,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = MemoryAccess.readByte(srcSegmentImplicit, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,4 +104,4 @@\n-            setLongAtIndex(os, i,getLongAtIndex(is, i) + MemoryAccess.getLongAtIndex(os, i));\n-            setLongAtIndex(os, i+1,getLongAtIndex(is, i+1) + getLongAtIndex(os, i+1));\n-            setLongAtIndex(os, i+2,getLongAtIndex(is, i+2) + getLongAtIndex(os, i+2));\n-            setLongAtIndex(os, i+3,getLongAtIndex(is, i+3) + getLongAtIndex(os, i+3));\n+            writeLong(os, i * 8, readLong(is, i * 8) + readLong(os, i * 8));\n+            writeLong(os, (i+1) * 8, readLong(is, (i+1) * 8) + readLong(os, (i+1) * 8));\n+            writeLong(os, (i+2) * 8, readLong(is, (i+2) * 8) + readLong(os, (i+2) * 8));\n+            writeLong(os, (i+3) * 8, readLong(is, (i+3)* 8) + readLong(os, (i+3) * 8));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -235,2 +235,2 @@\n-      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n-      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+      var v = MemoryAccess.readByte(srcSegmentImplicit, i);\n+      MemoryAccess.writeByte(dstSegmentImplicit, i, v);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}