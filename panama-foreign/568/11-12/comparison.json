{"files":[{"patch":"@@ -626,1 +626,1 @@\n-     * Copies a number of double elements from a source segment to a destination array,\n+     * Copies a number of elements from a source segment to a destination array,\n@@ -644,1 +644,1 @@\n-     * Copies a number of double elements from a source segment to a destination array,\n+     * Copies a number of elements from a source segment to a destination array,\n@@ -680,1 +680,1 @@\n-     * Copies a number of double elements from a source array to a destination segment,\n+     * Copies a number of elements from a source array to a destination segment,\n@@ -698,1 +698,1 @@\n-     * Copies a number of double elements from a source array to a destination segment,\n+     * Copies a number of elements from a source array to a destination segment,\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -731,33 +731,0 @@\n-    \/**\n-     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n-     * {@code 0} through {@code bytes - 1} in the source segment are copied into the destination\n-     * segment at offset {@code 0} through {@code bytes - 1}.\n-     * <p>\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code srcOffset} through {@code bytes - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * the destination segment at offset {@code dstOffset} through {@code bytes - 1}.\n-     * <p>\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     * <p>\n-     * Calling this method is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemorySegment.copy(srcSegment, 0, dstSegment, 0, bytes);\n-     * }<\/pre><\/blockquote>\n-     * @param srcSegment the source segment.\n-     * @param dstSegment the destination segment.\n-     * @param bytes the number of bytes to be copied.\n-     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n-     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n-     * owning either scopes.\n-     * @throws IndexOutOfBoundsException if {@code bytes > srcSegment.byteSize()} or if\n-     * {@code bytes > dstSegment.byteSize()}, or if {@code bytes <= 0}.\n-     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n-     *\/\n-    @ForceInline\n-    static void copy(MemorySegment srcSegment, MemorySegment dstSegment, long bytes) {\n-        copy(srcSegment, 0, dstSegment, 0, bytes);\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        MemorySegment.copy(s1.segment, s2.segment, size);\n+        MemorySegment.copy(s1.segment, 0, s2.segment, 0, size);\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}