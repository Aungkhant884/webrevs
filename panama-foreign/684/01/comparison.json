{"files":[{"patch":"@@ -33,1 +33,1 @@\n-#include \"prims\/universalNativeInvoker.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n@@ -38,1 +38,1 @@\n-class NativeInvokerGenerator : public StubCodeGenerator {\n+class DowncallStubGenerator : public StubCodeGenerator {\n@@ -53,1 +53,1 @@\n-  NativeInvokerGenerator(CodeBuffer* buffer,\n+  DowncallStubGenerator(CodeBuffer* buffer,\n@@ -91,7 +91,7 @@\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n+RuntimeStub* DowncallLinker::make_downcall_stub(BasicType* signature,\n+                                                int num_args,\n+                                                BasicType ret_bt,\n+                                                const ABIDescriptor& abi,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers,\n+                                                bool needs_return_buffer) {\n@@ -100,1 +100,1 @@\n-  NativeInvokerGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n@@ -123,1 +123,1 @@\n-void NativeInvokerGenerator::generate() {\n+void DowncallStubGenerator::generate() {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"previous_filename":"src\/hotspot\/cpu\/aarch64\/universalNativeInvoker_aarch64.cpp","status":"renamed"},{"patch":"@@ -32,2 +32,2 @@\n-#include \"prims\/foreign_globals.hpp\"\n-#include \"prims\/foreign_globals.inline.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n+#include \"prims\/foreignGlobals.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","status":"renamed"},{"patch":"","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.hpp","status":"renamed"},{"patch":"@@ -121,1 +121,1 @@\n-    } else if (is_optimized_entry_frame()) {\n+    } else if (is_upcall_stub_frame()) {\n@@ -225,1 +225,1 @@\n-    } else if (sender_blob->is_optimized_entry_blob()) {\n+    } else if (sender_blob->is_upcall_stub()) {\n@@ -375,2 +375,2 @@\n-OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n-  assert(frame.is_optimized_entry_frame(), \"wrong frame\");\n+UpcallStub::FrameData* UpcallStub::frame_data_for_frame(const frame& frame) const {\n+  assert(frame.is_upcall_stub_frame(), \"wrong frame\");\n@@ -378,1 +378,1 @@\n-  return reinterpret_cast<OptimizedEntryBlob::FrameData*>(\n+  return reinterpret_cast<UpcallStub::FrameData*>(\n@@ -382,3 +382,3 @@\n-bool frame::optimized_entry_frame_is_first() const {\n-  assert(is_optimized_entry_frame(), \"must be optimzed entry frame\");\n-  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+bool frame::upcall_stub_frame_is_first() const {\n+  assert(is_upcall_stub_frame(), \"must be optimzed entry frame\");\n+  UpcallStub* blob = _cb->as_upcall_stub();\n@@ -389,1 +389,1 @@\n-frame frame::sender_for_optimized_entry_frame(RegisterMap* map) const {\n+frame frame::sender_for_upcall_stub_frame(RegisterMap* map) const {\n@@ -391,1 +391,1 @@\n-  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+  UpcallStub* blob = _cb->as_upcall_stub();\n@@ -395,1 +395,1 @@\n-  assert(!optimized_entry_frame_is_first(), \"must have a frame anchor to go back to\");\n+  assert(!upcall_stub_frame_is_first(), \"must have a frame anchor to go back to\");\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -400,3 +400,3 @@\n-  if (is_entry_frame())           return sender_for_entry_frame(map);\n-  if (is_optimized_entry_frame()) return sender_for_optimized_entry_frame(map);\n-  if (is_interpreted_frame())     return sender_for_interpreter_frame(map);\n+  if (is_entry_frame())       return sender_for_entry_frame(map);\n+  if (is_upcall_stub_frame()) return sender_for_upcall_stub_frame(map);\n+  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-                    Address(nep_reg, NONZERO(jdk_internal_foreign_abi_NativeEntryPoint::invoker_offset_in_bytes())),\n+                    Address(nep_reg, NONZERO(jdk_internal_foreign_abi_NativeEntryPoint::downcall_stub_address_offset_in_bytes())),\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,337 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2022, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"runtime\/signature.hpp\"\n-#include \"runtime\/signature.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"utilities\/formatBuffer.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"vmreg_aarch64.inline.hpp\"\n-\n-#define __ _masm->\n-\n-\/\/ for callee saved regs, according to the caller's ABI\n-static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n-  int size = 0;\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n-    Register reg = as_Register(i);\n-    if (reg == rfp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n-    if (!abi.is_volatile_reg(reg)) {\n-      size += 8; \/\/ bytes\n-    }\n-  }\n-\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n-    FloatRegister reg = as_FloatRegister(i);\n-    if (!abi.is_volatile_reg(reg)) {\n-      \/\/ Only the lower 64 bits of vector registers need to be preserved.\n-      size += 8; \/\/ bytes\n-    }\n-  }\n-\n-  return size;\n-}\n-\n-static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n-  \/\/ 1. iterate all registers in the architecture\n-  \/\/     - check if they are volatile or not for the given abi\n-  \/\/     - if NOT, we need to save it here\n-\n-  int offset = reg_save_area_offset;\n-\n-  __ block_comment(\"{ preserve_callee_saved_regs \");\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n-    Register reg = as_Register(i);\n-    if (reg == rfp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n-    if (!abi.is_volatile_reg(reg)) {\n-      __ str(reg, Address(sp, offset));\n-      offset += 8;\n-    }\n-  }\n-\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n-    FloatRegister reg = as_FloatRegister(i);\n-    if (!abi.is_volatile_reg(reg)) {\n-      __ strd(reg, Address(sp, offset));\n-      offset += 8;\n-    }\n-  }\n-\n-  __ block_comment(\"} preserve_callee_saved_regs \");\n-}\n-\n-static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n-  \/\/ 1. iterate all registers in the architecture\n-  \/\/     - check if they are volatile or not for the given abi\n-  \/\/     - if NOT, we need to restore it here\n-\n-  int offset = reg_save_area_offset;\n-\n-  __ block_comment(\"{ restore_callee_saved_regs \");\n-  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n-    Register reg = as_Register(i);\n-    if (reg == rfp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n-    if (!abi.is_volatile_reg(reg)) {\n-      __ ldr(reg, Address(sp, offset));\n-      offset += 8;\n-    }\n-  }\n-\n-  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n-    FloatRegister reg = as_FloatRegister(i);\n-    if (!abi.is_volatile_reg(reg)) {\n-      __ ldrd(reg, Address(sp, offset));\n-      offset += 8;\n-    }\n-  }\n-\n-  __ block_comment(\"} restore_callee_saved_regs \");\n-}\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  ResourceMark rm;\n-  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n-  const CallRegs call_regs = ForeignGlobals::parse_call_regs(jconv);\n-  CodeBuffer buffer(\"upcall_stub_linkToNative\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n-\n-  Register shuffle_reg = r19;\n-  JavaCallingConvention out_conv;\n-  NativeCallingConvention in_conv(call_regs._arg_regs);\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n-  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n-  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, upcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n-  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n-  \/\/ make sure it is big enough.\n-  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n-    out_arg_area = frame::arg_reg_save_area_bytes;\n-  }\n-\n-  int reg_save_area_size = compute_reg_save_area_size(abi);\n-  RegSpiller arg_spilller(call_regs._arg_regs);\n-  RegSpiller result_spiller(call_regs._ret_regs);\n-\n-  int shuffle_area_offset    = 0;\n-  int res_save_area_offset   = shuffle_area_offset    + out_arg_area;\n-  int arg_save_area_offset   = res_save_area_offset   + result_spiller.spill_size_bytes();\n-  int reg_save_area_offset   = arg_save_area_offset   + arg_spilller.spill_size_bytes();\n-  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n-  int frame_bottom_offset    = frame_data_offset      + sizeof(OptimizedEntryBlob::FrameData);\n-\n-  int ret_buf_offset = -1;\n-  if (needs_return_buffer) {\n-    ret_buf_offset = frame_bottom_offset;\n-    frame_bottom_offset += ret_buf_size;\n-  }\n-\n-  int frame_size = frame_bottom_offset;\n-  frame_size = align_up(frame_size, StackAlignmentInBytes);\n-\n-  \/\/ The space we have allocated will look like:\n-  \/\/\n-  \/\/\n-  \/\/ FP-> |                     |\n-  \/\/      |---------------------| = frame_bottom_offset = frame_size\n-  \/\/      | (optional)          |\n-  \/\/      | ret_buf             |\n-  \/\/      |---------------------| = ret_buf_offset\n-  \/\/      |                     |\n-  \/\/      | FrameData           |\n-  \/\/      |---------------------| = frame_data_offset\n-  \/\/      |                     |\n-  \/\/      | reg_save_area       |\n-  \/\/      |---------------------| = reg_save_are_offset\n-  \/\/      |                     |\n-  \/\/      | arg_save_area       |\n-  \/\/      |---------------------| = arg_save_are_offset\n-  \/\/      |                     |\n-  \/\/      | res_save_area       |\n-  \/\/      |---------------------| = res_save_are_offset\n-  \/\/      |                     |\n-  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n-  \/\/\n-  \/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  MacroAssembler* _masm = new MacroAssembler(&buffer);\n-  address start = __ pc();\n-  __ enter(); \/\/ set up frame\n-  assert((abi._stack_alignment_bytes % 16) == 0, \"must be 16 byte aligned\");\n-  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n-  __ sub(sp, sp, frame_size);\n-\n-  \/\/ we have to always spill args since we need to do a call to get the thread\n-  \/\/ (and maybe attach it).\n-  arg_spilller.generate_spill(_masm, arg_save_area_offset);\n-  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n-  __ block_comment(\"{ on_entry\");\n-  __ lea(c_rarg0, Address(sp, frame_data_offset));\n-  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, ProgrammableUpcallHandler::on_entry));\n-  __ blr(rscratch1);\n-  __ mov(rthread, r0);\n-  __ reinit_heapbase();\n-  __ block_comment(\"} on_entry\");\n-\n-  __ block_comment(\"{ argument shuffle\");\n-  arg_spilller.generate_fill(_masm, arg_save_area_offset);\n-  if (needs_return_buffer) {\n-    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n-    __ lea(abi._ret_buf_addr_reg, Address(sp, ret_buf_offset));\n-  }\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n-  __ block_comment(\"} argument shuffle\");\n-\n-  __ block_comment(\"{ receiver \");\n-  __ movptr(shuffle_reg, (intptr_t)receiver);\n-  __ resolve_jobject(shuffle_reg, rthread, rscratch2);\n-  __ mov(j_rarg0, shuffle_reg);\n-  __ block_comment(\"} receiver \");\n-\n-  __ mov_metadata(rmethod, entry);\n-  __ str(rmethod, Address(rthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n-\n-  __ ldr(rscratch1, Address(rmethod, Method::from_compiled_offset()));\n-  __ blr(rscratch1);\n-\n-    \/\/ return value shuffle\n-  if (!needs_return_buffer) {\n-#ifdef ASSERT\n-    if (call_regs._ret_regs.length() == 1) { \/\/ 0 or 1\n-      VMReg j_expected_result_reg;\n-      switch (ret_type) {\n-        case T_BOOLEAN:\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_CHAR:\n-        case T_INT:\n-        case T_LONG:\n-        j_expected_result_reg = r0->as_VMReg();\n-        break;\n-        case T_FLOAT:\n-        case T_DOUBLE:\n-          j_expected_result_reg = v0->as_VMReg();\n-          break;\n-        default:\n-          fatal(\"unexpected return type: %s\", type2name(ret_type));\n-      }\n-      \/\/ No need to move for now, since CallArranger can pick a return type\n-      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n-      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n-      \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n-    }\n-#endif\n-  } else {\n-    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n-    __ lea(rscratch1, Address(sp, ret_buf_offset));\n-    int offset = 0;\n-    for (int i = 0; i < call_regs._ret_regs.length(); i++) {\n-      VMReg reg = call_regs._ret_regs.at(i);\n-      if (reg->is_Register()) {\n-        __ ldr(reg->as_Register(), Address(rscratch1, offset));\n-        offset += 8;\n-      } else if (reg->is_FloatRegister()) {\n-        __ ldrd(reg->as_FloatRegister(), Address(rscratch1, offset));\n-        offset += 16; \/\/ needs to match VECTOR_REG_SIZE in AArch64Architecture (Java)\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-    }\n-  }\n-\n-  result_spiller.generate_spill(_masm, res_save_area_offset);\n-\n-  __ block_comment(\"{ on_exit\");\n-  __ lea(c_rarg0, Address(sp, frame_data_offset));\n-  \/\/ stack already aligned\n-  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, ProgrammableUpcallHandler::on_exit));\n-  __ blr(rscratch1);\n-  __ block_comment(\"} on_exit\");\n-\n-  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n-  result_spiller.generate_fill(_masm, res_save_area_offset);\n-\n-  __ leave();\n-  __ ret(lr);\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ block_comment(\"{ exception handler\");\n-\n-  intptr_t exception_handler_offset = __ pc() - start;\n-\n-  \/\/ Native caller has no idea how to handle exceptions,\n-  \/\/ so we just crash here. Up to callee to catch exceptions.\n-  __ verify_oop(r0);\n-  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, ProgrammableUpcallHandler::handle_uncaught_exception));\n-  __ blr(rscratch1);\n-  __ should_not_reach_here();\n-\n-  __ block_comment(\"} exception handler\");\n-\n-  _masm->flush();\n-\n-#ifndef PRODUCT\n-  stringStream ss;\n-  ss.print(\"optimized_upcall_stub_%s\", entry->signature()->as_C_string());\n-  const char* name = _masm->code_string(ss.as_string());\n-#else \/\/ PRODUCT\n-  const char* name = \"optimized_upcall_stub\";\n-#endif \/\/ PRODUCT\n-\n-  OptimizedEntryBlob* blob\n-    = OptimizedEntryBlob::create(name,\n-                                 &buffer,\n-                                 exception_handler_offset,\n-                                 receiver,\n-                                 in_ByteSize(frame_data_offset));\n-\n-  if (TraceOptimizedUpcallStubs) {\n-    blob->print_on(tty);\n-  }\n-\n-  return blob->code_begin();\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":0,"deletions":337,"binary":false,"changes":337,"status":"deleted"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/signature.hpp\"\n+#include \"runtime\/signature.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"vmreg_aarch64.inline.hpp\"\n+\n+#define __ _masm->\n+\n+\/\/ for callee saved regs, according to the caller's ABI\n+static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n+  int size = 0;\n+  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+    Register reg = as_Register(i);\n+    if (reg == rfp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+    FloatRegister reg = as_FloatRegister(i);\n+    if (!abi.is_volatile_reg(reg)) {\n+      \/\/ Only the lower 64 bits of vector registers need to be preserved.\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  return size;\n+}\n+\n+static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to save it here\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ preserve_callee_saved_regs \");\n+  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+    Register reg = as_Register(i);\n+    if (reg == rfp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ str(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+    FloatRegister reg = as_FloatRegister(i);\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ strd(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  __ block_comment(\"} preserve_callee_saved_regs \");\n+}\n+\n+static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to restore it here\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ restore_callee_saved_regs \");\n+  for (int i = 0; i < RegisterImpl::number_of_registers; i++) {\n+    Register reg = as_Register(i);\n+    if (reg == rfp || reg == sp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ ldr(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (int i = 0; i < FloatRegisterImpl::number_of_registers; i++) {\n+    FloatRegister reg = as_FloatRegister(i);\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ ldrd(reg, Address(sp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  __ block_comment(\"} restore_callee_saved_regs \");\n+}\n+\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  ResourceMark rm;\n+  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n+  const CallRegs call_regs = ForeignGlobals::parse_call_regs(jconv);\n+  CodeBuffer buffer(\"upcall_stub\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n+\n+  Register shuffle_reg = r19;\n+  JavaCallingConvention out_conv;\n+  NativeCallingConvention in_conv(call_regs._arg_regs);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n+  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n+  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n+  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n+  \/\/ make sure it is big enough.\n+  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n+    out_arg_area = frame::arg_reg_save_area_bytes;\n+  }\n+\n+  int reg_save_area_size = compute_reg_save_area_size(abi);\n+  RegSpiller arg_spilller(call_regs._arg_regs);\n+  RegSpiller result_spiller(call_regs._ret_regs);\n+\n+  int shuffle_area_offset    = 0;\n+  int res_save_area_offset   = shuffle_area_offset    + out_arg_area;\n+  int arg_save_area_offset   = res_save_area_offset   + result_spiller.spill_size_bytes();\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_spilller.spill_size_bytes();\n+  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = frame_data_offset      + sizeof(UpcallStub::FrameData);\n+\n+  int ret_buf_offset = -1;\n+  if (needs_return_buffer) {\n+    ret_buf_offset = frame_bottom_offset;\n+    frame_bottom_offset += ret_buf_size;\n+  }\n+\n+  int frame_size = frame_bottom_offset;\n+  frame_size = align_up(frame_size, StackAlignmentInBytes);\n+\n+  \/\/ The space we have allocated will look like:\n+  \/\/\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      | (optional)          |\n+  \/\/      | ret_buf             |\n+  \/\/      |---------------------| = ret_buf_offset\n+  \/\/      |                     |\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n+  \/\/      |                     |\n+  \/\/      | reg_save_area       |\n+  \/\/      |---------------------| = reg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | arg_save_area       |\n+  \/\/      |---------------------| = arg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_are_offset\n+  \/\/      |                     |\n+  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n+  \/\/\n+  \/\/\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+  address start = __ pc();\n+  __ enter(); \/\/ set up frame\n+  assert((abi._stack_alignment_bytes % 16) == 0, \"must be 16 byte aligned\");\n+  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n+  __ sub(sp, sp, frame_size);\n+\n+  \/\/ we have to always spill args since we need to do a call to get the thread\n+  \/\/ (and maybe attach it).\n+  arg_spilller.generate_spill(_masm, arg_save_area_offset);\n+  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ block_comment(\"{ on_entry\");\n+  __ lea(c_rarg0, Address(sp, frame_data_offset));\n+  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::on_entry));\n+  __ blr(rscratch1);\n+  __ mov(rthread, r0);\n+  __ reinit_heapbase();\n+  __ block_comment(\"} on_entry\");\n+\n+  __ block_comment(\"{ argument shuffle\");\n+  arg_spilller.generate_fill(_masm, arg_save_area_offset);\n+  if (needs_return_buffer) {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(abi._ret_buf_addr_reg, Address(sp, ret_buf_offset));\n+  }\n+  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n+  __ block_comment(\"} argument shuffle\");\n+\n+  __ block_comment(\"{ receiver \");\n+  __ movptr(shuffle_reg, (intptr_t)receiver);\n+  __ resolve_jobject(shuffle_reg, rthread, rscratch2);\n+  __ mov(j_rarg0, shuffle_reg);\n+  __ block_comment(\"} receiver \");\n+\n+  __ mov_metadata(rmethod, entry);\n+  __ str(rmethod, Address(rthread, JavaThread::callee_target_offset())); \/\/ just in case callee is deoptimized\n+\n+  __ ldr(rscratch1, Address(rmethod, Method::from_compiled_offset()));\n+  __ blr(rscratch1);\n+\n+    \/\/ return value shuffle\n+  if (!needs_return_buffer) {\n+#ifdef ASSERT\n+    if (call_regs._ret_regs.length() == 1) { \/\/ 0 or 1\n+      VMReg j_expected_result_reg;\n+      switch (ret_type) {\n+        case T_BOOLEAN:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_CHAR:\n+        case T_INT:\n+        case T_LONG:\n+        j_expected_result_reg = r0->as_VMReg();\n+        break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = v0->as_VMReg();\n+          break;\n+        default:\n+          fatal(\"unexpected return type: %s\", type2name(ret_type));\n+      }\n+      \/\/ No need to move for now, since CallArranger can pick a return type\n+      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n+      \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n+    }\n+#endif\n+  } else {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(rscratch1, Address(sp, ret_buf_offset));\n+    int offset = 0;\n+    for (int i = 0; i < call_regs._ret_regs.length(); i++) {\n+      VMReg reg = call_regs._ret_regs.at(i);\n+      if (reg->is_Register()) {\n+        __ ldr(reg->as_Register(), Address(rscratch1, offset));\n+        offset += 8;\n+      } else if (reg->is_FloatRegister()) {\n+        __ ldrd(reg->as_FloatRegister(), Address(rscratch1, offset));\n+        offset += 16; \/\/ needs to match VECTOR_REG_SIZE in AArch64Architecture (Java)\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+\n+  result_spiller.generate_spill(_masm, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ lea(c_rarg0, Address(sp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::on_exit));\n+  __ blr(rscratch1);\n+  __ block_comment(\"} on_exit\");\n+\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  result_spiller.generate_fill(_masm, res_save_area_offset);\n+\n+  __ leave();\n+  __ ret(lr);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ exception handler\");\n+\n+  intptr_t exception_handler_offset = __ pc() - start;\n+\n+  \/\/ Native caller has no idea how to handle exceptions,\n+  \/\/ so we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(r0);\n+  __ movptr(rscratch1, CAST_FROM_FN_PTR(uint64_t, UpcallLinker::handle_uncaught_exception));\n+  __ blr(rscratch1);\n+  __ should_not_reach_here();\n+\n+  __ block_comment(\"} exception handler\");\n+\n+  _masm->flush();\n+\n+#ifndef PRODUCT\n+  stringStream ss;\n+  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  const char* name = _masm->code_string(ss.as_string());\n+#else \/\/ PRODUCT\n+  const char* name = \"upcall_stub\";\n+#endif \/\/ PRODUCT\n+\n+  UpcallStub* blob\n+    = UpcallStub::create(name,\n+                         &buffer,\n+                         exception_handler_offset,\n+                         receiver,\n+                         in_ByteSize(frame_data_offset));\n+\n+  if (TraceOptimizedUpcallStubs) {\n+    blob->print_on(tty);\n+  }\n+\n+  return blob->code_begin();\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+RuntimeStub* DowncallLinker::make_downcall_stub(BasicType* signature,\n+                                                int num_args,\n+                                                BasicType ret_bt,\n+                                                const ABIDescriptor& abi,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers,\n+                                                bool needs_return_buffer) {\n+  Unimplemented();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/cpu\/arm\/foreign_globals_arm.cpp","status":"renamed"},{"patch":"","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/arm\/foreign_globals_arm.hpp","status":"renamed"},{"patch":"@@ -314,1 +314,1 @@\n-OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+UpcallStub::FrameData* UpcallStub::frame_data_for_frame(const frame& frame) const {\n@@ -319,1 +319,1 @@\n-bool frame::optimized_entry_frame_is_first() const {\n+bool frame::upcall_stub_frame_is_first() const {\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n-  Unimplemented();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/universalNativeInvoker_arm.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  ShouldNotCallThis();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/universalUpcallHandle_arm.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/arm\/upcallLinker_arm.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+RuntimeStub* DowncallLinker::make_downcall_stub(BasicType* signature,\n+                                                int num_args,\n+                                                BasicType ret_bt,\n+                                                const ABIDescriptor& abi,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers,\n+                                                bool needs_return_buffer) {\n+  Unimplemented();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/cpu\/ppc\/foreign_globals_ppc.cpp","status":"renamed"},{"patch":"","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/ppc\/foreign_globals_ppc.hpp","status":"renamed"},{"patch":"@@ -207,1 +207,1 @@\n-OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+UpcallStub::FrameData* UpcallStub::frame_data_for_frame(const frame& frame) const {\n@@ -212,1 +212,1 @@\n-bool frame::optimized_entry_frame_is_first() const {\n+bool frame::upcall_stub_frame_is_first() const {\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n-  Unimplemented();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/universalNativeInvoker_ppc.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  ShouldNotCallThis();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/universalUpcallHandle_ppc.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/upcallLinker_ppc.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/universalNativeInvoker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+RuntimeStub* DowncallLinker::make_native_invoker(BasicType* signature,\n+                                                 int num_args,\n+                                                 BasicType ret_bt,\n+                                                 const ABIDescriptor& abi,\n+                                                 const GrowableArray<VMReg>& input_registers,\n+                                                 const GrowableArray<VMReg>& output_registers,\n+                                                 bool needs_return_buffer) {\n+  Unimplemented();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/cpu\/riscv\/foreign_globals_riscv.cpp","status":"renamed"},{"patch":"","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/riscv\/foreign_globals_riscv.hpp","status":"renamed"},{"patch":"@@ -346,1 +346,1 @@\n-OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+UpcallStub::FrameData* UpcallStub::frame_data_for_frame(const frame& frame) const {\n@@ -351,1 +351,1 @@\n-bool frame::optimized_entry_frame_is_first() const {\n+bool frame::upcall_stub_frame_is_first() const {\n@@ -356,1 +356,1 @@\n-frame frame::sender_for_optimized_entry_frame(RegisterMap* map) const {\n+frame frame::sender_for_upcall_stub_frame(RegisterMap* map) const {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n-  Unimplemented();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/riscv\/universalNativeInvoker_riscv.cpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  ShouldNotCallThis();\n-  return nullptr;\n-}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/universalUpcallHandle_riscv.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/upcallLinker_riscv.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+RuntimeStub* DowncallLinker::make_downcall_stub(BasicType* signature,\n+                                                int num_args,\n+                                                BasicType ret_bt,\n+                                                const ABIDescriptor& abi,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers,\n+                                                bool needs_return_buffer) {\n+  Unimplemented();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/cpu\/s390\/foreign_globals_s390.cpp","status":"renamed"},{"patch":"","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/s390\/foreign_globals_s390.hpp","status":"renamed"},{"patch":"@@ -218,1 +218,1 @@\n-OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+UpcallStub::FrameData* UpcallStub::frame_data_for_frame(const frame& frame) const {\n@@ -223,1 +223,1 @@\n-bool frame::optimized_entry_frame_is_first() const {\n+bool frame::upcall_stub_frame_is_first() const {\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n-  Unimplemented();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/s390\/universalNativeInvoker_s390.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  ShouldNotCallThis();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/s390\/universalUpcallHandle_s390.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/s390\/upcallLinker_s390.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n+\n+RuntimeStub* DowncallLinker::make_downcall_stub(BasicType* signature,\n+                                                int num_args,\n+                                                BasicType ret_bt,\n+                                                const ABIDescriptor& abi,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers,\n+                                                bool needs_return_buffer) {\n+  Unimplemented();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -29,2 +29,2 @@\n-#include \"prims\/foreign_globals.inline.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n+#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n@@ -37,1 +37,1 @@\n-class NativeInvokerGenerator : public StubCodeGenerator {\n+class DowncallStubGenerator : public StubCodeGenerator {\n@@ -52,1 +52,1 @@\n-  NativeInvokerGenerator(CodeBuffer* buffer,\n+  DowncallStubGenerator(CodeBuffer* buffer,\n@@ -90,7 +90,7 @@\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n+RuntimeStub* DowncallLinker::make_downcall_stub(BasicType* signature,\n+                                                int num_args,\n+                                                BasicType ret_bt,\n+                                                const ABIDescriptor& abi,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers,\n+                                                bool needs_return_buffer) {\n@@ -99,1 +99,1 @@\n-  NativeInvokerGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n@@ -122,1 +122,1 @@\n-void NativeInvokerGenerator::generate() {\n+void DowncallStubGenerator::generate() {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"previous_filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86_64.cpp","status":"renamed"},{"patch":"","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.hpp","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86_32.cpp","status":"renamed"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"prims\/foreign_globals.inline.hpp\"\n+#include \"prims\/foreignGlobals.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86_64.cpp","status":"renamed"},{"patch":"@@ -109,1 +109,1 @@\n-    } else if (is_optimized_entry_frame()) {\n+    } else if (is_upcall_stub_frame()) {\n@@ -214,1 +214,1 @@\n-    } else if (sender_blob->is_optimized_entry_blob()) {\n+    } else if (sender_blob->is_upcall_stub()) {\n@@ -369,2 +369,2 @@\n-OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n-  assert(frame.is_optimized_entry_frame(), \"wrong frame\");\n+UpcallStub::FrameData* UpcallStub::frame_data_for_frame(const frame& frame) const {\n+  assert(frame.is_upcall_stub_frame(), \"wrong frame\");\n@@ -372,1 +372,1 @@\n-  return reinterpret_cast<OptimizedEntryBlob::FrameData*>(\n+  return reinterpret_cast<UpcallStub::FrameData*>(\n@@ -376,3 +376,3 @@\n-bool frame::optimized_entry_frame_is_first() const {\n-  assert(is_optimized_entry_frame(), \"must be optimzed entry frame\");\n-  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+bool frame::upcall_stub_frame_is_first() const {\n+  assert(is_upcall_stub_frame(), \"must be optimzed entry frame\");\n+  UpcallStub* blob = _cb->as_upcall_stub();\n@@ -383,1 +383,1 @@\n-frame frame::sender_for_optimized_entry_frame(RegisterMap* map) const {\n+frame frame::sender_for_upcall_stub_frame(RegisterMap* map) const {\n@@ -385,1 +385,1 @@\n-  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+  UpcallStub* blob = _cb->as_upcall_stub();\n@@ -389,1 +389,1 @@\n-  assert(!optimized_entry_frame_is_first(), \"must have a frame anchor to go back to\");\n+  assert(!upcall_stub_frame_is_first(), \"must have a frame anchor to go back to\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -387,3 +387,3 @@\n-  if (is_entry_frame())           return sender_for_entry_frame(map);\n-  if (is_optimized_entry_frame()) return sender_for_optimized_entry_frame(map);\n-  if (is_interpreted_frame())     return sender_for_interpreter_frame(map);\n+  if (is_entry_frame())       return sender_for_entry_frame(map);\n+  if (is_upcall_stub_frame()) return sender_for_upcall_stub_frame(map);\n+  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-                    Address(nep_reg, NONZERO(jdk_internal_foreign_abi_NativeEntryPoint::invoker_offset_in_bytes())),\n+                    Address(nep_reg, NONZERO(jdk_internal_foreign_abi_NativeEntryPoint::downcall_stub_address_offset_in_bytes())),\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n-\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n-  Unimplemented();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/x86\/universalNativeInvoker_x86_32.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  ShouldNotCallThis();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_32.cpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,401 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"code\/codeBlob.hpp\"\n-#include \"code\/codeBlob.hpp\"\n-#include \"code\/vmreg.inline.hpp\"\n-#include \"compiler\/disassembler.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"prims\/foreign_globals.inline.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"runtime\/signature.hpp\"\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"utilities\/formatBuffer.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#define __ _masm->\n-\n-static bool is_valid_XMM(XMMRegister reg) {\n-  return reg->is_valid() && (UseAVX >= 3 || (reg->encoding() < 16)); \/\/ why is this not covered by is_valid()?\n-}\n-\n-\/\/ for callee saved regs, according to the caller's ABI\n-static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n-  int size = 0;\n-  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n-    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n-    if (!abi.is_volatile_reg(reg)) {\n-      size += 8; \/\/ bytes\n-    }\n-  }\n-\n-  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n-    if (!abi.is_volatile_reg(reg)) {\n-      if (UseAVX >= 3) {\n-        size += 64; \/\/ bytes\n-      } else if (UseAVX >= 1) {\n-        size += 32;\n-      } else {\n-        size += 16;\n-      }\n-    }\n-  }\n-\n-#ifndef _WIN64\n-  \/\/ for mxcsr\n-  size += 8;\n-#endif\n-\n-  return size;\n-}\n-\n-constexpr int MXCSR_MASK = 0xFFC0;  \/\/ Mask out any pending exceptions\n-\n-static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n-  \/\/ 1. iterate all registers in the architecture\n-  \/\/     - check if they are volatile or not for the given abi\n-  \/\/     - if NOT, we need to save it here\n-  \/\/ 2. save mxcsr on non-windows platforms\n-\n-  int offset = reg_save_area_offset;\n-\n-  __ block_comment(\"{ preserve_callee_saved_regs \");\n-  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n-    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n-    if (!abi.is_volatile_reg(reg)) {\n-      __ movptr(Address(rsp, offset), reg);\n-      offset += 8;\n-    }\n-  }\n-\n-  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n-    if (!abi.is_volatile_reg(reg)) {\n-      if (UseAVX >= 3) {\n-        __ evmovdqul(Address(rsp, offset), reg, Assembler::AVX_512bit);\n-        offset += 64;\n-      } else if (UseAVX >= 1) {\n-        __ vmovdqu(Address(rsp, offset), reg);\n-        offset += 32;\n-      } else {\n-        __ movdqu(Address(rsp, offset), reg);\n-        offset += 16;\n-      }\n-    }\n-  }\n-\n-#ifndef _WIN64\n-  {\n-    const Address mxcsr_save(rsp, offset);\n-    Label skip_ldmx;\n-    __ stmxcsr(mxcsr_save);\n-    __ movl(rax, mxcsr_save);\n-    __ andl(rax, MXCSR_MASK);    \/\/ Only check control and mask bits\n-    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n-    __ cmp32(rax, mxcsr_std);\n-    __ jcc(Assembler::equal, skip_ldmx);\n-    __ ldmxcsr(mxcsr_std);\n-    __ bind(skip_ldmx);\n-  }\n-#endif\n-\n-  __ block_comment(\"} preserve_callee_saved_regs \");\n-}\n-\n-static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n-  \/\/ 1. iterate all registers in the architecture\n-  \/\/     - check if they are volatile or not for the given abi\n-  \/\/     - if NOT, we need to restore it here\n-  \/\/ 2. restore mxcsr on non-windows platforms\n-\n-  int offset = reg_save_area_offset;\n-\n-  __ block_comment(\"{ restore_callee_saved_regs \");\n-  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n-    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n-    if (!abi.is_volatile_reg(reg)) {\n-      __ movptr(reg, Address(rsp, offset));\n-      offset += 8;\n-    }\n-  }\n-\n-  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n-    if (!abi.is_volatile_reg(reg)) {\n-      if (UseAVX >= 3) {\n-        __ evmovdqul(reg, Address(rsp, offset), Assembler::AVX_512bit);\n-        offset += 64;\n-      } else if (UseAVX >= 1) {\n-        __ vmovdqu(reg, Address(rsp, offset));\n-        offset += 32;\n-      } else {\n-        __ movdqu(reg, Address(rsp, offset));\n-        offset += 16;\n-      }\n-    }\n-  }\n-\n-#ifndef _WIN64\n-  const Address mxcsr_save(rsp, offset);\n-  __ ldmxcsr(mxcsr_save);\n-#endif\n-\n-  __ block_comment(\"} restore_callee_saved_regs \");\n-}\n-\/\/ Register is a class, but it would be assigned numerical value.\n-\/\/ \"0\" is assigned for rax and for xmm0. Thus we need to ignore -Wnonnull.\n-PRAGMA_DIAG_PUSH\n-PRAGMA_NONNULL_IGNORED\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n-  const CallRegs call_regs = ForeignGlobals::parse_call_regs(jconv);\n-  CodeBuffer buffer(\"upcall_stub_linkToNative\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n-\n-  Register shuffle_reg = rbx;\n-  JavaCallingConvention out_conv;\n-  NativeCallingConvention in_conv(call_regs._arg_regs);\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n-  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n-  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n-\n-#ifndef PRODUCT\n-  LogTarget(Trace, foreign, upcall) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    arg_shuffle.print_on(&ls);\n-  }\n-#endif\n-\n-  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n-  \/\/ make sure it is big enough.\n-  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n-    out_arg_area = frame::arg_reg_save_area_bytes;\n-  }\n-\n-  int reg_save_area_size = compute_reg_save_area_size(abi);\n-  RegSpiller arg_spilller(call_regs._arg_regs);\n-  RegSpiller result_spiller(call_regs._ret_regs);\n-\n-  int shuffle_area_offset    = 0;\n-  int res_save_area_offset   = shuffle_area_offset    + out_arg_area;\n-  int arg_save_area_offset   = res_save_area_offset   + result_spiller.spill_size_bytes();\n-  int reg_save_area_offset   = arg_save_area_offset   + arg_spilller.spill_size_bytes();\n-  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n-  int frame_bottom_offset    = frame_data_offset      + sizeof(OptimizedEntryBlob::FrameData);\n-\n-  int ret_buf_offset = -1;\n-  if (needs_return_buffer) {\n-    ret_buf_offset = frame_bottom_offset;\n-    frame_bottom_offset += ret_buf_size;\n-  }\n-\n-  int frame_size = frame_bottom_offset;\n-  frame_size = align_up(frame_size, StackAlignmentInBytes);\n-\n-  \/\/ Ok The space we have allocated will look like:\n-  \/\/\n-  \/\/\n-  \/\/ FP-> |                     |\n-  \/\/      |---------------------| = frame_bottom_offset = frame_size\n-  \/\/      | (optional)          |\n-  \/\/      | ret_buf             |\n-  \/\/      |---------------------| = ret_buf_offset\n-  \/\/      |                     |\n-  \/\/      | FrameData           |\n-  \/\/      |---------------------| = frame_data_offset\n-  \/\/      |                     |\n-  \/\/      | reg_save_area       |\n-  \/\/      |---------------------| = reg_save_are_offset\n-  \/\/      |                     |\n-  \/\/      | arg_save_area       |\n-  \/\/      |---------------------| = arg_save_are_offset\n-  \/\/      |                     |\n-  \/\/      | res_save_area       |\n-  \/\/      |---------------------| = res_save_are_offset\n-  \/\/      |                     |\n-  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n-  \/\/\n-  \/\/\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  MacroAssembler* _masm = new MacroAssembler(&buffer);\n-  address start = __ pc();\n-  __ enter(); \/\/ set up frame\n-  if ((abi._stack_alignment_bytes % 16) != 0) {\n-    \/\/ stack alignment of caller is not a multiple of 16\n-    __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack\n-  }\n-  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n-  __ subptr(rsp, frame_size);\n-\n-  \/\/ we have to always spill args since we need to do a call to get the thread\n-  \/\/ (and maybe attach it).\n-  arg_spilller.generate_spill(_masm, arg_save_area_offset);\n-\n-  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n-  __ block_comment(\"{ on_entry\");\n-  __ vzeroupper();\n-  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_entry)));\n-  __ movptr(r15_thread, rax);\n-  __ reinit_heapbase();\n-  __ block_comment(\"} on_entry\");\n-\n-  __ block_comment(\"{ argument shuffle\");\n-  arg_spilller.generate_fill(_masm, arg_save_area_offset);\n-  if (needs_return_buffer) {\n-    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n-    __ lea(abi._ret_buf_addr_reg, Address(rsp, ret_buf_offset));\n-  }\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n-  __ block_comment(\"} argument shuffle\");\n-\n-  __ block_comment(\"{ receiver \");\n-  __ movptr(rscratch1, (intptr_t)receiver);\n-  __ resolve_jobject(rscratch1, r15_thread, rscratch2);\n-  __ movptr(j_rarg0, rscratch1);\n-  __ block_comment(\"} receiver \");\n-\n-  __ mov_metadata(rbx, entry);\n-  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n-\n-  __ call(Address(rbx, Method::from_compiled_offset()));\n-\n-  \/\/ return value shuffle\n-  if (!needs_return_buffer) {\n-#ifdef ASSERT\n-    if (call_regs._ret_regs.length() == 1) { \/\/ 0 or 1\n-      VMReg j_expected_result_reg;\n-      switch (ret_type) {\n-        case T_BOOLEAN:\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_CHAR:\n-        case T_INT:\n-        case T_LONG:\n-        j_expected_result_reg = rax->as_VMReg();\n-        break;\n-        case T_FLOAT:\n-        case T_DOUBLE:\n-          j_expected_result_reg = xmm0->as_VMReg();\n-          break;\n-        default:\n-          fatal(\"unexpected return type: %s\", type2name(ret_type));\n-      }\n-      \/\/ No need to move for now, since CallArranger can pick a return type\n-      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n-      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n-        \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n-    }\n-#endif\n-  } else {\n-    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n-    __ lea(rscratch1, Address(rsp, ret_buf_offset));\n-    int offset = 0;\n-    for (int i = 0; i < call_regs._ret_regs.length(); i++) {\n-      VMReg reg = call_regs._ret_regs.at(i);\n-      if (reg->is_Register()) {\n-        __ movptr(reg->as_Register(), Address(rscratch1, offset));\n-        offset += 8;\n-      } else if (reg->is_XMMRegister()) {\n-        __ movdqu(reg->as_XMMRegister(), Address(rscratch1, offset));\n-        offset += 16;\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-    }\n-  }\n-\n-  result_spiller.generate_spill(_masm, res_save_area_offset);\n-\n-  __ block_comment(\"{ on_exit\");\n-  __ vzeroupper();\n-  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_exit)));\n-  __ reinit_heapbase();\n-  __ block_comment(\"} on_exit\");\n-\n-  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n-  result_spiller.generate_fill(_masm, res_save_area_offset);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ block_comment(\"{ exception handler\");\n-\n-  intptr_t exception_handler_offset = __ pc() - start;\n-\n-  \/\/ TODO: this is always the same, can we bypass and call handle_uncaught_exception directly?\n-\n-  \/\/ native caller has no idea how to handle exceptions\n-  \/\/ we just crash here. Up to callee to catch exceptions.\n-  __ verify_oop(rax);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, rax);\n-  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows (not really needed)\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::handle_uncaught_exception)));\n-  __ should_not_reach_here();\n-\n-  __ block_comment(\"} exception handler\");\n-\n-  _masm->flush();\n-\n-\n-#ifndef PRODUCT\n-  stringStream ss;\n-  ss.print(\"optimized_upcall_stub_%s\", entry->signature()->as_C_string());\n-  const char* name = _masm->code_string(ss.as_string());\n-#else \/\/ PRODUCT\n-  const char* name = \"optimized_upcall_stub\";\n-#endif \/\/ PRODUCT\n-\n-  OptimizedEntryBlob* blob\n-    = OptimizedEntryBlob::create(name,\n-                                 &buffer,\n-                                 exception_handler_offset,\n-                                 receiver,\n-                                 in_ByteSize(frame_data_offset));\n-\n-  if (TraceOptimizedUpcallStubs) {\n-    blob->print_on(tty);\n-  }\n-\n-  return blob->code_begin();\n-}\n-PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":0,"deletions":401,"binary":false,"changes":401,"status":"deleted"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_32.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,401 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/signature.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define __ _masm->\n+\n+static bool is_valid_XMM(XMMRegister reg) {\n+  return reg->is_valid() && (UseAVX >= 3 || (reg->encoding() < 16)); \/\/ why is this not covered by is_valid()?\n+}\n+\n+\/\/ for callee saved regs, according to the caller's ABI\n+static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n+  int size = 0;\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        size += 64; \/\/ bytes\n+      } else if (UseAVX >= 1) {\n+        size += 32;\n+      } else {\n+        size += 16;\n+      }\n+    }\n+  }\n+\n+#ifndef _WIN64\n+  \/\/ for mxcsr\n+  size += 8;\n+#endif\n+\n+  return size;\n+}\n+\n+constexpr int MXCSR_MASK = 0xFFC0;  \/\/ Mask out any pending exceptions\n+\n+static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to save it here\n+  \/\/ 2. save mxcsr on non-windows platforms\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ preserve_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(Address(rsp, offset), reg);\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(Address(rsp, offset), reg, Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(Address(rsp, offset), reg);\n+        offset += 32;\n+      } else {\n+        __ movdqu(Address(rsp, offset), reg);\n+        offset += 16;\n+      }\n+    }\n+  }\n+\n+#ifndef _WIN64\n+  {\n+    const Address mxcsr_save(rsp, offset);\n+    Label skip_ldmx;\n+    __ stmxcsr(mxcsr_save);\n+    __ movl(rax, mxcsr_save);\n+    __ andl(rax, MXCSR_MASK);    \/\/ Only check control and mask bits\n+    ExternalAddress mxcsr_std(StubRoutines::x86::addr_mxcsr_std());\n+    __ cmp32(rax, mxcsr_std);\n+    __ jcc(Assembler::equal, skip_ldmx);\n+    __ ldmxcsr(mxcsr_std);\n+    __ bind(skip_ldmx);\n+  }\n+#endif\n+\n+  __ block_comment(\"} preserve_callee_saved_regs \");\n+}\n+\n+static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to restore it here\n+  \/\/ 2. restore mxcsr on non-windows platforms\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ restore_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(reg, Address(rsp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(reg, Address(rsp, offset), Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(reg, Address(rsp, offset));\n+        offset += 32;\n+      } else {\n+        __ movdqu(reg, Address(rsp, offset));\n+        offset += 16;\n+      }\n+    }\n+  }\n+\n+#ifndef _WIN64\n+  const Address mxcsr_save(rsp, offset);\n+  __ ldmxcsr(mxcsr_save);\n+#endif\n+\n+  __ block_comment(\"} restore_callee_saved_regs \");\n+}\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for rax and for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n+  const CallRegs call_regs = ForeignGlobals::parse_call_regs(jconv);\n+  CodeBuffer buffer(\"upcall_stub\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n+\n+  Register shuffle_reg = rbx;\n+  JavaCallingConvention out_conv;\n+  NativeCallingConvention in_conv(call_regs._arg_regs);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n+  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n+  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+\n+#ifndef PRODUCT\n+  LogTarget(Trace, foreign, upcall) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n+\n+  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n+  \/\/ make sure it is big enough.\n+  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n+    out_arg_area = frame::arg_reg_save_area_bytes;\n+  }\n+\n+  int reg_save_area_size = compute_reg_save_area_size(abi);\n+  RegSpiller arg_spilller(call_regs._arg_regs);\n+  RegSpiller result_spiller(call_regs._ret_regs);\n+\n+  int shuffle_area_offset    = 0;\n+  int res_save_area_offset   = shuffle_area_offset    + out_arg_area;\n+  int arg_save_area_offset   = res_save_area_offset   + result_spiller.spill_size_bytes();\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_spilller.spill_size_bytes();\n+  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = frame_data_offset      + sizeof(UpcallStub::FrameData);\n+\n+  int ret_buf_offset = -1;\n+  if (needs_return_buffer) {\n+    ret_buf_offset = frame_bottom_offset;\n+    frame_bottom_offset += ret_buf_size;\n+  }\n+\n+  int frame_size = frame_bottom_offset;\n+  frame_size = align_up(frame_size, StackAlignmentInBytes);\n+\n+  \/\/ Ok The space we have allocated will look like:\n+  \/\/\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      | (optional)          |\n+  \/\/      | ret_buf             |\n+  \/\/      |---------------------| = ret_buf_offset\n+  \/\/      |                     |\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n+  \/\/      |                     |\n+  \/\/      | reg_save_area       |\n+  \/\/      |---------------------| = reg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | arg_save_area       |\n+  \/\/      |---------------------| = arg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_are_offset\n+  \/\/      |                     |\n+  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n+  \/\/\n+  \/\/\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+  address start = __ pc();\n+  __ enter(); \/\/ set up frame\n+  if ((abi._stack_alignment_bytes % 16) != 0) {\n+    \/\/ stack alignment of caller is not a multiple of 16\n+    __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack\n+  }\n+  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n+  __ subptr(rsp, frame_size);\n+\n+  \/\/ we have to always spill args since we need to do a call to get the thread\n+  \/\/ (and maybe attach it).\n+  arg_spilller.generate_spill(_masm, arg_save_area_offset);\n+\n+  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ block_comment(\"{ on_entry\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, UpcallLinker::on_entry)));\n+  __ movptr(r15_thread, rax);\n+  __ reinit_heapbase();\n+  __ block_comment(\"} on_entry\");\n+\n+  __ block_comment(\"{ argument shuffle\");\n+  arg_spilller.generate_fill(_masm, arg_save_area_offset);\n+  if (needs_return_buffer) {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(abi._ret_buf_addr_reg, Address(rsp, ret_buf_offset));\n+  }\n+  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n+  __ block_comment(\"} argument shuffle\");\n+\n+  __ block_comment(\"{ receiver \");\n+  __ movptr(rscratch1, (intptr_t)receiver);\n+  __ resolve_jobject(rscratch1, r15_thread, rscratch2);\n+  __ movptr(j_rarg0, rscratch1);\n+  __ block_comment(\"} receiver \");\n+\n+  __ mov_metadata(rbx, entry);\n+  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+  \/\/ return value shuffle\n+  if (!needs_return_buffer) {\n+#ifdef ASSERT\n+    if (call_regs._ret_regs.length() == 1) { \/\/ 0 or 1\n+      VMReg j_expected_result_reg;\n+      switch (ret_type) {\n+        case T_BOOLEAN:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_CHAR:\n+        case T_INT:\n+        case T_LONG:\n+        j_expected_result_reg = rax->as_VMReg();\n+        break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = xmm0->as_VMReg();\n+          break;\n+        default:\n+          fatal(\"unexpected return type: %s\", type2name(ret_type));\n+      }\n+      \/\/ No need to move for now, since CallArranger can pick a return type\n+      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n+        \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n+    }\n+#endif\n+  } else {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(rscratch1, Address(rsp, ret_buf_offset));\n+    int offset = 0;\n+    for (int i = 0; i < call_regs._ret_regs.length(); i++) {\n+      VMReg reg = call_regs._ret_regs.at(i);\n+      if (reg->is_Register()) {\n+        __ movptr(reg->as_Register(), Address(rscratch1, offset));\n+        offset += 8;\n+      } else if (reg->is_XMMRegister()) {\n+        __ movdqu(reg->as_XMMRegister(), Address(rscratch1, offset));\n+        offset += 16;\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+\n+  result_spiller.generate_spill(_masm, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, UpcallLinker::on_exit)));\n+  __ reinit_heapbase();\n+  __ block_comment(\"} on_exit\");\n+\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  result_spiller.generate_fill(_masm, res_save_area_offset);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ exception handler\");\n+\n+  intptr_t exception_handler_offset = __ pc() - start;\n+\n+  \/\/ TODO: this is always the same, can we bypass and call handle_uncaught_exception directly?\n+\n+  \/\/ native caller has no idea how to handle exceptions\n+  \/\/ we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(rax);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, rax);\n+  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n+  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows (not really needed)\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, UpcallLinker::handle_uncaught_exception)));\n+  __ should_not_reach_here();\n+\n+  __ block_comment(\"} exception handler\");\n+\n+  _masm->flush();\n+\n+\n+#ifndef PRODUCT\n+  stringStream ss;\n+  ss.print(\"upcall_stub_%s\", entry->signature()->as_C_string());\n+  const char* name = _masm->code_string(ss.as_string());\n+#else \/\/ PRODUCT\n+  const char* name = \"upcall_stub\";\n+#endif \/\/ PRODUCT\n+\n+  UpcallStub* blob\n+    = UpcallStub::create(name,\n+                         &buffer,\n+                         exception_handler_offset,\n+                         receiver,\n+                         in_ByteSize(frame_data_offset));\n+\n+  if (TraceOptimizedUpcallStubs) {\n+    blob->print_on(tty);\n+  }\n+\n+  return blob->code_begin();\n+}\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":401,"deletions":0,"binary":false,"changes":401,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n+\n+RuntimeStub* DowncallLinker::make_downcall_stub(BasicType* signature,\n+                                                int num_args,\n+                                                BasicType ret_bt,\n+                                                const ABIDescriptor& abi,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers,\n+                                                bool needs_return_buffer) {\n+  Unimplemented();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/cpu\/zero\/foreign_globals_zero.cpp","status":"renamed"},{"patch":"","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/zero\/foreign_globals_zero.hpp","status":"renamed"},{"patch":"@@ -65,1 +65,1 @@\n-OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+UpcallStub::FrameData* UpcallStub::frame_data_for_frame(const frame& frame) const {\n@@ -70,1 +70,1 @@\n-bool frame::optimized_entry_frame_is_first() const {\n+bool frame::upcall_stub_frame_is_first() const {\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n-\n-RuntimeStub* ProgrammableInvoker::make_native_invoker(BasicType* signature,\n-                                                      int num_args,\n-                                                      BasicType ret_bt,\n-                                                      const ABIDescriptor& abi,\n-                                                      const GrowableArray<VMReg>& input_registers,\n-                                                      const GrowableArray<VMReg>& output_registers,\n-                                                      bool needs_return_buffer) {\n-  Unimplemented();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/zero\/universalNativeInvoker_zero.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n-                                                                  BasicType* in_sig_bt, int total_in_args,\n-                                                                  BasicType* out_sig_bt, int total_out_args,\n-                                                                  BasicType ret_type,\n-                                                                  jobject jabi, jobject jconv,\n-                                                                  bool needs_return_buffer, int ret_buf_size) {\n-  ShouldNotCallThis();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/cpu\/zero\/universalUpcallHandle_zero.cpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+\n+address UpcallLinker::make_upcall_stub(jobject receiver, Method* entry,\n+                                       BasicType* in_sig_bt, int total_in_args,\n+                                       BasicType* out_sig_bt, int total_out_args,\n+                                       BasicType ret_type,\n+                                       jobject jabi, jobject jconv,\n+                                       bool needs_return_buffer, int ret_buf_size) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/cpu\/zero\/upcallLinker_zero.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -4241,1 +4241,1 @@\n-int jdk_internal_foreign_abi_NativeEntryPoint::_invoker_offset;\n+int jdk_internal_foreign_abi_NativeEntryPoint::_downcall_stub_address_offset;\n@@ -4244,2 +4244,2 @@\n-  macro(_method_type_offset,     k, \"methodType\",     java_lang_invoke_MethodType_signature, false); \\\n-  macro(_invoker_offset,         k, \"invoker\",        long_signature, false);\n+  macro(_method_type_offset,           k, \"methodType\",          java_lang_invoke_MethodType_signature, false); \\\n+  macro(_downcall_stub_address_offset, k, \"downcallStubAddress\", long_signature, false);\n@@ -4266,2 +4266,2 @@\n-jlong jdk_internal_foreign_abi_NativeEntryPoint::invoker(oop entry) {\n-  return entry->long_field(_invoker_offset);\n+jlong jdk_internal_foreign_abi_NativeEntryPoint::downcall_stub_address(oop entry) {\n+  return entry->long_field(_downcall_stub_address_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1171,2 +1171,2 @@\n-  static inline intptr_t pc(oop chunk);\n-  static inline void set_pc(oop chunk, intptr_t value);\n+  static inline address pc(oop chunk);\n+  static inline void set_pc(oop chunk, address value);\n@@ -1287,1 +1287,1 @@\n-  static int _invoker_offset;\n+  static int _downcall_stub_address_offset;\n@@ -1296,1 +1296,1 @@\n-  static jlong      invoker(oop entry);\n+  static jlong      downcall_stub_address(oop entry);\n@@ -1306,2 +1306,2 @@\n-  static int method_type_offset_in_bytes()     { return _method_type_offset;     }\n-  static int invoker_offset_in_bytes()         { return _invoker_offset;         }\n+  static int method_type_offset_in_bytes()           { return _method_type_offset; }\n+  static int downcall_stub_address_offset_in_bytes() { return _downcall_stub_address_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -329,2 +329,2 @@\n-inline intptr_t jdk_internal_vm_StackChunk::pc(oop chunk) {\n-  return chunk->long_field(_pc_offset);\n+inline address jdk_internal_vm_StackChunk::pc(oop chunk) {\n+  return chunk->address_field(_pc_offset);\n@@ -333,2 +333,2 @@\n-inline void jdk_internal_vm_StackChunk::set_pc(oop chunk, intptr_t value) {\n-  chunk->long_field_put(_pc_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_pc(oop chunk, address value) {\n+  chunk->address_field_put(_pc_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-  template(jdk_internal_foreign_abi_CallConv,                        \"jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler$CallRegs\") \\\n+  template(jdk_internal_foreign_abi_CallConv,                        \"jdk\/internal\/foreign\/abi\/UpcallLinker$CallRegs\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-\/\/ Implementation of OptimizedEntryBlob\n+\/\/ Implementation of UpcallStub\n@@ -728,4 +728,4 @@\n-OptimizedEntryBlob::OptimizedEntryBlob(const char* name, CodeBuffer* cb, int size,\n-                                       intptr_t exception_handler_offset,\n-                                       jobject receiver, ByteSize frame_data_offset) :\n-  RuntimeBlob(name, cb, sizeof(OptimizedEntryBlob), size, CodeOffsets::frame_never_safe, 0 \/* no frame size *\/,\n+UpcallStub::UpcallStub(const char* name, CodeBuffer* cb, int size,\n+                       intptr_t exception_handler_offset,\n+                       jobject receiver, ByteSize frame_data_offset) :\n+  RuntimeBlob(name, cb, sizeof(UpcallStub), size, CodeOffsets::frame_never_safe, 0 \/* no frame size *\/,\n@@ -739,1 +739,1 @@\n-void* OptimizedEntryBlob::operator new(size_t s, unsigned size) throw() {\n+void* UpcallStub::operator new(size_t s, unsigned size) throw() {\n@@ -743,3 +743,3 @@\n-OptimizedEntryBlob* OptimizedEntryBlob::create(const char* name, CodeBuffer* cb,\n-                                               intptr_t exception_handler_offset,\n-                                               jobject receiver, ByteSize frame_data_offset) {\n+UpcallStub* UpcallStub::create(const char* name, CodeBuffer* cb,\n+                               intptr_t exception_handler_offset,\n+                               jobject receiver, ByteSize frame_data_offset) {\n@@ -748,2 +748,2 @@\n-  OptimizedEntryBlob* blob = nullptr;\n-  unsigned int size = CodeBlob::allocation_size(cb, sizeof(OptimizedEntryBlob));\n+  UpcallStub* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(UpcallStub));\n@@ -752,1 +752,1 @@\n-    blob = new (size) OptimizedEntryBlob(name, cb, size,\n+    blob = new (size) UpcallStub(name, cb, size,\n@@ -758,1 +758,1 @@\n-  trace_new_stub(blob, \"OptimizedEntryBlob\");\n+  trace_new_stub(blob, \"UpcallStub\");\n@@ -763,1 +763,1 @@\n-void OptimizedEntryBlob::oops_do(OopClosure* f, const frame& frame) {\n+void UpcallStub::oops_do(OopClosure* f, const frame& frame) {\n@@ -767,1 +767,1 @@\n-JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+JavaFrameAnchor* UpcallStub::jfa_for_frame(const frame& frame) const {\n@@ -771,1 +771,1 @@\n-void OptimizedEntryBlob::free(OptimizedEntryBlob* blob) {\n+void UpcallStub::free(UpcallStub* blob) {\n@@ -777,1 +777,1 @@\n-void OptimizedEntryBlob::preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) {\n+void UpcallStub::preserve_callee_argument_oops(frame fr, const RegisterMap* reg_map, OopClosure* f) {\n@@ -782,1 +782,1 @@\n-void OptimizedEntryBlob::verify() {\n+void UpcallStub::verify() {\n@@ -786,1 +786,1 @@\n-void OptimizedEntryBlob::print_on(outputStream* st) const {\n+void UpcallStub::print_on(outputStream* st) const {\n@@ -791,2 +791,2 @@\n-void OptimizedEntryBlob::print_value_on(outputStream* st) const {\n-  st->print_cr(\"OptimizedEntryBlob (\" INTPTR_FORMAT  \") used for %s\", p2i(this), name());\n+void UpcallStub::print_value_on(outputStream* st) const {\n+  st->print_cr(\"UpcallStub (\" INTPTR_FORMAT  \") used for %s\", p2i(this), name());\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-\/\/   OptimizedEntryBlob  : Used for upcalls from native code\n+\/\/   UpcallStub  : Used for upcalls from native code\n@@ -82,1 +82,1 @@\n-class OptimizedEntryBlob; \/\/ for as_optimized_entry_blob()\n+class UpcallStub; \/\/ for as_upcall_stub()\n@@ -84,1 +84,1 @@\n-class JavaFrameAnchor; \/\/ for OptimizedEntryBlob::jfa_for_frame\n+class JavaFrameAnchor; \/\/ for UpcallStub::jfa_for_frame\n@@ -157,1 +157,1 @@\n-  virtual bool is_optimized_entry_blob() const        { return false; }\n+  virtual bool is_upcall_stub() const                 { return false; }\n@@ -168,7 +168,7 @@\n-  nmethod* as_nmethod_or_null()                       { return is_nmethod() ? (nmethod*) this : NULL; }\n-  nmethod* as_nmethod()                               { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n-  CompiledMethod* as_compiled_method_or_null()        { return is_compiled() ? (CompiledMethod*) this : NULL; }\n-  CompiledMethod* as_compiled_method()                { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n-  CodeBlob* as_codeblob_or_null() const               { return (CodeBlob*) this; }\n-  OptimizedEntryBlob* as_optimized_entry_blob() const { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n-  RuntimeStub* as_runtime_stub() const                { assert(is_runtime_stub(), \"must be runtime blob\"); return (RuntimeStub*) this; }\n+  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }\n+  nmethod* as_nmethod()                        { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n+  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }\n+  CompiledMethod* as_compiled_method()         { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n+  CodeBlob* as_codeblob_or_null() const        { return (CodeBlob*) this; }\n+  UpcallStub* as_upcall_stub() const           { assert(is_upcall_stub(), \"must be upcall stub\"); return (UpcallStub*) this; }\n+  RuntimeStub* as_runtime_stub() const         { assert(is_runtime_stub(), \"must be runtime blob\"); return (RuntimeStub*) this; }\n@@ -412,1 +412,1 @@\n-  friend class OptimizedEntryBlob;\n+  friend class UpcallStub;\n@@ -756,1 +756,1 @@\n-class ProgrammableUpcallHandler;\n+class UpcallLinker;\n@@ -758,2 +758,3 @@\n-class OptimizedEntryBlob: public RuntimeBlob {\n-  friend class ProgrammableUpcallHandler;\n+\/\/ A (Panama) upcall stub. Not used by JNI.\n+class UpcallStub: public RuntimeBlob {\n+  friend class UpcallLinker;\n@@ -765,1 +766,1 @@\n-  OptimizedEntryBlob(const char* name, CodeBuffer* cb, int size,\n+  UpcallStub(const char* name, CodeBuffer* cb, int size,\n@@ -782,3 +783,3 @@\n-  static OptimizedEntryBlob* create(const char* name, CodeBuffer* cb,\n-                                    intptr_t exception_handler_offset,\n-                                    jobject receiver, ByteSize frame_data_offset);\n+  static UpcallStub* create(const char* name, CodeBuffer* cb,\n+                            intptr_t exception_handler_offset,\n+                            jobject receiver, ByteSize frame_data_offset);\n@@ -786,1 +787,1 @@\n-  static void free(OptimizedEntryBlob* blob);\n+  static void free(UpcallStub* blob);\n@@ -794,1 +795,1 @@\n-  virtual bool is_optimized_entry_blob() const override { return true; }\n+  virtual bool is_upcall_stub() const override { return true; }\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -134,1 +134,6 @@\n-    if (v > max_intx) {\n+    if (g_isnan(v) || !g_isfinite(v)) {\n+      return max_intx;\n+    }\n+    int exp;\n+    (void) frexp(v, &exp);\n+    if (exp > 63) {\n@@ -136,2 +141,0 @@\n-    } else {\n-      return (intx)(v);\n@@ -139,0 +142,1 @@\n+    return (intx)(v);\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -40,0 +41,2 @@\n+uint G1CardSet::_split_card_shift = 0;\n+size_t G1CardSet::_split_card_mask = 0;\n@@ -370,0 +373,24 @@\n+void G1CardSet::initialize(MemRegion reserved) {\n+  const uint BitsInUint = sizeof(uint) * BitsPerByte;\n+  const uint CardBitsWithinCardRegion = MIN2((uint)HeapRegion::LogCardsPerRegion, G1CardSetContainer::LogCardsPerRegionLimit);\n+\n+  \/\/ Check if the number of cards within a region fits an uint.\n+  if (CardBitsWithinCardRegion > BitsInUint) {\n+    vm_exit_during_initialization(\"Can not represent all cards in a card region within uint.\");\n+  }\n+\n+  _split_card_shift = CardBitsWithinCardRegion;\n+  _split_card_mask = ((size_t)1 << _split_card_shift) - 1;\n+\n+  \/\/ Check if the card region\/region within cards combination can cover the heap.\n+  const uint HeapSizeBits = log2i_exact(round_up_power_of_2(reserved.byte_size()));\n+  if (HeapSizeBits > (BitsInUint + _split_card_shift + G1CardTable::card_shift())) {\n+    FormatBuffer<> fmt(\"Can not represent all cards in the heap with card region\/card within region. \"\n+                       \"Heap %zuB (%u bits) Card set only covers %u bits.\",\n+                       reserved.byte_size(),\n+                       HeapSizeBits,\n+                       BitsInUint + _split_card_shift + G1CardTable::card_shift());\n+    vm_exit_during_initialization(fmt, \"Decrease heap size.\");\n+  }\n+}\n+\n@@ -710,0 +737,22 @@\n+void G1CardSet::split_card(uintptr_t card, uint& card_region, uint& card_within_region) const {\n+  card_region = (uint)(card >> _split_card_shift);\n+  card_within_region = (uint)(card & _split_card_mask);\n+  assert(card_within_region < _config->max_cards_in_region(), \"must be\");\n+}\n+\n+G1AddCardResult G1CardSet::add_card(uintptr_t card) {\n+  uint card_region;\n+  uint card_within_region;\n+  split_card(card, card_region, card_within_region);\n+\n+  return add_card(card_region, card_within_region, true \/* increment_total *\/);\n+}\n+\n+bool G1CardSet::contains_card(uintptr_t card) {\n+  uint card_region;\n+  uint card_within_region;\n+  split_card(card, card_region, card_within_region);\n+\n+  return contains_card(card_region, card_within_region);\n+}\n+\n@@ -788,1 +837,6 @@\n-void G1CardSet::print_info(outputStream* st, uint card_region, uint card_in_region) {\n+void G1CardSet::print_info(outputStream* st, uintptr_t card) {\n+  uint card_region;\n+  uint card_in_region;\n+\n+  split_card(card, card_region, card_in_region);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/memRegion.hpp\"\n@@ -188,0 +189,1 @@\n+  friend class G1CheckCardClosure;\n@@ -193,0 +195,7 @@\n+  \/\/ When splitting addresses into region and card within that region, the logical\n+  \/\/ shift value to get the region.\n+  static uint _split_card_shift;\n+  \/\/ When splitting addresses into region and card within that region, the mask\n+  \/\/ to get the offset within the region.\n+  static size_t _split_card_mask;\n+\n@@ -204,1 +213,1 @@\n-  \/\/ 0...00000 free               (Empty, should never happen)\n+  \/\/ 0...00000 free               (Empty, should never happen on a top-level ContainerPtr)\n@@ -212,1 +221,4 @@\n-  using ContainerPtr = void*;\n+  \/\/\n+  \/\/ The container's pointer starts off with an inline container and is then subsequently\n+  \/\/ coarsened as more cards are added.\n+  \/\/\n@@ -214,3 +226,20 @@\n-  \/\/ ContainerInlinePtr -> ContainerArrayOfCards -> ContainerHowl -> Full\n-  \/\/ Corsening of containers inside the ContainerHowl happens in the order:\n-  \/\/ ContainerInlinePtr -> ContainerArrayOfCards -> ContainerBitMap -> Full\n+  \/\/   ContainerInlinePtr -> ContainerArrayOfCards -> ContainerHowl -> Full\n+  \/\/\n+  \/\/ There is intentionally no bitmap based container that covers a full region; first,\n+  \/\/ a whole region is covered very well (and more flexibly) using the howl container and\n+  \/\/ even then the overhead of the ContainerPtr array with all-bitmaps vs. a single bitmap\n+  \/\/ is negligible, and most importantly transferring such a Howl container to a\n+  \/\/ \"Full Region Bitmap\" is fairly hard without missing entries that are added by\n+  \/\/ concurrent threads.\n+  \/\/\n+  \/\/ Howl containers are basically arrays of containers. An entry starts off with\n+  \/\/ Free. Further corsening of containers inside the ContainerHowl happens in the order:\n+  \/\/\n+  \/\/   Free -> ContainerInlinePtr -> ContainerArrayOfCards -> ContainerBitMap -> Full\n+  \/\/\n+  \/\/ Throughout the code it is assumed (and checked) that the last two bits of the encoding\n+  \/\/ for Howl (0b11) is assumed to be the same as the last two bits for \"FullCardSet\"; this\n+  \/\/ has been done in various places to not be required to check for a \"FullCardSet\" first\n+  \/\/ all the time in iteration code (only if there is a Howl card set container, that is\n+  \/\/ fairly uncommon).\n+  using ContainerPtr = void*;\n@@ -297,0 +326,14 @@\n+  void split_card(uintptr_t card, uint& card_region, uint& card_within_region) const;\n+\n+  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  bool contains_card(uint card_region, uint card_in_region);\n+\n+  \/\/ Testing API\n+  class CardClosure {\n+  public:\n+    virtual void do_card(uint region_idx, uint card_idx) = 0;\n+  };\n+\n+  void iterate_cards(CardClosure& cl);\n+\n@@ -304,0 +347,2 @@\n+  static void initialize(MemRegion reserved);\n+\n@@ -306,1 +351,1 @@\n-  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+  G1AddCardResult add_card(uintptr_t card);\n@@ -308,1 +353,1 @@\n-  bool contains_card(uint card_region, uint card_in_region);\n+  bool contains_card(uintptr_t card);\n@@ -310,1 +355,1 @@\n-  void print_info(outputStream* st, uint card_region, uint card_in_region);\n+  void print_info(outputStream* st, uintptr_t card);\n@@ -355,1 +400,1 @@\n-    virtual void do_containerptr(uint region_idx, size_t num_occupied, ContainerPtr container) = 0;\n+    virtual void do_containerptr(uint card_region_idx, size_t num_occupied, ContainerPtr container) = 0;\n@@ -359,7 +404,0 @@\n-\n-  class CardClosure {\n-  public:\n-    virtual void do_card(uint region_idx, uint card_idx) = 0;\n-  };\n-\n-  void iterate_cards(CardClosure& cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":54,"deletions":16,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1300,10 +1300,0 @@\n-\n-  \/\/ vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS\n-  \/\/\n-  \/\/ NOTE: Only the \"prev\" marking information is guaranteed to be\n-  \/\/ consistent most of the time, so most calls to this should use\n-  \/\/ vo == UsePrevMarking.\n-  \/\/ Currently there is only one place where this is called with\n-  \/\/ vo == UseFullMarking, which is to verify the marking during a\n-  \/\/ full GC.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+\n@@ -55,2 +56,0 @@\n-  \/\/ _vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ _vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS\n@@ -206,0 +205,1 @@\n+\n@@ -207,2 +207,0 @@\n-  \/\/ _vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ _vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS.\n@@ -357,0 +355,1 @@\n+\n@@ -358,2 +357,0 @@\n-  \/\/ _vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ _vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS\n@@ -426,2 +423,0 @@\n-  \/\/ _vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ _vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,10 +62,0 @@\n-\n-  \/\/ vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS\n-  \/\/\n-  \/\/ NOTE: Only the \"prev\" marking information is guaranteed to be\n-  \/\/ consistent most of the time, so most calls to this should use\n-  \/\/ vo == UsePrevMarking.\n-  \/\/ Currently there is only one place where this is called with\n-  \/\/ vo == UseFullMarking, which is to verify the marking during a\n-  \/\/ full GC.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -480,0 +480,1 @@\n+\n@@ -481,2 +482,0 @@\n-  \/\/ _vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ _vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -584,9 +584,0 @@\n-  \/\/ vo == UsePrevMarking -> use \"prev\" marking information,\n-  \/\/ vo == UseFullMarking -> use \"next\" marking bitmap but no TAMS\n-  \/\/\n-  \/\/ NOTE: Only the \"prev\" marking information is guaranteed to be\n-  \/\/ consistent most of the time, so most calls to this should use\n-  \/\/ vo == UsePrevMarking.\n-  \/\/ Currently there is only one place where this is called with\n-  \/\/ vo == UseFullMarking, which is to verify the marking during a\n-  \/\/ full GC.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-uint HeapRegionRemSet::_split_card_shift = 0;\n-size_t HeapRegionRemSet::_split_card_mask = 0;\n@@ -55,22 +53,1 @@\n-  const uint BitsInUint = sizeof(uint) * BitsPerByte;\n-  const uint CardBitsWithinCardRegion = MIN2((uint)HeapRegion::LogCardsPerRegion, G1CardSetContainer::LogCardsPerRegionLimit);\n-\n-  \/\/ Check if the number of cards within a region fits an uint.\n-  if (CardBitsWithinCardRegion > BitsInUint) {\n-    vm_exit_during_initialization(\"Can not represent all cards in a card region within uint.\");\n-  }\n-\n-  _split_card_shift = CardBitsWithinCardRegion + CardTable::card_shift();\n-  _split_card_mask = ((size_t)1 << _split_card_shift) - 1;\n-\n-  \/\/ Check if the card region\/region within cards combination can cover the heap.\n-  const uint HeapSizeBits = log2i_exact(round_up_power_of_2(reserved.byte_size()));\n-  if (HeapSizeBits > (BitsInUint + _split_card_shift)) {\n-    FormatBuffer<> fmt(\"Can not represent all cards in the heap with card region\/card within region. \"\n-                       \"Heap %zuB (%u bits) Remembered set covers %u bits.\",\n-                       reserved.byte_size(),\n-                       HeapSizeBits,\n-                       BitsInUint + _split_card_shift);\n-    vm_exit_during_initialization(fmt, \"Decrease heap size.\");\n-  }\n-\n+  G1CardSet::initialize(reserved);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,6 +54,0 @@\n-  \/\/ When splitting addresses into region and card within that region, the logical\n-  \/\/ shift value to get the region.\n-  static uint _split_card_shift;\n-  \/\/ When splitting addresses into region and card within that region, the mask\n-  \/\/ to get the offset within the region.\n-  static size_t _split_card_mask;\n@@ -98,0 +92,2 @@\n+  inline uintptr_t to_card(OopOrNarrowOopStar from) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,5 +118,3 @@\n-void HeapRegionRemSet::split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const {\n-  size_t offset = pointer_delta(from, _heap_base_address, 1);\n-  card_region = (uint)(offset >> _split_card_shift);\n-  card_within_region = (uint)((offset & _split_card_mask) >> CardTable::card_shift());\n-  assert(card_within_region < G1CardSetContainer::cards_per_region_limit(), \"must be\");\n+\n+uintptr_t HeapRegionRemSet::to_card(OopOrNarrowOopStar from) const {\n+  return pointer_delta(from, _heap_base_address, 1) >> CardTable::card_shift();\n@@ -138,6 +136,1 @@\n-  uint card_region;\n-  uint card_within_region;\n-\n-  split_card(from, card_region, card_within_region);\n-\n-  _card_set.add_card(card_region, card_within_region);\n+  _card_set.add_card(to_card(from));\n@@ -147,6 +140,1 @@\n-  uint card_region;\n-  uint card_within_region;\n-\n-  split_card(from, card_region, card_within_region);\n-\n-  return _card_set.contains_card(card_region, card_within_region);\n+  return _card_set.contains_card(to_card(from));\n@@ -156,6 +144,1 @@\n-  uint card_region;\n-  uint card_within_region;\n-\n-  split_card(from, card_region, card_within_region);\n-\n-  _card_set.print_info(st, card_region, card_within_region);\n+  _card_set.print_info(st, to_card(from));\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-      VerifyOption_Default = 0,\n+  VerifyOption_Default = 0,\n@@ -31,3 +31,7 @@\n-      \/\/ G1\n-      VerifyOption_G1UsePrevMarking = VerifyOption_Default,\n-      VerifyOption_G1UseFullMarking = VerifyOption_G1UsePrevMarking + 1\n+  \/\/ G1\n+\n+  \/\/ Use \"prev\" mark bitmap information using pTAMS.\n+  VerifyOption_G1UsePrevMarking = VerifyOption_Default,\n+  \/\/ Use \"next\" mark bitmap information from full gc marking. This does not\n+  \/\/ use (or need) TAMS.\n+  VerifyOption_G1UseFullMarking = VerifyOption_G1UsePrevMarking + 1\n","filename":"src\/hotspot\/share\/gc\/shared\/verifyOption.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-inline address stackChunkOopDesc::pc() const            { return (address)jdk_internal_vm_StackChunk::pc(as_oop()); }\n-inline void stackChunkOopDesc::set_pc(address value)    { jdk_internal_vm_StackChunk::set_pc(this, (intptr_t)value); }\n+inline address stackChunkOopDesc::pc() const            { return jdk_internal_vm_StackChunk::pc(as_oop()); }\n+inline void stackChunkOopDesc::set_pc(address value)    { jdk_internal_vm_StackChunk::set_pc(this, value); }\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_VM_PRIMS_DOWNCALLLINKER_HPP\n+#define SHARE_VM_PRIMS_DOWNCALLLINKER_HPP\n+\n+#include \"prims\/foreignGlobals.hpp\"\n+\n+class RuntimeStub;\n+\n+class DowncallLinker: AllStatic {\n+public:\n+  static RuntimeStub* make_downcall_stub(BasicType*,\n+                                         int num_args,\n+                                         BasicType ret_bt,\n+                                         const ABIDescriptor& abi,\n+                                         const GrowableArray<VMReg>& input_registers,\n+                                         const GrowableArray<VMReg>& output_registers,\n+                                         bool needs_return_buffer);\n+};\n+\n+#endif \/\/ SHARE_VM_PRIMS_DOWNCALLLINKER_HPP\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"foreign_globals.hpp\"\n+#include \"foreignGlobals.hpp\"\n@@ -28,1 +28,1 @@\n-#include \"prims\/foreign_globals.inline.hpp\"\n+#include \"prims\/foreignGlobals.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","status":"renamed"},{"patch":"@@ -33,1 +33,1 @@\n-#include CPU_HEADER(foreign_globals)\n+#include CPU_HEADER(foreignGlobals)\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","status":"renamed"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"prims\/foreign_globals.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/hotspot\/share\/prims\/foreign_globals.inline.hpp","status":"renamed"},{"patch":"@@ -33,2 +33,2 @@\n-#include \"prims\/foreign_globals.inline.hpp\"\n-#include \"prims\/universalNativeInvoker.hpp\"\n+#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n@@ -37,2 +37,2 @@\n-JNI_ENTRY(jlong, NEP_makeInvoker(JNIEnv* env, jclass _unused, jobject method_type, jobject jabi,\n-                                 jobjectArray arg_moves, jobjectArray ret_moves, jboolean needs_return_buffer))\n+JNI_ENTRY(jlong, NEP_makeDowncallStub(JNIEnv* env, jclass _unused, jobject method_type, jobject jabi,\n+                                      jobjectArray arg_moves, jobjectArray ret_moves, jboolean needs_return_buffer))\n@@ -76,1 +76,1 @@\n-  return (jlong) ProgrammableInvoker::make_native_invoker(\n+  return (jlong) DowncallLinker::make_downcall_stub(\n@@ -80,1 +80,1 @@\n-JNI_ENTRY(jboolean, NEP_freeInvoker(JNIEnv* env, jclass _unused, jlong invoker))\n+JNI_ENTRY(jboolean, NEP_freeDowncallStub(JNIEnv* env, jclass _unused, jlong invoker))\n@@ -97,2 +97,2 @@\n-  {CC \"makeInvoker\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"Z)J\", FN_PTR(NEP_makeInvoker)},\n-  {CC \"freeInvoker0\", CC \"(J)Z\", FN_PTR(NEP_freeInvoker)},\n+  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"Z)J\", FN_PTR(NEP_makeDowncallStub)},\n+  {CC \"freeDowncallStub0\", CC \"(J)Z\", FN_PTR(NEP_freeDowncallStub)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-  void JNICALL JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass unsafecls);\n+  void JNICALL JVM_RegisterUpcallLinkerMethods(JNIEnv *env, jclass unsafecls);\n@@ -223,1 +223,1 @@\n-  { CC\"Java_jdk_internal_foreign_abi_ProgrammableUpcallHandler_registerNatives\",      NULL, FN_PTR(JVM_RegisterProgrammableUpcallHandlerMethods) },\n+  { CC\"Java_jdk_internal_foreign_abi_UpcallLinker_registerNatives\",      NULL, FN_PTR(JVM_RegisterUpcallLinkerMethods) },\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_VM_PRIMS_UNIVERSALNATIVEINVOKER_HPP\n-#define SHARE_VM_PRIMS_UNIVERSALNATIVEINVOKER_HPP\n-\n-#include \"prims\/foreign_globals.hpp\"\n-\n-class RuntimeStub;\n-\n-class ProgrammableInvoker: AllStatic {\n-public:\n-  static RuntimeStub* make_native_invoker(BasicType*,\n-                                          int num_args,\n-                                          BasicType ret_bt,\n-                                          const ABIDescriptor& abi,\n-                                          const GrowableArray<VMReg>& input_registers,\n-                                          const GrowableArray<VMReg>& output_registers,\n-                                          bool needs_return_buffer);\n-};\n-\n-#endif \/\/ SHARE_VM_PRIMS_UNIVERSALNATIVEINVOKER_HPP\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.hpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,199 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"compiler\/compilationPolicy.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"prims\/universalUpcallHandler.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/javaCalls.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#define FOREIGN_ABI \"jdk\/internal\/foreign\/abi\/\"\n-\n-extern struct JavaVM_ main_vm;\n-\n-\/\/ When an upcall is invoked from a thread that is not attached to the VM, we need to attach it,\n-\/\/ and then to detach it at some point later. Detaching a thread as soon as the upcall completes\n-\/\/ is suboptimal, as the same thread could later upcall to Java again, at which point the VM would\n-\/\/ create multiple Java views of the same native thread. For this reason, we use thread local storage\n-\/\/ to keep track of the fact that we have attached a native thread to the VM. When the thread local\n-\/\/ storage is destroyed (which happens when the native threads is terminated), we check if the\n-\/\/ storage has an attached thread and, if so, we detach it from the VM.\n-struct UpcallContext {\n-  Thread* attachedThread;\n-\n-  ~UpcallContext() {\n-    if (attachedThread != NULL) {\n-      JavaVM_ *vm = (JavaVM *)(&main_vm);\n-      vm->functions->DetachCurrentThread(vm);\n-    }\n-  }\n-};\n-\n-APPROVED_CPP_THREAD_LOCAL UpcallContext threadContext;\n-\n-JavaThread* ProgrammableUpcallHandler::maybe_attach_and_get_thread() {\n-  JavaThread* thread = JavaThread::current_or_null();\n-  if (thread == nullptr) {\n-    JavaVM_ *vm = (JavaVM *)(&main_vm);\n-    JNIEnv* p_env = nullptr; \/\/ unused\n-    jint result = vm->functions->AttachCurrentThreadAsDaemon(vm, (void**) &p_env, nullptr);\n-    guarantee(result == JNI_OK, \"Could not attach thread for upcall. JNI error code: %d\", result);\n-    thread = JavaThread::current();\n-    threadContext.attachedThread = thread;\n-    assert(!thread->has_last_Java_frame(), \"newly-attached thread not expected to have last Java frame\");\n-  }\n-  return thread;\n-}\n-\n-\/\/ modelled after JavaCallWrapper::JavaCallWrapper\n-JavaThread* ProgrammableUpcallHandler::on_entry(OptimizedEntryBlob::FrameData* context) {\n-  JavaThread* thread = maybe_attach_and_get_thread();\n-  context->thread = thread;\n-\n-  assert(thread->can_call_java(), \"must be able to call Java\");\n-\n-  \/\/ Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java,\n-  \/\/ since it can potentially block.\n-  context->new_handles = JNIHandleBlock::allocate_block(thread);\n-\n-  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n-  thread->clear_pending_exception();\n-\n-  \/\/ The call to transition_from_native below contains a safepoint check\n-  \/\/ which needs the code cache to be writable.\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n-\n-  \/\/ After this, we are officially in Java Code. This needs to be done before we change any of the thread local\n-  \/\/ info, since we cannot find oops before the new information is set up completely.\n-  ThreadStateTransition::transition_from_native(thread, _thread_in_Java, true \/* check_asyncs *\/);\n-\n-  context->old_handles = thread->active_handles();\n-\n-  \/\/ For the profiler, the last_Java_frame information in thread must always be in\n-  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n-  \/\/ the valid transition is to clear _last_Java_sp and then reset the rest of\n-  \/\/ the (platform specific) state.\n-\n-  context->jfa.copy(thread->frame_anchor());\n-  thread->frame_anchor()->clear();\n-\n-  debug_only(thread->inc_java_call_counter());\n-  thread->set_active_handles(context->new_handles);     \/\/ install new handle block and reset Java frame linkage\n-\n-  return thread;\n-}\n-\n-\/\/ modelled after JavaCallWrapper::~JavaCallWrapper\n-void ProgrammableUpcallHandler::on_exit(OptimizedEntryBlob::FrameData* context) {\n-  JavaThread* thread = context->thread;\n-  assert(thread == JavaThread::current(), \"must still be the same thread\");\n-\n-  \/\/ restore previous handle block\n-  thread->set_active_handles(context->old_handles);\n-\n-  thread->frame_anchor()->zap();\n-\n-  debug_only(thread->dec_java_call_counter());\n-\n-  \/\/ Old thread-local info. has been restored. We are now back in native code.\n-  ThreadStateTransition::transition_from_java(thread, _thread_in_native);\n-\n-  thread->frame_anchor()->copy(&context->jfa);\n-\n-  \/\/ Release handles after we are marked as being in native code again, since this\n-  \/\/ operation might block\n-  JNIHandleBlock::release_block(context->new_handles, thread);\n-\n-  assert(!thread->has_pending_exception(), \"Upcall can not throw an exception\");\n-}\n-\n-void ProgrammableUpcallHandler::handle_uncaught_exception(oop exception) {\n-  ResourceMark rm;\n-  \/\/ Based on CATCH macro\n-  tty->print_cr(\"Uncaught exception:\");\n-  exception->print();\n-  ShouldNotReachHere();\n-}\n-\n-JVM_ENTRY(jlong, PUH_AllocateOptimizedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv,\n-                                                 jboolean needs_return_buffer, jlong ret_buf_size))\n-  ResourceMark rm(THREAD);\n-  Handle mh_h(THREAD, JNIHandles::resolve(mh));\n-  jobject mh_j = JNIHandles::make_global(mh_h);\n-\n-  oop lform = java_lang_invoke_MethodHandle::form(mh_h());\n-  oop vmentry = java_lang_invoke_LambdaForm::vmentry(lform);\n-  Method* entry = java_lang_invoke_MemberName::vmtarget(vmentry);\n-  const methodHandle mh_entry(THREAD, entry);\n-\n-  assert(entry->method_holder()->is_initialized(), \"no clinit barrier\");\n-  CompilationPolicy::compile_if_required(mh_entry, CHECK_0);\n-\n-  assert(entry->is_static(), \"static only\");\n-  \/\/ Fill in the signature array, for the calling-convention call.\n-  const int total_out_args = entry->size_of_parameters();\n-  assert(total_out_args > 0, \"receiver arg\");\n-\n-  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n-  BasicType ret_type;\n-  {\n-    int i = 0;\n-    SignatureStream ss(entry->signature());\n-    for (; !ss.at_return_type(); ss.next()) {\n-      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n-      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n-        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n-    }\n-    assert(i == total_out_args, \"\");\n-    ret_type = ss.type();\n-  }\n-  \/\/ skip receiver\n-  BasicType* in_sig_bt = out_sig_bt + 1;\n-  int total_in_args = total_out_args - 1;\n-\n-  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(\n-    mh_j, entry, in_sig_bt, total_in_args, out_sig_bt, total_out_args, ret_type, abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size));\n-JVM_END\n-\n-#define CC (char*)  \/*cast a literal from (const char*)*\/\n-#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &f)\n-\n-static JNINativeMethod PUH_methods[] = {\n-  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \"ZJ)J\", FN_PTR(PUH_AllocateOptimizedUpcallStub)},\n-};\n-\n-\/**\n- * This one function is exported, used by NativeLookup.\n- *\/\n-JNI_ENTRY(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n-  ThreadToNativeFromVM ttnfv(thread);\n-  int status = env->RegisterNatives(PUH_class, PUH_methods, sizeof(PUH_methods)\/sizeof(JNINativeMethod));\n-  guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n-            \"register jdk.internal.foreign.abi.ProgrammableUpcallHandler natives\");\n-JNI_END\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":0,"deletions":199,"binary":false,"changes":199,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_VM_PRIMS_UNIVERSALUPCALLHANDLER_HPP\n-#define SHARE_VM_PRIMS_UNIVERSALUPCALLHANDLER_HPP\n-\n-#include \"asm\/codeBuffer.hpp\"\n-#include \"code\/codeBlob.hpp\"\n-#include \"prims\/foreign_globals.hpp\"\n-\n-class JavaThread;\n-\n-class ProgrammableUpcallHandler {\n-private:\n-  static void handle_uncaught_exception(oop exception);\n-  static JavaThread* maybe_attach_and_get_thread();\n-\n-  static JavaThread* on_entry(OptimizedEntryBlob::FrameData* context);\n-  static void on_exit(OptimizedEntryBlob::FrameData* context);\n-public:\n-  static address generate_optimized_upcall_stub(jobject mh, Method* entry,\n-                                                BasicType* in_sig_bt, int total_in_args,\n-                                                BasicType* out_sig_bt, int total_out_args,\n-                                                BasicType ret_type,\n-                                                jobject jabi, jobject jconv,\n-                                                bool needs_return_buffer, int ret_buf_size);\n-};\n-\n-#endif \/\/ SHARE_VM_PRIMS_UNIVERSALUPCALLHANDLER_HPP\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"compiler\/compilationPolicy.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define FOREIGN_ABI \"jdk\/internal\/foreign\/abi\/\"\n+\n+extern struct JavaVM_ main_vm;\n+\n+\/\/ When an upcall is invoked from a thread that is not attached to the VM, we need to attach it,\n+\/\/ and then to detach it at some point later. Detaching a thread as soon as the upcall completes\n+\/\/ is suboptimal, as the same thread could later upcall to Java again, at which point the VM would\n+\/\/ create multiple Java views of the same native thread. For this reason, we use thread local storage\n+\/\/ to keep track of the fact that we have attached a native thread to the VM. When the thread local\n+\/\/ storage is destroyed (which happens when the native threads is terminated), we check if the\n+\/\/ storage has an attached thread and, if so, we detach it from the VM.\n+struct UpcallContext {\n+  Thread* attachedThread;\n+\n+  ~UpcallContext() {\n+    if (attachedThread != NULL) {\n+      JavaVM_ *vm = (JavaVM *)(&main_vm);\n+      vm->functions->DetachCurrentThread(vm);\n+    }\n+  }\n+};\n+\n+APPROVED_CPP_THREAD_LOCAL UpcallContext threadContext;\n+\n+JavaThread* UpcallLinker::maybe_attach_and_get_thread() {\n+  JavaThread* thread = JavaThread::current_or_null();\n+  if (thread == nullptr) {\n+    JavaVM_ *vm = (JavaVM *)(&main_vm);\n+    JNIEnv* p_env = nullptr; \/\/ unused\n+    jint result = vm->functions->AttachCurrentThreadAsDaemon(vm, (void**) &p_env, nullptr);\n+    guarantee(result == JNI_OK, \"Could not attach thread for upcall. JNI error code: %d\", result);\n+    thread = JavaThread::current();\n+    threadContext.attachedThread = thread;\n+    assert(!thread->has_last_Java_frame(), \"newly-attached thread not expected to have last Java frame\");\n+  }\n+  return thread;\n+}\n+\n+\/\/ modelled after JavaCallWrapper::JavaCallWrapper\n+JavaThread* UpcallLinker::on_entry(UpcallStub::FrameData* context) {\n+  JavaThread* thread = maybe_attach_and_get_thread();\n+  context->thread = thread;\n+\n+  assert(thread->can_call_java(), \"must be able to call Java\");\n+\n+  \/\/ Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java,\n+  \/\/ since it can potentially block.\n+  context->new_handles = JNIHandleBlock::allocate_block(thread);\n+\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  thread->clear_pending_exception();\n+\n+  \/\/ The call to transition_from_native below contains a safepoint check\n+  \/\/ which needs the code cache to be writable.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n+  \/\/ After this, we are officially in Java Code. This needs to be done before we change any of the thread local\n+  \/\/ info, since we cannot find oops before the new information is set up completely.\n+  ThreadStateTransition::transition_from_native(thread, _thread_in_Java, true \/* check_asyncs *\/);\n+\n+  context->old_handles = thread->active_handles();\n+\n+  \/\/ For the profiler, the last_Java_frame information in thread must always be in\n+  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n+  \/\/ the valid transition is to clear _last_Java_sp and then reset the rest of\n+  \/\/ the (platform specific) state.\n+\n+  context->jfa.copy(thread->frame_anchor());\n+  thread->frame_anchor()->clear();\n+\n+  debug_only(thread->inc_java_call_counter());\n+  thread->set_active_handles(context->new_handles);     \/\/ install new handle block and reset Java frame linkage\n+\n+  return thread;\n+}\n+\n+\/\/ modelled after JavaCallWrapper::~JavaCallWrapper\n+void UpcallLinker::on_exit(UpcallStub::FrameData* context) {\n+  JavaThread* thread = context->thread;\n+  assert(thread == JavaThread::current(), \"must still be the same thread\");\n+\n+  \/\/ restore previous handle block\n+  thread->set_active_handles(context->old_handles);\n+\n+  thread->frame_anchor()->zap();\n+\n+  debug_only(thread->dec_java_call_counter());\n+\n+  \/\/ Old thread-local info. has been restored. We are now back in native code.\n+  ThreadStateTransition::transition_from_java(thread, _thread_in_native);\n+\n+  thread->frame_anchor()->copy(&context->jfa);\n+\n+  \/\/ Release handles after we are marked as being in native code again, since this\n+  \/\/ operation might block\n+  JNIHandleBlock::release_block(context->new_handles, thread);\n+\n+  assert(!thread->has_pending_exception(), \"Upcall can not throw an exception\");\n+}\n+\n+void UpcallLinker::handle_uncaught_exception(oop exception) {\n+  ResourceMark rm;\n+  \/\/ Based on CATCH macro\n+  tty->print_cr(\"Uncaught exception:\");\n+  exception->print();\n+  ShouldNotReachHere();\n+}\n+\n+JVM_ENTRY(jlong, UL_MakeUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv,\n+                                                 jboolean needs_return_buffer, jlong ret_buf_size))\n+  ResourceMark rm(THREAD);\n+  Handle mh_h(THREAD, JNIHandles::resolve(mh));\n+  jobject mh_j = JNIHandles::make_global(mh_h);\n+\n+  oop lform = java_lang_invoke_MethodHandle::form(mh_h());\n+  oop vmentry = java_lang_invoke_LambdaForm::vmentry(lform);\n+  Method* entry = java_lang_invoke_MemberName::vmtarget(vmentry);\n+  const methodHandle mh_entry(THREAD, entry);\n+\n+  assert(entry->method_holder()->is_initialized(), \"no clinit barrier\");\n+  CompilationPolicy::compile_if_required(mh_entry, CHECK_0);\n+\n+  assert(entry->is_static(), \"static only\");\n+  \/\/ Fill in the signature array, for the calling-convention call.\n+  const int total_out_args = entry->size_of_parameters();\n+  assert(total_out_args > 0, \"receiver arg\");\n+\n+  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n+  BasicType ret_type;\n+  {\n+    int i = 0;\n+    SignatureStream ss(entry->signature());\n+    for (; !ss.at_return_type(); ss.next()) {\n+      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n+        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+    }\n+    assert(i == total_out_args, \"\");\n+    ret_type = ss.type();\n+  }\n+  \/\/ skip receiver\n+  BasicType* in_sig_bt = out_sig_bt + 1;\n+  int total_in_args = total_out_args - 1;\n+\n+  return (jlong) UpcallLinker::make_upcall_stub(\n+    mh_j, entry, in_sig_bt, total_in_args, out_sig_bt, total_out_args, ret_type, abi, conv, needs_return_buffer, checked_cast<int>(ret_buf_size));\n+JVM_END\n+\n+#define CC (char*)  \/*cast a literal from (const char*)*\/\n+#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &f)\n+\n+static JNINativeMethod UL_methods[] = {\n+  {CC \"makeUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"UpcallLinker$CallRegs;\" \"ZJ)J\", FN_PTR(UL_MakeUpcallStub)},\n+};\n+\n+\/**\n+ * This one function is exported, used by NativeLookup.\n+ *\/\n+JNI_ENTRY(void, JVM_RegisterUpcallLinkerMethods(JNIEnv *env, jclass UL_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n+  int status = env->RegisterNatives(UL_class, UL_methods, sizeof(UL_methods)\/sizeof(JNINativeMethod));\n+  guarantee(status == JNI_OK && !env->ExceptionOccurred(),\n+            \"register jdk.internal.foreign.abi.UpcallLinker natives\");\n+JNI_END\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_VM_PRIMS_UPCALLLINKER_HPP\n+#define SHARE_VM_PRIMS_UPCALLLINKER_HPP\n+\n+#include \"asm\/codeBuffer.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"prims\/foreignGlobals.hpp\"\n+\n+class JavaThread;\n+\n+class UpcallLinker {\n+private:\n+  static void handle_uncaught_exception(oop exception);\n+  static JavaThread* maybe_attach_and_get_thread();\n+\n+  static JavaThread* on_entry(UpcallStub::FrameData* context);\n+  static void on_exit(UpcallStub::FrameData* context);\n+public:\n+  static address make_upcall_stub(jobject mh, Method* entry,\n+                                  BasicType* in_sig_bt, int total_in_args,\n+                                  BasicType* out_sig_bt, int total_out_args,\n+                                  BasicType ret_type,\n+                                  jobject jabi, jobject jconv,\n+                                  bool needs_return_buffer, int ret_buf_size);\n+};\n+\n+#endif \/\/ SHARE_VM_PRIMS_UPCALLLINKER_HPP\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-  OptimizedEntryBlob::free(cb->as_optimized_entry_blob());\n+  UpcallStub::free(cb->as_upcall_stub());\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1156,2 +1156,2 @@\n-  } else if (is_optimized_entry_frame()) {\n-    _cb->as_optimized_entry_blob()->oops_do(f, *this);\n+  } else if (is_upcall_stub_frame()) {\n+    _cb->as_upcall_stub()->oops_do(f, *this);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  bool is_optimized_entry_frame()  const;\n+  bool is_upcall_stub_frame()    const;\n@@ -203,1 +203,1 @@\n-    return is_compiled_frame() || is_optimized_entry_frame();\n+    return is_compiled_frame() || is_upcall_stub_frame();\n@@ -241,1 +241,1 @@\n-  frame sender_for_optimized_entry_frame(RegisterMap* map) const;\n+  frame sender_for_upcall_stub_frame(RegisterMap* map) const;\n@@ -423,1 +423,1 @@\n-  bool optimized_entry_frame_is_first() const;\n+  bool upcall_stub_frame_is_first() const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-      \/\/ Optimized entry frames are only present on certain platforms\n-      || (is_optimized_entry_frame() && optimized_entry_frame_is_first());\n+      \/\/ Upcall stub frames entry frames are only present on certain platforms\n+      || (is_upcall_stub_frame() && upcall_stub_frame_is_first());\n@@ -61,2 +61,2 @@\n-inline bool frame::is_optimized_entry_frame() const {\n-  return _cb != NULL && _cb->is_optimized_entry_blob();\n+inline bool frame::is_upcall_stub_frame() const {\n+  return _cb != NULL && _cb->is_upcall_stub();\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#include \"prims\/universalNativeInvoker.hpp\"\n+#include \"prims\/downcallLinker.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-class ProgrammableUpcallHandler;\n+class UpcallLinker;\n@@ -56,1 +56,1 @@\n-friend class ProgrammableUpcallHandler;\n+friend class UpcallLinker;\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -516,2 +516,2 @@\n-  if (blob != NULL && blob->is_optimized_entry_blob()) {\n-    return ((OptimizedEntryBlob*)blob)->exception_handler();\n+  if (blob != NULL && blob->is_upcall_stub()) {\n+    return ((UpcallStub*)blob)->exception_handler();\n@@ -1462,1 +1462,1 @@\n-  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame() && !caller_frame.is_optimized_entry_frame(), \"unexpected frame\");\n+  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame() && !caller_frame.is_upcall_stub_frame(), \"unexpected frame\");\n@@ -1495,1 +1495,1 @@\n-      caller_frame.is_optimized_entry_frame()) {\n+      caller_frame.is_upcall_stub_frame()) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.Buffer;\n@@ -65,1 +66,1 @@\n- *     <li>{@linkplain MemorySegment#ofByteBuffer(ByteBuffer) buffer segments}, wrapping an existing {@link ByteBuffer} instance;\n+ *     <li>{@linkplain MemorySegment#ofBuffer(Buffer) buffer segments}, wrapping an existing {@link Buffer} instance;\n@@ -67,1 +68,1 @@\n- * wrapped byte buffer instance. For instance, a buffer memory segment obtained from a byte buffer created with the\n+ * wrapped buffer instance. For instance, a buffer memory segment obtained from a byte buffer created with the\n@@ -87,2 +88,5 @@\n- * Heap and buffer segments are always associated with a <em>global<\/em>, shared memory session. This session cannot be closed,\n- * and segments associated with it can be considered as <em>always alive<\/em>.\n+ * Heap segments are always associated with the {@linkplain MemorySession#global() global} memory session.\n+ * This session cannot be closed, and segments associated with it can be considered as <em>always alive<\/em>.\n+ * Buffer segments are typically associated with the global memory session, with one exception: buffer segments created\n+ * from byte buffer instances obtained calling the {@link #asByteBuffer()} method on a memory segment {@code S}\n+ * are associated with the same memory session as {@code S}.\n@@ -347,1 +351,1 @@\n-     * derived from a {@linkplain ByteBuffer#allocateDirect(int) direct byte buffer} using the {@link #ofByteBuffer(ByteBuffer)} factory,\n+     * derived from a {@linkplain ByteBuffer#allocateDirect(int) direct byte buffer} using the {@link #ofBuffer(Buffer)} factory,\n@@ -356,1 +360,1 @@\n-     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofBuffer(Buffer)} factory.\n@@ -710,3 +714,2 @@\n-     * Creates a buffer memory segment that models the memory associated with the given byte\n-     * buffer. The segment starts relative to the buffer's position (inclusive)\n-     * and ends relative to the buffer's limit (exclusive).\n+     * Creates a buffer memory segment that models the memory associated with the given {@link Buffer} instance.\n+     * The segment starts relative to the buffer's position (inclusive) and ends relative to the buffer's limit (exclusive).\n@@ -721,1 +724,1 @@\n-     * @param bb the byte buffer backing the buffer memory segment.\n+     * @param buffer the buffer instance backing the buffer memory segment.\n@@ -724,2 +727,2 @@\n-    static MemorySegment ofByteBuffer(ByteBuffer bb) {\n-        return AbstractMemorySegmentImpl.ofBuffer(bb);\n+    static MemorySegment ofBuffer(Buffer buffer) {\n+        return AbstractMemorySegmentImpl.ofBuffer(buffer);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -807,2 +807,2 @@\n-                public Object getBufferBase(ByteBuffer bb) {\n-                    return bb.base();\n+                public Object getBufferBase(Buffer buffer) {\n+                    return buffer.base();\n@@ -812,2 +812,2 @@\n-                public long getBufferAddress(ByteBuffer bb) {\n-                    return bb.address;\n+                public long getBufferAddress(Buffer buffer) {\n+                    return buffer.address;\n@@ -817,3 +817,3 @@\n-                public UnmapperProxy unmapper(ByteBuffer bb) {\n-                    if (bb instanceof MappedByteBuffer) {\n-                        return ((MappedByteBuffer)bb).unmapper();\n+                public UnmapperProxy unmapper(Buffer buffer) {\n+                    if (buffer instanceof MappedByteBuffer mbb) {\n+                        return mbb.unmapper();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    Object getBufferBase(ByteBuffer bb);\n+    Object getBufferBase(Buffer bb);\n@@ -76,1 +76,1 @@\n-    long getBufferAddress(ByteBuffer bb);\n+    long getBufferAddress(Buffer buffer);\n@@ -81,1 +81,1 @@\n-    UnmapperProxy unmapper(ByteBuffer bb);\n+    UnmapperProxy unmapper(Buffer buffer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.Buffer;\n@@ -36,0 +37,6 @@\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n@@ -520,1 +527,1 @@\n-    public static AbstractMemorySegmentImpl ofBuffer(ByteBuffer bb) {\n+    public static AbstractMemorySegmentImpl ofBuffer(Buffer bb) {\n@@ -543,0 +550,1 @@\n+        int scaleFactor = getScaleFactor(bb);\n@@ -544,1 +552,17 @@\n-            return new HeapMemorySegmentImpl.OfByte(bbAddress + pos, (byte[])base, size, modes);\n+            if (base instanceof byte[]) {\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof short[]) {\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof char[]) {\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof int[]) {\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof float[]) {\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof long[]) {\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else if (base instanceof double[]) {\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, modes);\n+            } else {\n+                throw new AssertionError(\"Cannot get here\");\n+            }\n@@ -546,1 +570,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + pos, size, modes, bufferSession);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, modes, bufferSession);\n@@ -548,0 +572,1 @@\n+            \/\/ we can ignore scale factor here, a mapped buffer is always a byte buffer, so scaleFactor == 0.\n@@ -551,0 +576,20 @@\n+\n+    private static int getScaleFactor(Buffer buffer) {\n+        if (buffer instanceof ByteBuffer) {\n+            return 0;\n+        } else if (buffer instanceof CharBuffer) {\n+            return 1;\n+        } else if (buffer instanceof ShortBuffer) {\n+            return 1;\n+        } else if (buffer instanceof IntBuffer) {\n+            return 2;\n+        } else if (buffer instanceof FloatBuffer) {\n+            return 2;\n+        } else if (buffer instanceof LongBuffer) {\n+            return 3;\n+        } else if (buffer instanceof DoubleBuffer) {\n+            return 3;\n+        } else {\n+            throw new AssertionError(\"Cannot get here\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -47,6 +47,1 @@\n-\/**\n- * This class implements native call invocation through a so called 'universal adapter'. A universal adapter takes\n- * an array of longs together with a call 'recipe', which is used to move the arguments in the right places as\n- * expected by the system ABI.\n- *\/\n-public class ProgrammableInvoker {\n+public class DowncallLinker {\n@@ -54,1 +49,1 @@\n-        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableInvoker.USE_SPEC\", \"true\"));\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.DowncallLinker.USE_SPEC\", \"true\"));\n@@ -65,1 +60,1 @@\n-            MH_INVOKE_INTERP_BINDINGS = lookup.findVirtual(ProgrammableInvoker.class, \"invokeInterpBindings\",\n+            MH_INVOKE_INTERP_BINDINGS = lookup.findVirtual(DowncallLinker.class, \"invokeInterpBindings\",\n@@ -77,1 +72,1 @@\n-    public ProgrammableInvoker(ABIDescriptor abi, CallingSequence callingSequence) {\n+    public DowncallLinker(ABIDescriptor abi, CallingSequence callingSequence) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":4,"deletions":9,"binary":false,"changes":13,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","status":"renamed"},{"patch":"@@ -36,1 +36,1 @@\n- * This class describes a 'native invoker', which is used as an appendix argument to linkToNative calls.\n+ * This class describes a 'native entry point', which is used as an appendix argument to linkToNative calls.\n@@ -44,1 +44,1 @@\n-    private final long invoker; \/\/ read by VM\n+    private final long downcallStubAddress; \/\/ read by VM\n@@ -47,1 +47,1 @@\n-    private static final SoftReferenceCache<CacheKey, NativeEntryPoint> INVOKER_CACHE = new SoftReferenceCache<>();\n+    private static final SoftReferenceCache<CacheKey, NativeEntryPoint> NEP_CACHE = new SoftReferenceCache<>();\n@@ -52,1 +52,1 @@\n-    private NativeEntryPoint(MethodType methodType, long invoker) {\n+    private NativeEntryPoint(MethodType methodType, long downcallStubAddress) {\n@@ -54,1 +54,1 @@\n-        this.invoker = invoker;\n+        this.downcallStubAddress = downcallStubAddress;\n@@ -68,4 +68,4 @@\n-        return INVOKER_CACHE.get(key, k -> {\n-            long invoker = makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer);\n-            NativeEntryPoint nep = new NativeEntryPoint(methodType, invoker);\n-            CLEANER.register(nep, () -> freeInvoker(invoker));\n+        return NEP_CACHE.get(key, k -> {\n+            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer);\n+            NativeEntryPoint nep = new NativeEntryPoint(methodType, downcallStub);\n+            CLEANER.register(nep, () -> freeDowncallStub(downcallStub));\n@@ -76,3 +76,3 @@\n-    private static native long makeInvoker(MethodType methodType, ABIDescriptor abi,\n-                                           VMStorage[] encArgMoves, VMStorage[] encRetMoves,\n-                                           boolean needsReturnBuffer);\n+    private static native long makeDowncallStub(MethodType methodType, ABIDescriptor abi,\n+                                                VMStorage[] encArgMoves, VMStorage[] encRetMoves,\n+                                                boolean needsReturnBuffer);\n@@ -80,4 +80,4 @@\n-    private static native boolean freeInvoker0(long invoker);\n-    private static void freeInvoker(long invoker) {\n-        if (!freeInvoker0(invoker)) {\n-            throw new InternalError(\"Could not free invoker\");\n+    private static native boolean freeDowncallStub0(long downcallStub);\n+    private static void freeDowncallStub(long downcallStub) {\n+        if (!freeDowncallStub0(downcallStub)) {\n+            throw new InternalError(\"Could not free downcall stub\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-public class ProgrammableUpcallHandler {\n+public class UpcallLinker {\n@@ -48,1 +48,1 @@\n-        privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.DEBUG\");\n+        privilegedGetProperty(\"jdk.internal.foreign.UpcallLinker.DEBUG\");\n@@ -50,1 +50,1 @@\n-        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC\", \"true\"));\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.UpcallLinker.USE_SPEC\", \"true\"));\n@@ -57,1 +57,1 @@\n-            MH_invokeInterpBindings = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeInterpBindings\",\n+            MH_invokeInterpBindings = lookup.findStatic(UpcallLinker.class, \"invokeInterpBindings\",\n@@ -94,1 +94,1 @@\n-        long entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv,\n+        long entryPoint = makeUpcallStub(doBindings, abi, conv,\n@@ -201,2 +201,2 @@\n-    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv,\n-                                                   boolean needsReturnBuffer, long returnBufferSize);\n+    static native long makeUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv,\n+                                      boolean needsReturnBuffer, long returnBufferSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","status":"renamed"},{"patch":"@@ -37,1 +37,2 @@\n-import jdk.internal.foreign.abi.ProgrammableUpcallHandler;\n+import jdk.internal.foreign.abi.DowncallLinker;\n+import jdk.internal.foreign.abi.UpcallLinker;\n@@ -43,1 +44,0 @@\n-import jdk.internal.foreign.abi.ProgrammableInvoker;\n@@ -55,2 +55,2 @@\n- * For the AArch64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2\n- * to translate a C FunctionDescriptor into a CallingSequence2, which can then be turned into a MethodHandle.\n+ * For the AArch64 C ABI specifically, this class uses CallingSequenceBuilder\n+ * to translate a C FunctionDescriptor into a CallingSequence, which can then be turned into a MethodHandle.\n@@ -150,1 +150,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(C, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new DowncallLinker(C, bindings.callingSequence).getBoundMethodHandle();\n@@ -166,1 +166,1 @@\n-        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(C, target, bindings.callingSequence, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,9 @@\n+import jdk.internal.foreign.abi.ABIDescriptor;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.CallingSequenceBuilder;\n+import jdk.internal.foreign.abi.DowncallLinker;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallLinker;\n+import jdk.internal.foreign.abi.VMStorage;\n+\n@@ -34,9 +43,0 @@\n-import jdk.internal.foreign.abi.ABIDescriptor;\n-import jdk.internal.foreign.abi.CallingSequence;\n-import jdk.internal.foreign.abi.CallingSequenceBuilder;\n-import jdk.internal.foreign.abi.VMStorage;\n-import jdk.internal.foreign.abi.Binding;\n-import jdk.internal.foreign.abi.ProgrammableInvoker;\n-import jdk.internal.foreign.abi.ProgrammableUpcallHandler;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n@@ -49,2 +49,2 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.PlatformLayouts.SysV;\n+import static jdk.internal.foreign.abi.Binding.vmStore;\n@@ -54,1 +54,1 @@\n- * For the SysV x64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2\n+ * For the SysV x64 C ABI specifically, this class uses namely CallingSequenceBuilder\n@@ -124,1 +124,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CSysV, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new DowncallLinker(CSysV, bindings.callingSequence).getBoundMethodHandle();\n@@ -141,1 +141,1 @@\n-        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(CSysV, target, bindings.callingSequence, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -27,6 +27,0 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemorySession;\n@@ -34,1 +28,0 @@\n-import jdk.internal.foreign.abi.CallingSequenceBuilder;\n@@ -38,2 +31,4 @@\n-import jdk.internal.foreign.abi.ProgrammableInvoker;\n-import jdk.internal.foreign.abi.ProgrammableUpcallHandler;\n+import jdk.internal.foreign.abi.CallingSequenceBuilder;\n+import jdk.internal.foreign.abi.DowncallLinker;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.UpcallLinker;\n@@ -42,1 +37,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n@@ -44,0 +38,6 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n@@ -49,1 +49,1 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n+import static jdk.internal.foreign.PlatformLayouts.Win64;\n@@ -53,2 +53,2 @@\n- * For the Windowx x64 C ABI specifically, this class uses the ProgrammableInvoker API, namely CallingSequenceBuilder2\n- * to translate a C FunctionDescriptor into a CallingSequence2, which can then be turned into a MethodHandle.\n+ * For the Windowx x64 C ABI specifically, this class uses CallingSequenceBuilder\n+ * to translate a C FunctionDescriptor into a CallingSequence, which can then be turned into a MethodHandle.\n@@ -127,1 +127,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CWindows, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new DowncallLinker(CWindows, bindings.callingSequence).getBoundMethodHandle();\n@@ -143,1 +143,1 @@\n-        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(CWindows, target, bindings.callingSequence, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -128,4 +128,1 @@\n-            String zid = zoneId;\n-            if (aliases.containsKey(zoneId)) {\n-                zid = aliases.get(zoneId);\n-            }\n+            String zid = aliases.getOrDefault(zoneId, zoneId);\n@@ -345,1 +342,1 @@\n-        \/\/ are exclued from the \"old\" ZoneInfo\n+        \/\/ are excluded from the \"old\" ZoneInfo\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, JetBrains s.r.o.. All rights reserved.\n@@ -32,0 +32,1 @@\n+    BOOL cacheValid;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TableAccessibility.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, JetBrains s.r.o.. All rights reserved.\n@@ -133,0 +133,9 @@\n+        cacheValid = YES;\n+    }\n+\n+    if (!cacheValid) {\n+        for (NSNumber *key in [rowCache allKeys]) {\n+            [[rowCache objectForKey:key] release];\n+            [rowCache removeObjectForKey:key];\n+        }\n+        cacheValid = YES;\n@@ -226,5 +235,1 @@\n-    for (NSNumber *key in [rowCache allKeys]) {\n-        [[rowCache objectForKey:key] release];\n-    }\n-    [rowCache release];\n-    rowCache = nil;\n+    cacheValid = NO;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/TableAccessibility.m","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+        if ((*env)->ExceptionCheck(env)) { \\\n+            (*env)->ExceptionClear(env); \\\n+        } \\\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/awt.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1428,1 +1428,0 @@\n-        (*env)->CallVoidMethod(env, this, midAddVisual, (visInfo[i]).visual);\n@@ -1432,0 +1431,1 @@\n+        (*env)->CallVoidMethod(env, this, midAddVisual, (visInfo[i]).visual);\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-                        env.messages.report(MISSING, Kind.WARNING, tree, \"dc.empty.description\");\n+                        env.messages.report(MISSING, Kind.WARNING, tree, \"dc.empty.main.description\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-dc.empty.description = no initial description\n+dc.empty.main.description = no main description\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-dc.empty.description = keine anf\\u00E4ngliche Beschreibung\n+dc.empty.main.description = keine anf\\u00E4ngliche Beschreibung\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint_de.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-dc.empty.description = \\u521D\\u671F\\u306E\\u8AAC\\u660E\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\n+dc.empty.main.description = \\u521D\\u671F\\u306E\\u8AAC\\u660E\\u304C\\u3042\\u308A\\u307E\\u305B\\u3093\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint_ja.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-dc.empty.description = \\u6CA1\\u6709\\u521D\\u59CB\\u8BF4\\u660E\n+dc.empty.main.description = \\u6CA1\\u6709\\u521D\\u59CB\\u8BF4\\u660E\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/resources\/doclint_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    private static final Method METHOD_ENABLED = new Method(\"enabled\", Type.BOOLEAN_TYPE, new Type[0]);\n+    private static final Method METHOD_SHOULD_COMMIT_LONG = new Method(\"shouldCommit\", Type.BOOLEAN_TYPE, new Type[] { Type.LONG_TYPE });\n@@ -115,0 +117,1 @@\n+    private final boolean isJDK;\n@@ -116,1 +119,1 @@\n-    EventInstrumentation(Class<?> superClass, byte[] bytes, long id, boolean bootClass, boolean guardEventConfiguration) {\n+    EventInstrumentation(Class<?> superClass, byte[] bytes, long id, boolean isJDK, boolean guardEventConfiguration) {\n@@ -124,1 +127,1 @@\n-        this.staticCommitMethod = bootClass ? findStaticCommitMethod(classNode, fieldInfos) : null;\n+        this.staticCommitMethod = isJDK ? findStaticCommitMethod(classNode, fieldInfos) : null;\n@@ -130,0 +133,1 @@\n+        this.isJDK = isJDK;\n@@ -337,16 +341,2 @@\n-        updateMethod(METHOD_IS_ENABLED, methodVisitor -> {\n-            Label nullLabel = new Label();\n-            if (guardEventConfiguration) {\n-                getEventConfiguration(methodVisitor);\n-                methodVisitor.visitJumpInsn(Opcodes.IFNULL, nullLabel);\n-            }\n-            getEventConfiguration(methodVisitor);\n-            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n-            methodVisitor.visitInsn(Opcodes.IRETURN);\n-            if (guardEventConfiguration) {\n-                methodVisitor.visitLabel(nullLabel);\n-                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n-                methodVisitor.visitInsn(Opcodes.ICONST_0);\n-                methodVisitor.visitInsn(Opcodes.IRETURN);\n-            }\n-        });\n+        \/\/ MyEvent#isEnabled()\n+        updateEnabledMethod(METHOD_IS_ENABLED);\n@@ -671,0 +661,68 @@\n+\n+        if (isJDK) {\n+            if (hasStaticMethod(METHOD_ENABLED)) {\n+                updateEnabledMethod(METHOD_ENABLED);\n+            };\n+            updateIfStaticMethodExists(METHOD_SHOULD_COMMIT_LONG, methodVisitor -> {\n+                Label fail = new Label();\n+                if (guardEventConfiguration) {\n+                    \/\/ if (eventConfiguration == null) goto fail;\n+                    getEventConfiguration(methodVisitor);\n+                    methodVisitor.visitJumpInsn(Opcodes.IFNULL, fail);\n+                }\n+                \/\/ return eventConfiguration.shouldCommit(duration);\n+                getEventConfiguration(methodVisitor);\n+                methodVisitor.visitVarInsn(Opcodes.LLOAD, 0);\n+                invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_EVENT_CONFIGURATION_SHOULD_COMMIT);\n+                methodVisitor.visitInsn(Opcodes.IRETURN);\n+                \/\/ fail:\n+                methodVisitor.visitLabel(fail);\n+                \/\/ return false\n+                methodVisitor.visitInsn(Opcodes.ICONST_0);\n+                methodVisitor.visitInsn(Opcodes.IRETURN);\n+                methodVisitor.visitMaxs(0, 0);\n+                methodVisitor.visitEnd();\n+            });\n+            updateIfStaticMethodExists(METHOD_TIME_STAMP, methodVisitor -> {\n+                invokeStatic(methodVisitor, TYPE_EVENT_CONFIGURATION.getInternalName(), METHOD_TIME_STAMP);\n+                methodVisitor.visitInsn(Opcodes.LRETURN);\n+                methodVisitor.visitMaxs(0, 0);\n+                methodVisitor.visitEnd();\n+            });\n+        }\n+    }\n+\n+    private void updateEnabledMethod(Method method) {\n+        updateMethod(method, methodVisitor -> {\n+            Label nullLabel = new Label();\n+            if (guardEventConfiguration) {\n+                getEventConfiguration(methodVisitor);\n+                methodVisitor.visitJumpInsn(Opcodes.IFNULL, nullLabel);\n+            }\n+            getEventConfiguration(methodVisitor);\n+            invokeVirtual(methodVisitor, TYPE_EVENT_CONFIGURATION, METHOD_IS_ENABLED);\n+            methodVisitor.visitInsn(Opcodes.IRETURN);\n+            if (guardEventConfiguration) {\n+                methodVisitor.visitLabel(nullLabel);\n+                methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);\n+                methodVisitor.visitInsn(Opcodes.ICONST_0);\n+                methodVisitor.visitInsn(Opcodes.IRETURN);\n+            }\n+            methodVisitor.visitMaxs(0, 0);\n+            methodVisitor.visitEnd();\n+        });\n+    }\n+\n+    private void updateIfStaticMethodExists(Method method, Consumer<MethodVisitor> code) {\n+        if (hasStaticMethod(method)) {\n+            updateMethod(method, code);\n+        }\n+    }\n+\n+    private boolean hasStaticMethod(Method method) {\n+        for (MethodNode m : classNode.methods) {\n+            if (m.name.equals(method.getName()) && m.desc.equals(method.getDescriptor())) {\n+                return Modifier.isStatic(m.access);\n+            }\n+        }\n+        return false;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":76,"deletions":18,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-        CDSArchiveUtils.insertBytesRandomlyAfterHeader(orgJsaFile, insertBytes, new byte[4096]);\n+        CDSArchiveUtils.insertBytesRandomlyAfterHeader(orgJsaFile, insertBytes);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -631,0 +631,2 @@\n+sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/Distrust.java    8287109 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,21 @@\n+    public void  createUIDraggable() {\n+        INSTRUCTIONS = \"INSTRUCTIONS:\\n\"\n+                + \"Check that table is properly updated when column order is changed.\\n\\n\"\n+                + \"Turn screen reader on, and Tab to the table.\\n\"\n+                + \"Using arrow keys navigate to the last cell in the first row in the table.\"\n+                + \"Screen reader should announce it as \\\"Column 3 row 1\\\"\\n\\n\"\n+                + \"Using mouse drag the header of the last culumn so the last column becomes the first one.\"\n+                + \"Wait for the screen reader to finish announcing new position in table.\\n\\n\"\n+                + \"If new position in table corresponds to the new table layout ctrl+tab further \"\n+                + \"and press PASS, otherwise press FAIL.\\n\";\n+\n+        JTable table = new JTable(data, columnNames);\n+        JPanel panel = new JPanel();\n+        panel.setLayout(new FlowLayout());\n+        JScrollPane scrollPane = new JScrollPane(table);\n+        panel.add(scrollPane);\n+        panel.setFocusable(false);\n+        exceptionString = \"AccessibleJTable test failed!\";\n+        super.createUI(panel, \"AccessibleJTableTest\");\n+    }\n+\n@@ -169,0 +190,7 @@\n+        countDownLatch = test.createCountDownLatch();\n+        SwingUtilities.invokeAndWait(test::createUIDraggable);\n+        countDownLatch.await(15, TimeUnit.MINUTES);\n+        if (!testResult) {\n+            throw new RuntimeException(exceptionString);\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/a11y\/AccessibleJTableTest.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+            MemorySegment segmentBufferView = MemorySegment.ofBuffer(z);\n@@ -172,0 +173,1 @@\n+                Object handleViewValue = handleExtractor.apply(segmentBufferView, j - i);\n@@ -175,0 +177,1 @@\n+                    assertEquals(((Number)handleViewValue).longValue(), j);\n@@ -178,0 +181,1 @@\n+                    assertEquals((long)(char)handleViewValue, j);\n@@ -213,1 +217,1 @@\n-                MemorySegment segment = MemorySegment.ofByteBuffer(mbb);\n+                MemorySegment segment = MemorySegment.ofBuffer(mbb);\n@@ -222,1 +226,1 @@\n-                MemorySegment segment = MemorySegment.ofByteBuffer(mbb);\n+                MemorySegment segment = MemorySegment.ofBuffer(mbb);\n@@ -453,1 +457,1 @@\n-        MemorySegment base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity]));\n+        MemorySegment base = MemorySegment.ofBuffer(ByteBuffer.wrap(new byte[capacity]));\n@@ -465,1 +469,1 @@\n-        MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n+        MemorySegment second = MemorySegment.ofBuffer(segment.asByteBuffer());\n@@ -474,1 +478,1 @@\n-            MemorySegment second = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n+            MemorySegment second = MemorySegment.ofBuffer(segment.asByteBuffer());\n@@ -610,1 +614,1 @@\n-            MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer);\n+            MemorySegment segment = MemorySegment.ofBuffer(rwBuffer);\n@@ -616,1 +620,1 @@\n-            MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer);\n+            MemorySegment segment = MemorySegment.ofBuffer(roBuffer);\n@@ -624,1 +628,1 @@\n-        MemorySegment segment = MemorySegment.ofByteBuffer(buffer);\n+        MemorySegment segment = MemorySegment.ofBuffer(buffer);\n@@ -645,1 +649,1 @@\n-        MemorySegment segment = MemorySegment.ofByteBuffer(bb);\n+        MemorySegment segment = MemorySegment.ofBuffer(bb);\n@@ -651,1 +655,1 @@\n-        segment = MemorySegment.ofByteBuffer(segment.asByteBuffer());\n+        segment = MemorySegment.ofBuffer(segment.asByteBuffer());\n@@ -660,1 +664,1 @@\n-        MemorySegment segment = MemorySegment.ofByteBuffer(bb);\n+        MemorySegment segment = MemorySegment.ofBuffer(bb);\n@@ -672,1 +676,1 @@\n-            MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());\n+            MemorySegment msRoundTrip = MemorySegment.ofBuffer(msNoAccess.asByteBuffer());\n@@ -680,1 +684,1 @@\n-        MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());\n+        MemorySegment s2 = MemorySegment.ofBuffer(s1.asByteBuffer());\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.nio.Buffer;\n@@ -148,0 +149,1 @@\n+        addDefaultMapping(Buffer.class, ByteBuffer.wrap(new byte[10]));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-        MemorySegment.ofByteBuffer(ByteBuffer.allocateDirect(0)).fill((byte) 0xFF);\n+        MemorySegment.ofBuffer(ByteBuffer.allocateDirect(0)).fill((byte) 0xFF);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                    MemorySegment s2 = MemorySegment.ofByteBuffer(bb);\n+                    MemorySegment s2 = MemorySegment.ofBuffer(bb);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            MemorySegment mbb = MemorySegment.ofByteBuffer(bb);\n+            MemorySegment mbb = MemorySegment.ofBuffer(bb);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-EmptyDescriptionTest.java:25: warning: no initial description\n+EmptyDescriptionTest.java:25: warning: no main description\n@@ -19,1 +19,1 @@\n-EmptyDescriptionTest.java:44: warning: no initial description\n+EmptyDescriptionTest.java:44: warning: no main description\n","filename":"test\/langtools\/tools\/doclint\/EmptyDescriptionTest.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -412,3 +412,23 @@\n-    \/\/ dstFile will keep original size so will remove corresponding bytes.length bytes at end of file\n-    public static File insertBytesRandomlyAfterHeader(File orgFile, String newFileName, byte[] bytes) throws Exception {\n-        long offset = fileHeaderSize(orgFile) + getRandomBetween(0L, 4096L);\n+    \/\/ Helper method for calling FileChannel.transferFrom and checking the\n+    \/\/ return value.\n+    private static void transferFrom(FileChannel inputChannel,\n+                                     FileChannel outputChannel,\n+                                     long offset,\n+                                     long length) throws Exception {\n+        long position = offset;\n+        long count = length;\n+        while (count > 0 && inputChannel.position() < inputChannel.size()) {\n+            long n = outputChannel.transferFrom(inputChannel, position, count);\n+            if (n < 0 || n > count) {\n+                throw new RuntimeException(\"Incorrect transfer length n = \" + n\n+                                           + \" (expected 0 <= n <= \" + length + \")\");\n+            }\n+            position += n;\n+            count -= n;\n+        }\n+    }\n+\n+    \/\/ dstFile will keep original size\n+    public static File insertBytesRandomlyAfterHeader(File orgFile, String newFileName) throws Exception {\n+        long headerSize = fileHeaderSize(orgFile);\n+        long dupSize = getRandomBetween(0L, headerSize);\n@@ -419,5 +439,8 @@\n-            outputChannel.transferFrom(inputChannel, 0, offset);\n-            outputChannel.position(offset);\n-            outputChannel.write(ByteBuffer.wrap(bytes));\n-            outputChannel.transferFrom(inputChannel, offset + bytes.length, orgSize - bytes.length);\n-        }\n+            \/\/ Copy the header\n+            transferFrom(inputChannel, outputChannel, 0, headerSize);\n+            \/\/ Copy dupSize bytes from the end of the header. Then, copy the rest\n+            \/\/ of the input such that the new file will have the same size as\n+            \/\/ the old file.\n+            inputChannel.position(headerSize - dupSize);\n+            transferFrom(inputChannel, outputChannel, headerSize, orgSize - headerSize);\n+            }\n@@ -434,1 +457,1 @@\n-            outputChannel.transferFrom(inputChannel, 0, offset);\n+            transferFrom(inputChannel, outputChannel, 0, offset);\n@@ -436,1 +459,1 @@\n-            outputChannel.transferFrom(inputChannel, offset, orgSize - nBytes);\n+            transferFrom(inputChannel, outputChannel, offset, orgSize - nBytes);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"}]}