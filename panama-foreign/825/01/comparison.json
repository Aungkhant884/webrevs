{"files":[{"patch":"@@ -165,1 +165,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int (*foo)[10]}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int (*ptr)[10]}<\/th>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -353,4 +353,3 @@\n- *     <li>pointers returned from a foreign function;<\/li>\n- *     <li>pointers passed by a foreign function to an\n- *     {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}; and<\/li>\n- *     <li>pointers {@linkplain MemorySegment#get(AddressLayout, long) read} from a memory segment.<\/li>\n+ *     <li>pointers <a href=\"Linker.html#by-ref\">returned from a foreign function<\/a>;<\/li>\n+ *     <li>pointers <a href=\"Linker.html#function-pointers\">passed by a foreign function to an upcall stub<\/a>; and<\/li>\n+ *     <li>pointers read from a memory segment (more on that below).<\/li>\n@@ -370,1 +369,8 @@\n- * To work with native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>.\n+ * To demonstrate how clients can work with zero-length memory segments, consider the case of a client that wants\n+ * to read a pointer from some memory segment. This can be done via the\n+ * {@linkplain MemorySegment#get(AddressLayout, long)} access method. This method accepts an\n+ * {@linkplain AddressLayout address layout} (e.g. {@link ValueLayout#ADDRESS}), the layout of the pointer\n+ * to be read. For instance on a 64-bit platform, the size of an address layout is 64 bits. The access operation\n+ * also accepts an offset, expressed in bytes, which indicates the position (relative to the start of the memory segment)\n+ * at which the pointer is stored. The access operation returns a zero-length native memory segment, backed by a region\n+ * of memory whose starting address is the 64-bit value read at the specified offset.\n@@ -372,3 +378,4 @@\n- * First, clients can unsafely resize a zero-length memory segment by {@linkplain #reinterpret(long) obtaining} a\n- * memory segment with the same base address as the zero-length memory segment, but with the desired size,\n- * so that the resulting segment can then be accessed directly, as follows:\n+ * The returned zero-length memory segment cannot be accessed directly by the client: since the size of the segment\n+ * is zero, any access operation would result in out-of-bounds access. Instead, the client must, <em>unsafely<\/em>,\n+ * assign new spatial bounds to the zero-length memory segment. This can be done via the\n+ * {@link #reinterpret(long)} method, as follows:\n@@ -377,3 +384,3 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ size = 0\n- *                                    .reinterpret(4)               \/\/ size = 4\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n+ * MemorySegment z = segment.get(ValueLayout.ADDRESS, ...);   \/\/ size = 0\n+ * MemorySegment ptr = z.reinterpret(16);                     \/\/ size = 16\n+ * int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);           \/\/ ok\n@@ -382,3 +389,3 @@\n- * In some cases, a client might additionally want to assign new temporal bounds to a zero-length memory segment.\n- * This can be done using the {@link #reinterpret(long, Arena, Consumer)} method, which returns a\n- * new native segment with the desired size and the same temporal bounds as those in the provided arena:\n+ * In some cases, the client might additionally want to assign new temporal bounds to a zero-length memory segment.\n+ * This can be done via the {@link #reinterpret(long, Arena, Consumer)} method, which returns a\n+ * new native segment with the desired size and the same temporal bounds as those of the provided arena:\n@@ -387,1 +394,1 @@\n- * MemorySegment foreign = null;\n+ * MemorySegment ptr = null;\n@@ -389,3 +396,3 @@\n- *       foreign = someSegment.get(ValueLayout.ADDRESS, 0)           \/\/ size = 0, scope = always alive\n- *                            .reinterpret(4, arena, null);          \/\/ size = 4, scope = arena.scope()\n- *       int x = foreign.get(ValueLayout.JAVA_INT, 0);               \/\/ ok\n+ *       MemorySegment z = segment.get(ValueLayout.ADDRESS, ...);    \/\/ size = 0, scope = always alive\n+ *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 4, scope = arena.scope()\n+ *       int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);            \/\/ ok\n@@ -393,1 +400,1 @@\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ throws IllegalStateException\n+ * int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);                  \/\/ throws IllegalStateException\n@@ -396,5 +403,6 @@\n- * Alternatively, if the size of the foreign segment is known statically, clients can associate a\n- * {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} with the address layout used to obtain the\n- * segment. When an access operation, or a function descriptor that is passed to a downcall method handle,\n- * uses an address value layout with target layout {@code T}, the runtime will wrap any corresponding raw addresses\n- * with native segments with size set to {@code T.byteSize()}:\n+ * Alternatively, if the size of the region of memory backing the zero-length memory segment is known statically,\n+ * the client can overlay a {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} on the address\n+ * layout used when reading a pointer. The target layout is then used to dynamically\n+ * <em>expand<\/em> the size of the native memory segment returned by the access operation, so that the size\n+ * of the segment is the same as the size of the target layout. In other words, the returned segment is no\n+ * longer a zero-length memory segment, and the pointer it represents can be dereferenced directly:\n@@ -403,2 +411,4 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ size = 4\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0);                                               \/\/ ok\n+ * AddressLayout intArrPtrLayout = ValueLayout.ADDRESS.withTargetLayout(\n+ *         MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT)); \/\/ layout for int (*ptr)[4]\n+ * MemorySegment ptr = segment.get(intArrPtrLayout, ...);         \/\/ size = 16\n+ * int x = ptr.getAtIndex(ValueLayout.JAVA_INT, 3);               \/\/ ok\n@@ -407,7 +417,0 @@\n- * Which approach is taken largely depends on the information that a client has available when obtaining a memory segment\n- * wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the\n- * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). If the\n- * size is known statically, using an address layout with the correct target layout might be preferable.\n- * In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should\n- * be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n- * <p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":36,"deletions":33,"binary":false,"changes":69,"status":"modified"}]}