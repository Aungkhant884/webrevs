{"files":[{"patch":"@@ -341,1 +341,1 @@\n-     * @throws IllegalArgumentException if {@code offset} is negative\n+     * @throws IllegalArgumentException if {@code offset} or {@code index} is negative\n@@ -349,0 +349,4 @@\n+        if (index < 0) {\n+            throw new IllegalArgumentException(\"Negative index: \" + index);\n+        }\n+\n@@ -432,5 +436,5 @@\n-     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n-     *     <li>it has as zero or more trailing access coordinates of type {@code long}, one for each\n-     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path. The order of these access\n-     *     coordinates corresponds to the order in which the open path elements occur in the provided\n-     *     layout path.\n+     *     <li>a following {@code long} parameter, corresponding to the base offset, denoted as {@code B};<\/li>\n+     *     <li>it has zero or more trailing access coordinates of type {@code long}, one for each\n+     *     <a href=#open-path-elements>open path element<\/a> in the provided layout path, denoted as\n+     *     {@code I1, I2, ... In}, respectively. The order of these access coordinates corresponds to the order\n+     *     in which the open path elements occur in the provided layout path.\n@@ -439,1 +443,2 @@\n-     * The final address accessed by the returned var handle can be computed as follows:\n+     * If the provided layout path {@code P} contains no dereference elements, then the offset of the access operation is\n+     * computed as follows:\n@@ -441,6 +446,3 @@\n-     * <blockquote><pre>{@code\n-     * address_1 = base(segment_1) + offset_1\n-     * address_2 = base(segment_2) + offset_2\n-     * ...\n-     * address_k = base(segment_k-1) + offset_k\n-     * }<\/pre><\/blockquote>\n+     * {@snippet lang = \"java\":\n+     * offset = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * }\n@@ -448,17 +450,3 @@\n-     * where {@code k} is the number of <a href=#deref-path-elements>dereference path elements<\/a> in a layout path,\n-     * {@code segment_1} is the input segment, {@code segment_2}, ...  {@code segment_k-1} are the segments obtained by\n-     * dereferencing the address associated with a given dereference path element (e.g. {@code segment_2} is a native\n-     * segment whose base address is {@code address_1}), and {@code offset_1}, {@code offset_2}, ... {@code offset_k}\n-     * are the offsets computed based on the path elements corresponding to a particular section,\n-     * {@code address_i = base(segment_i) + offset_i}, of the path, where {@code 0 < i <= k}. {@code base(segment)}\n-     * denotes a function that returns the physical base address of the accessed memory segment. For native segments,\n-     * this function just returns the native segment's {@linkplain MemorySegment#address() address}. For heap segments,\n-     * this function is more complex, as the address of heap segments is virtualized. Each {@code offset_i} corresponding\n-     * to a section of the path, is computed as if by a call to a {@linkplain #byteOffsetHandle(PathElement...) byte offset handle}\n-     * constructed using the path elements pertaining to that particular section of the path. The arguments to the byte\n-     * offset handle are taken from the dynamic {@code long} coordinates corresponding to that path section. The base\n-     * offset parameter of the returned var handle is used in the offset computation of the first path section. The base\n-     * offset used when computing the offset for the other path sections is zero.\n-     * <p>\n-     * All memory accesses immediately preceding a dereference operation (e.g. those at addresses {@code address_1},\n-     * {@code address_2}, ..., {@code address_k-1} are performed using the {@link VarHandle.AccessMode#GET} access mode.\n+     * The physical address corresponding to the accessed offset must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a>\n+     * according to the {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout).\n+     * Note that this can be more strict (but not less) than the alignment constraint of the selected value layout.\n@@ -466,3 +454,10 @@\n-     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n-     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n-     * (but not less) than the alignment constraint of the selected value layout.\n+     * If the selected layout is an {@linkplain AddressLayout address layout}, calling {@link VarHandle#get(Object...)}\n+     * on the returned var handle will return a new memory segment. The segment is associated with a fresh scope that is\n+     * always alive. Moreover, the size of the segment depends on whether the address layout has a\n+     * {@linkplain AddressLayout#targetLayout() target layout}. More specifically:\n+     * <ul>\n+     *     <li>If the address layout has a target layout {@code T}, then the size of the returned segment\n+     *     is {@code T.byteSize()};<\/li>\n+     *     <li>Otherwise, the address layout has no target layout, and the size of the returned segment\n+     *     is <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>.<\/li>\n+     * <\/ul>\n@@ -470,2 +465,16 @@\n-     * Additionally, the provided dynamic values must conform to bounds which are derived from the layout path, that is,\n-     * {@code 0 <= x_i < b_i}, where {@code 1 <= i <= n}, or {@link IndexOutOfBoundsException} is thrown.\n+     * If the provided layout path has size {@code m} and contains a dereference path element in position {@code k}\n+     * (where {@code k <= m}) then two layout paths {@code P} and {@code P'} are derived, where P contains all the path\n+     * elements from 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1} to\n+     * {@code m} (if any). Then, the returned var handle is computed as follows:\n+     *\n+     * {@snippet lang = \"java\":\n+     * VarHandle baseHandle = this.varHandle(P);\n+     * MemoryLayout target = ((AddressLayout)this.select(P)).targetLayout().get();\n+     * VarHandle targetHandle = target.varHandle(P');\n+     * targetHandle = MethodHandles.insertCoordinates(targetHandle, 1, 0L); \/\/ always access nested targets at offset 0\n+     * targetHandle = MethodHandles.collectCoordinates(targetHandle, 0,\n+     *         baseHandle.toMethodHandle(VarHandle.AccessMode.GET));\n+     * }\n+     *\n+     * (The above can be trivially generalized to cases where the provided layout path contains more than one dereference\n+     * path elements).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -361,0 +361,6 @@\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative index.*\")\n+    public void testScaleNegativeIndex() {\n+        JAVA_INT.scale(0, -1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}