{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.invoke.MethodType;\n@@ -47,0 +48,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -234,0 +236,39 @@\n+ * <h2 id=\"access-mode-restrictions\">Access mode restrictions<\/h2>\n+ *\n+ * The var handles returned by {@link #varHandle(PathElement...)} and {@link ValueLayout#varHandle()} feature certain\n+ * <i>access mode restrictions<\/i>. A var handle is associated with an access size {@code S}, derived from the\n+ * {@linkplain ValueLayout#byteSize() byte size} of the receiver layout, and an alignment constraint {@code B}, derived\n+ * from the {@linkplain ValueLayout#byteAlignment() alignment constraint} of the receiver layout. We say that a memory\n+ * access operation is <em>fully aligned<\/em> if it occurs at a memory address {@code A} which is compatible with both\n+ * alignment constraints {@code S} and {@code B}. If access is fully aligned then following access modes are supported\n+ * and are guaranteed to support atomic access:\n+ * <ul>\n+ * <li>read write access modes for all {@code T}, with the exception of\n+ *     access modes {@code get} and {@code set} for {@code long} and\n+ *     {@code double} on 32-bit platforms.\n+ * <li>atomic update access modes for {@code int}, {@code long},\n+ *     {@code float}, {@code double} or {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     types for certain currently unsupported access modes.)\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n+ *     (Future major platform releases of the JDK may support additional\n+ *     numeric types for certain currently unsupported access modes.)\n+ * <\/ul>\n+ * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic update access modes compare\n+ * values using their bitwise representation (see {@link Float#floatToRawIntBits}, {@link Double#doubleToRawLongBits}\n+ * and {@link MemorySegment#address()}, respectively).\n+ * <p>\n+ * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n+ * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n+ * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n+ * atomic access is only guaranteed when {@code A} is aligned according to {@code S}.\n+ * <p>\n+ * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n+ * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n+ * <p>\n+ * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n+ * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n+ *\n@@ -295,0 +336,34 @@\n+    \/**\n+     * {@return {@code offset + (byteSize() * index)}}\n+     *\n+     * @param offset the base offset\n+     * @param index the index to be scaled by the byte size of this layout\n+     * @throws IllegalArgumentException if {@code offset} is negative\n+     * @throws ArithmeticException if either the addition or multiplication overflows\n+     *\/\n+    @ForceInline\n+    default long scale(long offset, long index) {\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Negative offset: \" + offset);\n+        }\n+        return Math.addExact(offset, Math.multiplyExact(byteSize(), index));\n+    }\n+\n+    \/**\n+     *{@return a method handle that can be used to invoke {@link #scale(long, long)} on this layout}\n+     *\/\n+    default MethodHandle scaleHandle() {\n+        class Holder {\n+            static final MethodHandle MH_SCALE;\n+            static {\n+                try {\n+                    MH_SCALE = MethodHandles.lookup().findVirtual(MemoryLayout.class, \"scale\",\n+                            MethodType.methodType(long.class, long.class, long.class));\n+                } catch (ReflectiveOperationException e) {\n+                    throw new ExceptionInInitializerError(e);\n+                }\n+            }\n+        }\n+        return Holder.MH_SCALE.bindTo(this);\n+    }\n+\n@@ -317,1 +392,2 @@\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has one leading {@code long} parameter representing the base offset;<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -325,1 +401,1 @@\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * offset = b + c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n@@ -328,4 +404,5 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * where {@code b} represents the base offset provided as a <em>dynamic<\/em> {@code long} argument, {@code x_1}, {@code x_2},\n+     * ... {@code x_n} represent indices into sequences provided as <em>dynamic<\/em> {@code long} arguments, whereas\n+     * {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants derived from the size of the element\n+     * layout of a sequence, and {@code c_1}, {@code c_2}, ... {@code c_m} are other <em>static<\/em> offset constants\n+     * (such as field offsets) which are derived from the layout path.\n@@ -354,1 +431,3 @@\n-     *     <li>it has as zero or more access coordinates of type {@code long}, one for each\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n+     *     <li>it has as zero or more trailing access coordinates of type {@code long}, one for each\n@@ -363,10 +442,4 @@\n-     * address = base(segment) + offset\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed\n-     * memory segment. For native segments, this function just returns the native segment's\n-     * {@linkplain MemorySegment#address() address}. For heap segments, this function is more complex, as the address\n-     * of heap segments is virtualized. The {@code offset} value can be expressed in the following form:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+     * address_1 = base(segment_1) + offset_1\n+     * address_2 = base(segment_2) + offset_2\n+     * ...\n+     * address_k = base(segment_k-1) + offset_k\n@@ -375,4 +448,21 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n-     * and {@code s_1}, {@code s_2}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n-     * the layout path.\n+     * where {@code k} is the number of <a href=#deref-path-elements>dereference path elements<\/a> in a layout path,\n+     * {@code segment_1} is the input segment, {@code segment_2}, ...  {@code segment_k-1} are the segments obtained by\n+     * dereferencing the address associated with a given dereference path element (e.g. {@code segment_2} is a native\n+     * segment whose base address is {@code address_1}), and {@code offset_1}, {@code offset_2}, ... {@code offset_k}\n+     * are the offsets computed based on the path elements corresponding to a particular section,\n+     * {@code address_i = base(segment_i) + offset_i}, of the path, where {@code 0 < i <= k}. {@code base(segment)}\n+     * denotes a function that returns the physical base address of the accessed memory segment. For native segments,\n+     * this function just returns the native segment's {@linkplain MemorySegment#address() address}. For heap segments,\n+     * this function is more complex, as the address of heap segments is virtualized. Each {@code offset_i} corresponding\n+     * to a section of the path, is computed as if by a call to a {@linkplain #byteOffsetHandle(PathElement...) byte offset handle}\n+     * constructed using the path elements pertaining to that particular section of the path. The arguments to the byte\n+     * offset handle are taken from the dynamic {@code long} coordinates corresponding to that path section. The base\n+     * offset parameter of the returned var handle is used in the offset computation of the first path section. The base\n+     * offset used when computing the offset for the other path sections is zero.\n+     * <p>\n+     * All memory accesses immediately preceding a dereference operation (e.g. those at addresses {@code address_1},\n+     * {@code address_2}, ..., {@code address_k-1} are performed using the {@link VarHandle.AccessMode#GET} access mode.\n+     * <p>\n+     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n+     * #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more strict\n+     * (but not less) than the alignment constraint of the selected value layout.\n@@ -383,21 +473,11 @@\n-     * Multiple paths can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n-     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n-     * read obtained by accessing a memory segment at the offset determined by the layout path elements immediately preceding\n-     * the dereference path element. In other words, if a layout path contains one or more dereference path elements,\n-     * the final address accessed by the returned var handle can be computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * address_1 = base(segment) + offset_1\n-     * address_2 = base(segment_1) + offset_2\n-     * ...\n-     * address_k = base(segment_k-1) + offset_k\n-     * }<\/pre><\/blockquote>\n-     *\n-     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n-     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n-     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n-     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n-     * the path elements after a given dereference operation (these offsets are obtained using the computation described\n-     * above). In these more complex access operations, all memory accesses immediately preceding a dereference operation\n-     * (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1} are performed using the\n-     * {@link VarHandle.AccessMode#GET} access mode.\n+     * As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n+     * {@snippet lang = \"java\":\n+     *     GroupLayout grp = java.lang.foreign.MemoryLayout.structLayout(\n+     *             MemoryLayout.paddingLayout(4),\n+     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n+     *     );\n+     * }\n+     * To access the member layout named {@code value}, we can construct a var handle as follows:\n+     * {@snippet lang = \"java\":\n+     *     VarHandle handle = grp.varHandle(PathElement.groupElement(\"value\")); \/\/(MemorySegment, long) -> int\n+     * }\n@@ -405,2 +485,2 @@\n-     * @apiNote The resulting var handle features certain <em>access mode restrictions<\/em>, which are common to all\n-     * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) memory segment view handles}.\n+     * @apiNote The resulting var handle features certain <a href=\"#access-mode-restrictions\"><em>access mode restrictions<\/em><\/a>,\n+     * which are common to all memory access var handles derived from memory layouts.\n@@ -412,1 +492,0 @@\n-     * @see MethodHandles#memorySegmentViewVarHandle(ValueLayout)\n@@ -415,0 +494,4 @@\n+        Objects.requireNonNull(elements);\n+        if (this instanceof ValueLayout vl && elements.length == 0) {\n+            return vl.varHandle(); \/\/ fast path\n+        }\n@@ -426,3 +509,3 @@\n-     *     <li>it has a leading parameter of type {@code MemorySegment}, corresponding to the memory segment\n-     *     to be sliced;<\/li>\n-     *     <li>it has as zero or more parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to the memory segment to be sliced<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n+     *     <li>it has as zero or more trailing parameters of type {@code long}, one for each <a href=#open-path-elements>open path element<\/a>\n@@ -433,6 +516,6 @@\n-     * The offset of the returned segment is computed as follows:\n-     * {@snippet lang=java :\n-     * long offset = byteOffset(elements);\n-     * long size = select(elements).byteSize();\n-     * MemorySegment slice = segment.asSlice(offset, size);\n-     * }\n+     * The offset of the returned segment is computed as if by a call to a\n+     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using the given path elements.\n+     * <p>\n+     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n+     * strict (but not less) than the alignment constraint of the selected value layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":137,"deletions":54,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import java.lang.foreign.Linker.Option;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n@@ -38,1 +35,1 @@\n-import java.nio.channels.FileChannel.*;\n+import java.nio.channels.FileChannel.MapMode;\n@@ -53,2 +50,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.layout.ValueLayouts;\n@@ -133,5 +128,6 @@\n- * For more complex access operations (e.g. structured memory access), clients can obtain a\n- * {@linkplain MethodHandles#memorySegmentViewVarHandle(ValueLayout) var handle}\n- * that accepts a segment and a {@code long} offset. More complex var handles\n- * can be obtained by adapting a segment var handle view using the var handle combinator functions defined in the\n- * {@link java.lang.invoke.MethodHandles} class:\n+ * More complex access operations can be implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout on a memory segment.\n+ * A var handle obtained from a layout supports several additional <a href=MemoryLayout.html#access-mode-restrictions>\n+ * access modes<\/a>. More importantly, var handles can be <em>combined<\/em> with method handles to express complex access\n+ * operations. For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -139,1 +135,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang=java:\n@@ -141,7 +137,5 @@\n- * VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n- * MethodHandle multiplyExact = MethodHandles.lookup()\n- *                                           .findStatic(Math.class, \"multiplyExact\",\n- *                                                                   MethodType.methodType(long.class, long.class, long.class));\n- * intHandle = MethodHandles.filterCoordinates(intHandle, 1,\n- *                                             MethodHandles.insertArguments(multiplyExact, 0, ValueLayout.JAVA_INT.byteSize()));\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * VarHandle intHandle = ValueLayout.JAVA_INT.varHandle(); \/\/ (MemorySegment, long)\n+ * MethodHandle scale = ValueLayout.JAVA_INT.scaleHandle(); \/\/ <base offset> + <index> * JAVA_INT.byteSize()\n+ *\n+ * intHandle = MethodHandles.filterCoordinates(intHandle, 1, scale);\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + 3 * 4 = 12\n@@ -150,3 +144,5 @@\n- * Alternatively, complex var handles can can be obtained\n- * from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n- * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>:\n+ * To make the process of creating these var handles easier, the method\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)} can be used, by providing it a so called\n+ * <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>. A layout path, consisting of several <em>layout\n+ * path elements<\/em>, selects a value layout to be accessed, which can be nested inside another memory layout. For example,\n+ * we can express the access to an element of an {@code int} array using layout paths like so:\n@@ -156,2 +152,7 @@\n- * VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n- * int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+ * MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"size\"),\n+ *     MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+ * );\n+ * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElemenet.groupElement(\"data\"),\n+ *                                               MemoryLayout.PathElement.sequenceElement());\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -159,0 +160,9 @@\n+ * Where {@code offsetof(data)} is the offset of the {@code data} element layout of the {@code segmentLayout} layout\n+ *\n+ * Both the var handle returned by {@link ValueLayout#varHandle()} and\n+ * {@link MemoryLayout#varHandle(MemoryLayout.PathElement...)}, as well as the method handle returned by\n+ * {@link MemoryLayout#byteOffsetHandle(MemoryLayout.PathElement...)} and {@link MemoryLayout#sliceHandle(MemoryLayout.PathElement...)}\n+ * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This\n+ * parameter allows a client to combine these handles further with additional offset computations. This is demonstrated\n+ * in the first of the two examples above, where {@code intHandle} is combined with a\n+ * {@linkplain MemoryLayout#scaleHandle() scale handle} obtained from {@code ValueLayout.JAVA_INT}.\n@@ -1434,1 +1444,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, offset);\n+        return (byte) layout.varHandle().get(this, offset);\n@@ -1454,1 +1464,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1473,1 +1483,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, offset);\n+        return (boolean) layout.varHandle().get(this, offset);\n@@ -1493,1 +1503,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1512,1 +1522,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, offset);\n+        return (char) layout.varHandle().get(this, offset);\n@@ -1532,1 +1542,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1551,1 +1561,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, offset);\n+        return (short) layout.varHandle().get(this, offset);\n@@ -1571,1 +1581,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1590,1 +1600,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, offset);\n+        return (int) layout.varHandle().get(this, offset);\n@@ -1610,1 +1620,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1629,1 +1639,1 @@\n-        return (float)((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, offset);\n+        return (float)layout.varHandle().get(this, offset);\n@@ -1649,1 +1659,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1668,1 +1678,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, offset);\n+        return (long) layout.varHandle().get(this, offset);\n@@ -1688,1 +1698,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1707,1 +1717,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, offset);\n+        return (double) layout.varHandle().get(this, offset);\n@@ -1727,1 +1737,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1752,1 +1762,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, offset);\n+        return (MemorySegment) layout.varHandle().get(this, offset);\n@@ -1773,1 +1783,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, offset, value);\n+        layout.varHandle().set(this, offset, value);\n@@ -1797,1 +1807,1 @@\n-        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (byte) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1821,1 +1831,1 @@\n-        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (boolean) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1845,1 +1855,1 @@\n-        return (char) ((ValueLayouts.OfCharImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (char) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1870,1 +1880,1 @@\n-        ((ValueLayouts.OfCharImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1894,1 +1904,1 @@\n-        return (short) ((ValueLayouts.OfShortImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (short) layout.varHandle().get(this, index * layout.byteSize());\n@@ -1919,1 +1929,1 @@\n-        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1945,1 +1955,1 @@\n-        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1970,1 +1980,1 @@\n-        ((ValueLayouts.OfShortImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -1994,1 +2004,1 @@\n-        return (int) ((ValueLayouts.OfIntImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (int) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2019,1 +2029,1 @@\n-        ((ValueLayouts.OfIntImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2043,1 +2053,1 @@\n-        return (float) ((ValueLayouts.OfFloatImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (float) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2068,1 +2078,1 @@\n-        ((ValueLayouts.OfFloatImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2092,1 +2102,1 @@\n-        return (long) ((ValueLayouts.OfLongImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (long) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2117,1 +2127,1 @@\n-        ((ValueLayouts.OfLongImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2141,1 +2151,1 @@\n-        return (double) ((ValueLayouts.OfDoubleImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (double) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2166,1 +2176,1 @@\n-        ((ValueLayouts.OfDoubleImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n@@ -2196,1 +2206,1 @@\n-        return (MemorySegment) ((ValueLayouts.OfAddressImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+        return (MemorySegment) layout.varHandle().get(this, index * layout.byteSize());\n@@ -2222,1 +2232,1 @@\n-        ((ValueLayouts.OfAddressImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+        layout.varHandle().set(this, index * layout.byteSize(), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":70,"deletions":60,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -144,1 +144,0 @@\n-        VarHandle handle = layout.varHandle();\n@@ -146,1 +145,1 @@\n-        handle.set(addr, value);\n+        addr.set(layout, 0, value);\n@@ -159,1 +158,0 @@\n-        VarHandle handle = layout.varHandle();\n@@ -161,1 +159,1 @@\n-        handle.set(addr, value);\n+        addr.set(layout, 0, value);\n@@ -174,1 +172,0 @@\n-        VarHandle handle = layout.varHandle();\n@@ -176,1 +173,1 @@\n-        handle.set(addr, value);\n+        addr.set(layout, 0, value);\n@@ -189,1 +186,0 @@\n-        VarHandle handle = layout.varHandle();\n@@ -191,1 +187,1 @@\n-        handle.set(addr, value);\n+        addr.set(layout, 0, value);\n@@ -204,1 +200,0 @@\n-        VarHandle handle = layout.varHandle();\n@@ -206,1 +201,1 @@\n-        handle.set(addr, value);\n+        addr.set(layout, 0, value);\n@@ -219,1 +214,0 @@\n-        VarHandle handle = layout.varHandle();\n@@ -221,1 +215,1 @@\n-        handle.set(addr, value);\n+        addr.set(layout, 0, value);\n@@ -234,1 +228,0 @@\n-        VarHandle handle = layout.varHandle();\n@@ -236,1 +229,1 @@\n-        handle.set(addr, value);\n+        addr.set(layout, 0, value);\n@@ -252,1 +245,1 @@\n-        layout.varHandle().set(segment, value);\n+        segment.set(layout, 0, value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -31,1 +30,0 @@\n-\n@@ -79,61 +77,0 @@\n-    \/**\n-     * Creates a <em>strided<\/em> var handle that can be used to access a memory segment as multi-dimensional\n-     * array. This array has a notional sequence layout featuring {@code shape.length} nested sequence layouts. The element\n-     * layout of the innermost sequence layout in the notional sequence layout is this value layout. The resulting var handle\n-     * is obtained as if calling the {@link #varHandle(PathElement...)} method on the notional layout, with a layout\n-     * path containing exactly {@code shape.length + 1} {@linkplain PathElement#sequenceElement() open sequence layout path elements}.\n-     * <p>\n-     * For instance, the following method call:\n-     *\n-     * {@snippet lang=java :\n-     * VarHandle arrayHandle = ValueLayout.JAVA_INT.arrayElementVarHandle(10, 20);\n-     * }\n-     *\n-     * Is equivalent to the following code:\n-     *\n-     * {@snippet lang = java:\n-     * MemoryLayout innerLayout = MemoryLayout.sequenceLayout(10,\n-     *         MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT));\n-     * SequenceLayout notionalLayout = MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ innerLayout.byteSize(), innerLayout);\n-     * VarHandle arrayHandle = notionalLayout.varHandle(PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement(),\n-     *                                                  PathElement.sequenceElement());\n-     *}\n-     *\n-     * The resulting var handle {@code arrayHandle} will feature 3 coordinates of type {@code long}; each coordinate\n-     * is interpreted as an index into the corresponding sequence layout. If we refer to the var handle coordinates, from left\n-     * to right, as {@code x}, {@code y} and {@code z} respectively, the final offset accessed by the var handle can be\n-     * computed with the following formula:\n-     *\n-     * <blockquote><pre>{@code\n-     * offset = (10 * 20 * 4 * x) + (20 * 4 * y) + (4 * z)\n-     * }<\/pre><\/blockquote>\n-     *\n-     * Additionally, the values of {@code x}, {@code y} and {@code z} are constrained as follows:\n-     * <ul>\n-     *     <li>{@code 0 <= x < notionalLayout.elementCount() }<\/li>\n-     *     <li>{@code 0 <= y < 10 }<\/li>\n-     *     <li>{@code 0 <= z < 20 }<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Consider the following access expressions:\n-     * {@snippet lang=java :\n-     * int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-     * int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-     * }\n-     * In the first case, access is well-formed, as the values for {@code x}, {@code y} and {@code z} conform to\n-     * the bounds specified above. In the second case, access fails with {@link IndexOutOfBoundsException},\n-     * as the value for {@code z} is outside its specified bounds.\n-     *\n-     * @param shape the size of each nested array dimension.\n-     * @return a var handle which can be used to access a memory segment as a multi-dimensional array,\n-     * featuring {@code shape.length + 1}\n-     * {@code long} coordinates.\n-     * @throws IllegalArgumentException if {@code shape[i] < 0}, for at least one index {@code i}.\n-     * @throws UnsupportedOperationException if {@code byteAlignment() > byteSize()}.\n-     * @see MethodHandles#memorySegmentViewVarHandle\n-     * @see MemoryLayout#varHandle(PathElement...)\n-     * @see SequenceLayout\n-     *\/\n-    VarHandle arrayElementVarHandle(int... shape);\n-\n@@ -153,0 +90,1 @@\n+     *\n@@ -158,0 +96,21 @@\n+    \/**\n+     * {@return a var handle which can be used to access values described by this value layout, in a given memory segment.}\n+     * <p>\n+     * The returned var handle's {@linkplain VarHandle#varType() var type} is the {@linkplain ValueLayout#carrier() carrier type} of\n+     * this value layout, and the list of coordinate types is {@code (MemorySegment, long)}, where the memory segment coordinate\n+     * corresponds to the memory segment to be accessed, and the {@code long} coordinate corresponds to the byte offset\n+     * into the accessed memory segment at which the access occurs.\n+     * <p>\n+     * The returned var handle checks that accesses are aligned according to this value layout's\n+     * {@linkplain MemoryLayout#byteAlignment() alignment constraint}.\n+     *\n+     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n+     * with an empty path element array, as it avoids the creation of the var args array.\n+     *\n+     * @apiNote The returned var handle features certain <a href=\"MemoryLayout.html#access-mode-restrictions\">access mode\n+     * restrictions<\/a> common to all memory access var handles derived from memory layouts.\n+     *\n+     * @see MemoryLayout#varHandle(PathElement...)\n+     *\/\n+    VarHandle varHandle();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":22,"deletions":63,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-                int errno = (int) errnoHandle.get(capturedState);\n+                int errno = (int) errnoHandle.get(capturedState, 0L);\n@@ -353,2 +353,2 @@\n-            long offset1 = (long) offsetHandle.invokeExact(1L); \/\/ 8\n-            long offset2 = (long) offsetHandle.invokeExact(2L); \/\/ 16\n+            long offset1 = (long) offsetHandle.invokeExact(0L, 1L); \/\/ 8\n+            long offset2 = (long) offsetHandle.invokeExact(0L, 2L); \/\/ 16\n@@ -398,1 +398,1 @@\n-                VarHandle intHandle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+                VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -410,2 +410,7 @@\n-                VarHandle intHandle = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-                int value = (int) intHandle.get(segment, 3L); \/\/ get int element at offset 3 * 4 = 12\n+                MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withName(\"size\"),\n+                    MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+                );\n+                VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+                                                              MemoryLayout.PathElement.sequenceElement());\n+                int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -654,12 +659,0 @@\n-        void arrayElementVarHandle() {\n-            MemoryLayout innerLayout = MemoryLayout.sequenceLayout(10,\n-                    MemoryLayout.sequenceLayout(20, ValueLayout.JAVA_INT));\n-            SequenceLayout notionalLayout = MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ innerLayout.byteSize(), innerLayout);\n-            VarHandle arrayHandle = notionalLayout.varHandle(PathElement.sequenceElement(),\n-                                                             PathElement.sequenceElement(),\n-                                                             PathElement.sequenceElement());\n-\n-            int value1 = (int) arrayHandle.get(10, 2, 4); \/\/ ok, accessed offset = 8176\n-            int value2 = (int) arrayHandle.get(0, 0, 30); \/\/ out of bounds value for z\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -7957,79 +7957,0 @@\n-    \/**\n-     * Creates a var handle object, which can be used to dereference a {@linkplain java.lang.foreign.MemorySegment memory segment}\n-     * at a given byte offset, using the provided value layout.\n-     *\n-     * <p>The provided layout specifies the {@linkplain ValueLayout#carrier() carrier type},\n-     * the {@linkplain ValueLayout#byteSize() byte size},\n-     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n-     * associated with the returned var handle.\n-     *\n-     * <p>The list of coordinate types associated with the returned var handle is {@code (MemorySegment, long)},\n-     * where the {@code long} coordinate type corresponds to byte offset into the given memory segment coordinate.\n-     * Thus, the returned var handle accesses bytes at an offset in a given memory segment, composing bytes to or from\n-     * a value of the var handle type. Moreover, the access operation will honor the endianness and the\n-     * alignment constraints expressed in the provided layout.\n-     *\n-     * <p>As an example, consider the memory layout expressed by a {@link GroupLayout} instance constructed as follows:\n-     * {@snippet lang=\"java\" :\n-     *     GroupLayout seq = java.lang.foreign.MemoryLayout.structLayout(\n-     *             MemoryLayout.paddingLayout(4),\n-     *             ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n-     *     );\n-     * }\n-     * To access the member layout named {@code value}, we can construct a memory segment view var handle as follows:\n-     * {@snippet lang=\"java\" :\n-     *     VarHandle handle = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n-     *     handle = MethodHandles.insertCoordinates(handle, 1, 4); \/\/(MemorySegment) -> int\n-     * }\n-     *\n-     * @apiNote The resulting var handle features certain <i>access mode restrictions<\/i>,\n-     * which are common to all memory segment view var handles. A memory segment view var handle is associated\n-     * with an access size {@code S} and an alignment constraint {@code B}\n-     * (both expressed in bytes). We say that a memory access operation is <em>fully aligned<\/em> if it occurs\n-     * at a memory address {@code A} which is compatible with both alignment constraints {@code S} and {@code B}.\n-     * If access is fully aligned then following access modes are supported and are\n-     * guaranteed to support atomic access:\n-     * <ul>\n-     * <li>read write access modes for all {@code T}, with the exception of\n-     *     access modes {@code get} and {@code set} for {@code long} and\n-     *     {@code double} on 32-bit platforms.\n-     * <li>atomic update access modes for {@code int}, {@code long},\n-     *     {@code float}, {@code double} or {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     types for certain currently unsupported access modes.)\n-     * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemorySegment}.\n-     *     (Future major platform releases of the JDK may support additional\n-     *     numeric types for certain currently unsupported access modes.)\n-     * <\/ul>\n-     *\n-     * If {@code T} is {@code float}, {@code double} or {@link MemorySegment} then atomic\n-     * update access modes compare values using their bitwise representation\n-     * (see {@link Float#floatToRawIntBits},\n-     * {@link Double#doubleToRawLongBits} and {@link MemorySegment#address()}, respectively).\n-     * <p>\n-     * Alternatively, a memory access operation is <em>partially aligned<\/em> if it occurs at a memory address {@code A}\n-     * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the\n-     * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,\n-     * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.\n-     * <p>\n-     * In all other cases, we say that a memory access operation is <em>misaligned<\/em>; in such cases an\n-     * {@code IllegalStateException} is thrown, irrespective of the access mode being used.\n-     * <p>\n-     * Finally, if {@code T} is {@code MemorySegment} all write access modes throw {@link IllegalArgumentException}\n-     * unless the value to be written is a {@linkplain MemorySegment#isNative() native} memory segment.\n-     *\n-     * @param layout the value layout for which a memory access handle is to be obtained.\n-     * @return the new memory segment view var handle.\n-     * @throws NullPointerException if {@code layout} is {@code null}.\n-     * @see MemoryLayout#varHandle(MemoryLayout.PathElement...)\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    public static VarHandle memorySegmentViewVarHandle(ValueLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return Utils.makeSegmentViewVarHandle(layout);\n-    }\n-\n@@ -8191,13 +8112,12 @@\n-     * If {@code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of\n-     * type {@code R} as its coordinate in position {@code pos}, preceded and\/or followed by\n-     * any coordinate not passed to the filter.\n-     * No coordinates are reordered, and the result returned from the filter\n-     * replaces (in order) the whole subsequence of coordinates originally\n-     * passed to the adapter.\n-     * <p>\n-     * The argument types (if any) of the filter\n-     * replace zero or one coordinate types of the target var handle, at position {@code pos},\n-     * in the resulting adapted var handle.\n-     * The return type of the filter must be identical to the\n-     * coordinate type of the target var handle at position {@code pos}, and that target var handle\n-     * coordinate is supplied by the return value of the filter.\n+     * If {@code R} is the return type of the filter, then:\n+     * <ul>\n+     * <li>if {@code R} <em>is not<\/em> {@code void}, the target var handle must have a coordinate of type {@code R} in\n+     * position {@code pos}. The parameter types of the filter will replace the coordinate type at position {@code pos}\n+     * of the target var handle. When the returned var handle is invoked, it will be as if the filter is invoked first,\n+     * and its result is passed in place of the coordinate at position {@code pos} in a downstream invocation of the\n+     * target var handle.<\/li>\n+     * <li> if {@code R} <em>is<\/em> {@code void}, the parameter types (if any) of the filter will be inserted in the\n+     * coordinate type list of the target var handle at position {@code pos}. In this case, when the returned var handle\n+     * is invoked, the filter essentially acts as a side effect, consuming some of the coordinate values, before a\n+     * downstream invocation of the target var handle.<\/li>\n+     * <\/ul>\n@@ -8212,1 +8132,1 @@\n-     * @param pos the position of the coordinate to be filtered\n+     * @param pos the position in the coordinate list of the target var handle where the filter is to be inserted\n@@ -8217,1 +8137,1 @@\n-     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,\n+     * is not void, and it is not the same as the {@code pos} coordinate of the target var handle,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":14,"deletions":94,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -566,3 +566,1 @@\n-        } else if (filter.type().returnType() == void.class) {\n-            throw newIllegalArgumentException(\"Invalid filter type \" + filter.type() + \" ; filter cannot be void\");\n-        } else if (filter.type().returnType() != targetCoordinates.get(pos)) {\n+        } else if (filter.type().returnType() != void.class && filter.type().returnType() != targetCoordinates.get(pos)) {\n@@ -573,1 +571,3 @@\n-        newCoordinates.remove(pos);\n+        if (filter.type().returnType() != void.class) {\n+            newCoordinates.remove(pos);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.List;\n@@ -44,0 +45,1 @@\n+import java.util.stream.IntStream;\n@@ -61,0 +63,2 @@\n+    private static final MethodHandle MH_SLICE_LAYOUT;;\n+    private static final MethodHandle MH_CHECK_ALIGN;\n@@ -62,0 +66,1 @@\n+    private static final MethodHandle MH_ADD;\n@@ -70,0 +75,4 @@\n+            MH_SLICE_LAYOUT = lookup.findVirtual(MemorySegment.class, \"asSlice\",\n+                    MethodType.methodType(MemorySegment.class, long.class, MemoryLayout.class));\n+            MH_CHECK_ALIGN = lookup.findStatic(LayoutPath.class, \"checkAlign\",\n+                    MethodType.methodType(void.class, MemorySegment.class, long.class, MemoryLayout.class));\n@@ -72,0 +81,2 @@\n+            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(long.class, long.class, long.class));\n@@ -196,8 +207,16 @@\n-        VarHandle handle = Utils.makeSegmentViewVarHandle(valueLayout);\n-        for (int i = strides.length - 1; i >= 0; i--) {\n-            MethodHandle collector = MethodHandles.insertArguments(MH_ADD_SCALED_OFFSET, 2,\n-                    strides[i],\n-                    bounds[i]);\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            handle = MethodHandles.collectCoordinates(handle, 1, collector);\n+        \/\/ If we have an enclosing layout, drop the alignment check for the accessed element,\n+        \/\/ we check the root layout instead\n+        ValueLayout accessedLayout = enclosing != null ? valueLayout.withByteAlignment(1) : valueLayout;\n+        VarHandle handle = accessedLayout.varHandle();\n+        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n+\n+        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n+        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n+        \/\/ (see Utils::longToAddress)\n+        if (derefAdapters.length == 0 && enclosing != null) {\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n+            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n@@ -205,2 +224,0 @@\n-        handle = MethodHandles.insertCoordinates(handle, 1,\n-                offset);\n@@ -209,0 +226,4 @@\n+            if (derefAdapters.length > 0) {\n+                \/\/ plug up the base offset if we have at least 1 enclosing dereference\n+                handle = MethodHandles.insertCoordinates(handle, 1, 0);\n+            }\n@@ -210,1 +231,7 @@\n-                handle = MethodHandles.collectCoordinates(handle, 0, derefAdapters[i - 1]);\n+                MethodHandle adapter = derefAdapters[i - 1];\n+                \/\/ the first\/outermost adapter will have a base offset coordinate, the rest are constant 0\n+                if (i > 1) {\n+                    \/\/ plug in a constant 0 base offset for all but the outermost access in a deref chain\n+                    adapter = MethodHandles.insertArguments(adapter, 1, 0);\n+                }\n+                handle = MethodHandles.collectCoordinates(handle, 0, adapter);\n@@ -223,2 +250,2 @@\n-        MethodHandle mh = MethodHandles.identity(long.class);\n-        for (int i = strides.length - 1; i >=0; i--) {\n+        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        for (int i = strides.length - 1; i >= 0; i--) {\n@@ -230,1 +257,1 @@\n-        mh = MethodHandles.insertArguments(mh, 0, offset);\n+\n@@ -234,0 +261,4 @@\n+    private MemoryLayout rootLayout() {\n+        return enclosing != null ? enclosing.rootLayout() : this.layout;\n+    }\n+\n@@ -235,1 +266,10 @@\n-        MethodHandle offsetHandle = offsetHandle(); \/\/ byte offset\n+        MethodHandle sliceHandle;\n+        if (enclosing != null) {\n+            \/\/ drop the alignment check for the accessed element, we check the root layout instead\n+            sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n+            sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n+        } else {\n+            sliceHandle = MH_SLICE_LAYOUT; \/\/ (MS, long, MemoryLayout) -> MS\n+            sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout); \/\/ (MS, long) -> MS\n+        }\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle()); \/\/ (MS, long, ...) -> MS\n@@ -237,3 +277,8 @@\n-        MethodHandle sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n-        sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n-        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle); \/\/ (MS, ...) -> MS\n+        if (enclosing != null) {\n+            \/\/ insert align check for the root layout on the initial MS + offset\n+            MethodType oldType = sliceHandle.type();\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            sliceHandle = MethodHandles.collectArguments(sliceHandle, 0, alignCheck); \/\/ (MS, long, MS, long) -> MS\n+            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, oldType.parameterCount())).toArray();\n+            sliceHandle = MethodHandles.permuteArguments(sliceHandle, oldType, reorder); \/\/ (MS, long, ...) -> MS\n+        }\n@@ -244,0 +289,6 @@\n+    private static void checkAlign(MemorySegment segment, long offset, MemoryLayout constraint) {\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, constraint)) {\n+            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":69,"deletions":18,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+\n+            static VarHandle get(ValueLayout layout) {\n+                return HANDLE_MAP.get(layout);\n+            }\n@@ -100,0 +104,8 @@\n+        layout = layout.withoutName(); \/\/ name doesn't matter\n+        \/\/ keep the addressee layout as it's used below\n+\n+        VarHandle handle = VarHandleCache.get(layout);\n+        if (handle != null) {\n+            return handle;\n+        }\n+\n@@ -111,1 +123,1 @@\n-        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n+        handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -415,14 +415,0 @@\n-    public static final class SimpleVaArg {\n-        public final MemoryLayout layout;\n-        public final Object value;\n-\n-        public SimpleVaArg(MemoryLayout layout, Object value) {\n-            this.layout = layout;\n-            this.value = value;\n-        }\n-\n-        public VarHandle varHandle() {\n-            return layout.varHandle();\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.Comparator;\n@@ -69,1 +68,1 @@\n-    private static final VarHandle VH_SIZE_T_ARRAY = SIZE_T.arrayElementVarHandle();\n+    private static final VarHandle VH_SIZE_T = SIZE_T.varHandle();\n@@ -83,2 +82,2 @@\n-        VH_TYPE.set(ffiType, LibFallback.structTag());\n-        VH_ELEMENTS.set(ffiType, elementsSeg);\n+        VH_TYPE.set(ffiType, 0L, LibFallback.structTag());\n+        VH_ELEMENTS.set(ffiType, 0L, elementsSeg);\n@@ -132,1 +131,1 @@\n-                    long ffiOffset = (long) VH_SIZE_T_ARRAY.get(offsetsOut, offsetIdx++);\n+                    long ffiOffset = sizeTAtIndex(offsetsOut, offsetIdx++);\n@@ -153,0 +152,9 @@\n+\n+    private static long sizeTAtIndex(MemorySegment segment, int index) {\n+        long offset = SIZE_T.scale(0, index);\n+        if (VH_SIZE_T.varType() == long.class) {\n+            return (long) VH_SIZE_T.get(segment, offset);\n+        } else {\n+            return (int) VH_SIZE_T.get(segment, offset); \/\/ 'erase' to long\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -57,1 +58,1 @@\n-        return dup(byteAlignment(), Optional.empty());\n+        return name.isPresent() ? dup(byteAlignment(), Optional.empty()) : (L) this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -36,0 +35,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -38,1 +38,0 @@\n-import java.lang.foreign.AddressLayout;\n@@ -42,2 +41,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -118,18 +115,0 @@\n-        public final VarHandle arrayElementVarHandle(int... shape) {\n-            Objects.requireNonNull(shape);\n-            if (!Utils.isElementAligned((ValueLayout) this)) {\n-                throw new UnsupportedOperationException(\"Layout alignment greater than its size\");\n-            }\n-            MemoryLayout layout = self();\n-            List<MemoryLayout.PathElement> path = new ArrayList<>();\n-            for (int i = shape.length; i > 0; i--) {\n-                int size = shape[i - 1];\n-                if (size < 0) throw new IllegalArgumentException(\"Invalid shape size: \" + size);\n-                layout = MemoryLayout.sequenceLayout(size, layout);\n-                path.add(MemoryLayout.PathElement.sequenceElement());\n-            }\n-            layout = MemoryLayout.sequenceLayout(Long.MAX_VALUE \/ layout.byteSize(), layout);\n-            path.add(MemoryLayout.PathElement.sequenceElement());\n-            return layout.varHandle(path.toArray(new MemoryLayout.PathElement[0]));\n-        }\n-\n@@ -180,1 +159,1 @@\n-        public final VarHandle accessHandle() {\n+        public final VarHandle varHandle() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -252,2 +252,2 @@\n-            accessor.set(container, fieldValue.value());\n-            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual));\n+            accessor.set(container, 0L, fieldValue.value());\n+            return actual -> fieldCheck.accept(accessor.get((MemorySegment) actual, 0L));\n@@ -261,1 +261,1 @@\n-                return (MemorySegment) slicer.invokeExact(container);\n+                return (MemorySegment) slicer.invokeExact(container, 0L);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -86,1 +86,2 @@\n-    static final VarHandle intHandleIndexed = ValueLayout.JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle intHandleIndexed = MethodHandles.collectCoordinates(ValueLayout.JAVA_INT.varHandle(),\n+            1, MethodHandles.insertArguments(ValueLayout.JAVA_INT.scaleHandle(), 0, 0L));\n@@ -88,1 +89,1 @@\n-    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle intHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_INT.varHandle(), 1, 0L);\n@@ -90,1 +91,1 @@\n-    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n+    static final VarHandle floatHandle = MethodHandles.insertCoordinates(ValueLayout.JAVA_FLOAT.varHandle(), 1, 0L);\n@@ -99,2 +100,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -102,1 +103,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -104,1 +105,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -106,1 +107,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -108,1 +109,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -120,3 +121,3 @@\n-        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 1, \"a\", \"b\");\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle = MethodHandles.insertCoordinates(i2SHandle, 2, \"a\", \"b\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -124,1 +125,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -126,1 +127,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -128,1 +129,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -130,1 +131,1 @@\n-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -141,2 +142,2 @@\n-        i2SHandle.set(segment, \"1\");\n-        String oldValue = (String)i2SHandle.getAndAdd(segment, \"42\");\n+        i2SHandle.set(segment, 0L, \"1\");\n+        String oldValue = (String)i2SHandle.getAndAdd(segment, 0L, \"42\");\n@@ -144,1 +145,1 @@\n-        String value = (String)i2SHandle.get(segment);\n+        String value = (String)i2SHandle.get(segment, 0L);\n@@ -146,1 +147,1 @@\n-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, \"43\", \"12\");\n+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment, 0L, \"43\", \"12\");\n@@ -148,1 +149,1 @@\n-        oldValue = (String)i2SHandle.compareAndExchange(segment, \"12\", \"42\");\n+        oldValue = (String)i2SHandle.compareAndExchange(segment, 0L, \"12\", \"42\");\n@@ -150,1 +151,1 @@\n-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment);\n+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment, 0L);\n@@ -197,2 +198,2 @@\n-            vh.set(seg, \"42\");\n-            String x = (String) vh.get(seg); \/\/ should throw\n+            vh.set(seg, 0L, \"42\");\n+            String x = (String) vh.get(seg, 0L); \/\/ should throw\n@@ -208,1 +209,1 @@\n-            vh.set(seg, \"42\"); \/\/ should throw\n+            vh.set(seg, 0L, \"42\"); \/\/ should throw\n@@ -354,0 +355,6 @@\n+    @Test\n+    public void testCollectCoordinatesVoidFilterType() {\n+        VarHandle handle = MethodHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n+        assertEquals(handle.coordinateTypes(), List.of(String.class, MemorySegment.class));\n+    }\n+\n@@ -369,5 +376,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCollectCoordinatesWrongVoidFilterType() {\n-        MethodHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":32,"deletions":30,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -32,0 +33,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -291,0 +295,5 @@\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+                1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n+\n@@ -292,2 +301,2 @@\n-        VarHandle indexedHandleNO = helper.elementLayout.withOrder(NATIVE_ORDER).arrayElementVarHandle();\n-        VarHandle indexedHandleNNO = helper.elementLayout.withOrder(NON_NATIVE_ORDER).arrayElementVarHandle();\n+        VarHandle indexedHandleNO = arrayVarHandle(helper.elementLayout.withOrder(NATIVE_ORDER));\n+        VarHandle indexedHandleNNO = arrayVarHandle(helper.elementLayout.withOrder(NON_NATIVE_ORDER));\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -147,1 +150,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -149,1 +152,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -151,1 +154,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -153,1 +156,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -155,1 +158,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -157,1 +160,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -159,1 +162,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -162,1 +165,1 @@\n-                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, 0L, pos));\n@@ -164,1 +167,1 @@\n-                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, 0L, pos));\n@@ -166,1 +169,1 @@\n-                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, 0L, pos));\n@@ -168,1 +171,1 @@\n-                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, 0L, pos));\n@@ -170,1 +173,1 @@\n-                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, 0L, pos));\n@@ -172,1 +175,1 @@\n-                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, 0L, pos));\n@@ -174,1 +177,1 @@\n-                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, 0L, pos));\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-            indexHandle.set(base, i, (int)i);\n-            valueHandle.set(base, i, (float)(i \/ 500f));\n+            indexHandle.set(base, 0L, i, (int)i);\n+            valueHandle.set(base, 0L, i, (float)(i \/ 500f));\n@@ -134,2 +134,2 @@\n-            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, i));\n-            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, i));\n+            assertEquals(index = bb.getInt(), (int)indexHandle.get(base, 0L, i));\n+            assertEquals(value = bb.getFloat(), (float)valueHandle.get(base, 0L, i));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            int val = (int) abcx.get(a);\n+            int val = (int) abcx.get(a, 0L);\n@@ -112,1 +112,1 @@\n-            int val00 = (int) abcx_multi.get(a, 0, 0); \/\/ a->b[0]->c[0] = 1\n+            int val00 = (int) abcx_multi.get(a, 0L, 0, 0); \/\/ a->b[0]->c[0] = 1\n@@ -114,1 +114,1 @@\n-            int val10 = (int) abcx_multi.get(a, 1, 0); \/\/ a->b[1]->c[0] = 3\n+            int val10 = (int) abcx_multi.get(a, 0L, 1, 0); \/\/ a->b[1]->c[0] = 3\n@@ -116,1 +116,1 @@\n-            int val01 = (int) abcx_multi.get(a, 0, 1); \/\/ a->b[0]->c[1] = 2\n+            int val01 = (int) abcx_multi.get(a, 0L, 0, 1); \/\/ a->b[0]->c[1] = 2\n@@ -118,1 +118,1 @@\n-            int val11 = (int) abcx_multi.get(a, 1, 1); \/\/ a->b[1]->c[1] = 4\n+            int val11 = (int) abcx_multi.get(a, 0L, 1, 1); \/\/ a->b[1]->c[1] = 4\n@@ -146,0 +146,12 @@\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void badDerefMisAligned() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT).withName(\"x\"));\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(struct.byteSize() + 1).asSlice(1);\n+            VarHandle vhX = struct.varHandle(PathElement.groupElement(\"x\"), PathElement.dereferenceElement());\n+            vhX.set(segment, 0L, 42); \/\/ should throw\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-        assertAligned(align, layout, () -> layout.varHandle().get(segment));\n-        assertAligned(align, layout, () -> layout.varHandle().set(segment, val));\n+        assertAligned(align, layout, () -> layout.varHandle().get(segment, 0L));\n+        assertAligned(align, layout, () -> layout.varHandle().set(segment, 0L, val));\n@@ -52,2 +52,2 @@\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L));\n-        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, val));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).get(segment, 0L, 0L));\n+        assertAligned(align, layout, () -> seq.varHandle(MemoryLayout.PathElement.sequenceElement()).set(segment, 0L, 0L, val));\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -45,0 +46,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -137,0 +140,28 @@\n+    @Test\n+    public void testBadAlignmentOfRoot() throws Throwable {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+            JAVA_INT,\n+            JAVA_SHORT.withName(\"x\"));\n+        assertEquals(struct.byteAlignment(), 4);\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = arena.allocate(struct.byteSize() + 2, struct.byteAlignment()).asSlice(2);\n+            assertEquals(seg.address() % JAVA_SHORT.byteAlignment(), 0); \/\/ should be aligned\n+            assertNotEquals(seg.address() % struct.byteAlignment(), 0); \/\/ should not be aligned\n+\n+            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+\n+            VarHandle vhX = struct.varHandle(groupElement(\"x\"));\n+            IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () -> {\n+                vhX.set(seg, 0L, (short) 42);\n+            });\n+            assertEquals(iae.getMessage(), expectedMessage);\n+\n+            MethodHandle sliceX = struct.sliceHandle(groupElement(\"x\"));\n+            iae = expectThrows(IllegalArgumentException.class, () -> {\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg, 0L);\n+            });\n+            assertEquals(iae.getMessage(), expectedMessage);\n+        }\n+    }\n+\n@@ -245,1 +276,1 @@\n-        long actualByteOffset = (long) byteOffsetHandle.invokeExact(indexes);\n+        long actualByteOffset = (long) byteOffsetHandle.invokeExact(0L, indexes);\n@@ -334,1 +365,1 @@\n-            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, indexes);\n+            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, 0L, indexes);\n@@ -341,1 +372,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                indexHandle.set(segment, (long)i, i);\n+                indexHandle.set(segment, 0L, (long)i, i);\n@@ -106,2 +106,2 @@\n-                int expected = (int)indexHandle.get(segment, (long)i);\n-                int found = (int)preindexHandle.get(segment);\n+                int expected = (int)indexHandle.get(segment, 0L, (long)i);\n+                int found = (int)preindexHandle.get(segment, 0L);\n@@ -333,8 +333,0 @@\n-    @Test(dataProvider=\"layoutsAndAlignments\")\n-    public void testArrayElementVarHandleBadAlignment(MemoryLayout layout, long byteAlign) {\n-        if (layout instanceof ValueLayout) {\n-            assertThrows(UnsupportedOperationException.class, () ->\n-                    ((ValueLayout) layout).withByteAlignment(byteAlign * 2).arrayElementVarHandle());\n-        }\n-    }\n-\n@@ -354,0 +346,25 @@\n+    @Test\n+    public void testVarHandleCaching() {\n+        assertSame(JAVA_INT.varHandle(), JAVA_INT.varHandle());\n+        assertSame(JAVA_INT.withName(\"foo\").varHandle(), JAVA_INT.varHandle());\n+\n+        assertNotSame(JAVA_INT_UNALIGNED.varHandle(), JAVA_INT.varHandle());\n+        assertNotSame(ADDRESS.withTargetLayout(JAVA_INT).varHandle(), ADDRESS.varHandle());\n+    }\n+\n+    @Test(expectedExceptions=IllegalArgumentException.class,\n+        expectedExceptionsMessageRegExp=\".*Negative offset.*\")\n+    public void testScaleNegativeOffset() {\n+        JAVA_INT.scale(-1, 0);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleAddOverflow() {\n+        JAVA_INT.scale(Long.MAX_VALUE, 1);\n+    }\n+\n+    @Test(expectedExceptions=ArithmeticException.class)\n+    public void testScaleMultiplyOverflow() {\n+        JAVA_INT.scale(0, Long.MAX_VALUE);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -69,6 +69,0 @@\n-    @Test(dataProvider = \"arrayElements\")\n-    public void testArrayAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, ArrayChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\"));\n-        testArrayAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(), checker);\n-    }\n-\n@@ -161,7 +155,0 @@\n-    @Test(dataProvider = \"matrixElements\")\n-    public void testMatrixAccessAlt(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, MatrixChecker checker) {\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n-                MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\")));\n-        testMatrixAccessInternal(viewFactory, seq, elemLayout.arrayElementVarHandle(10), checker);\n-    }\n-\n@@ -270,2 +257,2 @@\n-            handle.set(segment, (byte)42);\n-            assertEquals(42, (byte)handle.get(segment));\n+            handle.set(segment, 0L, (byte)42);\n+            assertEquals(42, (byte)handle.get(segment, 0L));\n@@ -275,2 +262,2 @@\n-            handle.set(segment, (short)42);\n-            assertEquals(42, (short)handle.get(segment));\n+            handle.set(segment, 0L, (short)42);\n+            assertEquals(42, (short)handle.get(segment, 0L));\n@@ -280,2 +267,2 @@\n-            handle.set(segment, (char)42);\n-            assertEquals(42, (char)handle.get(segment));\n+            handle.set(segment, 0L, (char)42);\n+            assertEquals(42, (char)handle.get(segment, 0L));\n@@ -285,2 +272,2 @@\n-            handle.set(segment, 42);\n-            assertEquals(42, (int)handle.get(segment));\n+            handle.set(segment, 0L, 42);\n+            assertEquals(42, (int)handle.get(segment, 0L));\n@@ -290,2 +277,2 @@\n-            handle.set(segment, (long)42);\n-            assertEquals(42, (long)handle.get(segment));\n+            handle.set(segment, 0L, (long)42);\n+            assertEquals(42, (long)handle.get(segment, 0L));\n@@ -295,2 +282,2 @@\n-            handle.set(segment, (float)42);\n-            assertEquals((float)42, (float)handle.get(segment));\n+            handle.set(segment, 0L, (float)42);\n+            assertEquals((float)42, (float)handle.get(segment, 0L));\n@@ -300,2 +287,2 @@\n-            handle.set(segment, (double)42);\n-            assertEquals((double)42, (double)handle.get(segment));\n+            handle.set(segment, 0L, (double)42);\n+            assertEquals((double)42, (double)handle.get(segment, 0L));\n@@ -347,2 +334,2 @@\n-            handle.set(segment, i, (byte)i);\n-            assertEquals(i, (byte)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (byte)i);\n+            assertEquals(i, (byte)handle.get(segment, 0L, i));\n@@ -352,2 +339,2 @@\n-            handle.set(segment, i, (short)i);\n-            assertEquals(i, (short)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (short)i);\n+            assertEquals(i, (short)handle.get(segment, 0L, i));\n@@ -357,2 +344,2 @@\n-            handle.set(segment, i, (char)i);\n-            assertEquals(i, (char)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (char)i);\n+            assertEquals(i, (char)handle.get(segment, 0L, i));\n@@ -362,2 +349,2 @@\n-            handle.set(segment, i, (int)i);\n-            assertEquals(i, (int)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (int)i);\n+            assertEquals(i, (int)handle.get(segment, 0L, i));\n@@ -367,2 +354,2 @@\n-            handle.set(segment, i, (long)i);\n-            assertEquals(i, (long)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (long)i);\n+            assertEquals(i, (long)handle.get(segment, 0L, i));\n@@ -372,2 +359,2 @@\n-            handle.set(segment, i, (float)i);\n-            assertEquals((float)i, (float)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (float)i);\n+            assertEquals((float)i, (float)handle.get(segment, 0L, i));\n@@ -377,2 +364,2 @@\n-            handle.set(segment, i, (double)i);\n-            assertEquals((double)i, (double)handle.get(segment, i));\n+            handle.set(segment, 0L, i, (double)i);\n+            assertEquals((double)i, (double)handle.get(segment, 0L, i));\n@@ -432,2 +419,2 @@\n-            handle.set(segment, r, c, (byte)(r + c));\n-            assertEquals(r + c, (byte)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (byte)(r + c));\n+            assertEquals(r + c, (byte)handle.get(segment, 0L, r, c));\n@@ -437,2 +424,2 @@\n-            handle.set(segment, r, c, (r + c) != 0);\n-            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, 0L, r, c));\n@@ -442,2 +429,2 @@\n-            handle.set(segment, r, c, (short)(r + c));\n-            assertEquals(r + c, (short)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (short)(r + c));\n+            assertEquals(r + c, (short)handle.get(segment, 0L, r, c));\n@@ -447,2 +434,2 @@\n-            handle.set(segment, r, c, (char)(r + c));\n-            assertEquals(r + c, (char)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (char)(r + c));\n+            assertEquals(r + c, (char)handle.get(segment, 0L, r, c));\n@@ -452,2 +439,2 @@\n-            handle.set(segment, r, c, (int)(r + c));\n-            assertEquals(r + c, (int)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (int)(r + c));\n+            assertEquals(r + c, (int)handle.get(segment, 0L, r, c));\n@@ -457,2 +444,2 @@\n-            handle.set(segment, r, c, r + c);\n-            assertEquals(r + c, (long)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, r + c);\n+            assertEquals(r + c, (long)handle.get(segment, 0L, r, c));\n@@ -462,2 +449,2 @@\n-            handle.set(segment, r, c, MemorySegment.ofAddress(r + c));\n-            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, MemorySegment.ofAddress(r + c));\n+            assertEquals(MemorySegment.ofAddress(r + c), (MemorySegment) handle.get(segment, 0L, r, c));\n@@ -467,2 +454,2 @@\n-            handle.set(segment, r, c, (float)(r + c));\n-            assertEquals((float)(r + c), (float)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (float)(r + c));\n+            assertEquals((float)(r + c), (float)handle.get(segment, 0L, r, c));\n@@ -472,2 +459,2 @@\n-            handle.set(segment, r, c, (double)(r + c));\n-            assertEquals((double)(r + c), (double)handle.get(segment, r, c));\n+            handle.set(segment, 0L, r, c, (double)(r + c));\n+            assertEquals((double)(r + c), (double)handle.get(segment, 0L, r, c));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":46,"deletions":59,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-            vh.set(segment, -42);\n-            int val = (int)vh.get(segment);\n+            vh.set(segment, 0L, -42);\n+            int val = (int)vh.get(segment, 0L);\n@@ -68,1 +68,1 @@\n-            vh.set(segment.asSlice(1L), -42);\n+            vh.set(segment.asSlice(1L), 0L, -42);\n@@ -96,1 +96,1 @@\n-                    vh.set(segment, i, -42);\n+                    vh.set(segment, 0L, i, -42);\n@@ -119,6 +119,6 @@\n-            vh_c.set(segment, Byte.MIN_VALUE);\n-            assertEquals(vh_c.get(segment), Byte.MIN_VALUE);\n-            vh_s.set(segment, Short.MIN_VALUE);\n-            assertEquals(vh_s.get(segment), Short.MIN_VALUE);\n-            vh_i.set(segment, Integer.MIN_VALUE);\n-            assertEquals(vh_i.get(segment), Integer.MIN_VALUE);\n+            vh_c.set(segment, 0L, Byte.MIN_VALUE);\n+            assertEquals(vh_c.get(segment, 0L), Byte.MIN_VALUE);\n+            vh_s.set(segment, 0L, Short.MIN_VALUE);\n+            assertEquals(vh_s.get(segment, 0L), Short.MIN_VALUE);\n+            vh_i.set(segment, 0L, Integer.MIN_VALUE);\n+            assertEquals(vh_i.get(segment, 0L), Integer.MIN_VALUE);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -200,2 +200,2 @@\n-                xh.set(segment, i, 1);\n-                yh.set(segment, i, (int) i);\n+                xh.set(segment, 0L, i, 1);\n+                yh.set(segment, 0L, i, (int) i);\n@@ -241,3 +241,3 @@\n-            u0.varHandle(PathElement.groupElement(\"x\")).set(segment, 1);\n-            u1.varHandle(PathElement.groupElement(\"y\")).set(segment, 2);\n-            u1.varHandle(PathElement.groupElement(\"z\")).set(segment, 3);\n+            u0.varHandle(PathElement.groupElement(\"x\")).set(segment, 0L, 1);\n+            u1.varHandle(PathElement.groupElement(\"y\")).set(segment, 0L, 2);\n+            u1.varHandle(PathElement.groupElement(\"z\")).set(segment, 0L, 3);\n@@ -268,1 +268,1 @@\n-            return (int) xVH.get(memorySegment);\n+            return (int) xVH.get(memorySegment, 0L);\n@@ -272,1 +272,1 @@\n-            return (int) yVH.get(memorySegment);\n+            return (int) yVH.get(memorySegment, 0L);\n@@ -276,1 +276,1 @@\n-            xVH.set(memorySegment, x);\n+            xVH.set(memorySegment, 0L, x);\n@@ -280,1 +280,1 @@\n-            yVH.set(memorySegment, y);\n+            yVH.set(memorySegment, 0L, y);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> byteHandle.set(addr, 0L, pos, (byte)(long)pos));\n@@ -213,1 +213,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, pos, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> charHandle.set(addr, 0L, pos, (char)(long)pos));\n@@ -215,1 +215,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, pos, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> shortHandle.set(addr, 0L, pos, (short)(long)pos));\n@@ -217,1 +217,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, pos, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> intHandle.set(addr, 0L, pos, (int)(long)pos));\n@@ -219,1 +219,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, pos, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> floatHandle.set(addr, 0L, pos, (float)(long)pos));\n@@ -221,1 +221,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, pos, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> longHandle.set(addr, 0L, pos, (long)pos));\n@@ -223,1 +223,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, pos, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> doubleHandle.set(addr, 0L, pos, (double)(long)pos));\n@@ -226,1 +226,1 @@\n-                (base) -> checkBytes(base, bytes, byteHandle::get, bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n+                (base) -> checkBytes(base, bytes, (addr, pos) -> byteHandle.get(addr, 0L, pos), bb -> bb, TestNative::getByteBuffer, TestNative::getByteRaw);\n@@ -228,1 +228,1 @@\n-                (base) -> checkBytes(base, chars, charHandle::get, ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n+                (base) -> checkBytes(base, chars, (addr, pos) -> charHandle.get(addr, 0L, pos), ByteBuffer::asCharBuffer, TestNative::getCharBuffer, TestNative::getCharRaw);\n@@ -230,1 +230,1 @@\n-                (base) -> checkBytes(base, shorts, shortHandle::get, ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n+                (base) -> checkBytes(base, shorts, (addr, pos) -> shortHandle.get(addr, 0L, pos), ByteBuffer::asShortBuffer, TestNative::getShortBuffer, TestNative::getShortRaw);\n@@ -232,1 +232,1 @@\n-                (base) -> checkBytes(base, ints, intHandle::get, ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n+                (base) -> checkBytes(base, ints, (addr, pos) -> intHandle.get(addr, 0L, pos), ByteBuffer::asIntBuffer, TestNative::getIntBuffer, TestNative::getIntRaw);\n@@ -234,1 +234,1 @@\n-                (base) -> checkBytes(base, floats, floatHandle::get, ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n+                (base) -> checkBytes(base, floats, (addr, pos) -> floatHandle.get(addr, 0L, pos), ByteBuffer::asFloatBuffer, TestNative::getFloatBuffer, TestNative::getFloatRaw);\n@@ -236,1 +236,1 @@\n-                (base) -> checkBytes(base, longs, longHandle::get, ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n+                (base) -> checkBytes(base, longs, (addr, pos) -> longHandle.get(addr, 0L, pos), ByteBuffer::asLongBuffer, TestNative::getLongBuffer, TestNative::getLongRaw);\n@@ -238,1 +238,1 @@\n-                (base) -> checkBytes(base, doubles, doubleHandle::get, ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n+                (base) -> checkBytes(base, doubles, (addr, pos) -> doubleHandle.get(addr, 0L, pos), ByteBuffer::asDoubleBuffer, TestNative::getDoubleBuffer, TestNative::getDoubleRaw);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-        addDefaultMapping(VarHandle.class, MethodHandles.memorySegmentViewVarHandle(JAVA_INT));\n+        addDefaultMapping(VarHandle.class, JAVA_INT.varHandle());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                        assertEquals(value, handle.get(address));\n+                        assertEquals(value, handle.get(address, 0L));\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-            return MethodHandles.memorySegmentViewVarHandle(layout);\n+            return layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -98,1 +98,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n@@ -251,1 +251,1 @@\n-        VarHandle byteHandle = ValueLayout.JAVA_BYTE.arrayElementVarHandle();\n+        VarHandle byteHandle = ValueLayout.JAVA_BYTE.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        return (int)intHandle.getVolatile(base);\n+        return (int)intHandle.getVolatile(base, 0L);\n@@ -158,1 +158,1 @@\n-        intHandle.setVolatile(base, value);\n+        intHandle.setVolatile(base, 0L, value);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                    VH_ALL.set(segment, i, j, (int)j + 1 + ((int)i * 5));\n+                    VH_ALL.set(segment, 0L, i, j, (int)j + 1 + ((int)i * 5));\n@@ -68,2 +68,2 @@\n-            assertThrows(() -> handle.get(segment, lo, 0));\n-            assertThrows(() -> handle.get(segment, 0, hi));\n+            assertThrows(() -> handle.get(segment, 0L, lo, 0));\n+            assertThrows(() -> handle.get(segment, 0L, 0, hi));\n@@ -77,1 +77,1 @@\n-                int x = (int) handle.get(segment, i, j);\n+                int x = (int) handle.get(segment, 0L, i, j);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.arrayElementVarHandle();\n-\n@@ -59,1 +57,1 @@\n-                INT_HANDLE.set(segment, (long) i, i);\n+                segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -86,1 +84,1 @@\n-            INT_HANDLE.set(segment, (long) i, i);\n+            segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n@@ -163,1 +161,1 @@\n-        return acc + (int)INT_HANDLE.get(segment, 0L);\n+        return acc + segment.getAtIndex(ValueLayout.JAVA_INT, 0);\n@@ -170,1 +168,1 @@\n-            sum += (int)INT_HANDLE.get(segment, (long)i);\n+            sum += segment.getAtIndex(ValueLayout.JAVA_INT, i);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        int v = (int)INT_HANDLE.get(\"string\");\n+        int v = (int)INT_HANDLE.get(\"string\", 0L);\n@@ -57,2 +57,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            String address = (String)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            String address = (String)ADDR_HANDLE.get(s, 0L);\n@@ -66,1 +66,1 @@\n-            ADDR_HANDLE.set(s, \"string\");\n+            ADDR_HANDLE.set(s, 0L, \"string\");\n@@ -73,2 +73,2 @@\n-            MemorySegment s = arena.allocate(8, 8);;\n-            int address = (int)ADDR_HANDLE.get(s);\n+            MemorySegment s = arena.allocate(8, 8);\n+            int address = (int)ADDR_HANDLE.get(s, 0L);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -54,1 +55,0 @@\n-    static final VarHandle VH_IntArray = C_INT.arrayElementVarHandle();\n@@ -85,1 +85,1 @@\n-                VH_IntArray.set(argIDs, (long) i, args.get(i).id.ordinal());\n+                argIDs.setAtIndex(ValueLayout.JAVA_INT, i, args.get(i).id.ordinal());\n@@ -200,1 +200,1 @@\n-            VH_writeback.set(seg, addr);\n+            VH_writeback.set(seg, 0L, addr);\n@@ -203,1 +203,1 @@\n-            VH_argIDs.set(seg, addr);\n+            VH_argIDs.set(seg, 0L, addr);\n@@ -222,1 +222,3 @@\n-            return new Arg(id, layout, value, layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET));\n+            MethodHandle getterHandle = layout.varHandle().toMethodHandle(VarHandle.AccessMode.GET);\n+            getterHandle = MethodHandles.insertArguments(getterHandle, 1, 0L); \/\/ align signature with getter for structs\n+            return new Arg(id, layout, value, getterHandle);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE);\n+        VarHandle vh = ValueLayout.JAVA_BYTE.varHandle();\n@@ -56,1 +56,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(4));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(4).varHandle();\n@@ -66,1 +66,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_BYTE.withByteAlignment(2));\n+        VarHandle vh = ValueLayout.JAVA_BYTE.withByteAlignment(2).varHandle();\n@@ -76,2 +76,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.LITTLE_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.LITTLE_ENDIAN).varHandle();\n@@ -87,2 +86,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_SHORT_UNALIGNED\n-                .withOrder(ByteOrder.BIG_ENDIAN));\n+        VarHandle vh = ValueLayout.JAVA_SHORT_UNALIGNED.withOrder(ByteOrder.BIG_ENDIAN).varHandle();\n@@ -103,1 +101,1 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayout.JAVA_INT);\n+        VarHandle vh = ValueLayout.JAVA_INT.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            int savedErrno = (int) errnoHandle.get(saveSeg, 0L);\n@@ -141,1 +141,1 @@\n-            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+            check = check.andThen(o -> assertEquals(fieldHandle.get(o, 0L), value));\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            long x = (long) vhX.get(result);\n+            long x = (long) vhX.get(result, 0L);\n@@ -78,1 +78,1 @@\n-            long y = (long) vhY.get(result);\n+            long y = (long) vhY.get(result, 0L);\n@@ -92,1 +92,1 @@\n-            int capturedErrno = (int) errnoHandle.get(captureSeg);\n+            int capturedErrno = (int) errnoHandle.get(captureSeg, 0L);\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -29,1 +30,4 @@\n-import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG_UNALIGNED;\n@@ -32,1 +36,1 @@\n- * Some useful Java {@link ValueLayout} and associated {@link ValueLayout#arrayElementVarHandle(int...)} var handles.\n+ * Some useful Java {@link ValueLayout} and associated array var handles.\n@@ -36,1 +40,2 @@\n-    static final VarHandle VH_INT_UNALIGNED = JAVA_INT_UNALIGNED.arrayElementVarHandle();\n+    static final VarHandle VH_INT_UNALIGNED = arrayVarHandle(JAVA_INT_UNALIGNED);\n+    static final VarHandle VH_INT = arrayVarHandle(JAVA_INT);\n@@ -38,1 +43,7 @@\n-    static final VarHandle VH_INT = JAVA_INT.arrayElementVarHandle();\n+    static final VarHandle VH_LONG_UNALIGNED = arrayVarHandle(JAVA_LONG_UNALIGNED);\n+    static final VarHandle VH_LONG = arrayVarHandle(JAVA_LONG);\n+\n+    private static VarHandle arrayVarHandle(ValueLayout layout) {\n+        return MethodHandles.collectCoordinates(layout.varHandle(),\n+            1, MethodHandles.insertArguments(layout.scaleHandle(), 0, 0L));\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,4 +48,0 @@\n-    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        generic = MethodHandles.memorySegmentViewVarHandle(JAVA_INT);\n+        generic = JAVA_INT.varHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        VH_x.set(segment, x);\n+        VH_x.set(segment, 0L, x);\n@@ -75,1 +75,1 @@\n-        return (int) VH_x.get(segment);\n+        return (int) VH_x.get(segment, 0L);\n@@ -79,1 +79,1 @@\n-        VH_y.set(segment, y);\n+        VH_y.set(segment, 0L, y);\n@@ -83,1 +83,1 @@\n-        return (int) VH_y.get(segment);\n+        return (int) VH_y.get(segment, 0L);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}