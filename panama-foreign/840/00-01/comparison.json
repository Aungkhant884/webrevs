{"files":[{"patch":"@@ -240,5 +240,5 @@\n- * {@linkplain ValueLayout#byteSize() byte size} of this layout, and an alignment constraint {@code B}, derived from the\n- * {@linkplain ValueLayout#byteAlignment() alignment constraint} of this value layout. We say that a memory access\n- * operation is <em>fully aligned<\/em> if it occurs at a memory address {@code A} which is compatible with both alignment\n- * constraints {@code S} and {@code B}. If access is fully aligned then following access modes are supported and are\n- * guaranteed to support atomic access:\n+ * {@linkplain ValueLayout#byteSize() byte size} of the receiver layout, and an alignment constraint {@code B}, derived\n+ * from the {@linkplain ValueLayout#byteAlignment() alignment constraint} of the receiver layout. We say that a memory\n+ * access operation is <em>fully aligned<\/em> if it occurs at a memory address {@code A} which is compatible with both\n+ * alignment constraints {@code S} and {@code B}. If access is fully aligned then following access modes are supported\n+ * and are guaranteed to support atomic access:\n@@ -426,2 +426,2 @@\n-     *     <li>it has two leading access coordinates of type {@link MemorySegment} and {@code long},\n-     *     representing the accessed segment and base offset respectively<\/li>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} representing the accessed segment<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n@@ -434,3 +434,1 @@\n-     * A layout path consists of zero or more <em>path sections<\/em> delimited by\n-     * <a href=#deref-path-elements>dereference path elements<\/a>. For each section of the layout path, the  final\n-     * accessed address can be computed as follows:\n+     * The final address accessed by the returned var handle can be computed as follows:\n@@ -439,1 +437,4 @@\n-     * address = base(segment) + offset\n+     * address_1 = base(segment_1) + offset_1\n+     * address_2 = base(segment_2) + offset_2\n+     * ...\n+     * address_k = base(segment_k-1) + offset_k\n@@ -442,6 +443,17 @@\n-     * Where {@code base(segment)} denotes a function that returns the physical base address of the accessed memory segment.\n-     * For native segments, this function just returns the native segment's {@linkplain MemorySegment#address() address}.\n-     * For heap segments, this function is more complex, as the address of heap segments is virtualized. The {@code offset}\n-     * is obtained as if by a call to a {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using\n-     * the path elements pertaining to a particular path section. Where the arguments are taken from the dynamic\n-     * {@code long} coordinates corresponding to that path section.\n+     * where {@code k} is the number of <a href=#deref-path-elements>dereference path elements<\/a> in a layout path,\n+     * {@code segment_1} is the input segment, {@code segment_2}, ...  {@code segment_k-1} are the segments obtained by\n+     * dereferencing the address associated with a given dereference path element (e.g. {@code segment_2} is a native\n+     * segment whose base address is {@code address_1}), and {@code offset_1}, {@code offset_2}, ... {@code offset_k}\n+     * are the offsets computed based on the path elements corresponding to a particular section,\n+     * {@code address_i = base(segment_i) + offset_i}, of the path, where {@code 0 < i <= k}. {@code base(segment)}\n+     * denotes a function that returns the physical base address of the accessed memory segment. For native segments,\n+     * this function just returns the native segment's {@linkplain MemorySegment#address() address}. For heap segments,\n+     * this function is more complex, as the address of heap segments is virtualized. Each {@code offset_i} corresponding\n+     * to a section of the path, is computed as if by a call to a {@linkplain #byteOffsetHandle(PathElement...) byte offset handle}\n+     * constructed using the path elements pertaining to that particular section of the path. The arguments to the byte\n+     * offset handle are taken from the dynamic {@code long} coordinates corresponding to that path section. The base\n+     * offset parameter of the returned var handle is used in the offset computation of the first path section. The base\n+     * offset used when computing the offset for the other path sections is zero.\n+     * <p>\n+     * All memory accesses immediately preceding a dereference operation (e.g. those at addresses {@code address_1},\n+     * {@code address_2}, ..., {@code address_k-1} are performed using the {@link VarHandle.AccessMode#GET} access mode.\n@@ -449,1 +461,1 @@\n-     * The accessed address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n+     * The base address must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the {@linkplain\n@@ -456,24 +468,0 @@\n-     * Multiple path sections can be chained, with <a href=#deref-path-elements>dereference path elements<\/a>.\n-     * A dereference path element constructs a fresh native memory segment whose base address is the address value\n-     * obtained by accessing a memory segment at the offset determined by the layout path elements immediately\n-     * preceding the dereference path element. In other words, if a layout path contains one or more dereference path\n-     * elements, the final address accessed by the returned var handle can be computed as follows:\n-     *\n-     * <blockquote><pre>{@code\n-     * address_1 = base(segment) + offset_1\n-     * address_2 = base(segment_1) + offset_2\n-     * ...\n-     * address_k = base(segment_k-1) + offset_k\n-     * }<\/pre><\/blockquote>\n-     *\n-     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n-     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n-     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n-     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n-     * the path elements after a given dereference operation. These offsets are again obtained as if by a call to a\n-     * {@linkplain #byteOffsetHandle(PathElement...) byte offset handle} constructed using the path elements pertaining\n-     * to a particular path section, except that for any offset besides {@code offset_1}, the base offset argument is\n-     * assumed to be {@code 0}. In these more complex access operations, all memory accesses immediately preceding a\n-     * dereference operation (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1}\n-     * are performed using the {@link VarHandle.AccessMode#GET} access mode.\n-     * <p>\n@@ -516,2 +504,2 @@\n-     *     <li>it has two leading parameter of type {@code MemorySegment} and {@code long}, corresponding to the memory segment\n-     *     to be sliced, and the base offset respectively;<\/li>\n+     *     <li>it has a leading parameter of type {@code MemorySegment} corresponding to the memory segment to be sliced<\/li>\n+     *     <li>a following {@code long} parameter, corresponding to the base offset<\/li>\n@@ -525,0 +513,4 @@\n+     * <p>\n+     * The segment to be sliced must be <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     * {@linkplain #byteAlignment() alignment constraint} of the root layout (this layout). Note that this can be more\n+     * strict (but not less) than the alignment constraint of the selected value layout.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":36,"deletions":44,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.nio.channels.FileChannel.*;\n+import java.nio.channels.FileChannel.MapMode;\n@@ -50,2 +50,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.layout.ValueLayouts;\n@@ -130,7 +128,6 @@\n- * More complex access operations can be expressed using var handles. The {@link ValueLayout#varHandle()}\n- * method can be used to obtain a var handle that can be used as a getter or setter for values represented by the given value layout.\n- * It supports the plain get and set access modes just like the get and set methods found on {@link MemorySegment}, but it also\n- * supports special access modes like {@linkplain java.lang.invoke.VarHandle#getVolatile(Object...) volatile access},\n- * or {@linkplain java.lang.invoke.VarHandle#compareAndExchange(Object...) compare and exchange}. More importantly, var\n- * handles can be <em>combined<\/em> with method handles to express complex access operations. For instance, a var handle\n- * that expresses access to an element of an {@code int} array can be created as follows:\n+ * More complex access operations can be implemented using var handles. The {@link ValueLayout#varHandle()}\n+ * method can be used to obtain a var handle that can be used to get\/set values represented by the given value layout on a memory segment.\n+ * A var handle obtained from a layout supports several additional <a href=MemoryLayout.html#access-mode-restrictions>\n+ * access modes<\/a>. More importantly, var handles can be <em>combined<\/em> with method handles to express complex access\n+ * operations. For instance, a var handle that can be used to access an element of an {@code int} array at a given logical\n+ * index can be created as follows:\n@@ -150,1 +147,1 @@\n- * path elements<\/em>, selects a value layout to be access, which can be nested inside another memory layout. For example,\n+ * path elements<\/em>, selects a value layout to be accessed, which can be nested inside another memory layout. For example,\n@@ -155,3 +152,7 @@\n- * MemoryLayout segmentLayout = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT); \/\/ array of 4 elements\n- * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.sequenceElement());\n- * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + 3 * 4 = 12\n+ * MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"size\"),\n+ *     MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+ * );\n+ * VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElemenet.groupElement(\"data\"),\n+ *                                               MemoryLayout.PathElement.sequenceElement());\n+ * int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n@@ -159,0 +160,1 @@\n+ * Where {@code offsetof(data)} is the offset of the {@code data} element layout of the {@code segmentLayout} layout\n@@ -163,2 +165,2 @@\n- * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This extra\n- * parameter allows a user to combine these handles further with additional offset computations. This is demonstrated\n+ * feature a <em>base offset<\/em> parameter. This parameter represents a base offset for the offset computation. This\n+ * parameter allows a client to combine these handles further with additional offset computations. This is demonstrated\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-\n@@ -98,1 +97,1 @@\n-     * {@return a var handle which can be used to access values represented by this value layout, in a given memory segment.}\n+     * {@return a var handle which can be used to access values describe by this value layout, in a given memory segment.}\n@@ -108,0 +107,3 @@\n+     * @apiNote This method is similar, but more efficient, than calling {@code MemoryLayout#varHandle(PathElement...)}\n+     * with zero arguments, as it avoids the creation of the var args array.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -410,3 +410,7 @@\n-                MemoryLayout segmentLayout = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n-                VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.sequenceElement());\n-                int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 3 * 4 = 12\n+                MemoryLayout segmentLayout = MemoryLayout.structLayout(\n+                    ValueLayout.JAVA_INT.withName(\"size\"),\n+                    MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT).withName(\"data\") \/\/ array of 4 elements\n+                );\n+                VarHandle intHandle = segmentLayout.varHandle(MemoryLayout.PathElement.groupElement(\"data\"),\n+                                                              MemoryLayout.PathElement.sequenceElement());\n+                int value = (int) intHandle.get(segment, 0L, 3L); \/\/ get int element at offset 0 + offsetof(data) + 3 * 4 = 12\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/snippet-files\/Snippets.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -8112,13 +8112,12 @@\n-     * If {@code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of\n-     * type {@code R} as its coordinate in position {@code pos}, preceded and\/or followed by\n-     * any coordinate not passed to the filter.\n-     * No coordinates are reordered, and the result returned from the filter\n-     * replaces (in order) the whole subsequence of coordinates originally\n-     * passed to the adapter.\n-     * <p>\n-     * The argument types (if any) of the filter\n-     * replace zero or one coordinate types of the target var handle, at position {@code pos},\n-     * in the resulting adapted var handle.\n-     * The return type of the filter must be identical to the\n-     * coordinate type of the target var handle at position {@code pos}, and that target var handle\n-     * coordinate is supplied by the return value of the filter.\n+     * If {@code R} is the return type of the filter, then:\n+     * <ul>\n+     * <li>if {@code R} <em>is not<\/em> {@code void}, the target var handle must have a coordinate of type {@code R} in\n+     * position {@code pos}. The parameter types of the filter will replace the coordinate type at position {@code pos}\n+     * of the target var handle. When the returned var handle is invoked, it will be as if the filter is invoked first,\n+     * and its result is passed in place of the coordinate at position {@code pos} in a downstream invocation of the\n+     * target var handle.<\/li>\n+     * <li> if {@code R} <em>is<\/em> {@code void}, the parameter types (if any) of the filter will be inserted in the\n+     * coordinate type list of the target var handle at position {@code pos}. In this case, when the returned var handle\n+     * is invoked, the filter essentially acts as a side effect, consuming some of the coordinate values, before a\n+     * downstream invocation of the target var handle.<\/li>\n+     * <\/ul>\n@@ -8133,1 +8132,1 @@\n-     * @param pos the position of the coordinate to be filtered\n+     * @param pos the position in the coordinate list of the target var handle where the filter is to be inserted\n@@ -8138,1 +8137,1 @@\n-     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,\n+     * is not void, and it is not the same as the {@code pos} coordinate of the target var handle,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    private static final MethodHandle MH_SLICE_LAYOUT;;\n@@ -73,0 +74,2 @@\n+                    MethodType.methodType(MemorySegment.class, long.class, long.class));\n+            MH_SLICE_LAYOUT = lookup.findVirtual(MemorySegment.class, \"asSlice\",\n@@ -204,1 +207,4 @@\n-        VarHandle handle = valueLayout.varHandle();\n+        \/\/ If we have an enclosing layout, drop the alignment check for the accessed element,\n+        \/\/ we check the root layout instead\n+        ValueLayout accessedLayout = enclosing != null ? valueLayout.withByteAlignment(1) : valueLayout;\n+        VarHandle handle = accessedLayout.varHandle();\n@@ -206,1 +212,5 @@\n-        if (enclosing != null) {\n+\n+        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n+        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n+        \/\/ (see Utils::longToAddress)\n+        if (derefAdapters.length == 0 && enclosing != null) {\n@@ -256,2 +266,9 @@\n-        MethodHandle sliceHandle = MH_SLICE; \/\/ (MS, long, MemoryLayout) -> MS\n-        sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout); \/\/ (MS, long, ...) -> MS\n+        MethodHandle sliceHandle;\n+        if (enclosing != null) {\n+            \/\/ drop the alignment check for the accessed element, we check the root layout instead\n+            sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n+            sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n+        } else {\n+            sliceHandle = MH_SLICE_LAYOUT; \/\/ (MS, long, MemoryLayout) -> MS\n+            sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout); \/\/ (MS, long) -> MS\n+        }\n@@ -274,1 +291,1 @@\n-            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints\");\n+            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints: \" + constraint.byteAlignment());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -146,0 +146,12 @@\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void badDerefMisAligned() {\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT).withName(\"x\"));\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(struct.byteSize() + 1).asSlice(1);\n+            VarHandle vhX = struct.varHandle(PathElement.groupElement(\"x\"), PathElement.dereferenceElement());\n+            vhX.set(segment, 0L, 42); \/\/ should throw\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -139,2 +140,2 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAlignmentOfRoot() {\n+    @Test\n+    public void testBadAlignmentOfRoot() throws Throwable {\n@@ -142,3 +143,4 @@\n-            JAVA_LONG,\n-            JAVA_INT.withName(\"x\"));\n-        VarHandle vhX = struct.varHandle(groupElement(\"x\"));\n+            JAVA_INT,\n+            JAVA_SHORT.withName(\"x\"));\n+        assertEquals(struct.byteAlignment(), 4);\n+\n@@ -146,2 +148,2 @@\n-            MemorySegment seg = arena.allocate(struct.byteSize() + 4, 8).asSlice(4);\n-            assertEquals(seg.address() % JAVA_INT.byteAlignment(), 0); \/\/ should be aligned\n+            MemorySegment seg = arena.allocate(struct.byteSize() + 2, struct.byteAlignment()).asSlice(2);\n+            assertEquals(seg.address() % JAVA_SHORT.byteAlignment(), 0); \/\/ should be aligned\n@@ -150,1 +152,13 @@\n-            vhX.set(seg, 0L, 42); \/\/ should throw\n+            String expectedMessage = \"Target offset incompatible with alignment constraints: \" + struct.byteAlignment();\n+\n+            VarHandle vhX = struct.varHandle(groupElement(\"x\"));\n+            IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () -> {\n+                vhX.set(seg, 0L, (short) 42);\n+            });\n+            assertEquals(iae.getMessage(), expectedMessage);\n+\n+            MethodHandle sliceX = struct.sliceHandle(groupElement(\"x\"));\n+            iae = expectThrows(IllegalArgumentException.class, () -> {\n+                MemorySegment slice = (MemorySegment) sliceX.invokeExact(seg, 0L);\n+            });\n+            assertEquals(iae.getMessage(), expectedMessage);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"}]}