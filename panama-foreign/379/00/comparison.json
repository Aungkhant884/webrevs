{"files":[{"patch":"@@ -21,0 +21,4 @@\n+    public static NativeScope emptyScope() {\n+        return new EmptyScope();\n+    }\n+\n@@ -134,0 +138,22 @@\n+\n+    \/\/ only for registering\n+    private static class EmptyScope extends AbstractNativeScope {\n+        public EmptyScope() {\n+            super(Thread.currentThread());\n+        }\n+\n+        @Override\n+        public OptionalLong byteSize() {\n+            return OptionalLong.of(0);\n+        }\n+\n+        @Override\n+        public long allocatedBytes() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            throw new OutOfMemoryError(\"Not enough space left to allocate\");\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractNativeScope.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class));\n+                    methodType(MemorySegment.class, MemoryAddress.class, long.class, SharedUtils.Allocator.class));\n@@ -840,1 +840,1 @@\n-     * Box_ADDRESS()\n+     * BOX_ADDRESS()\n@@ -910,2 +910,2 @@\n-     * BASE_ADDRESS([size])\n-     *   Pops a MemoryAddress from the operand stack, and takes the converts it to a MemorySegment\n+     * TO_SEGMENT([size])\n+     *   Pops a MemoryAddress from the operand stack, and converts it to a MemorySegment\n@@ -923,3 +923,3 @@\n-        \/\/ FIXME should register with scope\n-        private static MemorySegment toSegment(MemoryAddress operand, long size) {\n-            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+        private static MemorySegment toSegment(MemoryAddress operand, long size, SharedUtils.Allocator allocator) {\n+            MemorySegment ms = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+            return allocator.handoff(ms);\n@@ -939,1 +939,1 @@\n-            MemorySegment segment = toSegment(operand, size);\n+            MemorySegment segment = toSegment(operand, size, allocator);\n@@ -946,1 +946,2 @@\n-            return filterArguments(specializedHandle, insertPos, toSegmentHandle);\n+            specializedHandle = filterArguments(specializedHandle, insertPos, toSegmentHandle);\n+            return Binding.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils.Allocator;\n@@ -97,2 +97,2 @@\n-            MH_WRAP_SCOPE = lookup.findStatic(SharedUtils.Allocator.class, \"ofScope\",\n-                    methodType(SharedUtils.Allocator.class, NativeScope.class));\n+            MH_WRAP_SCOPE = lookup.findStatic(Allocator.class, \"ofScope\",\n+                    methodType(Allocator.class, NativeScope.class));\n@@ -129,18 +129,1 @@\n-        this.bufferCopySize = bufferCopySize(callingSequence);\n-    }\n-\n-    private static long bufferCopySize(CallingSequence callingSequence) {\n-        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n-        \/\/ starting address of the allocator might be un-aligned.\n-        long size = 0;\n-        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            for (Binding b : bindings) {\n-                if (b instanceof Binding.Copy) {\n-                    Binding.Copy c = (Binding.Copy) b;\n-                    size = Utils.alignUp(size, c.alignment());\n-                    size += c.size();\n-                }\n-            }\n-        }\n-        return size;\n+        this.bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n@@ -224,1 +207,1 @@\n-            specializedHandle = dropArguments(specializedHandle, argAllocatorPos, SharedUtils.Allocator.class);\n+            specializedHandle = dropArguments(specializedHandle, argAllocatorPos, Allocator.class);\n@@ -245,1 +228,1 @@\n-            returnFilter = dropArguments(returnFilter, retAllocatorPos, SharedUtils.Allocator.class);\n+            returnFilter = dropArguments(returnFilter, retAllocatorPos, Allocator.class);\n@@ -344,2 +327,2 @@\n-        SharedUtils.Allocator unboxAllocator = bufferCopySize != 0\n-                ? SharedUtils.Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n+        Allocator unboxAllocator = bufferCopySize != 0\n+                ? Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":8,"deletions":25,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.foreign.NativeScope;\n@@ -31,1 +31,1 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils.Allocator;\n@@ -37,2 +37,0 @@\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n@@ -42,1 +40,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.DEFAULT_ALLOCATOR;\n@@ -66,0 +63,2 @@\n+    private final long bufferCopySize;\n+\n@@ -73,0 +72,1 @@\n+        this.bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n@@ -85,1 +85,4 @@\n-        try {\n+        Allocator allocator = bufferCopySize != 0\n+                ? Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n+                : Allocator.empty();\n+        try (allocator) {\n@@ -102,1 +105,1 @@\n-                        }, DEFAULT_ALLOCATOR);\n+                        }, allocator);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.foreign.AbstractNativeScope;\n@@ -267,0 +268,21 @@\n+    static long bufferCopySize(CallingSequence callingSequence) {\n+        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n+        \/\/ starting address of the allocator might be un-aligned.\n+        long size = 0;\n+        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n+            List<Binding> bindings = callingSequence.argumentBindings(i);\n+            for (Binding b : bindings) {\n+                if (b instanceof Binding.Copy) {\n+                    Binding.Copy c = (Binding.Copy) b;\n+                    size = Utils.alignUp(size, c.alignment());\n+                    size += c.size();\n+                } else if (b instanceof Binding.Allocate) {\n+                    Binding.Allocate c = (Binding.Allocate) b;\n+                    size = Utils.alignUp(size, c.alignment());\n+                    size += c.size();\n+                }\n+            }\n+        }\n+        return size;\n+    }\n+\n@@ -371,0 +393,4 @@\n+        static Allocator empty() {\n+            return Allocator.ofScope(AbstractNativeScope.emptyScope());\n+        }\n+\n@@ -382,0 +408,4 @@\n+        default MemorySegment handoff(MemorySegment ms) {\n+            return ms;\n+        }\n+\n@@ -391,0 +421,5 @@\n+                @Override\n+                public MemorySegment handoff(MemorySegment ms) {\n+                    return ms.handoff(scope);\n+                }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -410,3 +410,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -282,3 +282,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\", MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n+            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\",\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, List.class));\n@@ -158,1 +159,1 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, segments);\n@@ -196,1 +197,10 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+                copies.add(copy);\n+            }\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                    MethodType.methodType(void.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(void.class, Object[].class, AtomicReference.class, List.class));\n@@ -107,1 +107,10 @@\n-    static void passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static void passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+                copies.add(copy);\n+            }\n+        }\n@@ -114,0 +123,1 @@\n+        List<MemorySegment> segments = new ArrayList<>();\n@@ -115,1 +125,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs)\n+        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs, segments)\n@@ -119,1 +129,0 @@\n-            List<MemorySegment> segments = new ArrayList<>();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   TestUpcallStructScope\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   TestUpcallStructScope\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static org.testng.Assert.assertFalse;\n+\n+public class TestUpcallStructScope {\n+    static final MethodHandle MH_do_upcall;\n+    static final CLinker LINKER = CLinker.getInstance();\n+    static final MethodHandle MH_Consumer_accept;\n+\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.ofStruct(\n+        C_POINTER.withName(\"p0\"),\n+        C_DOUBLE.withName(\"p1\"),\n+        C_INT.withName(\"p2\")\n+    );\n+\n+    static {\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallStructScope\");\n+        MH_do_upcall = LINKER.downcallHandle(\n+            lookup.lookup(\"do_upcall\").orElseThrow(),\n+            MethodType.methodType(void.class, MemoryAddress.class, MemorySegment.class),\n+            FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n+        );\n+\n+        try {\n+            MH_Consumer_accept = MethodHandles.publicLookup().findVirtual(Consumer.class, \"accept\",\n+                    MethodType.methodType(void.class, Object.class));\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static MethodHandle methodHandle (Consumer<MemorySegment> callback) {\n+        return MH_Consumer_accept.bindTo(callback).asType(MethodType.methodType(void.class, MemorySegment.class));\n+    }\n+\n+    @Test\n+    public void testUpcall() throws Throwable {\n+        AtomicReference<MemorySegment> capturedSegment = new AtomicReference<>();\n+        MethodHandle target = methodHandle(capturedSegment::set);\n+        FunctionDescriptor upcallDesc = FunctionDescriptor.ofVoid(S_PDI_LAYOUT);\n+        try (MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc);\n+             MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT)) {\n+\n+            MH_do_upcall.invokeExact(upcallStub.address(), argSegment);\n+        }\n+\n+        MemorySegment captured = capturedSegment.get();\n+        assertFalse(captured.isAlive());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct S_PDI { void* p0; double p1; int p2; };\n+\n+EXPORT void do_upcall(void (*cb)(struct S_PDI), struct S_PDI a0) {\n+    cb(a0);\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestUpcallStructScope.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}