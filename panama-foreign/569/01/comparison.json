{"files":[{"patch":"@@ -6,1 +6,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -21,1 +21,1 @@\n-message=Merge\n+message=Merge .*\n@@ -29,3 +29,0 @@\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n","filename":".jcheck\/conf","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncInvokers := $(LIBCXX)\n@@ -69,0 +70,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncInvokers := \/EHsc\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,1 +365,1 @@\n-JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,0 +200,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -211,0 +211,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -356,1 +356,1 @@\n-JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n@@ -358,1 +358,2 @@\n-  return reinterpret_cast<JavaFrameAnchor*>(reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(jfa_sp_offset()));\n+  return reinterpret_cast<OptimizedEntryBlob::FrameData*>(\n+    reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(_frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -319,41 +319,0 @@\n-void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n-  __ block_comment(\"{ save_java_frame_anchor \");\n-  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} save_java_frame_anchor \");\n-}\n-\n-void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n-  __ block_comment(\"{ restore_java_frame_anchor \");\n-  \/\/ thread->_last_Java_sp = NULL\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n-\n-  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n-  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-\n-  \/\/_thread->frame_anchor()->copy(&_anchor);\n-\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n-\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n-\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} restore_java_frame_anchor \");\n-}\n-\n@@ -445,0 +404,54 @@\n+static int compute_res_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  return result_size;\n+}\n+\n+static void save_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ save java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, offset), reg->as_Register());\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, offset), reg->as_XMMRegister());\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} save java result \");\n+}\n+\n+static void restore_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ restore java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, offset));\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} restore java result \");\n+}\n+\n@@ -577,6 +590,0 @@\n-struct AuxiliarySaves {\n-  JavaFrameAnchor jfa;\n-  uintptr_t thread;\n-  bool should_detach;\n-};\n-\n@@ -611,0 +618,1 @@\n+  int res_save_area_size = compute_res_save_area_size(conv);\n@@ -616,1 +624,2 @@\n-  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int res_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int arg_save_area_offset   = res_save_area_offset   + res_save_area_size;\n@@ -618,6 +627,2 @@\n-  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n-  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n-\n-  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n-  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n-  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = frame_data_offset      + sizeof(OptimizedEntryBlob::FrameData);\n@@ -634,2 +639,2 @@\n-  \/\/      | AuxiliarySaves      |\n-  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n@@ -643,0 +648,3 @@\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_are_offset\n+  \/\/      |                     |\n@@ -653,1 +661,0 @@\n-  Label call_return;\n@@ -669,1 +676,1 @@\n-  __ block_comment(\"{ get_thread\");\n+  __ block_comment(\"{ on_entry\");\n@@ -671,1 +678,1 @@\n-  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n@@ -673,1 +680,1 @@\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_entry)));\n@@ -676,40 +683,1 @@\n-  __ movptr(Address(rsp, thread_offset), r15_thread);\n-  __ block_comment(\"} get_thread\");\n-\n-  \/\/ TODO:\n-  \/\/ We expect not to be coming from JNI code, but we might be.\n-  \/\/ We should figure out what our stance is on supporting that and then maybe add\n-  \/\/ some more handling here for:\n-  \/\/   - handle blocks\n-  \/\/   - check for active exceptions (and emit an error)\n-\n-  __ block_comment(\"{ safepoint poll\");\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  if (os::is_MP()) {\n-    __ membar(Assembler::Membar_mask_bits(\n-                Assembler::LoadLoad  | Assembler::StoreLoad |\n-                Assembler::LoadStore | Assembler::StoreStore));\n-   }\n-\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n-  Label L_after_safepoint_poll;\n-  Label L_safepoint_poll_slow_path;\n-\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n-\n-  __ bind(L_after_safepoint_poll);\n-  __ block_comment(\"} safepoint poll\");\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n-\n-  __ block_comment(\"{ reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n-  __ block_comment(\"} reguard stack check\");\n+  __ block_comment(\"} on_entry\");\n@@ -731,0 +699,10 @@\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+  save_java_result(_masm, conv, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_exit)));\n@@ -732,0 +710,1 @@\n+  __ block_comment(\"} on_exit\");\n@@ -733,2 +712,1 @@\n-  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n-  __ reset_last_Java_frame(r15_thread, true);\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n@@ -736,1 +714,1 @@\n-  __ call(Address(rbx, Method::from_compiled_offset()));\n+  restore_java_result(_masm, conv, res_save_area_offset);\n@@ -738,0 +716,1 @@\n+  \/\/ return value shuffle\n@@ -764,21 +743,0 @@\n-  __ bind(call_return);\n-\n-  \/\/ also sets last Java frame\n-  __ movptr(r15_thread, Address(rsp, thread_offset));\n-  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n-  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n-\n-  __ block_comment(\"{ maybe_detach_thread\");\n-  Label L_after_detach;\n-  __ cmpb(Address(rsp, should_detach_offset), 0);\n-  __ jcc(Assembler::equal, L_after_detach);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n-  __ reinit_heapbase();\n-  __ bind(L_after_detach);\n-  __ block_comment(\"} maybe_detach_thread\");\n-\n-  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n@@ -790,23 +748,0 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_reguard);\n-  __ block_comment(\"} L_reguard\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -842,1 +777,1 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":83,"deletions":148,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+OptimizedEntryBlob::FrameData* OptimizedEntryBlob::frame_data_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+#include \"runtime\/javaFrameAnchor.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n@@ -716,1 +718,1 @@\n-                     jobject receiver, ByteSize jfa_sp_offset) :\n+                                       jobject receiver, ByteSize frame_data_offset) :\n@@ -720,1 +722,1 @@\n-  _jfa_sp_offset(jfa_sp_offset) {\n+  _frame_data_offset(frame_data_offset) {\n@@ -725,1 +727,1 @@\n-                             jobject receiver, ByteSize jfa_sp_offset) {\n+                                               jobject receiver, ByteSize frame_data_offset) {\n@@ -732,1 +734,1 @@\n-    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, frame_data_offset);\n@@ -739,0 +741,8 @@\n+\n+void OptimizedEntryBlob::oops_do(OopClosure* f, const frame& frame) {\n+  frame_data_for_frame(frame)->old_handles->oops_do(f);\n+}\n+\n+JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+  return &frame_data_for_frame(frame)->jfa;\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/javaFrameAnchor.hpp\"\n@@ -37,0 +38,1 @@\n+class JNIHandleBlock;\n@@ -80,1 +82,1 @@\n-class JavaFrameAnchor; \/\/ for EntryBlob::jfa_for_frame\n+class JavaFrameAnchor; \/\/ for OptimizedEntryBlob::jfa_for_frame\n@@ -729,1 +731,2 @@\n-\/\/ For optimized upcall stubs\n+class ProgrammableUpcallHandler;\n+\n@@ -731,0 +734,1 @@\n+  friend class ProgrammableUpcallHandler;\n@@ -734,1 +738,1 @@\n-  ByteSize _jfa_sp_offset;\n+  ByteSize _frame_data_offset;\n@@ -737,1 +741,9 @@\n-            jobject receiver, ByteSize jfa_sp_offset);\n+                     jobject receiver, ByteSize frame_data_offset);\n+\n+  struct FrameData {\n+    JavaFrameAnchor jfa;\n+    JavaThread* thread;\n+    JNIHandleBlock* old_handles;\n+    JNIHandleBlock* new_handles;\n+    bool should_detach;\n+  };\n@@ -739,0 +751,2 @@\n+  \/\/ defined in frame_ARCH.cpp\n+  FrameData* frame_data_for_frame(const frame& frame) const;\n@@ -742,2 +756,2 @@\n-                           intptr_t exception_handler_offset, jobject receiver,\n-                           ByteSize jfa_sp_offset);\n+                                    intptr_t exception_handler_offset, jobject receiver,\n+                                    ByteSize frame_data_offset);\n@@ -747,1 +761,0 @@\n-  ByteSize jfa_sp_offset() const { return _jfa_sp_offset; }\n@@ -749,1 +762,0 @@\n-  \/\/ defined in frame_ARCH.cpp\n@@ -752,0 +764,2 @@\n+  void oops_do(OopClosure* f, const frame& frame);\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+  DEBUG_ONLY(LOG_TAG(panama)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    assert(!JavaThread::cast(thread)->has_last_Java_frame(), \"newly-attached thread not expected to have last Java frame\");\n@@ -74,0 +75,87 @@\n+\/\/ modelled after JavaCallWrapper::JavaCallWrapper\n+Thread* ProgrammableUpcallHandler::on_entry(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = JavaThread::cast(maybe_attach_and_get_thread(&context->should_detach));\n+  context->thread = thread;\n+\n+  assert(thread->can_call_java(), \"must be able to call Java\");\n+\n+  \/\/ Allocate handle block for Java code. This must be done before we change thread_state to _thread_in_Java,\n+  \/\/ since it can potentially block.\n+  context->new_handles = JNIHandleBlock::allocate_block(thread);\n+\n+  \/\/ After this, we are official in Java Code. This needs to be done before we change any of the thread local\n+  \/\/ info, since we cannot find oops before the new information is set up completely.\n+  ThreadStateTransition::transition_from_native(thread, _thread_in_Java);\n+\n+  \/\/ Make sure that we handle asynchronous stops and suspends _before_ we clear all thread state\n+  \/\/ in OptimizedEntryBlob::FrameData. This way, we can decide if we need to do any pd actions\n+  \/\/ to prepare for stop\/suspend (flush register windows on sparcs, cache sp, or other state).\n+  bool clear_pending_exception = true;\n+  if (thread->has_special_runtime_exit_condition()) {\n+    thread->handle_special_runtime_exit_condition();\n+    if (thread->has_pending_exception()) {\n+      clear_pending_exception = false;\n+    }\n+  }\n+\n+  context->old_handles = thread->active_handles();\n+\n+  \/\/ For the profiler, the last_Java_frame information in thread must always be in\n+  \/\/ legal state. We have no last Java frame if last_Java_sp == NULL so\n+  \/\/ the valid transition is to clear _last_Java_sp and then reset the rest of\n+  \/\/ the (platform specific) state.\n+\n+  context->jfa.copy(thread->frame_anchor());\n+  thread->frame_anchor()->clear();\n+\n+  debug_only(thread->inc_java_call_counter());\n+  thread->set_active_handles(context->new_handles);     \/\/ install new handle block and reset Java frame linkage\n+\n+  assert (thread->thread_state() != _thread_in_native, \"cannot set native pc to NULL\");\n+\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  if(clear_pending_exception) {\n+    thread->clear_pending_exception();\n+  }\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n+\n+  return thread;\n+}\n+\n+\/\/ modelled after JavaCallWrapper::~JavaCallWrapper\n+void ProgrammableUpcallHandler::on_exit(OptimizedEntryBlob::FrameData* context) {\n+  JavaThread* thread = context->thread;\n+  assert(thread == JavaThread::current(), \"must still be the same thread\");\n+\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n+\n+  \/\/ restore previous handle block\n+  thread->set_active_handles(context->old_handles);\n+\n+  thread->frame_anchor()->zap();\n+\n+  debug_only(thread->dec_java_call_counter());\n+\n+  \/\/ Old thread-local info. has been restored. We are not back in native code.\n+  ThreadStateTransition::transition_from_java(thread, _thread_in_native);\n+\n+  \/\/ State has been restored now make the anchor frame visible for the profiler.\n+  \/\/ Do this after the transition because this allows us to put an assert\n+  \/\/ the Java->native transition which checks to see that stack is not walkable\n+  \/\/ on sparc\/ia64 which will catch violations of the reseting of last_Java_frame\n+  \/\/ invariants (i.e. _flags always cleared on return to Java)\n+\n+  thread->frame_anchor()->copy(&context->jfa);\n+\n+  \/\/ Release handles after we are marked as being in native code again, since this\n+  \/\/ operation might block\n+  JNIHandleBlock::release_block(context->new_handles, thread);\n+\n+  assert(!thread->has_pending_exception(), \"Upcall can not throw an exception\");\n+\n+  if (context->should_detach) {\n+    detach_thread(thread);\n+  }\n+}\n+\n@@ -110,0 +198,1 @@\n+  ResourceMark rm;\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/codeBlob.hpp\"\n@@ -52,0 +53,3 @@\n+\n+  static Thread* on_entry(OptimizedEntryBlob::FrameData* context);\n+  static void on_exit(OptimizedEntryBlob::FrameData* context);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1071,3 +1071,1 @@\n-   \/\/ Nothing to do\n-   \/\/ receiver is a global ref\n-   \/\/ handle block is for JNI\n+    _cb->as_optimized_entry_blob()->oops_do(f, *this);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class ProgrammableUpcallHandler;\n@@ -55,0 +56,1 @@\n+friend class ProgrammableUpcallHandler;\n","filename":"src\/hotspot\/share\/runtime\/javaFrameAnchor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1932,0 +1932,9 @@\n+#ifdef ASSERT\n+void JavaThread::verify_frame_info() {\n+  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n+         (has_last_Java_frame() && java_call_counter() > 0),\n+         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n+         has_last_Java_frame(), java_call_counter());\n+}\n+#endif\n+\n@@ -1939,2 +1948,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0), \"wrong java_sp info!\");\n+  DEBUG_ONLY(verify_frame_info();)\n@@ -1988,4 +1996,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  verify_frame_info();\n@@ -1996,4 +2001,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  DEBUG_ONLY(verify_frame_info();)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1129,0 +1129,2 @@\n+  DEBUG_ONLY(void verify_frame_info();)\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1461,5 +1461,0 @@\n-            @Override\n-            public void ensureCustomized(MethodHandle mh) {\n-                mh.customize();\n-            }\n-\n@@ -1506,0 +1501,5 @@\n+\n+            @Override\n+            public Class<?>[] exceptionTypes(MethodHandle handle) {\n+                return VarHandles.exceptionTypes(handle);\n+            }\n@@ -2112,9 +2112,10 @@\n-            MH_cast                  = 0,\n-            MH_selectAlternative     = 1,\n-            MH_countedLoopPred       = 2,\n-            MH_countedLoopStep       = 3,\n-            MH_initIterator          = 4,\n-            MH_iteratePred           = 5,\n-            MH_iterateNext           = 6,\n-            MH_Array_newInstance     = 7,\n-            MH_LIMIT                 = 8;\n+            MH_cast                               = 0,\n+            MH_selectAlternative                  = 1,\n+            MH_countedLoopPred                    = 2,\n+            MH_countedLoopStep                    = 3,\n+            MH_initIterator                       = 4,\n+            MH_iteratePred                        = 5,\n+            MH_iterateNext                        = 6,\n+            MH_Array_newInstance                  = 7,\n+            MH_VarHandles_handleCheckedExceptions = 8,\n+            MH_LIMIT                              = 9;\n@@ -2170,0 +2171,3 @@\n+                case MH_VarHandles_handleCheckedExceptions:\n+                    return IMPL_LOOKUP.findStatic(VarHandles.class, \"handleCheckedExceptions\",\n+                            MethodType.methodType(void.class, Throwable.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Parameter;\n@@ -37,1 +36,0 @@\n-import java.util.LinkedHashMap;\n@@ -39,1 +37,0 @@\n-import java.util.Map;\n@@ -48,2 +45,0 @@\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toList;\n@@ -362,1 +357,1 @@\n-    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {\n+    public static VarHandle filterValue(VarHandle target, MethodHandle pFilterToTarget, MethodHandle pFilterFromTarget) {\n@@ -364,2 +359,2 @@\n-        Objects.requireNonNull(filterToTarget);\n-        Objects.requireNonNull(filterFromTarget);\n+        Objects.requireNonNull(pFilterToTarget);\n+        Objects.requireNonNull(pFilterFromTarget);\n@@ -367,2 +362,2 @@\n-        noCheckedExceptions(filterToTarget);\n-        noCheckedExceptions(filterFromTarget);\n+        MethodHandle filterToTarget = adaptForCheckedExceptions(pFilterToTarget);\n+        MethodHandle filterFromTarget = adaptForCheckedExceptions(pFilterFromTarget);\n@@ -476,2 +471,3 @@\n-            noCheckedExceptions(filters[i]);\n-            MethodType filterType = filters[i].type();\n+            MethodHandle filter = Objects.requireNonNull(filters[i]);\n+            filter = adaptForCheckedExceptions(filter);\n+            MethodType filterType = filter.type();\n@@ -567,1 +563,1 @@\n-    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {\n+    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle pFilter) {\n@@ -569,2 +565,2 @@\n-        Objects.requireNonNull(filter);\n-        noCheckedExceptions(filter);\n+        Objects.requireNonNull(pFilter);\n+        MethodHandle filter = adaptForCheckedExceptions(pFilter);\n@@ -607,1 +603,23 @@\n-    private static void noCheckedExceptions(MethodHandle handle) {\n+    private static MethodHandle adaptForCheckedExceptions(MethodHandle target) {\n+        Class<?>[] exceptionTypes = exceptionTypes(target);\n+        if (exceptionTypes != null) { \/\/ exceptions known\n+            if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n+                throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n+            }\n+            return target; \/\/ no adaptation needed\n+        } else {\n+            MethodHandle handler = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_VarHandles_handleCheckedExceptions);\n+            MethodHandle zero = MethodHandles.zero(target.type().returnType()); \/\/ dead branch\n+            handler = MethodHandles.collectArguments(zero, 0, handler);\n+            return MethodHandles.catchException(target, Throwable.class, handler);\n+        }\n+    }\n+\n+    static void handleCheckedExceptions(Throwable throwable) throws Throwable {\n+        if (isCheckedException(throwable.getClass())) {\n+            throw new IllegalStateException(\"Adapter handle threw checked exception\", throwable);\n+        }\n+        throw throwable;\n+    }\n+\n+    static Class<?>[] exceptionTypes(MethodHandle handle) {\n@@ -614,1 +632,0 @@\n-            final Class<?>[] exceptionTypes;\n@@ -616,1 +633,1 @@\n-                exceptionTypes = info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -619,1 +636,1 @@\n-                exceptionTypes = null;\n+                return new Class<?>[0];\n@@ -621,1 +638,1 @@\n-                exceptionTypes = info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -626,5 +643,0 @@\n-            if (exceptionTypes != null) {\n-                if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n-                    throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n-                }\n-            }\n@@ -632,10 +644,3 @@\n-            noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());\n-        } else {\n-            \/\/bound\n-            BoundMethodHandle boundHandle = (BoundMethodHandle)handle;\n-            for (int i = 0 ; i < boundHandle.fieldCount() ; i++) {\n-                Object arg = boundHandle.arg(i);\n-                if (arg instanceof MethodHandle){\n-                    noCheckedExceptions((MethodHandle) arg);\n-                }\n-            }\n+            return exceptionTypes(((DelegatingMethodHandle)handle).getTarget());\n+        } else if (handle instanceof NativeMethodHandle) {\n+            return new Class<?>[0];\n@@ -643,0 +648,4 @@\n+\n+        assert handle instanceof BoundMethodHandle : \"Unexpected handle type: \" + handle;\n+        \/\/ unknown\n+        return null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -137,3 +137,3 @@\n-     * Ensure given method handle is customized\n-     *\n-     * @param mh the method handle\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n@@ -141,1 +141,1 @@\n-    void ensureCustomized(MethodHandle mh);\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n- *       <li>If {@code C} is {@code VaList.class}, then {@code L} must be {@link CLinker#C_VA_LIST}<\/li>\n@@ -232,1 +231,2 @@\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch, or\n+     *         if it is determined that the target method handle can throw an exception.\n@@ -270,4 +270,0 @@\n-    \/**\n-     * The layout for the {@code va_list} C type\n-     *\/\n-    MemoryLayout C_VA_LIST = pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);\n@@ -434,1 +430,2 @@\n-     * A va list is a stateful cursor used to iterate over a set of variadic arguments.\n+     * A va list is a stateful cursor used to iterate over a set of variadic arguments. A va list can be passed\n+     * {@linkplain #address() by reference} e.g. to a downcall method handle.\n@@ -567,2 +564,1 @@\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n-         * backed by the {@linkplain ResourceScope#globalScope() global} resource scope.\n+         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,6 @@\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ * elements to a method in this class causes a {@link NullPointerException} to be thrown. Moreover,\n+ * attempting to dereference a segment whose {@linkplain MemorySegment#scope() scope} has already been closed,\n+ * or from a thread other than the thread owning the scope causes an {@link IllegalStateException} to be thrown.\n+ * Finally, attempting to dereference a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n+ * {@linkplain MemorySegment#byteSize() size} {@code S}) at addresses that are {@code < B}, or {@code >= B + S},\n+ * causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,713 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import java.nio.ByteOrder;\n+import java.util.Objects;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * This class provides convenient methods for copying data between primitive arrays and memory segments.\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\n+ * <p>\n+ * Copy operations defined in this class accept a <em>byte order<\/em> parameter. If the specified byte order is different\n+ * from the <em>native<\/em> byte order, a byte swap operation is performed on each array elements\n+ * as they are copied from the source (destination) segment to the destination (source) array.\n+ * Additional overloads are provided (see {@link #copyFromArray(double[], int, int, MemorySegment, long)}),\n+ * so that clients can omit the byte order parameter.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException} to be thrown. Moreover,\n+ * attempting to copy to\/from a segment whose {@linkplain MemorySegment#scope() scope} has already been closed,\n+ * or from a thread other than the thread owning the scope causes an {@link IllegalStateException} to be thrown.\n+ * Finally, attempting to copy to\/from a segment (of {@linkplain MemorySegment#address() base address} {@code B} and\n+ * {@linkplain MemorySegment#byteSize() size} {@code S}) at addresses that are {@code < B}, or {@code >= B + S},\n+ * causes an {@link IndexOutOfBoundsException} to be thrown; similarly, attempting to copy to\/from an array\n+ * (of length {@code L}) at indices that are {@code < 0}, or {@code >= L} causes an {@link IndexOutOfBoundsException} to be thrown.<\/p>\n+ *\/\n+public final class MemoryCopy {\n+\n+    private static final ScopedMemoryAccess scopedMemoryAccess = ScopedMemoryAccess.getScopedMemoryAccess();\n+    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+\n+    private static final int BYTE_BASE = unsafe.arrayBaseOffset(byte[].class);\n+    private static final int CHAR_BASE = unsafe.arrayBaseOffset(char[].class);\n+    private static final int SHORT_BASE = unsafe.arrayBaseOffset(short[].class);\n+    private static final int INT_BASE = unsafe.arrayBaseOffset(int[].class);\n+    private static final int FLOAT_BASE = unsafe.arrayBaseOffset(float[].class);\n+    private static final int LONG_BASE = unsafe.arrayBaseOffset(long[].class);\n+    private static final int DOUBLE_BASE = unsafe.arrayBaseOffset(double[].class);\n+\n+    private MemoryCopy() { \/* singleton *\/ }\n+\n+    \/\/BYTE\n+    \/**\n+     * Copies a number of byte elements from a source byte array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source byte array.\n+     * @param srcIndexBytes the starting index of the source byte array.\n+     * @param srcCopyLengthBytes the number of byte elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            byte[] srcArray, int srcIndexBytes, int srcCopyLengthBytes,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.checkFromIndexSize(srcIndexBytes, srcCopyLengthBytes, srcArray.length);\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthBytes, false);\n+        scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                srcArray, BYTE_BASE + srcIndexBytes,\n+                destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthBytes);\n+    }\n+\n+    \/**\n+     * Copies a number of byte elements from a source segment to a destination byte array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination byte array.\n+     * @param dstIndexBytes the starting index of the destination byte array.\n+     * @param dstCopyLengthBytes the number of byte elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            byte[] dstArray, int dstIndexBytes, int dstCopyLengthBytes) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthBytes, true);\n+        Objects.checkFromIndexSize(dstIndexBytes, dstCopyLengthBytes, dstArray.length);\n+        scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                dstArray, BYTE_BASE + dstIndexBytes, dstCopyLengthBytes);\n+    }\n+\n+    \/\/CHAR\n+    \/**\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source char array.\n+     * @param srcIndexChars the starting index of the source char array.\n+     * @param srcCopyLengthChars the number of char elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexChars, srcCopyLengthChars, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of char elements from a source char array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source char array.\n+     * @param srcIndexChars the starting index of the source char array.\n+     * @param srcCopyLengthChars the number of char elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            char[] srcArray, int srcIndexChars, int srcCopyLengthChars,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(order);\n+        Objects.checkFromIndexSize(srcIndexChars, srcCopyLengthChars, srcArray.length);\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthChars << 1, false);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, CHAR_BASE + (srcIndexChars << 1),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthChars << 1, 2);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndexChars the starting index of the destination char array.\n+     * @param dstCopyLengthChars the number of char elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            char[] dstArray, int dstIndexChars, int dstCopyLengthChars) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexChars, dstCopyLengthChars, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of char elements from a source segment to a destination char array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination char array.\n+     * @param dstIndexChars the starting index of the destination char array.\n+     * @param dstCopyLengthChars the number of char elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            char[] dstArray, int dstIndexChars, int dstCopyLengthChars,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthChars << 1, true);\n+        Objects.checkFromIndexSize(dstIndexChars, dstCopyLengthChars, dstArray.length);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, CHAR_BASE + (dstIndexChars << 1), dstCopyLengthChars << 1, 2);\n+        }\n+    }\n+\n+    \/\/SHORT\n+    \/**\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source short array.\n+     * @param srcIndexShorts the starting index of the source short array.\n+     * @param srcCopyLengthShorts the number of short elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexShorts, srcCopyLengthShorts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of short elements from a source short array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source short array.\n+     * @param srcIndexShorts the starting index of the source short array.\n+     * @param srcCopyLengthShorts the number of short elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            short[] srcArray, int srcIndexShorts, int srcCopyLengthShorts,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(order);\n+        Objects.checkFromIndexSize(srcIndexShorts, srcCopyLengthShorts, srcArray.length);\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthShorts << 1, false);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, SHORT_BASE + (srcIndexShorts << 1),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthShorts << 1, 2);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndexShorts the starting index of the destination short array.\n+     * @param dstCopyLengthShorts the number of short elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexShorts, dstCopyLengthShorts, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of short elements from a source segment to a destination short array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination short array.\n+     * @param dstIndexShorts the starting index of the destination short array.\n+     * @param dstCopyLengthShorts the number of short elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            short[] dstArray, int dstIndexShorts, int dstCopyLengthShorts,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthShorts << 1, true);\n+        Objects.checkFromIndexSize(dstIndexShorts, dstCopyLengthShorts, dstArray.length);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, SHORT_BASE + (dstIndexShorts << 1), dstCopyLengthShorts << 1, 2);\n+        }\n+    }\n+\n+    \/\/INT\n+    \/**\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source int array.\n+     * @param srcIndexInts the starting index of the source int array.\n+     * @param srcCopyLengthInts the number of int elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexInts, srcCopyLengthInts, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of int elements from a source int array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source int array.\n+     * @param srcIndexInts the starting index of the source int array.\n+     * @param srcCopyLengthInts the number of int elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            int[] srcArray, int srcIndexInts, int srcCopyLengthInts,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(order);\n+        Objects.checkFromIndexSize(srcIndexInts, srcCopyLengthInts, srcArray.length);\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthInts << 2, false);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, INT_BASE + (srcIndexInts << 2),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, INT_BASE + (srcIndexInts << 2),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthInts << 2, 4);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndexInts the starting index of the destination int array.\n+     * @param dstCopyLengthInts the number of int elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            int[] dstArray, int dstIndexInts, int dstCopyLengthInts) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexInts, dstCopyLengthInts, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of int elements from a source segment to a destination int array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination int array.\n+     * @param dstIndexInts the starting index of the destination int array.\n+     * @param dstCopyLengthInts the number of int elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            int[] dstArray, int dstIndexInts, int dstCopyLengthInts,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthInts << 2, true);\n+        Objects.checkFromIndexSize(dstIndexInts, dstCopyLengthInts, dstArray.length);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, INT_BASE + (dstIndexInts << 2), dstCopyLengthInts << 2, 4);\n+        }\n+    }\n+\n+    \/\/FLOAT\n+    \/**\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source float array.\n+     * @param srcIndexFloats the starting index of the source float array.\n+     * @param srcCopyLengthFloats the number of float elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexFloats, srcCopyLengthFloats, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of float elements from a source float array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source float array.\n+     * @param srcIndexFloats the starting index of the source float array.\n+     * @param srcCopyLengthFloats the number of float elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            float[] srcArray, int srcIndexFloats, int srcCopyLengthFloats,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(order);\n+        Objects.checkFromIndexSize(srcIndexFloats, srcCopyLengthFloats, srcArray.length);\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthFloats << 2, false);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, FLOAT_BASE + (srcIndexFloats << 2),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthFloats << 2, 4);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndexFloats the starting index of the destination float array.\n+     * @param dstCopyLengthFloats the number of float elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexFloats, dstCopyLengthFloats, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of float elements from a source segment to a destination float array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination float array.\n+     * @param dstIndexFloats the starting index of the destination float array.\n+     * @param dstCopyLengthFloats the number of float elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a float swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            float[] dstArray, int dstIndexFloats, int dstCopyLengthFloats,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthFloats << 2, true);\n+        Objects.checkFromIndexSize(dstIndexFloats, dstCopyLengthFloats, dstArray.length);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, FLOAT_BASE + (dstIndexFloats << 2), dstCopyLengthFloats << 2, 4);\n+        }\n+    }\n+\n+    \/\/LONG\n+    \/**\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source long array.\n+     * @param srcIndexLongs the starting index of the source long array.\n+     * @param srcCopyLengthLongs the number of long elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexLongs, srcCopyLengthLongs, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of long elements from a source long array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source long array.\n+     * @param srcIndexLongs the starting index of the source long array.\n+     * @param srcCopyLengthLongs the number of long elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            long[] srcArray, int srcIndexLongs, int srcCopyLengthLongs,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(order);\n+        Objects.checkFromIndexSize(srcIndexLongs, srcCopyLengthLongs, srcArray.length);\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthLongs << 3, false);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, LONG_BASE + (srcIndexLongs << 3),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthLongs << 3, 8);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndexLongs the starting index of the destination long array.\n+     * @param dstCopyLengthLongs the number of long elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexLongs, dstCopyLengthLongs, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of long elements from a source segment to a destination long array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination long array.\n+     * @param dstIndexLongs the starting index of the destination long array.\n+     * @param dstCopyLengthLongs the number of long elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            long[] dstArray, int dstIndexLongs, int dstCopyLengthLongs,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthLongs << 3, true);\n+        Objects.checkFromIndexSize(dstIndexLongs, dstCopyLengthLongs, dstArray.length);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, LONG_BASE + (dstIndexLongs << 3), dstCopyLengthLongs << 3, 8);\n+        }\n+    }\n+\n+    \/\/DOUBLE\n+    \/**\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes).\n+     * @param srcArray the source double array.\n+     * @param srcIndexDoubles the starting index of the source double array.\n+     * @param srcCopyLengthDoubles the number of double elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n+            MemorySegment dstSegment, long dstOffsetBytes) {\n+        copyFromArray(srcArray, srcIndexDoubles, srcCopyLengthDoubles, dstSegment,dstOffsetBytes, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source double array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given byte order.\n+     * @param srcArray the source double array.\n+     * @param srcIndexDoubles the starting index of the source double array.\n+     * @param srcCopyLengthDoubles the number of double elements to be copied.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffsetBytes the starting offset, in bytes, of the destination segment.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyFromArray(\n+            double[] srcArray, int srcIndexDoubles, int srcCopyLengthDoubles,\n+            MemorySegment dstSegment, long dstOffsetBytes,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(order);\n+        Objects.checkFromIndexSize(srcIndexDoubles, srcCopyLengthDoubles, srcArray.length);\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffsetBytes, srcCopyLengthDoubles << 3, false);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(null, destImpl.scope(),\n+                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(null, destImpl.scope(),\n+                    srcArray, DOUBLE_BASE + (srcIndexDoubles << 3),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffsetBytes, srcCopyLengthDoubles << 3, 8);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndexDoubles the starting index of the destination double array.\n+     * @param dstCopyLengthDoubles the number of double elements to be copied.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles) {\n+        copyToArray(srcSegment, srcOffsetBytes, dstArray, dstIndexDoubles, dstCopyLengthDoubles, ByteOrder.nativeOrder());\n+    }\n+\n+    \/**\n+     * Copies a number of double elements from a source segment to a destination double array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given byte order.\n+     * @param srcSegment the source segment.\n+     * @param srcOffsetBytes the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination double array.\n+     * @param dstIndexDoubles the starting index of the destination double array.\n+     * @param dstCopyLengthDoubles the number of double elements to be copied.\n+     * @param order the byte order to be used for the copy operation. If the specified byte order is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     *\/\n+    @ForceInline\n+    public static void copyToArray(\n+            MemorySegment srcSegment, long srcOffsetBytes,\n+            double[] dstArray, int dstIndexDoubles, int dstCopyLengthDoubles,\n+            ByteOrder order) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(order);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffsetBytes, dstCopyLengthDoubles << 3, true);\n+        Objects.checkFromIndexSize(dstIndexDoubles, dstCopyLengthDoubles, dstArray.length);\n+        if (order == ByteOrder.nativeOrder()) {\n+            scopedMemoryAccess.copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3);\n+        } else {\n+            scopedMemoryAccess.copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffsetBytes,\n+                    dstArray, DOUBLE_BASE + (dstIndexDoubles << 3), dstCopyLengthDoubles << 3, 8);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryCopy.java","additions":713,"deletions":0,"binary":false,"changes":713,"status":"added"},{"patch":"@@ -332,0 +332,3 @@\n+     * If the boxing and unboxing filters throw any checked exceptions when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -341,1 +344,1 @@\n-     * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n+     * or if it's determined that either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n@@ -359,0 +362,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -371,1 +377,1 @@\n-     * or if any of the filters throws any checked exceptions.\n+     * or if it's determined that any of the filters throws any checked exceptions.\n@@ -467,0 +473,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -479,1 +488,1 @@\n-     * or if {@code filter} throws any checked exceptions.\n+     * or if it's determined that {@code filter} throws any checked exceptions.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.nio.ByteOrder;\n@@ -376,0 +377,40 @@\n+    \/**\n+     * Performs an element-wise bulk copy from given source segment to this segment. More specifically, the bytes at\n+     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment are copied into this segment\n+     * at offset {@code 0} through {@code src.byteSize() - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the source bytes are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in this segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S} and\n+     * alignment {@code A}, and the size of the source segment must be a multiple of {@code S} for the copy operation\n+     * to be correctly specified. If the byte order of the two element layouts differ, the bytes corresponding to each\n+     * element to be copied are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     *\n+     * @implSpec\n+     * If {@code srcElementLayout.byteSize() == 1}, or if {@code srcElementLayout.order() == dstElementLayout.order()}, calling\n+     * this method must be equivalent to calling {@link #copyFrom(MemorySegment)} with the same source segment.\n+     *\n+     * @param dstElementLayout the element layout associated with this segment.\n+     * @param src the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @throws IndexOutOfBoundsException if {@code src.byteSize() > this.byteSize()}.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source segment size is not\n+     * a multiple of the source element layout size, if the source segment is incompatible with the alignment constraints\n+     * in the source element layout, or if this segment is incompatible with the alignment constraints\n+     * in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n+     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -318,5 +317,1 @@\n-        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n-            addr.copyFrom(heapSegmentFactory.apply(array));\n-        } else {\n-            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n-        }\n+        addr.copyFrom(elementLayout, heapSegmentFactory.apply(array), elementLayout.withOrder(ByteOrder.nativeOrder()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -153,8 +153,24 @@\n-    public void copyFromSwap(MemorySegment src, long elemSize) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                        that.base(), that.min(),\n-                        base(), min(), size, elemSize);\n+    public void copyFrom(ValueLayout dstElementLayout, MemorySegment src, ValueLayout srcElementLayout) {\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (((AbstractMemorySegmentImpl)src).min() % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (min() % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = src.byteSize();\n+        if (size % srcElementLayout.byteSize() != 0) {\n+            throw new IllegalArgumentException(\"Segment size is not a multiple of layout size\");\n+        }\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            copyFrom(src);\n+        } else {\n+            AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) src;\n+            checkAccess(0, size, false);\n+            that.checkAccess(0, size, true);\n+            SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n+                    that.base(), that.min(),\n+                    base(), min(), size, srcElementLayout.byteSize());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import static java.lang.invoke.MethodHandles.exactInvoker;\n@@ -70,2 +71,0 @@\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n-\n@@ -126,1 +125,1 @@\n-            JLI.ensureCustomized(doBindings);\n+            doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess;\n@@ -81,0 +82,1 @@\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n@@ -437,0 +439,7 @@\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n@@ -516,28 +525,0 @@\n-    public static MethodType convertVaListCarriers(MethodType mt, Class<?> carrier) {\n-        Class<?>[] params = new Class<?>[mt.parameterCount()];\n-        for (int i = 0; i < params.length; i++) {\n-            Class<?> pType = mt.parameterType(i);\n-            params[i] = ((pType == VaList.class) ? carrier : pType);\n-        }\n-        return methodType(mt.returnType(), params);\n-    }\n-\n-    public static MethodHandle unboxVaLists(MethodType type, MethodHandle handle, MethodHandle unboxer) {\n-        for (int i = 0; i < type.parameterCount(); i++) {\n-            if (type.parameterType(i) == VaList.class) {\n-               handle = filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n-            }\n-        }\n-        return handle;\n-    }\n-\n-    public static MethodHandle boxVaLists(MethodHandle handle, MethodHandle boxer) {\n-        MethodType type = handle.type();\n-        for (int i = 0; i < type.parameterCount(); i++) {\n-            if (type.parameterType(i) == VaList.class) {\n-               handle = filterArguments(handle, i, boxer);\n-            }\n-        }\n-        return handle;\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":9,"deletions":28,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -53,15 +53,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(LinuxAArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -79,2 +64,1 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, LinuxAArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -85,1 +69,0 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n@@ -94,1 +77,1 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,15 +57,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(MacOsAArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -83,2 +68,1 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, MacOsAArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -89,1 +73,0 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n@@ -98,1 +81,0 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -57,15 +57,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(SysVx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -89,2 +74,1 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, SysVVaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -95,1 +79,0 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n@@ -104,1 +87,1 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -58,15 +58,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(Windowsx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -90,2 +75,1 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, WinVaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -96,1 +80,0 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n@@ -105,1 +88,1 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n+        SharedUtils.checkExceptions(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -193,2 +193,2 @@\n-                MethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+                MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));\n@@ -331,1 +331,1 @@\n-                return (int)vprintf.invokeExact(formatStr.address(), vaList);\n+                return (int)vprintf.invokeExact(formatStr.address(), vaList.address());\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -195,1 +195,6 @@\n-        MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            vh.set(seg, \"42\");\n+            String x = (String) vh.get(seg); \/\/ should throw\n+        }\n@@ -198,1 +203,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -201,1 +206,5 @@\n-        MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, scope);\n+            vh.set(seg, \"42\"); \/\/ should throw\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -327,0 +327,3 @@\n+        } catch(IOException e) {\n+            if (e.getMessage().equals(\"Function not implemented\"))\n+                throw new SkipException(e.getMessage(), e);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestCopyFrom\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestCopyFrom {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n+        int size = Math.min(s1.byteSize(), s2.byteSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s2, i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s1, i, i);\n+        }\n+        \/\/perform copy\n+        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n+        \/\/check that copy actually worked\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.check(s2, i, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.type.carrier != s2.type.carrier) return;\n+        int size = Math.min(s1.elementSize(), s2.elementSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            s2.set(i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            s1.set(i, i);\n+        }\n+        \/\/perform copy\n+        s2.segment.copyFrom(s2.type.layout, s1.segment.asSlice(0, size * s1.type.size()), s1.type.layout);\n+        \/\/check that copy actually worked\n+        for (int i = 0; i < size; i++) {\n+            s2.check(i, i);\n+        }\n+    }\n+\n+    interface Getter<X> {\n+        X get(MemorySegment segment, long index, ByteOrder order);\n+    }\n+\n+    interface Setter<X> {\n+        void set(MemorySegment segment, long index, ByteOrder order, X val);\n+    }\n+\n+    enum Type {\n+        \/\/ Byte\n+        BYTE(byte.class, MemoryLayouts.JAVA_BYTE, (s, i, o) -> MemoryAccess.getByteAtOffset(s, i), (s, i, o, v) -> MemoryAccess.setByteAtOffset(s, i, v), i -> (byte)i),\n+        \/\/LE\n+        SHORT_LE(short.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n+        CHAR_LE(char.class, MemoryLayouts.BITS_16_LE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n+        INT_LE(int.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n+        FLOAT_LE(float.class, MemoryLayouts.BITS_32_LE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n+        LONG_LE(long.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n+        DOUBLE_LE(double.class, MemoryLayouts.BITS_64_LE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i),\n+        \/\/BE\n+        SHORT_BE(short.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getShortAtOffset, MemoryAccess::setShortAtOffset, i -> (short)i),\n+        CHAR_BE(char.class, MemoryLayouts.BITS_16_BE, MemoryAccess::getCharAtOffset, MemoryAccess::setCharAtOffset, i -> (char)i),\n+        INT_BE(int.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getIntAtOffset, MemoryAccess::setIntAtOffset, i -> i),\n+        FLOAT_BE(float.class, MemoryLayouts.BITS_32_BE, MemoryAccess::getFloatAtOffset, MemoryAccess::setFloatAtOffset, i -> (float)i),\n+        LONG_BE(long.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getLongAtOffset, MemoryAccess::setLongAtOffset, i -> (long)i),\n+        DOUBLE_BE(double.class, MemoryLayouts.BITS_64_BE, MemoryAccess::getDoubleAtOffset, MemoryAccess::setDoubleAtOffset, i -> (double)i);\n+\n+        final ValueLayout layout;\n+        final Getter<Object> getter;\n+        final Setter<Object> setter;\n+        final IntFunction<Object> valueConverter;\n+        final Class<?> carrier;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <Z> Type(Class<Z> carrier, ValueLayout layout, Getter<Z> getter, Setter<Z> setter, IntFunction<Z> valueConverter) {\n+            this.carrier = carrier;\n+            this.layout = layout;\n+            this.getter = (Getter<Object>)getter;\n+            this.setter = (Setter<Object>)setter;\n+            this.valueConverter = (IntFunction<Object>)valueConverter;\n+        }\n+\n+        int size() {\n+            return (int)layout.byteSize();\n+        }\n+\n+        void set(SegmentSlice slice, int index, int val) {\n+            setter.set(slice.segment, index * size(), layout.order(), valueConverter.apply(val));\n+        }\n+\n+        void check(SegmentSlice slice, int index, int val) {\n+            assertEquals(getter.get(slice.segment, index * size(), layout.order()), valueConverter.apply(val));\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final Type type;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.type = type;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        void set(int index, int val) {\n+            type.set(this, index, val);\n+        }\n+\n+        void check(int index, int val) {\n+            type.check(this, index, val);\n+        }\n+\n+        int byteSize() {\n+            return last - first + 1;\n+        }\n+\n+        int elementSize() {\n+            return byteSize() \/ type.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] elementSlices() {\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            MemorySegment segment = kind.makeSegment(16);\n+            \/\/compute all slices\n+            for (Type type : Type.values()) {\n+                for (int index = 0; index < 16; index += type.size()) {\n+                    MemorySegment first = segment.asSlice(0, index);\n+                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n+                    MemorySegment second = segment.asSlice(index);\n+                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCopyFrom.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -19,1 +19,1 @@\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n@@ -22,1 +22,0 @@\n- *\n@@ -30,5 +29,2 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n@@ -37,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -39,1 +36,0 @@\n-import java.util.function.IntFunction;\n@@ -41,1 +37,4 @@\n-import static org.testng.Assert.*;\n+import jdk.incubator.foreign.MemoryCopy;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -43,0 +42,14 @@\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n+ * To make these tests more challenging the segment is a view of the given array,\n+ * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\/\n@@ -44,0 +57,32 @@\n+    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n+    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n+            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n+\n+    private static final int SEG_LENGTH_BYTES = 32;\n+    private static final int SEG_OFFSET_BYTES = 8;\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testSelfCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        assertEquals(truth.mismatch(dstSeg), -1);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemorySegment result = helper.fromArray(dstArr);\n+        assertEquals(truth.mismatch(result), -1);\n+    }\n@@ -45,1 +90,21 @@\n-    final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testUnalignedCopy(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? (SEG_OFFSET_BYTES - 1) : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : (SEG_OFFSET_BYTES - 1);\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+    }\n@@ -47,6 +112,21 @@\n-    @Test(dataProvider = \"slices\")\n-    public void testCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.size(), s2.size());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s2.segment.asSlice(i), (byte)0);\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobLength(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n@@ -54,2 +134,14 @@\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s1.segment.asSlice(i), (byte) i);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n@@ -57,5 +149,8 @@\n-        \/\/perform copy\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            assertEquals((byte)i, BYTE_HANDLE.get(s2.segment.asSlice(i)));\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n@@ -65,1 +160,23 @@\n-    static class SegmentSlice {\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n@@ -67,3 +184,23 @@\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobIndices(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n@@ -71,1 +208,23 @@\n-            final IntFunction<MemorySegment> segmentFactory;\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobOffsets(CopyMode mode, CopyHelper<Object> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n@@ -73,3 +232,1 @@\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n+    \/***** Utilities *****\/\n@@ -77,2 +234,38 @@\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n+    public static MemorySegment srcSegment(int bytesLength) {\n+        byte[] arr = new byte[bytesLength];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte)i;\n+        }\n+        return MemorySegment.ofArray(arr);\n+    }\n+\n+    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?> helper, int indexShifts, CopyMode mode) {\n+        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n+                                                .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n+        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n+                                                 .varHandle(helper.carrier.componentType(), MemoryLayout.PathElement.sequenceElement());\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toByteArray());\n+        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n+        if (mode.direction) {\n+            if (mode.swap) {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            } else {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            }\n+        } else { \/\/down\n+            if (mode.swap) {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            } else {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n@@ -81,0 +274,2 @@\n+        return dstSeg;\n+    }\n@@ -82,4 +277,5 @@\n-        final Kind kind;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n+    enum CopyMode {\n+        UP_NO_SWAP(true, false),\n+        UP_SWAP(true, true),\n+        DOWN_NO_SWAP(false, false),\n+        DOWN_SWAP(false, true);\n@@ -87,6 +283,2 @@\n-        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n+        final boolean direction;\n+        final boolean swap;\n@@ -94,2 +286,3 @@\n-        int size() {\n-            return last - first + 1;\n+        CopyMode(boolean direction, boolean swap) {\n+            this.direction = direction;\n+            this.swap = swap;\n@@ -99,13 +292,8 @@\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n-        int[] sizes = { 16, 8, 4, 2, 1 };\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (int size : sizes) {\n-                for (int index = 0 ; index < 16 ; index += size) {\n-                    MemorySegment slice = segment.asSlice(index, size);\n-                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n-                }\n-            }\n+    abstract static class CopyHelper<X> {\n+\n+        final ValueLayout elementLayout;\n+        final Class<?> carrier;\n+\n+        public CopyHelper(ValueLayout elementLayout, Class<X> carrier) {\n+            this.elementLayout = elementLayout;\n+            this.carrier = carrier;\n@@ -113,4 +301,213 @@\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+\n+        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n+        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n+        abstract X toArray(MemorySegment segment);\n+        abstract MemorySegment fromArray(X array);\n+        abstract int length(X arr);\n+\n+        @Override\n+        public String toString() {\n+            return \"CopyHelper{\" +\n+                    \"elementLayout=\" + elementLayout +\n+                    \", carrier=\" + carrier.getName() +\n+                    '}';\n+        }\n+\n+        static final CopyHelper<byte[]> BYTE = new CopyHelper<>(MemoryLayouts.JAVA_BYTE, byte[].class) {\n+            @Override\n+            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            byte[] toArray(MemorySegment segment) {\n+                return segment.toByteArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(byte[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(byte[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<char[]> CHAR = new CopyHelper<>(MemoryLayouts.JAVA_CHAR, char[].class) {\n+            @Override\n+            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            char[] toArray(MemorySegment segment) {\n+                return segment.toCharArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(char[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(char[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<short[]> SHORT = new CopyHelper<>(MemoryLayouts.JAVA_SHORT, short[].class) {\n+            @Override\n+            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            short[] toArray(MemorySegment segment) {\n+                return segment.toShortArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(short[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(short[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<int[]> INT = new CopyHelper<>(MemoryLayouts.JAVA_INT, int[].class) {\n+            @Override\n+            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            int[] toArray(MemorySegment segment) {\n+                return segment.toIntArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(int[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(int[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<float[]> FLOAT = new CopyHelper<>(MemoryLayouts.JAVA_FLOAT, float[].class) {\n+            @Override\n+            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            float[] toArray(MemorySegment segment) {\n+                return segment.toFloatArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(float[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(float[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<long[]> LONG = new CopyHelper<>(MemoryLayouts.JAVA_LONG, long[].class) {\n+            @Override\n+            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            long[] toArray(MemorySegment segment) {\n+                return segment.toLongArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(long[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(long[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<double[]> DOUBLE = new CopyHelper<>(MemoryLayouts.JAVA_DOUBLE, double[].class) {\n+            @Override\n+            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemoryCopy.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemoryCopy.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+            }\n+\n+            @Override\n+            double[] toArray(MemorySegment segment) {\n+                return segment.toDoubleArray();\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(double[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(double[] arr) {\n+                return arr.length;\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] copyModesAndHelpers() {\n+        CopyHelper<?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n+                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n+        List<Object[]> results = new ArrayList<>();\n+        for (CopyHelper<?> helper : helpers) {\n+            for (CopyMode mode : CopyMode.values()) {\n+                results.add(new Object[] { mode, helper, helper.toString() });\n@@ -119,1 +516,1 @@\n-        return sliceArray;\n+        return results.stream().toArray(Object[][]::new);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":461,"deletions":64,"binary":false,"changes":525,"status":"modified"},{"patch":"@@ -96,1 +96,2 @@\n-            ResourceScope.class\n+            ResourceScope.class,\n+            MemoryCopy.class\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test\n+ * @test id=scope\n@@ -33,0 +33,25 @@\n+ *   -DUPCALL_TEST_TYPE=SCOPE\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=no_scope\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   -DUPCALL_TEST_TYPE=NO_SCOPE\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=async\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -44,0 +69,1 @@\n+import org.testng.SkipException;\n@@ -51,0 +77,1 @@\n+import java.util.HashMap;\n@@ -52,0 +79,1 @@\n+import java.util.Map;\n@@ -63,0 +91,8 @@\n+    private enum TestType {\n+        SCOPE,\n+        NO_SCOPE,\n+        ASYNC\n+    }\n+\n+    private static final TestType UPCALL_TEST_TYPE = TestType.valueOf(System.getProperty(\"UPCALL_TEST_TYPE\"));\n+\n@@ -65,0 +101,1 @@\n+        System.loadLibrary(\"AsyncInvokers\");\n@@ -90,0 +127,5 @@\n+    private static void checkSelected(TestType type) {\n+        if (UPCALL_TEST_TYPE != type)\n+            throw new SkipException(\"Skipping tests that were not selected\");\n+    }\n+\n@@ -92,0 +134,2 @@\n+        checkSelected(TestType.SCOPE);\n+\n@@ -110,0 +154,2 @@\n+        checkSelected(TestType.NO_SCOPE);\n+\n@@ -124,0 +170,57 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.ASYNC);\n+\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        MethodType mtype = methodType(ret, paramTypes, fields);\n+        try (NativeScope scope = new NativeScope()) {\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            MemoryAddress callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(scope, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n+\n+    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n+        if (ret == Ret.VOID) {\n+            String name = \"call_async_V\";\n+            return INVOKERS.computeIfAbsent(name, symbol ->\n+                abi.downcallHandle(\n+                    LOOKUP.lookup(symbol).orElseThrow(),\n+                    MethodType.methodType(void.class, MemoryAddress.class),\n+                    FunctionDescriptor.ofVoid(C_POINTER)));\n+        }\n+\n+        String name = \"call_async_\" + returnType.name().charAt(0)\n+                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n+\n+        return INVOKERS.computeIfAbsent(name, symbol -> {\n+            MemoryAddress invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            MemoryLayout returnLayout = returnType.layout(fields);\n+            MethodType type = MethodType.methodType(paramCarrier(returnLayout), MemoryAddress.class);\n+            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n+\n+            return abi.downcallHandle(invokerSymbol, type, desc);\n+        });\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":104,"deletions":1,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                    assertEquals(capturedArgsArr[i], args[i + 1]);\n+                    assertEquals(capturedArgsArr[i], args[i + 1], \"For index \" + i);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <thread>\n+\n+#include \"libTestUpcall.h\"\n+#ifdef __clang__\n+#pragma clang optimize off\n+#elif defined __GNUC__\n+#pragma GCC optimize (\"O0\")\n+#elif defined _MSC_BUILD\n+#pragma optimize( \"\", off )\n+#endif\n+\n+template<typename CB>\n+void launch_v(CB cb) {\n+    std::thread thrd(cb);\n+    thrd.join();\n+}\n+\n+template<typename O, typename CB>\n+void start(O& out, CB cb) {\n+    out = cb();\n+}\n+\n+template<typename O, typename CB>\n+O launch(CB cb) {\n+    O result;\n+    std::thread thrd(&start<O, CB>, std::ref(result), cb);\n+    thrd.join();\n+    return result;\n+}\n+\n+extern \"C\" {\n+EXPORT void call_async_V(void (*cb)(void)) { launch_v(cb); }\n+\n+EXPORT int call_async_I(int (*cb)(void)) { return launch<int>(cb); }\n+EXPORT float call_async_F(float (*cb)(void)) { return launch<float>(cb); }\n+EXPORT double call_async_D(double (*cb)(void)) { return launch<double>(cb); }\n+EXPORT void* call_async_P(void* (*cb)(void)) { return launch<void*>(cb); }\n+\n+EXPORT struct S_I call_async_S_I(struct S_I (*cb)(void)) { return launch<struct S_I>(cb); }\n+EXPORT struct S_F call_async_S_F(struct S_F (*cb)(void)) { return launch<struct S_F>(cb); }\n+EXPORT struct S_D call_async_S_D(struct S_D (*cb)(void)) { return launch<struct S_D>(cb); }\n+EXPORT struct S_P call_async_S_P(struct S_P (*cb)(void)) { return launch<struct S_P>(cb); }\n+EXPORT struct S_II call_async_S_II(struct S_II (*cb)(void)) { return launch<struct S_II>(cb); }\n+EXPORT struct S_IF call_async_S_IF(struct S_IF (*cb)(void)) { return launch<struct S_IF>(cb); }\n+EXPORT struct S_ID call_async_S_ID(struct S_ID (*cb)(void)) { return launch<struct S_ID>(cb); }\n+EXPORT struct S_IP call_async_S_IP(struct S_IP (*cb)(void)) { return launch<struct S_IP>(cb); }\n+EXPORT struct S_FI call_async_S_FI(struct S_FI (*cb)(void)) { return launch<struct S_FI>(cb); }\n+EXPORT struct S_FF call_async_S_FF(struct S_FF (*cb)(void)) { return launch<struct S_FF>(cb); }\n+EXPORT struct S_FD call_async_S_FD(struct S_FD (*cb)(void)) { return launch<struct S_FD>(cb); }\n+EXPORT struct S_FP call_async_S_FP(struct S_FP (*cb)(void)) { return launch<struct S_FP>(cb); }\n+EXPORT struct S_DI call_async_S_DI(struct S_DI (*cb)(void)) { return launch<struct S_DI>(cb); }\n+EXPORT struct S_DF call_async_S_DF(struct S_DF (*cb)(void)) { return launch<struct S_DF>(cb); }\n+EXPORT struct S_DD call_async_S_DD(struct S_DD (*cb)(void)) { return launch<struct S_DD>(cb); }\n+EXPORT struct S_DP call_async_S_DP(struct S_DP (*cb)(void)) { return launch<struct S_DP>(cb); }\n+EXPORT struct S_PI call_async_S_PI(struct S_PI (*cb)(void)) { return launch<struct S_PI>(cb); }\n+EXPORT struct S_PF call_async_S_PF(struct S_PF (*cb)(void)) { return launch<struct S_PF>(cb); }\n+EXPORT struct S_PD call_async_S_PD(struct S_PD (*cb)(void)) { return launch<struct S_PD>(cb); }\n+EXPORT struct S_PP call_async_S_PP(struct S_PP (*cb)(void)) { return launch<struct S_PP>(cb); }\n+EXPORT struct S_III call_async_S_III(struct S_III (*cb)(void)) { return launch<struct S_III>(cb); }\n+EXPORT struct S_IIF call_async_S_IIF(struct S_IIF (*cb)(void)) { return launch<struct S_IIF>(cb); }\n+EXPORT struct S_IID call_async_S_IID(struct S_IID (*cb)(void)) { return launch<struct S_IID>(cb); }\n+EXPORT struct S_IIP call_async_S_IIP(struct S_IIP (*cb)(void)) { return launch<struct S_IIP>(cb); }\n+EXPORT struct S_IFI call_async_S_IFI(struct S_IFI (*cb)(void)) { return launch<struct S_IFI>(cb); }\n+EXPORT struct S_IFF call_async_S_IFF(struct S_IFF (*cb)(void)) { return launch<struct S_IFF>(cb); }\n+EXPORT struct S_IFD call_async_S_IFD(struct S_IFD (*cb)(void)) { return launch<struct S_IFD>(cb); }\n+EXPORT struct S_IFP call_async_S_IFP(struct S_IFP (*cb)(void)) { return launch<struct S_IFP>(cb); }\n+EXPORT struct S_IDI call_async_S_IDI(struct S_IDI (*cb)(void)) { return launch<struct S_IDI>(cb); }\n+EXPORT struct S_IDF call_async_S_IDF(struct S_IDF (*cb)(void)) { return launch<struct S_IDF>(cb); }\n+EXPORT struct S_IDD call_async_S_IDD(struct S_IDD (*cb)(void)) { return launch<struct S_IDD>(cb); }\n+EXPORT struct S_IDP call_async_S_IDP(struct S_IDP (*cb)(void)) { return launch<struct S_IDP>(cb); }\n+EXPORT struct S_IPI call_async_S_IPI(struct S_IPI (*cb)(void)) { return launch<struct S_IPI>(cb); }\n+EXPORT struct S_IPF call_async_S_IPF(struct S_IPF (*cb)(void)) { return launch<struct S_IPF>(cb); }\n+EXPORT struct S_IPD call_async_S_IPD(struct S_IPD (*cb)(void)) { return launch<struct S_IPD>(cb); }\n+EXPORT struct S_IPP call_async_S_IPP(struct S_IPP (*cb)(void)) { return launch<struct S_IPP>(cb); }\n+EXPORT struct S_FII call_async_S_FII(struct S_FII (*cb)(void)) { return launch<struct S_FII>(cb); }\n+EXPORT struct S_FIF call_async_S_FIF(struct S_FIF (*cb)(void)) { return launch<struct S_FIF>(cb); }\n+EXPORT struct S_FID call_async_S_FID(struct S_FID (*cb)(void)) { return launch<struct S_FID>(cb); }\n+EXPORT struct S_FIP call_async_S_FIP(struct S_FIP (*cb)(void)) { return launch<struct S_FIP>(cb); }\n+EXPORT struct S_FFI call_async_S_FFI(struct S_FFI (*cb)(void)) { return launch<struct S_FFI>(cb); }\n+EXPORT struct S_FFF call_async_S_FFF(struct S_FFF (*cb)(void)) { return launch<struct S_FFF>(cb); }\n+EXPORT struct S_FFD call_async_S_FFD(struct S_FFD (*cb)(void)) { return launch<struct S_FFD>(cb); }\n+EXPORT struct S_FFP call_async_S_FFP(struct S_FFP (*cb)(void)) { return launch<struct S_FFP>(cb); }\n+EXPORT struct S_FDI call_async_S_FDI(struct S_FDI (*cb)(void)) { return launch<struct S_FDI>(cb); }\n+EXPORT struct S_FDF call_async_S_FDF(struct S_FDF (*cb)(void)) { return launch<struct S_FDF>(cb); }\n+EXPORT struct S_FDD call_async_S_FDD(struct S_FDD (*cb)(void)) { return launch<struct S_FDD>(cb); }\n+EXPORT struct S_FDP call_async_S_FDP(struct S_FDP (*cb)(void)) { return launch<struct S_FDP>(cb); }\n+EXPORT struct S_FPI call_async_S_FPI(struct S_FPI (*cb)(void)) { return launch<struct S_FPI>(cb); }\n+EXPORT struct S_FPF call_async_S_FPF(struct S_FPF (*cb)(void)) { return launch<struct S_FPF>(cb); }\n+EXPORT struct S_FPD call_async_S_FPD(struct S_FPD (*cb)(void)) { return launch<struct S_FPD>(cb); }\n+EXPORT struct S_FPP call_async_S_FPP(struct S_FPP (*cb)(void)) { return launch<struct S_FPP>(cb); }\n+EXPORT struct S_DII call_async_S_DII(struct S_DII (*cb)(void)) { return launch<struct S_DII>(cb); }\n+EXPORT struct S_DIF call_async_S_DIF(struct S_DIF (*cb)(void)) { return launch<struct S_DIF>(cb); }\n+EXPORT struct S_DID call_async_S_DID(struct S_DID (*cb)(void)) { return launch<struct S_DID>(cb); }\n+EXPORT struct S_DIP call_async_S_DIP(struct S_DIP (*cb)(void)) { return launch<struct S_DIP>(cb); }\n+EXPORT struct S_DFI call_async_S_DFI(struct S_DFI (*cb)(void)) { return launch<struct S_DFI>(cb); }\n+EXPORT struct S_DFF call_async_S_DFF(struct S_DFF (*cb)(void)) { return launch<struct S_DFF>(cb); }\n+EXPORT struct S_DFD call_async_S_DFD(struct S_DFD (*cb)(void)) { return launch<struct S_DFD>(cb); }\n+EXPORT struct S_DFP call_async_S_DFP(struct S_DFP (*cb)(void)) { return launch<struct S_DFP>(cb); }\n+EXPORT struct S_DDI call_async_S_DDI(struct S_DDI (*cb)(void)) { return launch<struct S_DDI>(cb); }\n+EXPORT struct S_DDF call_async_S_DDF(struct S_DDF (*cb)(void)) { return launch<struct S_DDF>(cb); }\n+EXPORT struct S_DDD call_async_S_DDD(struct S_DDD (*cb)(void)) { return launch<struct S_DDD>(cb); }\n+EXPORT struct S_DDP call_async_S_DDP(struct S_DDP (*cb)(void)) { return launch<struct S_DDP>(cb); }\n+EXPORT struct S_DPI call_async_S_DPI(struct S_DPI (*cb)(void)) { return launch<struct S_DPI>(cb); }\n+EXPORT struct S_DPF call_async_S_DPF(struct S_DPF (*cb)(void)) { return launch<struct S_DPF>(cb); }\n+EXPORT struct S_DPD call_async_S_DPD(struct S_DPD (*cb)(void)) { return launch<struct S_DPD>(cb); }\n+EXPORT struct S_DPP call_async_S_DPP(struct S_DPP (*cb)(void)) { return launch<struct S_DPP>(cb); }\n+EXPORT struct S_PII call_async_S_PII(struct S_PII (*cb)(void)) { return launch<struct S_PII>(cb); }\n+EXPORT struct S_PIF call_async_S_PIF(struct S_PIF (*cb)(void)) { return launch<struct S_PIF>(cb); }\n+EXPORT struct S_PID call_async_S_PID(struct S_PID (*cb)(void)) { return launch<struct S_PID>(cb); }\n+EXPORT struct S_PIP call_async_S_PIP(struct S_PIP (*cb)(void)) { return launch<struct S_PIP>(cb); }\n+EXPORT struct S_PFI call_async_S_PFI(struct S_PFI (*cb)(void)) { return launch<struct S_PFI>(cb); }\n+EXPORT struct S_PFF call_async_S_PFF(struct S_PFF (*cb)(void)) { return launch<struct S_PFF>(cb); }\n+EXPORT struct S_PFD call_async_S_PFD(struct S_PFD (*cb)(void)) { return launch<struct S_PFD>(cb); }\n+EXPORT struct S_PFP call_async_S_PFP(struct S_PFP (*cb)(void)) { return launch<struct S_PFP>(cb); }\n+EXPORT struct S_PDI call_async_S_PDI(struct S_PDI (*cb)(void)) { return launch<struct S_PDI>(cb); }\n+EXPORT struct S_PDF call_async_S_PDF(struct S_PDF (*cb)(void)) { return launch<struct S_PDF>(cb); }\n+EXPORT struct S_PDD call_async_S_PDD(struct S_PDD (*cb)(void)) { return launch<struct S_PDD>(cb); }\n+EXPORT struct S_PDP call_async_S_PDP(struct S_PDP (*cb)(void)) { return launch<struct S_PDP>(cb); }\n+EXPORT struct S_PPI call_async_S_PPI(struct S_PPI (*cb)(void)) { return launch<struct S_PPI>(cb); }\n+EXPORT struct S_PPF call_async_S_PPF(struct S_PPF (*cb)(void)) { return launch<struct S_PPF>(cb); }\n+EXPORT struct S_PPD call_async_S_PPD(struct S_PPD (*cb)(void)) { return launch<struct S_PPD>(cb); }\n+EXPORT struct S_PPP call_async_S_PPP(struct S_PPP (*cb)(void)) { return launch<struct S_PPP>(cb); }\n+}\n","filename":"test\/jdk\/java\/foreign\/libAsyncInvokers.cpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default_gc\n@@ -50,0 +50,57 @@\n+\/*\n+ * @test id=zgc\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Z\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestAsyncStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestAsyncStackWalk\n+ *\/\n+\/*\n+ * @test id=shenandoah\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestAsyncStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestAsyncStackWalk\n+ *\/\n+\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=default_gc\n@@ -50,0 +50,57 @@\n+\/*\n+ * @test id=zgc\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Z\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseZGC\n+ *   TestStackWalk\n+ *\/\n+\/*\n+ * @test id=shenandoah\n+ * @requires (((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\")\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UseShenandoahGC\n+ *   TestStackWalk\n+ *\/\n+\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -79,24 +79,37 @@\n-    private static final MethodHandle MH_sumInts = link(\"sumInts\",\n-            MethodType.methodType(int.class, int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumDoubles = link(\"sumDoubles\",\n-            MethodType.methodType(double.class, int.class, VaList.class),\n-            FunctionDescriptor.of(C_DOUBLE, C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_getInt = link(\"getInt\",\n-            MethodType.methodType(int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumStruct = link(\"sumStruct\",\n-            MethodType.methodType(int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumBigStruct = link(\"sumBigStruct\",\n-            MethodType.methodType(long.class, VaList.class),\n-            FunctionDescriptor.of(C_LONG_LONG, C_VA_LIST));\n-    private static final MethodHandle MH_sumHugeStruct = link(\"sumHugeStruct\",\n-            MethodType.methodType(long.class, VaList.class),\n-            FunctionDescriptor.of(C_LONG_LONG, C_VA_LIST));\n-    private static final MethodHandle MH_sumFloatStruct = link(\"sumFloatStruct\",\n-            MethodType.methodType(float.class, VaList.class),\n-            FunctionDescriptor.of(C_FLOAT, C_VA_LIST));\n-    private static final MethodHandle MH_sumStack = link(\"sumStack\",\n-            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),\n-            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));\n+    private static final MethodHandle VALIST_TO_ADDRESS;\n+    private static final MethodHandle ADDRESS_TO_VALIST;\n+\n+    static {\n+        try {\n+            VALIST_TO_ADDRESS = MethodHandles.lookup().findVirtual(VaList.class, \"address\", MethodType.methodType(MemoryAddress.class));\n+            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class));\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+\n+    private static final MethodHandle MH_sumInts = linkVaList(\"sumInts\",\n+            MethodType.methodType(int.class, int.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_INT, C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumDoubles = linkVaList(\"sumDoubles\",\n+            MethodType.methodType(double.class, int.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_DOUBLE, C_INT, C_POINTER));\n+    private static final MethodHandle MH_getInt = linkVaList(\"getInt\",\n+            MethodType.methodType(int.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumStruct = linkVaList(\"sumStruct\",\n+            MethodType.methodType(int.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumBigStruct = linkVaList(\"sumBigStruct\",\n+            MethodType.methodType(long.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n+    private static final MethodHandle MH_sumHugeStruct = linkVaList(\"sumHugeStruct\",\n+            MethodType.methodType(long.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n+    private static final MethodHandle MH_sumFloatStruct = linkVaList(\"sumFloatStruct\",\n+            MethodType.methodType(float.class, MemoryAddress.class),\n+            FunctionDescriptor.of(C_FLOAT, C_POINTER));\n+    private static final MethodHandle MH_sumStack = linkVaList(\"sumStack\",\n+            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),\n+            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER));\n@@ -105,1 +118,13 @@\n-        return abi.downcallHandle(LOOKUP.lookup(symbol).get(), mt, fd);\n+        return linkInternal(symbol, mt, fd, false);\n+    }\n+\n+    private static MethodHandle linkVaList(String symbol, MethodType mt, FunctionDescriptor fd) {\n+        return linkInternal(symbol, mt, fd, true);\n+    }\n+\n+\n+    private static MethodHandle linkInternal(String symbol, MethodType mt, FunctionDescriptor fd, boolean hasVaListParam) {\n+        MethodHandle handle = abi.downcallHandle(LOOKUP.lookup(symbol).get(), mt, fd);\n+        return hasVaListParam ?\n+                MethodHandles.filterArguments(handle, handle.type().parameterCount() - 1, VALIST_TO_ADDRESS) :\n+                handle;\n@@ -527,1 +552,1 @@\n-        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_POINTER);\n@@ -804,1 +829,1 @@\n-                return MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n+                MethodHandle handle = MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n@@ -806,0 +831,1 @@\n+                return MethodHandles.filterArguments(handle, 0, ADDRESS_TO_VALIST);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":54,"deletions":28,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+typedef struct {\n+    jclass holder;\n+    jmethodID mid;\n+} *JNICB;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+public class JNICB {\n+\n+    static {\n+        System.loadLibrary(\"JNICB\");\n+    }\n+\n+    public static native long makeCB(String holder, String name, String signature);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class QSort {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+    static final MethodHandle clib_qsort;\n+    static final MemoryAddress native_compar;\n+    static final MemoryAddress panama_upcall_compar;\n+    static final long jni_upcall_compar;\n+\n+    static final int[] INPUT = { 5, 3, 2, 7, 8, 12, 1, 7 };\n+    static final MemorySegment INPUT_SEGMENT;\n+\n+    static {\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), ResourceScope.globalScope());\n+        INPUT_SEGMENT.copyFrom(MemorySegment.ofArray(INPUT));\n+\n+        System.loadLibrary(\"QSortJNI\");\n+        jni_upcall_compar = JNICB.makeCB(\"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\", \"jni_upcall_compar\", \"(II)I\");\n+\n+        try {\n+            SymbolLookup systemLookup = CLinker.systemLookup();\n+            clib_qsort = abi.downcallHandle(\n+                    systemLookup.lookup(\"qsort\").orElseThrow(),\n+                    MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+                    FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER)\n+            );\n+            System.loadLibrary(\"QSort\");\n+            native_compar = SymbolLookup.loaderLookup().lookup(\"compar\").orElseThrow();\n+            panama_upcall_compar = abi.upcallStub(\n+                    lookup().findStatic(QSort.class,\n+                            \"panama_upcall_compar\",\n+                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n+                    FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+                    ResourceScope.globalScope()\n+            );\n+        } catch (ReflectiveOperationException e) {\n+            throw new BootstrapMethodError(e);\n+        }\n+    }\n+\n+    static native void jni_qsort_optimized(int[] array, long cb);\n+    static native void jni_qsort_naive(int[] array);\n+\n+    @FunctionalInterface\n+    interface JNIComparator {\n+        int cmp(int e0, int e1);\n+    }\n+\n+    static final JNIComparator COMP = QSort::jni_upcall_compar;\n+\n+    @Benchmark\n+    public void native_qsort() throws Throwable {\n+         clib_qsort.invokeExact(INPUT_SEGMENT.address(), (long) INPUT.length, JAVA_INT.byteSize(), native_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_optimized() {\n+        jni_qsort_optimized(INPUT, jni_upcall_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_naive() {\n+        jni_qsort_naive(INPUT);\n+    }\n+\n+    @Benchmark\n+    public void panama_upcall_qsort() throws Throwable {\n+        clib_qsort.invokeExact(INPUT_SEGMENT.address(), (long) INPUT.length, JAVA_INT.byteSize(), panama_upcall_compar);\n+    }\n+\n+    private static int getIntAbsolute(MemoryAddress addr) {\n+        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+    }\n+\n+    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n+        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n+    }\n+\n+    static int jni_upcall_compar(int j0, int j1) {\n+        return Integer.compare(j0, j1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -77,4 +77,4 @@\n-        cb_blank_jni = makeCB(className, \"blank\", \"()V\");\n-        cb_identity_jni = makeCB(className, \"identity\", \"(I)I\");\n-        cb_args5_jni = makeCB(className, \"args5\", \"(JDJDJ)V\");\n-        cb_args10_jni = makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n+        cb_blank_jni = JNICB.makeCB(className, \"blank\", \"()V\");\n+        cb_identity_jni = JNICB.makeCB(className, \"identity\", \"(I)I\");\n+        cb_args5_jni = JNICB.makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = JNICB.makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -147,1 +147,0 @@\n-    static native long makeCB(String holder, String name, String signature);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -71,1 +71,1 @@\n-                FunctionDescriptor.ofVoid(C_INT, C_VA_LIST));\n+                FunctionDescriptor.ofVoid(C_INT, C_POINTER));\n@@ -88,1 +88,1 @@\n-                    vaList);\n+                    vaList.address());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+\n+#include \"JNICB.h\"\n+#include \"jlong.h\"\n+\n+#define CHECK_NULL(thing, message) \\\n+    if (thing == NULL) { \\\n+        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n+        (*env)->ThrowNew(env, cls, message); \\\n+        return 0; \\\n+    }\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_JNICB_makeCB\n+  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n+\n+  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n+  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n+  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n+\n+  JNICB cb = malloc(sizeof *cb);\n+  CHECK_NULL(cb, \"Can not allocate cb\");\n+\n+  jclass holder = (*env)->FindClass(env, holderNameC);\n+  CHECK_NULL(holder, \"Can not find class\");\n+  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n+  cb->holder = holder;\n+\n+  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n+  CHECK_NULL(methodID, \"Can not find method\");\n+  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n+  cb->mid = methodID;\n+\n+  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n+  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n+  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n+\n+  return ptr_to_jlong(cb);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libJNICB.c","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\n+EXPORT int compar(const void* e0, const void* e1) {\n+    int i0 = *((int*) e0);\n+    int i1 = *((int*) e1);\n+    return i0 - i1;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSort.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+#include <stdlib.h>\n+\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n+\n+#ifdef _WIN64\n+#define THREAD_LOCAL __declspec(thread)\n+#else\n+#define THREAD_LOCAL __thread\n+#endif\n+\n+THREAD_LOCAL struct {\n+  JNICB cb;\n+  JNIEnv* env;\n+} ctx_opt;\n+\n+static int comparator(const void* e0, const void* e1) {\n+    JNICB jniCb = ctx_opt.cb;\n+    JNIEnv* env = ctx_opt.env;\n+    jint j0 = *((jint*) e0);\n+    jint j1 = *((jint*) e1);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, j0, j1);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1optimized\n+        (JNIEnv *env, jclass cls, jintArray arr, jlong cb) {\n+\n+    ctx_opt.cb = jlong_to_ptr(cb);\n+    ctx_opt.env = env;\n+\n+    jint* ints = (*env)->GetIntArrayElements(env, arr, NULL);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+\n+    qsort(ints, length, sizeof(jint), &comparator);\n+\n+    (*env)->ReleaseIntArrayElements(env, arr, ints, 0);\n+}\n+\n+JavaVM* VM = NULL;\n+\n+int java_cmp(const void *a, const void *b) {\n+   int v1 = *((int*)a);\n+   int v2 = *((int*)b);\n+\n+   JNIEnv* env;\n+   (*VM)->GetEnv(VM, (void**) &env, JNI_VERSION_10);\n+\n+   jclass qsortClass = (*env)->FindClass(env, \"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\");\n+   jmethodID methodId = (*env)->GetStaticMethodID(env, qsortClass, \"jni_upcall_compar\", \"(II)I\");\n+\n+   return (*env)->CallStaticIntMethod(env, qsortClass, methodId, v1, v2);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1naive\n+        (JNIEnv *env, jclass cls, jintArray arr) {\n+    if (VM == NULL) {\n+        (*env)->GetJavaVM(env, &VM);\n+    }\n+\n+    jint* carr = (*env)->GetIntArrayElements(env, arr, 0);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+    qsort(carr, length, sizeof(jint), java_cmp);\n+    (*env)->ReleaseIntArrayElements(env, arr, carr, 0);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSortJNI.c","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -25,20 +25,0 @@\n-#include \"jlong.h\"\n-\n-typedef struct {\n-    jclass holder;\n-    jmethodID mid;\n-} *JNICB;\n-\n-#define CHECK_NULL(thing, message) \\\n-    if (thing == NULL) { \\\n-        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n-        (*env)->ThrowNew(env, cls, message); \\\n-        return 0; \\\n-    }\n-\n-JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_makeCB\n-  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n-\n-  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n-  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n-  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n@@ -46,19 +26,2 @@\n-  JNICB cb = malloc(sizeof *cb);\n-  CHECK_NULL(cb, \"Can not allocate cb\");\n-\n-  jclass holder = (*env)->FindClass(env, holderNameC);\n-  CHECK_NULL(holder, \"Can not find class\");\n-  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n-  cb->holder = holder;\n-\n-  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n-  CHECK_NULL(methodID, \"Can not find method\");\n-  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n-  cb->mid = methodID;\n-\n-  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n-  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n-  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n-\n-  return ptr_to_jlong(cb);\n-}\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-            lookup.lookup(\"distance_ptrs\").get(),\n+                lookup.lookup(\"distance_ptrs\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}