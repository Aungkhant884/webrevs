{"files":[{"patch":"@@ -319,41 +319,0 @@\n-void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n-  __ block_comment(\"{ save_java_frame_anchor \");\n-  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n-\n-  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n-  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n-  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} save_java_frame_anchor \");\n-}\n-\n-void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n-  __ block_comment(\"{ restore_java_frame_anchor \");\n-  \/\/ thread->_last_Java_sp = NULL\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n-\n-  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n-  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-\n-  \/\/_thread->frame_anchor()->copy(&_anchor);\n-\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n-\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n-\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n-\n-  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n-  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n-  __ block_comment(\"} restore_java_frame_anchor \");\n-}\n-\n@@ -445,0 +404,54 @@\n+static int compute_res_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  return result_size;\n+}\n+\n+static void save_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ save java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, offset), reg->as_Register());\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, offset), reg->as_XMMRegister());\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} save java result \");\n+}\n+\n+static void restore_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n+  int offset = res_save_area_offset;\n+  __ block_comment(\"{ restore java result \");\n+  for (int i = 0; i < conv._rets_length; i++) {\n+    VMReg reg = conv._ret_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, offset));\n+      offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n+      offset += 16;\n+    } else {\n+      ShouldNotReachHere(); \/\/ unhandled type\n+    }\n+  }\n+  __ block_comment(\"} restore java result \");\n+}\n+\n@@ -577,0 +590,1 @@\n+<<<<<<< HEAD\n@@ -587,0 +601,2 @@\n+=======\n+>>>>>>> 59281cd64b5109b6b635377c03ce1155e53765b9\n@@ -611,0 +627,1 @@\n+  int res_save_area_size = compute_res_save_area_size(conv);\n@@ -616,1 +633,2 @@\n-  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int res_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int arg_save_area_offset   = res_save_area_offset   + res_save_area_size;\n@@ -618,6 +636,2 @@\n-  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n-  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n-\n-  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n-  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n-  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+  int frame_data_offset      = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = frame_data_offset      + sizeof(OptimizedEntryBlob::FrameData);\n@@ -634,2 +648,2 @@\n-  \/\/      | AuxiliarySaves      |\n-  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      | FrameData           |\n+  \/\/      |---------------------| = frame_data_offset\n@@ -643,0 +657,3 @@\n+  \/\/      | res_save_area       |\n+  \/\/      |---------------------| = res_save_are_offset\n+  \/\/      |                     |\n@@ -653,1 +670,0 @@\n-  Label call_return;\n@@ -669,1 +685,1 @@\n-  __ block_comment(\"{ get_thread\");\n+  __ block_comment(\"{ on_entry\");\n@@ -671,1 +687,1 @@\n-  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n@@ -673,1 +689,1 @@\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_entry)));\n@@ -676,40 +692,1 @@\n-  __ movptr(Address(rsp, thread_offset), r15_thread);\n-  __ block_comment(\"} get_thread\");\n-\n-  \/\/ TODO:\n-  \/\/ We expect not to be coming from JNI code, but we might be.\n-  \/\/ We should figure out what our stance is on supporting that and then maybe add\n-  \/\/ some more handling here for:\n-  \/\/   - handle blocks\n-  \/\/   - check for active exceptions (and emit an error)\n-\n-  __ block_comment(\"{ safepoint poll\");\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  if (os::is_MP()) {\n-    __ membar(Assembler::Membar_mask_bits(\n-                Assembler::LoadLoad  | Assembler::StoreLoad |\n-                Assembler::LoadStore | Assembler::StoreStore));\n-   }\n-\n-  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n-  Label L_after_safepoint_poll;\n-  Label L_safepoint_poll_slow_path;\n-\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n-\n-  __ bind(L_after_safepoint_poll);\n-  __ block_comment(\"} safepoint poll\");\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n-\n-  __ block_comment(\"{ reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n-  __ block_comment(\"} reguard stack check\");\n+  __ block_comment(\"} on_entry\");\n@@ -731,0 +708,10 @@\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+  save_java_result(_masm, conv, res_save_area_offset);\n+\n+  __ block_comment(\"{ on_exit\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, frame_data_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::on_exit)));\n@@ -732,0 +719,1 @@\n+  __ block_comment(\"} on_exit\");\n@@ -733,2 +721,1 @@\n-  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n-  __ reset_last_Java_frame(r15_thread, true);\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n@@ -736,1 +723,1 @@\n-  __ call(Address(rbx, Method::from_compiled_offset()));\n+  restore_java_result(_masm, conv, res_save_area_offset);\n@@ -738,0 +725,1 @@\n+  \/\/ return value shuffle\n@@ -764,21 +752,0 @@\n-  __ bind(call_return);\n-\n-  \/\/ also sets last Java frame\n-  __ movptr(r15_thread, Address(rsp, thread_offset));\n-  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n-  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n-\n-  __ block_comment(\"{ maybe_detach_thread\");\n-  Label L_after_detach;\n-  __ cmpb(Address(rsp, should_detach_offset), 0);\n-  __ jcc(Assembler::equal, L_after_detach);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n-  __ reinit_heapbase();\n-  __ bind(L_after_detach);\n-  __ block_comment(\"} maybe_detach_thread\");\n-\n-  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n-\n@@ -790,23 +757,0 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n-  __ mov(c_rarg0, r15_thread);\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-  \/\/ stack already aligned\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ reinit_heapbase();\n-  __ jmp(L_after_reguard);\n-  __ block_comment(\"} L_reguard\");\n-\n-  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -842,1 +786,1 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":86,"deletions":142,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test\n+ * @test id=scope\n@@ -32,0 +32,1 @@\n+<<<<<<< HEAD\n@@ -33,0 +34,28 @@\n+=======\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -DUPCALL_TEST_TYPE=SCOPE\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=no_scope\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -DUPCALL_TEST_TYPE=NO_SCOPE\n+ *   TestUpcall\n+ *\/\n+\n+\/*\n+ * @test id=async\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -DUPCALL_TEST_TYPE=ASYNC\n+>>>>>>> 59281cd64b5109b6b635377c03ce1155e53765b9\n@@ -44,0 +73,4 @@\n+<<<<<<< HEAD\n+=======\n+import org.testng.SkipException;\n+>>>>>>> 59281cd64b5109b6b635377c03ce1155e53765b9\n@@ -51,0 +84,1 @@\n+import java.util.HashMap;\n@@ -52,0 +86,1 @@\n+import java.util.Map;\n@@ -63,0 +98,8 @@\n+    private enum TestType {\n+        SCOPE,\n+        NO_SCOPE,\n+        ASYNC\n+    }\n+\n+    private static final TestType UPCALL_TEST_TYPE = TestType.valueOf(System.getProperty(\"UPCALL_TEST_TYPE\"));\n+\n@@ -65,0 +108,1 @@\n+        System.loadLibrary(\"AsyncInvokers\");\n@@ -90,0 +134,5 @@\n+    private static void checkSelected(TestType type) {\n+        if (UPCALL_TEST_TYPE != type)\n+            throw new SkipException(\"Skipping tests that were not selected\");\n+    }\n+\n@@ -92,0 +141,2 @@\n+        checkSelected(TestType.SCOPE);\n+\n@@ -110,0 +161,2 @@\n+        checkSelected(TestType.NO_SCOPE);\n+\n@@ -124,0 +177,57 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.ASYNC);\n+\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        MethodType mtype = methodType(ret, paramTypes, fields);\n+        try (NativeScope scope = new NativeScope()) {\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            MemoryAddress callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(scope, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n+\n+    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n+        if (ret == Ret.VOID) {\n+            String name = \"call_async_V\";\n+            return INVOKERS.computeIfAbsent(name, symbol ->\n+                abi.downcallHandle(\n+                    LOOKUP.lookup(symbol).orElseThrow(),\n+                    MethodType.methodType(void.class, MemoryAddress.class),\n+                    FunctionDescriptor.ofVoid(C_POINTER)));\n+        }\n+\n+        String name = \"call_async_\" + returnType.name().charAt(0)\n+                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n+\n+        return INVOKERS.computeIfAbsent(name, symbol -> {\n+            MemoryAddress invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            MemoryLayout returnLayout = returnType.layout(fields);\n+            MethodType type = MethodType.methodType(paramCarrier(returnLayout), MemoryAddress.class);\n+            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n+\n+            return abi.downcallHandle(invokerSymbol, type, desc);\n+        });\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":111,"deletions":1,"binary":false,"changes":112,"status":"modified"}]}