{"files":[{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemorySegment;\n@@ -2464,1 +2464,1 @@\n-     * Finds a native library symbol with the given name that is associated\n+     * Finds the address of a native symbol with given name, in one of the libraries {@linkplain System#loadLibrary(String) associated}\n@@ -2468,1 +2468,1 @@\n-     * @return the symbol (if any).\n+     * @return a zero-length segment, whose base address is the symbol address (if any).\n@@ -2470,0 +2470,2 @@\n+     * @see System#load(String)\n+     * @see System#loadLibrary(String)\n@@ -2471,1 +2473,1 @@\n-    public final Optional<NativeSymbol> findNative(String name) {\n+    public final Optional<MemorySegment> findNative(String name) {\n@@ -2476,1 +2478,1 @@\n-                : Optional.of(NativeSymbol.ofAddress(name, addr, loaderScope));\n+                : Optional.of(MemorySegment.ofAddress(addr, 0L, loaderScope));\n@@ -2480,1 +2482,1 @@\n-    \/\/ native symbols associated with libraries loaded by this loader.\n+    \/\/ segments associated with libraries loaded by this loader.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * {@link MemoryAddress}, {@link VaList} and {@link NativeSymbol}.\n+ * {@link MemoryAddress} and {@link VaList}.\n@@ -45,1 +45,1 @@\n-public sealed interface Addressable permits MemorySegment, MemoryAddress, NativeSymbol, VaList {\n+public sealed interface Addressable permits MemorySegment, MemoryAddress, VaList {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Addressable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n- * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a native symbol},\n- * the downcall method handle type features a leading parameter of type {@link NativeSymbol}, from which the\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a target address},\n+ * the downcall method handle type features a leading parameter of type {@link Addressable}, from which the\n@@ -104,2 +104,2 @@\n- * Upcall stubs are modelled by instances of type {@link NativeSymbol}; upcall stubs can be passed by reference to other\n- * downcall method handles (as {@link NativeSymbol} implements the {@link Addressable} interface) and,\n+ * Upcall stubs are modelled by instances of type {@link MemorySegment}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link MemorySegment} implements the {@link Addressable} interface) and,\n@@ -119,2 +119,2 @@\n- * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment},\n- * {@link NativeSymbol} or {@link VaList}):\n+ * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment}\n+ * or {@link VaList}):\n@@ -168,1 +168,1 @@\n-     * @return a symbol in the standard libraries associated with this linker.\n+     * @return a zero-length segment, whose base address is the symbol address (if any).\n@@ -170,1 +170,1 @@\n-    default Optional<NativeSymbol> lookup(String name) {\n+    default Optional<MemorySegment> lookup(String name) {\n@@ -176,1 +176,1 @@\n-     * which can be used to call a target foreign function at the address in the given native symbol.\n+     * which can be used to call a target foreign function at the address in the given {@link Addressable} instance.\n@@ -193,1 +193,1 @@\n-    default MethodHandle downcallHandle(NativeSymbol symbol, FunctionDescriptor function) {\n+    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n@@ -200,1 +200,1 @@\n-     * used to call a target foreign function at the address in a dynamically provided native symbol.\n+     * used to call a target foreign function at the address in a dynamically provided {@link Addressable} instance.\n@@ -202,1 +202,1 @@\n-     * entry point, of type {@link NativeSymbol}.\n+     * entry point, of type {@link Addressable}.\n@@ -208,2 +208,2 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the native symbol passed to it is\n-     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if the native symbol is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link Addressable} parameter passed to it is\n+     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n@@ -223,2 +223,2 @@\n-     * The returned function pointer is associated with the provided memory session. When such session is closed,\n-     * the corresponding native stub will be deallocated.\n+     * The returned memory segment's base address points to the newly allocated native stub, and is associated with\n+     * the provided memory session. When such session is closed, the corresponding native stub will be deallocated.\n@@ -235,1 +235,1 @@\n-     * @return the native stub symbol.\n+     * @return a zero-length segment whose base address is the address of the native stub.\n@@ -242,1 +242,1 @@\n-    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.util.Objects;\n-\n-import jdk.internal.foreign.Scoped;\n-import jdk.internal.foreign.NativeSymbolImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-\/**\n- * A native symbol models a reference to a location (typically the entry point of a function) in a native library.\n- * A native symbol has a name, and is associated with a memory session, which governs the native symbol's lifecycle.\n- * This is useful, since the library a native symbol refers to can be <em>unloaded<\/em>, thus invalidating the native symbol.\n- * While native symbols are typically obtained via {@link ClassLoader#findNative(String)}, it is also possible to obtain an\n- * <em>anonymous<\/em> native symbol, in the form of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, MemorySession) upcall stub},\n- * that is, a reference to a dynamically-generated native symbol which can be used to call back into Java code.\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-sealed public interface NativeSymbol extends Addressable permits NativeSymbolImpl {\n-\n-    \/**\n-     * {@return the name of this symbol}\n-     *\/\n-    String name();\n-\n-    \/**\n-     * {@return the memory address associated with this symbol}\n-     * @throws IllegalStateException if the {@linkplain #session() session} associated with this native symbol is not\n-     * {@linkplain MemorySession#isAlive() alive}, or if access occurs from a thread other than the thread owning that session.\n-     *\/\n-    @Override\n-    MemoryAddress address();\n-\n-    \/**\n-     * {@return a non-closeable view of the memory session associated with this native symbol}\n-     *\/\n-    MemorySession session();\n-\n-    \/**\n-     * Creates a new symbol from given name, address and memory session.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param name the symbol name.\n-     * @param address the symbol address.\n-     * @param session the symbol memory session.\n-     * @return A new symbol from given name, address and memory session.\n-     * @throws IllegalStateException if {@code session} is not {@linkplain MemorySession#isAlive() alive}, or if access occurs from\n-     * a thread other than the thread {@linkplain MemorySession#ownerThread() owning} {@code session}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static NativeSymbol ofAddress(String name, MemoryAddress address, MemorySession session) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), NativeSymbol.class, \"ofAddress\");\n-        Objects.requireNonNull(name);\n-        Objects.requireNonNull(address);\n-        Objects.requireNonNull(session);\n-        return new NativeSymbolImpl(name, address, Scoped.toSessionImpl(session));\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/NativeSymbol.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -100,1 +100,1 @@\n- * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.NativeSymbol} and\n+ * The key abstractions introduced to support foreign function access are {@link java.lang.foreign.FunctionDescriptor} and\n@@ -102,1 +102,1 @@\n- * The first is used to model native addresses (more on that later), while the second provides linking capabilities\n+ * The first is used to model the signature of foreign functions, while the second provides linking capabilities\n@@ -213,1 +213,1 @@\n- * provided when the upcall stub is created. This same session is made available by the {@link java.lang.foreign.NativeSymbol}\n+ * provided when the upcall stub is created. This same session is made available by the {@link java.lang.foreign.MemorySegment}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.NativeSymbol;\n-\n-public record NativeSymbolImpl(String name, MemoryAddress address, MemorySessionImpl sessionImpl) implements NativeSymbol, Scoped {\n-    @Override\n-    public MemoryAddress address() {\n-        sessionImpl.checkValidStateSlow();\n-        return address;\n-    }\n-\n-    @Override\n-    public MemorySession session() {\n-        return new MemorySessionImpl.NonCloseableView(sessionImpl());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -38,1 +37,0 @@\n-import jdk.internal.loader.NativeLibraries;\n@@ -52,1 +50,1 @@\n-    private static final Function<String, Optional<NativeSymbol>> fallbackLookup = name -> Optional.empty();\n+    private static final Function<String, Optional<MemorySegment>> fallbackLookup = name -> Optional.empty();\n@@ -58,1 +56,1 @@\n-    private static final Function<String, Optional<NativeSymbol>> syslookup = makeSystemLookup();\n+    private static final Function<String, Optional<MemorySegment>> syslookup = makeSystemLookup();\n@@ -60,1 +58,1 @@\n-    private static final Function<String, Optional<NativeSymbol>> makeSystemLookup() {\n+    private static final Function<String, Optional<MemorySegment>> makeSystemLookup() {\n@@ -74,1 +72,1 @@\n-    private static Function<String, Optional<NativeSymbol>> makeWindowsLookup() {\n+    private static Function<String, Optional<MemorySegment>> makeWindowsLookup() {\n@@ -81,1 +79,1 @@\n-        Function<String, Optional<NativeSymbol>> lookup = libLookup(libs -> libs.load(stdLib));\n+        Function<String, Optional<MemorySegment>> lookup = libLookup(libs -> libs.load(stdLib));\n@@ -86,1 +84,1 @@\n-            Function<String, Optional<NativeSymbol>> fallbackLibLookup =\n+            Function<String, Optional<MemorySegment>> fallbackLibLookup =\n@@ -93,2 +91,2 @@\n-            Function<String, Optional<NativeSymbol>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n-                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), MemorySession.global()));\n+            Function<String, Optional<MemorySegment>> fallbackLookup = name -> Optional.ofNullable(WindowsFallbackSymbols.valueOfOrNull(name))\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()), 0L, MemorySession.global()));\n@@ -96,1 +94,1 @@\n-            final Function<String, Optional<NativeSymbol>> finalLookup = lookup;\n+            final Function<String, Optional<MemorySegment>> finalLookup = lookup;\n@@ -103,1 +101,1 @@\n-    private static Function<String, Optional<NativeSymbol>> libLookup(Function<RawNativeLibraries, NativeLibrary> loader) {\n+    private static Function<String, Optional<MemorySegment>> libLookup(Function<RawNativeLibraries, NativeLibrary> loader) {\n@@ -111,1 +109,1 @@\n-                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), MemorySession.global()));\n+                        Optional.of(MemorySegment.ofAddress(MemoryAddress.ofLong(addr), 0, MemorySession.global()));\n@@ -136,1 +134,1 @@\n-    public Optional<NativeSymbol> lookup(String name) {\n+    public Optional<MemorySegment> lookup(String name) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -36,1 +37,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -60,1 +60,1 @@\n-    public NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session) {\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session) {\n@@ -70,1 +70,1 @@\n-        NativeSymbol symb =  arrangeUpcall(target, target.type(), function, Scoped.toSessionImpl(session));\n+        MemorySegment symb =  arrangeUpcall(target, target.type(), function, Scoped.toSessionImpl(session));\n@@ -74,1 +74,1 @@\n-    protected abstract NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType,\n+    protected abstract MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -418,1 +417,1 @@\n-        return type == Addressable.class || type == NativeSymbol.class;\n+        return type == Addressable.class;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.Addressable;\n@@ -30,1 +31,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -97,2 +97,2 @@\n-            addArgumentBinding(0, NativeSymbol.class, ValueLayout.ADDRESS, List.of(\n-                Binding.unboxAddress(NativeSymbol.class),\n+            addArgumentBinding(0, Addressable.class, ValueLayout.ADDRESS, List.of(\n+                Binding.unboxAddress(Addressable.class),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Addressable;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -64,1 +64,1 @@\n-                    methodType(void.class, NativeSymbol.class));\n+                    methodType(void.class, Addressable.class));\n@@ -114,1 +114,1 @@\n-        assert handle.type().parameterType(1) == NativeSymbol.class;\n+        assert handle.type().parameterType(1) == Addressable.class;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -352,1 +351,1 @@\n-    public static void checkSymbol(NativeSymbol symbol) {\n+    public static void checkSymbol(Addressable symbol) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -65,1 +64,1 @@\n-    public static NativeSymbol make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, MemorySession session) {\n+    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemorySegment;\n@@ -32,1 +32,0 @@\n-import jdk.internal.foreign.NativeSymbolImpl;\n@@ -52,1 +51,1 @@\n-    static NativeSymbol makeUpcall(long entry, MemorySession session) {\n+    static MemorySegment makeUpcall(long entry, MemorySession session) {\n@@ -60,1 +59,1 @@\n-        return new NativeSymbolImpl(\"upcall:\" + Long.toHexString(entry), MemoryAddress.ofLong(entry), ((MemorySessionImpl)session));\n+        return MemorySegment.ofAddress(MemoryAddress.ofLong(entry), 0L, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -158,1 +157,1 @@\n-    public NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemorySegment;\n@@ -62,1 +62,1 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemorySegment;\n@@ -62,1 +62,1 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -134,1 +133,1 @@\n-    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemorySegment;\n@@ -66,1 +66,1 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -134,1 +133,1 @@\n-    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.MemorySegment;\n@@ -65,1 +65,1 @@\n-    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, MemorySession session) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -457,1 +456,1 @@\n-    MethodHandle downcallHandle(CLinker abi, NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+    MethodHandle downcallHandle(CLinker abi, Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -110,1 +109,1 @@\n-    public static NativeSymbol findNativeOrThrow(Class<?> clazz, String name) {\n+    public static Addressable findNativeOrThrow(Class<?> clazz, String name) {\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -127,1 +126,1 @@\n-        NativeSymbol upcall;\n+        MemorySegment upcall;\n@@ -174,1 +173,1 @@\n-            NativeSymbol upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n+            MemorySegment upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), session);\n@@ -179,1 +178,1 @@\n-    NativeSymbol sessionChecker(MemorySession session) {\n+    MemorySegment sessionChecker(MemorySession session) {\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-        final static NativeSymbol printfAddr = abi.lookup(\"printf\").get();\n+        final static Addressable printfAddr = abi.lookup(\"printf\").get();\n@@ -283,1 +283,1 @@\n-                NativeSymbol qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n+                Addressable qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, session);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.Addressable;\n@@ -43,1 +44,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -69,1 +69,1 @@\n-        NativeSymbol addr = findNativeOrThrow(TestDowncall.class, fName);\n+        Addressable addr = findNativeOrThrow(TestDowncall.class, fName);\n@@ -91,1 +91,1 @@\n-        NativeSymbol addr = findNativeOrThrow(TestDowncall.class, \"s\" + fName);\n+        Addressable addr = findNativeOrThrow(TestDowncall.class, \"s\" + fName);\n@@ -110,1 +110,1 @@\n-    Object doCall(NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+    Object doCall(Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Addressable;\n@@ -36,2 +37,0 @@\n-import java.lang.foreign.NativeSymbol;\n-import java.lang.foreign.MemorySession;\n@@ -46,1 +45,1 @@\n-    private static final NativeSymbol DUMMY_TARGET = NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), MemorySession.global());\n+    private static final Addressable DUMMY_TARGET = MemoryAddress.ofLong(1);\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Addressable;\n@@ -44,1 +45,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -87,1 +87,1 @@\n-            NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, name);\n+            Addressable ma = findNativeOrThrow(TestIntrinsics.class, name);\n@@ -96,1 +96,1 @@\n-            NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, \"empty\");\n+            Addressable ma = findNativeOrThrow(TestIntrinsics.class, \"empty\");\n@@ -111,1 +111,1 @@\n-            NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, \"identity_va\");\n+            Addressable ma = findNativeOrThrow(TestIntrinsics.class, \"identity_va\");\n@@ -124,1 +124,1 @@\n-                NativeSymbol ma = findNativeOrThrow(TestIntrinsics.class, \"invoke_high_arity\" + i);\n+                Addressable ma = findNativeOrThrow(TestIntrinsics.class, \"invoke_high_arity\" + i);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Addressable;\n@@ -38,2 +39,0 @@\n-import java.lang.foreign.MemorySession;\n-import java.lang.foreign.NativeSymbol;\n@@ -49,1 +48,1 @@\n-                NativeSymbol.ofAddress(\"nullAddress\", MemoryAddress.NULL, MemorySession.global()),\n+                MemoryAddress.NULL,\n@@ -57,1 +56,1 @@\n-        mh.invokeExact(NativeSymbol.ofAddress(\"null\", MemoryAddress.NULL, MemorySession.global()));\n+        mh.invokeExact((Addressable)MemoryAddress.NULL);\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,2 +103,1 @@\n-            MemorySession.class,\n-            NativeSymbol.class\n+            MemorySession.class\n@@ -187,1 +186,0 @@\n-        addDefaultMapping(NativeSymbol.class, NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), MemorySession.global()));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -161,2 +160,0 @@\n-        \/\/ native symbol\n-        ScopedOperation.of(session -> NativeSymbol.ofAddress(\"\", MemoryAddress.NULL, session), NativeSymbol::address, \"NativeSymbol::address\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Addressable;\n@@ -40,1 +41,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -63,1 +63,1 @@\n-        NativeSymbol addr = findNativeOrThrow(TestUpcallAsync.class, fName);\n+        Addressable addr = findNativeOrThrow(TestUpcallAsync.class, fName);\n@@ -75,1 +75,1 @@\n-            NativeSymbol callback = ABI.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, session);\n+            Addressable callback = ABI.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, session);\n@@ -104,1 +104,1 @@\n-            NativeSymbol invokerSymbol = TestUpcallAsync.class.getClassLoader().findNative(symbol).orElseThrow();\n+            Addressable invokerSymbol = TestUpcallAsync.class.getClassLoader().findNative(symbol).orElseThrow();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Addressable;\n@@ -28,1 +29,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -63,1 +63,1 @@\n-    private static NativeSymbol DUMMY_STUB;\n+    private static Addressable DUMMY_STUB;\n@@ -100,1 +100,1 @@\n-    static NativeSymbol makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static Addressable makeCallback(MemorySession session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.Addressable;\n@@ -38,1 +39,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -104,1 +104,1 @@\n-            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n+            Addressable upcallStub = LINKER.upcallStub(target, upcallDescriptor, session);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Addressable;\n@@ -36,1 +37,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -55,1 +55,1 @@\n-        NativeSymbol addr = findNativeOrThrow(TestUpcallScope.class, fName);\n+        Addressable addr = findNativeOrThrow(TestUpcallScope.class, fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Addressable;\n@@ -37,1 +38,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -56,1 +56,1 @@\n-        NativeSymbol addr = findNativeOrThrow(TestUpcallStack.class, \"s\" + fName);\n+        Addressable addr = findNativeOrThrow(TestUpcallStack.class, \"s\" + fName);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.lang.foreign.Addressable;\n@@ -42,1 +43,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -93,1 +93,1 @@\n-            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n+            Addressable upcallStub = LINKER.upcallStub(target, upcallDesc, session);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Addressable;\n@@ -37,1 +38,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -68,1 +68,1 @@\n-    static final NativeSymbol VARARGS_ADDR = findNativeOrThrow(TestVarArgs.class, \"varargs\");\n+    static final Addressable VARARGS_ADDR = findNativeOrThrow(TestVarArgs.class, \"varargs\");\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.foreign.Addressable;\n@@ -26,1 +27,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -76,1 +76,1 @@\n-            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n+            Addressable stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), session);\n@@ -89,1 +89,1 @@\n-            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n+            Addressable stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), session);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.Addressable;\n@@ -66,1 +66,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -70,1 +70,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) }\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) }\n@@ -90,1 +90,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -94,1 +94,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -120,1 +120,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -124,1 +124,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -142,1 +142,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -146,1 +146,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -202,1 +202,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -206,1 +206,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -233,1 +233,1 @@\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n@@ -237,1 +237,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -257,1 +257,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n@@ -262,1 +262,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) }\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) }\n@@ -286,1 +286,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, Addressable.class));\n@@ -291,1 +291,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -324,1 +324,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -328,1 +328,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -378,1 +378,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -382,1 +382,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -407,1 +407,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -412,1 +412,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n@@ -430,1 +430,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -435,1 +435,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r9, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r9, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.Addressable;\n@@ -67,1 +67,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -71,1 +71,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -95,1 +95,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -99,1 +99,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -126,1 +126,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -130,1 +130,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -156,1 +156,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -160,1 +160,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -186,1 +186,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -190,1 +190,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -211,1 +211,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -215,1 +215,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -242,1 +242,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -246,1 +246,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -277,1 +277,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -281,1 +281,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -334,1 +334,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -338,1 +338,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -377,1 +377,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -381,1 +381,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -399,1 +399,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, Addressable.class));\n@@ -403,1 +403,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -458,1 +458,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, Addressable.class));\n@@ -463,1 +463,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -490,1 +490,1 @@\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class, long.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class, long.class));\n@@ -494,1 +494,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.Addressable;\n@@ -65,1 +65,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -69,1 +69,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) }\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) }\n@@ -82,1 +82,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -86,1 +86,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -104,1 +104,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -108,1 +108,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -128,1 +128,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -132,1 +132,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -159,1 +159,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -163,1 +163,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -196,1 +196,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -200,1 +200,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -230,1 +230,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -234,1 +234,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -260,1 +260,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -264,1 +264,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -291,1 +291,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -295,1 +295,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -312,1 +312,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -316,1 +316,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -336,1 +336,1 @@\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, Addressable.class, MemoryAddress.class));\n@@ -340,1 +340,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n@@ -365,1 +365,1 @@\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, Addressable.class));\n@@ -369,1 +369,1 @@\n-            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { unboxAddress(Addressable.class), vmStore(r10, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        NativeSymbol foo = (NativeSymbol)fooSymbol.invoke(null);\n+        Addressable foo = (Addressable)fooSymbol.invoke(null);\n@@ -49,1 +49,1 @@\n-        Method invoke = invoker.getDeclaredMethod(\"invoke\", NativeSymbol.class);\n+        Method invoke = invoker.getDeclaredMethod(\"invoke\", Addressable.class);\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-    public static void invoke(NativeSymbol symbol) throws Throwable {\n+    public static void invoke(Addressable symbol) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.Addressable;\n@@ -33,1 +33,1 @@\n-    public static NativeSymbol fooSymbol() {\n+    public static Addressable fooSymbol() {\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+import java.lang.foreign.Addressable;\n@@ -83,1 +84,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -120,1 +120,1 @@\n-            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n+            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+import java.lang.foreign.Addressable;\n@@ -83,1 +84,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -119,1 +119,1 @@\n-            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n+            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), session);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -84,1 +83,1 @@\n-            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n+            Addressable stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), session);\n@@ -95,1 +94,1 @@\n-    static void payload(NativeSymbol cb) throws Throwable {\n+    static void payload(Addressable cb) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -530,1 +530,1 @@\n-            NativeSymbol stub = abi.upcallStub(callback, desc, session);\n+            Addressable stub = abi.upcallStub(callback, desc, session);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.Addressable;\n@@ -39,1 +40,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -49,3 +49,3 @@\n-    static final NativeSymbol funcA;\n-    static final NativeSymbol funcB;\n-    static final NativeSymbol funcC;\n+    static final Addressable funcA;\n+    static final Addressable funcB;\n+    static final Addressable funcC;\n@@ -72,1 +72,1 @@\n-        int x = (int) func.invokeExact((NativeSymbol) null);\n+        int x = (int) func.invokeExact((Addressable) null);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Addressable;\n@@ -29,1 +30,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -44,1 +44,1 @@\n-    static NativeSymbol func_addr;\n+    static Addressable func_addr;\n@@ -47,1 +47,1 @@\n-    static NativeSymbol identity_addr;\n+    static Addressable identity_addr;\n@@ -50,1 +50,1 @@\n-    static NativeSymbol identity_struct_addr;\n+    static Addressable identity_struct_addr;\n@@ -53,1 +53,1 @@\n-    static NativeSymbol identity_struct_3_addr;\n+    static Addressable identity_struct_3_addr;\n@@ -56,1 +56,1 @@\n-    static NativeSymbol identity_memory_address_addr;\n+    static Addressable identity_memory_address_addr;\n@@ -59,1 +59,1 @@\n-    static NativeSymbol identity_memory_address_3_addr;\n+    static Addressable identity_memory_address_3_addr;\n@@ -62,1 +62,1 @@\n-    static NativeSymbol args1_addr;\n+    static Addressable args1_addr;\n@@ -65,1 +65,1 @@\n-    static NativeSymbol args2_addr;\n+    static Addressable args2_addr;\n@@ -68,1 +68,1 @@\n-    static NativeSymbol args3_addr;\n+    static Addressable args3_addr;\n@@ -71,1 +71,1 @@\n-    static NativeSymbol args4_addr;\n+    static Addressable args4_addr;\n@@ -74,1 +74,1 @@\n-    static NativeSymbol args5_addr;\n+    static Addressable args5_addr;\n@@ -77,1 +77,1 @@\n-    static NativeSymbol args10_addr;\n+    static Addressable args10_addr;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -59,2 +58,2 @@\n-    static final NativeSymbol native_compar;\n-    static final NativeSymbol panama_upcall_compar;\n+    static final Addressable native_compar;\n+    static final Addressable panama_upcall_compar;\n@@ -66,1 +65,1 @@\n-    static NativeSymbol qsort_addr = abi.lookup(\"qsort\").get();\n+    static Addressable qsort_addr = abi.lookup(\"qsort\").get();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.NativeSymbol;\n@@ -59,4 +58,4 @@\n-    static final NativeSymbol cb_blank;\n-    static final NativeSymbol cb_identity;\n-    static final NativeSymbol cb_args5;\n-    static final NativeSymbol cb_args10;\n+    static final Addressable cb_blank;\n+    static final Addressable cb_identity;\n+    static final Addressable cb_args5;\n+    static final Addressable cb_args10;\n@@ -130,1 +129,1 @@\n-    static NativeSymbol makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static Addressable makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"}]}