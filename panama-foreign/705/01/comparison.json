{"files":[{"patch":"@@ -188,1 +188,1 @@\n-     * Returns a memory layout with the same size and alignment constraints as this layout,\n+     * Returns a memory layout of the same type with the same size and alignment constraints as this layout,\n@@ -238,1 +238,1 @@\n-     * Returns a memory layout with the same size and name as this layout,\n+     * Returns a memory layout of the same type with the same size and name as this layout,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -661,2 +661,1 @@\n-    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder())\n-            .withBitAlignment(ValueLayout.ADDRESS_SIZE_BITS);\n+    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder());\n@@ -672,1 +671,1 @@\n-    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder()).withBitAlignment(8);\n+    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder());\n@@ -682,1 +681,1 @@\n-    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder()).withBitAlignment(8);\n+    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder());\n@@ -692,1 +691,1 @@\n-    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder()).withBitAlignment(16);\n+    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder());\n@@ -702,1 +701,1 @@\n-    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder()).withBitAlignment(16);\n+    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder());\n@@ -712,1 +711,1 @@\n-    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder()).withBitAlignment(32);\n+    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder());\n@@ -722,2 +721,1 @@\n-    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder())\n-            .withBitAlignment(64);\n+    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder());\n@@ -733,1 +731,1 @@\n-    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder()).withBitAlignment(32);\n+    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder());\n@@ -743,1 +741,124 @@\n-    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder()).withBitAlignment(64);\n+    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder());\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(MemorySegment.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfAddress ADDRESS_UNALIGNED = unaligned(ADDRESS);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code byte},\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfByte JAVA_BYTE_UNALIGNED = unaligned(JAVA_BYTE);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code boolean}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfBoolean JAVA_BOOLEAN_UNALIGNED = unaligned(JAVA_BOOLEAN);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code char}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfChar JAVA_CHAR_UNALIGNED = unaligned(JAVA_CHAR);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code short}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfShort JAVA_SHORT_UNALIGNED = unaligned(JAVA_SHORT);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code int}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfInt JAVA_INT_UNALIGNED = unaligned(JAVA_INT);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code long}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfLong JAVA_LONG_UNALIGNED = unaligned(JAVA_LONG);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code float}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfFloat JAVA_FLOAT_UNALIGNED = unaligned(JAVA_FLOAT);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code double}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder())\n+     *             .withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfDouble JAVA_DOUBLE_UNALIGNED = unaligned(JAVA_DOUBLE);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T extends MemoryLayout> T unaligned(T layout) {\n+        return (T) layout.withBitAlignment(8);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":132,"deletions":11,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestLayouts\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import jdk.internal.misc.Unsafe;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+public class TestValueLayouts {\n+\n+    @Test\n+    public void testByte() {\n+        testAligned(JAVA_INT, int.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testByteUnaligned() {\n+        testUnaligned(JAVA_INT_UNALIGNED, int.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testBoolean() {\n+        testAligned(JAVA_BOOLEAN, boolean.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testBooleanUnaligned() {\n+        testUnaligned(JAVA_BOOLEAN_UNALIGNED, boolean.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testShort() {\n+        testAligned(JAVA_SHORT, short.class, Short.SIZE);\n+    }\n+\n+    @Test\n+    public void testShortUnaligned() {\n+        testUnaligned(JAVA_SHORT_UNALIGNED, short.class, Short.SIZE);\n+    }\n+\n+    @Test\n+    public void testInt() {\n+        testAligned(JAVA_INT, int.class, Integer.SIZE);\n+    }\n+\n+    @Test\n+    public void testIntUnaligned() {\n+        testUnaligned(JAVA_INT_UNALIGNED, int.class, Integer.SIZE);\n+    }\n+\n+    @Test\n+    public void testLong() {\n+        testAligned(JAVA_LONG, long.class, Long.SIZE);\n+    }\n+\n+    @Test\n+    public void testIntUnaligned() {\n+        testUnaligned(JAVA_LONG_UNALIGNED, long.class, Long.SIZE);\n+    }\n+\n+    @Test\n+    public void testFloat() {\n+        testAligned(JAVA_FLOAT, float.class, Float.SIZE);\n+    }\n+\n+    @Test\n+    public void testFloatUnaligned() {\n+        testUnaligned(JAVA_FLOAT_UNALIGNED, float.class, Float.SIZE);\n+    }\n+\n+    @Test\n+    public void testDouble() {\n+        testAligned(JAVA_DOUBLE, double.class, Double.SIZE);\n+    }\n+\n+    @Test\n+    public void testFloatUnaligned() {\n+        testUnaligned(JAVA_DOUBLE_UNALIGNED, double.class, Double.SIZE);\n+    }\n+\n+    @Test\n+    public void testChar() {\n+        testAligned(JAVA_CHAR, char.class, Character.SIZE);\n+    }\n+\n+    @Test\n+    public void testCharUnaligned() {\n+        testUnaligned(JAVA_CHAR_UNALIGNED, char.class, Character.SIZE);\n+    }\n+\n+    @Test\n+    public void testAddress() {\n+        testAligned(ADDRESS, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+    }\n+\n+    @Test\n+    public void testCharUnaligned() {\n+        testUnaligned(ADDRESS_UNALIGNED, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+    }\n+\n+\n+    void testAligned(ValueLayout layout,\n+                     Class<?> carrier,\n+                     long bitSize) {\n+        test(layout, carrier, bitSize, bitSize);\n+    }\n+\n+    void testUnaligned(ValueLayout layout,\n+                       Class<?> carrier,\n+                       long bitSize) {\n+        test(layout, carrier, bitSize, Byte.SIZE);\n+    }\n+\n+    void test(ValueLayout layout,\n+              Class<?> carrier,\n+              long bitSize,\n+              long bitAlignment) {\n+        assertEquals(layout.carrier(), carrier);\n+        assertEquals(layout.bitSize(), bitSize);\n+        assertEquals(layout.order(), ByteOrder.nativeOrder());\n+        assertEquals(layout.bitAlignment(), bitAlignment);\n+        assertTrue(layout.name().isEmpty());\n+        assertEquals(layout.byteSize(), layout.bitSize() * 8);\n+        assertEquals(layout.byteAlignment(), layout.bitAlignment() * 8);\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}