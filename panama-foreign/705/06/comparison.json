{"files":[{"patch":"@@ -188,1 +188,1 @@\n-     * Returns a memory layout with the same size and alignment constraints as this layout,\n+     * Returns a memory layout of the same type with the same size and alignment constraints as this layout,\n@@ -238,1 +238,1 @@\n-     * Returns a memory layout with the same size and name as this layout,\n+     * Returns a memory layout of the same type with the same size and name as this layout,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -661,2 +661,1 @@\n-    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder())\n-            .withBitAlignment(ValueLayout.ADDRESS_SIZE_BITS);\n+    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder());\n@@ -672,1 +671,1 @@\n-    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder()).withBitAlignment(8);\n+    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder());\n@@ -682,1 +681,1 @@\n-    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder()).withBitAlignment(8);\n+    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder());\n@@ -692,1 +691,1 @@\n-    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder()).withBitAlignment(16);\n+    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder());\n@@ -702,1 +701,1 @@\n-    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder()).withBitAlignment(16);\n+    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder());\n@@ -712,1 +711,1 @@\n-    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder()).withBitAlignment(32);\n+    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder());\n@@ -722,2 +721,1 @@\n-    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder())\n-            .withBitAlignment(64);\n+    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder());\n@@ -733,1 +731,1 @@\n-    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder()).withBitAlignment(32);\n+    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder());\n@@ -743,1 +741,86 @@\n-    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder()).withBitAlignment(64);\n+    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder());\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a machine address ({@code size_t}),\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * ADDRESS.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code char}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_CHAR.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code short}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_SHORT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code int}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_INT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code long}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_LONG.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code float}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_FLOAT.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n+\n+    \/**\n+     * An unaligned value layout constant whose size is the same as that of a Java {@code double}\n+     * and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * JAVA_DOUBLE.withBitAlignment(8);\n+     * }\n+     * @apiNote Care should be taken when using unaligned value layouts as they may induce\n+     *          performance and portability issues.\n+     *\/\n+    public static final OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":94,"deletions":11,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -730,1 +730,1 @@\n-        emitGetStatic(BindingSpecializer.Runtime.class, valueLayoutConstantName, valueLayoutType.descriptorString());\n+        emitGetStatic(ValueLayout.class, valueLayoutConstantName, valueLayoutType.descriptorString());\n@@ -736,1 +736,1 @@\n-            return \"JAVA_BOOLEAN_UNALIGNED\";\n+            return \"JAVA_BOOLEAN\";\n@@ -738,1 +738,1 @@\n-            return \"JAVA_BYTE_UNALIGNED\";\n+            return \"JAVA_BYTE\";\n@@ -920,18 +920,0 @@\n-    \/\/ constants that are accessed from the generated bytecode\n-    \/\/ see emitLoadLayoutConstant\n-    static final class Runtime {\n-\n-        private Runtime() {\n-        }\n-\n-        \/\/ unaligned constants\n-        static final ValueLayout.OfBoolean JAVA_BOOLEAN_UNALIGNED = JAVA_BOOLEAN;\n-        static final ValueLayout.OfByte JAVA_BYTE_UNALIGNED = JAVA_BYTE;\n-        static final ValueLayout.OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n-        static final ValueLayout.OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n-        static final ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-        static final ValueLayout.OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n-        static final ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-        static final ValueLayout.OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n-        static final ValueLayout.OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -510,8 +510,0 @@\n-    \/\/ unaligned constants\n-    public final static ValueLayout.OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n-    public final static ValueLayout.OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n-    public final static ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-    public final static ValueLayout.OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n-    public final static ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-    public final static ValueLayout.OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,8 +38,1 @@\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_BOOLEAN;\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -100,8 +93,0 @@\n-    \/\/ unaligned constants\n-    public final static ValueLayout.OfShort JAVA_SHORT_UNALIGNED = JAVA_SHORT.withBitAlignment(8);\n-    public final static ValueLayout.OfChar JAVA_CHAR_UNALIGNED = JAVA_CHAR.withBitAlignment(8);\n-    public final static ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-    public final static ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-    public final static ValueLayout.OfDouble JAVA_DOUBLE_UNALIGNED = JAVA_DOUBLE.withBitAlignment(8);\n-    public final static ValueLayout.OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n-\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ * @run testng TestValueLayouts\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.*;\n+import java.nio.ByteOrder;\n+import jdk.internal.misc.Unsafe;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n+\n+public class TestValueLayouts {\n+\n+    @Test\n+    public void testByte() {\n+        testAligned(JAVA_BYTE, byte.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testBoolean() {\n+        testAligned(JAVA_BOOLEAN, boolean.class, Byte.SIZE);\n+    }\n+\n+    @Test\n+    public void testShort() {\n+        testAligned(JAVA_SHORT, short.class, Short.SIZE);\n+    }\n+\n+    @Test\n+    public void testShortUnaligned() {\n+        testUnaligned(JAVA_SHORT_UNALIGNED, short.class, Short.SIZE);\n+    }\n+\n+    @Test\n+    public void testInt() {\n+        testAligned(JAVA_INT, int.class, Integer.SIZE);\n+    }\n+\n+    @Test\n+    public void testIntUnaligned() {\n+        testUnaligned(JAVA_INT_UNALIGNED, int.class, Integer.SIZE);\n+    }\n+\n+    @Test\n+    public void testLong() {\n+        testAligned(JAVA_LONG, long.class, Long.SIZE);\n+    }\n+\n+    @Test\n+    public void testLongUnaligned() {\n+        testUnaligned(JAVA_LONG_UNALIGNED, long.class, Long.SIZE);\n+    }\n+\n+    @Test\n+    public void testFloat() {\n+        testAligned(JAVA_FLOAT, float.class, Float.SIZE);\n+    }\n+\n+    @Test\n+    public void testFloatUnaligned() {\n+        testUnaligned(JAVA_FLOAT_UNALIGNED, float.class, Float.SIZE);\n+    }\n+\n+    @Test\n+    public void testDouble() {\n+        testAligned(JAVA_DOUBLE, double.class, Double.SIZE);\n+    }\n+\n+    @Test\n+    public void testDoubleUnaligned() {\n+        testUnaligned(JAVA_DOUBLE_UNALIGNED, double.class, Double.SIZE);\n+    }\n+\n+    @Test\n+    public void testChar() {\n+        testAligned(JAVA_CHAR, char.class, Character.SIZE);\n+    }\n+\n+    @Test\n+    public void testCharUnaligned() {\n+        testUnaligned(JAVA_CHAR_UNALIGNED, char.class, Character.SIZE);\n+    }\n+\n+    @Test\n+    public void testAddress() {\n+        testAligned(ADDRESS, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+    }\n+\n+    @Test\n+    public void testAddressUnaligned() {\n+        testUnaligned(ADDRESS_UNALIGNED, MemorySegment.class, Unsafe.ADDRESS_SIZE * 8L);\n+    }\n+\n+    void testAligned(ValueLayout layout,\n+                     Class<?> carrier,\n+                     long bitSize) {\n+        test(layout, carrier, bitSize, bitSize);\n+    }\n+\n+    void testUnaligned(ValueLayout layout,\n+                       Class<?> carrier,\n+                       long bitSize) {\n+        test(layout, carrier, bitSize, Byte.SIZE);\n+    }\n+\n+    void test(ValueLayout layout,\n+              Class<?> carrier,\n+              long bitSize,\n+              long bitAlignment) {\n+        assertEquals(layout.carrier(), carrier);\n+        assertEquals(layout.bitSize(), bitSize);\n+        assertEquals(layout.order(), ByteOrder.nativeOrder());\n+        assertEquals(layout.bitAlignment(), bitAlignment);\n+        assertTrue(layout.name().isEmpty());\n+        assertEquals(layout.byteSize(), layout.bitSize() \/ 8);\n+        assertEquals(layout.byteAlignment(), layout.bitAlignment() \/ 8);\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestValueLayouts.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -29,3 +29,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -37,5 +35,0 @@\n-    static final ValueLayout.OfInt JAVA_INT_UNALIGNED = JAVA_INT.withBitAlignment(8);\n-\n-    static final ValueLayout.OfFloat JAVA_FLOAT_UNALIGNED = JAVA_FLOAT.withBitAlignment(8);\n-\n-    static final ValueLayout.OfLong JAVA_LONG_UNALIGNED = JAVA_LONG.withBitAlignment(8);\n@@ -47,7 +40,0 @@\n-    static final VarHandle VH_FLOAT_UNALIGNED = JAVA_FLOAT_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_FLOAT = JAVA_FLOAT.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n-\n-    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNewHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,4 +44,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_FLOAT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.*;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -34,1 +35,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -46,0 +47,4 @@\n+    static final VarHandle VH_LONG_UNALIGNED = JAVA_LONG_UNALIGNED.arrayElementVarHandle();\n+\n+    static final VarHandle VH_LONG = JAVA_LONG.arrayElementVarHandle();\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}