{"files":[{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.Stream;\n@@ -52,0 +53,5 @@\n+    static final List<MemoryLayout> STACK_PREFIX_LAYOUTS = Stream.concat(\n+            Stream.generate(() -> (MemoryLayout) C_LONG_LONG).limit(8),\n+            Stream.generate(() -> (MemoryLayout)  C_DOUBLE).limit(8)\n+        ).toList();\n+\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -39,0 +38,1 @@\n+import jdk.incubator.foreign.GroupLayout;\n@@ -42,1 +42,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -46,1 +45,0 @@\n-import java.lang.invoke.MethodType;\n@@ -50,0 +48,1 @@\n+import java.util.stream.Stream;\n@@ -61,0 +60,1 @@\n+        System.loadLibrary(\"TestDowncallStack\");\n@@ -69,1 +69,0 @@\n-        MethodType mt = methodType(ret, paramTypes, fields);\n@@ -73,1 +72,23 @@\n-            boolean needsScope = mt.returnType().equals(MemorySegment.class);\n+            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(scope) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n+            if (ret == Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment) res).scope(), scope);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncallStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        FunctionDescriptor descriptor = functionStack(ret, paramTypes, fields);\n+        Object[] args = makeArgsStack(paramTypes, fields, checks);\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n@@ -94,7 +115,2 @@\n-    static MethodType methodType(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        MethodType mt = ret == Ret.VOID ?\n-                MethodType.methodType(void.class) : MethodType.methodType(carrier(params.get(0).layout(fields), false));\n-        for (ParamType p : params) {\n-            mt = mt.appendParameterTypes(carrier(p.layout(fields), true));\n-        }\n-        return mt;\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n@@ -104,1 +120,6 @@\n-        MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n+        List<MemoryLayout> pLayouts = params.stream().map(p -> p.layout(fields)).toList();\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), pLayouts.stream()).toArray(MemoryLayout[]::new);\n@@ -107,1 +128,5 @@\n-                FunctionDescriptor.of(paramLayouts[0], paramLayouts);\n+                FunctionDescriptor.of(paramLayouts[prefix.size()], paramLayouts);\n+    }\n+\n+    static Object[] makeArgsStack(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n+        return makeArgs(params, fields, checks, STACK_PREFIX_LAYOUTS);\n@@ -111,1 +136,9 @@\n-        Object[] args = new Object[params.size()];\n+        return makeArgs(params, fields, checks, List.of());\n+    }\n+\n+    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size()];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n@@ -113,1 +146,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":49,"deletions":16,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestDowncallStack\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   TestDowncallStack\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.GroupLayout;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.SymbolLookup;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestDowncallStack extends CallGeneratorHelper {\n-\n-    static CLinker abi = CLinker.systemCLinker();\n-    static {\n-        System.loadLibrary(\"TestDowncallStack\");\n-    }\n-\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testDowncall(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<Consumer<Object>> checks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n-        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n-        Object[] args = makeArgs(paramTypes, fields, checks);\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            boolean needsScope = descriptor.returnLayout().map(l -> l instanceof GroupLayout).orElse(false);\n-            SegmentAllocator allocator = needsScope ?\n-                    SegmentAllocator.newNativeArena(scope) :\n-                    THROWING_ALLOCATOR;\n-            Object res = doCall(addr, allocator, descriptor, args);\n-            if (ret == Ret.NON_VOID) {\n-                checks.forEach(c -> c.accept(res));\n-                if (needsScope) {\n-                    \/\/ check that return struct has indeed been allocated in the native scope\n-                    assertEquals(((MemorySegment) res).scope(), scope);\n-                }\n-            }\n-        }\n-    }\n-\n-    Object doCall(NativeSymbol addr, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n-        MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n-        Object res = mh.invokeWithArguments(args);\n-        return res;\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        Stream<MemoryLayout> prefixLongs = Stream.generate(() -> (MemoryLayout) C_LONG_LONG).limit(8);\n-        Stream<MemoryLayout> prefixDoubles = Stream.generate(() -> (MemoryLayout)  C_DOUBLE).limit(8);\n-        Stream<MemoryLayout> prefix = Stream.concat(prefixLongs, prefixDoubles);\n-        List<MemoryLayout> pLayouts = params.stream().map(p -> p.layout(fields)).toList();\n-        MemoryLayout[] paramLayouts = Stream.concat(prefix, pLayouts.stream()).toArray(MemoryLayout[]::new);\n-        return ret == Ret.VOID ?\n-                FunctionDescriptor.ofVoid(paramLayouts) :\n-                FunctionDescriptor.of(pLayouts.get(0), paramLayouts);\n-    }\n-\n-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n-        Object[] args = new Object[16 + params.size()];\n-        int argNum = 0;\n-        for (int i = 0; i < 8; i++) {\n-            args[argNum++] = makeArg(C_LONG_LONG, null, false);\n-        }\n-        for (int i = 0; i < 8; i++) {\n-            args[argNum++] = makeArg(C_DOUBLE, null, false);\n-        }\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n-        }\n-        return args;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -38,1 +38,1 @@\n- * @test id=no_scope\n+ * @test id=async\n@@ -45,1 +45,1 @@\n- *   -DUPCALL_TEST_TYPE=NO_SCOPE\n+ *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -50,1 +50,1 @@\n- * @test id=async\n+ * @test id=stack\n@@ -57,1 +57,1 @@\n- *   -DUPCALL_TEST_TYPE=ASYNC\n+ *   -DUPCALL_TEST_TYPE=STACK\n@@ -86,0 +86,1 @@\n+import java.util.stream.Stream;\n@@ -90,1 +91,0 @@\n-\n@@ -95,2 +95,2 @@\n-        NO_SCOPE,\n-        ASYNC\n+        ASYNC,\n+        STACK\n@@ -103,0 +103,1 @@\n+        System.loadLibrary(\"TestUpcallStack\");\n@@ -116,1 +117,1 @@\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n@@ -131,1 +132,1 @@\n-            return;\/\/throw new SkipException(\"Skipping tests that were not selected\");\n+            throw new SkipException(\"Skipping tests that were not selected\");\n@@ -157,0 +158,1 @@\n+\n@@ -185,0 +187,20 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.STACK);\n+\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, functionStack(ret, paramTypes, fields));\n+            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n@@ -191,3 +213,3 @@\n-                abi.downcallHandle(\n-                    LOOKUP.lookup(symbol).orElseThrow(),\n-                        FunctionDescriptor.ofVoid(C_POINTER)));\n+                    abi.downcallHandle(\n+                            LOOKUP.lookup(symbol).orElseThrow(),\n+                            FunctionDescriptor.ofVoid(C_POINTER)));\n@@ -208,0 +230,4 @@\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n+    }\n+\n@@ -209,0 +235,4 @@\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n@@ -211,1 +241,1 @@\n-        MemoryLayout[] layouts = paramLayouts.toArray(new MemoryLayout[0]);\n+        MemoryLayout[] layouts = Stream.concat(prefix.stream(), paramLayouts.stream()).toArray(MemoryLayout[]::new);\n@@ -214,1 +244,5 @@\n-                FunctionDescriptor.of(layouts[0], layouts);\n+                FunctionDescriptor.of(layouts[prefix.size()], layouts);\n+    }\n+\n+    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n@@ -218,1 +252,9 @@\n-        Object[] args = new Object[params.size() + 1];\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size() + 1];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n@@ -220,1 +262,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n@@ -222,1 +264,1 @@\n-        args[params.size()] = makeCallback(scope, ret, params, fields, checks, argChecks);\n+        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n@@ -226,2 +268,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -233,2 +274,6 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n-        mh = mh.asCollector(Object[].class, params.size());\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n+        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n+\n+        for(int i = 0; i < prefix.size(); i++) {\n+            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n+        }\n@@ -240,1 +285,1 @@\n-            mh = mh.asType(mh.type().changeParameterType(i, carrier));\n+            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n@@ -242,1 +287,1 @@\n-            final int finalI = i;\n+            final int finalI = prefix.size() + i;\n@@ -255,1 +300,1 @@\n-            checks.add(o -> assertStructEquals((MemorySegment) box.get()[0], (MemorySegment) o, firstlayout));\n+            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n@@ -257,1 +302,1 @@\n-            checks.add(o -> assertEquals(o, box.get()[0]));\n+            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n@@ -262,1 +307,1 @@\n-        MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n@@ -269,1 +314,1 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n@@ -279,1 +324,1 @@\n-        return o[0];\n+        return o[retArg];\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":73,"deletions":28,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1,203 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test id=scope\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallStack\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   TestUpcallStack\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.SymbolLookup;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.lang.invoke.MethodHandles.insertArguments;\n-import static org.testng.Assert.assertEquals;\n-\n-\n-public class TestUpcallStack extends CallGeneratorHelper {\n-\n-    static {\n-        System.loadLibrary(\"TestUpcallStack\");\n-    }\n-    static CLinker abi = CLinker.systemCLinker();\n-\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n-    static MethodHandle DUMMY;\n-    static MethodHandle PASS_AND_SAVE;\n-\n-    static {\n-        try {\n-            DUMMY = MethodHandles.lookup().findStatic(TestUpcallStack.class, \"dummy\", MethodType.methodType(void.class));\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcallStack.class, \"passAndSave\",\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n-        } catch (Throwable ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    static NativeSymbol dummyStub;\n-\n-    @BeforeClass\n-    void setup() {\n-        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newSharedScope());\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcalls(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n-            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n-            Object[] callArgs = args;\n-            Object res = mh.invokeWithArguments(callArgs);\n-            argChecks.forEach(c -> c.accept(args));\n-            if (ret == Ret.NON_VOID) {\n-                returnChecks.forEach(c -> c.accept(res));\n-            }\n-        }\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        Stream<MemoryLayout> prefixLongs = Stream.generate(() -> (MemoryLayout) C_LONG_LONG).limit(8);\n-        Stream<MemoryLayout> prefixDoubles = Stream.generate(() -> (MemoryLayout)  C_DOUBLE).limit(8);\n-        Stream<MemoryLayout> prefix = Stream.concat(prefixLongs, prefixDoubles);\n-        List<MemoryLayout> paramLayouts = params.stream().map(p -> p.layout(fields)).collect(Collectors.toList());\n-        paramLayouts.add(C_POINTER); \/\/ the callback\n-        MemoryLayout[] layouts = Stream.concat(prefix, paramLayouts.stream()).toArray(MemoryLayout[]::new);\n-        return ret == Ret.VOID ?\n-                FunctionDescriptor.ofVoid(layouts) :\n-                FunctionDescriptor.of(layouts[16], layouts);\n-    }\n-\n-    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        Object[] args = new Object[16 + params.size() + 1];\n-        int argNum = 0;\n-        for (int i = 0; i < 8; i++) {\n-            args[argNum++] = makeArg(C_LONG_LONG, null, false);\n-        }\n-        for (int i = 0; i < 8; i++) {\n-            args[argNum++] = makeArg(C_DOUBLE, null, false);\n-        }\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n-        }\n-        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks);\n-        return args;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n-        if (params.isEmpty()) {\n-            return dummyStub;\n-        }\n-\n-        AtomicReference<Object[]> box = new AtomicReference<>();\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n-        mh = mh.asCollector(Object[].class, 16 + params.size());\n-\n-        for(int i = 0; i < 8; i++) {\n-            mh = mh.asType(mh.type().changeParameterType(i, long.class));\n-        }\n-        for(int i = 0; i < 8; i++) {\n-            mh = mh.asType(mh.type().changeParameterType(8 + i, double.class));\n-        }\n-        for (int i = 0; i < params.size(); i++) {\n-            ParamType pt = params.get(i);\n-            MemoryLayout layout = pt.layout(fields);\n-            Class<?> carrier = carrier(layout, false);\n-            mh = mh.asType(mh.type().changeParameterType(16 + i, carrier));\n-\n-            final int finalI = 16 + i;\n-            if (carrier == MemorySegment.class) {\n-                argChecks.add(o -> assertStructEquals((MemorySegment) box.get()[finalI], (MemorySegment) o[finalI], layout));\n-            } else {\n-                argChecks.add(o -> assertEquals(box.get()[finalI], o[finalI]));\n-            }\n-        }\n-\n-        ParamType firstParam = params.get(0);\n-        MemoryLayout firstlayout = firstParam.layout(fields);\n-        Class<?> firstCarrier = carrier(firstlayout, true);\n-\n-        if (firstCarrier == MemorySegment.class) {\n-            checks.add(o -> assertStructEquals((MemorySegment) box.get()[16], (MemorySegment) o, firstlayout));\n-        } else {\n-            checks.add(o -> assertEquals(o, box.get()[16]));\n-        }\n-\n-        mh = mh.asType(mh.type().changeReturnType(ret == Ret.VOID ? void.class : firstCarrier));\n-\n-        Stream<MemoryLayout> prefixLongs = Stream.generate(() -> (MemoryLayout) C_LONG_LONG).limit(8);\n-        Stream<MemoryLayout> prefixDoubles = Stream.generate(() -> (MemoryLayout)  C_DOUBLE).limit(8);\n-        Stream<MemoryLayout> prefix = Stream.concat(prefixLongs, prefixDoubles);\n-        MemoryLayout[] paramLayouts = Stream.concat(prefix, params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n-        FunctionDescriptor func = ret != Ret.VOID\n-                ? FunctionDescriptor.of(firstlayout, paramLayouts)\n-                : FunctionDescriptor.ofVoid(paramLayouts);\n-        return abi.upcallStub(mh, func, scope);\n-    }\n-\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n-        for (int i = 0; i < o.length; i++) {\n-            if (o[i] instanceof MemorySegment) {\n-                MemorySegment ms = (MemorySegment) o[i];\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newSharedScope());\n-                copy.copyFrom(ms);\n-                o[i] = copy;\n-            }\n-        }\n-        ref.set(o);\n-        return o[16];\n-    }\n-\n-    static void dummy() {\n-        \/\/do nothing\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":0,"deletions":203,"binary":false,"changes":203,"status":"deleted"}]}