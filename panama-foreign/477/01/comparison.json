{"files":[{"patch":"@@ -385,2 +385,3 @@\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n-     * <em>static<\/em> stride constants which are derived from the layout path.\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n@@ -436,2 +437,3 @@\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n-     * <em>static<\/em> stride constants which are derived from the layout path.\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n@@ -473,3 +475,4 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as optional {@code long}\n-     * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n-     * <em>static<\/em> stride constants which are derived from the layout path.\n+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n@@ -496,0 +499,44 @@\n+    \/**\n+     * Creates a method handle which, given a memory segment, returns a {@link MemorySegment#asSlice(long,long)}\n+     * corresponding to the layout selected by a given layout path, where the path is considered rooted in this layout.\n+     *\n+     * <p>The returned method handle has a return type of {@code MemorySegment}, features a {@code MemorySegment}\n+     * parameter as leading parameter representing the segment to be sliced, and features as many trailing {@code long}\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * where the order of the parameters corresponds to the order of the path elements.\n+     * The returned method handle can be used to create a slice similar to using {@link MemorySegment#asSlice(long, long)},\n+     * but where the offset argument is dynamically compute based on indices specified when invoking the method handle.\n+     *\n+     * <p>The offset of the returned segment is computed as follows:\n+     *\n+     * <blockquote><pre>{@code\n+    bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+    offset = bitOffset \/ 8\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n+     *\n+     * <p>After the offset is computed, the returned segment is create as if by calling:\n+     * <blockquote><pre>{@code\n+    segment.asSlice(offset, layout.byteSize());\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code segment} is the segment to be sliced, and where {@code layout} is the layout selected by the given\n+     * layout path, as per {@link MemoryLayout#select(PathElement...)}.\n+     *\n+     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n+     * offset in bits is not a multiple of 8.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a method handle which can be used to create a slice of the selected layout element, given a segment.\n+     * @throws UnsupportedOperationException if the size of the selected layout in bits is not a multiple of 8.\n+     *\/\n+    default MethodHandle sliceHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::sliceHandle,\n+                Set.of(), elements);\n+    }\n+\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":54,"deletions":7,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    private static final MethodHandle MH_SLICE;\n@@ -75,0 +76,2 @@\n+            MH_SLICE = lookup.findVirtual(MemorySegment.class, \"asSlice\",\n+                    MethodType.methodType(MemorySegment.class, long.class, long.class));\n@@ -203,0 +206,16 @@\n+    public MethodHandle sliceHandle() {\n+        if (strides.length == 0) {\n+            \/\/ trigger checks eagerly\n+            Utils.bitsToBytesOrThrow(offset, Utils.bitsToBytesThrowOffset);\n+        }\n+\n+        MethodHandle offsetHandle = offsetHandle(); \/\/ bit offset\n+        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_bitsToBytesOrThrowForOffset); \/\/ byte offset\n+\n+        MethodHandle sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n+        sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle); \/\/ (MS, ...) -> MS\n+\n+        return sliceHandle;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -36,0 +38,1 @@\n+import org.testng.SkipException;\n@@ -39,0 +42,1 @@\n+import java.nio.ByteOrder;\n@@ -401,1 +405,1 @@\n-    @Test(dataProvider =  \"offsetHandleCases\")\n+    @Test(dataProvider = \"testLayouts\")\n@@ -417,1 +421,1 @@\n-    public static Object[][] offsetHandleCases() {\n+    public static Object[][] testLayouts() {\n@@ -492,0 +496,68 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testSliceHandle(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                long expectedBitOffset) throws Throwable {\n+        if (expectedBitOffset % 8 != 0)\n+            throw new SkipException(\"Offset not a multiple of 8\");\n+\n+        MemoryLayout selected = layout.select(pathElements);\n+        MethodHandle sliceHandle = layout.sliceHandle(pathElements);\n+        sliceHandle = sliceHandle.asSpreader(long[].class, indexes.length);\n+\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, indexes);\n+            assertEquals(slice.address().segmentOffset(segment), expectedBitOffset \/ 8);\n+            assertEquals(slice.byteSize(), selected.byteSize());\n+        }\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testSliceHandleUOEInvalidSize() {\n+        MemoryLayout layout = MemoryLayout.ofStruct(\n+            MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()).withName(\"x\"),\n+            MemoryLayout.ofValueBits(31, ByteOrder.nativeOrder()).withName(\"y\") \/\/ size not a multiple of 8\n+        );\n+\n+        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testSliceHandleUOEInvalidOffsetEager() throws Throwable {\n+        MemoryLayout layout = MemoryLayout.ofStruct(\n+            MemoryLayout.ofPaddingBits(5),\n+            MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+        );\n+\n+        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testSliceHandleUOEInvalidOffsetLate() throws Throwable {\n+        MemoryLayout layout = MemoryLayout.ofSequence(3,\n+            MemoryLayout.ofStruct(\n+                MemoryLayout.ofPaddingBits(4),\n+                MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+            )\n+        );\n+\n+        MethodHandle sliceHandle;\n+        try {\n+            sliceHandle = layout.sliceHandle(sequenceElement(), groupElement(\"y\")); \/\/ should work\n+        } catch (UnsupportedOperationException uoe) {\n+            fail(\"Unexpected exception\", uoe);\n+            return;\n+        }\n+\n+        try (ResourceScope scope = ResourceScope.ofConfined()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+\n+            try {\n+                sliceHandle.invokeExact(segment, 1); \/\/ should work\n+            } catch (UnsupportedOperationException uoe) {\n+                fail(\"Unexpected exception\", uoe);\n+                return;\n+            }\n+\n+            sliceHandle.invokeExact(segment, 0); \/\/ should throw\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"}]}