{"files":[{"patch":"@@ -91,1 +91,1 @@\n-     * bounds, and can therefore be closed. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators),\n+     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n@@ -101,0 +101,5 @@\n+     * Equivalent to the following code:\n+     * <pre>{@code\n+    asSegmentRestricted(byteSize, null);\n+     * }<\/pre>\n+     * <p>\n@@ -105,0 +110,2 @@\n+     * @see #asSegmentRestricted(long, Object)\n+     *\n@@ -113,0 +120,30 @@\n+        return asSegmentRestricted(bytesSize, null);\n+    }\n+\n+    \/**\n+     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n+     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from native code\n+     * (often as a plain {@code long} value). The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * Moreover, the returned segment will keep a strong reference to the supplied attachment object, which can\n+     * be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n+     * <p>\n+     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n+     * memory resources which might implicitly be associated with the segment. If the client wants to specify\n+     * a cleanup action to be executed when the returned segment is closed, the {@link MemorySegment#withCleanupAction(Runnable)}\n+     * method should be used.\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param bytesSize the desired size.\n+     * @param attachment an attachment object that will be kept strongly reachable by the returned segment; can be {@code null}.\n+     * @return a new confined native memory segment with given base address and size.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     *\/\n+    default MemorySegment asSegmentRestricted(long bytesSize, Object attachment) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -323,0 +323,5 @@\n+     *\n+     * @see #asSlice(long)\n+     * @see #asSlice(MemoryAddress)\n+     * @see #asSlice(MemoryAddress, long)\n+     *\n@@ -330,0 +335,23 @@\n+    \/**\n+     * Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.\n+     * <p>\n+     * Equivalent to the following code:\n+     * <pre>{@code\n+    asSlice(newBase.segmentOffset(this), newSize);\n+     * }<\/pre>\n+     *\n+     * @see #asSlice(long)\n+     * @see #asSlice(MemoryAddress)\n+     * @see #asSlice(long, long)\n+     *\n+     * @param newBase The new segment base address.\n+     * @param newSize The new segment size, specified in bytes.\n+     * @return a new memory segment view with updated base\/limit addresses.\n+     * @throws NullPointerException if {@code newBase == null}.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n+     *\/\n+    default MemorySegment asSlice(MemoryAddress newBase, long newSize) {\n+        Objects.requireNonNull(newBase);\n+        return asSlice(newBase.segmentOffset(this), newSize);\n+    }\n+\n@@ -333,0 +361,10 @@\n+     * <p>\n+     * Equivalent to the following code:\n+     * <pre>{@code\n+    asSlice(offset, byteSize() - offset);\n+     * }<\/pre>\n+     *\n+     * @see #asSlice(MemoryAddress)\n+     * @see #asSlice(MemoryAddress, long)\n+     * @see #asSlice(long, long)\n+     *\n@@ -337,1 +375,3 @@\n-    MemorySegment asSlice(long offset);\n+    default MemorySegment asSlice(long offset) {\n+        return asSlice(offset, byteSize() - offset);\n+    }\n@@ -340,4 +380,13 @@\n-     * Obtains a new memory segment view whose base address is the address passed as argument,\n-     * and whose new size is computed by subtracting the address offset relative to this segment\n-     * (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.\n-     * @param address The new segment base offset (relative to the current segment base address), specified in bytes.\n+     * Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting\n+     * the address offset relative to this segment (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.\n+     * <p>\n+     * Equivalent to the following code:\n+     * <pre>{@code\n+    asSlice(newBase.segmentOffset(this));\n+     * }<\/pre>\n+     *\n+     * @see #asSlice(long)\n+     * @see #asSlice(MemoryAddress, long)\n+     * @see #asSlice(long, long)\n+     *\n+     * @param newBase The new segment base offset (relative to the current segment base address), specified in bytes.\n@@ -345,0 +394,1 @@\n+     * @throws NullPointerException if {@code newBase == null}.\n@@ -347,2 +397,3 @@\n-    default MemorySegment asSlice(MemoryAddress address) {\n-        return asSlice(address.segmentOffset(this));\n+    default MemorySegment asSlice(MemoryAddress newBase) {\n+        Objects.requireNonNull(newBase);\n+        return asSlice(newBase.segmentOffset(this));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":58,"deletions":7,"binary":false,"changes":65,"status":"modified"}]}