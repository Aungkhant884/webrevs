{"files":[{"patch":"@@ -3,1 +3,1 @@\n-**May 2022**\n+**December 2022**\n@@ -7,1 +7,1 @@\n-Panama supports foreign functions through the Foreign Linker API, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). The central abstraction in the Foreign Linker API is the *foreign linker*, which allows clients to construct *downcall* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+The Foreign Function & Memory API (FFM API in short) provides access to foreign functions through the `Linker` interface, which has been available as an [incubating](https:\/\/openjdk.java.net\/jeps\/11) API since Java [16](https:\/\/openjdk.java.net\/jeps\/389). A linker allows clients to construct *downcall* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, FFM API's foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n@@ -9,1 +9,1 @@\n-### Native addresses\n+### Zero-length memory segments\n@@ -13,1 +13,1 @@\n-Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we often receive *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in our interop support are modeled using the `MemoryAddress` abstraction.\n+Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we often receive *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in the FFM API are modelled using *zero-length memory segments*.\n@@ -15,1 +15,1 @@\n-If clients want to dereference `MemoryAddress`, they can do so *unsafely* in two ways. First, they can use one of the *unsafe* dereference methods provided by `MemoryAddress` (these methods closely mirror those offered by `MemorySegment`); these methods are *restricted* and will generate runtime warnings if called without specifying the `--enable-native-access` command-line flag:\n+If clients want to dereference a zero-length memory segment, they can do so *unsafely* in two ways. First, the client can create a new memory segment from the zero-length memory segment *unsafely*, using the `MemorySegment::ofAddress` factory. This method is *restricted* and will generate runtime warnings if called without specifying the `--enable-native-access` command-line flag. By calling `MemorySegment::ofAddress` a client inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n@@ -18,3 +18,5 @@\n-...\n-MemoryAddress addr = ... \/\/obtain address from native code\n-int x = addr.get(JAVA_INT, 0);\n+MemorySegment raw = ... \/\/obtain address from native code\n+try (Arena arena = Arena.openConfined()) {\n+    MemorySegment segment = MemorySegment.ofAddress(raw.address(), 100, arena.scope());\n+    int x = segment.get(JAVA_INT, 0);\n+}\n@@ -23,1 +25,1 @@\n-Alternatively, the client can create a memory segment from an address *unsafely*, using the `MemorySegment::ofAddress` factory (which is also a *restricted* method); this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n+Alternatively, clients can obtain an *unbounded* address value layout. This is done using the `ValueLayout.OfAddress::asUnbounded` method (which is also a restricted method). When an access operation uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments with <em>maximal<\/em> size (i.e. `Long.MAX_VALUE`). As such, these segments can be accessed directly, as follows:\n@@ -26,5 +28,2 @@\n-MemoryAddress addr = ... \/\/obtain address from native code\n-try (MemorySession session = MemorySession openConfined()) {\n-\tMemorySegment segment = MemorySegment.ofAddress(100, session);\n-\tint x = segment.get(JAVA_INT, 0);\n-}\n+MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ wrap address into segment (size = Long.MAX_VALUE)\n+int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n@@ -33,2 +32,1 @@\n-Both `MemoryAddress` and `MemorySegment` implement the `Addressable` interface, which is an interface modelling entities that can be passed *by reference* — that is, which can be projected to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddress` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n-\n+Which approach is taken largely depends on the information that a client has available when obtaining a memory segment wrapping a native pointer. For instance, if such pointer points to a C struct, the client might prefer to resize the segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). In other instances, however, there will be no, or little information as to what spatial and\/or temporal bounds should be associated with a given native pointer. In these cases using an unbounded address layout might be preferable.\n@@ -46,2 +44,2 @@\n-try (MemorySession session = MemorySession openConfined()) {\n-    MemorySegment arr = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(5, JAVA_INT), session);\n+try (Arena arena = Arena openConfined()) {\n+    MemorySegment arr = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(5, JAVA_INT), arena.scope());\n@@ -60,1 +58,1 @@\n-To address these problems, Panama provides a `SegmentAllocator` abstraction, a functional interface which provides methods to allocate commonly used values. Since `MemorySession` implements the `SegmentAllocator` interface, the above code can be rewritten conveniently as follows:\n+To address these problems, the FFM API provides a `SegmentAllocator` abstraction, a functional interface which provides methods to allocate commonly used values. Since `Arena` implements the `SegmentAllocator` interface, the above code can be rewritten conveniently as follows:\n@@ -63,2 +61,2 @@\n-try (MemorySession session = MemorySession openConfined()) {    \n-    MemorySegment arr = session.allocateArray(JAVA_INT, 0, 1, 2, 3, 4);\n+try (Arena arena = Arena.openConfined()) {\n+    MemorySegment arr = arena.allocateArray(JAVA_INT, 0, 1, 2, 3, 4);\n@@ -68,1 +66,1 @@\n-In the above code, the memory session acts as a *native* allocator (that is, an allocator built on top of `MemorySegment::allocateNative`). The session is then used to create a native array, initialized to the values `0, 1, 2, 3, 4`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. The returned segment is associated with the session which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.\n+In the above code, the arena acts as a *native* allocator (that is, an allocator built on top of `MemorySegment::allocateNative`). The arena is then used to create a native array, initialized to the values `0, 1, 2, 3, 4`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. The returned segment is associated with the scope of the arena which performed the allocation, meaning that the segment will no longer be accessible after the try-with-resource construct.\n@@ -70,1 +68,1 @@\n-Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the `SegmentAllocator` interface. For instance, it is possible to create an arena-based allocator, as follows:\n+Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the `SegmentAllocator` interface. For example, the following code creates a *slicing* allocator and uses it to allocate a segment whose content is initialized from a Java `int` array:\n@@ -73,4 +71,5 @@\n-try (MemorySession session = MemorySession openConfined()) {\n-    SegmentAllocator allocator = SegmentAllocator.newNativeArena(session);\n-    for (int i = 0 ; i < 100 ; i++) {\n-        allocator.allocateArray(JAVA_INT, 0, 1, 2, 3, 4);\n+try (Arena arena = Arena.openConfined()) {\n+    SegmentAllocator allocator = SegmentAllocator.slicingAllocator(arena.allocate(1024));\n+    for (int i = 0 ; i < 10 ; i++) {\n+        MemorySegment s = allocator.allocateArray(JAVA_INT,  new int[] { 1, 2, 3, 4, 5 });\n+        ...\n@@ -79,1 +78,1 @@\n-} \/\/ all memory allocated is released here\n+ } \/\/ all memory allocated is released here\n@@ -82,1 +81,1 @@\n-The above code creates a confined session; inside the *try-with-resources*, a new unbounded arena allocation is created, associated with the existing session. The allocator will pre-allocate a native segment, of a specific size, and respond to allocation requests by returning different slices of the pre-allocated segment. If the pre-allocated segment does not have sufficient space to accommodate a new allocation request, a new segment will be allocated. If the session associated with the arena allocator is closed, all memory segments created by the allocator (see the body of the `for` loop) will be deallocated at once. This idiom combines the advantages of deterministic deallocation (provided by the Memory Access API) with a more flexible and scalable allocation scheme, and can be very useful when writing large applications.\n+This code creates a native segment whose size is 1024 bytes. The segment is then used to create a slicing allocator, which responds to  allocation requests by returning slices of that pre-allocated segment.  If the current segment does not have sufficient space to accommodate an  allocation request, an exception is thrown. All of the memory associated with the segments created by the allocator (i.e., in the body of the  for loop) is deallocated atomically when the arena is closed. This  technique combines the advantages of deterministic deallocation,  provided by the `Arena` abstraction, with a more flexible and scalable allocation scheme. It can be very useful when writing code  which manages a large number of off-heap segments.\n@@ -84,1 +83,1 @@\n-For these reasons, all the methods in the Foreign Linker API which *produce* memory segments (see `VaList::nextVarg`), allow an optional allocator to be provided by user code — this is key in ensuring that an application using the Foreign Linker API achieves optimal allocation performances, especially in non-trivial use cases.\n+All the methods in the FFM API which *produce* memory segments (see `VaList::nextVarg` and downcall method handles), allow for an allocator parameter to be provided — this is key in ensuring that an application using the FFM API achieves optimal allocation performances, especially in non-trivial use cases.\n@@ -90,1 +89,1 @@\n-* `SymbolLookup::libraryLookup(String, MemorySession)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided memory session parameter controls the library lifecycle: that is, when the memory session is closed, the library referred to by the lookup will also be closed;\n+* `SymbolLookup::libraryLookup(String, SegmentScope)` — creates a symbol lookup which can be used to search symbol in a library with the given name. The provided segment scope parameter controls the library lifecycle: that is, when the scope is not longer alive, the library referred to by the lookup will also be closed;\n@@ -94,1 +93,1 @@\n-Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an `Optional<MemorySegment>`.  The memory segments returned by the `lookup` are zero-length segments, whose base address is the address of the function or variable in the library.\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `find(String)` method, which returns an `Optional<MemorySegment>`.  The memory segments returned by the `lookup` are zero-length segments, whose base address is the address of the function or variable in the library.\n@@ -96,1 +95,1 @@\n-For instance, the following code can be used to look up the `clang_getClangVersion` function provided by the `clang` library; it does so by creating a *library lookup* whose lifecycle is associated to that of a confined memory session.\n+For instance, the following code can be used to look up the `clang_getClangVersion` function provided by the `clang` library; it does so by creating a *library lookup* whose lifecycle is associated to that of a confined arena.\n@@ -99,3 +98,3 @@\n-try (MemorySession session = MemorySession.openConfined()) {\n-    SymbolLookup libclang = SymbolLookup.libraryLookup(\"libclang.so\");\n-    MemorySegment clangVersion = libclang.lookup(\"clang_getClangVersion\").get();\n+try (Arena arena = Arena.openConfined()) {\n+    SymbolLookup libclang = SymbolLookup.libraryLookup(\"libclang.so\", arena.scope());\n+    MemorySegment clangVersion = libclang.find(\"clang_getClangVersion\").get();\n@@ -107,1 +106,1 @@\n-At the core of Panama foreign function support we find the `Linker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling foreign function calls as plain `MethodHandle` calls (see `Linker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to foreign functions as a function pointer (see `Linker::upcallStub`):\n+At the core of the FFM API's foreign function support we find the `Linker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows modelling foreign function calls as plain `MethodHandle` calls (see `Linker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to foreign functions as a function pointer (see `Linker::upcallStub`):\n@@ -112,1 +111,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, MemorySession session);    \n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope);\n@@ -123,14 +122,17 @@\n-| C type                                                       | Layout                                                       | Java carrier                       |\n-| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |\n-| `bool`                                                       | `JAVA_BOOLEAN`                                               | `byte`                             |\n-| `char`                                                       | `JAVA_BYTE`                                                  | `byte`                             |\n-| `short`                                                      | `JAVA_SHORT`                                                 | `short`, `char`                    |\n-| `int`                                                        | `JAVA_INT`                                                   | `int`                              |\n-| `long`                                                       | `JAVA_LONG`                                                  | `long`                             |\n-| `long long`                                                  | `JAVA_LONG`                                                  | `long`                             |\n-| `float`                                                      | `JAVA_FLOAT`                                                 | `float`                            |\n-| `double`                                                     | `JAVA_DOUBLE`                                                | `double`                           |\n-| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`                                                    | `Addressable`<br \/>`MemoryAddress` |\n-| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `MemoryLayout.structLayout(...)`<br \/>`MemoryLayout.unionLayout(...)`<br \/> | `MemorySegment`                    |\n-\n-Note that all C pointer types are modelled using the `ADDRESS` layout constant; the Java carrier type associated with this layout is either `Addressable` or `MemoryAddress` depending on where the layout occurs in the function descriptor. For downcall method handles, for instance, the `Addressable` carrier is used when the `ADDRESS` layout occurs in a parameter position of the corresponding function descriptor. This maximizes applicability of a downcall method handles, ensuring that any implementation of `Addressable` (e.g. memory segments, memory address, upcall stubs, va lists) can be passed where a pointer is expected.\n+| C type                                                       | Layout                                                       | Java carrier    |\n+| ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |\n+| `bool`                                                       | `JAVA_BOOLEAN`                                               | `byte`          |\n+| `char`                                                       | `JAVA_BYTE`                                                  | `byte`          |\n+| `short`                                                      | `JAVA_SHORT`                                                 | `short`, `char` |\n+| `int`                                                        | `JAVA_INT`                                                   | `int`           |\n+| `long`                                                       | `JAVA_LONG`                                                  | `long`          |\n+| `long long`                                                  | `JAVA_LONG`                                                  | `long`          |\n+| `float`                                                      | `JAVA_FLOAT`                                                 | `float`         |\n+| `double`                                                     | `JAVA_DOUBLE`                                                | `double`        |\n+| `char*`<br \/>`int**`<br \/> ...                               | `ADDRESS`                                                    | `MemorySegment` |\n+| `struct Point { int x; int y; };`<br \/>`union Choice { float a; int b; };`<br \/>... | `MemoryLayout.structLayout(...)`<br \/>`MemoryLayout.unionLayout(...)`<br \/> | `MemorySegment` |\n+\n+Both C structs\/unions and pointers are modelled using the `MemorySegment` carrier type. However, C structs\/unions are modelled in function descriptors with memory layouts of type `GroupLayout`, whereas pointers are modelled using the `ADDRESS` value layout constant (whose size is platform-specific). Moreover, the behavior of a downcall method handle returning a struct\/union type is radically different from that of a downcall method handle returning a C pointer:\n+\n+* downcall method handles returning C pointers will wrap the pointer address into a fresh zero-length memory segment (unless an unbounded address layout is specified);\n+* downcall method handles returning a C struct\/union type will return a *new* segment, of given size (the size of the struct\/union). The segment is allocated using a user-provided `SegmentAllocator`, which is provided using an additional prefix parameter inserted in the downcall method handle signature.\n@@ -160,1 +162,1 @@\n-\t\tlinker.defaultLookup().lookup(\"strlen\").get(),\n+        linker.defaultLookup().find(\"strlen\").get(),\n@@ -170,2 +172,2 @@\n-try (MemorySession session = MemorySession openConfined()) {\n-    long len = strlen.invoke(session.allocateUtf8String(\"Hello\")); \/\/ 5\n+try (Arena arena = Arena.openConfined()) {\n+    long len = strlen.invoke(arena.allocateUtf8String(\"Hello\")); \/\/ 5\n@@ -175,1 +177,1 @@\n-Here we are using a memory session to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this is possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an explicit memory session to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n+Here we are using a confined arena to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this is possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we use an arena to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n@@ -177,1 +179,1 @@\n-The `Linker` interface also supports linking of native functions without an address known at link time; when that happens, an address (of type `Addressable`) must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n+The `Linker` interface also supports linking of native functions without an address known at link time; when that happens, an address (of type `MemorySegment`) must be provided when the method handle returned by the linker is invoked — this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n@@ -184,1 +186,1 @@\n-try (MemorySession session = MemorySession openConfined()) {\n+try (Arena arena = Arena openConfined()) {\n@@ -186,2 +188,2 @@\n-        linker.defaultLookup().lookup(\"strlen\").get() \/\/ address provided here!\n-        session.allocateUtf8String(\"Hello\")\n+        linker.defaultLookup().find(\"strlen\").get() \/\/ address provided here!\n+        arena.allocateUtf8String(\"Hello\")\n@@ -192,3 +194,1 @@\n-It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Panama runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Panama runtime has to *trust* the function descriptor passed in<a href=\"#3\"><sup>2<\/sup><\/a>; for this reason, the `Linker::nativeLinker` factory is also a restricted method.\n-\n-If a native function returns a raw pointer (of type `MemoryAddress`), it is then up to the client to make sure that the address is being accessed and disposed of correctly, compatibly with the requirements of the underlying native library. If a native function returns a struct by value, a *fresh*, memory segment is allocated off-heap and returned to the caller. In such cases, the downcall method handle will feature an additional prefix `SegmentAllocator` (see above) parameter which will be used by the downcall method handle to allocate the returned segment. The allocation will likely associate the segment with a memory session that is known to the caller and which can then be used to release the memory associated with that segment. \n+It is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Java runtime. After all, a symbol in a dynamic library is nothing but a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that the Java runtime has to *trust* the function descriptor passed in<a href=\"#3\"><sup>2<\/sup><\/a>; for this reason, the `Linker::nativeLinker` factory is also a restricted method.\n@@ -196,1 +196,1 @@\n-When working with deterministic deallocation and shared memory session, it is always possible for the session associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `Addressable` instance passed to a downcall method handle will be *kept alive* for the entire duration of the call. In other words, it's as if the call to the downcall method handle occurred inside an invisible call to `MemorySession::whileAlive`.\n+When working with shared arenas, it is always possible for the arena associated with a memory segment passed *by reference* to a native function to be closed (by another thread) *while* the native function is executing. When this happens, the native code is at risk of dereferencing already-freed memory, which might trigger a JVM crash, or even result in silent memory corruption. For this reason, the `Linker` API provides some basic temporal safety guarantees: any `MemorySegment` instance passed by reference to a downcall method handle will be *kept alive* for the entire duration of the call. In other words, it's as if the call to the downcall method handle occurred inside an invisible call to `SegmentScope::whileAlive`.\n@@ -245,1 +245,1 @@\n-try (MemorySession session = MemorySession openConfined()) {\n+try (Arena arena = Arena.openConfined()) {\n@@ -253,1 +253,1 @@\n-The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function, of type `MemorySegment`. The upcall stub is associated with the provided memory session instance; this means that the stub will be uninstalled when the session is closed.\n+The above code creates an upcall stub — `comparFunc` — a function pointer that can be used to invoke our Java comparator function, of type `MemorySegment`. The upcall stub is associated with the provided segment scope instance; this means that the stub will be uninstalled when the arena is closed.\n@@ -273,1 +273,1 @@\n-To do this using the foreign function support provided by Panama we would have to build a *specialized* downcall handle for that call shape, using the `FunctionDescriptor::asVariadic` to inject additional variadic layouts, as follows:\n+To do this using the foreign function support provided by the FFM API we would have to build a *specialized* downcall handle for that call shape, using the `FunctionDescriptor::asVariadic` to inject additional variadic layouts, as follows:\n@@ -286,2 +286,2 @@\n-try (MemorySession session = MemorySession openConfined()) {    \n-    printf.invoke(session.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+try (Arena arena = Arena.openConfined()) {\n+    printf.invoke(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n@@ -316,1 +316,1 @@\n-try (MemorySession session = MemorySession openConfined()) {\n+try (Arena arena = Arena.openConfined()) {\n@@ -318,1 +318,1 @@\n-            session.allocateUtf8String(\"%d plus %d equals %d\"),\n+            arena.allocateUtf8String(\"%d plus %d equals %d\"),\n@@ -322,1 +322,1 @@\n-                                   .addVarg(JAVA_INT, 4), session)\n+                                   .addVarg(JAVA_INT, 4), arena.scope()).segment()\n@@ -326,1 +326,1 @@\n-While the callee has to do more work to call the `vprintf` handle, note that that now we're back in a place where the downcall handle  `vprintf` can be shared across multiple callees. Note that both the format string and the `VaList` are associated with the given memory session — this means that both will remain valid throughout the native function call.\n+While the callee has to do more work to call the `vprintf` handle, note that that now we're back in a place where the downcall handle  `vprintf` can be shared across multiple callees. Note that both the format string and the `VaList` are associated with the given segment scope — this means that both will remain valid throughout the native function call.\n@@ -335,0 +335,1 @@\n+import java.lang.foreign.Arena;\n@@ -338,1 +339,0 @@\n-import java.lang.foreign.MemoryAddress;\n@@ -340,1 +340,0 @@\n-import java.lang.foreign.MemorySession;\n@@ -364,1 +363,1 @@\n-                STDLIB.lookup(\"strlen\").get(),\n+                STDLIB.find(\"strlen\").get(),\n@@ -368,2 +367,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment hello = session.allocateUtf8String(\"Hello\");\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment hello = arena.allocateUtf8String(\"Hello\");\n@@ -380,2 +379,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment hello = session.allocateUtf8String(\"Hello\");\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment hello = arena.allocateUtf8String(\"Hello\");\n@@ -383,1 +382,1 @@\n-                STDLIB.lookup(\"strlen\").get(),\n+                STDLIB.find(\"strlen\").get(),\n@@ -390,1 +389,1 @@\n-        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+        static int qsortCompare(MemorySegment addr1, MemorySegment addr2) {\n@@ -397,1 +396,1 @@\n-                STDLIB.lookup(\"qsort\").get(),\n+                STDLIB.find(\"qsort\").get(),\n@@ -400,1 +399,1 @@\n-        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS, ADDRESS);\n+        FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT, ADDRESS.asUnbounded(), ADDRESS.asUnbounded());\n@@ -403,1 +402,1 @@\n-                                                     Linker.upcallType(comparDesc));\n+                                                     comparDesc.toMethodType());\n@@ -405,1 +404,1 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n+        try (Arena arena = Arena.openConfined()) {\n@@ -407,1 +406,1 @@\n-                comparHandle, comparDesc, session);\n+                comparHandle, comparDesc, arena.scope());\n@@ -409,1 +408,1 @@\n-            MemorySegment array = session.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+            MemorySegment array = arena.allocateArray(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n@@ -418,1 +417,1 @@\n-                STDLIB.lookup(\"printf\").get(),\n+                STDLIB.find(\"printf\").get(),\n@@ -422,2 +421,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment s = session.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment s = arena.allocateUtf8String(\"%d plus %d equals %d\\n\");\n@@ -431,1 +430,1 @@\n-                STDLIB.lookup(\"vprintf\").get(),\n+                STDLIB.find(\"vprintf\").get(),\n@@ -434,2 +433,2 @@\n-        try (MemorySession session = MemorySession.openConfined()) {\n-            MemorySegment s = session.allocateUtf8String(\"%d plus %d equals %d\\n\");\n+        try (Arena arena = Arena.openConfined()) {\n+            MemorySegment s = arena.allocateUtf8String(\"%d plus %d equals %d\\n\");\n@@ -439,2 +438,2 @@\n-                            .addVarg(JAVA_INT, 4), session);\n-            vprintf.invoke(s, vlist);\n+                            .addVarg(JAVA_INT, 4), arena.scope());\n+            vprintf.invoke(s, vlist.segment());\n","filename":"doc\/panama_ffi.md","additions":95,"deletions":96,"binary":false,"changes":191,"status":"modified"}]}