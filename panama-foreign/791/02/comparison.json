{"files":[{"patch":"@@ -53,0 +53,3 @@\n+    public interface UpcallStubFactory {\n+        MemorySegment makeStub(MethodHandle target, Arena arena);\n+    }\n@@ -56,0 +59,1 @@\n+    private final SoftReferenceCache<LinkRequest, UpcallStubFactory> UPCALL_CACHE = new SoftReferenceCache<>();\n@@ -87,1 +91,4 @@\n-        return arrangeUpcall(target, target.type(), function, arena, optionSet);\n+\n+        UpcallStubFactory factory = UPCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->\n+            arrangeUpcall(type, linkRequest.descriptor(), linkRequest.options()));\n+        return factory.makeStub(target, arena);\n@@ -90,3 +97,1 @@\n-    protected abstract MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType,\n-                                                   FunctionDescriptor function, Arena arena,\n-                                                   LinkerOptions options);\n+    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -110,2 +110,0 @@\n-    private static final SoftReferenceCache<FunctionDescriptor, MethodHandle> UPCALL_WRAPPER_CACHE = new SoftReferenceCache<>();\n-\n@@ -141,10 +139,1 @@\n-    static MethodHandle specialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n-        if (callingSequence.forUpcall()) {\n-            MethodHandle wrapper = UPCALL_WRAPPER_CACHE.get(callingSequence.functionDesc(), fd -> specializeUpcall(leafHandle, callingSequence, abi));\n-            return MethodHandles.insertArguments(wrapper, 0, leafHandle); \/\/ lazily customized for leaf handle instances\n-        } else {\n-            return specializeDowncall(leafHandle, callingSequence, abi);\n-        }\n-    }\n-\n-    private static MethodHandle specializeDowncall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+    static MethodHandle specializeDowncall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n@@ -168,1 +157,1 @@\n-    private static MethodHandle specializeUpcall(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+    static MethodHandle specializeUpcall(MethodType targetType, CallingSequence callingSequence, ABIDescriptor abi) {\n@@ -172,1 +161,1 @@\n-        byte[] bytes = specializeHelper(leafHandle.type(), callerMethodType, callingSequence, abi);\n+        byte[] bytes = specializeHelper(targetType, callerMethodType, callingSequence, abi);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            handle = BindingSpecializer.specialize(handle, callingSequence, abi);\n+            handle = BindingSpecializer.specializeDowncall(handle, callingSequence, abi);\n@@ -199,1 +199,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -143,1 +144,1 @@\n-    public static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n+    private static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n@@ -160,0 +161,21 @@\n+    public static UpcallStubFactory arrangeUpcallHelper(MethodType targetType, boolean isInMemoryReturn, boolean dropReturn,\n+                                                        ABIDescriptor abi, CallingSequence callingSequence) {\n+        if (isInMemoryReturn) {\n+            \/\/ simulate the adaptation to get the type\n+            MethodHandle fakeTarget = MethodHandles.empty(targetType);\n+            targetType = adaptUpcallForIMR(fakeTarget, dropReturn).type();\n+        }\n+\n+        UpcallStubFactory factory = UpcallLinker.makeFactory(targetType, abi, callingSequence);\n+\n+        if (isInMemoryReturn) {\n+            final UpcallStubFactory finalFactory = factory;\n+            factory = (target, scope) -> {\n+                target = adaptUpcallForIMR(target, dropReturn);\n+                return finalFactory.makeStub(target, scope);\n+            };\n+        }\n+\n+        return factory;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -31,1 +32,0 @@\n-import java.lang.foreign.Arena;\n@@ -38,0 +38,1 @@\n+import java.util.function.UnaryOperator;\n@@ -58,1 +59,1 @@\n-                    methodType(Object.class, Object[].class, InvocationData.class));\n+                    methodType(Object.class, MethodHandle.class, Object[].class, InvocationData.class));\n@@ -64,1 +65,1 @@\n-    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, Arena scope) {\n+    public static UpcallStubFactory makeFactory(MethodType targetType, ABIDescriptor abi, CallingSequence callingSequence) {\n@@ -71,1 +72,1 @@\n-        MethodHandle doBindings;\n+        UnaryOperator<MethodHandle> doBindingsMaker;\n@@ -73,2 +74,6 @@\n-            doBindings = BindingSpecializer.specialize(target, callingSequence, abi);\n-            assert doBindings.type() == llType;\n+            MethodHandle doBindings = BindingSpecializer.specializeUpcall(targetType, callingSequence, abi);\n+            doBindingsMaker = target -> {\n+                MethodHandle handle = MethodHandles.insertArguments(doBindings, 0, target);\n+                assert handle.type() == llType;\n+                return handle;\n+            };\n@@ -82,5 +87,9 @@\n-            target = target.asSpreader(Object[].class, spreaderCount);\n-            InvocationData invData = new InvocationData(target, argIndices, retIndices, callingSequence, retMoves, abi);\n-            doBindings = insertArguments(MH_invokeInterpBindings, 1, invData);\n-            doBindings = doBindings.asCollector(Object[].class, llType.parameterCount());\n-            doBindings = doBindings.asType(llType);\n+            final int finalSpreaderCount = spreaderCount;\n+            InvocationData invData = new InvocationData(argIndices, retIndices, callingSequence, retMoves, abi);\n+            MethodHandle doBindings = insertArguments(MH_invokeInterpBindings, 2, invData);\n+            doBindingsMaker = target -> {\n+                target = target.asSpreader(Object[].class, finalSpreaderCount);\n+                MethodHandle handle = MethodHandles.insertArguments(doBindings, 0, target);\n+                handle = handle.asCollector(Object[].class, llType.parameterCount());\n+                return handle.asType(llType);\n+            };\n@@ -89,2 +98,0 @@\n-        checkPrimitive(doBindings.type());\n-        doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n@@ -94,3 +101,9 @@\n-        long entryPoint = makeUpcallStub(doBindings, abi, conv,\n-                callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n-        return UpcallStubs.makeUpcall(entryPoint, scope);\n+        return (target, scope) -> {\n+            assert target.type() == targetType;\n+            MethodHandle doBindings = doBindingsMaker.apply(target);\n+            checkPrimitive(doBindings.type());\n+            doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n+            long entryPoint = makeUpcallStub(doBindings, abi, conv,\n+                    callingSequence.needsReturnBuffer(), callingSequence.returnBufferSize());\n+            return UpcallStubs.makeUpcall(entryPoint, scope);\n+        };\n@@ -123,2 +136,1 @@\n-    private record InvocationData(MethodHandle leaf,\n-                                  Map<VMStorage, Integer> argIndexMap,\n+    private record InvocationData(Map<VMStorage, Integer> argIndexMap,\n@@ -130,1 +142,1 @@\n-    private static Object invokeInterpBindings(Object[] lowLevelArgs, InvocationData invData) throws Throwable {\n+    private static Object invokeInterpBindings(MethodHandle leaf, Object[] lowLevelArgs, InvocationData invData) throws Throwable {\n@@ -157,1 +169,1 @@\n-            Object o = invData.leaf.invoke(highLevelArgs);\n+            Object o = leaf.invoke(highLevelArgs);\n@@ -165,1 +177,1 @@\n-            if (invData.leaf.type().returnType() != void.class) {\n+            if (leaf.type().returnType() != void.class) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":33,"deletions":21,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.Arena;\n@@ -34,0 +33,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -191,1 +191,2 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena session, LinkerOptions options) {\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc,\n+                                                          LinkerOptions options) {\n@@ -193,6 +194,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(abiDescriptor(), target, bindings.callingSequence, session);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, abiDescriptor(),\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.Arena;\n@@ -34,1 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -37,1 +35,0 @@\n-import java.util.function.Consumer;\n@@ -63,2 +60,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n-        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, scope, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.LINUX.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.Arena;\n@@ -34,1 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -37,1 +35,0 @@\n-import java.util.function.Consumer;\n@@ -63,2 +60,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n-        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, scope, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.MACOS.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.Arena;\n@@ -35,1 +34,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -38,1 +36,0 @@\n-import java.util.function.Consumer;\n@@ -60,2 +57,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n-        return  CallArranger.WINDOWS.arrangeUpcall(target, targetType, function, scope, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return  CallArranger.WINDOWS.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.Linker;\n@@ -64,1 +63,1 @@\n-                    MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, UpcallData.class));\n+                    MethodType.methodType(void.class, MethodHandle.class, MemorySegment.class, MemorySegment.class, UpcallData.class));\n@@ -108,3 +107,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function,\n-                                          Arena scope, LinkerOptions options) {\n-        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, Arena.ofAuto());\n@@ -112,2 +110,2 @@\n-        UpcallData invData = new UpcallData(target, function.returnLayout().orElse(null),\n-                function.argumentLayouts());\n+        UpcallData invData = new UpcallData(function.returnLayout().orElse(null), function.argumentLayouts(), cif);\n+        MethodHandle doUpcallMH = MethodHandles.insertArguments(MH_DO_UPCALL, 3, invData);\n@@ -115,2 +113,4 @@\n-        MethodHandle doUpcallMH = MethodHandles.insertArguments(MH_DO_UPCALL, 2, invData);\n-        return LibFallback.createClosure(cif, doUpcallMH, options.uncaughtExceptionHandler(), scope);\n+        return (target, scope) -> {\n+            target = MethodHandles.insertArguments(doUpcallMH, 0, target);\n+            return LibFallback.createClosure(cif, target, options.uncaughtExceptionHandler(), scope);\n+        };\n@@ -185,1 +185,2 @@\n-    private record UpcallData(MethodHandle target, MemoryLayout returnLayout, List<MemoryLayout> argLayouts) {}\n+    \/\/ note that cif is not used, but we store it here to keep it alive\n+    private record UpcallData(MemoryLayout returnLayout, List<MemoryLayout> argLayouts, MemorySegment cif) {}\n@@ -187,1 +188,1 @@\n-    private static void doUpcall(MemorySegment retPtr, MemorySegment argPtrs, UpcallData data) throws Throwable {\n+    private static void doUpcall(MethodHandle target, MemorySegment retPtr, MemorySegment argPtrs, UpcallData data) throws Throwable {\n@@ -205,1 +206,1 @@\n-            Object result = data.target().invokeWithArguments(args);\n+            Object result = target.invokeWithArguments(args);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.Arena;\n@@ -35,0 +34,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -123,1 +123,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena scope, LinkerOptions options) {\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n@@ -125,6 +125,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(CLinux, target, bindings.callingSequence, scope);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CLinux,\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.Arena;\n@@ -34,1 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -58,2 +56,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n-        return LinuxRISCV64CallArranger.arrangeUpcall(target, targetType, function, scope, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return LinuxRISCV64CallArranger.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -40,1 +41,0 @@\n-import java.lang.foreign.Arena;\n@@ -140,1 +140,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena scope, LinkerOptions options) {\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n@@ -142,6 +142,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(CSysV, target, bindings.callingSequence, scope);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CSysV,\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.Arena;\n@@ -33,1 +32,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -36,1 +34,0 @@\n-import java.util.function.Consumer;\n@@ -61,2 +58,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -39,1 +40,0 @@\n-import java.lang.foreign.Arena;\n@@ -134,1 +134,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena scope, LinkerOptions options) {\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n@@ -136,6 +136,3 @@\n-\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, false \/* need the return value as well *\/);\n-        }\n-\n-        return UpcallLinker.make(CWindows, target, bindings.callingSequence, scope);\n+        final boolean dropReturn = false; \/* need the return value as well *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, CWindows,\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.Arena;\n@@ -32,1 +31,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -35,1 +33,0 @@\n-import java.util.function.Consumer;\n@@ -60,2 +57,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n-        return CallArranger.arrangeUpcall(target, targetType, function, scope, options);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(targetType, function, options);\n@@ -64,1 +61,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}