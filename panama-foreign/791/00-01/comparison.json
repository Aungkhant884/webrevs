{"files":[{"patch":"@@ -157,26 +157,0 @@\n-    private static MethodType computeCollectArgumentsType(MethodType target, int insertIndex, MethodType collector) {\n-        if (collector.returnType() != void.class){\n-            \/\/ for non-void collector, the returned value is inserted into the argument list passed to the target\n-            target = target.dropParameterTypes(insertIndex, insertIndex + 1);\n-        }\n-        return target.insertParameterTypes(insertIndex, collector.parameterArray()); \/\/ insert targetType parameters instead\n-    }\n-\n-    \/\/ this just computes the adjusted type\n-    private static MethodType computeUpcallIMRType(MethodType targetType, boolean dropReturn) {\n-        if (targetType.returnType() != MemorySegment.class)\n-            throw new IllegalArgumentException(\"Must return MemorySegment for IMR\");\n-\n-        targetType = computeCollectArgumentsType(MH_BUFFER_COPY.type(), 1, targetType);\n-\n-        if (dropReturn) { \/\/ no handling for return value, need to drop it\n-            targetType = targetType.changeReturnType(void.class);\n-        } else {\n-            \/\/ adjust return type so it matches the inferred type of the effective\n-            \/\/ function descriptor\n-            targetType = targetType.changeReturnType(MemorySegment.class);\n-        }\n-\n-        return targetType;\n-    }\n-\n@@ -186,1 +160,3 @@\n-            targetType = computeUpcallIMRType(targetType, dropReturn);\n+            \/\/ simulate the adaptation to get the type\n+            MethodHandle fakeTarget = MethodHandles.empty(targetType);\n+            targetType = adaptUpcallForIMR(fakeTarget, dropReturn).type();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"}]}