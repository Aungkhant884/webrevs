{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.jextract.Declaration;\n@@ -43,1 +44,1 @@\n-\n+    private final AnnotationWriter annotationWriter;\n@@ -49,1 +50,1 @@\n-    HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper) {\n+    HeaderBuilder(String className, String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter) {\n@@ -51,0 +52,1 @@\n+        this.annotationWriter = annotationWriter;\n@@ -197,1 +199,3 @@\n-    void emitTypedef(String className, String superClassName) {\n+    void emitTypedef(Declaration.Typedef td, String superClassName) {\n+        String className = td.name();\n+        boolean superClassExists = superClassName != null;\n@@ -201,1 +205,2 @@\n-        append(\"class \");\n+        append(annotationWriter.getCAnnotation(td.type()));\n+        append(\" class \");\n@@ -204,2 +209,4 @@\n-        append(\" extends \");\n-        append(superClassName);\n+        if (superClassExists) {\n+            append(\" extends \");\n+            append(superClassName);\n+        }\n@@ -207,0 +214,1 @@\n+\n@@ -214,0 +222,32 @@\n+\n+        \/\/ typedef of incomplete struct\/union\n+        \/\/ generate a class with just allocatePointer methods with right annotation\n+        if (!superClassExists) {\n+            String anno = annotationWriter.getCAnnotation(Type.pointer(td.type()));\n+            \/\/ allocatePointer\n+            incrAlign();\n+            indent();\n+            append(PUB_MODS);\n+            append(anno + \" MemorySegment allocatePointer() {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+\n+            \/\/ allocatePointer (scope version)\n+            incrAlign();\n+            indent();\n+            append(PUB_MODS);\n+            append(anno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return scope.allocate(C_POINTER);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderBuilder.java","additions":46,"deletions":6,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    protected final AnnotationWriter annotationWriter = new AnnotationWriter();\n+    protected final AnnotationWriter annotationWriter;\n@@ -101,2 +101,3 @@\n-        return new OutputFactory(pkgName,\n-                new HeaderBuilder(clsName, pkgName, constantHelper), constantHelper).generate(decl);\n+        AnnotationWriter annotationWriter = new AnnotationWriter();\n+        HeaderBuilder headerBuilder = new HeaderBuilder(clsName, pkgName, constantHelper, annotationWriter);\n+        return new OutputFactory(pkgName, headerBuilder, constantHelper, annotationWriter).generate(decl);\n@@ -105,1 +106,2 @@\n-    private OutputFactory(String pkgName, HeaderBuilder toplevelBuilder, ConstantHelper constantHelper) {\n+    private OutputFactory(String pkgName, HeaderBuilder toplevelBuilder, ConstantHelper constantHelper,\n+                          AnnotationWriter annotationWriter) {\n@@ -110,0 +112,1 @@\n+        this.annotationWriter = annotationWriter;\n@@ -136,3 +139,1 @@\n-            if (structDefinitionSeen(structDef)) {\n-                toplevelBuilder.emitTypedef(td.name(), structDefinitionName(structDef));\n-            }\n+            toplevelBuilder.emitTypedef(td, structDefinitionSeen(structDef)? structDefinitionName(structDef) : null);\n@@ -219,3 +220,2 @@\n-                    String anno = annotationWriter.getCAnnotation(Type.declared(d));\n-                    String arrayAnno = annotationWriter.getCAnnotation(Type.array(Type.declared(d)));\n-                    currentBuilder = new StructBuilder(currentBuilder, className, parentLayoutFieldName, parentLayout, pkgName, constantHelper, anno, arrayAnno);\n+                    currentBuilder = new StructBuilder(currentBuilder, className, parentLayoutFieldName, parentLayout,\n+                            pkgName, constantHelper, annotationWriter, Type.declared(d));\n@@ -376,1 +376,1 @@\n-                                toplevelBuilder.emitTypedef(tree.name(), structDefinitionName(s));\n+                                toplevelBuilder.emitTypedef(tree, structDefinitionName(s));\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n@@ -40,0 +42,1 @@\n+    private final String structPtrAnno;\n@@ -41,2 +44,2 @@\n-    StructBuilder(JavaSourceBuilder prev, String className, String parentLayoutFieldName, MemoryLayout parentLayout, String pkgName,\n-            ConstantHelper constantHelper, String structAnno, String structArrayAnno) {\n+    StructBuilder(JavaSourceBuilder prev, String className, String parentLayoutFieldName, MemoryLayout parentLayout,\n+            String pkgName, ConstantHelper constantHelper, AnnotationWriter annotationWriter, Type structType) {\n@@ -47,2 +50,3 @@\n-        this.structAnno = structAnno;\n-        this.structArrayAnno = structArrayAnno;\n+        this.structAnno = annotationWriter.getCAnnotation(structType);\n+        this.structArrayAnno = annotationWriter.getCAnnotation(Type.array(structType));\n+        this.structPtrAnno = annotationWriter.getCAnnotation(Type.pointer(structType));\n@@ -107,0 +111,2 @@\n+        emitAllocatePoiner();\n+        emitScopeAllocatePointer();\n@@ -194,0 +200,1 @@\n+\n@@ -227,1 +234,1 @@\n-        append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\");\n+        append(\"return MemorySegment.allocateNative(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n@@ -229,1 +236,2 @@\n-        append(\"}\\n\");\n+        indent();\n+        append('}');\n@@ -240,1 +248,18 @@\n-        append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\");\n+        append(\"return scope.allocate(MemoryLayout.ofSequence(len, $LAYOUT()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocatePoiner() {\n+        incrAlign();\n+        indent();\n+        append(PUB_MODS);\n+        append(structPtrAnno + \" MemorySegment allocatePointer() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return MemorySegment.allocateNative(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n@@ -242,0 +267,12 @@\n+    }\n+\n+    private void emitScopeAllocatePointer() {\n+        incrAlign();\n+        indent();\n+        append(PUB_MODS);\n+        append(structPtrAnno + \" MemorySegment allocatePointer(NativeScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return scope.allocate(C_POINTER);\\n\");\n+        decrAlign();\n+        indent();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":44,"deletions":7,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.reflect.Method;\n@@ -25,1 +26,1 @@\n-\n+import jdk.incubator.foreign.NativeScope;\n@@ -50,1 +51,1 @@\n-            \/\/ no class should be generated for typedef on opaque struct\n+            \/\/ class should be generated for typedef on opaque struct\n@@ -52,1 +53,5 @@\n-            assertNull(fooCls);\n+            assertNotNull(fooCls);\n+            Method alloc = findMethod(fooCls, \"allocatePointer\");\n+            assertNotNull(alloc);\n+            alloc = findMethod(fooCls, \"allocatePointer\", NativeScope.class);\n+            assertNotNull(alloc);\n","filename":"test\/jdk\/tools\/jextract\/Test8245767.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.NativeScope;\n@@ -60,0 +61,4 @@\n+            Class<?> fooTypedefClass = loader.loadClass(\"test8252634_h$Foo\");\n+            checkAnnotation(fooTypedefClass, \"struct foo\");\n+            checkFooAllocatePointer(fooTypedefClass);\n+\n@@ -120,0 +125,2 @@\n+        allocate = findMethod(pointClass, \"allocate\", NativeScope.class);\n+        checkAnnotation(allocate.getAnnotatedReturnType(), \"struct Point\");\n@@ -122,0 +129,13 @@\n+        allocateArray = findMethod(pointClass, \"allocateArray\", int.class, NativeScope.class);\n+        checkAnnotation(allocateArray.getAnnotatedReturnType(), \"struct Point[]\");\n+        Method allocatePointer = findMethod(pointClass, \"allocatePointer\");\n+        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct Point*\");\n+        allocatePointer = findMethod(pointClass, \"allocatePointer\", NativeScope.class);\n+        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct Point*\");\n+    }\n+\n+    private void checkFooAllocatePointer(Class<?> fooClass) throws Throwable {\n+        Method allocatePointer = findMethod(fooClass, \"allocatePointer\");\n+        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct foo*\");\n+        allocatePointer = findMethod(fooClass, \"allocatePointer\", NativeScope.class);\n+        checkAnnotation(allocatePointer.getAnnotatedReturnType(), \"struct foo*\");\n","filename":"test\/jdk\/tools\/jextract\/Test8252634.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+typedef struct foo Foo;\n+\n","filename":"test\/jdk\/tools\/jextract\/test8252634.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}