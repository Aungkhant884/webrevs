{"files":[{"patch":"@@ -1128,25 +1128,4 @@\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n-        }\n-        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n-        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        long size = elementCount * srcElementLayout.byteSize();\n-        srcImpl.checkAccess(srcOffset, size, true);\n-        dstImpl.checkAccess(dstOffset, size, false);\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n-        }\n+\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcElementLayout, srcOffset,\n+                dstSegment, dstElementLayout, dstOffset,\n+                elementCount);\n@@ -1951,22 +1930,4 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n-        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n-        }\n-        int dstBase = (int)baseAndScale;\n-        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n-        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n-        }\n+\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcLayout, srcOffset,\n+                dstArray, dstIndex,\n+                elementCount);\n@@ -2003,23 +1964,0 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n-        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n-            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n-        }\n-        int srcBase = (int)baseAndScale;\n-        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n-        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n-        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n-        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n-        }\n-    }\n@@ -2027,18 +1965,3 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long)Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+        AbstractMemorySegmentImpl.copy(srcArray, srcIndex,\n+                dstSegment, dstLayout, dstOffset,\n+                elementCount);\n@@ -2085,34 +2008,2 @@\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n-        long srcBytes = srcToOffset - srcFromOffset;\n-        long dstBytes = dstToOffset - dstFromOffset;\n-        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n-        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n-        if (dstImpl == srcImpl) {\n-            srcImpl.checkValidState();\n-            return -1;\n-        }\n-\n-        long bytes = Math.min(srcBytes, dstBytes);\n-        long i = 0;\n-        if (bytes > 7) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n-                return 0;\n-            }\n-            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n-                    bytes);\n-            if (i >= 0) {\n-                return i;\n-            }\n-            long remaining = ~i;\n-            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n-            i = bytes - remaining;\n-        }\n-        for (; i < bytes; i++) {\n-            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n-                return i;\n-            }\n-        }\n-        return srcBytes != dstBytes ? bytes : -1;\n+        return AbstractMemorySegmentImpl.mismatch(srcSegment, srcFromOffset, srcToOffset,\n+                dstSegment, dstFromOffset, dstToOffset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":13,"deletions":122,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.Array;\n@@ -53,0 +54,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -57,0 +59,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -530,0 +534,148 @@\n+\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                            MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                            long elementCount) {\n+\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n+        }\n+        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n+        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void copy(MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n+                            Object dstArray, int dstIndex,\n+                            int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n+        }\n+        int dstBase = (int)baseAndScale;\n+        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        Utils.checkElementAlignment(srcLayout, \"Source layout alignment greater than its size\");\n+        if (!srcImpl.isAlignedForElement(srcOffset, srcLayout)) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void copy(Object srcArray, int srcIndex,\n+                            MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset,\n+                            int elementCount) {\n+\n+        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n+        }\n+        int srcBase = (int)baseAndScale;\n+        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        Utils.checkElementAlignment(dstLayout, \"Destination layout alignment greater than its size\");\n+        if (!destImpl.isAlignedForElement(dstOffset, dstLayout)) {\n+            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n+        }\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.sessionImpl(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n+    }\n+\n+    public static long mismatch(MemorySegment srcSegment, long srcFromOffset, long srcToOffset,\n+                                MemorySegment dstSegment, long dstFromOffset, long dstToOffset) {\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(srcSegment);\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)Objects.requireNonNull(dstSegment);\n+        long srcBytes = srcToOffset - srcFromOffset;\n+        long dstBytes = dstToOffset - dstFromOffset;\n+        srcImpl.checkAccess(srcFromOffset, srcBytes, true);\n+        dstImpl.checkAccess(dstFromOffset, dstBytes, true);\n+        if (dstImpl == srcImpl) {\n+            srcImpl.checkValidState();\n+            return -1;\n+        }\n+\n+        long bytes = Math.min(srcBytes, dstBytes);\n+        long i = 0;\n+        if (bytes > 7) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset) != dstImpl.get(JAVA_BYTE, dstFromOffset)) {\n+                return 0;\n+            }\n+            i = AbstractMemorySegmentImpl.vectorizedMismatchLargeForBytes(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcFromOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstFromOffset,\n+                    bytes);\n+            if (i >= 0) {\n+                return i;\n+            }\n+            long remaining = ~i;\n+            assert remaining < 8 : \"remaining greater than 7: \" + remaining;\n+            i = bytes - remaining;\n+        }\n+        for (; i < bytes; i++) {\n+            if (srcImpl.get(JAVA_BYTE, srcFromOffset + i) != dstImpl.get(JAVA_BYTE, dstFromOffset + i)) {\n+                return i;\n+            }\n+        }\n+        return srcBytes != dstBytes ? bytes : -1;\n+    }\n+\n+    private static long getBaseAndScale(Class<?> arrayType) {\n+        if (arrayType.equals(byte[].class)) {\n+            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(char[].class)) {\n+            return (long) Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(short[].class)) {\n+            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(int[].class)) {\n+            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(float[].class)) {\n+            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(long[].class)) {\n+            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(double[].class)) {\n+            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n+        } else {\n+            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"}]}