{"files":[{"patch":"@@ -491,1 +491,1 @@\n-        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE\n+        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n@@ -596,1 +596,1 @@\n-        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE\n+        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n@@ -705,1 +705,1 @@\n-        public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE\n+        public static final ValueLayout C_POINTER = MemoryLayouts.ADDRESS\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CSupport.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,10 @@\n-    private static final VarHandle address_handle = MemoryHandles.asAddressVarHandle((ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle);\n+    private static final VarHandle address_handle;\n+\n+    static {\n+        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n+            case 4 -> int.class;\n+            case 8 -> long.class;\n+            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n+        };\n+        address_handle = MemoryHandles.asAddressVarHandle(indexedHandle(MemoryLayouts.ADDRESS, carrier));\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.misc.Unsafe;\n+\n@@ -138,0 +140,5 @@\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}), and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final ValueLayout ADDRESS = MemoryLayout.ofValueBits(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.stream.Stream;\n@@ -184,0 +185,23 @@\n+    \/**\n+     * Allocate a block of memory in this native scope with given layout and initialize it with given address value.\n+     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * The segment returned by this method cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if\n+     * {@code limit() - size() < layout.byteSize()}.\n+     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n+     *\/\n+    default MemorySegment allocate(MemoryLayout layout, MemoryAddress value) {\n+        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n+            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n+        }\n+        switch ((int)layout.byteSize()) {\n+            case 4: return allocate(layout, (int)value.toRawLongValue());\n+            case 8: return allocate(layout, value.toRawLongValue());\n+            default: throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n+        }\n+    }\n+\n@@ -289,0 +313,27 @@\n+    \/**\n+     * Allocate a block of memory in this native scope with given layout and initialize it with given address array.\n+     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n+     * segment must conform to the layout alignment constraints.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if\n+     * {@code limit() - size() < (elementLayout.byteSize() * array.length)}.\n+     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, MemoryAddress[] array) {\n+        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n+        }\n+        switch ((int)elementLayout.byteSize()) {\n+            case 4: return copyArrayWithSwapIfNeeded(Stream.of(array)\n+                            .mapToInt(a -> (int)a.toRawLongValue()).toArray(),\n+                            elementLayout, MemorySegment::ofArray);\n+            case 8: return copyArrayWithSwapIfNeeded(Stream.of(array)\n+                            .mapToLong(MemoryAddress::toRawLongValue).toArray(),\n+                            elementLayout, MemorySegment::ofArray);\n+            default: throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n@@ -239,0 +241,3 @@\n+                { MemoryAddress.ofLong(42), (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },\n@@ -259,0 +264,3 @@\n+                { MemoryAddress.ofLong(42), (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },\n@@ -279,0 +287,3 @@\n+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },\n@@ -299,0 +310,3 @@\n+                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(long.class)) },\n@@ -324,0 +338,3 @@\n+                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n@@ -345,0 +362,3 @@\n+                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n@@ -365,0 +385,3 @@\n+                { (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n@@ -386,0 +409,3 @@\n+                { (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n@@ -490,0 +516,28 @@\n+\n+        ToArrayHelper<MemoryAddress[]> toAddressArray = new ToArrayHelper<>() {\n+            @Override\n+            public MemoryAddress[] array() {\n+                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+                    case 4 -> wrap(toIntArray.array());\n+                    case 8 -> wrap(toLongArray.array());\n+                    default -> throw new IllegalStateException(\"Cannot get here\");\n+                };\n+            }\n+\n+            @Override\n+            public MemoryAddress[] toArray(MemorySegment segment, ValueLayout layout) {\n+                return switch ((int)layout.byteSize()) {\n+                    case 4 -> wrap(toIntArray.toArray(segment, layout));\n+                    case 8 -> wrap(toLongArray.toArray(segment, layout));\n+                    default -> throw new IllegalStateException(\"Cannot get here\");\n+                };\n+            }\n+\n+            private MemoryAddress[] wrap(int[] ints) {\n+                return IntStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n+            }\n+\n+            private MemoryAddress[] wrap(long[] ints) {\n+                return LongStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n+            }\n+        };\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"}]}