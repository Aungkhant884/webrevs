{"files":[{"patch":"@@ -49,0 +49,1 @@\n+  int _preserved_value_mask;\n@@ -61,1 +62,2 @@\n-                         bool needs_return_buffer)\n+                         bool needs_return_buffer,\n+                         int preserved_value_mask)\n@@ -70,0 +72,1 @@\n+     _preserved_value_mask(preserved_value_mask),\n@@ -98,2 +101,3 @@\n-                                                bool needs_return_buffer) {\n-  int locs_size  = 64;\n+                                                bool needs_return_buffer,\n+                                                int preserved_value_mask) {\n+  int locs_size = 64;\n@@ -101,1 +105,3 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                          input_registers, output_registers,\n+                          needs_return_buffer, preserved_value_mask);\n@@ -164,0 +170,4 @@\n+  if (_preserved_value_mask != 0) {\n+    locs.set_frame_data(StubLocations::PRESERVED_VALUE_MASK, allocated_frame_size);\n+    allocated_frame_size += 8;\n+  }\n@@ -224,0 +234,22 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  if (_preserved_value_mask != 0) {\n+    __ block_comment(\"{ save thread local\");\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n+\n+    __ ldr(c_rarg0, Address(sp, locs.data_offset(StubLocations::PRESERVED_VALUE_MASK)));\n+    __ movw(c_rarg1, _preserved_value_mask);\n+    __ rt_call(CAST_FROM_FN_PTR(address, DowncallLinker::preserve_values), tmp1);\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n+\n+    __ block_comment(\"} save thread local\");\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  int _preserved_value_mask;\n@@ -60,1 +61,2 @@\n-                         bool needs_return_buffer)\n+                         bool needs_return_buffer,\n+                         int preserved_value_mask)\n@@ -69,0 +71,1 @@\n+     _preserved_value_mask(preserved_value_mask),\n@@ -97,2 +100,3 @@\n-                                                bool needs_return_buffer) {\n-  int locs_size  = 64;\n+                                                bool needs_return_buffer,\n+                                                int preserved_value_mask) {\n+  int locs_size = 64;\n@@ -100,1 +104,3 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                          input_registers, output_registers,\n+                          needs_return_buffer, preserved_value_mask);\n@@ -161,0 +167,4 @@\n+  if (_preserved_value_mask != 0) {\n+    locs.set_frame_data(StubLocations::PRESERVED_VALUE_MASK, allocated_frame_size);\n+    allocated_frame_size += 8;\n+  }\n@@ -223,0 +233,28 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  if (_preserved_value_mask != 0) {\n+    __ block_comment(\"{ save thread local\");\n+    __ vzeroupper();\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n+\n+    __ movptr(c_rarg0, Address(rsp, locs.data_offset(StubLocations::PRESERVED_VALUE_MASK)));\n+    __ movl(c_rarg1, _preserved_value_mask);\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, DowncallLinker::preserve_values)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n+\n+    __ block_comment(\"} save thread local\");\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"downcallLinker.hpp\"\n+\n+#include <cerrno>\n+#ifdef _WIN64\n+#include <Windows.h>\n+#include <Winsock2.h>\n+#endif\n+\n+void DowncallLinker::preserve_values(int32_t* value_ptr, int preserved_value_mask) {\n+  \/\/ keep in synch with jdk.internal.foreign.abi.PreservableValues\n+  enum PreservableValues {\n+    NONE = 0,\n+    GET_LAST_ERROR = 1,\n+    WSA_GET_LAST_ERROR = 1 << 1,\n+    ERRNO = 1 << 2\n+  };\n+#ifdef _WIN64\n+  if (preserved_value_mask & GET_LAST_ERROR) {\n+    *value_ptr = GetLastError();\n+    value_ptr++;\n+  }\n+  if (preserved_value_mask & WSA_GET_LAST_ERROR) {\n+    *value_ptr = WSAGetLastError();\n+    value_ptr++;\n+  }\n+#endif\n+  if (preserved_value_mask & ERRNO) {\n+    *value_ptr = errno;\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -39,1 +39,4 @@\n-                                         bool needs_return_buffer);\n+                                         bool needs_return_buffer,\n+                                         int preserved_value_mask);\n+\n+  static void preserve_values(int32_t* value_ptr, int preserved_value_mask);\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    PRESERVED_VALUE_MASK,\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-                                      jobjectArray arg_moves, jobjectArray ret_moves, jboolean needs_return_buffer))\n+                                      jobjectArray arg_moves, jobjectArray ret_moves,\n+                                      jboolean needs_return_buffer, jint preserved_value_mask))\n@@ -77,2 +78,3 @@\n-  return (jlong) DowncallLinker::make_downcall_stub(\n-    basic_type, pslots, ret_bt, abi, input_regs, output_regs, needs_return_buffer)->code_begin();\n+  return (jlong) DowncallLinker::make_downcall_stub(basic_type, pslots, ret_bt, abi,\n+                                                    input_regs, output_regs,\n+                                                    needs_return_buffer, preserved_value_mask)->code_begin();\n@@ -98,1 +100,1 @@\n-  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"Z)J\", FN_PTR(NEP_makeDowncallStub)},\n+  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"ZI)J\", FN_PTR(NEP_makeDowncallStub)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.PreservableValues;\n@@ -36,0 +37,6 @@\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -296,1 +303,2 @@\n-            permits LinkerOptions.FirstVariadicArg {\n+            permits LinkerOptions.LinkerOptionImpl,\n+                    Option.PreserveValue {\n@@ -306,0 +314,62 @@\n+\n+        \/**\n+         * {@return A linker option used to preserve values that might be overwritten by the runtime\n+         *          before they can be read through conventional means}\n+         * <p>\n+         * A downcall method handle linked with this option will feature an additional {@link MemorySegment}\n+         * parameter directly following the target address parameter. This memory segment represents\n+         * the off-heap memory into which the preserved values are to be written.\n+         *\n+         * @param preservedValues the names of the values to preserve.\n+         * @see PreserveValue#supported()\n+         *\/\n+        static PreserveValue preserveValue(String... preservedValues) {\n+            Set<String> set = Stream.of(preservedValues).collect(Collectors.toSet());\n+            return new LinkerOptions.PreserveValueImpl(set);\n+        }\n+\n+        \/**\n+         * A linker option for preserving a value that might be overwritten by the runtime\n+         * before it can be read through conventional means.\n+         * <p>\n+         * Values are preserved by a downcall method handle on invocation, by writing them\n+         * to a region of off-heap memory provided by the user to the downcall method handle.\n+         * <p>\n+         * The off-heap memory region should have the layout {@linkplain PreserveValue#layout associated}\n+         * with the particular {@code PreserveValue} instance used to link the downcall handle.\n+         * <p>\n+         * Preserved values can be retrieved from this region by constructing var handles\n+         * from the {@linkplain PreserveValue#layout layout} of the region.\n+         * <p>\n+         * The following example demonstrates the use of this linker option:\n+         * {@snippet lang = \"java\":\n+         * MemorySegment targetAddress = ...\n+         * PreserveValue pv = Linker.Option.preserveValue(\"errno\");\n+         * MethodHandle handle = Linker.nativeLinker().downcallHandle(targetAddress, FunctionDescriptor.ofVoid(), pv);\n+         *\n+         * VarHandle errnoHandle = pv.layout().varHandle(PathElement.groupElement(\"errno\"));\n+         * try (MemorySession session = MemorySession.openConfined()) {\n+         *     MemorySegment preservedValues = session.allocate(pv.layout());\n+         *     handle.invoke(preservedValues);\n+         *     int errno = errnoHandle.get(preservedValues);\n+         *     \/\/ use errno\n+         * }\n+         * }\n+         *\/\n+        sealed interface PreserveValue extends Option\n+                                       permits LinkerOptions.PreserveValueImpl {\n+            \/**\n+             * {@return A struct layout that represents the layout of the memory region passed\n+             *          to a downcall handle linked with this {@code PreserveValue} instance}\n+             *\/\n+            StructLayout layout();\n+\n+            \/**\n+             * {@return the names of the values that can be preserved by this implementation}\n+             *\/\n+            static Set<String> supported() {\n+                return Arrays.stream(PreservableValues.values())\n+                             .map(PreservableValues::valueName)\n+                             .collect(Collectors.toSet());\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    final VMStorage preservedValueStorage;\n@@ -52,1 +53,2 @@\n-                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage,\n+                         VMStorage preservedValueStorage) {\n@@ -63,0 +65,1 @@\n+        this.preservedValueStorage = preservedValueStorage;\n@@ -72,0 +75,4 @@\n+\n+    public VMStorage preservedValueStorage() {\n+        return preservedValueStorage;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+        optionSet.validateForDowncall(function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    private final LinkerOptions linkerOptions;\n+\n@@ -47,1 +49,2 @@\n-                           List<List<Binding>> argumentBindings, List<Binding> returnBindings) {\n+                           List<List<Binding>> argumentBindings, List<Binding> returnBindings,\n+                           LinkerOptions linkerOptions) {\n@@ -57,0 +60,1 @@\n+        this.linkerOptions = linkerOptions;\n@@ -184,0 +188,7 @@\n+    public int preservedValueMask() {\n+        return linkerOptions.preservedValues()\n+                .map(PreservableValues::forName)\n+                .mapToInt(PreservableValues::mask)\n+                .reduce(0, (a, b) -> a | b);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private final LinkerOptions linkerOptions;\n@@ -58,1 +59,1 @@\n-    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall) {\n+    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall, LinkerOptions linkerOptions) {\n@@ -61,0 +62,1 @@\n+        this.linkerOptions = linkerOptions;\n@@ -98,0 +100,5 @@\n+            if (linkerOptions.hasPreservedValues()) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                        Binding.unboxAddress(),\n+                        Binding.vmStore(abi.preservedValueStorage(), long.class)));\n+            }\n@@ -120,1 +127,1 @@\n-                returnBufferSize, allocationSize, inputBindings, outputBindings);\n+                returnBufferSize, allocationSize, inputBindings, outputBindings, linkerOptions);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-            callingSequence.needsReturnBuffer()\n+            callingSequence.needsReturnBuffer(),\n+            callingSequence.preservedValueMask()\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.FunctionDescriptor;\n@@ -28,0 +29,3 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.util.Comparator;\n@@ -31,0 +35,3 @@\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -35,1 +42,1 @@\n-    private final Map<Class<?>, Linker.Option> optionsMap;\n+    private final Map<Class<?>, LinkerOptionImpl> optionsMap;\n@@ -37,1 +44,1 @@\n-    private LinkerOptions(Map<Class<?>, Linker.Option> optionsMap) {\n+    private LinkerOptions(Map<Class<?>, LinkerOptionImpl> optionsMap) {\n@@ -42,1 +49,1 @@\n-        Map<Class<?>, Linker.Option> optionMap = new HashMap<>();\n+        Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n@@ -48,1 +55,1 @@\n-            optionMap.put(option.getClass(), option);\n+            optionMap.put(option.getClass(), (LinkerOptionImpl) option);\n@@ -58,0 +65,4 @@\n+    public void validateForDowncall(FunctionDescriptor descriptor) {\n+        optionsMap.values().forEach(v -> v.validateForDowncall(descriptor));\n+    }\n+\n@@ -67,0 +78,9 @@\n+    public boolean hasPreservedValues() {\n+        return getOption(PreserveValueImpl.class) != null;\n+    }\n+\n+    public Stream<String> preservedValues() {\n+        PreserveValueImpl stl = getOption(PreserveValueImpl.class);\n+        return stl == null ? Stream.empty() : stl.saved().stream();\n+    }\n+\n@@ -79,1 +99,44 @@\n-    public record FirstVariadicArg(int index) implements Linker.Option { }\n+    public sealed interface LinkerOptionImpl extends Linker.Option\n+                                             permits FirstVariadicArg,\n+                                                     PreserveValueImpl {\n+        default void validateForDowncall(FunctionDescriptor descriptor) {\n+            throw new IllegalArgumentException(\"Not supported for downcall: \" + this);\n+        }\n+    }\n+\n+    public record FirstVariadicArg(int index) implements LinkerOptionImpl {\n+        @Override\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            if (index < 0 || index > descriptor.argumentLayouts().size()) {\n+                throw new IllegalArgumentException(\"Index '\" + index + \"' not in bounds for descriptor: \" + descriptor);\n+            }\n+        }\n+    }\n+\n+    public record PreserveValueImpl(Set<String> saved) implements LinkerOptionImpl, Linker.Option.PreserveValue {\n+\n+        @Override\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            for (String save : saved) {\n+                if (!PreservableValues.isSupported(save)) {\n+                    throw new IllegalArgumentException(\"Unknown name: \" + save\n+                            + \", must be one of: \"\n+                            + Stream.of(PreservableValues.values())\n+                                    .map(PreservableValues::valueName)\n+                                    .collect(Collectors.joining(\",\")));\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public StructLayout layout() {\n+            return MemoryLayout.structLayout(\n+                saved.stream()\n+                      .map(PreservableValues::forName)\n+                      .sorted(Comparator.comparingInt(PreservableValues::ordinal))\n+                      .map(PreservableValues::layout)\n+                      .toArray(MemoryLayout[]::new)\n+            );\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":68,"deletions":5,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                            boolean needsReturnBuffer) {}\n+                            boolean needsReturnBuffer, int preservedValueMask) {}\n@@ -59,1 +59,3 @@\n-                                        MethodType methodType, boolean needsReturnBuffer) {\n+                                        MethodType methodType,\n+                                        boolean needsReturnBuffer,\n+                                        int preservedValueMask) {\n@@ -63,0 +65,1 @@\n+        checkType(methodType, needsReturnBuffer, preservedValueMask);\n@@ -64,4 +67,1 @@\n-        assert (methodType.parameterType(0) == long.class) : \"Address expected\";\n-        assert (!needsReturnBuffer || methodType.parameterType(1) == long.class) : \"return buffer address expected\";\n-\n-        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer);\n+        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer, preservedValueMask);\n@@ -69,1 +69,1 @@\n-            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer);\n+            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer, preservedValueMask);\n@@ -76,0 +76,11 @@\n+    private static void checkType(MethodType methodType, boolean needsReturnBuffer, int preservedValueMask) {\n+        if (methodType.parameterType(0) != long.class) {\n+            throw new IllegalArgumentException(\"Address expected as first param: \" + methodType);\n+        }\n+        int checkIdx = 1;\n+        if ((needsReturnBuffer && methodType.parameterType(checkIdx++) != long.class)\n+            || (preservedValueMask != 0 && methodType.parameterType(checkIdx) != long.class)) {\n+            throw new IllegalArgumentException(\"return buffer and\/or preserved value address expected: \" + methodType);\n+        }\n+    }\n+\n@@ -78,1 +89,2 @@\n-                                                boolean needsReturnBuffer);\n+                                                boolean needsReturnBuffer,\n+                                                int preservedValueMask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.foreign.ValueLayout;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public enum PreservableValues {\n+    GET_LAST_ERROR    (\"GetLastError\",    JAVA_INT, 1 << 0),\n+    WSA_GET_LAST_ERROR(\"WSAGetLastError\", JAVA_INT, 1 << 1),\n+    ERRNO             (\"errno\",           JAVA_INT, 1 << 2);\n+\n+    private final String valueName;\n+    private final ValueLayout layout;\n+    private final int mask;\n+\n+    PreservableValues(String valueName, ValueLayout layout, int mask) {\n+        this.valueName = valueName;\n+        this.layout = layout.withName(valueName);\n+        this.mask = mask;\n+    }\n+\n+    public static boolean isSupported(String name) {\n+        return Stream.of(values()).anyMatch(stl -> stl.valueName().equals(name));\n+    }\n+\n+    public static PreservableValues forName(String name) {\n+        return Stream.of(values())\n+                .filter(stl -> stl.valueName().equals(name))\n+                .findAny()\n+                .orElseThrow(() -> new IllegalArgumentException(\"Unknown name: \" + name));\n+    }\n+\n+    public String valueName() {\n+        return valueName;\n+    }\n+\n+    public ValueLayout layout() {\n+        return layout;\n+    }\n+\n+    public int mask() {\n+        return mask;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/PreservableValues.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -30,1 +30,2 @@\n-    RETURN_BUFFER;\n+    RETURN_BUFFER,\n+    PRESERVED_VALUE_MASK;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER));\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.PRESERVED_VALUE_MASK.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall);\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,2 @@\n-            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER));\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.PRESERVED_VALUE_MASK.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,1 +87,5 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(CSysV, forUpcall);\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(CSysV, forUpcall, options);\n@@ -118,2 +122,2 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        return CallArranger.arrangeDowncall(inferredMethodType, function);\n+        return CallArranger.arrangeDowncall(inferredMethodType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            final CallingSequenceBuilder csb = new CallingSequenceBuilder(CWindows, forUpcall);\n+            final CallingSequenceBuilder csb = new CallingSequenceBuilder(CWindows, forUpcall, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n@@ -115,2 +117,2 @@\n-    public static MethodHandle downcallHandle(String symbol, FunctionDescriptor desc) {\n-        return LINKER.downcallHandle(findNativeOrThrow(symbol), desc);\n+    public static MethodHandle downcallHandle(String symbol, FunctionDescriptor desc, Linker.Option... options) {\n+        return LINKER.downcallHandle(findNativeOrThrow(symbol), desc, options);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng TestLinker\n+ * @run junit TestLinker\n@@ -30,1 +30,3 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -36,1 +38,3 @@\n-import static org.testng.Assert.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -50,0 +54,21 @@\n+    @ParameterizedTest\n+    @ValueSource(ints={ -1, 42 })\n+    public void testInvalidOption(int invalidIndex) {\n+        Linker.Option option = Linker.Option.firstVariadicArg(invalidIndex);\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid();\n+        IllegalArgumentException thrown = assertThrows(\n+               IllegalArgumentException.class,\n+               () -> Linker.nativeLinker().downcallHandle(desc, option));\n+        assertTrue(thrown.getMessage().matches(\".*not in bounds for descriptor.*\"));\n+    }\n+\n+    @Test\n+    public void testInvalidPreservedValueName() {\n+        Linker.Option option = Linker.Option.preserveValue(\"foo\");\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid();\n+        IllegalArgumentException thrown = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> Linker.nativeLinker().downcallHandle(desc, option));\n+        assertTrue(thrown.getMessage().matches(\".*Unknown name.*\"));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestPreserveValue\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestPreserveValue extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"PreserveValue\");\n+        if (IS_WINDOWS) {\n+            String system32 = System.getenv(\"SystemRoot\") + \"\\\\system32\";\n+            System.load(system32 + \"\\\\Kernel32.dll\");\n+            System.load(system32 + \"\\\\Ws2_32.dll\");\n+        }\n+    }\n+\n+    private record SavedThreadLocalCase(String nativeTarget, String threadLocalName) {}\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testSavedThreadLocal(SavedThreadLocalCase testCase) throws Throwable {\n+        Linker.Option.PreserveValue stl = Linker.Option.preserveValue(testCase.threadLocalName());\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), FunctionDescriptor.ofVoid(JAVA_INT), stl);\n+\n+        VarHandle errnoHandle = stl.layout().varHandle(groupElement(testCase.threadLocalName()));\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment saveSeg = session.allocate(stl.layout());\n+            int testValue = 42;\n+            handle.invoke(saveSeg, testValue);\n+            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            assertEquals(savedErrno, testValue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        List<SavedThreadLocalCase> cases = new ArrayList<>();\n+\n+        cases.add(new SavedThreadLocalCase(\"set_errno\", \"errno\"));\n+        if (IS_WINDOWS) {\n+            cases.add(new SavedThreadLocalCase(\"SetLastError\", \"GetLastError\"));\n+            cases.add(new SavedThreadLocalCase(\"WSASetLastError\", \"WSAGetLastError\"));\n+        }\n+\n+        return cases.stream().map(tc -> new Object[] {tc}).toArray(Object[][]::new);\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/preservevalue\/TestPreserveValue.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void set_errno(int value) {\n+    errno = value;\n+}\n","filename":"test\/jdk\/java\/foreign\/preservevalue\/libPreserveValue.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}