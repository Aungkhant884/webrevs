{"files":[{"patch":"@@ -49,0 +49,1 @@\n+  int _saved_value_mask;\n@@ -61,1 +62,2 @@\n-                         bool needs_return_buffer)\n+                         bool needs_return_buffer,\n+                         int saved_value_mask)\n@@ -70,0 +72,1 @@\n+     _saved_value_mask(saved_value_mask),\n@@ -98,2 +101,3 @@\n-                                                bool needs_return_buffer) {\n-  int locs_size  = 64;\n+                                                bool needs_return_buffer,\n+                                                int saved_value_mask) {\n+  int locs_size = 64;\n@@ -101,1 +105,3 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                          input_registers, output_registers,\n+                          needs_return_buffer, saved_value_mask);\n@@ -164,0 +170,4 @@\n+  if (_saved_value_mask != 0) {\n+    locs.set_frame_data(StubLocations::SAVED_VALUE_MASK, allocated_frame_size);\n+    allocated_frame_size += 8;\n+  }\n@@ -224,0 +234,22 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  if (_saved_value_mask != 0) {\n+    __ block_comment(\"{ save thread local\");\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n+\n+    __ ldr(c_rarg0, Address(sp, locs.data_offset(StubLocations::SAVED_VALUE_MASK)));\n+    __ movw(c_rarg1, _saved_value_mask);\n+    __ rt_call(CAST_FROM_FN_PTR(address, DowncallLinker::save_values), tmp1);\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n+\n+    __ block_comment(\"} save thread local\");\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  int _saved_value_mask;\n@@ -60,1 +61,2 @@\n-                         bool needs_return_buffer)\n+                         bool needs_return_buffer,\n+                         int saved_value_mask)\n@@ -69,0 +71,1 @@\n+     _saved_value_mask(saved_value_mask),\n@@ -97,2 +100,3 @@\n-                                                bool needs_return_buffer) {\n-  int locs_size  = 64;\n+                                                bool needs_return_buffer,\n+                                                int saved_value_mask) {\n+  int locs_size = 64;\n@@ -100,1 +104,3 @@\n-  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi, input_registers, output_registers, needs_return_buffer);\n+  DowncallStubGenerator g(&code, signature, num_args, ret_bt, abi,\n+                          input_registers, output_registers,\n+                          needs_return_buffer, saved_value_mask);\n@@ -161,0 +167,4 @@\n+  if (_saved_value_mask != 0) {\n+    locs.set_frame_data(StubLocations::SAVED_VALUE_MASK, allocated_frame_size);\n+    allocated_frame_size += 8;\n+  }\n@@ -223,0 +233,28 @@\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  if (_saved_value_mask != 0) {\n+    __ block_comment(\"{ save thread local\");\n+    __ vzeroupper();\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n+\n+    __ movptr(c_rarg0, Address(rsp, locs.data_offset(StubLocations::SAVED_VALUE_MASK)));\n+    __ movl(c_rarg1, _saved_value_mask);\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, DowncallLinker::save_values)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n+\n+    if(should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n+\n+    __ block_comment(\"} save thread local\");\n+  }\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"downcallLinker.hpp\"\n+\n+#include <cerrno>\n+#ifdef _WIN64\n+#include <Windows.h>\n+#include <Winsock2.h>\n+#endif\n+\n+void DowncallLinker::save_values(int32_t* value_ptr, int saved_value_mask) {\n+  \/\/ keep in synch with jdk.internal.foreign.abi.PreservableValues\n+  enum PreservableValues {\n+    NONE = 0,\n+    GET_LAST_ERROR = 1,\n+    WSA_GET_LAST_ERROR = 1 << 1,\n+    ERRNO = 1 << 2\n+  };\n+#ifdef _WIN64\n+  if (saved_value_mask & GET_LAST_ERROR) {\n+    *value_ptr = GetLastError();\n+    value_ptr++;\n+  }\n+  if (saved_value_mask & WSA_GET_LAST_ERROR) {\n+    *value_ptr = WSAGetLastError();\n+    value_ptr++;\n+  }\n+#endif\n+  if (saved_value_mask & ERRNO) {\n+    *value_ptr = errno;\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -39,1 +39,4 @@\n-                                         bool needs_return_buffer);\n+                                         bool needs_return_buffer,\n+                                         int saved_value_mask);\n+\n+  static void save_values(int32_t* value_ptr, int saved_value_mask);\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    SAVED_VALUE_MASK,\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-                                      jobjectArray arg_moves, jobjectArray ret_moves, jboolean needs_return_buffer))\n+                                      jobjectArray arg_moves, jobjectArray ret_moves,\n+                                      jboolean needs_return_buffer, jint saved_value_mask))\n@@ -77,2 +78,3 @@\n-  return (jlong) DowncallLinker::make_downcall_stub(\n-    basic_type, pslots, ret_bt, abi, input_regs, output_regs, needs_return_buffer)->code_begin();\n+  return (jlong) DowncallLinker::make_downcall_stub(basic_type, pslots, ret_bt, abi,\n+                                                    input_regs, output_regs,\n+                                                    needs_return_buffer, saved_value_mask)->code_begin();\n@@ -98,1 +100,1 @@\n-  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"Z)J\", FN_PTR(NEP_makeDowncallStub)},\n+  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"ZI)J\", FN_PTR(NEP_makeDowncallStub)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.SavableValues;\n@@ -36,0 +37,4 @@\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -296,1 +301,2 @@\n-            permits LinkerOptions.FirstVariadicArg {\n+            permits LinkerOptions.LinkerOptionImpl,\n+                    Option.SaveValues {\n@@ -306,0 +312,64 @@\n+\n+        \/**\n+         * {@return A linker option used to save values that might be overwritten by the runtime\n+         *          before they can be read through conventional means}\n+         * <p>\n+         * A downcall method handle linked with this option will feature an additional {@link MemorySegment}\n+         * parameter directly following the target address parameter. This memory segment must be a\n+         * native segment into which the saved values are to be written.\n+         *\n+         * @param savedValues the names of the values to save.\n+         * @see SaveValues#supported()\n+         *\/\n+        static SaveValues saveValues(String... savedValues) {\n+            Set<SavableValues> set = Stream.of(savedValues)\n+                    .map(SavableValues::forName)\n+                    .collect(Collectors.toSet());\n+            return new LinkerOptions.SaveValuesImpl(set);\n+        }\n+\n+        \/**\n+         * A linker option for saving a value that might be overwritten by the runtime\n+         * before it can be read through conventional means.\n+         * <p>\n+         * Values are saved by a downcall method handle on invocation, by writing them\n+         * to a region of off-heap memory provided by the user to the downcall method handle.\n+         * <p>\n+         * The off-heap memory region should have the layout {@linkplain SaveValues#layout associated}\n+         * with the particular {@code SaveValues} instance used to link the downcall handle.\n+         * <p>\n+         * Saved values can be retrieved from this region by constructing var handles\n+         * from the {@linkplain SaveValues#layout layout} of the region.\n+         * <p>\n+         * The following example demonstrates the use of this linker option:\n+         * {@snippet lang = \"java\":\n+         * MemorySegment targetAddress = ...\n+         * SaveValues sv = Linker.Option.saveValues(\"errno\");\n+         * MethodHandle handle = Linker.nativeLinker().downcallHandle(targetAddress, FunctionDescriptor.ofVoid(), sv);\n+         *\n+         * VarHandle errnoHandle = sv.layout().varHandle(PathElement.groupElement(\"errno\"));\n+         * try (MemorySession session = MemorySession.openConfined()) {\n+         *     MemorySegment savedValues = session.allocate(svlayout());\n+         *     handle.invoke(savedValues);\n+         *     int errno = errnoHandle.get(savedValues);\n+         *     \/\/ use errno\n+         * }\n+         * }\n+         *\/\n+        sealed interface SaveValues extends Option\n+                                    permits LinkerOptions.SaveValuesImpl {\n+            \/**\n+             * {@return A struct layout that represents the layout of the native segment passed\n+             *          to a downcall handle linked with this {@code SaveValues} instance}\n+             *\/\n+            StructLayout layout();\n+\n+            \/**\n+             * {@return the names of the values that can be saved by this implementation}\n+             *\/\n+            static Set<String> supported() {\n+                return Arrays.stream(SavableValues.values())\n+                             .map(SavableValues::valueName)\n+                             .collect(Collectors.toSet());\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    final VMStorage savedValueStorage;\n@@ -52,1 +53,2 @@\n-                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+                         VMStorage targetAddrStorage, VMStorage retBufAddrStorage,\n+                         VMStorage savedValueStorage) {\n@@ -63,0 +65,1 @@\n+        this.savedValueStorage = savedValueStorage;\n@@ -72,0 +75,4 @@\n+\n+    public VMStorage savedValueStorage() {\n+        return savedValueStorage;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        LinkerOptions optionSet = LinkerOptions.of(options);\n+        LinkerOptions optionSet = LinkerOptions.forDowncall(function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    private final LinkerOptions linkerOptions;\n+\n@@ -47,1 +49,2 @@\n-                           List<List<Binding>> argumentBindings, List<Binding> returnBindings) {\n+                           List<List<Binding>> argumentBindings, List<Binding> returnBindings,\n+                           LinkerOptions linkerOptions) {\n@@ -57,0 +60,1 @@\n+        this.linkerOptions = linkerOptions;\n@@ -184,0 +188,6 @@\n+    public int savedValueMask() {\n+        return linkerOptions.saveValues()\n+                .mapToInt(SavableValues::mask)\n+                .reduce(0, (a, b) -> a | b);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private final LinkerOptions linkerOptions;\n@@ -58,1 +59,1 @@\n-    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall) {\n+    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall, LinkerOptions linkerOptions) {\n@@ -61,0 +62,1 @@\n+        this.linkerOptions = linkerOptions;\n@@ -98,0 +100,5 @@\n+            if (linkerOptions.hasSavedValues()) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                        Binding.unboxAddress(),\n+                        Binding.vmStore(abi.savedValueStorage(), long.class)));\n+            }\n@@ -120,1 +127,1 @@\n-                returnBufferSize, allocationSize, inputBindings, outputBindings);\n+                returnBufferSize, allocationSize, inputBindings, outputBindings, linkerOptions);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-            callingSequence.needsReturnBuffer()\n+            callingSequence.needsReturnBuffer(),\n+            callingSequence.savedValueMask()\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.FunctionDescriptor;\n@@ -28,0 +29,3 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.util.Comparator;\n@@ -31,0 +35,2 @@\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -34,2 +40,2 @@\n-    private static final LinkerOptions EMPTY = LinkerOptions.of();\n-    private final Map<Class<?>, Linker.Option> optionsMap;\n+    private static final LinkerOptions EMPTY = new LinkerOptions(Map.of());\n+    private final Map<Class<?>, LinkerOptionImpl> optionsMap;\n@@ -37,1 +43,1 @@\n-    private LinkerOptions(Map<Class<?>, Linker.Option> optionsMap) {\n+    private LinkerOptions(Map<Class<?>, LinkerOptionImpl> optionsMap) {\n@@ -41,2 +47,2 @@\n-    public static LinkerOptions of(Linker.Option... options) {\n-        Map<Class<?>, Linker.Option> optionMap = new HashMap<>();\n+    public static LinkerOptions forDowncall(FunctionDescriptor desc, Linker.Option... options) {\n+        Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n@@ -48,1 +54,3 @@\n-            optionMap.put(option.getClass(), option);\n+            LinkerOptionImpl opImpl = (LinkerOptionImpl) option;\n+            opImpl.validateForDowncall(desc);\n+            optionMap.put(option.getClass(), opImpl);\n@@ -67,0 +75,9 @@\n+    public boolean hasSavedValues() {\n+        return getOption(SaveValuesImpl.class) != null;\n+    }\n+\n+    public Stream<SavableValues> saveValues() {\n+        SaveValuesImpl stl = getOption(SaveValuesImpl.class);\n+        return stl == null ? Stream.empty() : stl.saved().stream();\n+    }\n+\n@@ -79,1 +96,35 @@\n-    public record FirstVariadicArg(int index) implements Linker.Option { }\n+    public sealed interface LinkerOptionImpl extends Linker.Option\n+                                             permits FirstVariadicArg,\n+                                                     SaveValuesImpl {\n+        default void validateForDowncall(FunctionDescriptor descriptor) {\n+            throw new IllegalArgumentException(\"Not supported for downcall: \" + this);\n+        }\n+    }\n+\n+    public record FirstVariadicArg(int index) implements LinkerOptionImpl {\n+        @Override\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            if (index < 0 || index > descriptor.argumentLayouts().size()) {\n+                throw new IllegalArgumentException(\"Index '\" + index + \"' not in bounds for descriptor: \" + descriptor);\n+            }\n+        }\n+    }\n+\n+    public record SaveValuesImpl(Set<SavableValues> saved) implements LinkerOptionImpl, Linker.Option.SaveValues {\n+\n+        @Override\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            \/\/ done during construction\n+        }\n+\n+        @Override\n+        public StructLayout layout() {\n+            return MemoryLayout.structLayout(\n+                saved.stream()\n+                      .sorted(Comparator.comparingInt(SavableValues::ordinal))\n+                      .map(SavableValues::layout)\n+                      .toArray(MemoryLayout[]::new)\n+            );\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":58,"deletions":7,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-                            boolean needsReturnBuffer) {}\n+                            boolean needsReturnBuffer, int savedValueMask) {}\n@@ -59,1 +59,3 @@\n-                                        MethodType methodType, boolean needsReturnBuffer) {\n+                                        MethodType methodType,\n+                                        boolean needsReturnBuffer,\n+                                        int savedValueMask) {\n@@ -63,0 +65,1 @@\n+        checkType(methodType, needsReturnBuffer, savedValueMask);\n@@ -64,4 +67,1 @@\n-        assert (methodType.parameterType(0) == long.class) : \"Address expected\";\n-        assert (!needsReturnBuffer || methodType.parameterType(1) == long.class) : \"return buffer address expected\";\n-\n-        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer);\n+        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer, savedValueMask);\n@@ -69,1 +69,1 @@\n-            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer);\n+            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer, savedValueMask);\n@@ -76,0 +76,11 @@\n+    private static void checkType(MethodType methodType, boolean needsReturnBuffer, int savedValueMask) {\n+        if (methodType.parameterType(0) != long.class) {\n+            throw new IllegalArgumentException(\"Address expected as first param: \" + methodType);\n+        }\n+        int checkIdx = 1;\n+        if ((needsReturnBuffer && methodType.parameterType(checkIdx++) != long.class)\n+            || (savedValueMask != 0 && methodType.parameterType(checkIdx) != long.class)) {\n+            throw new IllegalArgumentException(\"return buffer and\/or preserved value address expected: \" + methodType);\n+        }\n+    }\n+\n@@ -78,1 +89,2 @@\n-                                                boolean needsReturnBuffer);\n+                                                boolean needsReturnBuffer,\n+                                                int savedValueMask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.foreign.ValueLayout;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+\n+public enum SavableValues {\n+    GET_LAST_ERROR    (\"GetLastError\",    JAVA_INT, 1 << 0),\n+    WSA_GET_LAST_ERROR(\"WSAGetLastError\", JAVA_INT, 1 << 1),\n+    ERRNO             (\"errno\",           JAVA_INT, 1 << 2);\n+\n+    private final String valueName;\n+    private final ValueLayout layout;\n+    private final int mask;\n+\n+    SavableValues(String valueName, ValueLayout layout, int mask) {\n+        this.valueName = valueName;\n+        this.layout = layout.withName(valueName);\n+        this.mask = mask;\n+    }\n+\n+    public static SavableValues forName(String name) {\n+        return Stream.of(values())\n+                .filter(stl -> stl.valueName().equals(name))\n+                .findAny()\n+                .orElseThrow(() -> new IllegalArgumentException(\n+                        \"Unknown name: \" + name +\", must be one of: \"\n+                            + Stream.of(SavableValues.values())\n+                                    .map(SavableValues::valueName)\n+                                    .collect(Collectors.joining(\", \"))));\n+    }\n+\n+    public String valueName() {\n+        return valueName;\n+    }\n+\n+    public ValueLayout layout() {\n+        return layout;\n+    }\n+\n+    public int mask() {\n+        return mask;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SavableValues.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -30,1 +30,2 @@\n-    RETURN_BUFFER;\n+    RETURN_BUFFER,\n+    SAVED_VALUE_MASK;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER));\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.SAVED_VALUE_MASK.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall);\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,2 @@\n-            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER));\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER),\n+            StubLocations.SAVED_VALUE_MASK.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,1 +87,5 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(CSysV, forUpcall);\n+        return getBindings(mt, cDesc, forUpcall, LinkerOptions.empty());\n+    }\n+\n+    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall, LinkerOptions options) {\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(CSysV, forUpcall, options);\n@@ -118,2 +122,2 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, false);\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, false, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        return CallArranger.arrangeDowncall(inferredMethodType, function);\n+        return CallArranger.arrangeDowncall(inferredMethodType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            final CallingSequenceBuilder csb = new CallingSequenceBuilder(CWindows, forUpcall);\n+            final CallingSequenceBuilder csb = new CallingSequenceBuilder(CWindows, forUpcall, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    public static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n@@ -115,2 +117,2 @@\n-    public static MethodHandle downcallHandle(String symbol, FunctionDescriptor desc) {\n-        return LINKER.downcallHandle(findNativeOrThrow(symbol), desc);\n+    public static MethodHandle downcallHandle(String symbol, FunctionDescriptor desc, Linker.Option... options) {\n+        return LINKER.downcallHandle(findNativeOrThrow(symbol), desc, options);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -50,0 +51,23 @@\n+    @DataProvider\n+    public static Object[][] invalidIndexCases() {\n+        return new Object[][]{\n+                { -1, },\n+                { 42, },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalidIndexCases\",\n+          expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*not in bounds for descriptor.*\")\n+    public void testInvalidOption(int invalidIndex) {\n+        Linker.Option option = Linker.Option.firstVariadicArg(invalidIndex);\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid();\n+        Linker.nativeLinker().downcallHandle(desc, option); \/\/ throws\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Unknown name.*\")\n+    public void testInvalidPreservedValueName() {\n+        Linker.Option option = Linker.Option.saveValues(\"foo\"); \/\/ throws\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n@@ -432,1 +432,1 @@\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(1)));\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, LinkerOptions.of(firstVariadicArg(2)));\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(2)));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestSaveValues\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestSaveValues extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"SaveValues\");\n+        if (IS_WINDOWS) {\n+            String system32 = System.getenv(\"SystemRoot\") + \"\\\\system32\";\n+            System.load(system32 + \"\\\\Kernel32.dll\");\n+            System.load(system32 + \"\\\\Ws2_32.dll\");\n+        }\n+    }\n+\n+    private record SaveValuesCase(String nativeTarget, String threadLocalName) {}\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testSavedThreadLocal(SaveValuesCase testCase) throws Throwable {\n+        Linker.Option.SaveValues stl = Linker.Option.saveValues(testCase.threadLocalName());\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), FunctionDescriptor.ofVoid(JAVA_INT), stl);\n+\n+        VarHandle errnoHandle = stl.layout().varHandle(groupElement(testCase.threadLocalName()));\n+\n+        try (MemorySession session = MemorySession.openConfined()) {\n+            MemorySegment saveSeg = session.allocate(stl.layout());\n+            int testValue = 42;\n+            handle.invoke(saveSeg, testValue);\n+            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            assertEquals(savedErrno, testValue);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] cases() {\n+        List<SaveValuesCase> cases = new ArrayList<>();\n+\n+        cases.add(new SaveValuesCase(\"set_errno\", \"errno\"));\n+        if (IS_WINDOWS) {\n+            cases.add(new SaveValuesCase(\"SetLastError\", \"GetLastError\"));\n+            cases.add(new SaveValuesCase(\"WSASetLastError\", \"WSAGetLastError\"));\n+        }\n+\n+        return cases.stream().map(tc -> new Object[] {tc}).toArray(Object[][]::new);\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/savevalues\/TestSaveValues.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void set_errno(int value) {\n+    errno = value;\n+}\n","filename":"test\/jdk\/java\/foreign\/savevalues\/libSaveValues.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}