{"files":[{"patch":"@@ -153,1 +153,1 @@\n-    protected <T> DynamicConstantDesc<T> decorateLayoutConstant(DynamicConstantDesc<T> desc) {\n+    <T> DynamicConstantDesc<T> decorateLayoutConstant(DynamicConstantDesc<T> desc) {\n@@ -166,1 +166,1 @@\n-    protected boolean hasNaturalAlignment() {\n+    boolean hasNaturalAlignment() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.constant.DynamicConstantDesc;\n@@ -37,1 +36,0 @@\n-import java.nio.ByteOrder;\n@@ -39,1 +37,0 @@\n-import java.util.Map;\n@@ -41,1 +38,0 @@\n-import java.util.Optional;\n@@ -44,1 +40,0 @@\n-import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n@@ -51,2 +46,2 @@\n- *\n- * <p>There are two components that go into linking a foreign function: a method type, and\n+ * <p>\n+ * There are two components that go into linking a foreign function: a method type, and\n@@ -56,9 +51,12 @@\n- * signature and classification information (via custom layout attributes), so that linking can take place.\n- * Memory layout attributes are used in the function descriptor to attach ABI classification meta-data to\n- * memory layouts, which are required for linking. Clients of this API should build function descriptors\n- * using the predefined memory layout constants (based on a subset of the built-in types provided by the C language),\n- * found in this interface; a failure to do so might result in linkage errors, given that linking requires additional\n- * classification information to determine, for instance, how arguments should be loaded into registers during a\n- * foreign function call.<\/p>\n- *\n- * <p>Implementations of this interface support the following primitive carrier types:\n+ * signature and classification information (via a custom layout attributes, see {@link TypeKind}), so that linking can take place.\n+ * Memory layout attributes are used in the function descriptor to attach ABI classification meta-data to memory layouts,\n+ * which are required for linking.\n+ * <p>\n+ * Clients of this API can build function descriptors using the predefined memory layout constants\n+ * (based on a subset of the built-in types provided by the C language), found in this interface; alternatively,\n+ * they can also decorate existing value layouts using the required {@link TypeKind} classification attribute\n+ * (this can be done using the {@link MemoryLayout#withAttribute(String, Constable)} method). A failure to do so might\n+ * result in linkage errors, given that linking requires additional classification information to determine, for instance,\n+ * how arguments should be loaded into registers during a foreign function call.\n+ * <p>\n+ * Implementations of this interface support the following primitive carrier types:\n@@ -68,4 +66,4 @@\n- * carrier type can be used to match the native {@code va_list} type.<\/p>\n- *\n- * <p>The function descriptor used in linking contains a memory layout to match each carrier type.\n- * There are some restrictions on the carrier type and memory layout combinations that are allowed:<\/p>\n+ * carrier type can be used to match the native {@code va_list} type.\n+ * <p>\n+ * The function descriptor used in linking contains a memory layout to match each carrier type.\n+ * There are some restrictions on the carrier type and memory layout combinations that are allowed:\n@@ -97,1 +95,1 @@\n- * argument in a specialized function descriptor<\/p>\n+ * argument in a specialized function descriptor\n@@ -154,1 +152,1 @@\n-    CValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n+    ValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n@@ -158,1 +156,1 @@\n-    CValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n+    ValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n@@ -162,1 +160,1 @@\n-    CValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n+    ValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n@@ -166,1 +164,1 @@\n-    CValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n+    ValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n@@ -170,1 +168,1 @@\n-    CValueLayout C_LONGLONG = pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);\n+    ValueLayout C_LONGLONG = pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);\n@@ -174,1 +172,1 @@\n-    CValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n+    ValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n@@ -178,1 +176,1 @@\n-    CValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n+    ValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n@@ -182,1 +180,1 @@\n-    CValueLayout C_LONGDOUBLE = pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);\n+    ValueLayout C_LONGDOUBLE = pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);\n@@ -186,1 +184,1 @@\n-    CValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n+    ValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n@@ -710,2 +708,4 @@\n-     * Subclass of {@link ValueLayout} that contains information needed when linking\n-     * downcalls or upcalls.\n+     * A C type kind. Each kind corresponds to a particular C language builtin type, and can be attached to\n+     * {@link ValueLayout} instances using the {@link MemoryLayout#withAttribute(String, Constable)} in order\n+     * to obtain a layout which can be classified accordingly by {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}\n+     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor)}.\n@@ -713,1 +713,1 @@\n-    class CValueLayout extends ValueLayout {\n+    enum TypeKind {\n@@ -715,2 +715,1 @@\n-         * The kind of {@link CValueLayout}. Each kind corresponds to a particular\n-         * C language builtin type.\n+         * A kind corresponding to the C {@code char} type\n@@ -718,89 +717,1 @@\n-        public enum Kind {\n-            \/**\n-             * A kind corresponding to the C {@code char} type\n-             *\/\n-            CHAR(findBSM(\"C_CHAR\"), true),\n-            \/**\n-             * A kind corresponding to the C {@code short} type\n-             *\/\n-            SHORT(findBSM(\"C_SHORT\"), true),\n-            \/**\n-             * A kind corresponding to the C {@code int} type\n-             *\/\n-            INT(findBSM(\"C_INT\"), true),\n-            \/**\n-             * A kind corresponding to the C {@code long} type\n-             *\/\n-            LONG(findBSM(\"C_LONG\"), true),\n-            \/**\n-             * A kind corresponding to the C {@code long long} type\n-             *\/\n-            LONGLONG(findBSM(\"C_LONGLONG\"), true),\n-            \/**\n-             * A kind corresponding to the C {@code float} type\n-             *\/\n-            FLOAT(findBSM(\"C_FLOAT\"), false),\n-            \/**\n-             * A kind corresponding to the C {@code double} type\n-             *\/\n-            DOUBLE(findBSM(\"C_DOUBLE\"), false),\n-            \/**\n-             * A kind corresponding to the C {@code long double} type\n-             *\/\n-            LONGDOUBLE(findBSM(\"C_LONGDOUBLE\"), false),\n-            \/**\n-             * A kind corresponding to the a C pointer type\n-             *\/\n-            POINTER(findBSM(\"C_POINTER\"), false);\n-\n-            private final DynamicConstantDesc<ValueLayout> bsm;\n-            private final boolean isIntegral;\n-\n-            Kind(DynamicConstantDesc<ValueLayout> bsm, boolean isIntegral) {\n-                this.bsm = bsm;\n-                this.isIntegral = isIntegral;\n-            }\n-\n-            private DynamicConstantDesc<ValueLayout> bsm() {\n-                return bsm;\n-            }\n-\n-            \/**\n-             * Is this kind integral?\n-             *\n-             * @return true if this kind is integral\n-             *\/\n-            public boolean isIntergral() {\n-                return isIntegral;\n-            }\n-\n-            \/**\n-             * Is this kind a floating point type?\n-             *\n-             * @return true if this kind is a floating point type\n-             *\/\n-            public boolean isFloat() {\n-                return !isIntergral() && !isPointer();\n-            }\n-\n-            \/**\n-             * Is this kind a pointer kind?\n-             *\n-             * @return true if this kind is a pointer kind\n-             *\/\n-            public boolean isPointer() {\n-                return this == POINTER;\n-            }\n-\n-            private static DynamicConstantDesc<ValueLayout> findBSM(String fieldName) {\n-                return DynamicConstantDesc.ofNamed(\n-                    BSM_GET_STATIC_FINAL,\n-                    fieldName,\n-                    CValueLayout.class.describeConstable().orElseThrow(),\n-                    CLinker.class.describeConstable().orElseThrow()\n-                );\n-            }\n-        }\n-\n-        private final Kind kind;\n-\n+        CHAR(true),\n@@ -808,7 +719,1 @@\n-         * CValueLayout constructor\n-         *\n-         * @param kind the kind of CValueLayout\n-         * @param order the byte order of the layout\n-         * @param bitSize the size, in bits, of the layout\n-         * @param bitAlignment the alignment, in bits, of the layout\n-         * @param attributes the attribute map of this layout\n+         * A kind corresponding to the C {@code short} type\n@@ -816,6 +721,1 @@\n-        public CValueLayout(Kind kind, ByteOrder order, long bitSize, long bitAlignment,\n-                            Map<String, Constable> attributes) {\n-            super(order, bitSize, bitAlignment, attributes);\n-            this.kind = kind;\n-        }\n-\n+        SHORT(true),\n@@ -823,3 +723,1 @@\n-         * Accessor for the kind of this layout\n-         *\n-         * @return the kind\n+         * A kind corresponding to the C {@code int} type\n@@ -827,4 +725,1 @@\n-        public final Kind kind() {\n-            return kind;\n-        }\n-\n+        INT(true),\n@@ -832,1 +727,1 @@\n-         * {@inheritDoc}\n+         * A kind corresponding to the C {@code long} type\n@@ -834,5 +729,1 @@\n-        @Override\n-        public CValueLayout withOrder(ByteOrder order) {\n-            return new CValueLayout(kind, order, bitSize(), alignment, attributes);\n-        }\n-\n+        LONG(true),\n@@ -840,1 +731,1 @@\n-         * {@inheritDoc}\n+         * A kind corresponding to the C {@code long long} type\n@@ -842,5 +733,1 @@\n-        @Override\n-        public CValueLayout withName(String name) {\n-            return (CValueLayout) super.withName(name);\n-        }\n-\n+        LONGLONG(true),\n@@ -848,1 +735,1 @@\n-         * {@inheritDoc}\n+         * A kind corresponding to the C {@code float} type\n@@ -850,5 +737,1 @@\n-        @Override\n-        public CValueLayout withBitAlignment(long alignmentBits) {\n-            return (CValueLayout) super.withBitAlignment(alignmentBits);\n-        }\n-\n+        FLOAT(false),\n@@ -856,1 +739,1 @@\n-         * {@inheritDoc}\n+         * A kind corresponding to the C {@code double} type\n@@ -858,4 +741,9 @@\n-        @Override\n-        public CValueLayout withAttribute(String name, Constable value) {\n-            return (CValueLayout) super.withAttribute(name, value);\n-        }\n+        DOUBLE(false),\n+        \/**\n+         * A kind corresponding to the C {@code long double} type\n+         *\/\n+        LONGDOUBLE(false),\n+        \/**\n+         * A kind corresponding to the a C pointer type\n+         *\/\n+        POINTER(false);\n@@ -863,3 +751,4 @@\n-        @Override\n-        CValueLayout dup(long alignment, Map<String, Constable> attributes) {\n-            return new CValueLayout(kind, order(), bitSize(), alignment, attributes);\n+        private final boolean isIntegral;\n+\n+        TypeKind(boolean isIntegral) {\n+            this.isIntegral = isIntegral;\n@@ -869,1 +758,3 @@\n-         * {@inheritDoc}\n+         * Is this kind integral?\n+         *\n+         * @return true if this kind is integral\n@@ -871,3 +762,2 @@\n-        @Override\n-        public Optional<DynamicConstantDesc<ValueLayout>> describeConstable() {\n-            return Optional.of(decorateLayoutConstant(kind.bsm()));\n+        public boolean isIntergral() {\n+            return isIntegral;\n@@ -877,1 +767,3 @@\n-         * {@inheritDoc}\n+         * Is this kind a floating point type?\n+         *\n+         * @return true if this kind is a floating point type\n@@ -879,13 +771,2 @@\n-        @Override\n-        public boolean equals(Object other) {\n-            if (this == other) {\n-                return true;\n-            }\n-            if (other == null || getClass() != other.getClass()) {\n-                return false;\n-            }\n-            if (!super.equals(other)) {\n-                return false;\n-            }\n-            CValueLayout that = (CValueLayout) other;\n-            return kind == that.kind;\n+        public boolean isFloat() {\n+            return !isIntergral() && !isPointer();\n@@ -895,1 +776,3 @@\n-         * {@inheritDoc}\n+         * Is this kind a pointer kind?\n+         *\n+         * @return true if this kind is a pointer kind\n@@ -897,3 +780,2 @@\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(super.hashCode(), kind);\n+        public boolean isPointer() {\n+            return this == POINTER;\n@@ -901,0 +783,10 @@\n+\n+        \/**\n+         * The layout attribute name associated with this classification kind. Clients can retrieve the type kind\n+         * of a layout using the following code:\n+         * <blockquote><pre>{@code\n+        ValueLayout layout = ...\n+        TypeKind = layout.attribute(TypeKind.ATTR_NAME).orElse(null);\n+         * }<\/pre><\/blockquote>\n+         *\/\n+        public final static String ATTR_NAME = \"abi\/kind\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":84,"deletions":192,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-public class ValueLayout extends AbstractLayout implements MemoryLayout {\n+public final class ValueLayout extends AbstractLayout implements MemoryLayout {\n@@ -55,1 +55,1 @@\n-    protected ValueLayout(ByteOrder order, long size) {\n+    ValueLayout(ByteOrder order, long size) {\n@@ -59,1 +59,1 @@\n-    protected ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n+    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n@@ -95,1 +95,1 @@\n-        if (other == null || getClass() != other.getClass()) {\n+        if (!super.equals(other)) {\n@@ -98,1 +98,1 @@\n-        if (!super.equals(other)) {\n+        if (!(other instanceof ValueLayout)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.CLinker.CValueLayout;\n@@ -34,1 +33,0 @@\n-import java.util.Map;\n@@ -55,2 +53,3 @@\n-    private static CValueLayout ofChar(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.CHAR, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofChar(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.CHAR);\n@@ -59,2 +58,3 @@\n-    private static CValueLayout ofShort(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.SHORT, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofShort(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.SHORT);\n@@ -63,2 +63,3 @@\n-    private static CValueLayout ofInt(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.INT, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofInt(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.INT);\n@@ -67,2 +68,3 @@\n-    private static CValueLayout ofLong(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.LONG, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofLong(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONG);\n@@ -71,2 +73,3 @@\n-    private static CValueLayout ofLongLong(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.LONGLONG, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofLongLong(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONGLONG);\n@@ -75,2 +78,3 @@\n-    private static CValueLayout ofFloat(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.FLOAT, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofFloat(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.FLOAT);\n@@ -79,2 +83,3 @@\n-    private static CValueLayout ofDouble(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.DOUBLE, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofDouble(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.DOUBLE);\n@@ -83,2 +88,3 @@\n-    private static CValueLayout ofLongDouble(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.LONGDOUBLE, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofLongDouble(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONGDOUBLE);\n@@ -87,9 +93,8 @@\n-    \/**\n-     * Creates a new CValueLayout with the {@code POINTER} kind\n-     *\n-     * @param order the byte order of the layout\n-     * @param bitSize the size, in bits, of the layout\n-     * @return the newly created CValueLayout\n-     *\/\n-    public static CValueLayout ofPointer(ByteOrder order, long bitSize) {\n-        return new CValueLayout(CValueLayout.Kind.POINTER, order, bitSize, bitSize, Map.of());\n+    private static ValueLayout ofPointer(ByteOrder order, long bitSize) {\n+        return MemoryLayout.ofValueBits(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.POINTER);\n+    }\n+\n+    public static CLinker.TypeKind getKind(MemoryLayout layout) {\n+        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n+            () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n@@ -109,1 +114,1 @@\n-        public static final CValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n@@ -114,1 +119,1 @@\n-        public static final CValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n@@ -119,1 +124,1 @@\n-        public static final CValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n@@ -124,1 +129,1 @@\n-        public static final CValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n@@ -129,1 +134,1 @@\n-        public static final CValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n@@ -134,1 +139,1 @@\n-        public static final CValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n@@ -139,1 +144,1 @@\n-        public static final CValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n@@ -144,1 +149,1 @@\n-        public static final CValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 128);\n+        public static final ValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 128);\n@@ -149,1 +154,1 @@\n-        public static final CValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n+        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n@@ -175,1 +180,1 @@\n-        public static final CValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n@@ -180,1 +185,1 @@\n-        public static final CValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n@@ -185,1 +190,1 @@\n-        public static final CValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n@@ -189,1 +194,1 @@\n-        public static final CValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 32);\n@@ -194,1 +199,1 @@\n-        public static final CValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n@@ -199,1 +204,1 @@\n-        public static final CValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n@@ -204,1 +209,1 @@\n-        public static final CValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n@@ -209,1 +214,1 @@\n-        public static final CValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 64);\n@@ -214,1 +219,1 @@\n-        public static final CValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n+        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n@@ -244,1 +249,1 @@\n-        public static final CValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n@@ -249,1 +254,1 @@\n-        public static final CValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n@@ -254,1 +259,1 @@\n-        public static final CValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n@@ -259,1 +264,1 @@\n-        public static final CValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n@@ -264,1 +269,1 @@\n-        public static final CValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_LONGLONG = ofLongLong(LITTLE_ENDIAN, 64);\n@@ -269,1 +274,1 @@\n-        public static final CValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n@@ -274,1 +279,1 @@\n-        public static final CValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n@@ -279,1 +284,1 @@\n-        public static final CValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 128);\n+        public static final ValueLayout C_LONGDOUBLE = ofLongDouble(LITTLE_ENDIAN, 128);\n@@ -284,1 +289,1 @@\n-        public static final CValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n+        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, ADDRESS.bitSize());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":59,"deletions":54,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -33,0 +32,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -45,5 +45,1 @@\n-        if (!(type instanceof CLinker.CValueLayout)) {\n-            throw new IllegalStateException(\"Unexpected value layout: could not determine ABI class\");\n-        }\n-\n-        return switch (((CLinker.CValueLayout) type).kind()) {\n+        return switch (PlatformLayouts.getKind(type)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,0 +31,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -110,5 +110,1 @@\n-        if (!(layout instanceof CLinker.CValueLayout)) {\n-            throw new IllegalStateException(\"Unexpected value layout: could not determine ABI class\");\n-        }\n-\n-        return switch (((CLinker.CValueLayout) layout).kind()) {\n+        return switch (PlatformLayouts.getKind(layout)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -31,0 +30,1 @@\n+import jdk.internal.foreign.PlatformLayouts;\n@@ -43,4 +43,0 @@\n-        if (!(type instanceof CLinker.CValueLayout)) {\n-            throw new IllegalStateException(\"Unexpected value layout: could not determine ABI class\");\n-        }\n-\n@@ -56,1 +52,1 @@\n-        return switch (((CLinker.CValueLayout) type).kind()) {\n+        return switch (PlatformLayouts.getKind(type)) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+    static CLinker.TypeKind kind(MemoryLayout layout) {\n+        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n+                () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+    }\n+\n@@ -31,1 +36,1 @@\n-        return ((CLinker.CValueLayout) layout).kind().isIntergral();\n+        return kind(layout).isIntergral();\n@@ -35,1 +40,1 @@\n-        return ((CLinker.CValueLayout) layout).kind().isPointer();\n+        return kind(layout).isPointer();\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        assertEquals(layout.attributes().toArray().length, 0);\n+        assertEquals(layout.attributes().toArray().length, 1);\n@@ -57,1 +57,1 @@\n-        \/\/ but equals should return false, because one is a CValueLayout\n+        \/\/ but equals should return false, because one is a ValueLayout with a CLinker kind\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}