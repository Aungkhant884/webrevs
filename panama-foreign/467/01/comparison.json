{"files":[{"patch":"@@ -6,1 +6,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -21,1 +21,1 @@\n-message=Merge\n+message=Merge .*\n@@ -29,3 +29,0 @@\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n","filename":".jcheck\/conf","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+\n+const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+  ShouldNotCallThis();\n+  return {};\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -361,0 +361,10 @@\n+JavaFrameAnchor* EntryBlob::jfa_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+frame frame::sender_for_panama_entry_frame(RegisterMap* map) const {\n+  ShouldNotCallThis();\n+  return {};\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -969,1 +969,1 @@\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -988,1 +988,1 @@\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1012,1 +1012,1 @@\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,9 @@\n+\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n+  return false;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,0 +90,29 @@\n+\n+const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+  oop conv_oop = JNIHandles::resolve_non_null(jconv);\n+  objArrayOop arg_regs_oop = cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.arg_regs_offset));\n+  objArrayOop ret_regs_oop = cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.ret_regs_offset));\n+\n+  CallRegs result;\n+  result._args_length = arg_regs_oop->length();\n+  result._arg_regs = NEW_RESOURCE_ARRAY(VMReg, result._args_length);\n+\n+  result._rets_length = ret_regs_oop->length();\n+  result._ret_regs = NEW_RESOURCE_ARRAY(VMReg, result._rets_length);\n+\n+  for (int i = 0; i < result._args_length; i++) {\n+    oop storage = arg_regs_oop->obj_at(i);\n+    jint index = storage->int_field(VMS.index_offset);\n+    jint type = storage->int_field(VMS.type_offset);\n+    result._arg_regs[i] = VMRegImpl::vmStorageToVMReg(type, index);\n+  }\n+\n+  for (int i = 0; i < result._rets_length; i++) {\n+    oop storage = ret_regs_oop->obj_at(i);\n+    jint index = storage->int_field(VMS.index_offset);\n+    jint type = storage->int_field(VMS.type_offset);\n+    result._ret_regs[i] = VMRegImpl::vmStorageToVMReg(type, index);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    } else if (is_panama_entry_frame()) {\n+      return fp_safe;\n@@ -202,0 +204,2 @@\n+    } else if (sender_blob->is_entry_blob()) {\n+      return false;\n@@ -352,0 +356,26 @@\n+JavaFrameAnchor* EntryBlob::jfa_for_frame(const frame& frame) const {\n+  \/\/ need unextended_sp here, since normal sp is wrong for interpreter callees\n+  return reinterpret_cast<JavaFrameAnchor*>(reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(jfa_sp_offset()));\n+}\n+\n+frame frame::sender_for_panama_entry_frame(RegisterMap* map) const {\n+  assert(map != NULL, \"map must be set\");\n+  EntryBlob* blob = _cb->as_entry_blob();\n+  \/\/ Java frame called from C; skip all C frames and return top C\n+  \/\/ frame of that chunk as the sender\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  assert(jfa->last_Java_sp() > sp(), \"must be above this frame on stack\");\n+  \/\/ Since we are walking the stack now this nested anchor is obviously walkable\n+  \/\/ even if it wasn't when it was stacked.\n+  if (!jfa->walkable()) {\n+    \/\/ Capture _last_Java_pc (if needed) and mark anchor walkable.\n+    jfa->capture_last_Java_pc();\n+  }\n+  map->clear();\n+  assert(map->include_argument_oops(), \"should be set by clear\");\n+  vmassert(jfa->last_Java_pc() != NULL, \"not walkable\");\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_fp(), jfa->last_Java_pc());\n+\n+  return fr;\n+}\n+\n@@ -481,2 +511,3 @@\n-  if (is_entry_frame())       return sender_for_entry_frame(map);\n-  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n+  if (is_entry_frame())        return sender_for_entry_frame(map);\n+  if (is_panama_entry_frame()) return sender_for_panama_entry_frame(map);\n+  if (is_interpreted_frame())  return sender_for_interpreter_frame(map);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-private:\n-\n","filename":"src\/hotspot\/cpu\/x86\/javaFrameAnchor_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1143,1 +1143,1 @@\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1261,1 +1261,1 @@\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1290,1 +1290,1 @@\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1315,1 +1315,1 @@\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1424,1 +1424,1 @@\n-  move32_64(masm, tmp, length_arg);\n+  SharedRuntime::move32_64(masm, tmp, length_arg);\n@@ -1430,1 +1430,1 @@\n-  move32_64(masm, tmp, length_arg);\n+  SharedRuntime::move32_64(masm, tmp, length_arg);\n@@ -1517,2 +1517,2 @@\n-  ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n-                    BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n+                  const BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n@@ -4065,0 +4065,10 @@\n+\n+void SharedRuntime::compute_move_order(const BasicType* in_sig_bt,\n+                                       int total_in_args, const VMRegPair* in_regs,\n+                                       int total_out_args, VMRegPair* out_regs,\n+                                       GrowableArray<int>& arg_order,\n+                                       VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder order(total_in_args, in_regs,\n+                         total_out_args, out_regs,\n+                         in_sig_bt, arg_order, tmp_vmreg);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -29,0 +33,4 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/signature.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -144,0 +152,674 @@\n+\n+struct ArgMove {\n+  BasicType bt;\n+  VMRegPair from;\n+  VMRegPair to;\n+\n+  bool is_identity() const {\n+      return from.first() == to.first() && from.second() == to.second();\n+  }\n+};\n+\n+static GrowableArray<ArgMove> compute_argument_shuffle(Method* entry, int& out_arg_size_bytes, const CallRegs& conv, BasicType& ret_type) {\n+  assert(entry->is_static(), \"\");\n+\n+  \/\/ Fill in the signature array, for the calling-convention call.\n+  const int total_out_args = entry->size_of_parameters();\n+  assert(total_out_args > 0, \"receiver arg \");\n+\n+  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n+  VMRegPair* out_regs = NEW_RESOURCE_ARRAY(VMRegPair, total_out_args);\n+\n+  {\n+    int i = 0;\n+    SignatureStream ss(entry->signature());\n+    for (; !ss.at_return_type(); ss.next()) {\n+      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n+        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+    }\n+    assert(i == total_out_args, \"\");\n+    ret_type = ss.type();\n+  }\n+\n+  int out_arg_slots = SharedRuntime::java_calling_convention(out_sig_bt, out_regs, total_out_args);\n+\n+  const int total_in_args = total_out_args - 1; \/\/ skip receiver\n+  BasicType* in_sig_bt  = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n+  VMRegPair* in_regs    = NEW_RESOURCE_ARRAY(VMRegPair, total_in_args);\n+\n+  for (int i = 0; i < total_in_args ; i++ ) {\n+    in_sig_bt[i] = out_sig_bt[i+1]; \/\/ skip receiver\n+  }\n+\n+  \/\/ Now figure out where the args must be stored and how much stack space they require.\n+  conv.calling_convention(in_sig_bt, in_regs, total_in_args);\n+\n+  GrowableArray<int> arg_order(2 * total_in_args);\n+\n+  VMRegPair tmp_vmreg;\n+  tmp_vmreg.set2(rbx->as_VMReg());\n+\n+  \/\/ Compute a valid move order, using tmp_vmreg to break any cycles\n+  SharedRuntime::compute_move_order(in_sig_bt,\n+                                    total_in_args, in_regs,\n+                                    total_out_args, out_regs,\n+                                    arg_order,\n+                                    tmp_vmreg);\n+\n+  GrowableArray<ArgMove> arg_order_vmreg(total_in_args); \/\/ conservative\n+\n+#ifdef ASSERT\n+  bool reg_destroyed[RegisterImpl::number_of_registers];\n+  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n+  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+    reg_destroyed[r] = false;\n+  }\n+  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n+    freg_destroyed[f] = false;\n+  }\n+#endif \/\/ ASSERT\n+\n+  for (int i = 0; i < arg_order.length(); i += 2) {\n+    int in_arg  = arg_order.at(i);\n+    int out_arg = arg_order.at(i + 1);\n+\n+    assert(in_arg != -1 || out_arg != -1, \"\");\n+    BasicType arg_bt = (in_arg != -1 ? in_sig_bt[in_arg] : out_sig_bt[out_arg]);\n+    switch (arg_bt) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+      case T_FLOAT:\n+        break; \/\/ process\n+\n+      case T_LONG:\n+      case T_DOUBLE:\n+        assert(in_arg  == -1 || (in_arg  + 1 < total_in_args  &&  in_sig_bt[in_arg  + 1] == T_VOID), \"bad arg list: %d\", in_arg);\n+        assert(out_arg == -1 || (out_arg + 1 < total_out_args && out_sig_bt[out_arg + 1] == T_VOID), \"bad arg list: %d\", out_arg);\n+        break; \/\/ process\n+\n+      case T_VOID:\n+        continue; \/\/ skip\n+\n+      default:\n+        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+    }\n+\n+    ArgMove move;\n+    move.bt   = arg_bt;\n+    move.from = (in_arg != -1 ? in_regs[in_arg] : tmp_vmreg);\n+    move.to   = (out_arg != -1 ? out_regs[out_arg] : tmp_vmreg);\n+\n+    if(move.is_identity()) {\n+      continue; \/\/ useless move\n+    }\n+\n+#ifdef ASSERT\n+    if (in_arg != -1) {\n+      if (in_regs[in_arg].first()->is_Register()) {\n+        assert(!reg_destroyed[in_regs[in_arg].first()->as_Register()->encoding()], \"destroyed reg!\");\n+      } else if (in_regs[in_arg].first()->is_XMMRegister()) {\n+        assert(!freg_destroyed[in_regs[in_arg].first()->as_XMMRegister()->encoding()], \"destroyed reg!\");\n+      }\n+    }\n+    if (out_arg != -1) {\n+      if (out_regs[out_arg].first()->is_Register()) {\n+        reg_destroyed[out_regs[out_arg].first()->as_Register()->encoding()] = true;\n+      } else if (out_regs[out_arg].first()->is_XMMRegister()) {\n+        freg_destroyed[out_regs[out_arg].first()->as_XMMRegister()->encoding()] = true;\n+      }\n+    }\n+#endif \/* ASSERT *\/\n+\n+    arg_order_vmreg.push(move);\n+  }\n+\n+  int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;\n+  out_arg_size_bytes = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+\n+  return arg_order_vmreg;\n+}\n+\n+static const char* null_safe_string(const char* str) {\n+  return str == nullptr ? \"NULL\" : str;\n+}\n+\n+#ifdef ASSERT\n+static void print_arg_moves(const GrowableArray<ArgMove>& arg_moves, Method* entry) {\n+  LogTarget(Trace, panama) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print_cr(\"Argument shuffle for %s {\", entry->name_and_sig_as_C_string());\n+    for (int i = 0; i < arg_moves.length(); i++) {\n+      ArgMove arg_mv = arg_moves.at(i);\n+      BasicType arg_bt     = arg_mv.bt;\n+      VMRegPair from_vmreg = arg_mv.from;\n+      VMRegPair to_vmreg   = arg_mv.to;\n+\n+      ls.print(\"Move a %s from (\", null_safe_string(type2name(arg_bt)));\n+      from_vmreg.first()->print_on(&ls);\n+      ls.print(\",\");\n+      from_vmreg.second()->print_on(&ls);\n+      ls.print(\") to \");\n+      to_vmreg.first()->print_on(&ls);\n+      ls.print(\",\");\n+      to_vmreg.second()->print_on(&ls);\n+      ls.print_cr(\")\");\n+    }\n+    ls.print_cr(\"}\");\n+  }\n+}\n+#endif\n+\n+void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n+  __ block_comment(\"{ save_java_frame_anchor \");\n+  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n+\n+  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n+\n+  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n+  __ block_comment(\"} save_java_frame_anchor \");\n+}\n+\n+void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n+  __ block_comment(\"{ restore_java_frame_anchor \");\n+  \/\/ thread->_last_Java_sp = NULL\n+  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n+\n+  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n+  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+\n+  \/\/_thread->frame_anchor()->copy(&_anchor);\n+\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n+\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n+\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n+  __ block_comment(\"} restore_java_frame_anchor \");\n+}\n+\n+static void save_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n+  __ block_comment(\"{ save_native_args \");\n+  int store_offset = arg_save_area_offset;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, store_offset), reg->as_Register());\n+      store_offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, store_offset), reg->as_XMMRegister());\n+      store_offset += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  __ block_comment(\"} save_native_args \");\n+}\n+\n+static void restore_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n+  __ block_comment(\"{ restore_native_args \");\n+  int load_offset = arg_save_area_offset;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, load_offset));\n+      load_offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, load_offset));\n+      load_offset += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  __ block_comment(\"} restore_native_args \");\n+}\n+\n+static bool is_valid_XMM(XMMRegister reg) {\n+  return reg->is_valid() && (UseAVX >= 3 || (reg->encoding() < 16)); \/\/ why is this not covered by is_valid()?\n+}\n+\n+\/\/ for callee saved regs, according to the caller's ABI\n+static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n+  int size = 0;\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        size += 64; \/\/ bytes\n+      } else if (UseAVX >= 1) {\n+        size += 32;\n+      } else {\n+        size += 16;\n+      }\n+    }\n+  }\n+\n+  return size;\n+}\n+\n+static int compute_arg_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  return result_size;\n+}\n+\n+static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to save it here\n+  \/\/ 2. save mxcsr (?)\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ preserve_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(Address(rsp, offset), reg);\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(Address(rsp, offset), reg, Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(Address(rsp, offset), reg);\n+        offset += 32;\n+      } else {\n+        __ movdqu(Address(rsp, offset), reg);\n+        offset += 16;\n+      }\n+    }\n+  }\n+  __ block_comment(\"} preserve_callee_saved_regs \");\n+\n+  \/\/ TODO mxcsr\n+}\n+\n+static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to restore it here\n+  \/\/ 2. restore mxcsr (?)\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ restore_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(reg, Address(rsp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(reg, Address(rsp, offset), Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(reg, Address(rsp, offset));\n+        offset += 32;\n+      } else {\n+        __ movdqu(reg, Address(rsp, offset));\n+        offset += 16;\n+      }\n+    }\n+  }\n+\n+  __ block_comment(\"} restore_callee_saved_regs \");\n+\n+  \/\/ TODO mxcsr\n+}\n+\n+static void shuffle_arguments(MacroAssembler* _masm, const GrowableArray<ArgMove>& arg_moves) {\n+  for (int i = 0; i < arg_moves.length(); i++) {\n+    ArgMove arg_mv = arg_moves.at(i);\n+    BasicType arg_bt     = arg_mv.bt;\n+    VMRegPair from_vmreg = arg_mv.from;\n+    VMRegPair to_vmreg   = arg_mv.to;\n+\n+    assert(\n+      !((from_vmreg.first()->is_Register() && to_vmreg.first()->is_XMMRegister())\n+      || (from_vmreg.first()->is_XMMRegister() && to_vmreg.first()->is_Register())),\n+       \"move between gp and fp reg not supported\");\n+\n+    __ block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n+    switch (arg_bt) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+       SharedRuntime::move32_64(_masm, from_vmreg, to_vmreg);\n+       break;\n+\n+      case T_FLOAT:\n+        SharedRuntime::float_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      case T_DOUBLE:\n+        SharedRuntime::double_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      case T_LONG :\n+        SharedRuntime::long_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      default:\n+        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+    }\n+  }\n+}\n+\n+struct AuxiliarySaves {\n+  JavaFrameAnchor jfa;\n+  uintptr_t thread;\n+  bool should_detach;\n+};\n+\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry, jobject jabi, jobject jconv) {\n+  ResourceMark rm;\n+  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n+  const CallRegs conv = ForeignGlobals::parse_call_regs(jconv);\n+  assert(conv._rets_length <= 1, \"no multi reg returns\");\n+  CodeBuffer buffer(\"upcall_stub_linkToNative\", \/* code_size = *\/ 1024, \/* locs_size = *\/ 1024);\n+\n+  int register_size = sizeof(uintptr_t);\n+  int buffer_alignment = xmm_reg_size;\n+\n+  int out_arg_area = -1;\n+  BasicType ret_type;\n+  GrowableArray<ArgMove> arg_moves = compute_argument_shuffle(entry, out_arg_area, conv, ret_type);\n+  assert(out_arg_area != -1, \"Should have been set\");\n+  DEBUG_ONLY(print_arg_moves(arg_moves, entry);)\n+\n+  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n+  \/\/ make sure it is big enough.\n+  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n+    out_arg_area = frame::arg_reg_save_area_bytes;\n+  }\n+\n+  int reg_save_area_size = compute_reg_save_area_size(abi);\n+  int arg_save_area_size = compute_arg_save_area_size(conv);\n+  \/\/ To spill receiver during deopt\n+  int deopt_spill_size = 1 * BytesPerWord;\n+\n+  int shuffle_area_offset    = 0;\n+  int deopt_spill_offset     = shuffle_area_offset    + out_arg_area;\n+  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_save_area_size;\n+  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n+\n+  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n+  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n+  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+\n+  int frame_size = frame_bottom_offset;\n+  frame_size = align_up(frame_size, StackAlignmentInBytes);\n+\n+  \/\/ Ok The space we have allocated will look like:\n+  \/\/\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      |                     |\n+  \/\/      | AuxiliarySaves      |\n+  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      |                     |\n+  \/\/      | reg_save_area       |\n+  \/\/      |---------------------| = reg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | arg_save_area       |\n+  \/\/      |---------------------| = arg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | deopt_spill         |\n+  \/\/      |---------------------| = deopt_spill_offset\n+  \/\/      |                     |\n+  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n+  \/\/\n+  \/\/\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+  Label call_return;\n+  address start = __ pc();\n+  __ enter(); \/\/ set up frame\n+  if ((abi._stack_alignment_bytes % 16) != 0) {\n+    \/\/ stack alignment of caller is not a multiple of 16\n+    __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack\n+  }\n+  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n+  __ subptr(rsp, frame_size);\n+\n+  \/\/ we have to always spill args since we need to do a call to get the thread\n+  \/\/ (and maybe attach it).\n+  save_native_arguments(_masm, conv, arg_save_area_offset);\n+\n+  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ block_comment(\"{ get_thread\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ movptr(r15_thread, rax);\n+  __ reinit_heapbase();\n+  __ movptr(Address(rsp, thread_offset), r15_thread);\n+  __ block_comment(\"} get_thread\");\n+\n+  \/\/ TODO:\n+  \/\/ We expect not to be coming from JNI code, but we might be.\n+  \/\/ We should figure out what our stance is on supporting that and then maybe add\n+  \/\/ some more handling here for:\n+  \/\/   - handle blocks\n+  \/\/   - check for active exceptions (and emit an error)\n+\n+  __ block_comment(\"{ safepoint poll\");\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n+\n+  if (os::is_MP()) {\n+    __ membar(Assembler::Membar_mask_bits(\n+                Assembler::LoadLoad  | Assembler::StoreLoad |\n+                Assembler::LoadStore | Assembler::StoreStore));\n+   }\n+\n+  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  Label L_after_safepoint_poll;\n+  Label L_safepoint_poll_slow_path;\n+\n+  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n+  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n+\n+  __ bind(L_after_safepoint_poll);\n+  __ block_comment(\"} safepoint poll\");\n+  \/\/ change thread state\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n+\n+  __ block_comment(\"{ reguard stack check\");\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n+  __ jcc(Assembler::equal, L_reguard);\n+  __ bind(L_after_reguard);\n+  __ block_comment(\"} reguard stack check\");\n+\n+  __ block_comment(\"{ argument shuffle\");\n+  \/\/ TODO merge these somehow\n+  restore_native_arguments(_masm, conv, arg_save_area_offset);\n+  shuffle_arguments(_masm, arg_moves);\n+  __ block_comment(\"} argument shuffle\");\n+\n+  __ block_comment(\"{ receiver \");\n+  __ movptr(rscratch1, (intptr_t)receiver);\n+  __ resolve_jobject(rscratch1, r15_thread, rscratch2);\n+  __ movptr(j_rarg0, rscratch1);\n+  __ block_comment(\"} receiver \");\n+\n+  __ mov_metadata(rbx, entry);\n+  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n+  __ reinit_heapbase();\n+\n+  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n+  __ reset_last_Java_frame(r15_thread, true);\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+#ifdef ASSERT\n+  if (conv._rets_length == 1) { \/\/ 0 or 1\n+    VMReg j_expected_result_reg;\n+    switch (ret_type) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+      case T_LONG:\n+       j_expected_result_reg = rax->as_VMReg();\n+       break;\n+      case T_FLOAT:\n+      case T_DOUBLE:\n+        j_expected_result_reg = xmm0->as_VMReg();\n+        break;\n+      default:\n+        fatal(\"unexpected return type: %s\", type2name(ret_type));\n+    }\n+    \/\/ No need to move for now, since CallArranger can pick a return type\n+    \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+    assert(conv._ret_regs[0] == j_expected_result_reg,\n+     \"unexpected result register: %s != %s\", conv._ret_regs[0]->name(), j_expected_result_reg->name());\n+  }\n+#endif\n+\n+  __ bind(call_return);\n+\n+  \/\/ also sets last Java frame\n+  __ movptr(r15_thread, Address(rsp, thread_offset));\n+  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n+  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n+\n+  __ block_comment(\"{ maybe_detach_thread\");\n+  Label L_after_detach;\n+  __ cmpb(Address(rsp, should_detach_offset), 0);\n+  __ jcc(Assembler::equal, L_after_detach);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, r15_thread);\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n+  __ reinit_heapbase();\n+  __ bind(L_after_detach);\n+  __ block_comment(\"} maybe_detach_thread\");\n+\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+  __ bind(L_safepoint_poll_slow_path);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, r15_thread);\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+  __ reinit_heapbase();\n+  __ jmp(L_after_safepoint_poll);\n+  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_reguard\");\n+  __ bind(L_reguard);\n+  __ vzeroupper();\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n+  __ reinit_heapbase();\n+  __ jmp(L_after_reguard);\n+  __ block_comment(\"} L_reguard\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ exception handler\");\n+\n+  intptr_t exception_handler_offset = __ pc() - start;\n+\n+  \/\/ TODO: this is always the same, can we bypass and call handle_uncaught_exception directly?\n+\n+  \/\/ native caller has no idea how to handle exceptions\n+  \/\/ we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(rax);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, rax);\n+  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n+  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows (not really needed)\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::handle_uncaught_exception)));\n+  __ should_not_reach_here();\n+\n+  __ block_comment(\"} exception handler\");\n+\n+  _masm->flush();\n+\n+\n+#ifndef PRODUCT\n+  stringStream ss;\n+  ss.print(\"panama_upcall_stub_%s\", entry->signature()->as_C_string());\n+  const char* name = _masm->code_string(ss.as_string());\n+#else \/\/ PRODUCT\n+  const char* name = \"panama_upcall_stub\";\n+#endif \/\/ PRODUCT\n+\n+  EntryBlob* blob = EntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+\n+  if (TracePanamaUpcallStubs) {\n+    blob->print_on(tty);\n+    Disassembler::decode(blob, tty);\n+  }\n+\n+  return blob->code_begin();\n+}\n+\n+bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":682,"deletions":0,"binary":false,"changes":682,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,0 @@\n-address ciNativeEntryPoint::entry_point() const {\n-  VM_ENTRY_MARK;\n-  return jdk_internal_invoke_NativeEntryPoint::addr(get_oop());\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-  address        entry_point() const;\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3831,1 +3831,0 @@\n-int jdk_internal_invoke_NativeEntryPoint::_addr_offset;\n@@ -3840,1 +3839,0 @@\n-  macro(_addr_offset,            k, \"addr\",           long_signature, false); \\\n@@ -3863,4 +3861,0 @@\n-address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {\n-  return (address)entry->long_field(_addr_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1019,1 +1019,0 @@\n-  static int _addr_offset;  \/\/ type is jlong\n@@ -1033,1 +1032,0 @@\n-  static address    addr(oop entry);\n@@ -1049,1 +1047,0 @@\n-  static int addr_offset_in_bytes()            { return _addr_offset;            }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -711,0 +711,27 @@\n+\n+\/\/ Implementation of EntryBlob\n+\n+EntryBlob::EntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                     jobject receiver, ByteSize jfa_sp_offset) :\n+  BufferBlob(name, size, cb),\n+  _exception_handler_offset(exception_handler_offset),\n+  _receiver(receiver),\n+  _jfa_sp_offset(jfa_sp_offset) {\n+  CodeCache::commit(this);\n+}\n+\n+EntryBlob* EntryBlob::create(const char* name, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                             jobject receiver, ByteSize jfa_sp_offset) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  EntryBlob* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(EntryBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) EntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+\/\/    EntryBlob          : Used for upcalls from native code\n@@ -85,0 +86,2 @@\n+class EntryBlob; \/\/ for as_entry_blob()\n+class JavaFrameAnchor; \/\/ for EntryBlob::jfa_for_frame\n@@ -147,0 +150,1 @@\n+  virtual bool is_entry_blob() const                  { return false; }\n@@ -160,0 +164,1 @@\n+  EntryBlob* as_entry_blob() const             { assert(is_entry_blob(), \"must be entry blob\"); return (EntryBlob*) this; }\n@@ -391,0 +396,1 @@\n+  friend class EntryBlob;\n@@ -730,0 +736,29 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\n+\/\/ For Panama upcall stubs\n+class EntryBlob: public BufferBlob {\n+ private:\n+  intptr_t _exception_handler_offset;\n+  jobject _receiver;\n+  ByteSize _jfa_sp_offset;\n+\n+  EntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+            jobject receiver, ByteSize jfa_sp_offset);\n+\n+ public:\n+  \/\/ Creation\n+  static EntryBlob* create(const char* name, CodeBuffer* cb,\n+                           intptr_t exception_handler_offset, jobject receiver,\n+                           ByteSize jfa_sp_offset);\n+\n+  address exception_handler() { return code_begin() + _exception_handler_offset; }\n+  jobject receiver() { return _receiver; }\n+  ByteSize jfa_sp_offset() const { return _jfa_sp_offset; }\n+\n+  \/\/ defined in frame_ARCH.cpp\n+  JavaFrameAnchor* jfa_for_frame(const frame& frame) const;\n+\n+  \/\/ Typing\n+  virtual bool is_entry_blob() const override { return true; }\n+};\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  DEBUG_ONLY(LOG_TAG(panama)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -421,2 +421,3 @@\n-  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, _input_not_const);\n-  assert(!_input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n+  bool input_not_const = true;\n+  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, input_not_const);\n+  assert(!input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n@@ -1061,0 +1062,1 @@\n+  address _call_addr;\n@@ -1063,2 +1065,2 @@\n-  NativeCallGenerator(ciMethod* m, ciNativeEntryPoint* nep)\n-   : CallGenerator(m), _nep(nep) {}\n+  NativeCallGenerator(ciMethod* m, address call_addr, ciNativeEntryPoint* nep)\n+   : CallGenerator(m), _call_addr(call_addr), _nep(nep) {}\n@@ -1072,1 +1074,1 @@\n-  Node* call = kit.make_native_call(tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n+  Node* call = kit.make_native_call(_call_addr, tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n@@ -1076,1 +1078,0 @@\n-  address addr = _nep->entry_point();\n@@ -1078,1 +1079,1 @@\n-    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(addr));\n+    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(_call_addr));\n@@ -1211,2 +1212,4 @@\n-      Node* nep = kit.argument(callee->arg_size() - 1);\n-      if (nep->Opcode() == Op_ConP) {\n+      Node* addr_n = kit.argument(1); \/\/ target address\n+      Node* nep_n = kit.argument(callee->arg_size() - 1); \/\/ NativeEntryPoint\n+      \/\/ This check needs to be kept in sync with the one in CallStaticJavaNode::Ideal\n+      if (addr_n->Opcode() == Op_ConL && nep_n->Opcode() == Op_ConP) {\n@@ -1214,3 +1217,5 @@\n-        const TypeOopPtr* oop_ptr = nep->bottom_type()->is_oopptr();\n-        ciNativeEntryPoint* nep = oop_ptr->const_oop()->as_native_entry_point();\n-        return new NativeCallGenerator(callee, nep);\n+        const TypeLong* addr_t = addr_n->bottom_type()->is_long();\n+        const TypeOopPtr* nep_t = nep_n->bottom_type()->is_oopptr();\n+        address addr = (address) addr_t->get_con();\n+        ciNativeEntryPoint* nep = nep_t->const_oop()->as_native_entry_point();\n+        return new NativeCallGenerator(callee, addr, nep);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1069,0 +1069,6 @@\n+    } else if(iid == vmIntrinsics::_linkToNative) {\n+      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP \/* NEP *\/\n+          && in(TypeFunc::Parms + 1)->Opcode() == Op_ConL \/* address *\/) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(NULL);\n+      }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2586,2 +2586,7 @@\n-Node* GraphKit::make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n-  uint n_filtered_args = nargs - 2; \/\/ -fallback, -nep;\n+Node* GraphKit::make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n+  \/\/ Select just the actual call args to pass on\n+  \/\/ [MethodHandle fallback, long addr, HALF addr, ... args , NativeEntryPoint nep]\n+  \/\/                                             |          |\n+  \/\/                                             V          V\n+  \/\/                                             [ ... args ]\n+  uint n_filtered_args = nargs - 4; \/\/ -fallback, -addr (2), -nep;\n@@ -2597,1 +2602,1 @@\n-      uint vm_unfiltered_arg_pos = vm_arg_pos + 1; \/\/ +1 to skip fallback handle argument\n+      uint vm_unfiltered_arg_pos = vm_arg_pos + 3; \/\/ +3 to skip fallback handle argument and addr (2 since long)\n@@ -2633,1 +2638,0 @@\n-  address call_addr = nep->entry_point();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -805,1 +805,1 @@\n-  Node* make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n+  Node* make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,4 @@\n+const CallRegs ForeignGlobals::parse_call_regs(jobject jconv) {\n+  return instance().parse_call_regs_impl(jconv);\n+}\n+\n@@ -68,5 +72,5 @@\n-  const char* strVMSArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n-  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray, (int)strlen(strVMSArray));\n-  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArray);\n-  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArray);\n-  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArray);\n+  const char* strVMSArrayArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n+  Symbol* symVMSArrayArray = SymbolTable::new_symbol(strVMSArrayArray);\n+  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArrayArray);\n+  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArrayArray);\n+  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArrayArray);\n@@ -79,0 +83,1 @@\n+  VMS.type_offset = field_offset(k_VMS, \"type\", vmSymbols::int_signature());\n@@ -88,0 +93,37 @@\n+\n+  \/\/ CallRegs\n+  const char* strVMSArray = \"[L\" FOREIGN_ABI \"VMStorage;\";\n+  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray);\n+  InstanceKlass* k_CC = find_InstanceKlass(FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs\", current_thread);\n+  CallConvOffsets.arg_regs_offset = field_offset(k_CC, \"argRegs\", symVMSArray);\n+  CallConvOffsets.ret_regs_offset = field_offset(k_CC, \"retRegs\", symVMSArray);\n+}\n+\n+void CallRegs::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n+  int src_pos = 0;\n+  for (uint i = 0; i < argcnt; i++) {\n+    switch (sig_bt[i]) {\n+      case T_BOOLEAN:\n+      case T_CHAR:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT:\n+      case T_FLOAT:\n+        assert(src_pos < _args_length, \"oob\");\n+        parm_regs[i].set1(_arg_regs[src_pos++]);\n+        break;\n+      case T_LONG:\n+      case T_DOUBLE:\n+        assert((i + 1) < argcnt && sig_bt[i + 1] == T_VOID, \"expecting half\");\n+        assert(src_pos < _args_length, \"oob\");\n+        parm_regs[i].set2(_arg_regs[src_pos++]);\n+        break;\n+      case T_VOID: \/\/ Halves of longs and doubles\n+        assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n+        parm_regs[i].set_bad();\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+        break;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/vmreg.hpp\"\n@@ -33,0 +34,10 @@\n+struct CallRegs {\n+  VMReg* _arg_regs;\n+  int _args_length;\n+\n+  VMReg* _ret_regs;\n+  int _rets_length;\n+\n+  void calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const;\n+};\n+\n@@ -45,0 +56,1 @@\n+    int type_offset;\n@@ -56,0 +68,5 @@\n+  struct {\n+    int arg_regs_offset;\n+    int ret_regs_offset;\n+  } CallConvOffsets;\n+\n@@ -68,0 +85,1 @@\n+  const CallRegs parse_call_regs_impl(jobject jconv) const;\n@@ -71,0 +89,1 @@\n+  static const CallRegs parse_call_regs(jobject jconv);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-JNI_LEAF(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))\n+JNI_ENTRY(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-JNI_LEAF(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))\n+JNI_ENTRY(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -52,1 +54,1 @@\n-void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n+Thread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n@@ -54,1 +56,0 @@\n-  bool should_detach = false;\n@@ -60,1 +61,1 @@\n-    should_detach = true;\n+    *should_detach = true;\n@@ -62,0 +63,2 @@\n+  } else {\n+    *should_detach = false;\n@@ -63,0 +66,11 @@\n+  return thread;\n+}\n+\n+void ProgrammableUpcallHandler::detach_thread(Thread* thread) {\n+  JavaVM_ *vm = (JavaVM *)(&main_vm);\n+  vm->functions->DetachCurrentThread(vm);\n+}\n+\n+void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n+  bool should_detach = false;\n+  Thread* thread = maybe_attach_and_get_thread(&should_detach);\n@@ -67,2 +81,1 @@\n-    JavaVM_ *vm = (JavaVM *)(&main_vm);\n-    vm->functions->DetachCurrentThread(vm);\n+    detach_thread(thread);\n@@ -86,1 +99,1 @@\n-  upcall_method.sig = SymbolTable::new_symbol(\"(L\" FOREIGN_ABI \"ProgrammableUpcallHandler;J)V\");\n+  upcall_method.sig = SymbolTable::new_symbol(\"(Ljava\/lang\/invoke\/MethodHandle;J)V\");\n@@ -93,1 +106,8 @@\n-JNI_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jobject rec, jobject abi, jobject buffer_layout))\n+void ProgrammableUpcallHandler::handle_uncaught_exception(oop exception) {\n+  \/\/ Based on CATCH macro\n+  tty->print_cr(\"Uncaught exception:\");\n+  exception->print();\n+  ShouldNotReachHere();\n+}\n+\n+JVM_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jclass unused, jobject rec, jobject abi, jobject buffer_layout))\n@@ -99,0 +119,19 @@\n+JVM_ENTRY(jlong, PUH_AllocateOptimzedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv))\n+  Handle mh_h(THREAD, JNIHandles::resolve(mh));\n+  jobject mh_j = JNIHandles::make_global(mh_h);\n+\n+  oop lform = java_lang_invoke_MethodHandle::form(mh_h());\n+  oop vmentry = java_lang_invoke_LambdaForm::vmentry(lform);\n+  Method* entry = java_lang_invoke_MemberName::vmtarget(vmentry);\n+  const methodHandle mh_entry(THREAD, entry);\n+\n+  assert(entry->method_holder()->is_initialized(), \"no clinit barrier\");\n+  CompilationPolicy::compile_if_required(mh_entry, CHECK_0);\n+\n+  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(mh_j, entry, abi, conv);\n+JVM_END\n+\n+JVM_ENTRY(jboolean, PUH_SupportsOptimzedUpcalls(JNIEnv *env, jclass unused))\n+  return (jboolean) ProgrammableUpcallHandler::supports_optimized_upcalls();\n+JVM_END\n+\n@@ -103,1 +142,3 @@\n-  {CC \"allocateUpcallStub\", CC \"(L\" FOREIGN_ABI \"ABIDescriptor;L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n+  {CC \"allocateUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n+  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \")J\", FN_PTR(PUH_AllocateOptimzedUpcallStub)},\n+  {CC \"supportsOptimizedUpcalls\", CC \"()Z\", FN_PTR(PUH_SupportsOptimzedUpcalls)},\n@@ -109,1 +150,2 @@\n-JNI_LEAF(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n+JNI_ENTRY(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":51,"deletions":9,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+\n+  static void handle_uncaught_exception(oop exception);\n+  static Thread* maybe_attach_and_get_thread(bool* should_detach);\n+  static void detach_thread(Thread* thread);\n@@ -49,0 +53,1 @@\n+  static address generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv);\n@@ -50,0 +55,1 @@\n+  static bool supports_optimized_upcalls();\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,2 +39,8 @@\n-  jobject* rec_ptr = (jobject*)(void*)cb -> content_begin();\n-  JNIHandles::destroy_global(*rec_ptr);\n+  jobject handle = NULL;\n+  if (cb->is_entry_blob()) {\n+    handle = ((EntryBlob*)cb)->receiver();\n+  } else {\n+    jobject* handle_ptr = (jobject*)(void*)cb->content_begin();\n+    handle = *handle_ptr;\n+  }\n+  JNIHandles::destroy_global(handle);\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2284,1 +2284,1 @@\n-WB_ENTRY(void, WB_VerifyFrames(JNIEnv* env, jobject wb, jboolean log))\n+WB_ENTRY(void, WB_VerifyFrames(JNIEnv* env, jobject wb, jboolean log, jboolean update_map))\n@@ -2290,1 +2290,1 @@\n-  for (StackFrameStream fst(JavaThread::current(), true, true); !fst.is_done(); fst.next()) {\n+  for (StackFrameStream fst(JavaThread::current(), update_map, true); !fst.is_done(); fst.next()) {\n@@ -2547,1 +2547,1 @@\n-  {CC\"verifyFrames\",                CC\"(Z)V\",            (void*)&WB_VerifyFrames },\n+  {CC\"verifyFrames\",                CC\"(ZZ)V\",            (void*)&WB_VerifyFrames },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1072,0 +1072,4 @@\n+  } else if (is_panama_entry_frame()) {\n+   \/\/ Nothing to do\n+   \/\/ receiver is a global ref\n+   \/\/ handle block is for JNI\n@@ -1110,1 +1114,3 @@\n-  oops_do_internal(&VerifyOopClosure::verify_oop, NULL, map, false, DerivedPointerIterationMode::_ignore);\n+  if (map->update_map()) { \/\/ The map has to be up-to-date for the current frame\n+    oops_do_internal(&VerifyOopClosure::verify_oop, NULL, map, false, DerivedPointerIterationMode::_ignore);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  bool is_panama_entry_frame()         const;\n@@ -174,0 +175,1 @@\n+  frame sender_for_panama_entry_frame(RegisterMap* map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+inline bool frame::is_panama_entry_frame() const {\n+  return _cb != NULL && _cb->is_entry_blob();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2089,0 +2089,3 @@\n+                                                                            \\\n+  develop(bool, TracePanamaUpcallStubs, false,                              \\\n+                \"Trace Panama upcall stub generation\")                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -515,0 +515,3 @@\n+  if (blob != NULL && blob->is_entry_blob()) {\n+    return ((EntryBlob*)blob)->exception_handler();\n+  }\n@@ -1447,1 +1450,1 @@\n-  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame(), \"unexpected frame\");\n+  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame() && !caller_frame.is_panama_entry_frame(), \"unexpected frame\");\n@@ -1479,1 +1482,2 @@\n-      caller_frame.is_entry_frame()) {\n+      caller_frame.is_entry_frame() ||\n+      caller_frame.is_panama_entry_frame()) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -476,0 +476,5 @@\n+  static void   move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void   long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void  float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+\n@@ -527,0 +532,6 @@\n+  static void compute_move_order(const BasicType* in_sig_bt,\n+                                 int total_in_args, const VMRegPair* in_regs,\n+                                 int total_out_args, VMRegPair* out_regs,\n+                                 GrowableArray<int>& arg_order,\n+                                 VMRegPair tmp_vmreg);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1763,0 +1763,5 @@\n+            @Override\n+            public void ensureCustomized(MethodHandle mh) {\n+                mh.customize();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-            throw new IllegalArgumentException(\"Type of fallback must match\");\n+            throw new IllegalArgumentException(\"Type of fallback must match: \" + type + \" != \" + fallback.type());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,0 +135,7 @@\n+\n+    \/**\n+     * Ensure given method handle is customized\n+     *\n+     * @param mh the method handle\n+     *\/\n+    void ensureCustomized(MethodHandle mh);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-    private final long addr;\n-\n@@ -52,1 +50,1 @@\n-    private NativeEntryPoint(long addr, int shadowSpace, long[] argMoves, long[] returnMoves,\n+    private NativeEntryPoint(int shadowSpace, long[] argMoves, long[] returnMoves,\n@@ -54,1 +52,0 @@\n-        this.addr = addr;\n@@ -63,1 +60,2 @@\n-    public static NativeEntryPoint make(long addr, String name, ABIDescriptorProxy abi, VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,\n+    public static NativeEntryPoint make(String name, ABIDescriptorProxy abi,\n+                                        VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,\n@@ -69,2 +67,2 @@\n-        return new NativeEntryPoint(\n-            addr, abi.shadowSpaceBytes(), encodeVMStorages(argMoves), encodeVMStorages(returnMoves), needTransition, methodType, name);\n+        return new NativeEntryPoint(abi.shadowSpaceBytes(), encodeVMStorages(argMoves), encodeVMStorages(returnMoves),\n+                needTransition, methodType, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/NativeEntryPoint.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -128,2 +129,2 @@\n-     * Obtain a foreign method handle, with given type, which can be used to call a\n-     * target foreign function at a given address and featuring a given function descriptor.\n+     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n+     * which can be used to call a target foreign function at the given address.\n@@ -139,1 +140,21 @@\n-    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n+    default MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(symbol);\n+        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+    }\n+\n+    \/**\n+     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n+     * which can be used to call a target foreign function at an address passed in as a leading argument.\n+     * <p>\n+     * For a given method type {@code (As...) -> R}, the returned method handle shall have the method type\n+     * {@code (Addressable, As...) -> R}, where {@code As...} are zero or more parameter types, and {@code R}\n+     * is the return type (which can be {@code void}).\n+     *\n+     * @see LibraryLookup#lookup(String)\n+     *\n+     * @param type     the method type.\n+     * @param function the function descriptor.\n+     * @return the downcall method handle.\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     *\/\n+    MethodHandle downcallHandle(MethodType type, FunctionDescriptor function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -360,0 +360,2 @@\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -409,0 +411,2 @@\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+    public static NativeScope emptyScope() {\n+        return new EmptyScope();\n+    }\n+\n@@ -172,0 +176,18 @@\n+\n+    \/\/ only for registering\n+    private static class EmptyScope extends AbstractNativeScope {\n+        @Override\n+        public OptionalLong byteSize() {\n+            return OptionalLong.of(0);\n+        }\n+\n+        @Override\n+        public long allocatedBytes() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            throw new OutOfMemoryError(\"Not enough space left to allocate\");\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractNativeScope.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.lang.invoke.MethodType;\n@@ -47,1 +46,0 @@\n-import static java.lang.invoke.MethodHandles.permuteArguments;\n@@ -225,1 +223,1 @@\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class));\n+                    methodType(MemorySegment.class, MemoryAddress.class, long.class, SharedUtils.Allocator.class));\n@@ -262,21 +260,0 @@\n-    private static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {\n-        MethodType oldType = mh.type();\n-        Class<?> sourceType = oldType.parameterType(sourceIndex);\n-        Class<?> destType = oldType.parameterType(destIndex);\n-        if (sourceType != destType) {\n-            \/\/ TODO meet?\n-            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n-        }\n-        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n-        int[] reorder = new int[oldType.parameterCount()];\n-        assert destIndex > sourceIndex;\n-        for (int i = 0, index = 0; i < reorder.length; i++) {\n-            if (i != destIndex) {\n-                reorder[i] = index++;\n-            } else {\n-                reorder[i] = sourceIndex;\n-            }\n-        }\n-        return permuteArguments(mh, newType, reorder);\n-    }\n-\n@@ -567,1 +544,4 @@\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);\n+            \/\/ alignment is set to 1 byte here to avoid exceptions for cases where we do super word\n+            \/\/ copies of e.g. 2 int fields of a struct as a single long, while the struct is only\n+            \/\/ 4-byte-aligned (since it only contains ints)\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, 1, ByteOrder.nativeOrder()), 1, offset);\n@@ -718,1 +698,1 @@\n-            return mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n@@ -787,1 +767,1 @@\n-            return mergeArguments(specializedHandle, allocatorPos, insertPos);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos);\n@@ -842,1 +822,1 @@\n-     * Box_ADDRESS()\n+     * BOX_ADDRESS()\n@@ -912,2 +892,2 @@\n-     * BASE_ADDRESS([size])\n-     *   Pops a MemoryAddress from the operand stack, and takes the converts it to a MemorySegment\n+     * TO_SEGMENT([size])\n+     *   Pops a MemoryAddress from the operand stack, and converts it to a MemorySegment\n@@ -925,3 +905,3 @@\n-        \/\/ FIXME should register with scope\n-        private static MemorySegment toSegment(MemoryAddress operand, long size) {\n-            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+        private static MemorySegment toSegment(MemoryAddress operand, long size, SharedUtils.Allocator allocator) {\n+            MemorySegment ms = MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+            return allocator.handoff(ms);\n@@ -941,1 +921,1 @@\n-            MemorySegment segment = toSegment(operand, size);\n+            MemorySegment segment = toSegment(operand, size, allocator);\n@@ -948,1 +928,2 @@\n-            return filterArguments(specializedHandle, insertPos, toSegmentHandle);\n+            specializedHandle = collectArguments(specializedHandle, insertPos, toSegmentHandle);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n@@ -1015,1 +996,1 @@\n-            return mergeArguments(specializedHandle, insertPos, insertPos + 1);\n+            return SharedUtils.mergeArguments(specializedHandle, insertPos, insertPos + 1);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":18,"deletions":37,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.MemoryAddressImpl;\n@@ -118,1 +119,1 @@\n-    private static void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,\n+    private void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,\n@@ -131,0 +132,8 @@\n+        long stack_ptr = (long) VH_LONG.get(buff.asSlice(stack_args));\n+        long stack_bytes = (long) VH_LONG.get(buff.asSlice(stack_args_bytes));\n+        MemorySegment stackArgs = MemoryAddressImpl.ofLongUnchecked(stack_ptr, stack_bytes);\n+        stream.println(\"Stack {\");\n+        for (int i = 0; i < stack_bytes \/ 8; i += 8) {\n+            stream.printf(\"    @%d: %s%n\", i, getLongString(stackArgs, i));\n+        }\n+        stream.println(\"}\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.NativeScope;\n@@ -33,1 +33,1 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils.Allocator;\n@@ -46,2 +46,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n@@ -52,1 +50,0 @@\n-import static java.lang.invoke.MethodHandles.empty;\n@@ -56,1 +53,0 @@\n-import static java.lang.invoke.MethodHandles.tryFinally;\n@@ -58,1 +54,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.Allocator.THROWING_ALLOCATOR;\n@@ -81,5 +76,1 @@\n-\n-    private static final MethodHandle MH_MAKE_SCOPE;\n-    private static final MethodHandle MH_CLOSE_SCOPE;\n-    private static final MethodHandle MH_WRAP_SCOPE;\n-\n+    private static final MethodHandle MH_ADDR_TO_LONG;\n@@ -88,0 +79,2 @@\n+    private static final MethodHandle EMPTY_OBJECT_ARRAY_HANDLE = MethodHandles.constant(Object[].class, new Object[0]);\n+\n@@ -92,1 +85,1 @@\n-                    methodType(Object.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n+                    methodType(Object.class, long.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n@@ -94,7 +87,6 @@\n-                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n-            MH_MAKE_SCOPE = lookup.findStatic(NativeScope.class, \"boundedScope\",\n-                    methodType(NativeScope.class, long.class));\n-            MH_CLOSE_SCOPE = lookup.findVirtual(NativeScope.class, \"close\",\n-                    methodType(void.class));\n-            MH_WRAP_SCOPE = lookup.findStatic(SharedUtils.Allocator.class, \"ofScope\",\n-                    methodType(SharedUtils.Allocator.class, NativeScope.class));\n+                    methodType(Object.class, Addressable.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+            MethodHandle MH_Addressable_address = lookup.findVirtual(Addressable.class, \"address\",\n+                    methodType(MemoryAddress.class));\n+            MethodHandle MH_MemoryAddress_toRawLongValue = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+                    methodType(long.class));\n+            MH_ADDR_TO_LONG = filterArguments(MH_MemoryAddress_toRawLongValue, 0, MH_Addressable_address);\n@@ -112,1 +104,0 @@\n-    private final Addressable addr;\n@@ -117,1 +108,1 @@\n-    public ProgrammableInvoker(ABIDescriptor abi, Addressable addr, CallingSequence callingSequence) {\n+    public ProgrammableInvoker(ABIDescriptor abi, CallingSequence callingSequence) {\n@@ -122,1 +113,0 @@\n-        this.addr = addr;\n@@ -131,18 +121,1 @@\n-        this.bufferCopySize = bufferCopySize(callingSequence);\n-    }\n-\n-    private static long bufferCopySize(CallingSequence callingSequence) {\n-        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n-        \/\/ starting address of the allocator might be un-aligned.\n-        long size = 0;\n-        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            for (Binding b : bindings) {\n-                if (b instanceof Binding.Copy) {\n-                    Binding.Copy c = (Binding.Copy) b;\n-                    size = Utils.alignUp(size, c.alignment());\n-                    size += c.size();\n-                }\n-            }\n-        }\n-        return size;\n+        this.bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n@@ -163,0 +136,1 @@\n+        MethodType leafTypeWithAddress = leafType.insertParameterTypes(0, long.class);\n@@ -164,3 +138,4 @@\n-        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 1, argMoves, retMoves)\n-                                            .asCollector(Object[].class, leafType.parameterCount())\n-                                            .asType(leafType);\n+        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 2, argMoves, retMoves);\n+        MethodHandle collector = makeCollectorHandle(leafType);\n+        handle = collectArguments(handle, 1, collector);\n+        handle = handle.asType(leafTypeWithAddress);\n@@ -172,1 +147,0 @@\n-                addr.address().toRawLongValue(),\n@@ -178,1 +152,1 @@\n-                leafType\n+                leafTypeWithAddress\n@@ -183,0 +157,1 @@\n+        handle = filterArguments(handle, 0, MH_ADDR_TO_LONG);\n@@ -187,2 +162,2 @@\n-            Map<VMStorage, Integer> argIndexMap = indexMap(argMoves);\n-            Map<VMStorage, Integer> retIndexMap = indexMap(retMoves);\n+            Map<VMStorage, Integer> argIndexMap = SharedUtils.indexMap(argMoves);\n+            Map<VMStorage, Integer> retIndexMap = SharedUtils.indexMap(retMoves);\n@@ -190,3 +165,4 @@\n-            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 1, handle, argIndexMap, retIndexMap);\n-            handle = handle.asCollector(Object[].class, callingSequence.methodType().parameterCount())\n-                                             .asType(callingSequence.methodType());\n+            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 2, handle, argIndexMap, retIndexMap);\n+            MethodHandle collectorInterp = makeCollectorHandle(callingSequence.methodType());\n+            handle = collectArguments(handle, 1, collectorInterp);\n+            handle = handle.asType(handle.type().changeReturnType(callingSequence.methodType().returnType()));\n@@ -198,0 +174,9 @@\n+    \/\/ Funnel from type to Object[]\n+    private static MethodHandle makeCollectorHandle(MethodType type) {\n+        return type.parameterCount() == 0\n+            ? EMPTY_OBJECT_ARRAY_HANDLE\n+            : identity(Object[].class)\n+                .asCollector(Object[].class, type.parameterCount())\n+                .asType(type.changeReturnType(Object[].class));\n+    }\n+\n@@ -218,1 +203,0 @@\n-        MethodType leafType = leafHandle.type();\n@@ -222,1 +206,1 @@\n-        int argInsertPos = -1;\n+        int argInsertPos = 0; \/\/ +1 for addr\n@@ -225,2 +209,2 @@\n-            argAllocatorPos = 0;\n-            specializedHandle = dropArguments(specializedHandle, argAllocatorPos, SharedUtils.Allocator.class);\n+            argAllocatorPos = 1;\n+            specializedHandle = dropArguments(specializedHandle, argAllocatorPos, Allocator.class);\n@@ -247,1 +231,1 @@\n-            returnFilter = dropArguments(returnFilter, retAllocatorPos, SharedUtils.Allocator.class);\n+            returnFilter = dropArguments(returnFilter, retAllocatorPos, Allocator.class);\n@@ -258,12 +242,1 @@\n-            \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n-            MethodHandle closer = leafType.returnType() == void.class\n-                  \/\/ (Throwable, NativeScope) -> void\n-                ? collectArguments(empty(methodType(void.class, Throwable.class)), 1, MH_CLOSE_SCOPE)\n-                  \/\/ (Throwable, V, NativeScope) -> V\n-                : collectArguments(dropArguments(identity(specializedHandle.type().returnType()), 0, Throwable.class),\n-                                   2, MH_CLOSE_SCOPE);\n-            \/\/ Handle takes a SharedUtils.Allocator, so need to wrap our NativeScope\n-            specializedHandle = filterArguments(specializedHandle, argAllocatorPos, MH_WRAP_SCOPE);\n-            specializedHandle = tryFinally(specializedHandle, closer);\n-            MethodHandle makeScopeHandle = insertArguments(MH_MAKE_SCOPE, 0, bufferCopySize);\n-            specializedHandle = collectArguments(specializedHandle, argAllocatorPos, makeScopeHandle);\n+            specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, false);\n@@ -274,6 +247,0 @@\n-    private static Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n-        return IntStream.range(0, moves.length)\n-                        .boxed()\n-                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n-    }\n-\n@@ -289,1 +256,1 @@\n-    Object invokeMoves(Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n+    Object invokeMoves(long addr, Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n@@ -296,1 +263,1 @@\n-            VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr.address().toRawLongValue());\n+            VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr);\n@@ -343,1 +310,1 @@\n-    Object invokeInterpBindings(Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(Addressable address, Object[] args, MethodHandle leaf,\n@@ -346,4 +313,1 @@\n-        SharedUtils.Allocator unboxAllocator = bufferCopySize != 0\n-                ? SharedUtils.Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n-                : THROWING_ALLOCATOR;\n-        try (unboxAllocator) {\n+        try (Allocator unboxAllocator = SharedUtils.makeAllocator(bufferCopySize)) {\n@@ -351,1 +315,2 @@\n-            Object[] moves = new Object[leaf.type().parameterCount()];\n+            Object[] leafArgs = new Object[leaf.type().parameterCount()];\n+            leafArgs[0] = address; \/\/ addr\n@@ -356,1 +321,1 @@\n-                            moves[argIndexMap.get(storage)] = value;\n+                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip addr\n@@ -361,1 +326,1 @@\n-            Object o = leaf.invokeWithArguments(moves);\n+            Object o = leaf.invokeWithArguments(leafArgs);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":50,"deletions":85,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -32,0 +31,2 @@\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,2 +34,2 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.vm.annotation.Stable;\n+import jdk.internal.foreign.abi.SharedUtils.Allocator;\n+import sun.security.action.GetPropertyAction;\n@@ -37,0 +38,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -39,2 +41,0 @@\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n@@ -42,0 +42,2 @@\n+import java.util.List;\n+import java.util.Map;\n@@ -43,0 +45,1 @@\n+import java.util.stream.Stream;\n@@ -44,1 +47,7 @@\n-import static jdk.internal.foreign.abi.SharedUtils.DEFAULT_ALLOCATOR;\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n+import static java.lang.invoke.MethodHandles.identity;\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.foreign.abi.SharedUtils.mergeArguments;\n@@ -52,2 +61,1 @@\n-public class ProgrammableUpcallHandler implements UpcallHandler {\n-\n+public class ProgrammableUpcallHandler {\n@@ -56,0 +64,6 @@\n+    private static final boolean USE_SPEC = Boolean.parseBoolean(\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC\", \"true\"));\n+    private static final boolean USE_INTRINSICS = Boolean.parseBoolean(\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS\", \"true\"));\n+\n+    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n@@ -59,16 +73,15 @@\n-    @Stable\n-    private final MethodHandle mh;\n-    private final MethodType type;\n-    private final CallingSequence callingSequence;\n-    private final long entryPoint;\n-\n-    private final ABIDescriptor abi;\n-    private final BufferLayout layout;\n-\n-    public ProgrammableUpcallHandler(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n-        this.abi = abi;\n-        this.layout = BufferLayout.of(abi);\n-        this.type = callingSequence.methodType();\n-        this.callingSequence = callingSequence;\n-        this.mh = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n-        this.entryPoint = allocateUpcallStub(abi, layout);\n+    private static final MethodHandle MH_invokeMoves;\n+    private static final MethodHandle MH_invokeInterpBindings;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = lookup();\n+            MH_invokeMoves = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeMoves\",\n+                    methodType(void.class, MemoryAddress.class, MethodHandle.class,\n+                               Binding.VMLoad[].class, Binding.VMStore[].class, ABIDescriptor.class, BufferLayout.class));\n+            MH_invokeInterpBindings = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeInterpBindings\",\n+                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class,\n+                            CallingSequence.class, long.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n@@ -77,3 +90,47 @@\n-    @Override\n-    public long entryPoint() {\n-        return entryPoint;\n+    public static UpcallHandler make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n+        Binding.VMLoad[] argMoves = argMoveBindings(callingSequence);\n+        Binding.VMStore[] retMoves = retMoveBindings(callingSequence);\n+\n+        boolean isSimple = !(retMoves.length > 1);\n+\n+        Class<?> llReturn = !isSimple\n+            ? Object[].class\n+            : retMoves.length == 1\n+                ? retMoves[0].type()\n+                : void.class;\n+        Class<?>[] llParams = Arrays.stream(argMoves).map(Binding.Move::type).toArray(Class<?>[]::new);\n+        MethodType llType = MethodType.methodType(llReturn, llParams);\n+\n+        MethodHandle doBindings;\n+        long bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n+        if (USE_SPEC && isSimple) {\n+            doBindings = specializedBindingHandle(target, callingSequence, llReturn, bufferCopySize);\n+            assert doBindings.type() == llType;\n+        } else {\n+            Map<VMStorage, Integer> argIndices = SharedUtils.indexMap(argMoves);\n+            Map<VMStorage, Integer> retIndices = SharedUtils.indexMap(retMoves);\n+            target = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n+            doBindings = insertArguments(MH_invokeInterpBindings, 1, target, argIndices, retIndices, callingSequence,\n+                    bufferCopySize);\n+            doBindings = doBindings.asCollector(Object[].class, llType.parameterCount());\n+            doBindings = doBindings.asType(llType);\n+        }\n+\n+        long entryPoint;\n+        boolean usesStackArgs = argMoveBindingsStream(callingSequence)\n+                .map(Binding.VMLoad::storage)\n+                .anyMatch(s -> abi.arch.isStackType(s.type()));\n+        if (USE_INTRINSICS && isSimple && !usesStackArgs && supportsOptimizedUpcalls()) {\n+            checkPrimitive(doBindings.type());\n+            JLI.ensureCustomized(doBindings);\n+            VMStorage[] args = Arrays.stream(argMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+            VMStorage[] rets = Arrays.stream(retMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+            CallRegs conv = new CallRegs(args, rets);\n+            entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv);\n+        } else {\n+            BufferLayout layout = BufferLayout.of(abi);\n+            MethodHandle doBindingsErased = doBindings.asSpreader(Object[].class, doBindings.type().parameterCount());\n+            MethodHandle invokeMoves = insertArguments(MH_invokeMoves, 1, doBindingsErased, argMoves, retMoves, abi, layout);\n+            entryPoint = allocateUpcallStub(invokeMoves, abi, layout);\n+        }\n+        return () -> entryPoint;\n@@ -82,2 +139,4 @@\n-    public static void invoke(ProgrammableUpcallHandler handler, long address) {\n-        handler.invoke(MemoryAddress.ofLong(address));\n+    private static void checkPrimitive(MethodType type) {\n+        if (!type.returnType().isPrimitive()\n+                || type.parameterList().stream().anyMatch(p -> !p.isPrimitive()))\n+            throw new IllegalArgumentException(\"MethodHandle type must be primitive: \" + type);\n@@ -86,3 +145,5 @@\n-    private void invoke(MemoryAddress buffer) {\n-        try {\n-            MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n+    private static Stream<Binding.VMLoad> argMoveBindingsStream(CallingSequence callingSequence) {\n+        return callingSequence.argumentBindings()\n+                .filter(Binding.VMLoad.class::isInstance)\n+                .map(Binding.VMLoad.class::cast);\n+    }\n@@ -90,3 +151,31 @@\n-            if (DEBUG) {\n-                System.err.println(\"Buffer state before:\");\n-                layout.dump(abi.arch, bufferBase, System.err);\n+    private static Binding.VMLoad[] argMoveBindings(CallingSequence callingSequence) {\n+        return argMoveBindingsStream(callingSequence)\n+                .toArray(Binding.VMLoad[]::new);\n+    }\n+\n+    private static Binding.VMStore[] retMoveBindings(CallingSequence callingSequence) {\n+        return callingSequence.returnBindings().stream()\n+                .filter(Binding.VMStore.class::isInstance)\n+                .map(Binding.VMStore.class::cast)\n+                .toArray(Binding.VMStore[]::new);\n+    }\n+\n+    private static MethodHandle specializedBindingHandle(MethodHandle target, CallingSequence callingSequence,\n+                                                         Class<?> llReturn, long bufferCopySize) {\n+        MethodType highLevelType = callingSequence.methodType();\n+\n+        MethodHandle specializedHandle = target; \/\/ initial\n+\n+        int argAllocatorPos = 0;\n+        int argInsertPos = 1;\n+        specializedHandle = dropArguments(specializedHandle, argAllocatorPos, SharedUtils.Allocator.class);\n+        for (int i = 0; i < highLevelType.parameterCount(); i++) {\n+            MethodHandle filter = identity(highLevelType.parameterType(i));\n+            int filterAllocatorPos = 0;\n+            int filterInsertPos = 1; \/\/ +1 for allocator\n+            filter = dropArguments(filter, filterAllocatorPos, Allocator.class);\n+\n+            List<Binding> bindings = callingSequence.argumentBindings(i);\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                filter = binding.specialize(filter, filterInsertPos, filterAllocatorPos);\n@@ -94,0 +183,4 @@\n+            specializedHandle = MethodHandles.collectArguments(specializedHandle, argInsertPos, filter);\n+            specializedHandle = mergeArguments(specializedHandle, argAllocatorPos, argInsertPos + filterAllocatorPos);\n+            argInsertPos += filter.type().parameterCount() - 1; \/\/ -1 for allocator\n+        }\n@@ -95,3 +188,76 @@\n-            MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n-            Object[] args = new Object[type.parameterCount()];\n-            for (int i = 0 ; i < type.parameterCount() ; i++) {\n+        if (llReturn != void.class) {\n+            int retAllocatorPos = -1; \/\/ assumed not needed\n+            int retInsertPos = 0;\n+            MethodHandle filter = identity(llReturn);\n+            List<Binding> bindings = callingSequence.returnBindings();\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n+            }\n+            specializedHandle = filterReturnValue(specializedHandle, filter);\n+        }\n+\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, true);\n+\n+        return specializedHandle;\n+    }\n+\n+    public static void invoke(MethodHandle mh, long address) throws Throwable {\n+        mh.invokeExact(MemoryAddress.ofLong(address));\n+    }\n+\n+    private static void invokeMoves(MemoryAddress buffer, MethodHandle leaf,\n+                                    Binding.VMLoad[] argBindings, Binding.VMStore[] returnBindings,\n+                                    ABIDescriptor abi, BufferLayout layout) throws Throwable {\n+        MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n+\n+        if (DEBUG) {\n+            System.err.println(\"Buffer state before:\");\n+            layout.dump(abi.arch, bufferBase, System.err);\n+        }\n+\n+        MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n+        Object[] moves = new Object[argBindings.length];\n+        for (int i = 0; i < moves.length; i++) {\n+            Binding.VMLoad binding = argBindings[i];\n+            VMStorage storage = binding.storage();\n+            MemorySegment ptr = abi.arch.isStackType(storage.type())\n+                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n+                : bufferBase.asSlice(layout.argOffset(storage));\n+            moves[i] = SharedUtils.read(ptr, binding.type());\n+        }\n+\n+        \/\/ invokeInterpBindings, and then actual target\n+        Object o = leaf.invoke(moves);\n+\n+        if (o == null) {\n+            \/\/ nop\n+        } else if (o instanceof Object[] returns) {\n+            for (int i = 0; i < returnBindings.length; i++) {\n+                Binding.VMStore binding = returnBindings[i];\n+                VMStorage storage = binding.storage();\n+                MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n+                SharedUtils.writeOverSized(ptr, binding.type(), returns[i]);\n+            }\n+        } else { \/\/ single Object\n+            Binding.VMStore binding = returnBindings[0];\n+            VMStorage storage = binding.storage();\n+            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n+            SharedUtils.writeOverSized(ptr, binding.type(), o);\n+        }\n+\n+        if (DEBUG) {\n+            System.err.println(\"Buffer state after:\");\n+            layout.dump(abi.arch, bufferBase, System.err);\n+        }\n+    }\n+\n+    private static Object invokeInterpBindings(Object[] moves, MethodHandle leaf,\n+                                               Map<VMStorage, Integer> argIndexMap,\n+                                               Map<VMStorage, Integer> retIndexMap,\n+                                               CallingSequence callingSequence,\n+                                               long bufferCopySize) throws Throwable {\n+        try (Allocator allocator = SharedUtils.makeAllocator(bufferCopySize)) {\n+            \/\/\/ Invoke interpreter, got array of high-level arguments back\n+            Object[] args = new Object[callingSequence.methodType().parameterCount()];\n+            for (int i = 0; i < args.length; i++) {\n@@ -99,6 +265,1 @@\n-                        (storage, type) -> {\n-                            MemorySegment ptr = abi.arch.isStackType(storage.type())\n-                                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n-                                : bufferBase.asSlice(layout.argOffset(storage));\n-                            return SharedUtils.read(ptr, type);\n-                        }, DEFAULT_ALLOCATOR);\n+                        (storage, type) -> moves[argIndexMap.get(storage)], allocator);\n@@ -112,1 +273,2 @@\n-            Object o = mh.invoke(args);\n+            \/\/ invoke our target\n+            Object o = leaf.invoke(args);\n@@ -119,1 +281,2 @@\n-            if (mh.type().returnType() != void.class) {\n+            Object[] returnMoves = new Object[retIndexMap.size()];\n+            if (leaf.type().returnType() != void.class) {\n@@ -121,4 +284,1 @@\n-                        (storage, type, value) -> {\n-                            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-                            SharedUtils.writeOverSized(ptr, type, value);\n-                        }, null);\n+                        (storage, type, value) -> returnMoves[retIndexMap.get(storage)] = value, null);\n@@ -127,3 +287,6 @@\n-            if (DEBUG) {\n-                System.err.println(\"Buffer state after:\");\n-                layout.dump(abi.arch, bufferBase, System.err);\n+            if (returnMoves.length == 0) {\n+                return null;\n+            } else if (returnMoves.length == 1) {\n+                return returnMoves[0];\n+            } else {\n+                return returnMoves;\n@@ -131,2 +294,0 @@\n-        } catch (Throwable t) {\n-            throw new IllegalStateException(t);\n@@ -136,1 +297,6 @@\n-    public native long allocateUpcallStub(ABIDescriptor abi, BufferLayout layout);\n+    \/\/ used for transporting data into native code\n+    private static record CallRegs(VMStorage[] argRegs, VMStorage[] retRegs) {}\n+\n+    public static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv);\n+    public static native long allocateUpcallStub(MethodHandle mh, ABIDescriptor abi, BufferLayout layout);\n+    public static native boolean supportsOptimizedUpcalls();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":222,"deletions":56,"binary":false,"changes":278,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -39,0 +40,1 @@\n+import jdk.internal.foreign.AbstractNativeScope;\n@@ -52,0 +54,1 @@\n+import java.util.Map;\n@@ -53,0 +56,1 @@\n+import java.util.stream.Collectors;\n@@ -56,0 +60,5 @@\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.dropReturn;\n+import static java.lang.invoke.MethodHandles.empty;\n+import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n@@ -59,0 +68,1 @@\n+import static java.lang.invoke.MethodHandles.tryFinally;\n@@ -67,0 +77,2 @@\n+    private static final MethodHandle MH_MAKE_ALLOCATOR;\n+    private static final MethodHandle MH_CLOSE_ALLOCATOR;\n@@ -79,0 +91,4 @@\n+            MH_MAKE_ALLOCATOR = lookup.findStatic(SharedUtils.class, \"makeAllocator\",\n+                    methodType(Allocator.class, long.class));\n+            MH_CLOSE_ALLOCATOR = lookup.findVirtual(Allocator.class, \"close\",\n+                    methodType(void.class));\n@@ -157,3 +173,3 @@\n-            throw new IllegalArgumentException(\"return expected to be void for in memory returns\");\n-        if (handle.type().parameterType(0) != MemoryAddress.class)\n-            throw new IllegalArgumentException(\"MemoryAddress expected as first param\");\n+            throw new IllegalArgumentException(\"return expected to be void for in memory returns: \" + handle.type());\n+        if (handle.type().parameterType(1) != MemoryAddress.class)\n+            throw new IllegalArgumentException(\"MemoryAddress expected as second param: \" + handle.type());\n@@ -164,8 +180,4 @@\n-        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, MemoryAddress ...) MemorySegment\n-        handle = collectArguments(handle, 1, MH_BASEADDRESS); \/\/ (MemorySegment, MemorySegment ...) MemorySegment\n-        MethodType oldType = handle.type(); \/\/ (MemorySegment, MemorySegment, ...) MemorySegment\n-        MethodType newType = oldType.dropParameterTypes(0, 1); \/\/ (MemorySegment, ...) MemorySegment\n-        int[] reorder = IntStream.range(-1, newType.parameterCount()).toArray();\n-        reorder[0] = 0; \/\/ [0, 0, 1, 2, 3, ...]\n-        handle = permuteArguments(handle, newType, reorder); \/\/ (MemorySegment, ...) MemoryAddress\n-        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 0, cDesc.returnLayout().get())); \/\/ (...) MemoryAddress\n+        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, Addressable, MemoryAddress, ...) MemorySegment\n+        handle = collectArguments(handle, 2, MH_BASEADDRESS); \/\/ (MemorySegment, Addressable, MemorySegment, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 2);  \/\/ (MemorySegment, Addressable, ...) MemorySegment\n+        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 0, cDesc.returnLayout().get())); \/\/ (Addressable, ...) MemoryAddress\n@@ -184,1 +196,1 @@\n-    public static MethodHandle adaptUpcallForIMR(MethodHandle target) {\n+    public static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n@@ -190,0 +202,4 @@\n+        if (dropReturn) { \/\/ no handling for return value, need to drop it\n+            target = dropReturn(target);\n+        }\n+\n@@ -226,9 +242,17 @@\n-    public static Class<?> primitiveCarrierForSize(long size) {\n-        if (size == 1) {\n-            return byte.class;\n-        } else if(size == 2) {\n-            return short.class;\n-        } else if (size <= 4) {\n-            return int.class;\n-        } else if (size <= 8) {\n-            return long.class;\n+    public static Class<?> primitiveCarrierForSize(long size, boolean useFloat) {\n+        if (useFloat) {\n+            if (size == 4) {\n+                return float.class;\n+            } else if (size == 8) {\n+                return double.class;\n+            }\n+        } else {\n+            if (size == 1) {\n+                return byte.class;\n+            } else if (size == 2) {\n+                return short.class;\n+            } else if (size <= 4) {\n+                return int.class;\n+            } else if (size <= 8) {\n+                return long.class;\n+            }\n@@ -237,1 +261,1 @@\n-        throw new IllegalArgumentException(\"Size too large: \" + size);\n+        throw new IllegalArgumentException(\"No type for size: \" + size + \" isFloat=\" + useFloat);\n@@ -267,0 +291,83 @@\n+    static long bufferCopySize(CallingSequence callingSequence) {\n+        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n+        \/\/ starting address of the allocator might be un-aligned.\n+        long size = 0;\n+        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n+            List<Binding> bindings = callingSequence.argumentBindings(i);\n+            for (Binding b : bindings) {\n+                if (b instanceof Binding.Copy) {\n+                    Binding.Copy c = (Binding.Copy) b;\n+                    size = Utils.alignUp(size, c.alignment());\n+                    size += c.size();\n+                } else if (b instanceof Binding.Allocate) {\n+                    Binding.Allocate c = (Binding.Allocate) b;\n+                    size = Utils.alignUp(size, c.alignment());\n+                    size += c.size();\n+                }\n+            }\n+        }\n+        return size;\n+    }\n+\n+    static Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n+        return IntStream.range(0, moves.length)\n+                        .boxed()\n+                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n+    }\n+\n+    static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {\n+        MethodType oldType = mh.type();\n+        Class<?> sourceType = oldType.parameterType(sourceIndex);\n+        Class<?> destType = oldType.parameterType(destIndex);\n+        if (sourceType != destType) {\n+            \/\/ TODO meet?\n+            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n+        }\n+        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n+        int[] reorder = new int[oldType.parameterCount()];\n+        assert destIndex > sourceIndex;\n+        for (int i = 0, index = 0; i < reorder.length; i++) {\n+            if (i != destIndex) {\n+                reorder[i] = index++;\n+            } else {\n+                reorder[i] = sourceIndex;\n+            }\n+        }\n+        return permuteArguments(mh, newType, reorder);\n+    }\n+\n+    static Allocator makeAllocator(long size) {\n+        return  size != 0\n+            ? Allocator.ofScope(NativeScope.boundedScope(size))\n+            : Allocator.empty();\n+    }\n+\n+    static MethodHandle wrapWithAllocator(MethodHandle specializedHandle,\n+                                          int allocatorPos, long bufferCopySize,\n+                                          boolean upcall) {\n+        \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n+        MethodHandle closer;\n+        int insertPos;\n+        if (specializedHandle.type().returnType() == void.class) {\n+            closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            insertPos = 1;\n+        } else {\n+            closer = identity(specializedHandle.type().returnType()); \/\/ (V) -> V\n+            closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n+            insertPos = 2;\n+        }\n+\n+        \/\/ downcalls get the leading Addressable param as well\n+        if (!upcall) {\n+            closer = dropArguments(closer, insertPos, Addressable.class); \/\/ (Throwable, V?, Addressable) -> V\/void\n+            insertPos++;\n+        }\n+\n+        closer = collectArguments(closer, insertPos, MH_CLOSE_ALLOCATOR); \/\/ (Throwable, V?, Addressable?, NativeScope) -> V\/void\n+\n+        specializedHandle = tryFinally(specializedHandle, closer);\n+        MethodHandle makeScopeHandle = insertArguments(MH_MAKE_ALLOCATOR, 0, bufferCopySize);\n+        specializedHandle = collectArguments(specializedHandle, allocatorPos, makeScopeHandle);\n+        return specializedHandle;\n+    }\n+\n@@ -307,1 +414,1 @@\n-            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize())))\n+            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n@@ -339,1 +446,1 @@\n-               handle = MethodHandles.filterArguments(handle, i, unboxer);\n+               handle = filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n@@ -349,1 +456,1 @@\n-               handle = MethodHandles.filterArguments(handle, i, boxer);\n+               handle = filterArguments(handle, i, boxer);\n@@ -369,1 +476,3 @@\n-        Allocator THROWING_ALLOCATOR = (size, align) -> { throw new UnsupportedOperationException(\"Null allocator\"); };\n+        static Allocator empty() {\n+            return Allocator.ofScope(AbstractNativeScope.emptyScope());\n+        }\n@@ -382,0 +491,4 @@\n+        default MemorySegment handoff(MemorySegment ms) {\n+            return ms;\n+        }\n+\n@@ -391,0 +504,5 @@\n+                @Override\n+                public MemorySegment handoff(MemorySegment ms) {\n+                    return ms.handoff(scope);\n+                }\n+\n@@ -412,1 +530,1 @@\n-                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize())))\n+                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":146,"deletions":28,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -82,1 +81,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -129,1 +127,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -132,1 +130,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(C, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(C, bindings.callingSequence).getBoundMethodHandle();\n@@ -145,1 +143,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n@@ -148,1 +146,1 @@\n-        return new ProgrammableUpcallHandler(C, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence);\n@@ -235,1 +233,1 @@\n-                Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -253,1 +251,1 @@\n-                Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -294,1 +292,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n@@ -327,1 +326,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, useFloat);\n@@ -396,1 +396,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n@@ -413,3 +414,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n@@ -429,1 +427,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, useFloat);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -126,1 +124,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -129,1 +127,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CSysV, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(CSysV, bindings.callingSequence).getBoundMethodHandle();\n@@ -143,1 +141,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n@@ -146,1 +144,1 @@\n-        return new ProgrammableUpcallHandler(CSysV, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence);\n@@ -273,1 +271,0 @@\n-                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n@@ -277,0 +274,2 @@\n+                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n@@ -327,1 +326,2 @@\n-                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -93,1 +92,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,1 +32,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -127,1 +125,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -130,1 +128,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CWindows, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(CWindows, bindings.callingSequence).getBoundMethodHandle();\n@@ -143,1 +141,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, false \/* need the return value as well *\/);\n@@ -146,1 +144,1 @@\n-        return new ProgrammableUpcallHandler(CWindows, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence);\n@@ -208,1 +206,1 @@\n-                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());\n+                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize(), false);\n@@ -273,1 +271,1 @@\n-                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());\n+                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize(), false);\n@@ -284,3 +282,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,2 +89,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -94,1 +93,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -340,1 +340,2 @@\n-    java\/foreign\n+    java\/foreign \\\n+    -java\/foreign\/TestMatrix.java\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,17 +33,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,8 +57,2 @@\n-    private static MethodHandle linkIndentity(String name, Class<?> carrier, MemoryLayout layout, boolean trivial) {\n-        LibraryLookup.Symbol ma = lookup.lookup(name).orElseThrow();\n-        MethodType mt = methodType(carrier, carrier);\n-        FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);\n-        if (trivial) {\n-            fd = fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true);\n-        }\n-        return abi.downcallHandle(ma, mt, fd);\n+    private interface RunnableX {\n+        void run() throws Throwable;\n@@ -74,8 +68,0 @@\n-    private interface RunnableX {\n-        void run() throws Throwable;\n-    }\n-\n-    private interface AddTest {\n-        void add(MethodHandle target, Object expectedResult, Object... args);\n-    }\n-\n@@ -85,0 +71,5 @@\n+\n+        interface AddTest {\n+            void add(MethodHandle target, Object expectedResult, Object... args);\n+        }\n+\n@@ -90,0 +81,14 @@\n+        interface AddIdentity {\n+            void add(String name, Class<?> carrier, MemoryLayout layout, Object arg);\n+        }\n+\n+        AddIdentity addIdentity = (name, carrier, layout, arg) -> {\n+            LibraryLookup.Symbol ma = lookup.lookup(name).orElseThrow();\n+            MethodType mt = methodType(carrier, carrier);\n+            FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);\n+\n+            tests.add(abi.downcallHandle(ma, mt, fd), arg, arg);\n+            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), arg, arg);\n+            tests.add(abi.downcallHandle(mt, fd), arg, ma, arg);\n+        };\n+\n@@ -98,12 +103,6 @@\n-        tests.add(linkIndentity(\"identity_char\", byte.class, C_CHAR, false), (byte) 10, (byte) 10);\n-        tests.add(linkIndentity(\"identity_char\", byte.class, C_CHAR, true), (byte) 10, (byte) 10);\n-        tests.add(linkIndentity(\"identity_short\", short.class, C_SHORT, false), (short) 10, (short) 10);\n-        tests.add(linkIndentity(\"identity_short\", short.class, C_SHORT, true), (short) 10, (short) 10);\n-        tests.add(linkIndentity(\"identity_int\", int.class, C_INT, false), 10, 10);\n-        tests.add(linkIndentity(\"identity_int\", int.class, C_INT, true), 10, 10);\n-        tests.add(linkIndentity(\"identity_long\", long.class, C_LONG_LONG, false), 10L, 10L);\n-        tests.add(linkIndentity(\"identity_long\", long.class, C_LONG_LONG, true), 10L, 10L);\n-        tests.add(linkIndentity(\"identity_float\", float.class, C_FLOAT, false), 10F, 10F);\n-        tests.add(linkIndentity(\"identity_float\", float.class, C_FLOAT, true), 10F, 10F);\n-        tests.add(linkIndentity(\"identity_double\", double.class, C_DOUBLE, false), 10D, 10D);\n-        tests.add(linkIndentity(\"identity_double\", double.class, C_DOUBLE, true), 10D, 10D);\n+        addIdentity.add(\"identity_char\",   byte.class,   C_CHAR,   (byte) 10);\n+        addIdentity.add(\"identity_short\",  short.class,  C_SHORT, (short) 10);\n+        addIdentity.add(\"identity_int\",    int.class,    C_INT,           10);\n+        addIdentity.add(\"identity_long\",   long.class,   C_LONG_LONG,     10L);\n+        addIdentity.add(\"identity_float\",  float.class,  C_FLOAT,         10F);\n+        addIdentity.add(\"identity_double\", double.class, C_DOUBLE,        10D);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":28,"deletions":29,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.nio.ByteOrder;\n@@ -53,1 +52,1 @@\n-        seq.bitOffset(PathElement.groupElement(\"foo\"));\n+        seq.bitOffset(groupElement(\"foo\"));\n@@ -59,1 +58,1 @@\n-        seq.byteOffset(PathElement.groupElement(\"foo\"));\n+        seq.byteOffset(groupElement(\"foo\"));\n@@ -89,1 +88,1 @@\n-        g.bitOffset(PathElement.groupElement(\"foo\"));\n+        g.bitOffset(groupElement(\"foo\"));\n@@ -95,1 +94,1 @@\n-        g.byteOffset(PathElement.groupElement(\"foo\"));\n+        g.byteOffset(groupElement(\"foo\"));\n@@ -171,1 +170,1 @@\n-        g.byteOffset(PathElement.groupElement(\"foo\"));\n+        g.byteOffset(groupElement(\"foo\"));\n@@ -215,2 +214,2 @@\n-            g.bitOffset(PathElement.groupElement(\"foo\"));\n-            g.byteOffset(PathElement.groupElement(\"foo\"));\n+            g.bitOffset(groupElement(\"foo\"));\n+            g.byteOffset(groupElement(\"foo\"));\n@@ -221,1 +220,1 @@\n-            g.varHandle(int.class, PathElement.groupElement(\"foo\")); \/\/ok\n+            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n@@ -234,2 +233,2 @@\n-            g.bitOffset(PathElement.groupElement(\"foo\"));\n-            g.byteOffset(PathElement.groupElement(\"foo\"));\n+            g.bitOffset(groupElement(\"foo\"));\n+            g.byteOffset(groupElement(\"foo\"));\n@@ -240,1 +239,1 @@\n-            g.varHandle(int.class, PathElement.groupElement(\"foo\")); \/\/ok\n+            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n@@ -308,1 +307,1 @@\n-            MemoryLayout selected = g.select(PathElement.groupElement(String.valueOf(i)));\n+            MemoryLayout selected = g.select(groupElement(String.valueOf(i)));\n@@ -315,1 +314,1 @@\n-            long bitOffset = g.bitOffset(PathElement.groupElement(String.valueOf(i)));\n+            long bitOffset = g.bitOffset(groupElement(String.valueOf(i)));\n@@ -317,1 +316,1 @@\n-            long byteOffset = g.byteOffset(PathElement.groupElement(String.valueOf(i)));\n+            long byteOffset = g.byteOffset(groupElement(String.valueOf(i)));\n@@ -324,1 +323,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, PathElement.groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -349,1 +348,1 @@\n-            MemoryLayout selected = g.select(PathElement.groupElement(String.valueOf(i)));\n+            MemoryLayout selected = g.select(groupElement(String.valueOf(i)));\n@@ -356,1 +355,1 @@\n-            long bitOffset = g.bitOffset(PathElement.groupElement(String.valueOf(i)));\n+            long bitOffset = g.bitOffset(groupElement(String.valueOf(i)));\n@@ -358,1 +357,1 @@\n-            long byteOffset = g.byteOffset(PathElement.groupElement(String.valueOf(i)));\n+            long byteOffset = g.byteOffset(groupElement(String.valueOf(i)));\n@@ -365,1 +364,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, PathElement.groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity TestUpcall TestDowncall\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ *\n+  * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestDowncall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ *\/\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -33,17 +33,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -89,1 +72,2 @@\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\", MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n+            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\",\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, List.class));\n@@ -159,1 +143,1 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, segments);\n@@ -197,1 +181,10 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+                copies.add(copy);\n+            }\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -33,17 +33,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -102,1 +85,1 @@\n-                    MethodType.methodType(void.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(void.class, Object[].class, AtomicReference.class, List.class));\n@@ -108,1 +91,10 @@\n-    static void passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static void passAndSave(Object[] o, AtomicReference<Object[]> ref, List<MemorySegment> copies) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+                copies.add(copy);\n+            }\n+        }\n@@ -115,0 +107,1 @@\n+        List<MemorySegment> segments = new ArrayList<>();\n@@ -116,1 +109,1 @@\n-        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs)\n+        MethodHandle target = MethodHandles.insertArguments(MH_passAndSave, 1, capturedArgs, segments)\n@@ -120,1 +113,0 @@\n-            List<MemorySegment> segments = new ArrayList<>();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ *\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   TestUpcallStructScope\n+ * @run testng\/othervm\/native\n+ *   -Dforeign.restricted=permit\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   TestUpcallStructScope\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static org.testng.Assert.assertFalse;\n+\n+public class TestUpcallStructScope {\n+    static final MethodHandle MH_do_upcall;\n+    static final CLinker LINKER = CLinker.getInstance();\n+    static final MethodHandle MH_Consumer_accept;\n+\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.ofStruct(\n+        C_POINTER.withName(\"p0\"),\n+        C_DOUBLE.withName(\"p1\"),\n+        C_INT.withName(\"p2\")\n+    );\n+\n+    static {\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallStructScope\");\n+        MH_do_upcall = LINKER.downcallHandle(\n+            lookup.lookup(\"do_upcall\").orElseThrow(),\n+            MethodType.methodType(void.class, MemoryAddress.class, MemorySegment.class),\n+            FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n+        );\n+\n+        try {\n+            MH_Consumer_accept = MethodHandles.publicLookup().findVirtual(Consumer.class, \"accept\",\n+                    MethodType.methodType(void.class, Object.class));\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static MethodHandle methodHandle (Consumer<MemorySegment> callback) {\n+        return MH_Consumer_accept.bindTo(callback).asType(MethodType.methodType(void.class, MemorySegment.class));\n+    }\n+\n+    @Test\n+    public void testUpcall() throws Throwable {\n+        AtomicReference<MemorySegment> capturedSegment = new AtomicReference<>();\n+        MethodHandle target = methodHandle(capturedSegment::set);\n+        FunctionDescriptor upcallDesc = FunctionDescriptor.ofVoid(S_PDI_LAYOUT);\n+        try (MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc);\n+             MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT)) {\n+\n+            MH_do_upcall.invokeExact(upcallStub.address(), argSegment);\n+        }\n+\n+        MemorySegment captured = capturedSegment.get();\n+        assertFalse(captured.isAlive());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -284,4 +284,4 @@\n-                bufferLoad(0, int.class),\n-                vmStore(v1, int.class),\n-                bufferLoad(4, int.class),\n-                vmStore(v2, int.class)\n+                bufferLoad(0, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(4, float.class),\n+                vmStore(v2, float.class)\n@@ -294,2 +294,2 @@\n-            vmLoad(v0, int.class),\n-            bufferStore(0, int.class),\n+            vmLoad(v0, float.class),\n+            bufferStore(0, float.class),\n@@ -297,2 +297,2 @@\n-            vmLoad(v1, int.class),\n-            bufferStore(4, int.class),\n+            vmLoad(v1, float.class),\n+            bufferStore(4, float.class),\n@@ -318,2 +318,2 @@\n-                bufferLoad(0, int.class),\n-                vmStore(v0, int.class),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n@@ -321,4 +321,4 @@\n-                bufferLoad(4, int.class),\n-                vmStore(v1, int.class),\n-                bufferLoad(8, int.class),\n-                vmStore(v2, int.class)\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class)\n@@ -328,2 +328,2 @@\n-                bufferLoad(0, int.class),\n-                vmStore(v3, int.class),\n+                bufferLoad(0, float.class),\n+                vmStore(v3, float.class),\n@@ -331,4 +331,4 @@\n-                bufferLoad(4, int.class),\n-                vmStore(v4, int.class),\n-                bufferLoad(8, int.class),\n-                vmStore(v5, int.class)\n+                bufferLoad(4, float.class),\n+                vmStore(v4, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v5, float.class)\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-                bufferLoad(8, long.class), vmStore(xmm0, long.class)\n+                bufferLoad(8, double.class), vmStore(xmm0, double.class)\n@@ -487,0 +487,24 @@\n+    @Test\n+    public void testFloatStructsUpcall() {\n+        MemoryLayout struct = MemoryLayout.ofStruct(C_FLOAT); \/\/ should be passed in float regs\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct, struct);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, true);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { allocate(struct), dup(), vmLoad(xmm0, float.class), bufferStore(0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[] {\n+            bufferLoad(0, float.class), vmStore(xmm0, float.class)\n+        });\n+\n+        assertEquals(bindings.nVectorArgs, 1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n-EXPORT void blank(void (*cb)(void)) {\n-    cb();\n-}\n+struct S_PDI { void* p0; double p1; int p2; };\n@@ -34,2 +32,2 @@\n-EXPORT int identity(int x, int (*cb)(int)) {\n-    return cb(x);\n+EXPORT void do_upcall(void (*cb)(struct S_PDI), struct S_PDI a0) {\n+    cb(a0);\n","filename":"test\/jdk\/java\/foreign\/libTestUpcallStructScope.c","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcalls.c","status":"copied"},{"patch":"@@ -108,1 +108,2 @@\n-            WB.verifyFrames(true);\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/true);\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/false); \/\/ triggers different code paths\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-                { platformVaListFactory, sumStackNative, C_LONG_LONG,         C_DOUBLE         },\n+                { platformVaListFactory, sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   TestVirtualCalls\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import org.testng.annotations.*;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestVirtualCalls {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"Virtual\");\n+\n+    static final MethodHandle func;\n+    static final LibraryLookup.Symbol funcA;\n+    static final LibraryLookup.Symbol funcB;\n+    static final LibraryLookup.Symbol funcC;\n+\n+    static {\n+        func = abi.downcallHandle(\n+            MethodType.methodType(int.class),\n+            FunctionDescriptor.of(C_INT));\n+\n+        funcA = lookup.lookup(\"funcA\").orElseThrow();\n+        funcB = lookup.lookup(\"funcB\").orElseThrow();\n+        funcC = lookup.lookup(\"funcC\").orElseThrow();\n+    }\n+\n+    @Test\n+    public void testVirtualCalls() throws Throwable {\n+        assertEquals((int) func.invokeExact((Addressable) funcA), 1);\n+        assertEquals((int) func.invokeExact((Addressable) funcB), 2);\n+        assertEquals((int) func.invokeExact((Addressable) funcC), 3);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int funcA() {\n+    return 1;\n+}\n+\n+EXPORT int funcB() {\n+    return 2;\n+}\n+\n+EXPORT int funcC() {\n+    return 3;\n+}\n","filename":"test\/jdk\/java\/foreign\/virtual\/libVirtual.c","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -641,1 +641,1 @@\n-  public native void verifyFrames(boolean log);\n+  public native void verifyFrames(boolean log, boolean updateRegisterMap);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.LibraryLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.CLinker;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n-public class CallOverhead {\n-\n-    static final CLinker abi = CLinker.getInstance();\n-\n-    static final MethodHandle func;\n-    static final MethodHandle identity;\n-    static final MethodHandle identity_struct;\n-    static final MethodHandle identity_memory_address;\n-    static final MethodHandle args5;\n-    static final MethodHandle args10;\n-    static final MethodHandle func_trivial;\n-    static final MethodHandle identity_trivial;\n-\n-    static final MemoryLayout POINT_LAYOUT = MemoryLayout.ofStruct(\n-            C_LONG_LONG, C_LONG_LONG\n-    );\n-\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT);\n-\n-    static {\n-        System.loadLibrary(\"CallOverheadJNI\");\n-\n-        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n-        {\n-            LibraryLookup.Symbol addr = ll.lookup(\"func\").get();\n-            MethodType mt = MethodType.methodType(void.class);\n-            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n-            func = abi.downcallHandle(addr, mt, fd);\n-            func_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        }\n-        {\n-            LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n-            MethodType mt = MethodType.methodType(int.class, int.class);\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n-            identity = abi.downcallHandle(addr, mt, fd);\n-            identity_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        }\n-        identity_struct = abi.downcallHandle(ll.lookup(\"identity_struct\").get(),\n-                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n-                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n-        identity_memory_address = abi.downcallHandle(ll.lookup(\"identity_memory_address\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_POINTER, C_POINTER));\n-        args5 = abi.downcallHandle(ll.lookup(\"args5\").get(),\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n-        args10 = abi.downcallHandle(ll.lookup(\"args10\").get(),\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n-                                                  double.class, long.class, double.class, long.class, double.class),\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n-                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n-    }\n-\n-    static native void blank();\n-    static native int identity(int x);\n-\n-    @Benchmark\n-    public void jni_blank() throws Throwable {\n-        blank();\n-    }\n-\n-    @Benchmark\n-    public void panama_blank() throws Throwable {\n-        func.invokeExact();\n-    }\n-\n-    @Benchmark\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n-    }\n-\n-    @Benchmark\n-    public int jni_identity() throws Throwable {\n-        return identity(10);\n-    }\n-\n-    @Benchmark\n-    public int panama_identity() throws Throwable {\n-        return (int) identity.invokeExact(10);\n-    }\n-\n-    @Benchmark\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n-    }\n-\n-    @Benchmark\n-    public MemorySegment panama_identity_struct() throws Throwable {\n-        return (MemorySegment) identity_struct.invokeExact(point);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n-    }\n-\n-    @Benchmark\n-    public void panama_args5() throws Throwable {\n-        args5.invokeExact(10L, 11D, 12L, 13D, 14L);\n-    }\n-\n-    @Benchmark\n-    public void panama_args10() throws Throwable {\n-        args10.invokeExact(10L, 11D, 12L, 13D, 14L,\n-                           15D, 16L, 17D, 18L, 19D);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverhead.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+public class CallOverheadConstant {\n+\n+    @Benchmark\n+    public void jni_blank() throws Throwable {\n+        blank();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank() throws Throwable {\n+        func.invokeExact();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial.invokeExact();\n+    }\n+\n+    @Benchmark\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity.invokeExact(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial.invokeExact(10);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(point);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_01() throws Throwable {\n+        args1.invokeExact(10L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_02() throws Throwable {\n+        args2.invokeExact(10L, 11D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_03() throws Throwable {\n+        args3.invokeExact(10L, 11D, 12L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_04() throws Throwable {\n+        args4.invokeExact(10L, 11D, 12L, 13D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_05() throws Throwable {\n+        args5.invokeExact(10L, 11D, 12L, 13D, 14L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_10() throws Throwable {\n+        args10.invokeExact(10L, 11D, 12L, 13D, 14L,\n+                           15D, 16L, 17D, 18L, 19D);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+public class CallOverheadHelper {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+\n+    static final MethodHandle func;\n+    static final MethodHandle func_v;\n+    static Addressable func_addr;\n+    static final MethodHandle identity;\n+    static final MethodHandle identity_v;\n+    static Addressable identity_addr;\n+    static final MethodHandle identity_struct;\n+    static final MethodHandle identity_struct_v;\n+    static Addressable identity_struct_addr;\n+    static final MethodHandle identity_memory_address;\n+    static final MethodHandle identity_memory_address_v;\n+    static Addressable identity_memory_address_addr;\n+    static final MethodHandle args1;\n+    static final MethodHandle args1_v;\n+    static Addressable args1_addr;\n+    static final MethodHandle args2;\n+    static final MethodHandle args2_v;\n+    static Addressable args2_addr;\n+    static final MethodHandle args3;\n+    static final MethodHandle args3_v;\n+    static Addressable args3_addr;\n+    static final MethodHandle args4;\n+    static final MethodHandle args4_v;\n+    static Addressable args4_addr;\n+    static final MethodHandle args5;\n+    static final MethodHandle args5_v;\n+    static Addressable args5_addr;\n+    static final MethodHandle args10;\n+    static final MethodHandle args10_v;\n+    static Addressable args10_addr;\n+    static final MethodHandle func_trivial;\n+    static final MethodHandle func_trivial_v;\n+    static final MethodHandle identity_trivial;\n+    static final MethodHandle identity_trivial_v;\n+\n+    static final MemoryLayout POINT_LAYOUT = MemoryLayout.ofStruct(\n+            C_LONG_LONG, C_LONG_LONG\n+    );\n+\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT);\n+\n+    static {\n+        System.loadLibrary(\"CallOverheadJNI\");\n+\n+        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n+        {\n+            func_addr = ll.lookup(\"func\").orElseThrow();\n+            MethodType mt = MethodType.methodType(void.class);\n+            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+            func_v = abi.downcallHandle(mt, fd);\n+            func = insertArguments(func_v, 0, func_addr);\n+            func_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n+        }\n+        {\n+            identity_addr = ll.lookup(\"identity\").orElseThrow();\n+            MethodType mt = MethodType.methodType(int.class, int.class);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+            identity_v = abi.downcallHandle(mt, fd);\n+            identity = insertArguments(identity_v, 0, identity_addr);\n+            identity_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n+        }\n+        identity_struct_addr = ll.lookup(\"identity_struct\").orElseThrow();\n+        identity_struct_v = abi.downcallHandle(\n+                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct = insertArguments(identity_struct_v, 0, identity_struct_addr);\n+\n+        identity_memory_address_addr = ll.lookup(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_v = abi.downcallHandle(\n+                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER));\n+        identity_memory_address = insertArguments(identity_memory_address_v, 0, identity_memory_address_addr);\n+\n+        args1_addr = ll.lookup(\"args1\").orElseThrow();\n+        args1_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG));\n+        args1 = insertArguments(args1_v, 0, args1_addr);\n+\n+        args2_addr = ll.lookup(\"args2\").orElseThrow();\n+        args2_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE));\n+        args2 = insertArguments(args2_v, 0, args2_addr);\n+\n+        args3_addr = ll.lookup(\"args3\").orElseThrow();\n+        args3_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args3 = insertArguments(args3_v, 0, args3_addr);\n+\n+        args4_addr = ll.lookup(\"args4\").orElseThrow();\n+        args4_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args4 = insertArguments(args4_v, 0, args4_addr);\n+\n+        args5_addr = ll.lookup(\"args5\").orElseThrow();\n+        args5_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args5 = insertArguments(args5_v, 0, args5_addr);\n+\n+        args10_addr = ll.lookup(\"args10\").orElseThrow();\n+        args10_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n+                                                  double.class, long.class, double.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n+                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args10 = insertArguments(args10_v, 0, args10_addr);\n+    }\n+\n+    static native void blank();\n+    static native int identity(int x);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+public class CallOverheadVirtual {\n+\n+    @Benchmark\n+    public void jni_blank() throws Throwable {\n+        blank();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank() throws Throwable {\n+        func_v.invokeExact(func_addr);\n+    }\n+\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial_v.invokeExact(func_addr);\n+    }\n+\n+    @Benchmark\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity_v.invokeExact(identity_addr, 10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, point);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, MemoryAddress.NULL);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_01() throws Throwable {\n+        args1_v.invokeExact(args1_addr, 10L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_02() throws Throwable {\n+        args2_v.invokeExact(args2_addr, 10L, 11D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_03() throws Throwable {\n+        args3_v.invokeExact(args3_addr, 10L, 11D, 12L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_04() throws Throwable {\n+        args4_v.invokeExact(args4_addr, 10L, 11D, 12L, 13D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_05() throws Throwable {\n+        args5_v.invokeExact(args5_addr, 10L, 11D, 12L, 13D, 14L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_10() throws Throwable {\n+        args10_v.invokeExact(args10_addr,\n+                           10L, 11D, 12L, 13D, 14L,\n+                           15D, 16L, 17D, 18L, 19D);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+public class StrLenTest {\n+\n+    NativeScope scope = NativeScope.unboundedScope();\n+\n+    @Param({\"5\", \"20\", \"100\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"StrLen\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+    static final MethodHandle STRLEN_TRIVIAL;\n+    static final MethodHandle MALLOC_TRIVIAL;\n+    static final MethodHandle FREE_TRIVIAL;\n+\n+    static {\n+        LibraryLookup lookup = LibraryLookup.ofDefault();\n+        CLinker abi = CLinker.getInstance();\n+        STRLEN = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+        STRLEN_TRIVIAL = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+        MALLOC_TRIVIAL = abi.downcallHandle(lookup.lookup(\"malloc\").get(),\n+                MethodType.methodType(MemoryAddress.class, long.class),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+\n+        FREE_TRIVIAL = abi.downcallHandle(lookup.lookup(\"free\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    public int jni_strlen() throws Throwable {\n+        return strlen(str);\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen() throws Throwable {\n+        try (MemorySegment segment = CLinker.toCString(str)) {\n+            return (int)STRLEN.invokeExact(segment.address());\n+        }\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_scope() throws Throwable {\n+        return (int)STRLEN.invokeExact(CLinker.toCString(str, scope).address());\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_unsafe() throws Throwable {\n+        MemoryAddress address = makeStringUnsafe(str);\n+        int res = (int) STRLEN.invokeExact(address);\n+        CLinker.freeMemoryRestricted(address);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_unsafe_trivial() throws Throwable {\n+        MemoryAddress address = makeStringUnsafeTrivial(str);\n+        int res = (int) STRLEN_TRIVIAL.invokeExact(address);\n+        FREE_TRIVIAL.invokeExact(address);\n+        return res;\n+    }\n+\n+    static MemoryAddress makeStringUnsafe(String s) {\n+        byte[] bytes = s.getBytes();\n+        int len = bytes.length;\n+        MemoryAddress address = CLinker.allocateMemoryRestricted(len + 1);\n+        MemorySegment str = address.asSegmentRestricted(len + 1);\n+        str.copyFrom(MemorySegment.ofArray(bytes));\n+        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        return address;\n+    }\n+\n+    static MemoryAddress makeStringUnsafeTrivial(String s) throws Throwable {\n+        byte[] bytes = s.getBytes();\n+        int len = bytes.length;\n+        MemoryAddress address = (MemoryAddress)MALLOC_TRIVIAL.invokeExact((long)len + 1);\n+        MemorySegment str = address.asSegmentRestricted(len + 1);\n+        str.copyFrom(MemorySegment.ofArray(bytes));\n+        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        return address;\n+    }\n+\n+    static native int strlen(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n@@ -44,0 +45,1 @@\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n@@ -57,0 +59,2 @@\n+    static final MethodHandle args5;\n+    static final MethodHandle args10;\n@@ -60,0 +64,2 @@\n+    static final MemoryAddress cb_args5;\n+    static final MemoryAddress cb_args10;\n@@ -63,0 +69,2 @@\n+    static final long cb_args5_jni;\n+    static final long cb_args10_jni;\n@@ -70,0 +78,2 @@\n+        cb_args5_jni = makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -74,9 +84,24 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"blank\").get();\n-                MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);\n-                FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_POINTER);\n-                blank = abi.downcallHandle(addr, mt, fd);\n-\n-                cb_blank = abi.upcallStub(\n-                    lookup().findStatic(Upcalls.class, \"blank\", MethodType.methodType(void.class)),\n-                    FunctionDescriptor.ofVoid()\n-                ).address();\n+                String name = \"blank\";\n+                MethodType mt = MethodType.methodType(void.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+\n+                blank = linkFunc(ll, name, mt, fd);\n+                cb_blank = makeCB(name, mt, fd);\n+            }\n+            {\n+                String name = \"identity\";\n+                MethodType mt = MethodType.methodType(int.class, int.class);\n+                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+\n+                identity = linkFunc(ll, name, mt, fd);\n+                cb_identity = makeCB(name, mt, fd);\n+            }\n+            {\n+                String name = \"args5\";\n+                MethodType mt = MethodType.methodType(void.class,\n+                        long.class, double.class, long.class, double.class, long.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                        C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG);\n+\n+                args5 = linkFunc(ll, name, mt, fd);\n+                cb_args5 = makeCB(name, mt, fd);\n@@ -85,9 +110,10 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n-                MethodType mt = MethodType.methodType(int.class, int.class, MemoryAddress.class);\n-                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, C_POINTER);\n-                identity = abi.downcallHandle(addr, mt, fd);\n-\n-                cb_identity = abi.upcallStub(\n-                    lookup().findStatic(Upcalls.class, \"identity\", MethodType.methodType(int.class, int.class)),\n-                    FunctionDescriptor.of(C_INT, C_INT)\n-                ).address();\n+                String name = \"args10\";\n+                MethodType mt = MethodType.methodType(void.class,\n+                        long.class, double.class, long.class, double.class, long.class,\n+                        double.class, long.class, double.class, long.class, double.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                        C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n+                        C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE);\n+\n+                args10 = linkFunc(ll, name, mt, fd);\n+                cb_args10 = makeCB(name, mt, fd);\n@@ -100,0 +126,15 @@\n+    static MethodHandle linkFunc(LibraryLookup ll, String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+        return abi.downcallHandle(\n+            ll.lookup(name).orElseThrow(),\n+            baseType.insertParameterTypes(baseType.parameterCount(), MemoryAddress.class),\n+            baseDesc.withAppendedArgumentLayouts(C_POINTER)\n+        );\n+    }\n+\n+    static MemoryAddress makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+        return abi.upcallStub(\n+            lookup().findStatic(Upcalls.class, name, mt),\n+            fd\n+        ).address();\n+    }\n+\n@@ -102,0 +143,3 @@\n+    static native void args5(long a0, double a1, long a2, double a3, long a4, long cb);\n+    static native void args10(long a0, double a1, long a2, double a3, long a4,\n+                              double a5, long a6, double a7, long a8, double a9, long cb);\n@@ -119,0 +163,10 @@\n+    @Benchmark\n+    public void jni_args5() throws Throwable {\n+        args5(1L, 2D, 3L, 4D, 5L, cb_args5_jni);\n+    }\n+\n+    @Benchmark\n+    public void jni_args10() throws Throwable {\n+        args10(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10_jni);\n+    }\n+\n@@ -124,0 +178,10 @@\n+    @Benchmark\n+    public void panama_args5() throws Throwable {\n+        args5.invokeExact(1L, 2D, 3L, 4D, 5L, cb_args5);\n+    }\n+\n+    @Benchmark\n+    public void panama_args10() throws Throwable {\n+        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10);\n+    }\n+\n@@ -126,0 +190,3 @@\n+    static void args5(long a0, double a1, long a2, double a3, long a4) { }\n+    static void args10(long a0, double a1, long a2, double a3, long a4,\n+                       double a5, long a6, double a7, long a8, double a9) { }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":85,"deletions":18,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,4 @@\n+EXPORT void args1(long long a0) {}\n+EXPORT void args2(long long a0, double a1) {}\n+EXPORT void args3(long long a0, double a1, long long a2) {}\n+EXPORT void args4(long long a0, double a1, long long a2, double a3) {}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverhead.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverhead_blank\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_blank\n@@ -36,1 +36,1 @@\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverhead_identity\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_identity\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverheadJNI.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_StrLenTest_strlen(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    int len = (int)strlen(str);\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return len;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libStrLen.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -37,0 +37,12 @@\n+\n+EXPORT void args5(long long a0, double a1, long long a2, double a3, long long a4,\n+                  void (*cb)(long long, double, long long, double, long long)) {\n+    cb(a0, a1, a2, a3, a4);\n+}\n+\n+EXPORT void args10(long long a0, double a1, long long a2, double a3, long long a4,\n+                   double a5, long long a6, double a7, long long a8, double a9,\n+                   void (*cb)(long long, double, long long, double, long long,\n+                              double, long long, double, long long, double)) {\n+    cb(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcalls.c","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,8 +27,0 @@\n-void blank(void (*cb)(void)) {\n-    cb();\n-}\n-\n-int identity(int x, int (*cb)(int)) {\n-    return cb(x);\n-}\n-\n@@ -85,0 +77,17 @@\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args5\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4);\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args10\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jdouble a5, jlong a6, jdouble a7, jlong a8, jdouble a9,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"}]}