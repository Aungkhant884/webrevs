{"files":[{"patch":"@@ -59,1 +59,1 @@\n- * <h2>Implicit closure<\/h2>\n+ * <h2><a id = \"implicit-closure\">Implicit closure<\/a><\/h2>\n@@ -175,1 +175,4 @@\n-     * acquired handles have been closed first.\n+     * acquired handles have been closed first. Additionally, a resource scope handle maintains a strong reference\n+     * to its resource scope; this means that if a resource scope features\n+     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>, the scope cannot be implicitly closed\n+     * until all its acquired handles becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.ref.Reference;\n@@ -44,2 +45,2 @@\n-    public ConfinedScope(Thread owner, Object ref, Cleaner cleaner, boolean closeable) {\n-        super(ref, cleaner, closeable, new ConfinedResourceList());\n+    public ConfinedScope(Thread owner, Object ref, Cleaner cleaner) {\n+        super(ref, cleaner, new ConfinedResourceList());\n@@ -67,1 +68,0 @@\n-        if (!closeable) return DUMMY_LOCK;\n@@ -124,0 +124,1 @@\n+                Reference.reachabilityFence(ConfinedScope.this);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    final boolean closeable;\n@@ -92,1 +91,1 @@\n-    protected MemoryScope(Object ref, Cleaner cleaner, boolean closeable, ResourceList resourceList) {\n+    protected MemoryScope(Object ref, Cleaner cleaner, ResourceList resourceList) {\n@@ -95,1 +94,0 @@\n-        this.closeable = closeable;\n@@ -102,1 +100,1 @@\n-        return new SharedScope(null, CleanerFactory.cleaner(), false);\n+        return new NonCloseableSharedScope(null, CleanerFactory.cleaner());\n@@ -106,1 +104,1 @@\n-        return new ConfinedScope(thread, ref, cleaner, true);\n+        return new ConfinedScope(thread, ref, cleaner);\n@@ -116,1 +114,1 @@\n-        return new ConfinedScope(Thread.currentThread(), ref, cleaner, true);\n+        return new ConfinedScope(Thread.currentThread(), ref, cleaner);\n@@ -125,1 +123,1 @@\n-        return new SharedScope(ref, cleaner, true);\n+        return new SharedScope(ref, cleaner);\n@@ -133,4 +131,1 @@\n-    public final void close() {\n-        if (!closeable) {\n-            throw new UnsupportedOperationException(\"Scope cannot be closed\");\n-        }\n+    public void close() {\n@@ -194,1 +189,36 @@\n-    public static MemoryScope GLOBAL = new SharedScope( null, null, false) {\n+    \/**\n+     * A non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n+     * In addition, non-closeable scopes feature a much simpler scheme for generating resource scope handles, where\n+     * the same per-scope handle is shared across multiple calls to {@link #acquire()}. In fact, for non-closeable\n+     * scopes, it is sufficient for resource scope handles to keep a strong reference to their scopes, to prevent closure.\n+     *\/\n+    static class NonCloseableSharedScope extends SharedScope {\n+\n+        @Stable\n+        private Handle handle;\n+\n+        public NonCloseableSharedScope(Object ref, Cleaner cleaner) {\n+            super(ref, cleaner);\n+        }\n+\n+        @Override\n+        public Handle acquire() {\n+            if (handle != null) {\n+                \/\/ capture 'this'\n+                handle = () -> Reference.reachabilityFence(NonCloseableSharedScope.this);\n+            }\n+            return handle;\n+        }\n+\n+        @Override\n+        public void close() {\n+            throw new UnsupportedOperationException(\"Scope cannot be closed\");\n+        }\n+    }\n+\n+    \/**\n+     * The global, always alive, non-closeable, shared scope. This is like a {@link NonCloseableSharedScope non-closeable scope},\n+     * except that the operation which adds new resources to the global scope does nothing: as the scope can never\n+     * become not-alive, there is nothing to track.\n+     *\/\n+    public static MemoryScope GLOBAL = new NonCloseableSharedScope( null, null) {\n@@ -201,2 +231,0 @@\n-    public final Handle DUMMY_LOCK = () -> { };\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":42,"deletions":14,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.ref.Reference;\n@@ -65,2 +66,2 @@\n-    SharedScope(Object ref, Cleaner cleaner, boolean closeable) {\n-        super(ref, cleaner, closeable, new SharedResourceList());\n+    SharedScope(Object ref, Cleaner cleaner) {\n+        super(ref, cleaner, new SharedResourceList());\n@@ -83,1 +84,0 @@\n-        if (!closeable) return DUMMY_LOCK;\n@@ -187,0 +187,1 @@\n+                Reference.reachabilityFence(SharedScope.this);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}