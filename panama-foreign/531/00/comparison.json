{"files":[{"patch":"@@ -0,0 +1,59 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include LibCommon.gmk\n+\n+ifeq ($(call isTargetOs, linux), true)\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCSTDLIB, \\\n+    NAME := syslookup, \\\n+    OPTIMIZATION := HIGH, \\\n+    DISABLED_WARNINGS_gcc := sign-compare pointer-arith, \\\n+    DISABLED_WARNINGS_clang := sign-compare pointer-arith format-nonliteral, \\\n+    CFLAGS := $(CFLAGS_JDKLIB), \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+    LDFLAGS := -Wl$(COMMA)--no-as-needed -lc -lm $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS := $(LIBCXX), \\\n+))\n+\n+else ifeq ($(call isTargetOs, windows), false)\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCSTDLIB, \\\n+    NAME := syslookup, \\\n+    OPTIMIZATION := HIGH, \\\n+    DISABLED_WARNINGS_gcc := sign-compare pointer-arith, \\\n+    DISABLED_WARNINGS_clang := sign-compare pointer-arith format-nonliteral, \\\n+    CFLAGS := $(CFLAGS_JDKLIB), \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS := $(LIBCXX), \\\n+))\n+\n+\n+endif\n+\n+TARGETS += $(BUILD_LIBCSTDLIB)\n+\n+################################################################################\n","filename":"make\/modules\/jdk.incubator.foreign\/Lib.gmk","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdlib.h>\n-\n-#include \"jni.h\"\n-\n-JNIEXPORT void JNICALL\n-Java_jdk_internal_foreign_abi_VMFunctions_initVMFunctions(JNIEnv *env,\n-                                        jclass cls,\n-                                        jlong address)\n-{\n-   size_t* addresses = (size_t*)(void*)address;\n-   \/\/ The order in which the function pointers are stored has to match the order of constants\n-   \/\/ in the VMFunctions.FunctionName enum.\n-   addresses[0] = (size_t)&malloc;\n-   addresses[1] = (size_t)&free;\n-}\n","filename":"src\/java.base\/share\/native\/libjava\/VMFunctions.c","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.SystemLookup;\n@@ -132,1 +133,0 @@\n-\n@@ -134,3 +134,2 @@\n-     * Finds the address of a symbol with given name in one of the native libraries associated with the caller's\n-     * classloader (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}).\n-     *\n+     * Obtains a system lookup which is suitable to find symbols in the standard C libraries. The set of symbols\n+     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n@@ -142,4 +141,1 @@\n-     *\n-     * @param name the name of the symbol to be searched.\n-     * @return the address of a symbol with given name in one of the native libraries associated with the caller's\n-     *         classloader (if any).\n+     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n@@ -148,7 +144,3 @@\n-    public static Optional<MemoryAddress> findNative(String name) {\n-         Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-         ClassLoader loader = Reflection.getCallerClass().getClassLoader();\n-         Objects.requireNonNull(name);\n-         JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n-         MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n-         return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+    static SymbolLookup systemLookup() {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return SystemLookup.getInstance();\n@@ -170,1 +162,1 @@\n-     * @see CLinker#findNative(String)\n+     * @see SymbolLookup\n@@ -192,1 +184,1 @@\n-     * @see CLinker#findNative(String)\n+     * @see SymbolLookup\n@@ -222,1 +214,1 @@\n-     * @see CLinker#findNative(String)\n+     * @see SymbolLookup\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * A symbol lookup. Exposes a lookup operation for searching symbols, see {@link SymbolLookup#lookup(String)}.\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\/\n+@FunctionalInterface\n+public interface SymbolLookup {\n+\n+    \/**\n+     * Looks up a symbol with given name in this lookup.\n+     *\n+     * @param name the symbol name.\n+     * @return the memory address associated with the library symbol (if any).\n+     *\/\n+    Optional<MemoryAddress> lookup(String name);\n+\n+    \/**\n+     * Obtains a symbol lookup suitable to find symbols in native libraries associated with the caller's classloader\n+     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}).\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @return a symbol lookup suitable to find symbols in libraries loaded by the caller's classloader.\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup loaderLookup() {\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller);\n+        ClassLoader loader = Objects.requireNonNull(caller.getClassLoader());\n+        return loaderLookup0(loader);\n+    }\n+\n+    \/**\n+     * Obtains a symbol lookup suitable to find symbols in native libraries associated with the given classloader\n+     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}).\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param loader the classloader whose symbol lookup is to be retrieved.\n+     * @return a symbol lookup suitable to find symbols in libraries loaded by given classloader.\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup loaderLookup(ClassLoader loader) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(loader);\n+        return loaderLookup0(loader);\n+    }\n+\n+    private static SymbolLookup loaderLookup0(ClassLoader loader) {\n+        return name -> {\n+            Objects.requireNonNull(name);\n+            JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n+            MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+        };\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -99,2 +99,3 @@\n- * The key abstractions introduced to support foreign function access is {@link jdk.incubator.foreign.CLinker}.\n- * CLinker provides linking capabilities which allow to model foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup} and {@link jdk.incubator.foreign.CLinker}.\n+ * The former is used to lookup symbols inside native libraries; the latter\n+ * provides linking capabilities which allow to model foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -109,1 +110,1 @@\n-        CLinker.findNative(\"strlen\").get(),\n+        CLinker.systemLookup().lookup(\"strlen\").get(),\n@@ -120,3 +121,1 @@\n- * Here, we lookup the {@code strlen} symbol; this assumes that a library containing the {@code strlen} symbol has been loaded\n- * earlier, e.g. using {@link System#loadLibrary(String)}.\n- *\n+ * Here, we lookup the {@code strlen} symbol in the {@linkplain jdk.incubator.foreign.CLinker#systemLookup() system lookup}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.loader.NativeLibraries;\n+import jdk.internal.loader.NativeLibrary;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public class SystemLookup implements SymbolLookup {\n+\n+    private SystemLookup() { }\n+\n+    final static SystemLookup INSTANCE = new SystemLookup();\n+\n+    final NativeLibrary syslookup = switch (CABI.current()) {\n+        case SysV, AArch64 -> NativeLibraries.rawNativeLibraries(SystemLookup.class, false).loadLibrary(\"syslookup\");\n+        case Win64 -> NativeLibraries.rawNativeLibraries(SystemLookup.class, false)\n+                .loadLibrary(Path.of(System.getenv(\"SystemRoot\"), \"System32\", \"msvcrt.dll\").toString());\n+    };\n+\n+    @Override\n+    public Optional<MemoryAddress> lookup(String name) {\n+        Objects.requireNonNull(name);\n+        long addr = syslookup.find(name);\n+        return addr == 0 ?\n+                Optional.empty() : Optional.of(MemoryAddress.ofLong(addr));\n+    }\n+\n+    public static SystemLookup getInstance() {\n+        return INSTANCE;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -415,0 +415,14 @@\n+    \/\/ lazy init MH_ALLOC and MH_FREE handles\n+    private static class AllocHolder {\n+\n+        private static final CLinker linker = getSystemLinker();\n+\n+        static final MethodHandle MH_MALLOC = linker.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n+                        MethodType.methodType(MemoryAddress.class, long.class),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+\n+        static final MethodHandle MH_FREE = linker.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n+                        MethodType.methodType(void.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER));\n+    }\n+\n@@ -425,1 +439,1 @@\n-            return (MemoryAddress) VMFunctions.MH_MALLOC.invokeExact(size);\n+            return (MemoryAddress) AllocHolder.MH_MALLOC.invokeExact(size);\n@@ -433,1 +447,1 @@\n-            VMFunctions.MH_FREE.invokeExact(addr);\n+            AllocHolder.MH_FREE.invokeExact(addr);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign.abi;\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-\n-\/**\n- * This class is used to setup downcall method handles which refer to commonly used functions within the JVM.\n- * A memory segment is allocated, with enough room to contain as many pointers as the number of constants\n- * defined in {@link FunctionName}. This segment is then filled by the JVM with function pointers which target\n- * the desired functions.\n- *\/\n-class VMFunctions {\n-\n-    \/**\n-     * The order of these constants has to match that in which the VM will fill the {@code vmFunctions} pointer array.\n-     *\/\n-    enum FunctionName {\n-        MALLOC,\n-        FREE;\n-\n-        MemoryAddress get() {\n-            return MemoryAccess.getAddressAtIndex(vmFunctions, ordinal());\n-        }\n-    }\n-\n-    private static final CLinker linker = SharedUtils.getSystemLinker();\n-    private static final MemorySegment vmFunctions;\n-\n-    static {\n-        vmFunctions = MemorySegment.allocateNative(\n-                MemoryLayouts.ADDRESS.byteSize() * FunctionName.values().length,\n-                ResourceScope.newImplicitScope());\n-        initVMFunctions(vmFunctions.address().toRawLongValue());\n-    }\n-\n-    static final MethodHandle MH_MALLOC = linker.downcallHandle(FunctionName.MALLOC.get(),\n-            MethodType.methodType(MemoryAddress.class, long.class),\n-            FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n-\n-    static final MethodHandle MH_FREE = linker.downcallHandle(FunctionName.FREE.get(),\n-            MethodType.methodType(void.class, MemoryAddress.class),\n-            FunctionDescriptor.ofVoid(C_POINTER));\n-\n-    static native void initVMFunctions(long address);\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/VMFunctions.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <assert.h>\n+#include <complex.h>\n+#include <ctype.h>\n+#include <errno.h>\n+#include <fenv.h>\n+#include <float.h>\n+#include <inttypes.h>\n+#include <iso646.h>\n+#include <limits.h>\n+#include <locale.h>\n+#include <math.h>\n+#include <setjmp.h>\n+#include <signal.h>\n+#include <stdalign.h>\n+#include <stdarg.h>\n+#include <stdatomic.h>\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdnoreturn.h>\n+#include <string.h>\n+#include <tgmath.h>\n+\/\/ #include <threads.h>\n+#include <time.h>\n+\/\/ #include <uchar.h>\n+#include <wchar.h>\n+#include <wctype.h>\n+\n","filename":"src\/jdk.incubator.foreign\/share\/native\/libsyslookup\/syslookup.c","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -52,0 +53,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n@@ -60,1 +63,1 @@\n-                CLinker.findNative(\"struct_func\").get(),\n+                lookup.lookup(\"struct_func\").get(),\n@@ -75,1 +78,1 @@\n-                CLinker.findNative(\"addr_func\").get(),\n+                lookup.lookup(\"addr_func\").get(),\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,3 +156,0 @@\n-        static {\n-            System.loadLibrary(\"StdLibTest\");\n-        }\n@@ -160,1 +157,1 @@\n-        final static MethodHandle strcat = abi.downcallHandle(CLinker.findNative(\"libc_strcat\").get(),\n+        final static MethodHandle strcat = abi.downcallHandle(CLinker.systemLookup().lookup(\"strcat\").get(),\n@@ -164,1 +161,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(CLinker.findNative(\"libc_strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(CLinker.systemLookup().lookup(\"strcmp\").get(),\n@@ -168,1 +165,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(CLinker.findNative(\"libc_puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(CLinker.systemLookup().lookup(\"puts\").get(),\n@@ -172,1 +169,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(CLinker.findNative(\"libc_strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n@@ -176,1 +173,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(CLinker.findNative(\"libc_gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(CLinker.systemLookup().lookup(\"gmtime\").get(),\n@@ -180,1 +177,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(CLinker.findNative(\"libc_qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(CLinker.systemLookup().lookup(\"qsort\").get(),\n@@ -188,1 +185,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(CLinker.findNative(\"libc_rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(CLinker.systemLookup().lookup(\"rand\").get(),\n@@ -192,1 +189,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(CLinker.findNative(\"libc_vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(CLinker.systemLookup().lookup(\"vprintf\").get(),\n@@ -196,1 +193,1 @@\n-        final static MemoryAddress printfAddr = CLinker.findNative(\"libc_printf\").get();\n+        final static MemoryAddress printfAddr = CLinker.systemLookup().lookup(\"printf\").get();\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -59,0 +60,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n@@ -62,1 +65,1 @@\n-        MemoryAddress addr = CLinker.findNative(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n@@ -89,1 +92,1 @@\n-        MemoryAddress addr = CLinker.findNative(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -59,0 +60,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n@@ -88,1 +91,1 @@\n-            MemoryAddress ma = CLinker.findNative(name).get();\n+            MemoryAddress ma = lookup.lookup(name).get();\n@@ -98,1 +101,1 @@\n-            MemoryAddress ma = CLinker.findNative(\"empty\").get();\n+            MemoryAddress ma = lookup.lookup(\"empty\").get();\n@@ -113,1 +116,1 @@\n-            MemoryAddress ma = CLinker.findNative(\"identity_va\").get();\n+            MemoryAddress ma = lookup.lookup(\"identity_va\").get();\n@@ -128,1 +131,1 @@\n-                MemoryAddress ma = CLinker.findNative(\"invoke_high_arity\" + i).get();\n+                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).get();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLibraryLookup\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.*;\n-\n-\/\/ FYI this test is run on 64-bit platforms only for now,\n-\/\/ since the windows 32-bit linker fails and there\n-\/\/ is some fallback behaviour to use the 64-bit linker,\n-\/\/ where cygwin gets in the way and we accidentally pick up its\n-\/\/ link.exe\n-public class TestLibraryLookup {\n-    static {\n-        System.loadLibrary(\"LookupTest\");\n-    }\n-\n-    @Test\n-    public void testSimpleLookup() {\n-        assertFalse(CLinker.findNative(\"f\").isEmpty());\n-    }\n-\n-    @Test\n-    public void testInvalidSymbolLookup() {\n-        assertTrue(CLinker.findNative(\"nonExistent\").isEmpty());\n-    }\n-\n-    @Test\n-    public void testVariableSymbolLookup() throws Throwable {\n-        MemorySegment segment = CLinker.findNative(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestLibraryLookup.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -87,0 +87,1 @@\n+            SymbolLookup.class,\n@@ -162,0 +163,2 @@\n+        addDefaultMapping(ClassLoader.class, TestNulls.class.getClassLoader());\n+        addDefaultMapping(SymbolLookup.class, CLinker.systemLookup());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestSymbolLookup\n+ *\/\n+\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+\/\/ FYI this test is run on 64-bit platforms only for now,\n+\/\/ since the windows 32-bit linker fails and there\n+\/\/ is some fallback behaviour to use the 64-bit linker,\n+\/\/ where cygwin gets in the way and we accidentally pick up its\n+\/\/ link.exe\n+public class TestSymbolLookup {\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    @Test\n+    public void testSimpleLookup() {\n+        assertFalse(lookup.lookup(\"f\").isEmpty());\n+    }\n+\n+    @Test\n+    public void testInvalidSymbolLookup() {\n+        assertTrue(lookup.lookup(\"nonExistent\").isEmpty());\n+    }\n+\n+    @Test\n+    public void testVariableSymbolLookup() {\n+        MemorySegment segment = lookup.lookup(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        assertEquals(MemoryAccess.getInt(segment), 42);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -43,1 +44,0 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -68,0 +68,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n@@ -92,1 +94,1 @@\n-        MemoryAddress addr = CLinker.findNative(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n@@ -110,1 +112,1 @@\n-        MemoryAddress addr = CLinker.findNative(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -69,0 +70,1 @@\n+            SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -70,1 +72,1 @@\n-                CLinker.findNative(\"do_upcall\").get(),\n+                lookup.lookup(\"do_upcall\").get(),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -72,0 +73,1 @@\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -73,1 +75,1 @@\n-            CLinker.findNative(\"do_upcall\").get(),\n+            lookup.lookup(\"do_upcall\").get(),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -66,1 +67,4 @@\n-    static final MemoryAddress varargsAddr = CLinker.findNative(\"varargs\").get();\n+\n+    static final MemoryAddress varargsAddr =\n+            SymbolLookup.loaderLookup()\n+                    .lookup(\"varargs\").get();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef _WIN64\n-#define EXPORT __declspec(dllexport)\n-#else\n-#define EXPORT\n-#endif\n-\n-#include <stdarg.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <time.h>\n-\n-EXPORT char *libc_strcat(char *str1, const char *str2) {\n-    return strcat(str1, str2);\n-}\n-\n-EXPORT int libc_strcmp(const char *str1, const char *str2) {\n-    return strcmp(str1, str2);\n-}\n-\n-EXPORT size_t libc_strlen(const char *str) {\n-    return strlen(str);\n-}\n-\n-EXPORT int libc_puts(const char *str) {\n-    return puts(str);\n-}\n-\n-EXPORT struct tm *libc_gmtime(const time_t* timer) {\n-    return gmtime(timer);\n-}\n-\n-EXPORT void libc_qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) {\n-    qsort(base, nitems, size, compar);\n-}\n-\n-EXPORT int libc_rand(void) {\n-    return rand();\n-}\n-\n-EXPORT int libc_vprintf(const char *format, va_list arg) {\n-    return vprintf(format, arg);\n-}\n-\n-EXPORT int libc_printf(const char *format, ...) {\n-   va_list arg;\n-   int done;\n-\n-   va_start(arg, format);\n-   done = vprintf(format, arg);\n-   va_end(arg);\n-\n-   return done;\n-}\n","filename":"test\/jdk\/java\/foreign\/libStdLibTest.c","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -53,1 +54,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n@@ -76,0 +76,1 @@\n+            SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -77,1 +78,1 @@\n-                    CLinker.findNative(\"foo\").get(),\n+                    lookup.lookup(\"foo\").get(),\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n@@ -100,1 +102,1 @@\n-        return abi.downcallHandle(CLinker.findNative(symbol).get(), mt, fd);\n+        return abi.downcallHandle(lookup.lookup(symbol).get(), mt, fd);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -60,3 +61,4 @@\n-        funcA = CLinker.findNative(\"funcA\").get();\n-        funcB = CLinker.findNative(\"funcB\").get();\n-        funcC = CLinker.findNative(\"funcC\").get();\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        funcA = lookup.lookup(\"funcA\").get();\n+        funcB = lookup.lookup(\"funcB\").get();\n+        funcC = lookup.lookup(\"funcC\").get();\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -94,0 +95,1 @@\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -95,1 +97,1 @@\n-            func_addr = CLinker.findNative(\"func\").orElseThrow();\n+            func_addr = lookup.lookup(\"func\").orElseThrow();\n@@ -104,1 +106,1 @@\n-            identity_addr = CLinker.findNative(\"identity\").orElseThrow();\n+            identity_addr = lookup.lookup(\"identity\").orElseThrow();\n@@ -112,1 +114,1 @@\n-        identity_struct_addr = CLinker.findNative(\"identity_struct\").orElseThrow();\n+        identity_struct_addr = lookup.lookup(\"identity_struct\").orElseThrow();\n@@ -118,1 +120,1 @@\n-        identity_memory_address_addr = CLinker.findNative(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_addr = lookup.lookup(\"identity_memory_address\").orElseThrow();\n@@ -124,1 +126,1 @@\n-        args1_addr = CLinker.findNative(\"args1\").orElseThrow();\n+        args1_addr = lookup.lookup(\"args1\").orElseThrow();\n@@ -130,1 +132,1 @@\n-        args2_addr = CLinker.findNative(\"args2\").orElseThrow();\n+        args2_addr = lookup.lookup(\"args2\").orElseThrow();\n@@ -136,1 +138,1 @@\n-        args3_addr = CLinker.findNative(\"args3\").orElseThrow();\n+        args3_addr = lookup.lookup(\"args3\").orElseThrow();\n@@ -142,1 +144,1 @@\n-        args4_addr = CLinker.findNative(\"args4\").orElseThrow();\n+        args4_addr = lookup.lookup(\"args4\").orElseThrow();\n@@ -148,1 +150,1 @@\n-        args5_addr = CLinker.findNative(\"args5\").orElseThrow();\n+        args5_addr = lookup.lookup(\"args5\").orElseThrow();\n@@ -154,1 +156,1 @@\n-        args10_addr = CLinker.findNative(\"args10\").orElseThrow();\n+        args10_addr = lookup.lookup(\"args10\").orElseThrow();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        STRLEN = abi.downcallHandle(CLinker.findNative(\"strlen_raw\").get(),\n+        STRLEN = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n@@ -84,1 +84,1 @@\n-        STRLEN_TRIVIAL = abi.downcallHandle(CLinker.findNative(\"strlen_raw\").get(),\n+        STRLEN_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n@@ -87,1 +87,1 @@\n-        MALLOC_TRIVIAL = abi.downcallHandle(CLinker.findNative(\"malloc_raw\").get(),\n+        MALLOC_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n@@ -91,1 +91,1 @@\n-        FREE_TRIVIAL = abi.downcallHandle(CLinker.findNative(\"free_raw\").get(),\n+        FREE_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -128,1 +129,1 @@\n-            CLinker.findNative(name).orElseThrow(),\n+            SymbolLookup.loaderLookup().lookup(name).orElseThrow(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -64,1 +65,2 @@\n-        MH_ellipsis = linker.downcallHandle(CLinker.findNative(\"ellipsis\").get(),\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        MH_ellipsis = linker.downcallHandle(lookup.lookup(\"ellipsis\").get(),\n@@ -67,1 +69,1 @@\n-        MH_vaList = linker.downcallHandle(CLinker.findNative(\"vaList\").get(),\n+        MH_vaList = linker.downcallHandle(lookup.lookup(\"vaList\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,12 +42,0 @@\n-\n-EXPORT int strlen_raw(const char *str) {\n-    return (int)strlen(str);\n-}\n-\n-EXPORT void* malloc_raw(size_t size) {\n-    return malloc(size);\n-}\n-\n-EXPORT void free_raw(void* ptr) {\n-    free(ptr);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libStrLen.c","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -54,0 +55,1 @@\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -55,1 +57,1 @@\n-            CLinker.findNative(\"distance\").get(),\n+            lookup.lookup(\"distance\").get(),\n@@ -60,1 +62,1 @@\n-                CLinker.findNative(\"distance_ptrs\").get(),\n+                lookup.lookup(\"distance_ptrs\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}