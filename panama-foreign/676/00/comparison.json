{"files":[{"patch":"@@ -111,1 +111,6 @@\n-     * @returns true if variadic arguments should be spilled to the stack.\n+     * @return true if variadic arguments should be spilled to the stack.\n+      *\/\n+     protected abstract boolean varArgsOnStack();\n+\n+    \/**\n+     * {@return true if this ABI requires sub-slot (smaller than STACK_SLOT_SIZE) packing of arguments on the stack.}\n@@ -113,1 +118,1 @@\n-    protected abstract boolean varArgsOnStack();\n+    protected abstract boolean requiresSubSlotStackPacking();\n@@ -174,1 +179,1 @@\n-    static class StorageCalculator {\n+    class StorageCalculator {\n@@ -186,2 +191,13 @@\n-            alignment = Math.max(alignment, STACK_SLOT_SIZE);\n-            stackOffset = Utils.alignUp(stackOffset, alignment);\n+            \/\/ Implementation limit: each arg must take up at least an 8 byte stack slot (on the Java side)\n+            \/\/ There is currently no way to address stack offsets that are not multiples of 8 bytes\n+            \/\/ The VM can only address multiple-of-4-bytes offsets, which is also not good enough for some ABIs\n+            \/\/ see JDK-8283462 and related issues\n+            long stackSlotAlignment = Math.max(alignment, STACK_SLOT_SIZE);\n+            long alignedStackOffset = Utils.alignUp(stackOffset, stackSlotAlignment);\n+            \/\/ macos-aarch64 ABI potentially requires addressing stack offsets that are not multiples of 8 bytes\n+            \/\/ Reject such call types here, to prevent undefined behavior down the line\n+            \/\/ Reject if the above stack-slot-aligned offset does not match the offset the ABI really wants\n+            if (requiresSubSlotStackPacking() && alignedStackOffset != Utils.alignUp(stackOffset, alignment))\n+                throw new UnsupportedOperationException(\"Call type not supported on this platform\");\n+\n+            stackOffset = alignedStackOffset;\n@@ -237,1 +253,1 @@\n-    static abstract class BindingCalculator {\n+    abstract class BindingCalculator {\n@@ -289,1 +305,1 @@\n-    static class UnboxBindingCalculator extends BindingCalculator {\n+    class UnboxBindingCalculator extends BindingCalculator {\n@@ -390,1 +406,1 @@\n-    static class BoxBindingCalculator extends BindingCalculator{\n+    class BoxBindingCalculator extends BindingCalculator {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,0 +41,5 @@\n+    @Override\n+    protected boolean requiresSubSlotStackPacking() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,5 @@\n+    @Override\n+    protected boolean requiresSubSlotStackPacking() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -535,0 +535,1 @@\n+java\/foreign\/TestVarArgs.java 8275584 macosx-aarch64\n@@ -536,0 +537,3 @@\n+java\/foreign\/TestIntrinsics.java 8275584 macosx-aarch64\n+java\/foreign\/TestDowncallStack.java 8275584 macosx-aarch64\n+java\/foreign\/StdLibTest.java 8275584 macosx-aarch64\n@@ -746,1 +750,1 @@\n-\t\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,151 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @build NativeTestHelper CallGeneratorHelper TestDowncall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   TestDowncall\n- *\n- * @run testng\/othervm -Xint -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=100000\n- *   TestDowncall\n- *\/\n-\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.CLinker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-\n-import java.lang.foreign.MemorySession;\n-import java.lang.invoke.MethodHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestDowncall extends CallGeneratorHelper {\n-\n-    static CLinker abi = CLinker.systemCLinker();\n-    static {\n-        System.loadLibrary(\"TestDowncall\");\n-        System.loadLibrary(\"TestDowncallStack\");\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testDowncall(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<Consumer<Object>> checks = new ArrayList<>();\n-        Addressable addr = findNativeOrThrow(fName);\n-        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n-        Object[] args = makeArgs(paramTypes, fields, checks);\n-        try (MemorySession session = MemorySession.openShared()) {\n-            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n-            SegmentAllocator allocator = needsScope ?\n-                    SegmentAllocator.newNativeArena(session) :\n-                    THROWING_ALLOCATOR;\n-            Object res = doCall(addr, allocator, descriptor, args);\n-            if (ret == Ret.NON_VOID) {\n-                checks.forEach(c -> c.accept(res));\n-                if (needsScope) {\n-                    \/\/ check that return struct has indeed been allocated in the native scope\n-                    assertEquals(((MemorySegment)res).session(), session);\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testDowncallStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<Consumer<Object>> checks = new ArrayList<>();\n-        Addressable addr = findNativeOrThrow(\"s\" + fName);\n-        FunctionDescriptor descriptor = functionStack(ret, paramTypes, fields);\n-        Object[] args = makeArgsStack(paramTypes, fields, checks);\n-        try (MemorySession session = MemorySession.openShared()) {\n-            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n-            SegmentAllocator allocator = needsScope ?\n-                    SegmentAllocator.newNativeArena(session) :\n-                    THROWING_ALLOCATOR;\n-            Object res = doCall(addr, allocator, descriptor, args);\n-            if (ret == Ret.NON_VOID) {\n-                checks.forEach(c -> c.accept(res));\n-                if (needsScope) {\n-                    \/\/ check that return struct has indeed been allocated in the native scope\n-                    assertEquals(((MemorySegment)res).session(), session);\n-                }\n-            }\n-        }\n-    }\n-\n-    Object doCall(Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n-        MethodHandle mh = downcallHandle(abi, symbol, allocator, descriptor);\n-        Object res = mh.invokeWithArguments(args);\n-        return res;\n-    }\n-\n-    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        return function(ret, params, fields, List.of());\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n-        List<MemoryLayout> pLayouts = params.stream().map(p -> p.layout(fields)).toList();\n-        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), pLayouts.stream()).toArray(MemoryLayout[]::new);\n-        return ret == Ret.VOID ?\n-                FunctionDescriptor.ofVoid(paramLayouts) :\n-                FunctionDescriptor.of(paramLayouts[prefix.size()], paramLayouts);\n-    }\n-\n-    static Object[] makeArgsStack(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n-        return makeArgs(params, fields, checks, STACK_PREFIX_LAYOUTS);\n-    }\n-\n-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n-        return makeArgs(params, fields, checks, List.of());\n-    }\n-\n-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n-        Object[] args = new Object[prefix.size() + params.size()];\n-        int argNum = 0;\n-        for (MemoryLayout layout : prefix) {\n-            args[argNum++] = makeArg(layout, null, false);\n-        }\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n-        }\n-        return args;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":0,"deletions":151,"binary":false,"changes":151,"status":"deleted"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+public class TestDowncallBase extends CallGeneratorHelper {\n+\n+    static CLinker ABI = CLinker.systemCLinker();\n+\n+    Object doCall(Addressable symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = downcallHandle(ABI, symbol, allocator, descriptor);\n+        Object res = mh.invokeWithArguments(args);\n+        return res;\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n+        List<MemoryLayout> pLayouts = params.stream().map(p -> p.layout(fields)).toList();\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), pLayouts.stream()).toArray(MemoryLayout[]::new);\n+        return ret == Ret.VOID ?\n+                FunctionDescriptor.ofVoid(paramLayouts) :\n+                FunctionDescriptor.of(paramLayouts[prefix.size()], paramLayouts);\n+    }\n+\n+    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size()];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n+        for (int i = 0 ; i < params.size() ; i++) {\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+        }\n+        return args;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDowncallBase.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestDowncallScope\n+ *\n+ * @run testng\/othervm -Xint -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=100000\n+ *   TestDowncallScope\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDowncallScope extends TestDowncallBase {\n+\n+    static {\n+        System.loadLibrary(\"TestDowncall\");\n+    }\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncall(int count, String fName, CallGeneratorHelper.Ret ret,\n+                             List<CallGeneratorHelper.ParamType> paramTypes,\n+                             List<CallGeneratorHelper.StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        Addressable addr = findNativeOrThrow(fName);\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(session) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n+            if (ret == CallGeneratorHelper.Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment)res).session(), session);\n+                }\n+            }\n+        }\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n+        return makeArgs(params, fields, checks, List.of());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestDowncallStack\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemorySession;\n+import java.lang.foreign.SegmentAllocator;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestDowncallStack extends TestDowncallBase {\n+\n+    static {\n+        System.loadLibrary(\"TestDowncallStack\");\n+    }\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncallStack(int count, String fName, CallGeneratorHelper.Ret ret,\n+                                  List<CallGeneratorHelper.ParamType> paramTypes,\n+                                  List<CallGeneratorHelper.StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        Addressable addr = findNativeOrThrow(\"s\" + fName);\n+        FunctionDescriptor descriptor = functionStack(ret, paramTypes, fields);\n+        Object[] args = makeArgsStack(paramTypes, fields, checks);\n+        try (MemorySession session = MemorySession.openShared()) {\n+            boolean needsScope = descriptor.returnLayout().map(GroupLayout.class::isInstance).orElse(false);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(session) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n+            if (ret == CallGeneratorHelper.Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment)res).session(), session);\n+                }\n+            }\n+        }\n+    }\n+\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n+    }\n+\n+    static Object[] makeArgsStack(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n+        return makeArgs(params, fields, checks, STACK_PREFIX_LAYOUTS);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -421,1 +421,3 @@\n-    @Test\n+    \/\/ The placement of the float is incorrect.\n+    @Test(expectedExceptions = UnsupportedOperationException.class,\n+            expectedExceptionsMessageRegExp = \".*Call type not supported on this platform.*\")\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}