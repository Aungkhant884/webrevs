{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -42,0 +43,7 @@\n+\n+    private static void checkSymbol(Addressable symbol) {\n+        MemoryAddress symbolAddr = symbol.address();\n+        if (symbolAddr.equals(MemoryAddress.NULL))\n+            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbolAddr);\n+    }\n+\n@@ -46,0 +54,1 @@\n+        checkSymbol(symbol);\n@@ -53,0 +62,1 @@\n+        checkSymbol(symbol);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -93,5 +93,1 @@\n-            MethodHandle MH_Addressable_address = lookup.findVirtual(Addressable.class, \"address\",\n-                    methodType(MemoryAddress.class));\n-            MethodHandle MH_MemoryAddress_toRawLongValue = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n-                    methodType(long.class));\n-            MH_ADDR_TO_LONG = filterArguments(MH_MemoryAddress_toRawLongValue, 0, MH_Addressable_address);\n+            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, Addressable.class));\n@@ -179,0 +175,8 @@\n+    private static long unboxTargetAddress(Addressable addr) {\n+        MemoryAddress ma = addr.address();\n+        if (ma.equals(MemoryAddress.NULL)) {\n+            throw new IllegalArgumentException(\"Target address is NULL: \" + ma);\n+        }\n+        return ma.toRawLongValue();\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\n+ * @run testng\/othervm\n+ *     --enable-native-access=ALL-UNNAMED\n+ *     TestNULLTarget\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+public class TestNULLTarget {\n+\n+    static final CLinker LINKER = CLinker.getInstance();\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNULLLinking() {\n+        LINKER.downcallHandle(\n+                MemoryAddress.NULL,\n+                MethodType.methodType(void.class),\n+                FunctionDescriptor.ofVoid());\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNULLVirtual() throws Throwable {\n+        MethodHandle mh = LINKER.downcallHandle(\n+                MethodType.methodType(void.class),\n+                FunctionDescriptor.ofVoid());\n+        mh.invokeExact((Addressable) MemoryAddress.NULL);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestNULLTarget.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -148,2 +148,2 @@\n-        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n-        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemoryAddress.class, MemoryAddress.ofLong(1));\n+        addDefaultMapping(Addressable.class, MemoryAddress.ofLong(1));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}