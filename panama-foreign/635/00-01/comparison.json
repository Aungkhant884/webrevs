{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Locale;\n@@ -107,4 +108,5 @@\n-        return decorateLayoutString(String.format(\"%s%d(%s)\",\n-                order == ByteOrder.BIG_ENDIAN ? \"B\" : \"b\",\n-                bitSize(),\n-                carrier == MemoryAddress.class ? \"MA\" : carrier.descriptorString()));\n+        char descriptor = carrier == MemoryAddress.class ? 'A' : carrier.descriptorString().charAt(0);\n+        if (order == ByteOrder.LITTLE_ENDIAN) {\n+            descriptor = Character.toLowerCase(descriptor);\n+        }\n+        return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -204,23 +204,0 @@\n-    private static final MethodHandle MH_UNBOX_ADDRESS;\n-    private static final MethodHandle MH_BOX_ADDRESS;\n-    private static final MethodHandle MH_COPY_BUFFER;\n-    private static final MethodHandle MH_ALLOCATE_BUFFER;\n-    private static final MethodHandle MH_TO_SEGMENT;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n-                    methodType(long.class));\n-            MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n-                    methodType(MemoryAddress.class, long.class));\n-            MH_COPY_BUFFER = lookup.findStatic(Copy.class, \"copyBuffer\",\n-                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, Context.class));\n-            MH_ALLOCATE_BUFFER = lookup.findStatic(Allocate.class, \"allocateBuffer\",\n-                    methodType(MemorySegment.class, long.class, long.class, Context.class));\n-            MH_TO_SEGMENT = lookup.findStatic(ToSegment.class, \"toSegment\",\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class, Context.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n@@ -339,2 +316,0 @@\n-    public abstract MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos);\n-\n@@ -546,5 +521,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return specializedHandle; \/\/ no-op\n-        }\n-\n@@ -581,5 +551,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return specializedHandle; \/\/ no-op\n-        }\n-\n@@ -665,7 +630,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);\n-            setter = setter.asType(methodType(void.class, MemorySegment.class, type()));\n-            return collectArguments(specializedHandle, insertPos + 1, setter);\n-        }\n-\n@@ -708,8 +666,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle filter = varHandle()\n-                    .toMethodHandle(VarHandle.AccessMode.GET)\n-                    .asType(methodType(type(), MemorySegment.class));\n-            return filterArguments(specializedHandle, insertPos, filter);\n-        }\n-\n@@ -778,7 +728,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, filter);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n-        }\n-\n@@ -847,7 +790,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle allocateBuffer = insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, allocateBuffer);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos);\n-        }\n-\n@@ -910,6 +846,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos,\n-                    MethodHandles.filterReturnValue(toAddress, MH_UNBOX_ADDRESS));\n-        }\n-\n@@ -946,5 +876,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_BOX_ADDRESS);\n-        }\n-\n@@ -994,7 +919,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle toSegmentHandle = insertArguments(MH_TO_SEGMENT, 1, size);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, toSegmentHandle);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n-        }\n-\n@@ -1045,23 +963,0 @@\n-        \/*\n-         * Fixes up Y-shaped data graphs (produced by DEREFERENCE):\n-         *\n-         * 1. DUP()\n-         * 2. BUFFER_LOAD(0, int.class)\n-         * 3. VM_STORE  (ignored)\n-         * 4. BUFFER_LOAD(4, int.class)\n-         * 5. VM_STORE  (ignored)\n-         *\n-         * (specialized in reverse!)\n-         *\n-         * 5. (int, int) -> void                       insertPos = 1\n-         * 4. (MemorySegment, int) -> void             insertPos = 1\n-         * 3. (MemorySegment, int) -> void             insertPos = 0\n-         * 2. (MemorySegment, MemorySegment) -> void   insertPos = 0\n-         * 1. (MemorySegment) -> void                  insertPos = 0\n-         *\n-         *\/\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return SharedUtils.mergeArguments(specializedHandle, insertPos, insertPos + 1);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,858 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.misc.VM;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;\n+import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+public class BindingSpecializer {\n+    private static final String DUMP_CLASSES_DIR\n+        = GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.DUMP_CLASSES_DIR\");\n+    private static final boolean PERFORM_VERIFICATION\n+        = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.PERFORM_VERIFICATION\");\n+\n+    \/\/ Bunch of helper constants\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+\n+    private static final String OBJECT_DESC = Object.class.descriptorString();\n+    private static final String OBJECT_INTRN = Type.getInternalName(Object.class);\n+\n+    private static final String BINDING_CONTEXT_DESC = Binding.Context.class.descriptorString();\n+    private static final String BINDING_CONTEXT_INTRN = Type.getInternalName(Binding.Context.class);\n+    private static final String OF_BOUNDED_ALLOCATOR_DESC = methodType(Binding.Context.class, long.class).descriptorString();\n+    private static final String OF_SCOPE_DESC = methodType(Binding.Context.class).descriptorString();\n+    private static final String ALLOCATOR_DESC = methodType(SegmentAllocator.class).descriptorString();\n+    private static final String SCOPE_DESC = methodType(ResourceScope.class).descriptorString();\n+    private static final String CLOSE_DESC = methodType(void.class).descriptorString();\n+\n+    private static final String ADDRESSABLE_INTRN = Type.getInternalName(Addressable.class);\n+    private static final String ADDRESS_DESC = methodType(MemoryAddress.class).descriptorString();\n+\n+    private static final String MEMORY_SEGMENT_INTRN = Type.getInternalName(MemorySegment.class);\n+    private static final String COPY_DESC = methodType(void.class, MemorySegment.class, long.class, MemorySegment.class, long.class, long.class).descriptorString();\n+\n+    private static final String MEMORY_ADDRESS_INTRN = Type.getInternalName(MemoryAddress.class);\n+    private static final String TO_RAW_LONG_VALUE_DESC = methodType(long.class).descriptorString();\n+    private static final String OF_LONG_DESC = methodType(MemoryAddress.class, long.class).descriptorString();\n+\n+    private static final String MEMORY_ADDRESS_IMPL_INTRN = Type.getInternalName(MemoryAddressImpl.class);\n+    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, ResourceScopeImpl.class).descriptorString();\n+\n+    private static final String VALUE_LAYOUT_INTRN = Type.getInternalName(ValueLayout.class);\n+\n+    private static final String SEGMENT_ALLOCATOR_INTRN = Type.getInternalName(SegmentAllocator.class);\n+    private static final String ALLOCATE_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n+\n+    private static final String RESOURCE_SCOPE_IMPL_INTRN = Type.getInternalName(ResourceScopeImpl.class);\n+\n+    private static final String SHARED_UTILS_INTRN = Type.getInternalName(SharedUtils.class);\n+    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class).descriptorString();\n+\n+    private static final String METHOD_HANDLES_INTRN = Type.getInternalName(MethodHandles.class);\n+    private static final String CLASS_DATA_DESC = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class).descriptorString();\n+\n+    private static final String METHOD_HANDLE_INTRN = Type.getInternalName(MethodHandle.class);\n+\n+    private static final Handle BSM_CLASS_DATA = new Handle(\n+            H_INVOKESTATIC,\n+            METHOD_HANDLES_INTRN,\n+            \"classData\",\n+            CLASS_DATA_DESC,\n+            false);\n+    private static final ConstantDynamic CLASS_DATA_CONDY = new ConstantDynamic(\n+            ConstantDescs.DEFAULT_NAME,\n+            OBJECT_DESC,\n+            BSM_CLASS_DATA);\n+\n+    private static final String CLASS_NAME_DOWNCALL = \"jdk\/internal\/foreign\/abi\/DowncallStub\";\n+    private static final String CLASS_NAME_UPCALL = \"jdk\/internal\/foreign\/abi\/UpcallStub\";\n+    private static final String METHOD_NAME = \"invoke\";\n+\n+    private static final String SUPER_NAME = OBJECT_INTRN;\n+\n+    \/\/ Instance fields start here\n+    private final MethodVisitor mv;\n+    private final MethodType callerMethodType;\n+    private final CallingSequence callingSequence;\n+    private final ABIDescriptor abi;\n+    private final MethodType leafType;\n+\n+    private int localIdx = 0;\n+    private int[] paramIndex2ParamSlot;\n+    private int[] leafArgSlots;\n+    private int RETURN_ALLOCATOR_IDX = -1;\n+    private int CONTEXT_IDX = -1;\n+    private int RETURN_BUFFER_IDX = -1;\n+    private int RET_VAL_IDX = -1;\n+    private Deque<Class<?>> typeStack;\n+    private List<Class<?>> leafArgTypes;\n+    private int paramIndex;\n+    private long retBufOffset; \/\/ for needsReturnBuffer\n+\n+    private BindingSpecializer(MethodVisitor mv, MethodType callerMethodType, CallingSequence callingSequence, ABIDescriptor abi, MethodType leafType) {\n+        this.mv = mv;\n+        this.callerMethodType = callerMethodType;\n+        this.callingSequence = callingSequence;\n+        this.abi = abi;\n+        this.leafType = leafType;\n+    }\n+\n+    static MethodHandle specialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+        String className = callingSequence.forDowncall() ? CLASS_NAME_DOWNCALL : CLASS_NAME_UPCALL;\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n+        cw.visit(CLASSFILE_VERSION, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, SUPER_NAME, null);\n+\n+        MethodType callerMethodType = callingSequence.callerMethodType();\n+        if (callingSequence.forDowncall()) {\n+            if (callingSequence.needsReturnBuffer()) {\n+                callerMethodType = callerMethodType.dropParameterTypes(0, 1); \/\/ Return buffer does not appear in the parameter list\n+            }\n+            callerMethodType = callerMethodType.insertParameterTypes(0, SegmentAllocator.class);\n+        }\n+        String descriptor = callerMethodType.descriptorString();\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, METHOD_NAME, descriptor, null, null);\n+\n+        new BindingSpecializer(mv, callerMethodType, callingSequence, abi, leafHandle.type()).specialize();\n+\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+\n+        cw.visitEnd();\n+\n+        byte[] bytes = cw.toByteArray();\n+        if (DUMP_CLASSES_DIR != null) {\n+            String fileName = className + escapeForFileName(callingSequence.functionDesc().toString()) + \".class\";\n+            Path dumpPath = Path.of(DUMP_CLASSES_DIR).resolve(fileName);\n+            try {\n+                Files.createDirectories(dumpPath.getParent());\n+                Files.write(dumpPath, bytes);\n+            } catch (IOException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        if (PERFORM_VERIFICATION) {\n+            boolean printResults = false; \/\/ only print in case of exception\n+            CheckClassAdapter.verify(new ClassReader(bytes), null, printResults, new PrintWriter(System.err));\n+        }\n+\n+        try {\n+            \/\/ We must initialize the class since the upcall stubs don't have a clinit barrier, and the slow\n+            \/\/ path in the c2i adapter we end up calling can not handle the particular code shape where the\n+            \/\/ caller is an optimized upcall stub.\n+            boolean initialize = callingSequence.forUpcall();\n+            MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, initialize);\n+            return lookup.findStatic(lookup.lookupClass(), METHOD_NAME, callerMethodType);\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new InternalError(\"Should not happen\", e);\n+        }\n+    }\n+\n+    private static String escapeForFileName(String str) {\n+        StringBuilder sb = new StringBuilder(str.length());\n+        for (int i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            sb.append(switch (c) {\n+                case ' ' -> '_';\n+                case '[', '<' -> '{';\n+                case ']', '>' -> '}';\n+                case '\/', '\\\\', ':', '*', '?', '\"', '|' -> '!'; \/\/ illegal in Windows file names.\n+                default -> c;\n+            });\n+        }\n+        return sb.toString();\n+    }\n+\n+    private void specialize() {\n+        \/\/ map of parameter indexes to local var table slots\n+        paramIndex2ParamSlot = new int[callerMethodType.parameterCount()];\n+        for (int i = 0; i < callerMethodType.parameterCount(); i++) {\n+            paramIndex2ParamSlot[i] = newLocal(callerMethodType.parameterType(i));\n+        }\n+\n+        \/\/ slots that store the output arguments (passed to the leaf handle)\n+        leafArgSlots = new int[leafType.parameterCount()];\n+        for (int i = 0; i < leafType.parameterCount(); i++) {\n+            leafArgSlots[i] = newLocal(leafType.parameterType(i));\n+        }\n+\n+        \/\/ allocator passed to us for allocating the return MS (downcalls only)\n+        if (callingSequence.forDowncall()) {\n+            RETURN_ALLOCATOR_IDX = 0; \/\/ first param\n+        }\n+\n+        \/\/ create a Binding.Context for this call\n+        if (callingSequence.allocationSize() != 0) {\n+            emitConst(callingSequence.allocationSize());\n+            emitInvokeStatic(BINDING_CONTEXT_INTRN, \"ofBoundedAllocator\", OF_BOUNDED_ALLOCATOR_DESC);\n+        } else if (callingSequence.forDowncall()) {\n+            emitGetStatic(BINDING_CONTEXT_INTRN, \"DUMMY\", BINDING_CONTEXT_DESC);\n+        } else {\n+            emitInvokeStatic(BINDING_CONTEXT_INTRN, \"ofScope\", OF_SCOPE_DESC);\n+        }\n+        CONTEXT_IDX = newLocal(BasicType.L);\n+        emitStore(BasicType.L, CONTEXT_IDX);\n+\n+        \/\/ in case the call needs a return buffer, allocate it here.\n+        \/\/ for upcalls the VM wrapper stub allocates the buffer.\n+        if (callingSequence.needsReturnBuffer() && callingSequence.forDowncall()) {\n+            emitLoadInternalAllocator();\n+            emitAllocateCall(callingSequence.returnBufferSize(), 1);\n+            RETURN_BUFFER_IDX = newLocal(BasicType.L);\n+            emitStore(BasicType.L, RETURN_BUFFER_IDX);\n+        }\n+\n+        Label tryStart = new Label();\n+        Label tryEnd = new Label();\n+        Label catchStart = new Label();\n+\n+        mv.visitLabel(tryStart);\n+\n+        \/\/ stack to keep track of types on the bytecode stack between bindings.\n+        \/\/ this is needed to e.g. emit the right DUP instruction,\n+        \/\/ but also used for type checking.\n+        typeStack = new ArrayDeque<>();\n+        \/\/ leaf arg types are the types of the args passed to the leaf handle.\n+        \/\/ these are collected from VM_STORE instructions for downcalls, and\n+        \/\/ recipe outputs for upcalls (see uses emitSetOutput for both)\n+        leafArgTypes = new ArrayList<>();\n+        paramIndex = callingSequence.forDowncall() ? 1 : 0; \/\/ +1 to skip SegmentAllocator\n+        for (int i = 0; i < callingSequence.argumentBindingsCount(); i++) {\n+            if (callingSequence.forDowncall()) {\n+                \/\/ for downcalls, recipes have an input value, which we set up here\n+                if (callingSequence.needsReturnBuffer() && i == 0) {\n+                    assert RETURN_BUFFER_IDX != -1;\n+                    emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                    typeStack.push(MemorySegment.class);\n+                } else {\n+                    emitGetInput();\n+                }\n+            }\n+\n+            \/\/ emit code according to binding recipe\n+            doBindings(callingSequence.argumentBindings(i));\n+\n+            if (callingSequence.forUpcall()) {\n+                \/\/ for upcalls, recipes have a result, which we handle here\n+                if (callingSequence.needsReturnBuffer() && i == 0) {\n+                    \/\/ return buffer ptr is wrapped in a MemorySegment above, but not passed to the leaf handle\n+                    assert typeStack.pop() == MemorySegment.class;\n+                    RETURN_BUFFER_IDX = newLocal(BasicType.L);\n+                    emitStore(BasicType.L, RETURN_BUFFER_IDX);\n+                } else {\n+                    \/\/ for upcalls the recipe result is an argument to the leaf handle\n+                    emitSetOutput(typeStack.pop());\n+                }\n+            }\n+            assert typeStack.isEmpty();\n+        }\n+\n+        assert leafArgTypes.equals(leafType.parameterList());\n+\n+        \/\/ load the leaf MethodHandle\n+        mv.visitLdcInsn(CLASS_DATA_CONDY);\n+        mv.visitTypeInsn(CHECKCAST, METHOD_HANDLE_INTRN);\n+        \/\/ load all the leaf args\n+        for (int i = 0; i < leafArgSlots.length; i++) {\n+            emitLoad(leafArgTypes.get(i), leafArgSlots[i]);\n+        }\n+        \/\/ call leaf MH\n+        emitInvokeVirtual(METHOD_HANDLE_INTRN, \"invokeExact\", leafType.descriptorString());\n+\n+        \/\/ for downcalls, store the result of the leaf handle call away, until\n+        \/\/ it is requested by a VM_LOAD in the return recipe.\n+        if (callingSequence.forDowncall() && leafType.returnType() != void.class) {\n+            emitSaveReturnValue(leafType.returnType());\n+        }\n+        \/\/ for upcalls we leave the return value on the stack to be picked up\n+        \/\/ as an input of the return recipe.\n+\n+        \/\/ return value processing\n+        if (callingSequence.hasReturnBindings()) {\n+            if (callingSequence.forUpcall()) {\n+                typeStack.push(leafType.returnType());\n+            }\n+\n+            retBufOffset = 0; \/\/ offset for reading from return buffer\n+            doBindings(callingSequence.returnBindings());\n+\n+            if (callingSequence.forUpcall() && !callingSequence.needsReturnBuffer()) {\n+                \/\/ was VM_STOREd somewhere in the bindings\n+                emitRestoreReturnValue(callerMethodType.returnType());\n+            }\n+            mv.visitLabel(tryEnd);\n+            \/\/ finally\n+            emitCloseContext();\n+\n+            if (callerMethodType.returnType() == void.class) {\n+                \/\/ The case for upcalls that return by return buffer\n+                assert typeStack.isEmpty();\n+                mv.visitInsn(RETURN);\n+            } else {\n+                assert typeStack.pop() == callerMethodType.returnType();\n+                assert typeStack.isEmpty();\n+                emitReturn(callerMethodType.returnType());\n+            }\n+        } else {\n+            assert callerMethodType.returnType() == void.class;\n+            assert typeStack.isEmpty();\n+            mv.visitLabel(tryEnd);\n+            \/\/ finally\n+            emitCloseContext();\n+            mv.visitInsn(RETURN);\n+        }\n+\n+        mv.visitLabel(catchStart);\n+        \/\/ finally\n+        emitCloseContext();\n+        if (callingSequence.forDowncall()) {\n+            mv.visitInsn(ATHROW);\n+        } else {\n+           emitInvokeStatic(SHARED_UTILS_INTRN, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n+           if (callerMethodType.returnType() != void.class) {\n+               emitConstZero(callerMethodType.returnType());\n+               emitReturn(callerMethodType.returnType());\n+           } else {\n+               mv.visitInsn(RETURN);\n+           }\n+        }\n+\n+        mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, null);\n+    }\n+\n+    private void doBindings(List<Binding> bindings) {\n+        for (Binding binding : bindings) {\n+            switch (binding.tag()) {\n+                case VM_STORE -> emitVMStore((Binding.VMStore) binding);\n+                case VM_LOAD -> emitVMLoad((Binding.VMLoad) binding);\n+                case BUFFER_STORE -> emitBufferStore((Binding.BufferStore) binding);\n+                case BUFFER_LOAD -> emitBufferLoad((Binding.BufferLoad) binding);\n+                case COPY_BUFFER -> emitCopyBuffer((Binding.Copy) binding);\n+                case ALLOC_BUFFER -> emitAllocBuffer((Binding.Allocate) binding);\n+                case BOX_ADDRESS -> emitBoxAddress();\n+                case UNBOX_ADDRESS -> emitUnboxAddress();\n+                case TO_SEGMENT -> emitToSegment((Binding.ToSegment) binding);\n+                case DUP -> emitDupBinding();\n+            }\n+        }\n+    }\n+\n+    private void emitSetOutput(Class<?> storeType) {\n+        emitStore(BasicType.of(storeType), leafArgSlots[leafArgTypes.size()]);\n+        leafArgTypes.add(storeType);\n+    }\n+\n+    private void emitGetInput() {\n+        Class<?> highLevelType = callerMethodType.parameterType(paramIndex);\n+        emitLoad(BasicType.of(highLevelType), paramIndex2ParamSlot[paramIndex]);\n+        typeStack.push(highLevelType);\n+        paramIndex++;\n+    }\n+\n+    private void emitSaveReturnValue(Class<?> storeType) {\n+        RET_VAL_IDX = newLocal(BasicType.of(storeType));\n+        emitStore(BasicType.of(storeType), RET_VAL_IDX);\n+    }\n+\n+    private void emitRestoreReturnValue(Class<?> loadType) {\n+        assert RET_VAL_IDX != -1;\n+        emitLoad(BasicType.of(loadType), RET_VAL_IDX);\n+        typeStack.push(loadType);\n+    }\n+\n+    private int newLocal(Class<?> type) {\n+        return newLocal(BasicType.of(type));\n+    }\n+\n+    private int newLocal(BasicType type) {\n+        int idx = localIdx;\n+        localIdx += (type == BasicType.D || type == BasicType.J) ? 2 : 1;\n+        return idx;\n+    }\n+\n+    private void emitLoadInternalScope() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(BINDING_CONTEXT_INTRN, \"scope\", SCOPE_DESC);\n+    }\n+\n+    private void emitLoadInternalAllocator() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(BINDING_CONTEXT_INTRN, \"allocator\", ALLOCATOR_DESC);\n+    }\n+\n+    private void emitCloseContext() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(BINDING_CONTEXT_INTRN, \"close\", CLOSE_DESC);\n+    }\n+\n+    private void emitToSegment(Binding.ToSegment binding) {\n+        long size = binding.size();\n+        assert typeStack.pop() == MemoryAddress.class;\n+\n+        emitToRawLongValue();\n+        emitConst(size);\n+        emitLoadInternalScope();\n+        mv.visitTypeInsn(CHECKCAST, RESOURCE_SCOPE_IMPL_INTRN);\n+        emitInvokeStatic(MEMORY_ADDRESS_IMPL_INTRN, \"ofLongUnchecked\", OF_LONG_UNCHECKED_DESC);\n+\n+        typeStack.push(MemorySegment.class);\n+    }\n+\n+    private void emitToRawLongValue() {\n+        emitInvokeInterface(MEMORY_ADDRESS_INTRN, \"toRawLongValue\", TO_RAW_LONG_VALUE_DESC);\n+    }\n+\n+    private void emitBoxAddress() {\n+        assert typeStack.pop() == long.class;\n+        emitInvokeInterfaceStatic(MEMORY_ADDRESS_INTRN, \"ofLong\", OF_LONG_DESC);\n+        typeStack.push(MemoryAddress.class);\n+    }\n+\n+    private void emitAllocBuffer(Binding.Allocate binding) {\n+        if (callingSequence.forDowncall()) {\n+            assert RETURN_ALLOCATOR_IDX != -1;\n+            emitLoad(BasicType.L, RETURN_ALLOCATOR_IDX);\n+        } else {\n+            emitLoadInternalAllocator();\n+        }\n+        emitAllocateCall(binding.size(), binding.alignment());\n+        typeStack.push(MemorySegment.class);\n+    }\n+\n+    private void emitBufferStore(Binding.BufferStore bufferStore) {\n+        Class<?> storeType = bufferStore.type();\n+        long offset = bufferStore.offset();\n+\n+        assert typeStack.pop() == storeType;\n+        assert typeStack.pop() == MemorySegment.class;\n+        BasicType basicStoreType = BasicType.of(storeType);\n+        int valueIdx = newLocal(basicStoreType);\n+        emitStore(basicStoreType, valueIdx);\n+\n+        Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n+        emitConst(offset);\n+        emitLoad(basicStoreType, valueIdx);\n+        String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n+        emitInvokeInterface(MEMORY_SEGMENT_INTRN, \"set\", descriptor);\n+    }\n+\n+    \/\/ VM_STORE and VM_LOAD are emulated, which is different for down\/upcalls\n+\n+    private void emitVMStore(Binding.VMStore vmStore) {\n+        Class<?> storeType = vmStore.type();\n+        assert typeStack.pop() == storeType;\n+\n+        if (callingSequence.forDowncall()) {\n+            \/\/ processing arg\n+            emitSetOutput(storeType);\n+        } else {\n+            \/\/ processing return\n+            if (!callingSequence.needsReturnBuffer()) {\n+                emitSaveReturnValue(storeType);\n+            } else {\n+                BasicType basicStoreType = BasicType.of(storeType);\n+                int valueIdx = newLocal(basicStoreType);\n+                emitStore(basicStoreType, valueIdx); \/\/ store away the stored value, need it later\n+\n+                assert RETURN_BUFFER_IDX != -1;\n+                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n+                emitConst(retBufOffset);\n+                emitLoad(basicStoreType, valueIdx);\n+                String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n+                emitInvokeInterface(MEMORY_SEGMENT_INTRN, \"set\", descriptor);\n+                retBufOffset += abi.arch.typeSize(vmStore.storage().type());\n+            }\n+        }\n+    }\n+    private void emitVMLoad(Binding.VMLoad vmLoad) {\n+        Class<?> loadType = vmLoad.type();\n+\n+        if (callingSequence.forDowncall()) {\n+            \/\/ processing return\n+            if (!callingSequence.needsReturnBuffer()) {\n+                emitRestoreReturnValue(loadType);\n+            } else {\n+                assert RETURN_BUFFER_IDX != -1;\n+                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n+                emitConst(retBufOffset);\n+                String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n+                emitInvokeInterface(MEMORY_SEGMENT_INTRN, \"get\", descriptor);\n+                retBufOffset += abi.arch.typeSize(vmLoad.storage().type());\n+                typeStack.push(loadType);\n+            }\n+        } else {\n+            \/\/ processing arg\n+            emitGetInput();\n+        }\n+    }\n+\n+    private void emitDupBinding() {\n+        Class<?> dupType = typeStack.peek();\n+        emitDup(BasicType.of(dupType));\n+        typeStack.push(dupType);\n+    }\n+\n+    private void emitUnboxAddress() {\n+        assert Addressable.class.isAssignableFrom(typeStack.pop());\n+        emitInvokeInterface(ADDRESSABLE_INTRN, \"address\", ADDRESS_DESC);\n+        emitToRawLongValue();\n+        typeStack.push(long.class);\n+    }\n+\n+    private void emitBufferLoad(Binding.BufferLoad bufferLoad) {\n+        Class<?> loadType = bufferLoad.type();\n+        long offset = bufferLoad.offset();\n+\n+        assert typeStack.pop() == MemorySegment.class;\n+\n+        Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n+        emitConst(offset);\n+        String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n+        emitInvokeInterface(MEMORY_SEGMENT_INTRN, \"get\", descriptor);\n+        typeStack.push(loadType);\n+    }\n+\n+    private void emitCopyBuffer(Binding.Copy copy) {\n+        long size = copy.size();\n+        long alignment = copy.alignment();\n+\n+        assert typeStack.pop() == MemorySegment.class;\n+\n+        \/\/ operand\/srcSegment is on the stack\n+        \/\/ generating a call to:\n+        \/\/   MemorySegment::copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)\n+        emitConst(0L);\n+        \/\/ create the dstSegment by allocating it. Similar to:\n+        \/\/   context.allocator().allocate(size, alignment)\n+        emitLoadInternalAllocator();\n+        emitAllocateCall(size, alignment);\n+        emitDup(BasicType.L);\n+        int storeIdx = newLocal(BasicType.L);\n+        emitStore(BasicType.L, storeIdx);\n+        emitConst(0L);\n+        emitConst(size);\n+        emitInvokeInterfaceStatic(MEMORY_SEGMENT_INTRN, \"copy\", COPY_DESC);\n+\n+        emitLoad(BasicType.L, storeIdx);\n+        typeStack.push(MemorySegment.class);\n+    }\n+\n+    private void emitAllocateCall(long size, long alignment) {\n+        emitConst(size);\n+        emitConst(alignment);\n+        emitInvokeInterface(SEGMENT_ALLOCATOR_INTRN, \"allocate\", ALLOCATE_DESC);\n+    }\n+\n+    private Class<?> emitLoadLayoutConstant(Class<?> type) {\n+        Class<?> valueLayoutType = valueLayoutTypeFor(type);\n+        String valueLayoutConstantName = valueLayoutConstantFor(type);\n+        emitGetStatic(VALUE_LAYOUT_INTRN, valueLayoutConstantName, valueLayoutType.descriptorString());\n+        return valueLayoutType;\n+    }\n+\n+    private static String valueLayoutConstantFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return \"JAVA_BOOLEAN\";\n+        } else if (type == byte.class) {\n+            return \"JAVA_BYTE\";\n+        } else if (type == short.class) {\n+            return \"JAVA_SHORT\";\n+        } else if (type == char.class) {\n+            return \"JAVA_CHAR\";\n+        } else if (type == int.class) {\n+            return \"JAVA_INT\";\n+        } else if (type == long.class) {\n+            return \"JAVA_LONG\";\n+        } else if (type == float.class) {\n+            return \"JAVA_FLOAT\";\n+        } else if (type == double.class) {\n+            return \"JAVA_DOUBLE\";\n+        } else if (type == MemoryAddress.class) {\n+            return \"ADDRESS\";\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n+    private static Class<?> valueLayoutTypeFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return ValueLayout.OfBoolean.class;\n+        } else if (type == byte.class) {\n+            return ValueLayout.OfByte.class;\n+        } else if (type == short.class) {\n+            return ValueLayout.OfShort.class;\n+        } else if (type == char.class) {\n+            return ValueLayout.OfChar.class;\n+        } else if (type == int.class) {\n+            return ValueLayout.OfInt.class;\n+        } else if (type == long.class) {\n+            return ValueLayout.OfLong.class;\n+        } else if (type == float.class) {\n+            return ValueLayout.OfFloat.class;\n+        } else if (type == double.class) {\n+            return ValueLayout.OfDouble.class;\n+        } else if (type == MemoryAddress.class) {\n+            return ValueLayout.OfAddress.class;\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n+    private void emitInvokeStatic(String ownerInternalName, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKESTATIC, ownerInternalName, methodName, descriptor, false);\n+    }\n+\n+    private void emitInvokeInterfaceStatic(String ownerInternalName, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKESTATIC, ownerInternalName, methodName, descriptor, true);\n+    }\n+\n+    private void emitInvokeInterface(String ownerInternalName, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKEINTERFACE, ownerInternalName, methodName, descriptor, true);\n+    }\n+\n+    private void emitInvokeVirtual(String ownerInternalName, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKEVIRTUAL, ownerInternalName, methodName, descriptor, false);\n+    }\n+\n+    private void emitGetStatic(String ownerInternalName, String fieldName, String descriptor) {\n+        mv.visitFieldInsn(GETSTATIC, ownerInternalName, fieldName, descriptor);\n+    }\n+\n+    private void emitDup(BasicType type) {\n+        if (type == BasicType.D || type == BasicType.J) {\n+            mv.visitInsn(DUP2);\n+        } else {\n+            mv.visitInsn(Opcodes.DUP);\n+        }\n+    }\n+\n+    \/*\n+     * Low-level emit helpers.\n+     *\/\n+\n+    private void emitConstZero(Class<?> type) {\n+        emitConst(switch (BasicType.of(type)) {\n+            case Z, B, S, C, I -> 0;\n+            case J -> 0L;\n+            case F -> 0F;\n+            case D -> 0D;\n+            case L -> null;\n+        });\n+    }\n+\n+    private void emitConst(Object con) {\n+        if (con == null) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+            return;\n+        }\n+        if (con instanceof Integer) {\n+            emitIconstInsn((int) con);\n+            return;\n+        }\n+        if (con instanceof Byte) {\n+            emitIconstInsn((byte)con);\n+            return;\n+        }\n+        if (con instanceof Short) {\n+            emitIconstInsn((short)con);\n+            return;\n+        }\n+        if (con instanceof Character) {\n+            emitIconstInsn((char)con);\n+            return;\n+        }\n+        if (con instanceof Long) {\n+            long x = (long) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2L);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Float) {\n+            float x = (float) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 2) {\n+                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2F);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Double) {\n+            double x = (double) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2D);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Boolean) {\n+            emitIconstInsn((boolean) con ? 1 : 0);\n+            return;\n+        }\n+        \/\/ fall through:\n+        mv.visitLdcInsn(con);\n+    }\n+\n+    private void emitIconstInsn(int cst) {\n+        if (cst >= -1 && cst <= 5) {\n+            mv.visitInsn(Opcodes.ICONST_0 + cst);\n+        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n+        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n+        } else {\n+            mv.visitLdcInsn(cst);\n+        }\n+    }\n+\n+    private void emitLoad(Class<?> type, int index) {\n+        emitLoad(BasicType.of(type), index);\n+    }\n+\n+    private void emitLoad(BasicType type, int index) {\n+        int opcode = loadOpcode(type);\n+        mv.visitVarInsn(opcode, index);\n+    }\n+\n+    private static int loadOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case Z, B, S, C, I -> ILOAD;\n+            case J -> LLOAD;\n+            case F -> FLOAD;\n+            case D -> DLOAD;\n+            case L -> ALOAD;\n+        };\n+    }\n+\n+    private void emitStore(BasicType type, int index) {\n+        int opcode = storeOpcode(type);\n+        mv.visitVarInsn(opcode, index);\n+    }\n+\n+    private static int storeOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case Z, B, S, C, I -> ISTORE;\n+            case J -> LSTORE;\n+            case F -> FSTORE;\n+            case D -> DSTORE;\n+            case L -> ASTORE;\n+        };\n+    }\n+\n+    private void emitReturn(Class<?> type) {\n+        int opcode = returnOpcode(BasicType.of(type));\n+        mv.visitInsn(opcode);\n+    }\n+\n+    private static int returnOpcode(BasicType type) {\n+       return switch (type) {\n+            case Z, B, S, C, I -> IRETURN;\n+            case J -> LRETURN;\n+            case F -> FRETURN;\n+            case D -> DRETURN;\n+            case L -> ARETURN;\n+        };\n+    }\n+\n+    private enum BasicType {\n+        Z, B, S, C, I, J, F, D, L;\n+\n+        static BasicType of(Class<?> cls) {\n+            if (cls == boolean.class) {\n+                return Z;\n+            } else if (cls == byte.class) {\n+                return B;\n+            } else if (cls == short.class) {\n+                return S;\n+            } else if (cls == char.class) {\n+                return C;\n+            } else if (cls == int.class) {\n+                return I;\n+            } else if (cls == long.class) {\n+                return J;\n+            } else if (cls == float.class) {\n+                return F;\n+            } else if (cls == double.class) {\n+                return D;\n+            } else {\n+                return L;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":858,"deletions":0,"binary":false,"changes":858,"status":"added"},{"patch":"@@ -102,1 +102,1 @@\n-            handle = Specializer.specialize(handle, callingSequence, abi);\n+            handle = BindingSpecializer.specialize(handle, callingSequence, abi);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -76,1 +75,1 @@\n-            doBindings = Specializer.specialize(target, callingSequence, abi);\n+            doBindings = BindingSpecializer.specialize(target, callingSequence, abi);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -350,46 +350,0 @@\n-    static MethodHandle wrapWithAllocator(MethodHandle specializedHandle,\n-                                          int allocatorPos, long allocationSize,\n-                                          boolean upcall) {\n-        \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n-        MethodHandle closer;\n-        int insertPos;\n-        if (specializedHandle.type().returnType() == void.class) {\n-            if (!upcall) {\n-                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n-            } else {\n-                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n-            }\n-            insertPos = 1;\n-        } else {\n-            closer = identity(specializedHandle.type().returnType()); \/\/ (V) -> V\n-            if (!upcall) {\n-                closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n-            } else {\n-                closer = collectArguments(closer, 0, MH_HANDLE_UNCAUGHT_EXCEPTION); \/\/ (Throwable, V) -> V\n-            }\n-            insertPos = 2;\n-        }\n-\n-        \/\/ downcalls get the leading SegmentAllocator param as well\n-        if (!upcall) {\n-            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, SegmentAllocator, NativeSymbol) -> V\/void\n-        }\n-\n-        closer = collectArguments(closer, insertPos, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, SegmentAllocator?, BindingContext) -> V\/void\n-\n-        MethodHandle contextFactory;\n-\n-        if (allocationSize > 0) {\n-            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, allocationSize);\n-        } else if (upcall) {\n-            contextFactory = MH_MAKE_CONTEXT_NO_ALLOCATOR;\n-        } else {\n-            \/\/ this path is probably never used now, since ProgrammableInvoker never calls this routine with bufferCopySize == 0\n-            contextFactory = constant(Binding.Context.class, Binding.Context.DUMMY);\n-        }\n-\n-        specializedHandle = tryFinally(specializedHandle, closer);\n-        specializedHandle = collectArguments(specializedHandle, allocatorPos, contextFactory);\n-        return specializedHandle;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,854 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi;\n-\n-import jdk.internal.foreign.MemoryAddressImpl;\n-import jdk.internal.foreign.ResourceScopeImpl;\n-import jdk.internal.misc.VM;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.ConstantDynamic;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;\n-import sun.security.action.GetBooleanAction;\n-import sun.security.action.GetPropertyAction;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.foreign.Addressable;\n-import java.lang.foreign.MemoryAddress;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ResourceScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.List;\n-\n-import static java.lang.invoke.MethodType.methodType;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n-public class Specializer {\n-    private static final String DUMP_CLASSES_DIR\n-        = GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.DUMP_CLASSES_DIR\");\n-    private static final boolean PERFORM_VERIFICATION\n-        = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.PERFORM_VERIFICATION\");\n-\n-    \/\/ Bunch of helper constants\n-    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n-\n-    private static final String OBJECT_DESC = Object.class.descriptorString();\n-    private static final String OBJECT_INTRN = Type.getInternalName(Object.class);\n-\n-    private static final String BINDING_CONTEXT_DESC = Binding.Context.class.descriptorString();\n-    private static final String BINDING_CONTEXT_INTRN = Type.getInternalName(Binding.Context.class);\n-    private static final String OF_BOUNDED_ALLOCATOR_NAME = \"ofBoundedAllocator\";\n-    private static final String OF_BOUNDED_ALLOCATOR_DESC = methodType(Binding.Context.class, long.class).descriptorString();\n-    private static final String OF_SCOPE_NAME = \"ofScope\";\n-    private static final String OF_SCOPE_DESC = methodType(Binding.Context.class).descriptorString();\n-    private static final String DUMMY_CONTEXT_NAME = \"DUMMY\";\n-    private static final String ALLOCATOR_NAME = \"allocator\";\n-    private static final String ALLOCATOR_DESC = methodType(SegmentAllocator.class).descriptorString();\n-    private static final String SCOPE_NAME = \"scope\";\n-    private static final String SCOPE_DESC = methodType(ResourceScope.class).descriptorString();\n-    private static final String CLOSE_NAME = \"close\";\n-    private static final String CLOSE_DESC = methodType(void.class).descriptorString();\n-\n-    private static final String ADDRESSABLE_INTRN = Type.getInternalName(Addressable.class);\n-    private static final String ADDRESS_NAME = \"address\";\n-    private static final String ADDRESS_DESC = methodType(MemoryAddress.class).descriptorString();\n-\n-    private static final String MEMORY_SEGMENT_INTRN = Type.getInternalName(MemorySegment.class);\n-    private static final String GET_NAME = \"get\";\n-    private static final String SET_NAME = \"set\";\n-    private static final String COPY_NAME = \"copy\";\n-    private static final String COPY_DESC = methodType(void.class, MemorySegment.class, long.class, MemorySegment.class, long.class, long.class).descriptorString();\n-\n-    private static final String MEMORY_ADDRESS_INTRN = Type.getInternalName(MemoryAddress.class);\n-    private static final String TO_RAW_LONG_VALUE_NAME = \"toRawLongValue\";\n-    private static final String TO_RAW_LONG_VALUE_DESC = methodType(long.class).descriptorString();\n-    private static final String OF_LONG_NAME = \"ofLong\";\n-    private static final String OF_LONG_DESC = methodType(MemoryAddress.class, long.class).descriptorString();\n-\n-    private static final String MEMORY_ADDRESS_IMPL_INTRN = Type.getInternalName(MemoryAddressImpl.class);\n-    private static final String OF_LONG_UNCHECKED_NAME = \"ofLongUnchecked\";\n-    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, ResourceScopeImpl.class).descriptorString();\n-\n-    private static final String VALUE_LAYOUT_INTRN = Type.getInternalName(ValueLayout.class);\n-\n-    private static final String SEGMENT_ALLOCATOR_INTRN = Type.getInternalName(SegmentAllocator.class);\n-    private static final String ALLOCATE_NAME = \"allocate\";\n-    private static final String ALLOCATE_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n-\n-    private static final String RESOURCE_SCOPE_IMPL_INTRN = Type.getInternalName(ResourceScopeImpl.class);\n-\n-    private static final String SHARED_UTILS_INTRN = Type.getInternalName(SharedUtils.class);\n-    private static final String HANDLE_UNCAUGHT_EXCEPTION_NAME = \"handleUncaughtException\";\n-    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class).descriptorString();\n-\n-    private static final String METHOD_HANDLES_INTRN = Type.getInternalName(MethodHandles.class);\n-    private static final String CLASS_DATA_NAME = \"classData\";\n-    private static final String CLASS_DATA_DESC = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class).descriptorString();\n-\n-    private static final String METHOD_HANDLE_INTRN = Type.getInternalName(MethodHandle.class);\n-    private static final String INVOKE_EXACT_NAME = \"invokeExact\";\n-\n-    private static final Handle BSM_CLASS_DATA = new Handle(\n-            H_INVOKESTATIC,\n-            METHOD_HANDLES_INTRN,\n-            CLASS_DATA_NAME,\n-            CLASS_DATA_DESC,\n-            false);\n-    private static final ConstantDynamic CLASS_DATA_CONDY = new ConstantDynamic(\n-            ConstantDescs.DEFAULT_NAME,\n-            OBJECT_DESC,\n-            BSM_CLASS_DATA);\n-\n-    private static final String CLASS_NAME_DOWNCALL = \"jdk\/internal\/foreign\/abi\/DowncallStub\";\n-    private static final String CLASS_NAME_UPCALL = \"jdk\/internal\/foreign\/abi\/UpcallStub\";\n-    private static final String METHOD_NAME = \"invoke\";\n-\n-    private static final String SUPER_NAME = OBJECT_INTRN;\n-\n-    \/\/ Instance fields start here\n-    private final MethodVisitor mv;\n-    private final MethodType callerMethodType;\n-    private final CallingSequence callingSequence;\n-    private final ABIDescriptor abi;\n-    private final MethodType leafType;\n-\n-    private int localIdx = 0;\n-    private int[] paramIndex2ParamSlot;\n-    private int[] leafArgSlots;\n-    private int RETURN_ALLOCATOR_IDX = -1;\n-    private int CONTEXT_IDX = -1;\n-    private int RETURN_BUFFER_IDX = -1;\n-    private int RET_VAL_IDX = -1;\n-    private Deque<Class<?>> typeStack;\n-    private List<Class<?>> leafArgTypes;\n-    private int paramIndex;\n-    private long retBufOffset; \/\/ for needsReturnBuffer\n-\n-    private Specializer(MethodVisitor mv, MethodType callerMethodType, CallingSequence callingSequence, ABIDescriptor abi, MethodType leafType) {\n-        this.mv = mv;\n-        this.callerMethodType = callerMethodType;\n-        this.callingSequence = callingSequence;\n-        this.abi = abi;\n-        this.leafType = leafType;\n-    }\n-\n-    static MethodHandle specialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n-        String className = callingSequence.forDowncall() ? CLASS_NAME_DOWNCALL : CLASS_NAME_UPCALL;\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(CLASSFILE_VERSION, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, SUPER_NAME, null);\n-\n-        MethodType callerMethodType = callingSequence.callerMethodType();\n-        if (callingSequence.forDowncall()) {\n-            if (callingSequence.needsReturnBuffer()) {\n-                callerMethodType = callerMethodType.dropParameterTypes(0, 1); \/\/ Return buffer does not appear in the parameter list\n-            }\n-            callerMethodType = callerMethodType.insertParameterTypes(0, SegmentAllocator.class);\n-        }\n-        String descriptor = callerMethodType.descriptorString();\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, METHOD_NAME, descriptor, null, null);\n-\n-        new Specializer(mv, callerMethodType, callingSequence, abi, leafHandle.type()).specialize();\n-\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-\n-        byte[] bytes = cw.toByteArray();\n-        if (DUMP_CLASSES_DIR != null) {\n-            String fileName = className + escapeForFileName(callingSequence.functionDesc().toString()) + \".class\";\n-            Path dumpPath = Path.of(DUMP_CLASSES_DIR).resolve(fileName);\n-            try {\n-                Files.createDirectories(dumpPath.getParent());\n-                Files.write(dumpPath, bytes);\n-            } catch (IOException e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-\n-        if (PERFORM_VERIFICATION) {\n-            boolean printResults = false; \/\/ only print in case of exception\n-            CheckClassAdapter.verify(new ClassReader(bytes), null, printResults, new PrintWriter(System.err));\n-        }\n-\n-        try {\n-            \/\/ We must initialize the class since the upcall stubs don't have a clinit barrier, and the slow\n-            \/\/ path in the c2i adapter we end up calling can not handle the particular code shape where the\n-            \/\/ caller is an optimized upcall stub.\n-            boolean initialize = callingSequence.forUpcall();\n-            MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, initialize);\n-            return lookup.findStatic(lookup.lookupClass(), METHOD_NAME, callerMethodType);\n-        } catch (IllegalAccessException | NoSuchMethodException e) {\n-            throw new InternalError(\"Should not happen\", e);\n-        }\n-    }\n-\n-    private static String escapeForFileName(String str) {\n-        StringBuilder sb = new StringBuilder(str.length());\n-        for (int i = 0; i < str.length(); i++) {\n-            char c = str.charAt(i);\n-            sb.append(switch (c) {\n-                case ' ' -> '_';\n-                case '[', '<' -> '{';\n-                case ']', '>' -> '}';\n-                case '\/', '\\\\', ':', '*', '?', '\"', '|' -> '!'; \/\/ illegal in Windows file names.\n-                default -> c;\n-            });\n-        }\n-        return sb.toString();\n-    }\n-\n-    private void specialize() {\n-        \/\/ map of parameter indexes to local var table slots\n-        paramIndex2ParamSlot = new int[callerMethodType.parameterCount()];\n-        for (int i = 0; i < callerMethodType.parameterCount(); i++) {\n-            paramIndex2ParamSlot[i] = newLocal(callerMethodType.parameterType(i));\n-        }\n-\n-        \/\/ slots that store the output arguments (passed to the leaf handle)\n-        leafArgSlots = new int[leafType.parameterCount()];\n-        for (int i = 0; i < leafType.parameterCount(); i++) {\n-            leafArgSlots[i] = newLocal(leafType.parameterType(i));\n-        }\n-\n-        \/\/ allocator passed to us for allocating the return MS (downcalls only)\n-        if (callingSequence.forDowncall()) {\n-            RETURN_ALLOCATOR_IDX = 0; \/\/ first param\n-        }\n-\n-        \/\/ create a Binding.Context for this call\n-        if (callingSequence.allocationSize() != 0) {\n-            emitConst(callingSequence.allocationSize());\n-            mv.visitMethodInsn(INVOKESTATIC, BINDING_CONTEXT_INTRN, OF_BOUNDED_ALLOCATOR_NAME, OF_BOUNDED_ALLOCATOR_DESC, false);\n-        } else if (callingSequence.forDowncall()) {\n-            mv.visitFieldInsn(GETSTATIC, BINDING_CONTEXT_INTRN, DUMMY_CONTEXT_NAME, BINDING_CONTEXT_DESC);\n-        } else {\n-            mv.visitMethodInsn(INVOKESTATIC, BINDING_CONTEXT_INTRN, OF_SCOPE_NAME, OF_SCOPE_DESC, false);\n-        }\n-        CONTEXT_IDX = newLocal(BasicType.L);\n-        emitStore(BasicType.L, CONTEXT_IDX);\n-\n-        \/\/ in case the call needs a return buffer, allocate it here.\n-        \/\/ for upcalls the VM wrapper stub allocates the buffer.\n-        if (callingSequence.needsReturnBuffer() && callingSequence.forDowncall()) {\n-            emitLoadInteralAllocator();\n-            emitAllocateCall(callingSequence.returnBufferSize(), 1);\n-            RETURN_BUFFER_IDX = newLocal(BasicType.L);\n-            emitStore(BasicType.L, RETURN_BUFFER_IDX);\n-        }\n-\n-        Label tryStart = new Label();\n-        Label tryEnd = new Label();\n-        Label catchStart = new Label();\n-\n-        mv.visitLabel(tryStart);\n-\n-        \/\/ stack to keep track of types on the bytecode stack between bindings.\n-        \/\/ this is needed to e.g. emit the right DUP instruction,\n-        \/\/ but also used for type checking.\n-        typeStack = new ArrayDeque<>();\n-        \/\/ leaf arg types are the types of the args passed to the leaf handle.\n-        \/\/ these are collected from VM_STORE instructions for downcalls, and\n-        \/\/ recipe outputs for upcalls (see uses emitSetOutput for both)\n-        leafArgTypes = new ArrayList<>();\n-        paramIndex = callingSequence.forDowncall() ? 1 : 0; \/\/ +1 to skip SegmentAllocator\n-        for (int i = 0; i < callingSequence.argumentBindingsCount(); i++) {\n-            if (callingSequence.forDowncall()) {\n-                \/\/ for downcalls, recipes have an input value, which we set up here\n-                if (callingSequence.needsReturnBuffer() && i == 0) {\n-                    assert RETURN_BUFFER_IDX != -1;\n-                    emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n-                    typeStack.push(MemorySegment.class);\n-                } else {\n-                    emitGetInput();\n-                }\n-            }\n-\n-            \/\/ emit code according to binding recipe\n-            doBindings(callingSequence.argumentBindings(i));\n-\n-            if (callingSequence.forUpcall()) {\n-                \/\/ for upcalls, recipes have a result, which we handle here\n-                if (callingSequence.needsReturnBuffer() && i == 0) {\n-                    \/\/ return buffer ptr is wrapped in a MemorySegment above, but not passed to the leaf handle\n-                    assert typeStack.pop() == MemorySegment.class;\n-                    RETURN_BUFFER_IDX = newLocal(BasicType.L);\n-                    emitStore(BasicType.L, RETURN_BUFFER_IDX);\n-                } else {\n-                    \/\/ for upcalls the recipe result is an argument to the leaf handle\n-                    emitSetOutput(typeStack.pop());\n-                }\n-            }\n-            assert typeStack.isEmpty();\n-        }\n-\n-        assert leafArgTypes.equals(leafType.parameterList());\n-\n-        \/\/ load the leaf MethodHandle\n-        mv.visitLdcInsn(CLASS_DATA_CONDY);\n-        mv.visitTypeInsn(CHECKCAST, METHOD_HANDLE_INTRN);\n-        \/\/ load all the leaf args\n-        for (int i = 0; i < leafArgSlots.length; i++) {\n-            emitLoad(leafArgTypes.get(i), leafArgSlots[i]);\n-        }\n-        \/\/ call leaf MH\n-        mv.visitMethodInsn(INVOKEVIRTUAL, METHOD_HANDLE_INTRN, INVOKE_EXACT_NAME, leafType.descriptorString(), false);\n-\n-        \/\/ for downcalls, store the result of the leaf handle call away, until\n-        \/\/ it is requested by a VM_LOAD in the return recipe.\n-        if (callingSequence.forDowncall() && leafType.returnType() != void.class) {\n-            emitSaveReturnValue(leafType.returnType());\n-        }\n-        \/\/ for upcalls we leave the return value on the stack to be picked up\n-        \/\/ as an input of the return recipe.\n-\n-        \/\/ return value processing\n-        if (callingSequence.hasReturnBindings()) {\n-            if (callingSequence.forUpcall()) {\n-                typeStack.push(leafType.returnType());\n-            }\n-\n-            retBufOffset = 0; \/\/ offset for reading from return buffer\n-            doBindings(callingSequence.returnBindings());\n-\n-            if (callingSequence.forUpcall() && !callingSequence.needsReturnBuffer()) {\n-                \/\/ was VM_STOREd somewhere in the bindings\n-                emitRestoreReturnValue(callerMethodType.returnType());\n-            }\n-            mv.visitLabel(tryEnd);\n-            \/\/ finally\n-            emitCloseContext();\n-\n-            if (callerMethodType.returnType() == void.class) {\n-                \/\/ The case for upcalls that return by return buffer\n-                assert typeStack.isEmpty();\n-                mv.visitInsn(RETURN);\n-            } else {\n-                assert typeStack.pop() == callerMethodType.returnType();\n-                assert typeStack.isEmpty();\n-                emitReturn(callerMethodType.returnType());\n-            }\n-        } else {\n-            assert callerMethodType.returnType() == void.class;\n-            assert typeStack.isEmpty();\n-            mv.visitLabel(tryEnd);\n-            \/\/ finally\n-            emitCloseContext();\n-            mv.visitInsn(RETURN);\n-        }\n-\n-        mv.visitLabel(catchStart);\n-        \/\/ finally\n-        emitCloseContext();\n-        if (callingSequence.forDowncall()) {\n-            mv.visitInsn(ATHROW);\n-        } else {\n-           mv.visitMethodInsn(INVOKESTATIC, SHARED_UTILS_INTRN, HANDLE_UNCAUGHT_EXCEPTION_NAME, HANDLE_UNCAUGHT_EXCEPTION_DESC, false);\n-           if (callerMethodType.returnType() != void.class) {\n-               emitConstZero(callerMethodType.returnType());\n-               emitReturn(callerMethodType.returnType());\n-           } else {\n-               mv.visitInsn(RETURN);\n-           }\n-        }\n-\n-        mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, null);\n-    }\n-\n-    private void doBindings(List<Binding> bindings) {\n-        for (Binding binding : bindings) {\n-            switch (binding.tag()) {\n-                case VM_STORE -> emitVMStore((Binding.VMStore) binding);\n-                case VM_LOAD -> emitVMLoad((Binding.VMLoad) binding);\n-                case BUFFER_STORE -> emitBufferStore((Binding.BufferStore) binding);\n-                case BUFFER_LOAD -> emitBufferLoad((Binding.BufferLoad) binding);\n-                case COPY_BUFFER -> emitCopyBuffer((Binding.Copy) binding);\n-                case ALLOC_BUFFER -> emitAllocBuffer((Binding.Allocate) binding);\n-                case BOX_ADDRESS -> emitBoxAddress();\n-                case UNBOX_ADDRESS -> emitUnboxAddress();\n-                case TO_SEGMENT -> emitToSegment((Binding.ToSegment) binding);\n-                case DUP -> emitDupBinding();\n-            }\n-        }\n-    }\n-\n-    private void emitSetOutput(Class<?> storeType) {\n-        emitStore(BasicType.of(storeType), leafArgSlots[leafArgTypes.size()]);\n-        leafArgTypes.add(storeType);\n-    }\n-\n-    private void emitGetInput() {\n-        Class<?> highLevelType = callerMethodType.parameterType(paramIndex);\n-        emitLoad(BasicType.of(highLevelType), paramIndex2ParamSlot[paramIndex]);\n-        typeStack.push(highLevelType);\n-        paramIndex++;\n-    }\n-\n-    private void emitSaveReturnValue(Class<?> storeType) {\n-        RET_VAL_IDX = newLocal(BasicType.of(storeType));\n-        emitStore(BasicType.of(storeType), RET_VAL_IDX);\n-    }\n-\n-    private void emitRestoreReturnValue(Class<?> loadType) {\n-        assert RET_VAL_IDX != -1;\n-        emitLoad(BasicType.of(loadType), RET_VAL_IDX);\n-        typeStack.push(loadType);\n-    }\n-\n-    private int newLocal(Class<?> type) {\n-        return newLocal(BasicType.of(type));\n-    }\n-\n-    private int newLocal(BasicType type) {\n-        int idx = localIdx;\n-        localIdx += (type == BasicType.D || type == BasicType.J) ? 2 : 1;\n-        return idx;\n-    }\n-\n-    private void emitLoadInternalScope() {\n-        assert CONTEXT_IDX != -1;\n-        emitLoad(BasicType.L, CONTEXT_IDX);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, BINDING_CONTEXT_INTRN, SCOPE_NAME, SCOPE_DESC, false);\n-    }\n-\n-    private void emitLoadInteralAllocator() {\n-        assert CONTEXT_IDX != -1;\n-        emitLoad(BasicType.L, CONTEXT_IDX);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, BINDING_CONTEXT_INTRN, ALLOCATOR_NAME, ALLOCATOR_DESC, false);\n-    }\n-\n-    private void emitCloseContext() {\n-        assert CONTEXT_IDX != -1;\n-        emitLoad(BasicType.L, CONTEXT_IDX);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, BINDING_CONTEXT_INTRN, CLOSE_NAME, CLOSE_DESC, false);\n-    }\n-\n-    private void emitToSegment(Binding.ToSegment binding) {\n-        long size = binding.size();\n-        assert typeStack.pop() == MemoryAddress.class;\n-\n-        emitToRawLongValue();\n-        emitConst(size);\n-        emitLoadInternalScope();\n-        mv.visitTypeInsn(CHECKCAST, RESOURCE_SCOPE_IMPL_INTRN);\n-        mv.visitMethodInsn(INVOKESTATIC, MEMORY_ADDRESS_IMPL_INTRN, OF_LONG_UNCHECKED_NAME, OF_LONG_UNCHECKED_DESC, false);\n-\n-        typeStack.push(MemorySegment.class);\n-    }\n-\n-    private void emitToRawLongValue() {\n-        mv.visitMethodInsn(INVOKEINTERFACE, MEMORY_ADDRESS_INTRN, TO_RAW_LONG_VALUE_NAME, TO_RAW_LONG_VALUE_DESC, true);\n-    }\n-\n-    private void emitBoxAddress() {\n-        assert typeStack.pop() == long.class;\n-        mv.visitMethodInsn(INVOKESTATIC, MEMORY_ADDRESS_INTRN, OF_LONG_NAME, OF_LONG_DESC, true);\n-        typeStack.push(MemoryAddress.class);\n-    }\n-\n-    private void emitAllocBuffer(Binding.Allocate binding) {\n-        if (callingSequence.forDowncall()) {\n-            assert RETURN_ALLOCATOR_IDX != -1;\n-            emitLoad(BasicType.L, RETURN_ALLOCATOR_IDX);\n-        } else {\n-            emitLoadInteralAllocator();\n-        }\n-        emitAllocateCall(binding.size(), binding.alignment());\n-        typeStack.push(MemorySegment.class);\n-    }\n-\n-    private void emitBufferStore(Binding.BufferStore bufferStore) {\n-        Class<?> storeType = bufferStore.type();\n-        long offset = bufferStore.offset();\n-\n-        assert typeStack.pop() == storeType;\n-        assert typeStack.pop() == MemorySegment.class;\n-        BasicType basicStoreType = BasicType.of(storeType);\n-        int valueIdx = newLocal(basicStoreType);\n-        emitStore(basicStoreType, valueIdx);\n-\n-        Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n-        emitConst(offset);\n-        emitLoad(basicStoreType, valueIdx);\n-        String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n-        mv.visitMethodInsn(INVOKEINTERFACE, MEMORY_SEGMENT_INTRN, SET_NAME, descriptor, true);\n-    }\n-\n-    \/\/ VM_STORE and VM_LOAD are emulated, which is different for down\/upcalls\n-\n-    private void emitVMStore(Binding.VMStore vmStore) {\n-        Class<?> storeType = vmStore.type();\n-        assert typeStack.pop() == storeType;\n-\n-        if (callingSequence.forDowncall()) {\n-            \/\/ processing arg\n-            emitSetOutput(storeType);\n-        } else {\n-            \/\/ processing return\n-            if (!callingSequence.needsReturnBuffer()) {\n-                emitSaveReturnValue(storeType);\n-            } else {\n-                BasicType basicStoreType = BasicType.of(storeType);\n-                int valueIdx = newLocal(basicStoreType);\n-                emitStore(basicStoreType, valueIdx); \/\/ store away the stored value, need it later\n-\n-                assert RETURN_BUFFER_IDX != -1;\n-                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n-                Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n-                emitConst(retBufOffset);\n-                emitLoad(basicStoreType, valueIdx);\n-                String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n-                mv.visitMethodInsn(INVOKEINTERFACE, MEMORY_SEGMENT_INTRN, SET_NAME, descriptor, true);\n-                retBufOffset += abi.arch.typeSize(vmStore.storage().type());\n-            }\n-        }\n-    }\n-    private void emitVMLoad(Binding.VMLoad vmLoad) {\n-        Class<?> loadType = vmLoad.type();\n-\n-        if (callingSequence.forDowncall()) {\n-            \/\/ processing return\n-            if (!callingSequence.needsReturnBuffer()) {\n-                emitRestoreReturnValue(loadType);\n-            } else {\n-                assert RETURN_BUFFER_IDX != -1;\n-                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n-                Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n-                emitConst(retBufOffset);\n-                String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n-                mv.visitMethodInsn(INVOKEINTERFACE, MEMORY_SEGMENT_INTRN, GET_NAME, descriptor, true);\n-                retBufOffset += abi.arch.typeSize(vmLoad.storage().type());\n-                typeStack.push(loadType);\n-            }\n-        } else {\n-            \/\/ processing arg\n-            emitGetInput();\n-        }\n-    }\n-\n-    private void emitDupBinding() {\n-        Class<?> dupType = typeStack.peek();\n-        emitDup(BasicType.of(dupType));\n-        typeStack.push(dupType);\n-    }\n-\n-    private void emitUnboxAddress() {\n-        assert Addressable.class.isAssignableFrom(typeStack.pop());\n-        mv.visitMethodInsn(INVOKEINTERFACE, ADDRESSABLE_INTRN, ADDRESS_NAME, ADDRESS_DESC, true);\n-        emitToRawLongValue();\n-        typeStack.push(long.class);\n-    }\n-\n-    private void emitBufferLoad(Binding.BufferLoad bufferLoad) {\n-        Class<?> loadType = bufferLoad.type();\n-        long offset = bufferLoad.offset();\n-\n-        assert typeStack.pop() == MemorySegment.class;\n-\n-        Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n-        emitConst(offset);\n-        String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n-        mv.visitMethodInsn(INVOKEINTERFACE, MEMORY_SEGMENT_INTRN, GET_NAME, descriptor, true);\n-        typeStack.push(loadType);\n-    }\n-\n-    private void emitCopyBuffer(Binding.Copy copy) {\n-        long size = copy.size();\n-        long alignment = copy.alignment();\n-\n-        assert typeStack.pop() == MemorySegment.class;\n-\n-        \/\/ operand\/srcSegment is on the stack\n-        \/\/ copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)\n-        emitConst(0L);\n-        \/\/ create the dstSegment by allocating it\n-        \/\/ context.allocator().allocate(size, alignment)\n-        emitLoadInteralAllocator();\n-        emitAllocateCall(size, alignment);\n-        emitDup(BasicType.L);\n-        int storeIdx = newLocal(BasicType.L);\n-        emitStore(BasicType.L, storeIdx);\n-        emitConst(0L);\n-        emitConst(size);\n-        mv.visitMethodInsn(INVOKESTATIC, MEMORY_SEGMENT_INTRN, COPY_NAME, COPY_DESC, true);\n-\n-        emitLoad(BasicType.L, storeIdx);\n-        typeStack.push(MemorySegment.class);\n-    }\n-\n-    private void emitAllocateCall(long size, long alignment) {\n-        emitConst(size);\n-        emitConst(alignment);\n-        mv.visitMethodInsn(INVOKEINTERFACE, SEGMENT_ALLOCATOR_INTRN, ALLOCATE_NAME, ALLOCATE_DESC, true);\n-    }\n-\n-    private Class<?> emitLoadLayoutConstant(Class<?> type) {\n-        Class<?> valueLayoutType = valueLayoutTypeFor(type);\n-        String valueLayoutConstantName = valueLayoutConstantFor(type);\n-        mv.visitFieldInsn(GETSTATIC, VALUE_LAYOUT_INTRN, valueLayoutConstantName, valueLayoutType.descriptorString());\n-        return valueLayoutType;\n-    }\n-\n-    private static String valueLayoutConstantFor(Class<?> type) {\n-        if (type == boolean.class) {\n-            return \"JAVA_BOOLEAN\";\n-        } else if (type == byte.class) {\n-            return \"JAVA_BYTE\";\n-        } else if (type == short.class) {\n-            return \"JAVA_SHORT\";\n-        } else if (type == char.class) {\n-            return \"JAVA_CHAR\";\n-        } else if (type == int.class) {\n-            return \"JAVA_INT\";\n-        } else if (type == long.class) {\n-            return \"JAVA_LONG\";\n-        } else if (type == float.class) {\n-            return \"JAVA_FLOAT\";\n-        } else if (type == double.class) {\n-            return \"JAVA_DOUBLE\";\n-        } else if (type == MemoryAddress.class) {\n-            return \"ADDRESS\";\n-        } else {\n-            throw new IllegalStateException(\"Unknown type: \" + type);\n-        }\n-    }\n-\n-    private static Class<?> valueLayoutTypeFor(Class<?> type) {\n-        if (type == boolean.class) {\n-            return ValueLayout.OfBoolean.class;\n-        } else if (type == byte.class) {\n-            return ValueLayout.OfByte.class;\n-        } else if (type == short.class) {\n-            return ValueLayout.OfShort.class;\n-        } else if (type == char.class) {\n-            return ValueLayout.OfChar.class;\n-        } else if (type == int.class) {\n-            return ValueLayout.OfInt.class;\n-        } else if (type == long.class) {\n-            return ValueLayout.OfLong.class;\n-        } else if (type == float.class) {\n-            return ValueLayout.OfFloat.class;\n-        } else if (type == double.class) {\n-            return ValueLayout.OfDouble.class;\n-        } else if (type == MemoryAddress.class) {\n-            return ValueLayout.OfAddress.class;\n-        } else {\n-            throw new IllegalStateException(\"Unknown type: \" + type);\n-        }\n-    }\n-\n-    private void emitDup(BasicType type) {\n-        if (type == BasicType.D || type == BasicType.J) {\n-            mv.visitInsn(DUP2);\n-        } else {\n-            mv.visitInsn(Opcodes.DUP);\n-        }\n-    }\n-\n-    \/*\n-     * Low-level emit helpers.\n-     *\/\n-\n-    private void emitConstZero(Class<?> type) {\n-        emitConst(switch (BasicType.of(type)) {\n-            case Z, B, S, C, I -> 0;\n-            case J -> 0L;\n-            case F -> 0F;\n-            case D -> 0D;\n-            case L -> null;\n-        });\n-    }\n-\n-    private void emitConst(Object con) {\n-        if (con == null) {\n-            mv.visitInsn(Opcodes.ACONST_NULL);\n-            return;\n-        }\n-        if (con instanceof Integer) {\n-            emitIconstInsn((int) con);\n-            return;\n-        }\n-        if (con instanceof Byte) {\n-            emitIconstInsn((byte)con);\n-            return;\n-        }\n-        if (con instanceof Short) {\n-            emitIconstInsn((short)con);\n-            return;\n-        }\n-        if (con instanceof Character) {\n-            emitIconstInsn((char)con);\n-            return;\n-        }\n-        if (con instanceof Long) {\n-            long x = (long) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2L);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Float) {\n-            float x = (float) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 2) {\n-                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2F);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Double) {\n-            double x = (double) con;\n-            short sx = (short)x;\n-            if (x == sx) {\n-                if (sx >= 0 && sx <= 1) {\n-                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n-                } else {\n-                    emitIconstInsn((int) x);\n-                    mv.visitInsn(Opcodes.I2D);\n-                }\n-                return;\n-            }\n-        }\n-        if (con instanceof Boolean) {\n-            emitIconstInsn((boolean) con ? 1 : 0);\n-            return;\n-        }\n-        \/\/ fall through:\n-        mv.visitLdcInsn(con);\n-    }\n-\n-    private void emitIconstInsn(int cst) {\n-        if (cst >= -1 && cst <= 5) {\n-            mv.visitInsn(Opcodes.ICONST_0 + cst);\n-        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-        } else {\n-            mv.visitLdcInsn(cst);\n-        }\n-    }\n-\n-    private void emitLoad(Class<?> type, int index) {\n-        emitLoad(BasicType.of(type), index);\n-    }\n-\n-    private void emitLoad(BasicType type, int index) {\n-        int opcode = loadOpcode(type);\n-        mv.visitVarInsn(opcode, index);\n-    }\n-\n-    private static int loadOpcode(BasicType type) throws InternalError {\n-        return switch (type) {\n-            case Z, B, S, C, I -> ILOAD;\n-            case J -> LLOAD;\n-            case F -> FLOAD;\n-            case D -> DLOAD;\n-            case L -> ALOAD;\n-        };\n-    }\n-\n-    private void emitStore(BasicType type, int index) {\n-        int opcode = storeOpcode(type);\n-        mv.visitVarInsn(opcode, index);\n-    }\n-\n-    private static int storeOpcode(BasicType type) throws InternalError {\n-        return switch (type) {\n-            case Z, B, S, C, I -> ISTORE;\n-            case J -> LSTORE;\n-            case F -> FSTORE;\n-            case D -> DSTORE;\n-            case L -> ASTORE;\n-        };\n-    }\n-\n-    private void emitReturn(Class<?> type) {\n-        int opcode = returnOpcode(BasicType.of(type));\n-        mv.visitInsn(opcode);\n-    }\n-\n-    private static int returnOpcode(BasicType type) {\n-       return switch (type) {\n-            case Z, B, S, C, I -> IRETURN;\n-            case J -> LRETURN;\n-            case F -> FRETURN;\n-            case D -> DRETURN;\n-            case L -> ARETURN;\n-        };\n-    }\n-\n-    private enum BasicType {\n-        Z, B, S, C, I, J, F, D, L;\n-\n-        static BasicType of(Class<?> cls) {\n-            if (cls == boolean.class) {\n-                return Z;\n-            } else if (cls == byte.class) {\n-                return B;\n-            } else if (cls == short.class) {\n-                return S;\n-            } else if (cls == char.class) {\n-                return C;\n-            } else if (cls == int.class) {\n-                return I;\n-            } else if (cls == long.class) {\n-                return J;\n-            } else if (cls == float.class) {\n-                return F;\n-            } else if (cls == double.class) {\n-                return D;\n-            } else {\n-                return L;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Specializer.java","additions":0,"deletions":854,"binary":false,"changes":854,"status":"deleted"},{"patch":"@@ -72,1 +72,1 @@\n-                    \"Unsupported layout: [:b32(I)]\"\n+                    \"Unsupported layout: [:i32]\"\n@@ -76,1 +76,1 @@\n-                    \"Unsupported layout: [:b32(I)]\"\n+                    \"Unsupported layout: [:i32]\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}