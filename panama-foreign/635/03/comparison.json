{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker;\n@@ -33,4 +34,0 @@\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n@@ -146,1 +143,1 @@\n-public sealed interface CLinker permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n+public sealed interface CLinker permits AbstractLinker {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/CLinker.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,3 +107,5 @@\n-        return decorateLayoutString(String.format(\"%s%d\",\n-                order == ByteOrder.BIG_ENDIAN ? \"B\" : \"b\",\n-                bitSize()));\n+        char descriptor = carrier == MemoryAddress.class ? 'A' : carrier.descriptorString().charAt(0);\n+        if (order == ByteOrder.LITTLE_ENDIAN) {\n+            descriptor = Character.toLowerCase(descriptor);\n+        }\n+        return decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n+\n+import java.lang.foreign.CLinker;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.NativeSymbol;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.SoftReference;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+public abstract sealed class AbstractLinker implements CLinker permits LinuxAArch64Linker, MacOsAArch64Linker,\n+                                                                       SysVx64Linker, Windowsx64Linker {\n+\n+    private final SoftReferenceCache<FunctionDescriptor, MethodHandle> DOWNCALL_CACHE = new SoftReferenceCache<>();\n+\n+    @Override\n+    public MethodHandle downcallHandle(FunctionDescriptor function) {\n+        Objects.requireNonNull(function);\n+\n+        return DOWNCALL_CACHE.get(function, fd -> {\n+            MethodType type = SharedUtils.inferMethodType(fd, false);\n+            MethodHandle handle = arrangeDowncall(type, fd);\n+            handle = SharedUtils.maybeInsertAllocator(handle);\n+            MethodHandle mh = SharedUtils.wrapDowncall(handle, fd);\n+            return mh;\n+        });\n+    }\n+    protected abstract MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function);\n+\n+    @Override\n+    public NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n+        SharedUtils.checkExceptions(target);\n+\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        NativeSymbol symb =  arrangeUpcall(target, target.type(), function, scope);\n+        return symb;\n+    }\n+\n+    protected abstract NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType,\n+                                                  FunctionDescriptor function, ResourceScope scope);\n+\n+    private static class SoftReferenceCache<K, V> {\n+        private final Map<K, Node> cache = new ConcurrentHashMap<>();\n+\n+        public V get(K key, Function<K, V> valueFactory) {\n+            return cache\n+                    .computeIfAbsent(key, k -> new Node()) \/\/ short lock (has to be according to ConcurrentHashMap)\n+                    .get(key, valueFactory); \/\/ long lock, but just for the particular key\n+        }\n+\n+        private class Node {\n+            private SoftReference<V> ref;\n+\n+            public Node() {\n+            }\n+\n+            public V get(K key, Function<K, V> valueFactory) {\n+                V result;\n+                if (ref == null || (result = ref.get()) == null) {\n+                    synchronized (this) { \/\/ don't let threads race on the valueFactory::apply call\n+                        if (ref == null || (result = ref.get()) == null) {\n+                            result = valueFactory.apply(key); \/\/ keep alive\n+                            ref = new SoftReference<>(result);\n+                        }\n+                    }\n+                }\n+                return result;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -204,23 +204,0 @@\n-    private static final MethodHandle MH_UNBOX_ADDRESS;\n-    private static final MethodHandle MH_BOX_ADDRESS;\n-    private static final MethodHandle MH_COPY_BUFFER;\n-    private static final MethodHandle MH_ALLOCATE_BUFFER;\n-    private static final MethodHandle MH_TO_SEGMENT;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n-                    methodType(long.class));\n-            MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n-                    methodType(MemoryAddress.class, long.class));\n-            MH_COPY_BUFFER = lookup.findStatic(Copy.class, \"copyBuffer\",\n-                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, Context.class));\n-            MH_ALLOCATE_BUFFER = lookup.findStatic(Allocate.class, \"allocateBuffer\",\n-                    methodType(MemorySegment.class, long.class, long.class, Context.class));\n-            MH_TO_SEGMENT = lookup.findStatic(ToSegment.class, \"toSegment\",\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class, Context.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n@@ -339,2 +316,0 @@\n-    public abstract MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos);\n-\n@@ -546,5 +521,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return specializedHandle; \/\/ no-op\n-        }\n-\n@@ -581,5 +551,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return specializedHandle; \/\/ no-op\n-        }\n-\n@@ -639,2 +604,2 @@\n-     * Pops a MemorySegment from the operand stack, loads a [type] from\n-     * [offset into memory region] from it, and pushes it onto the operand stack.\n+     * Pops a [type] from the operand stack, then pops a MemorySegment from the operand stack.\n+     * Stores the [type] to [offset into memory region].\n@@ -665,7 +630,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);\n-            setter = setter.asType(methodType(void.class, MemorySegment.class, type()));\n-            return collectArguments(specializedHandle, insertPos + 1, setter);\n-        }\n-\n@@ -708,8 +666,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle filter = varHandle()\n-                    .toMethodHandle(VarHandle.AccessMode.GET)\n-                    .asType(methodType(type(), MemorySegment.class));\n-            return filterArguments(specializedHandle, insertPos, filter);\n-        }\n-\n@@ -741,2 +691,1 @@\n-        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment,\n-                                                    Context context) {\n+        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, Context context) {\n@@ -779,7 +728,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle filter = insertArguments(MH_COPY_BUFFER, 1, size, alignment);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, filter);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n-        }\n-\n@@ -848,7 +790,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle allocateBuffer = insertArguments(MH_ALLOCATE_BUFFER, 0, size, alignment);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, allocateBuffer);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos);\n-        }\n-\n@@ -911,6 +846,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos,\n-                    MethodHandles.filterReturnValue(toAddress, MH_UNBOX_ADDRESS));\n-        }\n-\n@@ -947,5 +876,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_BOX_ADDRESS);\n-        }\n-\n@@ -972,0 +896,4 @@\n+        public long size() {\n+            return size;\n+        }\n+\n@@ -991,7 +919,0 @@\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            MethodHandle toSegmentHandle = insertArguments(MH_TO_SEGMENT, 1, size);\n-            specializedHandle = collectArguments(specializedHandle, insertPos, toSegmentHandle);\n-            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n-        }\n-\n@@ -1042,23 +963,0 @@\n-        \/*\n-         * Fixes up Y-shaped data graphs (produced by DEREFERENCE):\n-         *\n-         * 1. DUP()\n-         * 2. BUFFER_LOAD(0, int.class)\n-         * 3. VM_STORE  (ignored)\n-         * 4. BUFFER_LOAD(4, int.class)\n-         * 5. VM_STORE  (ignored)\n-         *\n-         * (specialized in reverse!)\n-         *\n-         * 5. (int, int) -> void                       insertPos = 1\n-         * 4. (MemorySegment, int) -> void             insertPos = 1\n-         * 3. (MemorySegment, int) -> void             insertPos = 0\n-         * 2. (MemorySegment, MemorySegment) -> void   insertPos = 0\n-         * 1. (MemorySegment) -> void                  insertPos = 0\n-         *\n-         *\/\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return SharedUtils.mergeArguments(specializedHandle, insertPos, insertPos + 1);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":7,"deletions":109,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,838 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.misc.VM;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.org.objectweb.asm.util.CheckClassAdapter;\n+import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.foreign.Addressable;\n+import java.lang.foreign.MemoryAddress;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ResourceScope;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+public class BindingSpecializer {\n+    private static final String DUMP_CLASSES_DIR\n+        = GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.DUMP_CLASSES_DIR\");\n+    private static final boolean PERFORM_VERIFICATION\n+        = GetBooleanAction.privilegedGetProperty(\"jdk.internal.foreign.abi.Specializer.PERFORM_VERIFICATION\");\n+\n+    \/\/ Bunch of helper constants\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+\n+    private static final String OBJECT_DESC = Object.class.descriptorString();\n+    private static final String OBJECT_INTRN = Type.getInternalName(Object.class);\n+\n+    private static final String BINDING_CONTEXT_DESC = Binding.Context.class.descriptorString();\n+    private static final String OF_BOUNDED_ALLOCATOR_DESC = methodType(Binding.Context.class, long.class).descriptorString();\n+    private static final String OF_SCOPE_DESC = methodType(Binding.Context.class).descriptorString();\n+    private static final String ALLOCATOR_DESC = methodType(SegmentAllocator.class).descriptorString();\n+    private static final String SCOPE_DESC = methodType(ResourceScope.class).descriptorString();\n+    private static final String CLOSE_DESC = methodType(void.class).descriptorString();\n+    private static final String ADDRESS_DESC = methodType(MemoryAddress.class).descriptorString();\n+    private static final String COPY_DESC = methodType(void.class, MemorySegment.class, long.class, MemorySegment.class, long.class, long.class).descriptorString();\n+    private static final String TO_RAW_LONG_VALUE_DESC = methodType(long.class).descriptorString();\n+    private static final String OF_LONG_DESC = methodType(MemoryAddress.class, long.class).descriptorString();\n+    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, ResourceScopeImpl.class).descriptorString();\n+    private static final String ALLOCATE_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n+    private static final String HANDLE_UNCAUGHT_EXCEPTION_DESC = methodType(void.class, Throwable.class).descriptorString();\n+    private static final String METHOD_HANDLES_INTRN = Type.getInternalName(MethodHandles.class);\n+    private static final String CLASS_DATA_DESC = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class).descriptorString();\n+\n+    private static final Handle BSM_CLASS_DATA = new Handle(\n+            H_INVOKESTATIC,\n+            METHOD_HANDLES_INTRN,\n+            \"classData\",\n+            CLASS_DATA_DESC,\n+            false);\n+    private static final ConstantDynamic CLASS_DATA_CONDY = new ConstantDynamic(\n+            ConstantDescs.DEFAULT_NAME,\n+            OBJECT_DESC,\n+            BSM_CLASS_DATA);\n+\n+    private static final String CLASS_NAME_DOWNCALL = \"jdk\/internal\/foreign\/abi\/DowncallStub\";\n+    private static final String CLASS_NAME_UPCALL = \"jdk\/internal\/foreign\/abi\/UpcallStub\";\n+    private static final String METHOD_NAME = \"invoke\";\n+\n+    private static final String SUPER_NAME = OBJECT_INTRN;\n+\n+    \/\/ Instance fields start here\n+    private final MethodVisitor mv;\n+    private final MethodType callerMethodType;\n+    private final CallingSequence callingSequence;\n+    private final ABIDescriptor abi;\n+    private final MethodType leafType;\n+\n+    private int localIdx = 0;\n+    private int[] paramIndex2ParamSlot;\n+    private int[] leafArgSlots;\n+    private int RETURN_ALLOCATOR_IDX = -1;\n+    private int CONTEXT_IDX = -1;\n+    private int RETURN_BUFFER_IDX = -1;\n+    private int RET_VAL_IDX = -1;\n+    private Deque<Class<?>> typeStack;\n+    private List<Class<?>> leafArgTypes;\n+    private int paramIndex;\n+    private long retBufOffset; \/\/ for needsReturnBuffer\n+\n+    private BindingSpecializer(MethodVisitor mv, MethodType callerMethodType, CallingSequence callingSequence, ABIDescriptor abi, MethodType leafType) {\n+        this.mv = mv;\n+        this.callerMethodType = callerMethodType;\n+        this.callingSequence = callingSequence;\n+        this.abi = abi;\n+        this.leafType = leafType;\n+    }\n+\n+    static MethodHandle specialize(MethodHandle leafHandle, CallingSequence callingSequence, ABIDescriptor abi) {\n+        String className = callingSequence.forDowncall() ? CLASS_NAME_DOWNCALL : CLASS_NAME_UPCALL;\n+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n+        cw.visit(CLASSFILE_VERSION, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, SUPER_NAME, null);\n+\n+        MethodType callerMethodType = callingSequence.callerMethodType();\n+        if (callingSequence.forDowncall()) {\n+            if (callingSequence.needsReturnBuffer()) {\n+                callerMethodType = callerMethodType.dropParameterTypes(0, 1); \/\/ Return buffer does not appear in the parameter list\n+            }\n+            callerMethodType = callerMethodType.insertParameterTypes(0, SegmentAllocator.class);\n+        }\n+        String descriptor = callerMethodType.descriptorString();\n+        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, METHOD_NAME, descriptor, null, null);\n+\n+        new BindingSpecializer(mv, callerMethodType, callingSequence, abi, leafHandle.type()).specialize();\n+\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+\n+        cw.visitEnd();\n+\n+        byte[] bytes = cw.toByteArray();\n+        if (DUMP_CLASSES_DIR != null) {\n+            String fileName = className + escapeForFileName(callingSequence.functionDesc().toString()) + \".class\";\n+            Path dumpPath = Path.of(DUMP_CLASSES_DIR).resolve(fileName);\n+            try {\n+                Files.createDirectories(dumpPath.getParent());\n+                Files.write(dumpPath, bytes);\n+            } catch (IOException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        if (PERFORM_VERIFICATION) {\n+            boolean printResults = false; \/\/ only print in case of exception\n+            CheckClassAdapter.verify(new ClassReader(bytes), null, printResults, new PrintWriter(System.err));\n+        }\n+\n+        try {\n+            \/\/ We must initialize the class since the upcall stubs don't have a clinit barrier, and the slow\n+            \/\/ path in the c2i adapter we end up calling can not handle the particular code shape where the\n+            \/\/ caller is an optimized upcall stub.\n+            boolean initialize = callingSequence.forUpcall();\n+            MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, initialize);\n+            return lookup.findStatic(lookup.lookupClass(), METHOD_NAME, callerMethodType);\n+        } catch (IllegalAccessException | NoSuchMethodException e) {\n+            throw new InternalError(\"Should not happen\", e);\n+        }\n+    }\n+\n+    private static String escapeForFileName(String str) {\n+        StringBuilder sb = new StringBuilder(str.length());\n+        for (int i = 0; i < str.length(); i++) {\n+            char c = str.charAt(i);\n+            sb.append(switch (c) {\n+                case ' ' -> '_';\n+                case '[', '<' -> '{';\n+                case ']', '>' -> '}';\n+                case '\/', '\\\\', ':', '*', '?', '\"', '|' -> '!'; \/\/ illegal in Windows file names.\n+                default -> c;\n+            });\n+        }\n+        return sb.toString();\n+    }\n+\n+    private void specialize() {\n+        \/\/ map of parameter indexes to local var table slots\n+        paramIndex2ParamSlot = new int[callerMethodType.parameterCount()];\n+        for (int i = 0; i < callerMethodType.parameterCount(); i++) {\n+            paramIndex2ParamSlot[i] = newLocal(callerMethodType.parameterType(i));\n+        }\n+\n+        \/\/ slots that store the output arguments (passed to the leaf handle)\n+        leafArgSlots = new int[leafType.parameterCount()];\n+        for (int i = 0; i < leafType.parameterCount(); i++) {\n+            leafArgSlots[i] = newLocal(leafType.parameterType(i));\n+        }\n+\n+        \/\/ allocator passed to us for allocating the return MS (downcalls only)\n+        if (callingSequence.forDowncall()) {\n+            RETURN_ALLOCATOR_IDX = 0; \/\/ first param\n+        }\n+\n+        \/\/ create a Binding.Context for this call\n+        if (callingSequence.allocationSize() != 0) {\n+            emitConst(callingSequence.allocationSize());\n+            emitInvokeStatic(Binding.Context.class, \"ofBoundedAllocator\", OF_BOUNDED_ALLOCATOR_DESC);\n+        } else if (callingSequence.forDowncall()) {\n+            emitGetStatic(Binding.Context.class, \"DUMMY\", BINDING_CONTEXT_DESC);\n+        } else {\n+            emitInvokeStatic(Binding.Context.class, \"ofScope\", OF_SCOPE_DESC);\n+        }\n+        CONTEXT_IDX = newLocal(BasicType.L);\n+        emitStore(BasicType.L, CONTEXT_IDX);\n+\n+        \/\/ in case the call needs a return buffer, allocate it here.\n+        \/\/ for upcalls the VM wrapper stub allocates the buffer.\n+        if (callingSequence.needsReturnBuffer() && callingSequence.forDowncall()) {\n+            emitLoadInternalAllocator();\n+            emitAllocateCall(callingSequence.returnBufferSize(), 1);\n+            RETURN_BUFFER_IDX = newLocal(BasicType.L);\n+            emitStore(BasicType.L, RETURN_BUFFER_IDX);\n+        }\n+\n+        Label tryStart = new Label();\n+        Label tryEnd = new Label();\n+        Label catchStart = new Label();\n+\n+        mv.visitLabel(tryStart);\n+\n+        \/\/ stack to keep track of types on the bytecode stack between bindings.\n+        \/\/ this is needed to e.g. emit the right DUP instruction,\n+        \/\/ but also used for type checking.\n+        typeStack = new ArrayDeque<>();\n+        \/\/ leaf arg types are the types of the args passed to the leaf handle.\n+        \/\/ these are collected from VM_STORE instructions for downcalls, and\n+        \/\/ recipe outputs for upcalls (see uses emitSetOutput for both)\n+        leafArgTypes = new ArrayList<>();\n+        paramIndex = callingSequence.forDowncall() ? 1 : 0; \/\/ +1 to skip SegmentAllocator\n+        for (int i = 0; i < callingSequence.argumentBindingsCount(); i++) {\n+            if (callingSequence.forDowncall()) {\n+                \/\/ for downcalls, recipes have an input value, which we set up here\n+                if (callingSequence.needsReturnBuffer() && i == 0) {\n+                    assert RETURN_BUFFER_IDX != -1;\n+                    emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                    typeStack.push(MemorySegment.class);\n+                } else {\n+                    emitGetInput();\n+                }\n+            }\n+\n+            \/\/ emit code according to binding recipe\n+            doBindings(callingSequence.argumentBindings(i));\n+\n+            if (callingSequence.forUpcall()) {\n+                \/\/ for upcalls, recipes have a result, which we handle here\n+                if (callingSequence.needsReturnBuffer() && i == 0) {\n+                    \/\/ return buffer ptr is wrapped in a MemorySegment above, but not passed to the leaf handle\n+                    assert typeStack.pop() == MemorySegment.class;\n+                    RETURN_BUFFER_IDX = newLocal(BasicType.L);\n+                    emitStore(BasicType.L, RETURN_BUFFER_IDX);\n+                } else {\n+                    \/\/ for upcalls the recipe result is an argument to the leaf handle\n+                    emitSetOutput(typeStack.pop());\n+                }\n+            }\n+            assert typeStack.isEmpty();\n+        }\n+\n+        assert leafArgTypes.equals(leafType.parameterList());\n+\n+        \/\/ load the leaf MethodHandle\n+        mv.visitLdcInsn(CLASS_DATA_CONDY);\n+        emitCheckCast(MethodHandle.class);\n+        \/\/ load all the leaf args\n+        for (int i = 0; i < leafArgSlots.length; i++) {\n+            emitLoad(leafArgTypes.get(i), leafArgSlots[i]);\n+        }\n+        \/\/ call leaf MH\n+        emitInvokeVirtual(MethodHandle.class, \"invokeExact\", leafType.descriptorString());\n+\n+        \/\/ for downcalls, store the result of the leaf handle call away, until\n+        \/\/ it is requested by a VM_LOAD in the return recipe.\n+        if (callingSequence.forDowncall() && leafType.returnType() != void.class) {\n+            emitSaveReturnValue(leafType.returnType());\n+        }\n+        \/\/ for upcalls we leave the return value on the stack to be picked up\n+        \/\/ as an input of the return recipe.\n+\n+        \/\/ return value processing\n+        if (callingSequence.hasReturnBindings()) {\n+            if (callingSequence.forUpcall()) {\n+                typeStack.push(leafType.returnType());\n+            }\n+\n+            retBufOffset = 0; \/\/ offset for reading from return buffer\n+            doBindings(callingSequence.returnBindings());\n+\n+            if (callingSequence.forUpcall() && !callingSequence.needsReturnBuffer()) {\n+                \/\/ was VM_STOREd somewhere in the bindings\n+                emitRestoreReturnValue(callerMethodType.returnType());\n+            }\n+            mv.visitLabel(tryEnd);\n+            \/\/ finally\n+            emitCloseContext();\n+\n+            if (callerMethodType.returnType() == void.class) {\n+                \/\/ The case for upcalls that return by return buffer\n+                assert typeStack.isEmpty();\n+                mv.visitInsn(RETURN);\n+            } else {\n+                assert typeStack.pop() == callerMethodType.returnType();\n+                assert typeStack.isEmpty();\n+                emitReturn(callerMethodType.returnType());\n+            }\n+        } else {\n+            assert callerMethodType.returnType() == void.class;\n+            assert typeStack.isEmpty();\n+            mv.visitLabel(tryEnd);\n+            \/\/ finally\n+            emitCloseContext();\n+            mv.visitInsn(RETURN);\n+        }\n+\n+        mv.visitLabel(catchStart);\n+        \/\/ finally\n+        emitCloseContext();\n+        if (callingSequence.forDowncall()) {\n+            mv.visitInsn(ATHROW);\n+        } else {\n+           emitInvokeStatic(SharedUtils.class, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n+           if (callerMethodType.returnType() != void.class) {\n+               emitConstZero(callerMethodType.returnType());\n+               emitReturn(callerMethodType.returnType());\n+           } else {\n+               mv.visitInsn(RETURN);\n+           }\n+        }\n+\n+        mv.visitTryCatchBlock(tryStart, tryEnd, catchStart, null);\n+    }\n+\n+    private void doBindings(List<Binding> bindings) {\n+        for (Binding binding : bindings) {\n+            switch (binding.tag()) {\n+                case VM_STORE -> emitVMStore((Binding.VMStore) binding);\n+                case VM_LOAD -> emitVMLoad((Binding.VMLoad) binding);\n+                case BUFFER_STORE -> emitBufferStore((Binding.BufferStore) binding);\n+                case BUFFER_LOAD -> emitBufferLoad((Binding.BufferLoad) binding);\n+                case COPY_BUFFER -> emitCopyBuffer((Binding.Copy) binding);\n+                case ALLOC_BUFFER -> emitAllocBuffer((Binding.Allocate) binding);\n+                case BOX_ADDRESS -> emitBoxAddress();\n+                case UNBOX_ADDRESS -> emitUnboxAddress();\n+                case TO_SEGMENT -> emitToSegment((Binding.ToSegment) binding);\n+                case DUP -> emitDupBinding();\n+            }\n+        }\n+    }\n+\n+    private void emitSetOutput(Class<?> storeType) {\n+        emitStore(BasicType.of(storeType), leafArgSlots[leafArgTypes.size()]);\n+        leafArgTypes.add(storeType);\n+    }\n+\n+    private void emitGetInput() {\n+        Class<?> highLevelType = callerMethodType.parameterType(paramIndex);\n+        emitLoad(BasicType.of(highLevelType), paramIndex2ParamSlot[paramIndex]);\n+        typeStack.push(highLevelType);\n+        paramIndex++;\n+    }\n+\n+    private void emitSaveReturnValue(Class<?> storeType) {\n+        RET_VAL_IDX = newLocal(BasicType.of(storeType));\n+        emitStore(BasicType.of(storeType), RET_VAL_IDX);\n+    }\n+\n+    private void emitRestoreReturnValue(Class<?> loadType) {\n+        assert RET_VAL_IDX != -1;\n+        emitLoad(BasicType.of(loadType), RET_VAL_IDX);\n+        typeStack.push(loadType);\n+    }\n+\n+    private int newLocal(Class<?> type) {\n+        return newLocal(BasicType.of(type));\n+    }\n+\n+    private int newLocal(BasicType type) {\n+        int idx = localIdx;\n+        localIdx += (type == BasicType.D || type == BasicType.J) ? 2 : 1;\n+        return idx;\n+    }\n+\n+    private void emitLoadInternalScope() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(Binding.Context.class, \"scope\", SCOPE_DESC);\n+    }\n+\n+    private void emitLoadInternalAllocator() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(Binding.Context.class, \"allocator\", ALLOCATOR_DESC);\n+    }\n+\n+    private void emitCloseContext() {\n+        assert CONTEXT_IDX != -1;\n+        emitLoad(BasicType.L, CONTEXT_IDX);\n+        emitInvokeVirtual(Binding.Context.class, \"close\", CLOSE_DESC);\n+    }\n+\n+    private void emitToSegment(Binding.ToSegment binding) {\n+        long size = binding.size();\n+        assert typeStack.pop() == MemoryAddress.class;\n+\n+        emitToRawLongValue();\n+        emitConst(size);\n+        emitLoadInternalScope();\n+        emitCheckCast(ResourceScopeImpl.class);\n+        emitInvokeStatic(MemoryAddressImpl.class, \"ofLongUnchecked\", OF_LONG_UNCHECKED_DESC);\n+\n+        typeStack.push(MemorySegment.class);\n+    }\n+\n+    private void emitToRawLongValue() {\n+        emitInvokeInterface(MemoryAddress.class, \"toRawLongValue\", TO_RAW_LONG_VALUE_DESC);\n+    }\n+\n+    private void emitBoxAddress() {\n+        assert typeStack.pop() == long.class;\n+        emitInvokeStatic(MemoryAddress.class, \"ofLong\", OF_LONG_DESC);\n+        typeStack.push(MemoryAddress.class);\n+    }\n+\n+    private void emitAllocBuffer(Binding.Allocate binding) {\n+        if (callingSequence.forDowncall()) {\n+            assert RETURN_ALLOCATOR_IDX != -1;\n+            emitLoad(BasicType.L, RETURN_ALLOCATOR_IDX);\n+        } else {\n+            emitLoadInternalAllocator();\n+        }\n+        emitAllocateCall(binding.size(), binding.alignment());\n+        typeStack.push(MemorySegment.class);\n+    }\n+\n+    private void emitBufferStore(Binding.BufferStore bufferStore) {\n+        Class<?> storeType = bufferStore.type();\n+        long offset = bufferStore.offset();\n+\n+        assert typeStack.pop() == storeType;\n+        assert typeStack.pop() == MemorySegment.class;\n+        BasicType basicStoreType = BasicType.of(storeType);\n+        int valueIdx = newLocal(basicStoreType);\n+        emitStore(basicStoreType, valueIdx);\n+\n+        Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n+        emitConst(offset);\n+        emitLoad(basicStoreType, valueIdx);\n+        String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n+        emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+    }\n+\n+\n+    \/\/ VM_STORE and VM_LOAD are emulated, which is different for down\/upcalls\n+    private void emitVMStore(Binding.VMStore vmStore) {\n+        Class<?> storeType = vmStore.type();\n+        assert typeStack.pop() == storeType;\n+\n+        if (callingSequence.forDowncall()) {\n+            \/\/ processing arg\n+            emitSetOutput(storeType);\n+        } else {\n+            \/\/ processing return\n+            if (!callingSequence.needsReturnBuffer()) {\n+                emitSaveReturnValue(storeType);\n+            } else {\n+                BasicType basicStoreType = BasicType.of(storeType);\n+                int valueIdx = newLocal(basicStoreType);\n+                emitStore(basicStoreType, valueIdx); \/\/ store away the stored value, need it later\n+\n+                assert RETURN_BUFFER_IDX != -1;\n+                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(storeType);\n+                emitConst(retBufOffset);\n+                emitLoad(basicStoreType, valueIdx);\n+                String descriptor = methodType(void.class, valueLayoutType, long.class, storeType).descriptorString();\n+                emitInvokeInterface(MemorySegment.class, \"set\", descriptor);\n+                retBufOffset += abi.arch.typeSize(vmStore.storage().type());\n+            }\n+        }\n+    }\n+\n+    private void emitVMLoad(Binding.VMLoad vmLoad) {\n+        Class<?> loadType = vmLoad.type();\n+\n+        if (callingSequence.forDowncall()) {\n+            \/\/ processing return\n+            if (!callingSequence.needsReturnBuffer()) {\n+                emitRestoreReturnValue(loadType);\n+            } else {\n+                assert RETURN_BUFFER_IDX != -1;\n+                emitLoad(BasicType.L, RETURN_BUFFER_IDX);\n+                Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n+                emitConst(retBufOffset);\n+                String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n+                emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+                retBufOffset += abi.arch.typeSize(vmLoad.storage().type());\n+                typeStack.push(loadType);\n+            }\n+        } else {\n+            \/\/ processing arg\n+            emitGetInput();\n+        }\n+    }\n+    private void emitDupBinding() {\n+        Class<?> dupType = typeStack.peek();\n+        emitDup(BasicType.of(dupType));\n+        typeStack.push(dupType);\n+    }\n+\n+    private void emitUnboxAddress() {\n+        assert Addressable.class.isAssignableFrom(typeStack.pop());\n+        emitInvokeInterface(Addressable.class, \"address\", ADDRESS_DESC);\n+        emitToRawLongValue();\n+        typeStack.push(long.class);\n+    }\n+\n+    private void emitBufferLoad(Binding.BufferLoad bufferLoad) {\n+        Class<?> loadType = bufferLoad.type();\n+        long offset = bufferLoad.offset();\n+\n+        assert typeStack.pop() == MemorySegment.class;\n+\n+        Class<?> valueLayoutType = emitLoadLayoutConstant(loadType);\n+        emitConst(offset);\n+        String descriptor = methodType(loadType, valueLayoutType, long.class).descriptorString();\n+        emitInvokeInterface(MemorySegment.class, \"get\", descriptor);\n+        typeStack.push(loadType);\n+    }\n+\n+    private void emitCopyBuffer(Binding.Copy copy) {\n+        long size = copy.size();\n+        long alignment = copy.alignment();\n+\n+        assert typeStack.pop() == MemorySegment.class;\n+\n+        \/\/ operand\/srcSegment is on the stack\n+        \/\/ generating a call to:\n+        \/\/   MemorySegment::copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes)\n+        emitConst(0L);\n+        \/\/ create the dstSegment by allocating it. Similar to:\n+        \/\/   context.allocator().allocate(size, alignment)\n+        emitLoadInternalAllocator();\n+        emitAllocateCall(size, alignment);\n+        emitDup(BasicType.L);\n+        int storeIdx = newLocal(BasicType.L);\n+        emitStore(BasicType.L, storeIdx);\n+        emitConst(0L);\n+        emitConst(size);\n+        emitInvokeStatic(MemorySegment.class, \"copy\", COPY_DESC);\n+\n+        emitLoad(BasicType.L, storeIdx);\n+        typeStack.push(MemorySegment.class);\n+    }\n+\n+    private void emitAllocateCall(long size, long alignment) {\n+        emitConst(size);\n+        emitConst(alignment);\n+        emitInvokeInterface(SegmentAllocator.class, \"allocate\", ALLOCATE_DESC);\n+    }\n+\n+    private Class<?> emitLoadLayoutConstant(Class<?> type) {\n+        Class<?> valueLayoutType = valueLayoutTypeFor(type);\n+        String valueLayoutConstantName = valueLayoutConstantFor(type);\n+        emitGetStatic(ValueLayout.class, valueLayoutConstantName, valueLayoutType.descriptorString());\n+        return valueLayoutType;\n+    }\n+\n+    private static String valueLayoutConstantFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return \"JAVA_BOOLEAN\";\n+        } else if (type == byte.class) {\n+            return \"JAVA_BYTE\";\n+        } else if (type == short.class) {\n+            return \"JAVA_SHORT\";\n+        } else if (type == char.class) {\n+            return \"JAVA_CHAR\";\n+        } else if (type == int.class) {\n+            return \"JAVA_INT\";\n+        } else if (type == long.class) {\n+            return \"JAVA_LONG\";\n+        } else if (type == float.class) {\n+            return \"JAVA_FLOAT\";\n+        } else if (type == double.class) {\n+            return \"JAVA_DOUBLE\";\n+        } else if (type == MemoryAddress.class) {\n+            return \"ADDRESS\";\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n+    private static Class<?> valueLayoutTypeFor(Class<?> type) {\n+        if (type == boolean.class) {\n+            return ValueLayout.OfBoolean.class;\n+        } else if (type == byte.class) {\n+            return ValueLayout.OfByte.class;\n+        } else if (type == short.class) {\n+            return ValueLayout.OfShort.class;\n+        } else if (type == char.class) {\n+            return ValueLayout.OfChar.class;\n+        } else if (type == int.class) {\n+            return ValueLayout.OfInt.class;\n+        } else if (type == long.class) {\n+            return ValueLayout.OfLong.class;\n+        } else if (type == float.class) {\n+            return ValueLayout.OfFloat.class;\n+        } else if (type == double.class) {\n+            return ValueLayout.OfDouble.class;\n+        } else if (type == MemoryAddress.class) {\n+            return ValueLayout.OfAddress.class;\n+        } else {\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+        }\n+    }\n+\n+    private void emitInvokeStatic(Class<?> owner, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKESTATIC, Type.getInternalName(owner), methodName, descriptor, owner.isInterface());\n+    }\n+\n+    private void emitInvokeInterface(Class<?> owner, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKEINTERFACE, Type.getInternalName(owner), methodName, descriptor, true);\n+    }\n+\n+    private void emitInvokeVirtual(Class<?> owner, String methodName, String descriptor) {\n+        mv.visitMethodInsn(INVOKEVIRTUAL, Type.getInternalName(owner), methodName, descriptor, false);\n+    }\n+\n+    private void emitGetStatic(Class<?> owner, String fieldName, String descriptor) {\n+        mv.visitFieldInsn(GETSTATIC, Type.getInternalName(owner), fieldName, descriptor);\n+    }\n+\n+    private void emitCheckCast(Class<?> cls) {\n+        mv.visitTypeInsn(CHECKCAST, Type.getInternalName(cls));\n+    }\n+\n+    private void emitDup(BasicType type) {\n+        if (type == BasicType.D || type == BasicType.J) {\n+            mv.visitInsn(DUP2);\n+        } else {\n+            mv.visitInsn(Opcodes.DUP);\n+        }\n+    }\n+\n+    \/*\n+     * Low-level emit helpers.\n+     *\/\n+\n+    private void emitConstZero(Class<?> type) {\n+        emitConst(switch (BasicType.of(type)) {\n+            case Z, B, S, C, I -> 0;\n+            case J -> 0L;\n+            case F -> 0F;\n+            case D -> 0D;\n+            case L -> null;\n+        });\n+    }\n+\n+    private void emitConst(Object con) {\n+        if (con == null) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+            return;\n+        }\n+        if (con instanceof Integer) {\n+            emitIconstInsn((int) con);\n+            return;\n+        }\n+        if (con instanceof Byte) {\n+            emitIconstInsn((byte)con);\n+            return;\n+        }\n+        if (con instanceof Short) {\n+            emitIconstInsn((short)con);\n+            return;\n+        }\n+        if (con instanceof Character) {\n+            emitIconstInsn((char)con);\n+            return;\n+        }\n+        if (con instanceof Long) {\n+            long x = (long) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.LCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2L);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Float) {\n+            float x = (float) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 2) {\n+                    mv.visitInsn(Opcodes.FCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2F);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Double) {\n+            double x = (double) con;\n+            short sx = (short)x;\n+            if (x == sx) {\n+                if (sx >= 0 && sx <= 1) {\n+                    mv.visitInsn(Opcodes.DCONST_0 + (int) sx);\n+                } else {\n+                    emitIconstInsn((int) x);\n+                    mv.visitInsn(Opcodes.I2D);\n+                }\n+                return;\n+            }\n+        }\n+        if (con instanceof Boolean) {\n+            emitIconstInsn((boolean) con ? 1 : 0);\n+            return;\n+        }\n+        \/\/ fall through:\n+        mv.visitLdcInsn(con);\n+    }\n+\n+    private void emitIconstInsn(int cst) {\n+        if (cst >= -1 && cst <= 5) {\n+            mv.visitInsn(Opcodes.ICONST_0 + cst);\n+        } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.BIPUSH, cst);\n+        } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n+            mv.visitIntInsn(Opcodes.SIPUSH, cst);\n+        } else {\n+            mv.visitLdcInsn(cst);\n+        }\n+    }\n+\n+    private void emitLoad(Class<?> type, int index) {\n+        emitLoad(BasicType.of(type), index);\n+    }\n+\n+    private void emitLoad(BasicType type, int index) {\n+        int opcode = loadOpcode(type);\n+        mv.visitVarInsn(opcode, index);\n+    }\n+\n+    private static int loadOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case Z, B, S, C, I -> ILOAD;\n+            case J -> LLOAD;\n+            case F -> FLOAD;\n+            case D -> DLOAD;\n+            case L -> ALOAD;\n+        };\n+    }\n+\n+    private void emitStore(BasicType type, int index) {\n+        int opcode = storeOpcode(type);\n+        mv.visitVarInsn(opcode, index);\n+    }\n+\n+    private static int storeOpcode(BasicType type) throws InternalError {\n+        return switch (type) {\n+            case Z, B, S, C, I -> ISTORE;\n+            case J -> LSTORE;\n+            case F -> FSTORE;\n+            case D -> DSTORE;\n+            case L -> ASTORE;\n+        };\n+    }\n+\n+    private void emitReturn(Class<?> type) {\n+        int opcode = returnOpcode(BasicType.of(type));\n+        mv.visitInsn(opcode);\n+    }\n+\n+    private static int returnOpcode(BasicType type) {\n+       return switch (type) {\n+            case Z, B, S, C, I -> IRETURN;\n+            case J -> LRETURN;\n+            case F -> FRETURN;\n+            case D -> DRETURN;\n+            case L -> ARETURN;\n+        };\n+    }\n+\n+    private enum BasicType {\n+        Z, B, S, C, I, J, F, D, L;\n+\n+        static BasicType of(Class<?> cls) {\n+            if (cls == boolean.class) {\n+                return Z;\n+            } else if (cls == byte.class) {\n+                return B;\n+            } else if (cls == short.class) {\n+                return S;\n+            } else if (cls == char.class) {\n+                return C;\n+            } else if (cls == int.class) {\n+                return I;\n+            } else if (cls == long.class) {\n+                return J;\n+            } else if (cls == float.class) {\n+                return F;\n+            } else if (cls == double.class) {\n+                return D;\n+            } else {\n+                return L;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":838,"deletions":0,"binary":false,"changes":838,"status":"added"},{"patch":"@@ -33,1 +33,3 @@\n-    private final MethodType mt;\n+    private final boolean forUpcall;\n+    private final MethodType callerMethodType;\n+    private final MethodType calleeMethodType;\n@@ -42,1 +44,1 @@\n-    public CallingSequence(MethodType mt, FunctionDescriptor desc,\n+    public CallingSequence(boolean forUpcall, MethodType callerMethodType, MethodType calleeMethodType, FunctionDescriptor desc,\n@@ -45,1 +47,3 @@\n-        this.mt = mt;\n+        this.forUpcall = forUpcall;\n+        this.callerMethodType = callerMethodType;\n+        this.calleeMethodType = calleeMethodType;\n@@ -54,1 +58,15 @@\n-    public int argumentCount() {\n+    \/**\n+     * An important distinction is that downcalls have 1 recipe per caller parameter and\n+     * each callee parameter corresponds to a VM_STORE. Upcalls have 1 recipe per callee parameter and\n+     * each caller parameter corresponds to a VM_LOAD.\n+     *\n+     * The VM_STOREs are then implemented by the leaf handle for downcalls, and vice versa, the wrapper\n+     * stub that wraps an upcall handle implements the VM_LOADS. In both cases the register values are\n+     * communicated through Java primitives.\n+     *\n+     * The 'argumentBindingsCount' below corresponds to the number of recipes, so it is the\n+     * caller parameter count for downcalls, and the callee parameter count for upcalls.\n+     *\n+     * @return the number of binding recipes in this calling sequence\n+     *\/\n+    public int argumentBindingsCount() {\n@@ -70,2 +88,3 @@\n-    public String asString() {\n-        StringBuilder sb = new StringBuilder();\n+    public boolean forUpcall() {\n+        return forUpcall;\n+    }\n@@ -73,11 +92,3 @@\n-        sb.append(\"CallingSequence: {\\n\");\n-        sb.append(\"  MethodType: \").append(mt);\n-        sb.append(\"  FunctionDescriptor: \").append(desc);\n-        sb.append(\"  Argument Bindings:\\n\");\n-        for (int i = 0; i < mt.parameterCount(); i++) {\n-            sb.append(\"    \").append(i).append(\": \").append(argumentBindings.get(i)).append(\"\\n\");\n-        }\n-        if (mt.returnType() != void.class) {\n-            sb.append(\"    \").append(\"Return: \").append(returnBindings).append(\"\\n\");\n-        }\n-        sb.append(\"}\\n\");\n+    public boolean forDowncall() {\n+        return !forUpcall;\n+    }\n@@ -85,1 +96,14 @@\n-        return sb.toString();\n+    \/**\n+     * Returns the caller method type, which is the high-level method type\n+     * for downcalls (the type of the downcall method handle)\n+     * and the low-level method type (all primitives, VM facing) for upcalls.\n+     *\n+     * Note that for downcalls a single parameter in this method type corresponds\n+     * to a single argument binding recipe in this calling sequence, but it may\n+     * correspond to multiple parameters in the callee method type (for instance\n+     * if a struct is split into multiple register values).\n+     *\n+     * @return the caller method type.\n+     *\/\n+    public MethodType callerMethodType() {\n+        return callerMethodType;\n@@ -88,2 +112,14 @@\n-    public MethodType methodType() {\n-        return mt;\n+    \/**\n+     * Returns the callee method type, which is the low-level method type\n+     * (all primitives, VM facing) for downcalls and the high-level method type\n+     * for upcalls (also the method type of the user-supplied target MH).\n+     *\n+     * Note that for upcalls a single parameter in this method type corresponds\n+     * to a single argument binding recipe in this calling sequence, but it may\n+     * correspond to multiple parameters in the caller method type (for instance\n+     * if a struct is reconstructed from multiple register values).\n+     *\n+     * @return the callee method type.\n+     *\/\n+    public MethodType calleeMethodType() {\n+        return calleeMethodType;\n@@ -96,0 +132,21 @@\n+    \/**\n+     * Whether this calling sequence needs a return buffer.\n+     *\n+     * A return buffer is used to support functions that  return values\n+     * in multiple registers, which is not possible to do just with Java primitives\n+     * (we can only return 1 value in Java, meaning only 1 register value).\n+     *\n+     * To emulate these multi-register returns, we instead use a pre-allocated buffer\n+     * (the return buffer) from\/into which the return values are loaded\/stored.\n+     *\n+     * For downcalls, we allocate the buffer in Java code, and pass the address down\n+     * to the VM stub, which stores the returned register values into this buffer.\n+     * VM_LOADs in the binding recipe for the return value then load the value from this buffer.\n+     *\n+     * For upcalls, the VM stub allocates a buffer (on the stack), and passes the address\n+     * to the Java method handle it calls. VM_STOREs in the return binding recipe then\n+     * store values into this buffer, after which the VM stub moves the values from the buffer\n+     * into the right register.\n+     *\n+     * @return whether this calling sequence needs a return buffer.\n+     *\/\n@@ -100,0 +157,7 @@\n+    \/**\n+     * The size of the return buffer, if one is needed.\n+     *\n+     * {@see #needsReturnBuffer}\n+     *\n+     * @return the return buffer size\n+     *\/\n@@ -104,0 +168,7 @@\n+    \/**\n+     * The amount of bytes this calling sequence needs to allocate during an invocation.\n+     *\n+     * Includes the return buffer size as well as space for any buffer copies in the recipes.\n+     *\n+     * @return the allocation size\n+     *\/\n@@ -107,0 +178,23 @@\n+\n+    public boolean hasReturnBindings() {\n+        return !returnBindings.isEmpty();\n+    }\n+\n+    public String asString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(\"CallingSequence: {\\n\");\n+        sb.append(\"  callerMethodType: \").append(callerMethodType);\n+        sb.append(\"  calleeMethodType: \").append(calleeMethodType);\n+        sb.append(\"  FunctionDescriptor: \").append(desc);\n+        sb.append(\"  Argument Bindings:\\n\");\n+        for (int i = 0; i < argumentBindingsCount(); i++) {\n+            sb.append(\"    \").append(i).append(\": \").append(argumentBindings.get(i)).append(\"\\n\");\n+        }\n+        if (!returnBindings.isEmpty()) {\n+            sb.append(\"    \").append(\"Return: \").append(returnBindings).append(\"\\n\");\n+        }\n+        sb.append(\"}\\n\");\n+\n+        return sb.toString();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":114,"deletions":20,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -93,0 +94,2 @@\n+        MethodType callerMethodType;\n+        MethodType calleeMethodType;\n@@ -102,5 +105,13 @@\n-        } else if (needsReturnBuffer) { \/\/ forUpcall == true\n-            addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n-                Binding.vmLoad(abi.retBufAddrStorage(), long.class),\n-                Binding.boxAddress(),\n-                Binding.toSegment(returnBufferSize)));\n+\n+            callerMethodType = mt;\n+            calleeMethodType = computeCalleeTypeForDowncall();\n+        } else { \/\/ forUpcall == true\n+            if (needsReturnBuffer) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                        Binding.vmLoad(abi.retBufAddrStorage(), long.class),\n+                        Binding.boxAddress(),\n+                        Binding.toSegment(returnBufferSize)));\n+            }\n+\n+            callerMethodType = computeCallerTypeForUpcall();\n+            calleeMethodType = mt;\n@@ -108,1 +119,28 @@\n-        return new CallingSequence(mt, desc, needsReturnBuffer, returnBufferSize, allocationSize, inputBindings, outputBindings);\n+        return new CallingSequence(forUpcall, callerMethodType, calleeMethodType, desc, needsReturnBuffer,\n+                returnBufferSize, allocationSize, inputBindings, outputBindings);\n+    }\n+\n+    private MethodType computeCallerTypeForUpcall() {\n+        return computeTypeHelper(Binding.VMLoad.class, Binding.VMStore.class);\n+    }\n+\n+    private MethodType computeCalleeTypeForDowncall() {\n+        return computeTypeHelper(Binding.VMStore.class, Binding.VMLoad.class);\n+    }\n+\n+    private MethodType computeTypeHelper(Class<? extends Binding.Move> inputVMClass,\n+                                         Class<? extends Binding.Move> outputVMClass) {\n+        Class<?>[] paramTypes = inputBindings.stream()\n+                .flatMap(List::stream)\n+                .filter(inputVMClass::isInstance)\n+                .map(inputVMClass::cast)\n+                .map(Binding.Move::type)\n+                .toArray(Class<?>[]::new);\n+\n+        Binding.Move[] retMoves = outputBindings.stream()\n+                .filter(outputVMClass::isInstance)\n+                .map(outputVMClass::cast)\n+                .toArray(Binding.Move[]::new);\n+        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n+\n+        return methodType(returnType, paramTypes);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -27,1 +27,6 @@\n-import java.lang.foreign.MemoryLayout;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.invoke.NativeEntryPoint;\n+import jdk.internal.invoke.VMStorageProxy;\n+import sun.security.action.GetPropertyAction;\n+\n@@ -31,1 +36,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -35,2 +39,0 @@\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n@@ -38,1 +40,0 @@\n-import java.util.List;\n@@ -41,5 +42,0 @@\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.invoke.NativeEntryPoint;\n-import jdk.internal.invoke.VMStorageProxy;\n-import sun.security.action.GetPropertyAction;\n@@ -47,1 +43,0 @@\n-import static java.lang.invoke.MethodHandles.dropArguments;\n@@ -65,2 +60,1 @@\n-    private static final MethodHandle MH_WRAP_ALLOCATOR;\n-    private static final MethodHandle MH_ALLOCATE_RETURN_BUFFER;\n+\n@@ -76,4 +70,0 @@\n-            MH_WRAP_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofAllocator\",\n-                    methodType(Binding.Context.class, SegmentAllocator.class));\n-            MH_ALLOCATE_RETURN_BUFFER = lookup.findStatic(ProgrammableInvoker.class, \"allocateReturnBuffer\",\n-                    methodType(MemorySegment.class, Binding.Context.class, long.class));\n@@ -92,0 +82,1 @@\n+        assert callingSequence.forDowncall();\n@@ -97,2 +88,0 @@\n-        Class<?>[] argMoveTypes = Arrays.stream(argMoves).map(Binding.VMStore::type).toArray(Class<?>[]::new);\n-\n@@ -100,1 +89,0 @@\n-        Class<?> returnType = retMoves.length == 1 ? retMoves[0].type() : void.class;\n@@ -102,1 +90,1 @@\n-        MethodType leafType = methodType(returnType, argMoveTypes);\n+        MethodType leafType = callingSequence.calleeMethodType();\n@@ -114,1 +102,1 @@\n-            handle = specialize(handle);\n+            handle = BindingSpecializer.specialize(handle, callingSequence, abi);\n@@ -121,1 +109,1 @@\n-            MethodType interpType = callingSequence.methodType();\n+            MethodType interpType = callingSequence.callerMethodType();\n@@ -141,4 +129,0 @@\n-    private static MemorySegment allocateReturnBuffer(Binding.Context context, long size) {\n-        return context.allocator().allocate(size);\n-    }\n-\n@@ -174,91 +158,0 @@\n-    private MethodHandle specialize(MethodHandle leafHandle) {\n-        MethodType highLevelType = callingSequence.methodType();\n-\n-        int argInsertPos = 0;\n-        int argContextPos = 0;\n-\n-        MethodHandle specializedHandle = dropArguments(leafHandle, argContextPos, Binding.Context.class);\n-        for (int i = 0; i < highLevelType.parameterCount(); i++) {\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            argInsertPos += bindings.stream().filter(Binding.VMStore.class::isInstance).count() + 1;\n-            \/\/ We interpret the bindings in reverse since we have to construct a MethodHandle from the bottom up\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                if (binding.tag() == Binding.Tag.VM_STORE) {\n-                    argInsertPos--;\n-                } else {\n-                    specializedHandle = binding.specialize(specializedHandle, argInsertPos, argContextPos);\n-                }\n-            }\n-        }\n-\n-        if (highLevelType.returnType() != void.class) {\n-            MethodHandle returnFilter = identity(highLevelType.returnType());\n-            int retBufPos = -1;\n-            long retBufReadOffset = -1;\n-            int retContextPos = 0;\n-            int retInsertPos = 1;\n-            if (callingSequence.needsReturnBuffer()) {\n-                retBufPos = 0;\n-                retBufReadOffset = callingSequence.returnBufferSize();\n-                retContextPos++;\n-                retInsertPos++;\n-                returnFilter = dropArguments(returnFilter, retBufPos, MemorySegment.class);\n-            }\n-            returnFilter = dropArguments(returnFilter, retContextPos, Binding.Context.class);\n-            List<Binding> bindings = callingSequence.returnBindings();\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_LOAD) {\n-                    \/\/ spacial case this, since we need to update retBufReadOffset as well\n-                    Binding.VMLoad load = (Binding.VMLoad) binding;\n-                    ValueLayout layout = MemoryLayout.valueLayout(load.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n-                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n-                    retBufReadOffset -= abi.arch.typeSize(load.storage().type());\n-                    MethodHandle loadHandle = MethodHandles.insertCoordinates(MethodHandles.memoryAccessVarHandle(layout), 1, retBufReadOffset)\n-                            .toMethodHandle(VarHandle.AccessMode.GET);\n-\n-                    returnFilter = MethodHandles.collectArguments(returnFilter, retInsertPos, loadHandle);\n-                    assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n-                    assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n-                    returnFilter = SharedUtils.mergeArguments(returnFilter, retBufPos, retInsertPos);\n-                    \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n-                    \/\/ from (... MemorySegment, MemorySegment, ...)\n-                    retInsertPos -= 2; \/\/ set insert pos back to the first MS (later DUP binding will merge the 2 MS)\n-                } else {\n-                    returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n-                    if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.BUFFER_STORE) {\n-                        \/\/ from (... MemorySegment, ...)\n-                        \/\/ to (... MemorySegment, MemorySegment, <primitive>, ...)\n-                        retInsertPos += 2; \/\/ set insert pos to <primitive>\n-                        assert returnFilter.type().parameterType(retInsertPos - 1) == MemorySegment.class;\n-                        assert returnFilter.type().parameterType(retInsertPos - 2) == MemorySegment.class;\n-                    }\n-                }\n-            }\n-            \/\/ (R, Context (ret)) -> (MemorySegment?, Context (ret), MemorySegment?, Context (arg), ...)\n-            specializedHandle = MethodHandles.collectArguments(returnFilter, retInsertPos, specializedHandle);\n-            if (callingSequence.needsReturnBuffer()) {\n-                \/\/ (MemorySegment, Context (ret), Context (arg), MemorySegment,  ...) -> (MemorySegment, Context (ret), Context (arg), ...)\n-                specializedHandle = SharedUtils.mergeArguments(specializedHandle, retBufPos, retBufPos + 3);\n-\n-                \/\/ allocate the return buffer from the binding context, and then merge the 2 allocator args\n-                MethodHandle retBufAllocHandle = MethodHandles.insertArguments(MH_ALLOCATE_RETURN_BUFFER, 1, callingSequence.returnBufferSize());\n-                \/\/ (MemorySegment, Context (ret), Context (arg), ...) -> (Context (arg), Context (ret), Context (arg), ...)\n-                specializedHandle = MethodHandles.filterArguments(specializedHandle, retBufPos, retBufAllocHandle);\n-                \/\/ (Context (arg), Context (ret), Context (arg), ...) -> (Context (ret), Context (arg), ...)\n-                specializedHandle = SharedUtils.mergeArguments(specializedHandle, argContextPos + 1, retBufPos); \/\/ +1 to skip return context\n-            }\n-            \/\/ (Context (ret), Context (arg), ...) -> (SegmentAllocator, Context (arg), ...)\n-            specializedHandle = MethodHandles.filterArguments(specializedHandle, 0, MH_WRAP_ALLOCATOR);\n-        } else {\n-            specializedHandle = MethodHandles.dropArguments(specializedHandle, 0, SegmentAllocator.class);\n-        }\n-\n-        \/\/ now bind the internal context parameter\n-\n-        argContextPos++; \/\/ skip over the return SegmentAllocator (inserted by the above code)\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, callingSequence.allocationSize(), false);\n-        return specializedHandle;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":11,"deletions":118,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -31,2 +30,0 @@\n-import java.lang.foreign.ResourceScope;\n-import java.lang.foreign.ValueLayout;\n@@ -35,0 +32,1 @@\n+import java.lang.foreign.ResourceScope;\n@@ -38,2 +36,0 @@\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n@@ -41,1 +37,0 @@\n-import java.util.List;\n@@ -46,1 +41,0 @@\n-import static java.lang.invoke.MethodHandles.collectArguments;\n@@ -48,1 +42,0 @@\n-import static java.lang.invoke.MethodHandles.empty;\n@@ -50,1 +43,0 @@\n-import static java.lang.invoke.MethodHandles.identity;\n@@ -54,1 +46,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.mergeArguments;\n@@ -76,0 +67,1 @@\n+        assert callingSequence.forUpcall();\n@@ -79,3 +71,1 @@\n-        Class<?> llReturn = retMoves.length == 1 ? retMoves[0].type() : void.class;\n-        Class<?>[] llParams = Arrays.stream(argMoves).map(Binding.Move::type).toArray(Class<?>[]::new);\n-        MethodType llType = methodType(llReturn, llParams);\n+        MethodType llType = callingSequence.callerMethodType();\n@@ -85,1 +75,1 @@\n-            doBindings = specializedBindingHandle(target, callingSequence, llReturn, abi);\n+            doBindings = BindingSpecializer.specialize(target, callingSequence, abi);\n@@ -90,1 +80,1 @@\n-            int spreaderCount = callingSequence.methodType().parameterCount();\n+            int spreaderCount = callingSequence.calleeMethodType().parameterCount();\n@@ -135,62 +125,0 @@\n-    private static MethodHandle specializedBindingHandle(MethodHandle target, CallingSequence callingSequence,\n-                                                         Class<?> llReturn, ABIDescriptor abi) {\n-        MethodType highLevelType = callingSequence.methodType();\n-\n-        MethodHandle specializedHandle = target; \/\/ initial\n-\n-        \/\/ we handle returns first since IMR adds an extra parameter that needs to be specialized as well\n-        if (llReturn != void.class || callingSequence.needsReturnBuffer()) {\n-            int retAllocatorPos = -1; \/\/ assumed not needed\n-            int retInsertPos;\n-            MethodHandle filter;\n-            if (callingSequence.needsReturnBuffer()) {\n-                retInsertPos = 1;\n-                filter = empty(methodType(void.class, MemorySegment.class));\n-            } else {\n-                retInsertPos = 0;\n-                filter = identity(llReturn);\n-            }\n-            long retBufWriteOffset = callingSequence.returnBufferSize();\n-            List<Binding> bindings = callingSequence.returnBindings();\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                if (callingSequence.needsReturnBuffer() && binding.tag() == Binding.Tag.VM_STORE) {\n-                    Binding.VMStore store = (Binding.VMStore) binding;\n-                    ValueLayout layout = MemoryLayout.valueLayout(store.type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n-                    \/\/ since we iterate the bindings in reverse, we have to compute the offset in reverse as well\n-                    retBufWriteOffset -= abi.arch.typeSize(store.storage().type());\n-                    MethodHandle storeHandle = MethodHandles.insertCoordinates(MethodHandles.memoryAccessVarHandle(layout), 1, retBufWriteOffset)\n-                            .toMethodHandle(VarHandle.AccessMode.SET);\n-                    filter = collectArguments(filter, retInsertPos, storeHandle);\n-                    filter = mergeArguments(filter, retInsertPos - 1, retInsertPos);\n-                } else {\n-                    filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n-                }\n-            }\n-            specializedHandle = collectArguments(filter, retInsertPos, specializedHandle);\n-        }\n-\n-        int argAllocatorPos = 0;\n-        int argInsertPos = 1;\n-        specializedHandle = dropArguments(specializedHandle, argAllocatorPos, Binding.Context.class);\n-        for (int i = 0; i < highLevelType.parameterCount(); i++) {\n-            MethodHandle filter = identity(highLevelType.parameterType(i));\n-            int filterAllocatorPos = 0;\n-            int filterInsertPos = 1; \/\/ +1 for allocator\n-            filter = dropArguments(filter, filterAllocatorPos, Binding.Context.class);\n-\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            for (int j = bindings.size() - 1; j >= 0; j--) {\n-                Binding binding = bindings.get(j);\n-                filter = binding.specialize(filter, filterInsertPos, filterAllocatorPos);\n-            }\n-            specializedHandle = MethodHandles.collectArguments(specializedHandle, argInsertPos, filter);\n-            specializedHandle = mergeArguments(specializedHandle, argAllocatorPos, argInsertPos + filterAllocatorPos);\n-            argInsertPos += filter.type().parameterCount() - 1; \/\/ -1 for allocator\n-        }\n-\n-        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, callingSequence.allocationSize(), true);\n-\n-        return specializedHandle;\n-    }\n-\n@@ -210,1 +138,1 @@\n-            Object[] highLevelArgs = new Object[invData.callingSequence.methodType().parameterCount()];\n+            Object[] highLevelArgs = new Object[invData.callingSequence.calleeMethodType().parameterCount()];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":6,"deletions":78,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -350,46 +350,0 @@\n-    static MethodHandle wrapWithAllocator(MethodHandle specializedHandle,\n-                                          int allocatorPos, long allocationSize,\n-                                          boolean upcall) {\n-        \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n-        MethodHandle closer;\n-        int insertPos;\n-        if (specializedHandle.type().returnType() == void.class) {\n-            if (!upcall) {\n-                closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n-            } else {\n-                closer = MH_HANDLE_UNCAUGHT_EXCEPTION;\n-            }\n-            insertPos = 1;\n-        } else {\n-            closer = identity(specializedHandle.type().returnType()); \/\/ (V) -> V\n-            if (!upcall) {\n-                closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n-            } else {\n-                closer = collectArguments(closer, 0, MH_HANDLE_UNCAUGHT_EXCEPTION); \/\/ (Throwable, V) -> V\n-            }\n-            insertPos = 2;\n-        }\n-\n-        \/\/ downcalls get the leading SegmentAllocator param as well\n-        if (!upcall) {\n-            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, SegmentAllocator, NativeSymbol) -> V\/void\n-        }\n-\n-        closer = collectArguments(closer, insertPos, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, SegmentAllocator?, BindingContext) -> V\/void\n-\n-        MethodHandle contextFactory;\n-\n-        if (allocationSize > 0) {\n-            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, allocationSize);\n-        } else if (upcall) {\n-            contextFactory = MH_MAKE_CONTEXT_NO_ALLOCATOR;\n-        } else {\n-            \/\/ this path is probably never used now, since ProgrammableInvoker never calls this routine with bufferCopySize == 0\n-            contextFactory = constant(Binding.Context.class, Binding.Context.DUMMY);\n-        }\n-\n-        specializedHandle = tryFinally(specializedHandle, closer);\n-        specializedHandle = collectArguments(specializedHandle, allocatorPos, contextFactory);\n-        return specializedHandle;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.CLinker;\n@@ -33,0 +32,3 @@\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n@@ -36,1 +38,0 @@\n-import java.util.Objects;\n@@ -38,2 +39,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.CallArranger;\n@@ -45,1 +44,1 @@\n-public final class LinuxAArch64Linker implements CLinker {\n+public final class LinuxAArch64Linker extends AbstractLinker {\n@@ -58,6 +57,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.LINUX.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.LINUX.arrangeDowncall(inferredMethodType, function);\n@@ -67,10 +62,2 @@\n-    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.LINUX.arrangeUpcall(target, target.type(), function, scope);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n+        return CallArranger.LINUX.arrangeUpcall(target, targetType, function, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.CLinker;\n@@ -36,1 +35,0 @@\n-import java.util.Objects;\n@@ -38,1 +36,2 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n@@ -45,1 +44,1 @@\n-public final class MacOsAArch64Linker implements CLinker {\n+public final class MacOsAArch64Linker extends AbstractLinker {\n@@ -58,6 +57,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.MACOS.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.MACOS.arrangeDowncall(inferredMethodType, function);\n@@ -67,9 +62,2 @@\n-    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.MACOS.arrangeUpcall(target, target.type(), function, scope);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n+        return CallArranger.MACOS.arrangeUpcall(target, targetType, function, scope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.CLinker;\n@@ -36,1 +35,0 @@\n-import java.util.Objects;\n@@ -38,1 +36,2 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n@@ -43,1 +42,1 @@\n-public final class SysVx64Linker implements CLinker {\n+public final class SysVx64Linker extends AbstractLinker {\n@@ -61,4 +60,3 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        SysVVaList.Builder builder = SysVVaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.arrangeDowncall(inferredMethodType, function);\n@@ -68,6 +66,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n@@ -76,11 +70,4 @@\n-    @Override\n-    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        SysVVaList.Builder builder = SysVVaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":12,"deletions":25,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.CLinker;\n@@ -35,1 +34,0 @@\n-import java.util.Objects;\n@@ -37,1 +35,2 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n@@ -42,1 +41,1 @@\n-public final class Windowsx64Linker implements CLinker {\n+public final class Windowsx64Linker extends AbstractLinker {\n@@ -53,2 +52,0 @@\n-    static final long ADDRESS_SIZE = 64; \/\/ bits\n-\n@@ -62,4 +59,3 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n-        WinVaList.Builder builder = WinVaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function) {\n+        return CallArranger.arrangeDowncall(inferredMethodType, function);\n@@ -69,6 +65,2 @@\n-    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n-        Objects.requireNonNull(function);\n-        MethodType type = SharedUtils.inferMethodType(function, false);\n-        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n-        handle = SharedUtils.maybeInsertAllocator(handle);\n-        return SharedUtils.wrapDowncall(handle, function);\n+    protected NativeSymbol arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, ResourceScope scope) {\n+        return CallArranger.arrangeUpcall(target, targetType, function, scope);\n@@ -77,11 +69,4 @@\n-    @Override\n-    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        Objects.requireNonNull(target);\n-        Objects.requireNonNull(function);\n-        SharedUtils.checkExceptions(target);\n-        MethodType type = SharedUtils.inferMethodType(function, true);\n-        if (!type.equals(target.type())) {\n-            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n-        }\n-        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        WinVaList.Builder builder = WinVaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n@@ -98,0 +83,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":13,"deletions":27,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                    \"Unsupported layout: [:b32]\"\n+                    \"Unsupported layout: [:i32]\"\n@@ -76,1 +76,1 @@\n-                    \"Unsupported layout: [:b32]\"\n+                    \"Unsupported layout: [:i32]\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        assertEquals(callingSequence.argumentCount(), argumentBindings.length);\n+        assertEquals(callingSequence.argumentBindingsCount(), argumentBindings.length);\n@@ -37,1 +37,1 @@\n-        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n+        for (int i = 0; i < callingSequence.argumentBindingsCount(); i++) {\n","filename":"test\/jdk\/java\/foreign\/callarranger\/CallArrangerTestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -90,1 +90,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -120,1 +120,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -142,1 +142,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -202,1 +202,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -233,1 +233,1 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n@@ -257,1 +257,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n@@ -286,1 +286,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n@@ -324,1 +324,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -378,1 +378,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -407,1 +407,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -430,1 +430,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -95,1 +95,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -126,1 +126,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -156,1 +156,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -186,1 +186,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -211,1 +211,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -242,1 +242,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -277,1 +277,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -334,1 +334,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -377,1 +377,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -399,1 +399,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n@@ -458,1 +458,1 @@\n-        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n@@ -490,1 +490,1 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class, long.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class, long.class));\n@@ -514,1 +514,1 @@\n-        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.calleeMethodType(), mt);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -82,1 +82,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -104,1 +104,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -128,1 +128,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -159,1 +159,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -196,1 +196,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -230,1 +230,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -260,1 +260,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -291,1 +291,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -312,1 +312,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n@@ -336,1 +336,1 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class));\n@@ -365,1 +365,1 @@\n-        assertEquals(callingSequence.methodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, NativeSymbol.class));\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"}]}