{"files":[{"patch":"@@ -543,17 +543,17 @@\n-            if (base instanceof byte[]) {\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof short[]) {\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof char[]) {\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof int[]) {\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof float[]) {\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof long[]) {\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof double[]) {\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else {\n-                throw new AssertionError(\"Cannot get here\");\n-            }\n+            return switch (base) {\n+                case byte[] __ ->\n+                        new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case short[] __ ->\n+                        new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case char[] __ ->\n+                        new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case int[] __ ->\n+                        new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case float[] __ ->\n+                        new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case long[] __ ->\n+                        new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case double[] __ ->\n+                        new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                default -> throw new AssertionError(\"Cannot get here\");\n+            };\n@@ -569,17 +569,9 @@\n-        if (buffer instanceof ByteBuffer) {\n-            return 0;\n-        } else if (buffer instanceof CharBuffer) {\n-            return 1;\n-        } else if (buffer instanceof ShortBuffer) {\n-            return 1;\n-        } else if (buffer instanceof IntBuffer) {\n-            return 2;\n-        } else if (buffer instanceof FloatBuffer) {\n-            return 2;\n-        } else if (buffer instanceof LongBuffer) {\n-            return 3;\n-        } else if (buffer instanceof DoubleBuffer) {\n-            return 3;\n-        } else {\n-            throw new AssertionError(\"Cannot get here\");\n-        }\n+        return switch (buffer) {\n+            case ByteBuffer   __ -> 0;\n+            case CharBuffer   __ -> 1;\n+            case ShortBuffer  __ -> 1;\n+            case IntBuffer    __ -> 2;\n+            case FloatBuffer  __ -> 2;\n+            case LongBuffer   __ -> 3;\n+            case DoubleBuffer __ -> 3;\n+        };\n@@ -717,17 +709,21 @@\n-        if (arrayType.equals(byte[].class)) {\n-            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long) Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+        return switch (arrayType) {\n+            case Class<?> c when c.equals(byte[].class) ->\n+                    make(Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);\n+            case Class<?> c when c.equals(char[].class) ->\n+                    make(Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+            case Class<?> c when c.equals(short[].class) ->\n+                    make(Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+            case Class<?> c when c.equals(int[].class) ->\n+                    make(Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);\n+            case Class<?> c when c.equals(float[].class) ->\n+                    make(Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);\n+            case Class<?> c when c.equals(long[].class) ->\n+                    make(Unsafe.ARRAY_LONG_BASE_OFFSET,  Unsafe.ARRAY_LONG_INDEX_SCALE);\n+            case Class<?> c when c.equals(double[].class) ->\n+                    make(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);\n+            default -> throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n+        };\n+    }\n+\n+    static long make(int offset, int scale) {\n+        return (long) offset | ((long) scale << 32);\n@@ -735,0 +731,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":48,"deletions":51,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<String>() {\n+        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<>() {\n@@ -89,1 +89,1 @@\n-        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<>() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -244,24 +244,19 @@\n-        if (layout instanceof ValueLayout.OfBoolean bl) {\n-            argSeg.set(bl, 0, (Boolean) arg);\n-        } else if (layout instanceof ValueLayout.OfByte bl) {\n-            argSeg.set(bl, 0, (Byte) arg);\n-        } else if (layout instanceof ValueLayout.OfShort sl) {\n-            argSeg.set(sl, 0, (Short) arg);\n-        } else if (layout instanceof ValueLayout.OfChar cl) {\n-            argSeg.set(cl, 0, (Character) arg);\n-        } else if (layout instanceof ValueLayout.OfInt il) {\n-            argSeg.set(il, 0, (Integer) arg);\n-        } else if (layout instanceof ValueLayout.OfLong ll) {\n-            argSeg.set(ll, 0, (Long) arg);\n-        } else if (layout instanceof ValueLayout.OfFloat fl) {\n-            argSeg.set(fl, 0, (Float) arg);\n-        } else if (layout instanceof ValueLayout.OfDouble dl) {\n-            argSeg.set(dl, 0, (Double) arg);\n-        } else if (layout instanceof AddressLayout al) {\n-            MemorySegment addrArg = (MemorySegment) arg;\n-            acquireCallback.accept(addrArg);\n-            argSeg.set(al, 0, addrArg);\n-        } else if (layout instanceof GroupLayout) {\n-            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n-        } else {\n-            assert layout == null;\n+        switch (layout) {\n+            case ValueLayout.OfBoolean bl -> argSeg.set(bl, 0, (Boolean) arg);\n+            case ValueLayout.OfByte    bl -> argSeg.set(bl, 0, (Byte) arg);\n+            case ValueLayout.OfShort   sl -> argSeg.set(sl, 0, (Short) arg);\n+            case ValueLayout.OfChar    cl -> argSeg.set(cl, 0, (Character) arg);\n+            case ValueLayout.OfInt     il -> argSeg.set(il, 0, (Integer) arg);\n+            case ValueLayout.OfLong    ll -> argSeg.set(ll, 0, (Long) arg);\n+            case ValueLayout.OfFloat   fl -> argSeg.set(fl, 0, (Float) arg);\n+            case ValueLayout.OfDouble  dl -> argSeg.set(dl, 0, (Double) arg);\n+            case AddressLayout         al -> {\n+                MemorySegment addrArg = (MemorySegment) arg;\n+                acquireCallback.accept(addrArg);\n+                argSeg.set(al, 0, addrArg);\n+            }\n+            case GroupLayout           __ ->\n+                    MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n+            case null, default -> {\n+                assert layout == null;\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -134,10 +134,16 @@\n-        if (layout instanceof ValueLayout valueLayout) {\n-            TypeClass typeClass = classifyValueType(valueLayout);\n-            return List.of(switch (typeClass) {\n-                case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n-                default -> throw new IllegalStateException(\"Should not reach here.\");\n-            });\n-        } else if (layout instanceof GroupLayout groupLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n-                if (memberLayout instanceof PaddingLayout) {\n+        return switch (layout) {\n+            case ValueLayout valueLayout -> {\n+                TypeClass typeClass = classifyValueType(valueLayout);\n+                yield List.of(switch (typeClass) {\n+                    case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n+                    default -> throw new IllegalStateException(\"Should not reach here.\");\n+                });\n+            }\n+            case GroupLayout groupLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                    if (memberLayout instanceof PaddingLayout) {\n+                        offset += memberLayout.byteSize();\n+                        continue;\n+                    }\n+                    fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n@@ -145,1 +151,0 @@\n-                    continue;\n@@ -147,2 +152,1 @@\n-                fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n-                offset += memberLayout.byteSize();\n+                yield fields;\n@@ -150,7 +154,8 @@\n-            return fields;\n-        } else if (layout instanceof SequenceLayout sequenceLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            MemoryLayout elementLayout = sequenceLayout.elementLayout();\n-            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n-                fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n-                offset += elementLayout.byteSize();\n+            case SequenceLayout sequenceLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                MemoryLayout elementLayout = sequenceLayout.elementLayout();\n+                for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                    fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n+                    offset += elementLayout.byteSize();\n+                }\n+                yield fields;\n@@ -158,4 +163,2 @@\n-            return fields;\n-        } else {\n-            throw new IllegalStateException(\"Cannot get here: \" + layout);\n-        }\n+            case null, default -> throw new IllegalStateException(\"Cannot get here: \" + layout);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -99,4 +99,1 @@\n-        if (baseArgClass != FLOAT)\n-            return false;\n-\n-        return true;\n+        return baseArgClass == FLOAT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/TypeClass.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -212,5 +212,7 @@\n-        if (l instanceof GroupLayout group) {\n-            for (MemoryLayout m : group.memberLayouts()) {\n-                groupByEightBytes(m, offset, groups);\n-                if (group instanceof StructLayout) {\n-                    offset += m.byteSize();\n+        switch (l) {\n+            case GroupLayout group -> {\n+                for (MemoryLayout m : group.memberLayouts()) {\n+                    groupByEightBytes(m, offset, groups);\n+                    if (group instanceof StructLayout) {\n+                        offset += m.byteSize();\n+                    }\n@@ -219,7 +221,1 @@\n-        } else if (l instanceof PaddingLayout) {\n-            return;\n-        } else if (l instanceof SequenceLayout seq) {\n-            MemoryLayout elem = seq.elementLayout();\n-            for (long i = 0 ; i < seq.elementCount() ; i++) {\n-                groupByEightBytes(elem, offset, groups);\n-                offset += elem.byteSize();\n+            case PaddingLayout __ -> {\n@@ -227,5 +223,6 @@\n-        } else if (l instanceof ValueLayout vl) {\n-            List<ArgumentClassImpl> layouts = groups[(int)offset \/ 8];\n-            if (layouts == null) {\n-                layouts = new ArrayList<>();\n-                groups[(int)offset \/ 8] = layouts;\n+            case SequenceLayout seq -> {\n+                MemoryLayout elem = seq.elementLayout();\n+                for (long i = 0; i < seq.elementCount(); i++) {\n+                    groupByEightBytes(elem, offset, groups);\n+                    offset += elem.byteSize();\n+                }\n@@ -233,7 +230,13 @@\n-            \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n-            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n-                    argumentClassFor(vl) :\n-                    ArgumentClassImpl.MEMORY;\n-            layouts.add(argumentClass);\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + l);\n+            case ValueLayout vl -> {\n+                List<ArgumentClassImpl> layouts = groups[(int) offset \/ 8];\n+                if (layouts == null) {\n+                    layouts = new ArrayList<>();\n+                    groups[(int) offset \/ 8] = layouts;\n+                }\n+                \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n+                ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                        argumentClassFor(vl) :\n+                        ArgumentClassImpl.MEMORY;\n+                layouts.add(argumentClass);\n+            }\n+            case null, default -> throw new IllegalStateException(\"Unexpected layout: \" + l);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"}]}