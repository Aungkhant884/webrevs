{"files":[{"patch":"@@ -543,17 +543,17 @@\n-            if (base instanceof byte[]) {\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof short[]) {\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof char[]) {\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof int[]) {\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof float[]) {\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof long[]) {\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else if (base instanceof double[]) {\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n-            } else {\n-                throw new AssertionError(\"Cannot get here\");\n-            }\n+            return switch (base) {\n+                case byte[] __ ->\n+                        new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case short[] __ ->\n+                        new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case char[] __ ->\n+                        new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case int[] __ ->\n+                        new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case float[] __ ->\n+                        new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case long[] __ ->\n+                        new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                case double[] __ ->\n+                        new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                default -> throw new AssertionError(\"Cannot get here\");\n+            };\n@@ -568,20 +568,0 @@\n-    private static int getScaleFactor(Buffer buffer) {\n-        if (buffer instanceof ByteBuffer) {\n-            return 0;\n-        } else if (buffer instanceof CharBuffer) {\n-            return 1;\n-        } else if (buffer instanceof ShortBuffer) {\n-            return 1;\n-        } else if (buffer instanceof IntBuffer) {\n-            return 2;\n-        } else if (buffer instanceof FloatBuffer) {\n-            return 2;\n-        } else if (buffer instanceof LongBuffer) {\n-            return 3;\n-        } else if (buffer instanceof DoubleBuffer) {\n-            return 3;\n-        } else {\n-            throw new AssertionError(\"Cannot get here\");\n-        }\n-    }\n-\n@@ -625,1 +605,1 @@\n-        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        var dstInfo = Utils.BaseAndScale.of(dstArray);\n@@ -629,2 +609,0 @@\n-        int dstBase = (int)baseAndScale;\n-        long dstWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -636,1 +614,1 @@\n-        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        srcImpl.checkAccess(srcOffset, elementCount * dstInfo.scale(), true);\n@@ -638,1 +616,1 @@\n-        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+        if (dstInfo.scale() == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n@@ -641,1 +619,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale());\n@@ -645,1 +623,1 @@\n-                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+                    dstArray, dstInfo.base() + (dstIndex * dstInfo.scale()), elementCount * dstInfo.scale(), dstInfo.scale());\n@@ -654,1 +632,1 @@\n-        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        var srcInfo = Utils.BaseAndScale.of(srcArray);\n@@ -658,2 +636,0 @@\n-        int srcBase = (int)baseAndScale;\n-        long srcWidth = (int)(baseAndScale >> 32); \/\/ Use long arithmetics below\n@@ -666,2 +642,2 @@\n-        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n-        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+        destImpl.checkAccess(dstOffset, elementCount * srcInfo.scale(), false);\n+        if (srcInfo.scale() == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n@@ -669,2 +645,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale());\n@@ -673,2 +649,2 @@\n-                    srcArray, srcBase + (srcIndex * srcWidth),\n-                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+                    srcArray, srcInfo.base() + (srcIndex * srcInfo.scale()),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcInfo.scale(), srcInfo.scale());\n@@ -716,18 +692,10 @@\n-    private static long getBaseAndScale(Class<?> arrayType) {\n-        if (arrayType.equals(byte[].class)) {\n-            return (long) Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(char[].class)) {\n-            return (long) Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(short[].class)) {\n-            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(int[].class)) {\n-            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(float[].class)) {\n-            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(long[].class)) {\n-            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n-        } else if (arrayType.equals(double[].class)) {\n-            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n-        } else {\n-            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n-        }\n+    private static int getScaleFactor(Buffer buffer) {\n+        return switch (buffer) {\n+            case ByteBuffer   __ -> 0;\n+            case CharBuffer   __ -> 1;\n+            case ShortBuffer  __ -> 1;\n+            case IntBuffer    __ -> 2;\n+            case FloatBuffer  __ -> 2;\n+            case LongBuffer   __ -> 3;\n+            case DoubleBuffer __ -> 3;\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":39,"deletions":71,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -53,3 +53,0 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-    private static final int BYTE_ARR_BASE = UNSAFE.arrayBaseOffset(byte[].class);\n-\n@@ -92,1 +89,1 @@\n-        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - Utils.BaseAndScale.BYTE.base(), (int) byteSize(), null);\n@@ -115,2 +112,2 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.BYTE.scale();\n+            return new OfByte(Utils.BaseAndScale.BYTE.base(), arr, byteSize, false,\n@@ -127,1 +124,1 @@\n-            return offset - Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.BYTE.base();\n@@ -149,2 +146,2 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_CHAR_INDEX_SCALE;\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.CHAR.scale();\n+            return new OfChar(Utils.BaseAndScale.CHAR.base(), arr, byteSize, false,\n@@ -161,1 +158,1 @@\n-            return offset - Unsafe.ARRAY_CHAR_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.CHAR.base();\n@@ -183,2 +180,2 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_SHORT_INDEX_SCALE;\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.SHORT.scale();\n+            return new OfShort(Utils.BaseAndScale.SHORT.base(), arr, byteSize, false,\n@@ -195,1 +192,1 @@\n-            return offset - Unsafe.ARRAY_SHORT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.SHORT.base();\n@@ -217,2 +214,2 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_INT_INDEX_SCALE;\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.INT.scale();\n+            return new OfInt(Utils.BaseAndScale.INT.base(), arr, byteSize, false,\n@@ -229,1 +226,1 @@\n-            return offset - Unsafe.ARRAY_INT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.INT.base();\n@@ -251,2 +248,2 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_LONG_INDEX_SCALE;\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.LONG.scale();\n+            return new OfLong(Utils.BaseAndScale.LONG.base(), arr, byteSize, false,\n@@ -263,1 +260,1 @@\n-            return offset - Unsafe.ARRAY_LONG_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.LONG.base();\n@@ -285,2 +282,2 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_FLOAT_INDEX_SCALE;\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.FLOAT.scale();\n+            return new OfFloat(Utils.BaseAndScale.FLOAT.base(), arr, byteSize, false,\n@@ -297,1 +294,1 @@\n-            return offset - Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.FLOAT.base();\n@@ -319,2 +316,2 @@\n-            long byteSize = (long)arr.length * Unsafe.ARRAY_DOUBLE_INDEX_SCALE;\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+            long byteSize = (long)arr.length * Utils.BaseAndScale.DOUBLE.scale();\n+            return new OfDouble(Utils.BaseAndScale.DOUBLE.base(), arr, byteSize, false,\n@@ -331,1 +328,1 @@\n-            return offset - Unsafe.ARRAY_DOUBLE_BASE_OFFSET;\n+            return offset - Utils.BaseAndScale.DOUBLE.base();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<String>() {\n+        String systemRoot = AccessController.doPrivileged(new PrivilegedAction<>() {\n@@ -89,1 +89,1 @@\n-        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\n+        boolean useUCRT = AccessController.doPrivileged(new PrivilegedAction<>() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -279,0 +280,32 @@\n+    public record BaseAndScale(int base, long scale) {\n+\n+        public static final BaseAndScale BYTE =\n+                new BaseAndScale(Unsafe.ARRAY_BYTE_BASE_OFFSET, Unsafe.ARRAY_BYTE_INDEX_SCALE);\n+        public static final BaseAndScale CHAR =\n+                new BaseAndScale(Unsafe.ARRAY_CHAR_BASE_OFFSET, Unsafe.ARRAY_CHAR_INDEX_SCALE);\n+        public static final BaseAndScale SHORT =\n+                new BaseAndScale(Unsafe.ARRAY_SHORT_BASE_OFFSET, Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+        public static final BaseAndScale INT =\n+                new BaseAndScale(Unsafe.ARRAY_INT_BASE_OFFSET, Unsafe.ARRAY_INT_INDEX_SCALE);\n+        public static final BaseAndScale FLOAT =\n+                new BaseAndScale(Unsafe.ARRAY_FLOAT_BASE_OFFSET, Unsafe.ARRAY_FLOAT_INDEX_SCALE);\n+        public static final BaseAndScale LONG =\n+                new BaseAndScale(Unsafe.ARRAY_LONG_BASE_OFFSET, Unsafe.ARRAY_LONG_INDEX_SCALE);\n+        public static final BaseAndScale DOUBLE =\n+                new BaseAndScale(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, Unsafe.ARRAY_DOUBLE_INDEX_SCALE);\n+\n+        public static BaseAndScale of(Object array) {\n+            return switch (array) {\n+                case byte[]   __ -> BaseAndScale.BYTE;\n+                case char[]   __ -> BaseAndScale.CHAR;\n+                case short[]  __ -> BaseAndScale.SHORT;\n+                case int[]    __ -> BaseAndScale.INT;\n+                case float[]  __ -> BaseAndScale.FLOAT;\n+                case long[]   __ -> BaseAndScale.LONG;\n+                case double[] __ -> BaseAndScale.DOUBLE;\n+                default -> throw new IllegalArgumentException(\"Not a supported array class: \" + array.getClass().getSimpleName());\n+            };\n+        }\n+\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -244,24 +244,19 @@\n-        if (layout instanceof ValueLayout.OfBoolean bl) {\n-            argSeg.set(bl, 0, (Boolean) arg);\n-        } else if (layout instanceof ValueLayout.OfByte bl) {\n-            argSeg.set(bl, 0, (Byte) arg);\n-        } else if (layout instanceof ValueLayout.OfShort sl) {\n-            argSeg.set(sl, 0, (Short) arg);\n-        } else if (layout instanceof ValueLayout.OfChar cl) {\n-            argSeg.set(cl, 0, (Character) arg);\n-        } else if (layout instanceof ValueLayout.OfInt il) {\n-            argSeg.set(il, 0, (Integer) arg);\n-        } else if (layout instanceof ValueLayout.OfLong ll) {\n-            argSeg.set(ll, 0, (Long) arg);\n-        } else if (layout instanceof ValueLayout.OfFloat fl) {\n-            argSeg.set(fl, 0, (Float) arg);\n-        } else if (layout instanceof ValueLayout.OfDouble dl) {\n-            argSeg.set(dl, 0, (Double) arg);\n-        } else if (layout instanceof AddressLayout al) {\n-            MemorySegment addrArg = (MemorySegment) arg;\n-            acquireCallback.accept(addrArg);\n-            argSeg.set(al, 0, addrArg);\n-        } else if (layout instanceof GroupLayout) {\n-            MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n-        } else {\n-            assert layout == null;\n+        switch (layout) {\n+            case ValueLayout.OfBoolean bl -> argSeg.set(bl, 0, (Boolean) arg);\n+            case ValueLayout.OfByte    bl -> argSeg.set(bl, 0, (Byte) arg);\n+            case ValueLayout.OfShort   sl -> argSeg.set(sl, 0, (Short) arg);\n+            case ValueLayout.OfChar    cl -> argSeg.set(cl, 0, (Character) arg);\n+            case ValueLayout.OfInt     il -> argSeg.set(il, 0, (Integer) arg);\n+            case ValueLayout.OfLong    ll -> argSeg.set(ll, 0, (Long) arg);\n+            case ValueLayout.OfFloat   fl -> argSeg.set(fl, 0, (Float) arg);\n+            case ValueLayout.OfDouble  dl -> argSeg.set(dl, 0, (Double) arg);\n+            case AddressLayout         al -> {\n+                MemorySegment addrArg = (MemorySegment) arg;\n+                acquireCallback.accept(addrArg);\n+                argSeg.set(al, 0, addrArg);\n+            }\n+            case GroupLayout           __ ->\n+                    MemorySegment.copy((MemorySegment) arg, 0, argSeg, 0, argSeg.byteSize()); \/\/ by-value struct\n+            case null, default -> {\n+                assert layout == null;\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -134,10 +134,16 @@\n-        if (layout instanceof ValueLayout valueLayout) {\n-            TypeClass typeClass = classifyValueType(valueLayout);\n-            return List.of(switch (typeClass) {\n-                case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n-                default -> throw new IllegalStateException(\"Should not reach here.\");\n-            });\n-        } else if (layout instanceof GroupLayout groupLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n-                if (memberLayout instanceof PaddingLayout) {\n+        return switch (layout) {\n+            case ValueLayout valueLayout -> {\n+                TypeClass typeClass = classifyValueType(valueLayout);\n+                yield List.of(switch (typeClass) {\n+                    case INTEGER, FLOAT -> new FlattenedFieldDesc(typeClass, offset, valueLayout);\n+                    default -> throw new IllegalStateException(\"Should not reach here.\");\n+                });\n+            }\n+            case GroupLayout groupLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                for (MemoryLayout memberLayout : groupLayout.memberLayouts()) {\n+                    if (memberLayout instanceof PaddingLayout) {\n+                        offset += memberLayout.byteSize();\n+                        continue;\n+                    }\n+                    fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n@@ -145,1 +151,0 @@\n-                    continue;\n@@ -147,2 +152,1 @@\n-                fields.addAll(getFlattenedFieldsInner(offset, memberLayout));\n-                offset += memberLayout.byteSize();\n+                yield fields;\n@@ -150,7 +154,8 @@\n-            return fields;\n-        } else if (layout instanceof SequenceLayout sequenceLayout) {\n-            List<FlattenedFieldDesc> fields = new ArrayList<>();\n-            MemoryLayout elementLayout = sequenceLayout.elementLayout();\n-            for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n-                fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n-                offset += elementLayout.byteSize();\n+            case SequenceLayout sequenceLayout -> {\n+                List<FlattenedFieldDesc> fields = new ArrayList<>();\n+                MemoryLayout elementLayout = sequenceLayout.elementLayout();\n+                for (long i = 0; i < sequenceLayout.elementCount(); i++) {\n+                    fields.addAll(getFlattenedFieldsInner(offset, elementLayout));\n+                    offset += elementLayout.byteSize();\n+                }\n+                yield fields;\n@@ -158,4 +163,2 @@\n-            return fields;\n-        } else {\n-            throw new IllegalStateException(\"Cannot get here: \" + layout);\n-        }\n+            case null, default -> throw new IllegalStateException(\"Cannot get here: \" + layout);\n+        };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/TypeClass.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -99,4 +99,1 @@\n-        if (baseArgClass != FLOAT)\n-            return false;\n-\n-        return true;\n+        return baseArgClass == FLOAT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/TypeClass.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -211,6 +211,10 @@\n-    private static void groupByEightBytes(MemoryLayout l, long offset, List<ArgumentClassImpl>[] groups) {\n-        if (l instanceof GroupLayout group) {\n-            for (MemoryLayout m : group.memberLayouts()) {\n-                groupByEightBytes(m, offset, groups);\n-                if (group instanceof StructLayout) {\n-                    offset += m.byteSize();\n+    private static void groupByEightBytes(MemoryLayout layout,\n+                                          long offset,\n+                                          List<ArgumentClassImpl>[] groups) {\n+        switch (layout) {\n+            case GroupLayout group -> {\n+                for (MemoryLayout m : group.memberLayouts()) {\n+                    groupByEightBytes(m, offset, groups);\n+                    if (group instanceof StructLayout) {\n+                        offset += m.byteSize();\n+                    }\n@@ -219,7 +223,1 @@\n-        } else if (l instanceof PaddingLayout) {\n-            return;\n-        } else if (l instanceof SequenceLayout seq) {\n-            MemoryLayout elem = seq.elementLayout();\n-            for (long i = 0 ; i < seq.elementCount() ; i++) {\n-                groupByEightBytes(elem, offset, groups);\n-                offset += elem.byteSize();\n+            case PaddingLayout __ -> {\n@@ -227,5 +225,6 @@\n-        } else if (l instanceof ValueLayout vl) {\n-            List<ArgumentClassImpl> layouts = groups[(int)offset \/ 8];\n-            if (layouts == null) {\n-                layouts = new ArrayList<>();\n-                groups[(int)offset \/ 8] = layouts;\n+            case SequenceLayout seq -> {\n+                MemoryLayout elem = seq.elementLayout();\n+                for (long i = 0; i < seq.elementCount(); i++) {\n+                    groupByEightBytes(elem, offset, groups);\n+                    offset += elem.byteSize();\n+                }\n@@ -233,7 +232,13 @@\n-            \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n-            ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n-                    argumentClassFor(vl) :\n-                    ArgumentClassImpl.MEMORY;\n-            layouts.add(argumentClass);\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + l);\n+            case ValueLayout vl -> {\n+                List<ArgumentClassImpl> layouts = groups[(int) offset \/ 8];\n+                if (layouts == null) {\n+                    layouts = new ArrayList<>();\n+                    groups[(int) offset \/ 8] = layouts;\n+                }\n+                \/\/ if the aggregate contains unaligned fields, it has class MEMORY\n+                ArgumentClassImpl argumentClass = (offset % vl.byteAlignment()) == 0 ?\n+                        argumentClassFor(vl) :\n+                        ArgumentClassImpl.MEMORY;\n+                layouts.add(argumentClass);\n+            }\n+            case null, default -> throw new IllegalStateException(\"Unexpected layout: \" + layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":30,"deletions":25,"binary":false,"changes":55,"status":"modified"}]}