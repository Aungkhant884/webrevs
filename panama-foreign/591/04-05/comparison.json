{"files":[{"patch":"@@ -389,4 +389,0 @@\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,3 +132,3 @@\n-     * with the same scope as this variable argument list. using the segment provided allocator. Copying is useful to\n-     * traverse the variable argument list elements, starting from the current position, without affecting the state\n-     * of the original variable argument list, essentially allowing the elements to be traversed multiple times.\n+     * with the same scope as this variable argument list. Copying is useful to traverse the variable argument list elements,\n+     * starting from the current position, without affecting the state of the original variable argument list,\n+     * essentially allowing the elements to be traversed multiple times.\n@@ -191,2 +191,2 @@\n-     * @throws IllegalStateException if the scope associated with {@code allocator} has been already closed,\n-     * or if access occurs from a thread other than the thread owning that scope.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.newImplicitScope());\n@@ -500,1 +500,1 @@\n-        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newSharedScope());\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n@@ -508,1 +508,1 @@\n-        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newSharedScope());\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}