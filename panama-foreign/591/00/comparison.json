{"files":[{"patch":"@@ -181,1 +181,1 @@\n-    MemorySegment segment = MemorySegment.allocateNative(2, ResourceScope.newConfinedScope());\n+    MemorySegment segment = MemorySegment.allocateNative(2, ResourceScope.newImplicitScope());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-     * Is this a padding layout (e.g. a layout created from {@link #paddingLayout(long)}) ?\n+     * Is this a {@linkplain #paddingLayout(long) padding layout} ?\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    segment = scope.allocate(8);\n+    segment = MemorySegment.allocateNative(8);\n@@ -190,1 +190,1 @@\n-    MemorySegment segment = scope.allocate(SEQUENCE_LAYOUT);\n+    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Objects;\n@@ -39,4 +40,2 @@\n- * with a resource scope can only be accessed while the resource scope is <em>alive<\/em> (see {@link #isAlive()}),\n- * and by the thread associated with the resource scope (if any). A resource scope can be used as a\n- * {@linkplain SegmentAllocator segment allocator}; that is, this interface provides many methods which can be\n- * used to allocate native segments, associated with this scope.\n+ * with a resource scope can only be accessed while the resource scope is {@linkplain #isAlive() alive},\n+ * and by the {@linkplain #ownerThread() thread} associated with the resource scope (if any).\n@@ -46,4 +45,4 @@\n- * Resource scopes obtained from {@link #newConfinedScope()}, {@link #newSharedScope()} support <em>deterministic deallocation<\/em>;\n- * Resource scopes can be closed explicitly (see {@link ResourceScope#close()}). When a resource scope is closed,\n- * it is no longer <em>alive<\/em> (see {@link #isAlive()}), and subsequent operations on resources associated with that scope\n- * (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * Resource scopes support <em>deterministic deallocation<\/em>; that is, they can be {@linkplain ResourceScope#close() closed}\n+ * explicitly. When a resource scope is closed, it is no longer {@link #isAlive() alive}, and subsequent\n+ * operations on resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance)\n+ * will fail with {@link IllegalStateException}.\n@@ -51,1 +50,1 @@\n- * Closing a resource scope will cause all the cleanup actions associated with that scope (see {@link #addCloseAction(Runnable)}) to be called.\n+ * Closing a resource scope will cause all the {@linkplain #addCloseAction(Runnable) close actions} associated with that scope to be called.\n@@ -54,6 +53,8 @@\n- *     <li>closing the scope associated with a native memory segment results in <em>freeing<\/em> the native memory associated with it\n- *     (see {@link MemorySegment#allocateNative(long, ResourceScope)}, or {@link SegmentAllocator#arenaUnbounded(ResourceScope)})<\/li>\n- *     <li>closing the scope associated with a mapped memory segment results in the backing memory-mapped file to be unmapped\n- *     (see {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)})<\/li>\n- *     <li>closing the scope associated with an upcall stub results in releasing the stub\n- *     (see {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}<\/li>\n+ *     <li>closing the scope associated with a {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) native memory segment}\n+ *     results in <em>freeing<\/em> the native memory associated with it;<\/li>\n+ *     <li>closing the scope associated with a {@linkplain MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope) mapped memory segment}\n+ *     results in the backing memory-mapped file to be unmapped;<\/li>\n+ *     <li>closing the scope associated with an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub}\n+ *     results in releasing the stub;<\/li>\n+ *     <li>closing the scope associated with a {@linkplain VaList variable arity list} results in releasing the memory\n+ *     associated with that variable arity list instance.<\/li>\n@@ -64,10 +65,6 @@\n- * Resource scopes are also closed automatically once the scope instance becomes\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>. This can be useful to allow for predictable,\n- * deterministic resource deallocation, while still preventing accidental native memory leaks. In case a managed resource scope\n- * is closed explicitly, no further action will be taken when the scope becomes unreachable; that is, cleanup actions\n- * (see {@link #addCloseAction(Runnable)}) associated with a resource scope, whether managed or not, are called <em>exactly once<\/em>.\n- * <p>\n- * Clients can opt out of implicit deallocation, by passing a {@code null} cleaner parameter to some of the\n- * {@linkplain #newConfinedScope(Cleaner) scope factories}. This should be done with care: if a scope is not associated\n- * with a {@linkplain Cleaner cleaner}, it is possible for the resources associated to the scope to never be cleaned up,\n- * should the scope become unreachable before the {@link #close()} method is called.\n+ * Resource scopes can be associated with a {@link Cleaner} instance, so that they are also closed automatically,\n+ * once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * This can be useful to allow for predictable, deterministic resource deallocation, while still preventing accidental\n+ * native memory leaks. In case a managed resource scope is closed explicitly, no further action will be taken when\n+ * the scope becomes unreachable; that is, {@linkplain #addCloseAction(Runnable) close actions} associated with a\n+ * resource scope, whether managed or not, are called <em>exactly once<\/em>.\n@@ -78,2 +75,5 @@\n- * a resource scope that cannot be closed, and that is guaranteed to never become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * As a results, the global scope will never attempt to release resources associated with it. Such resources must, where\n+ * a resource scope that cannot be closed, either explicitly or implicitly. As a results, the global scope will never\n+ * attempt to release resources associated with it. Examples of resources associated with the global scope are\n+ * {@linkplain MemorySegment#ofArray(int[]) heap segments} and variable arity lists\n+ * {@linkplain VaList#ofAddress(MemoryAddress, ResourceScope) obtained} from raw memory addresses.\n+ * In other words, the global scope is used to indicate that the lifecycle of one or more resources must, where\n@@ -84,1 +84,1 @@\n- * Resource scopes can be further divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n+ * Resource scopes can be divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n@@ -87,2 +87,2 @@\n- * Confined resource scopes (see {@link #newConfinedScope()}), support strong thread-confinement guarantees. Upon creation,\n- * they are assigned an <em>owner thread<\/em>, typically the thread which initiated the creation operation (see {@link #ownerThread()}).\n+ * {@linkplain #newConfinedScope() Confined resource scopes}, support strong thread-confinement guarantees. Upon creation,\n+ * they are assigned an {@linkplain #ownerThread() owner thread}, typically the thread which initiated the creation operation.\n@@ -93,2 +93,2 @@\n- * Shared resource scopes (see {@link #newSharedScope()}), on the other hand, have no owner thread;\n- * as such resources associated with this shared resource scopes can be accessed by multiple threads.\n+ * {@linkplain #newSharedScope() Shared resource scopes}, on the other hand, have no owner thread;\n+ * as such, resources associated with shared resource scopes can be accessed by multiple threads.\n@@ -96,1 +96,1 @@\n- * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n+ * For instance, a client might obtain a {@link Spliterator} from a segment backed by a shared scope, which can then be used to slice the\n@@ -103,1 +103,1 @@\n-    MemorySegment segment = scope.allocate(SEQUENCE_LAYOUT);\n+    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n@@ -115,1 +115,1 @@\n- * should always ensure that proper synchronization mechanisms (e.g. using resource scope handles, see below) are put in place\n+ * should always ensure that proper synchronization mechanisms (e.g. using temporal dependencies, see below) are put in place\n@@ -122,1 +122,1 @@\n- * Such a resource scope cannot be closed (either implicitly or explicitly) until <em>all<\/em> the scopes it is bound to\n+ * Such a resource scope cannot be closed (either implicitly or explicitly) until <em>all<\/em> the scopes it depends on\n@@ -142,1 +142,1 @@\n-public sealed interface ResourceScope extends AutoCloseable, SegmentAllocator permits ResourceScopeImpl {\n+public sealed interface ResourceScope extends AutoCloseable permits ResourceScopeImpl {\n@@ -192,2 +192,2 @@\n-     * @throws IllegalStateException if this scope has been closed, or if access occurs from\n-     * a thread other than the thread owning this scope.\n+     * @throws IllegalStateException if this scope or {@code target} have been closed, or if access occurs from\n+     * a thread other than the thread owning this scope or {@code target}.\n@@ -198,15 +198,1 @@\n-     * Allocate a native segment with given size and alignment constraint. This is equivalent to:\n-     * <blockquote><pre>{@code\n-    MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n-     * }<\/pre><\/blockquote>\n-     * @param bytesSize the size (in bytes) of the native segment to be allocated.\n-     * @param bytesAlignment the alignment (in bytes) of the native segment to be allocated.\n-     * @return a new native segment with given size and alignment.\n-     *\/\n-    MemorySegment allocate(long bytesSize, long bytesAlignment);\n-\n-    \/**\n-     * Create a new confined scope. Equivalent to (but likely more efficient than) the following code:\n-     * <pre>{@code\n-    newConfinedScope(Cleaner.create());\n-     * }<\/pre>\n+     * Create a new confined scope.\n@@ -216,1 +202,1 @@\n-        return ResourceScopeImpl.createConfined( Thread.currentThread(), CleanerFactory.cleaner());\n+        return ResourceScopeImpl.createConfined( Thread.currentThread(), null);\n@@ -220,4 +206,3 @@\n-     * Create a new confined scope. If {@code cleaner != null}, the resulting scope is managed by the provided\n-     * cleaner instance; otherwise the resulting scope will <em>not<\/em> feature implicit deallocation.\n-     * @param cleaner the cleaner to be associated with the returned scope (can be {@code null}).\n-     * @return a new confined scope, managed by {@code cleaner}, if {@code cleaner != null}.\n+     * Create a new confined scope, managed by the provided cleaner instance.\n+     * @param cleaner the cleaner to be associated with the returned scope.\n+     * @return a new confined scope, managed by {@code cleaner}.\n@@ -226,0 +211,1 @@\n+        Objects.requireNonNull(cleaner);\n@@ -230,4 +216,1 @@\n-     * Create a new shared scope. Equivalent to (but likely more efficient than) the following code:\n-     * <pre>{@code\n-newSharedScope(Cleaner.create());\n-     * }<\/pre>\n+     * Create a new shared scope.\n@@ -237,1 +220,1 @@\n-        return ResourceScopeImpl.createShared(CleanerFactory.cleaner());\n+        return ResourceScopeImpl.createShared(null);\n@@ -241,4 +224,3 @@\n-     * Create a new shared scope. If {@code cleaner != null}, the resulting scope is managed by the provided\n-     * cleaner instance; otherwise the resulting scope will <em>not<\/em> feature implicit deallocation.\n-     * @param cleaner the cleaner to be associated with the returned scope (can be {@code null}).\n-     * @return a new shared scope, managed by {@code cleaner}, if {@code cleaner != null}.\n+     * Create a new shared scope, managed by the provided cleaner instance.\n+     * @param cleaner the cleaner to be associated with the returned scope.\n+     * @return a new shared scope, managed by {@code cleaner}.\n@@ -247,0 +229,1 @@\n+        Objects.requireNonNull(cleaner);\n@@ -251,1 +234,13 @@\n-     * Returns an implicit scope which is assumed to be always alive.\n+     * Returns a shared scope, managed by a private {@link Cleaner} instance. Equivalent to (but likely more efficient than)\n+     * the following code:\n+     * <pre>{@code\n+    newSharedScope(Cleaner.create());\n+     * }<\/pre>\n+     * @return a shared scope, managed by a private {@link Cleaner} instance.\n+     *\/\n+    static ResourceScope newImplicitScope() {\n+        return newSharedScope(CleanerFactory.cleaner());\n+    }\n+\n+    \/**\n+     * Returns a shared scope which is assumed to be always alive.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":64,"deletions":69,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -29,0 +30,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -42,2 +44,3 @@\n- * This interface can be seen as a thin wrapper around the basic capabilities for creating native segments\n- * (e.g. {@link MemorySegment#allocateNative(long, long, ResourceScope)}); since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n+ * This interface can be seen as a thin wrapper around the basic capabilities for\n+ * {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) creating} native segments;\n+ * since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n@@ -46,3 +49,15 @@\n- * This interface also defines factories for commonly used allocators; for instance {@link #arenaUnbounded(ResourceScope)}\n- * and {@link #arenaBounded(long, ResourceScope)} are arena-style native allocators. Finally {@link #prefixAllocator(MemorySegment)}\n- * returns an allocator which wraps a segment (either on-heap or off-heap) and recycles its content upon each new allocation request.\n+ * This interface also defines factories for commonly used allocators:\n+ * <ul>\n+ *     <li>{@link #nativeAllocator(ResourceScope)} creates an allocator which\n+ *     {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) allocates} native segments, backed by a given scope;<\/li>\n+ *     <li>{@link #newNativeArena(ResourceScope)} creates a more efficient arena-style native allocator, where memory\n+ *     is allocated in bigger blocks, which are then sliced accordingly to fit allocation requests;<\/li>\n+ *     <li>{@link #prefixAllocator(MemorySegment)} creates an allocator which wraps a segment (either on-heap or off-heap)\n+ *     and recycles its content upon each new allocation request.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Passing a segment allocator to an API can be especially useful in circumstances where a client wants to communicate <em>where<\/em>\n+ * the results of a certain operation (performed by the API) should be stored, as a memory segment. For instance,\n+ * {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handles} can accept an additional\n+ * {@link SegmentAllocator} parameter if the underlying native function is known to return a struct by-value. Effectively,\n+ * the allocator parameter tells the linker runtime where to store the return value of the native function.\n@@ -55,1 +70,1 @@\n-     * storing the result into a native memory segment allocated using the provided allocator.\n+     * storing the result into a memory segment.\n@@ -71,1 +86,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given byte value.\n+     * Allocate a memory segment with given layout and initialize it with given byte value.\n@@ -86,1 +101,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given char value.\n+     * Allocate a memory segment with given layout and initialize it with given char value.\n@@ -101,1 +116,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given short value.\n+     * Allocate a memory segment with given layout and initialize it with given short value.\n@@ -116,1 +131,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given int value.\n+     * Allocate a memory segment with given layout and initialize it with given int value.\n@@ -131,1 +146,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given float value.\n+     * Allocate a memory segment with given layout and initialize it with given float value.\n@@ -146,1 +161,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given long value.\n+     * Allocate a memory segment with given layout and initialize it with given long value.\n@@ -161,1 +176,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given double value.\n+     * Allocate a memory segment with given layout and initialize it with given double value.\n@@ -176,1 +191,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given address value\n+     * Allocate a memory segment with given layout and initialize it with given address value\n@@ -193,1 +208,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given byte array.\n+     * Allocate a memory segment with given layout and initialize it with given byte array.\n@@ -204,1 +219,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given short array.\n+     * Allocate a memory segment with given layout and initialize it with given short array.\n@@ -215,1 +230,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given char array.\n+     * Allocate a memory segment with given layout and initialize it with given char array.\n@@ -226,1 +241,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given int array.\n+     * Allocate a memory segment with given layout and initialize it with given int array.\n@@ -237,1 +252,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given float array.\n+     * Allocate a memory segment with given layout and initialize it with given float array.\n@@ -248,1 +263,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given long array.\n+     * Allocate a memory segment with given layout and initialize it with given long array.\n@@ -259,1 +274,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given double array.\n+     * Allocate a memory segment with given layout and initialize it with given double array.\n@@ -281,1 +296,1 @@\n-     * Allocate a block of memory  with given layout.\n+     * Allocate a memory segment with given layout.\n@@ -292,1 +307,1 @@\n-     * Allocate a block of memory corresponding to an array with given element layout and size.\n+     * Allocate a memory segment with given element layout and size.\n@@ -304,1 +319,2 @@\n-     * Allocate a block of memory with given size, with default alignment (1-byte aligned).\n+     * Allocate a memory segment with given size\n+     * and default alignment constraints (1-byte aligned).\n@@ -314,1 +330,1 @@\n-     * Allocate a block of memory  with given size and alignment constraint.\n+     * Allocate a memory segment with given size and alignment constraints.\n@@ -322,12 +338,5 @@\n-     * Returns a native arena-based allocator which {@linkplain MemorySegment#allocateNative(long, ResourceScope) allocates}\n-     * a single memory segment, of given size, and then responds to allocation request by returning different slices of that same segment\n-     * (until no further allocation is possible).\n-     * This can be useful when clients want to perform multiple allocation requests while avoiding the cost associated\n-     * with allocating a new off-heap memory region upon each allocation request.\n-     * <p>\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n-     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n-     * the allocator capacity.\n+     * Returns a native unbounded arena-based allocator, with predefined block size and maximum arena size,\n+     * associated with the provided scope. Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    SegmentAllocator.newNativeArena(Long.MAX_VALUE, predefinedBlockSize, scope);\n+     * }<\/pre><\/blockquote>\n@@ -335,1 +344,0 @@\n-     * @param size the size (in bytes) of the allocation arena.\n@@ -337,2 +345,1 @@\n-     * @return a new bounded arena-based allocator\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @return a new unbounded arena-based allocator\n@@ -342,5 +349,2 @@\n-    static SegmentAllocator arenaBounded(long size, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        return scope.ownerThread() == null ?\n-                new ArenaAllocator.BoundedSharedArenaAllocator(scope, size) :\n-                new ArenaAllocator.BoundedArenaAllocator(scope, size);\n+    static SegmentAllocator newNativeArena(ResourceScope scope) {\n+        return newNativeArena(Long.MAX_VALUE, ArenaAllocator.DEFAULT_BLOCK_SIZE, scope);\n@@ -350,27 +354,5 @@\n-     * Returns a native unbounded arena-based allocator, with predefined block size.\n-     * <p>\n-     * The returned allocator {@linkplain MemorySegment#allocateNative(long, ResourceScope) allocates} a memory segment\n-     * {@code S} of a certain (fixed) block size and then responds to allocation requests in one of the following ways:\n-     * <ul>\n-     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has a <em>free<\/em>\n-     *     slice {@code S'} which fits that allocation request, return that {@code S'}.\n-     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has no <em>free<\/em>\n-     *     slices which fits that allocation request, allocate a new segment {@code S'}, which has same size as {@code S}\n-     *     and set {@code S = S'}; the allocator then tries to respond to the same allocation request again.\n-     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'},\n-     *     which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n-     * <\/ul>\n-     * <p>\n-     * The block size of the returned arena-based allocator is unspecified, can be platform-dependent, and should generally\n-     * not be relied upon. Clients can {@linkplain #arenaUnbounded(long, ResourceScope) obtain} an unbounded arena-based allocator\n-     * with specific block size, if they so wish.\n-     * <p>\n-     * This segment allocator can be useful when clients want to perform multiple allocation requests while avoiding the\n-     * cost associated with allocating a new off-heap memory region upon each allocation request.\n-     * <p>\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n-     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n-     * the system capacity.\n+     * Returns a native unbounded arena-based allocator, with block size set to the specified arena size, associated with\n+     * the provided scope, with given arena size. Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    SegmentAllocator.newNativeArena(arenaSize, arenaSize, scope);\n+     * }<\/pre><\/blockquote>\n@@ -378,0 +360,1 @@\n+     * @param arenaSize the size (in bytes) of the allocation arena.\n@@ -380,0 +363,1 @@\n+     * @throws IllegalArgumentException if {@code blockSize <= 0}, if {@code arenaSize <= 0} or if {@code arenaSize < blockSize}.\n@@ -383,2 +367,2 @@\n-    static SegmentAllocator arenaUnbounded(ResourceScope scope) {\n-        return arenaUnbounded(ArenaAllocator.DEFAULT_BLOCK_SIZE, scope);\n+    static SegmentAllocator newNativeArena(long arenaSize, ResourceScope scope) {\n+        return newNativeArena(arenaSize, arenaSize, scope);\n@@ -388,1 +372,1 @@\n-     * Returns a native unbounded arena-based allocator, with given block size.\n+     * Returns a native arena-based allocator, associated with the provided scope, with given arena size and block size.\n@@ -409,2 +393,3 @@\n-     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n-     * the system capacity.\n+     * The returned allocator might throw an {@link OutOfMemoryError} if the total memory allocated with this allocator\n+     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe, and all\n+     * allocation requests should occur within a single thread (regardless of the scope associated with the native arena).\n@@ -412,0 +397,1 @@\n+     * @param arenaSize the size (in bytes) of the allocation arena.\n@@ -415,1 +401,1 @@\n-     * @throws IllegalArgumentException if {@code blockSize <= 0}.\n+     * @throws IllegalArgumentException if {@code blockSize <= 0}, if {@code arenaSize <= 0} or if {@code arenaSize < blockSize}.\n@@ -419,1 +405,1 @@\n-    static SegmentAllocator arenaUnbounded(long blockSize, ResourceScope scope) {\n+    static SegmentAllocator newNativeArena(long arenaSize, long blockSize, ResourceScope scope) {\n@@ -424,3 +410,4 @@\n-        return scope.ownerThread() == null ?\n-                new ArenaAllocator.UnboundedSharedArenaAllocator(blockSize, scope) :\n-                new ArenaAllocator.UnboundedArenaAllocator(blockSize, scope);\n+        if (arenaSize <= 0 || arenaSize < blockSize) {\n+            throw new IllegalArgumentException(\"Invalid arena size: \" + arenaSize);\n+        }\n+        return new ArenaAllocator(blockSize, arenaSize, scope);\n@@ -433,0 +420,6 @@\n+     * Equivalent to (but likely more efficient than) the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment segment = ...\n+    SegmentAllocator prefixAllocator = (size, align) -> segment.asSlice(0, size);\n+     * }<\/pre><\/blockquote>\n+     * <p>\n@@ -445,1 +438,1 @@\n-        return (size, align) -> segment.asSlice(0, size);\n+        return (AbstractMemorySegmentImpl)segment;\n@@ -448,0 +441,14 @@\n+    \/**\n+     * Returns a native allocator, associated with the provided scope. Equivalent to (but likely more efficient than)\n+     * the following code:\n+     * <blockquote><pre>{@code\n+    SegmentAllocator nativeAllocator = (size, align) -> MemorySegment.allocateNative(size, align);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param scope the scope associated with the returned allocator.\n+     * @return a native allocator, associated with the provided scope.\n+     *\/\n+    static SegmentAllocator nativeAllocator(ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        return (ResourceScopeImpl)scope;\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":90,"deletions":83,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * An interface that models a C {@code va_list}.\n+ * An interface that models a variable argument list, similar in functionality to a C {@code va_list}.\n@@ -42,2 +42,2 @@\n- * A va list is a stateful cursor used to iterate over a set of variadic arguments. A va list can be passed\n- * by reference e.g. to a downcall method handle.\n+ * A variable argument list is a stateful cursor used to iterate over a set of arguments. A variable argument list\n+ * can be passed by reference e.g. to a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle}.\n@@ -53,0 +53,3 @@\n+ * This class is not thread safe, and all accesses should occur within a single thread\n+ * (regardless of the scope associated with the variable arity list).\n+ *\n@@ -59,1 +62,1 @@\n-     * Reads the next value as an {@code int} and advances this va list's position.\n+     * Reads the next value as an {@code int} and advances this variable argument list's position.\n@@ -61,4 +64,4 @@\n-     * @param layout the layout of the value\n-     * @return the value read as an {@code int}\n-     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-     * (see {@link #scope()}).\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code int} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -69,1 +72,1 @@\n-     * Reads the next value as a {@code long} and advances this va list's position.\n+     * Reads the next value as a {@code long} and advances this variable argument list's position.\n@@ -71,4 +74,4 @@\n-     * @param layout the layout of the value\n-     * @return the value read as an {@code long}\n-     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-     * (see {@link #scope()}).\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code long} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -79,1 +82,1 @@\n-     * Reads the next value as a {@code double} and advances this va list's position.\n+     * Reads the next value as a {@code double} and advances this variable argument list's position.\n@@ -82,3 +85,3 @@\n-     * @return the value read as an {@code double}\n-     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-     * (see {@link #scope()}).\n+     * @return the {@code double} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -89,1 +92,1 @@\n-     * Reads the next value as a {@code MemoryAddress} and advances this va list's position.\n+     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position.\n@@ -91,4 +94,4 @@\n-     * @param layout the layout of the value\n-     * @return the value read as an {@code MemoryAddress}\n-     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-     * (see {@link #scope()}).\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code MemoryAddress} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -99,1 +102,1 @@\n-     * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n+     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position.\n@@ -103,5 +106,6 @@\n-     * @param layout the layout of the value\n-     * @param allocator the allocator to be used for the native segment allocation\n-     * @return the value read as an {@code MemorySegment}\n-     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-     * (see {@link #scope()}).\n+     * @param layout the layout of the value to be read.\n+     * @param allocator the allocator to be used to create a segment where the contents of the variable argument list\n+     *                  will be copied.\n+     * @return the {@code MemorySegment} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -112,1 +116,1 @@\n-     * Skips a number of elements with the given memory layouts, and advances this va list's position.\n+     * Skips a number of elements with the given memory layouts, and advances this variable argument list's position.\n@@ -114,3 +118,3 @@\n-     * @param layouts the layout of the value\n-     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-     * (see {@link #scope()}).\n+     * @param layouts the layouts of the values to be skipped.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -121,2 +125,2 @@\n-     * Returns the resource scope associated with this instance.\n-     * @return the resource scope associated with this instance.\n+     * Returns the resource scope associated with this variable argument list.\n+     * @return the resource scope associated with this variable argument list.\n@@ -127,11 +131,4 @@\n-     * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-     * starting from the current position, without affecting the state of the original va list, essentially\n-     * allowing the elements to be traversed multiple times.\n-     * <p>\n-     * Any native resource required by the execution of this method will be allocated in the resource scope\n-     * associated with this instance (see {@link #scope()}).\n-     * <p>\n-     * This method only copies the va list cursor itself and not the memory that may be attached to the\n-     * va list which holds its elements. That means that if this va list was created with the\n-     * {@link #make(Consumer, ResourceScope)} method, closing this va list will also release the native memory that holds its\n-     * elements, making the copy unusable.\n+     * Copies this variable argument list at its current position into a new variable argument list associated\n+     * with the same scope as this variable argument list. using the segment provided allocator. Copying is useful to\n+     * traverse the variable argument list elements, starting from the current position, without affecting the state\n+     * of the original variable argument list, essentially allowing the elements to be traversed multiple times.\n@@ -139,3 +136,3 @@\n-     * @return a copy of this C {@code va_list}.\n-     * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-     * (see {@link #scope()}).\n+     * @return a copy of this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -146,2 +143,3 @@\n-     * Returns the memory address associated with this va list.\n-     * @throws IllegalStateException if the scope associated with this va list has been closed, or if access occurs from\n+     * Returns the memory address associated with this variable argument list.\n+     * @throws UnsupportedOperationException if this variable argument list has been allocated using heap segments.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n@@ -149,1 +147,1 @@\n-     * @return The memory address associated with this va list.\n+     * @return The memory address associated with this variable argument list.\n@@ -155,21 +153,1 @@\n-     * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param address a memory address pointing to an existing C {@code va_list}.\n-     * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static VaList ofAddress(MemoryAddress address) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return SharedUtils.newVaListOfAddress(address, ResourceScope.globalScope());\n-    }\n-\n-    \/**\n-     * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n+     * Constructs a new variable argument list from a memory address pointing to an existing variable argument list,\n@@ -183,3 +161,3 @@\n-     * @param address a memory address pointing to an existing C {@code va_list}.\n-     * @param scope the resource scope to be associated with the returned {@code VaList} instance.\n-     * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n+     * @param address a memory address pointing to an existing variable argument list.\n+     * @param scope the resource scope to be associated with the returned variable argument list.\n+     * @return a new variable argument list backed by the memory region at {@code address}.\n@@ -201,2 +179,1 @@\n-     * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a given\n-     * {@linkplain ResourceScope resource scope}.\n+     * Constructs a new variable argument list using a builder (see {@link Builder}), with a given resource scope.\n@@ -211,5 +188,5 @@\n-     *                of the underlying C {@code va_list}.\n-     * @param scope the scope to be used for the valist allocation.\n-     * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n+     *                of the underlying variable argument list.\n+     * @param scope scope the scope to be associated with the new variable arity list.\n+     * @return a new variable argument list.\n+     * @throws IllegalStateException if the scope associated with {@code allocator} has been already closed,\n+     * or if access occurs from a thread other than the thread owning that scope.\n@@ -224,5 +201,4 @@\n-     * Returns an empty C {@code va_list} constant.\n-     * <p>\n-     * The returned {@code VaList} can not be closed.\n-     *\n-     * @return a {@code VaList} modelling an empty C {@code va_list}.\n+     * Returns an empty variable argument list, associated with the {@linkplain ResourceScope#globalScope() global}\n+     * scope. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n+     * on all operations, except for {@link #scope()}, {@link #copy()} and {@link #address()}.\n+     * @return an empty variable argument list.\n@@ -235,1 +211,1 @@\n-     * A builder interface used to construct a C {@code va_list}.\n+     * A builder interface used to construct a variable argument list.\n@@ -243,1 +219,1 @@\n-         * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.\n+         * Writes an {@code int} value to the variable argument list being constructed.\n@@ -245,2 +221,2 @@\n-         * @param layout the native layout of the value.\n-         * @param value the value, represented as an {@code int}.\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code int} value to be written.\n@@ -252,1 +228,1 @@\n-         * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.\n+         * Writes a {@code long} value to the variable argument list being constructed.\n@@ -254,2 +230,2 @@\n-         * @param layout the native layout of the value.\n-         * @param value the value, represented as a {@code long}.\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code long} value to be written.\n@@ -261,1 +237,1 @@\n-         * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.\n+         * Writes a {@code double} value to the variable argument list being constructed.\n@@ -263,2 +239,2 @@\n-         * @param layout the native layout of the value.\n-         * @param value the value, represented as a {@code double}.\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code double} value to be written.\n@@ -270,1 +246,1 @@\n-         * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.\n+         * Writes an {@code Addressable} value to the variable argument list being constructed.\n@@ -272,2 +248,2 @@\n-         * @param layout the native layout of the value.\n-         * @param value the value, represented as a {@code Addressable}.\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code Addressable} value to be written.\n@@ -279,1 +255,1 @@\n-         * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.\n+         * Writes a {@code MemorySegment} value, with given layout, to the variable argument list being constructed.\n@@ -281,2 +257,2 @@\n-         * @param layout the native layout of the value.\n-         * @param value the value, represented as a {@code MemorySegment}.\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code MemorySegment} whose contents will be copied.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":79,"deletions":103,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -36,1 +35,0 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n@@ -38,2 +36,0 @@\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n@@ -46,3 +42,0 @@\n-import static java.lang.constant.ConstantDescs.BSM_GET_STATIC_FINAL;\n-import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newConfinedScope());\n+MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newImplicitScope());\n@@ -75,1 +75,1 @@\n-    MemorySegment segment = scope.allocate(10 * 4);\n+    MemorySegment segment = MemorySegment.allocateNative(10 * 4, scope);\n@@ -86,2 +86,0 @@\n- * Since a resource scope acts as a {@link jdk.incubator.foreign.SegmentAllocator segment allocators}, we can also\n- * allocate the native memory segment more directly, through the scope.\n@@ -121,1 +119,2 @@\n-         var cString = scope.allocateUtf8String(\"Hello\");\n+         var cString = MemorySegment.allocateNative(5 + 1);\n+         cString.setUtf8String(\"Hello\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment, Scoped {\n+public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment, SegmentAllocator, Scoped {\n@@ -146,0 +146,5 @@\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return asSlice(0, bytesSize);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public abstract class ArenaAllocator implements SegmentAllocator {\n+public final class ArenaAllocator implements SegmentAllocator {\n@@ -36,1 +36,1 @@\n-    protected MemorySegment segment;\n+    MemorySegment segment;\n@@ -38,1 +38,5 @@\n-    protected long sp = 0L;\n+    long sp = 0L;\n+    long size = 0;\n+    final long blockSize;\n+    final long arenaSize;\n+    final ResourceScope scope;\n@@ -40,2 +44,5 @@\n-    ArenaAllocator(MemorySegment segment) {\n-        this.segment = segment;\n+    public ArenaAllocator(long blockSize, long arenaSize, ResourceScope scope) {\n+        this.blockSize = blockSize;\n+        this.arenaSize = arenaSize;\n+        this.scope = scope;\n+        this.segment = newSegment(blockSize, 1);\n@@ -56,5 +63,2 @@\n-    void checkConfinementIfNeeded() {\n-        Thread ownerThread = scope().ownerThread();\n-        if (ownerThread != null && ownerThread != Thread.currentThread()) {\n-            throw new IllegalStateException(\"Attempt to allocate outside confinement thread\");\n-        }\n+    public ResourceScope scope() {\n+        return scope;\n@@ -63,2 +67,2 @@\n-    ResourceScope scope() {\n-        return segment.scope();\n+    private MemorySegment newSegment(long size, long align) {\n+        return MemorySegment.allocateNative(size, align, scope);\n@@ -67,16 +71,5 @@\n-    public static class UnboundedArenaAllocator extends ArenaAllocator {\n-\n-        final long blockSize;\n-\n-        public UnboundedArenaAllocator(long blockSize, ResourceScope scope) {\n-            super(MemorySegment.allocateNative(blockSize, 1, scope));\n-            this.blockSize = blockSize;\n-        }\n-\n-        private MemorySegment newSegment(long size, long align) {\n-            return MemorySegment.allocateNative(size, align, segment.scope());\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkConfinementIfNeeded();\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        long prevSp = sp;\n+        long allocatedSize = 0L;\n+        try {\n@@ -86,0 +79,1 @@\n+                allocatedSize = sp - prevSp;\n@@ -91,0 +85,4 @@\n+                    allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n+                    if (size > arenaSize) {\n+                        throw new OutOfMemoryError();\n+                    }\n@@ -94,0 +92,1 @@\n+                    allocatedSize += segment.byteSize() - sp;\n@@ -96,1 +95,3 @@\n-                    return trySlice(bytesSize, bytesAlignment);\n+                    slice = trySlice(bytesSize, bytesAlignment);\n+                    allocatedSize += sp;\n+                    return slice;\n@@ -99,42 +100,4 @@\n-        }\n-    }\n-\n-    public static class BoundedArenaAllocator extends ArenaAllocator {\n-\n-        public BoundedArenaAllocator(ResourceScope scope, long size) {\n-            super(MemorySegment.allocateNative(size, 1, scope));\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkConfinementIfNeeded();\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice != null) {\n-                return slice;\n-            } else {\n-                throw new OutOfMemoryError(\"Not enough space left to allocate\");\n-            }\n-        }\n-    }\n-\n-    public static class BoundedSharedArenaAllocator extends BoundedArenaAllocator {\n-        public BoundedSharedArenaAllocator(ResourceScope scope, long size) {\n-            super(scope, size);\n-        }\n-\n-        @Override\n-        public synchronized MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            return super.allocate(bytesSize, bytesAlignment);\n-        }\n-    }\n-\n-    public static class UnboundedSharedArenaAllocator implements SegmentAllocator {\n-\n-        final ResourceScope scope;\n-        final long blockSize;\n-\n-        final ThreadLocal<ArenaAllocator> allocators = new ThreadLocal<>() {\n-            @Override\n-            protected ArenaAllocator initialValue() {\n-                return new UnboundedArenaAllocator(blockSize, scope);\n+        } finally {\n+            size += allocatedSize;\n+            if (size > arenaSize) {\n+                throw new OutOfMemoryError();\n@@ -142,10 +105,0 @@\n-        };\n-\n-        public UnboundedSharedArenaAllocator(long blockSize, ResourceScope scope) {\n-            this.scope = scope;\n-            this.blockSize = blockSize;\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            return allocators.get().allocate(bytesSize, bytesAlignment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":34,"deletions":81,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -32,1 +31,0 @@\n-import java.lang.ref.Reference;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.nio.file.Path;\n@@ -53,1 +52,1 @@\n-public abstract non-sealed class ResourceScopeImpl implements ResourceScope, ScopedMemoryAccess.Scope, SegmentAllocator {\n+public abstract non-sealed class ResourceScopeImpl implements ResourceScope, SegmentAllocator, ScopedMemoryAccess.Scope {\n@@ -107,0 +106,5 @@\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+    }\n+\n@@ -180,8 +184,0 @@\n-    \/**\n-     * Allocates a segment using this scope.\n-     *\/\n-    @Override\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -35,2 +34,0 @@\n-import java.lang.ref.Reference;\n-import java.util.concurrent.atomic.AtomicBoolean;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -264,2 +264,2 @@\n-            ResourceScope scope = ResourceScope.newConfinedScope(null);\n-            return new Context(SegmentAllocator.arenaBounded(size, scope), scope);\n+            ResourceScope scope = ResourceScope.newConfinedScope();\n+            return new Context(SegmentAllocator.newNativeArena(size, scope), scope);\n@@ -286,1 +286,1 @@\n-            ResourceScope scope = ResourceScope.newConfinedScope(null);\n+            ResourceScope scope = ResourceScope.newConfinedScope();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.stream.IntStream;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.lang.ref.Reference;\n@@ -266,1 +265,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,1 +136,3 @@\n-    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> { throw new IllegalStateException(\"Cannot get here\"); };\n+    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n+        throw new IllegalStateException(\"Cannot get here\");\n+    };\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.incubator.foreign.VaList;\n@@ -102,1 +101,0 @@\n-    private static final Cleaner cleaner = Cleaner.create();\n@@ -127,1 +125,1 @@\n-        ResourceScope scope = ResourceScope.newSharedScope();\n+        ResourceScope scope = ResourceScope.newImplicitScope();\n@@ -131,1 +129,0 @@\n-        cleaner.register(LinuxAArch64VaList.class, () -> ms.scope().close());\n@@ -359,1 +356,1 @@\n-        MemorySegment copy = segment.scope().allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -406,2 +403,2 @@\n-            this.gpRegs = scope.allocate(LAYOUT_GP_REGS);\n-            this.fpRegs = scope.allocate(LAYOUT_FP_REGS);\n+            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n+            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n@@ -500,1 +497,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.VaList;\n@@ -214,1 +213,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import jdk.incubator.foreign.VaList;\n@@ -113,1 +112,0 @@\n-    private static final Cleaner cleaner = Cleaner.create();\n@@ -131,1 +129,1 @@\n-        ResourceScope scope = ResourceScope.newSharedScope();\n+        ResourceScope scope = ResourceScope.newImplicitScope();\n@@ -135,1 +133,0 @@\n-        cleaner.register(SysVVaList.class, () -> base.scope().close());\n@@ -236,1 +233,1 @@\n-                    try (ResourceScope localScope = ResourceScope.newConfinedScope(null)) {\n+                    try (ResourceScope localScope = ResourceScope.newConfinedScope()) {\n@@ -312,1 +309,1 @@\n-        MemorySegment copy = segment.scope().allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -346,1 +343,1 @@\n-            this.reg_save_area = scope.allocate(LAYOUT_REG_SAVE_AREA);\n+            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n@@ -425,1 +422,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.VaList;\n@@ -212,1 +211,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -49,1 +48,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -54,1 +52,3 @@\n-    static SegmentAllocator CONFINED_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newSharedScope());\n+    static SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n+        throw new UnsupportedOperationException();\n+    };\n@@ -379,1 +379,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newSharedScope());\n+            MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -383,1 +383,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1, ResourceScope.newSharedScope());\n+            MemorySegment segment = MemorySegment.allocateNative(1, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,35 +52,0 @@\n-    public static class NativeScope implements SegmentAllocator, AutoCloseable {\n-        final ResourceScope resourceScope;\n-        final ResourceScope privateScope;\n-        final SegmentAllocator allocator;\n-\n-        long allocatedBytes = 0;\n-\n-        public NativeScope() {\n-            this.resourceScope = ResourceScope.newConfinedScope();\n-            this.privateScope = ResourceScope.newConfinedScope();\n-            privateScope.keepAlive(resourceScope);\n-            this.allocator = SegmentAllocator.arenaUnbounded(resourceScope);\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            allocatedBytes += bytesSize;\n-            return allocator.allocate(bytesSize, bytesAlignment);\n-        }\n-\n-        public ResourceScope scope() {\n-            return resourceScope;\n-        }\n-\n-        public long allocatedBytes() {\n-            return allocatedBytes;\n-        }\n-\n-        @Override\n-        public void close() {\n-            privateScope.close();\n-            resourceScope.close();\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), ResourceScope.newConfinedScope());\n+            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,1 +199,2 @@\n-                MemorySegment buf = scope.allocate(s1.length() + s2.length() + 1);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment buf = malloc.allocate(s1.length() + s2.length() + 1);\n@@ -201,1 +202,1 @@\n-                MemorySegment other = scope.allocateUtf8String(s2);\n+                MemorySegment other = malloc.allocateUtf8String(s2);\n@@ -208,2 +209,3 @@\n-                MemorySegment ns1 = scope.allocateUtf8String(s1);\n-                MemorySegment ns2 = scope.allocateUtf8String(s2);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment ns1 = malloc.allocateUtf8String(s1);\n+                MemorySegment ns2 = malloc.allocateUtf8String(s2);\n@@ -216,1 +218,2 @@\n-                MemorySegment s = scope.allocateUtf8String(msg);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment s = malloc.allocateUtf8String(msg);\n@@ -223,1 +226,2 @@\n-                MemorySegment s = scope.allocateUtf8String(msg);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment s = malloc.allocateUtf8String(msg);\n@@ -230,1 +234,1 @@\n-                MemorySegment time = scope.allocate(8);\n+                MemorySegment time = MemorySegment.allocateNative(8, scope);\n@@ -279,1 +283,2 @@\n-                MemorySegment nativeArr = scope.allocateArray(C_INT, arr);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment nativeArr = malloc.allocateArray(C_INT, arr);\n@@ -302,1 +307,2 @@\n-                MemorySegment formatStr = scope.allocateUtf8String(format);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment formatStr = malloc.allocateUtf8String(format);\n@@ -310,1 +316,2 @@\n-                MemorySegment formatStr = scope.allocateUtf8String(format);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment formatStr = malloc.allocateUtf8String(format);\n@@ -388,1 +395,5 @@\n-        STRING(MemoryAddress.class, C_POINTER, \"%s\", scope -> scope.allocateUtf8String(\"str\").address(), \"str\", VaList.Builder::addVarg),\n+        STRING(MemoryAddress.class, C_POINTER, \"%s\", scope -> {\n+            var segment = MemorySegment.allocateNative(4, scope);\n+            segment.setUtf8String(0, \"str\");\n+            return segment.address();\n+        }, \"str\", VaList.Builder::addVarg),\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -117,1 +117,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -138,1 +138,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -215,1 +215,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -258,1 +258,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -296,1 +296,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -335,1 +335,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -378,1 +378,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n@@ -500,1 +500,1 @@\n-        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newSharedScope());\n@@ -508,1 +508,1 @@\n-        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newSharedScope());\n@@ -567,1 +567,1 @@\n-        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n@@ -729,0 +729,1 @@\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newImplicitScope()) },\n@@ -737,2 +738,5 @@\n-                { (Supplier<ResourceScope>)ResourceScope::newConfinedScope },\n-                { (Supplier<ResourceScope>)ResourceScope::newSharedScope }\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope()   },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope() },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope(Cleaner.create())   },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newImplicitScope() }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -71,1 +72,1 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n@@ -73,1 +74,4 @@\n-            Object res = doCall(addr, scope, mt, descriptor, args);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(scope) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n@@ -78,5 +82,1 @@\n-                    assertEquals(((MemorySegment) res).scope(), scope.scope());\n-                    assertEquals(scope.allocatedBytes(), descriptor.returnLayout().get().byteSize());\n-                } else {\n-                    \/\/ if here, there should be no allocation through the scope!\n-                    assertEquals(scope.allocatedBytes(), 0L);\n+                    assertEquals(((MemorySegment) res).scope(), scope);\n@@ -84,3 +84,0 @@\n-            } else {\n-                \/\/ if here, there should be no allocation through the scope!\n-                assertEquals(scope.allocatedBytes(), 0L);\n@@ -91,20 +88,1 @@\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testDowncallNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<Consumer<Object>> checks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n-        MethodType mt = methodType(ret, paramTypes, fields);\n-        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n-        Object[] args = makeArgs(paramTypes, fields, checks);\n-        boolean needsScope = mt.returnType().equals(MemorySegment.class);\n-        Object res = doCall(addr, CONFINED_ALLOCATOR, mt, descriptor, args);\n-        if (ret == Ret.NON_VOID) {\n-            checks.forEach(c -> c.accept(res));\n-            if (needsScope) {\n-                \/\/ check that return struct has indeed been allocated in the default scope\n-                ((MemorySegment)res).scope().close(); \/\/ should be ok\n-            }\n-        }\n-    }\n-\n-\n-    Object doCall(NativeSymbol symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+    Object doCall(NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":8,"deletions":30,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n+        NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,2 +186,2 @@\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newConfinedScope());\n-        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newSharedScope());\n+        addDefaultMapping(SegmentAllocator.class, SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[10])));\n@@ -203,1 +203,1 @@\n-            }, ResourceScope.newConfinedScope());\n+            }, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,3 @@\n-        ResourceScope scope = ResourceScope.newConfinedScope(cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newConfinedScope(cleaner) :\n+                ResourceScope.newConfinedScope();\n@@ -78,1 +80,3 @@\n-        ResourceScope scope = ResourceScope.newSharedScope(cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newSharedScope(cleaner) :\n+                ResourceScope.newSharedScope();\n@@ -102,1 +106,3 @@\n-        ResourceScope scope = ResourceScope.newSharedScope(cleaner);\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newSharedScope(cleaner) :\n+                ResourceScope.newSharedScope();\n@@ -297,0 +303,1 @@\n+                { (Supplier<ResourceScope>)ResourceScope::newImplicitScope },\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.function.BiConsumer;\n@@ -51,1 +50,0 @@\n-import java.util.function.Supplier;\n@@ -131,1 +129,1 @@\n-        ScopedOperation.ofScope(SegmentAllocator::arenaUnbounded, \"SegmentAllocator::arenaAllocator\");\n+        ScopedOperation.ofScope(SegmentAllocator::newNativeArena, \"SegmentAllocator::arenaAllocator\");\n@@ -146,1 +144,2 @@\n-        ScopedOperation.ofVaList(list -> list.nextVarg(MemoryLayout.structLayout(ValueLayout.JAVA_INT), ResourceScope.newConfinedScope()), \"VaList::vargAsSegment\/1\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(MemoryLayout.structLayout(ValueLayout.JAVA_INT),\n+                SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[4]))), \"VaList::nextVargs\/segment\");\n@@ -258,2 +257,2 @@\n-            ARENA_BOUNDED(scope -> SegmentAllocator.arenaBounded(1000, scope)),\n-            ARENA_UNBOUNDED(SegmentAllocator::arenaUnbounded);\n+            ARENA_BOUNDED(scope -> SegmentAllocator.newNativeArena(1000, scope)),\n+            ARENA_UNBOUNDED(SegmentAllocator::newNativeArena);\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                        allocationFunction.allocate(allocator, alignedLayout, value); \/\/too much, should fail if bound\n+                        allocationFunction.allocate(allocator, alignedLayout, value);\n@@ -106,1 +106,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaUnbounded(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -120,1 +120,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaBounded(10, scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(10, scope);\n@@ -128,1 +128,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaBounded(4 * 1024 * 2, scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(4 * 1024 * 2, scope);\n@@ -135,1 +135,1 @@\n-        SegmentAllocator.arenaUnbounded(-1, ResourceScope.globalScope());\n+        SegmentAllocator.newNativeArena( -1, ResourceScope.globalScope());\n@@ -388,2 +388,2 @@\n-        static AllocationFactory BOUNDED = new AllocationFactory(true, SegmentAllocator::arenaBounded);\n-        static AllocationFactory UNBOUNDED = new AllocationFactory(false, (size, scope) -> SegmentAllocator.arenaUnbounded(scope));\n+        static AllocationFactory BOUNDED = new AllocationFactory(true, SegmentAllocator::newNativeArena);\n+        static AllocationFactory UNBOUNDED = new AllocationFactory(false, (size, scope) -> SegmentAllocator.newNativeArena(scope));\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        MemorySegment.allocateNative(size, align, ResourceScope.newConfinedScope());\n+        MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n@@ -57,1 +57,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE, ResourceScope.newConfinedScope());\n+        MemorySegment.allocateNative(Long.MAX_VALUE, ResourceScope.newImplicitScope());\n@@ -62,1 +62,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, ResourceScope.newConfinedScope()); \/\/ 2M\n+        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, ResourceScope.newImplicitScope()); \/\/ 2M\n@@ -102,1 +102,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n@@ -109,1 +109,1 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newConfinedScope());\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n@@ -136,6 +136,6 @@\n-                () -> MemorySegment.allocateNative(4, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(4, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope())\n+                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope())\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -42,1 +43,2 @@\n-            MemorySegment text = scope.allocateUtf8String(testString);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(expectedByteLength, scope);\n+            MemorySegment text = allocator.allocateUtf8String(testString);\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -101,1 +102,1 @@\n-        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newSharedScope());\n+        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n@@ -116,3 +117,4 @@\n-        try (NativeScope scope = new NativeScope()) {\n-            MethodHandle mh = downcallHandle(abi, addr, scope, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(scope.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n@@ -128,18 +130,0 @@\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcallsNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        checkSelected(TestType.NO_SCOPE);\n-\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n-        MethodHandle mh = downcallHandle(abi, addr, CONFINED_ALLOCATOR, function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(ResourceScope.newSharedScope(), ret, paramTypes, fields, returnChecks, argChecks);\n-        Object[] callArgs = args;\n-        Object res = mh.invokeWithArguments(callArgs);\n-        argChecks.forEach(c -> c.accept(args));\n-        if (ret == Ret.NON_VOID) {\n-            returnChecks.forEach(c -> c.accept(res));\n-        }\n-    }\n-\n-\n@@ -152,1 +136,2 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -154,2 +139,2 @@\n-            MethodHandle mh = reverse(downcallHandle(abi, addr, CONFINED_ALLOCATOR, descriptor));\n-            Object[] args = makeArgs(ResourceScope.newSharedScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+            MethodHandle mh = reverse(downcallHandle(abi, addr, allocator, descriptor));\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -162,1 +147,1 @@\n-            NativeSymbol callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n+            NativeSymbol callback = abi.upcallStub(mh, callbackDesc, scope);\n@@ -167,1 +152,1 @@\n-                    ? invoker.invoke(scope, callback)\n+                    ? invoker.invoke(allocator, callback)\n@@ -264,1 +249,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newSharedScope());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":13,"deletions":28,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newConfinedScope());\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1, 2, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(1, 2, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-                new ScopeSupplier(() -> ResourceScope.newConfinedScope(), \"newConfinedScope()\");\n+                new ScopeSupplier(ResourceScope::newConfinedScope, \"newConfinedScope()\");\n@@ -184,1 +184,3 @@\n-                new ScopeSupplier(() -> ResourceScope.newSharedScope(), \"newSharedScope()\");\n+                new ScopeSupplier(ResourceScope::newSharedScope, \"newSharedScope()\");\n+        static final Supplier<ResourceScope> NEW_IMPLICIT =\n+                new ScopeSupplier(ResourceScope::newImplicitScope, \"newImplicitScope()\");\n@@ -186,1 +188,1 @@\n-                new ScopeSupplier(() -> ResourceScope.globalScope(), \"globalScope()\");\n+                new ScopeSupplier(ResourceScope::globalScope, \"globalScope()\");\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -78,2 +79,2 @@\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newConfinedScope());\n-        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n+        addDefaultMapping(SegmentAllocator.class, SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[10])));\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,3 +55,0 @@\n-                    { MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\",\n-                            MethodType.methodType(VaList.class, MemoryAddress.class)),\n-                            \"VaList::ofAddress\/1\" },\n@@ -60,1 +57,1 @@\n-                            \"VaList::ofAddress\/2\" },\n+                            \"VaList::ofAddress\/1\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        MemorySegment seg = MemorySegment.ofAddressNative(ma, 4L, ResourceScope.newConfinedScope());\n+        MemorySegment seg = MemorySegment.ofAddressNative(ma, 4L, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class));\n+            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class));\n@@ -132,10 +132,10 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> winVaListScopedFactory\n-            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> sysvVaListScopedFactory\n-            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> linuxAArch64VaListScopedFactory\n-            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> macAArch64VaListScopedFactory\n-            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> platformVaListScopedFactory\n-            = (builder, scope) -> VaList.make(builder, scope.scope());\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> winVaListScopedFactory\n+            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> sysvVaListScopedFactory\n+            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> linuxAArch64VaListScopedFactory\n+            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> macAArch64VaListScopedFactory\n+            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> platformVaListScopedFactory\n+            = (builder, scope) -> VaList.make(builder, scope);\n@@ -243,1 +243,2 @@\n-                    MemorySegment struct = list.nextVarg(pointLayout, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, ResourceScope.newImplicitScope());\n+                    list.nextVarg(pointLayout, SegmentAllocator.prefixAllocator(struct));\n@@ -296,1 +297,2 @@\n-                    MemorySegment struct = list.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -349,1 +351,2 @@\n-                    MemorySegment struct = list.nextVarg(FloatPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -407,1 +410,2 @@\n-                    MemorySegment struct = list.nextVarg(HugePoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -578,1 +582,1 @@\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> vaListFactory,\n+    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> vaListFactory,\n@@ -582,1 +586,1 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n@@ -584,2 +588,1 @@\n-                            .addVarg(intLayout, 8),\n-                    scope);\n+                            .addVarg(intLayout, 8), scope);\n@@ -598,1 +601,1 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n@@ -604,1 +607,2 @@\n-                pointOut = list.nextVarg(Point_LAYOUT, scope);\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, scope);\n+                list.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(pointOut));\n@@ -688,1 +692,2 @@\n-                    MemorySegment struct = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -694,1 +699,2 @@\n-                    MemorySegment struct = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -702,1 +708,1 @@\n-                    struct = copy.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    copy.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -707,1 +713,2 @@\n-                    MemorySegment struct = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -718,1 +725,2 @@\n-                    MemorySegment struct = vaList.nextVarg(Point_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -723,1 +731,2 @@\n-                    MemorySegment struct = vaList.nextVarg(HugePoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -729,1 +738,2 @@\n-                    MemorySegment struct = vaList.nextVarg(FloatPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -774,1 +784,4 @@\n-                    MemorySegment point = vaList.nextVarg(Point_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    SegmentAllocator bufferAllocator = SegmentAllocator.prefixAllocator(buffer);\n+\n+                    MemorySegment point = vaList.nextVarg(Point_LAYOUT, bufferAllocator);\n@@ -779,1 +792,1 @@\n-                    MemorySegment bigPoint = vaList.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment bigPoint = vaList.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n@@ -787,1 +800,1 @@\n-                    MemorySegment struct = copy.nextVarg(BigPoint_LAYOUT, ResourceScope.newConfinedScope());\n+                    MemorySegment struct = copy.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n@@ -812,1 +825,2 @@\n-                return MethodHandles.filterArguments(handle, 0, ADDRESS_TO_VALIST);\n+                return MethodHandles.filterArguments(handle, 0,\n+                        MethodHandles.insertArguments(ADDRESS_TO_VALIST, 1, ResourceScope.newConfinedScope()));\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":46,"deletions":32,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-        SHARED(ResourceScope::newSharedScope);\n+        SHARED(ResourceScope::newSharedScope),\n+        IMPLICIT(ResourceScope::newImplicitScope);\n@@ -131,1 +132,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n@@ -152,1 +153,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n@@ -87,1 +87,1 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n@@ -89,1 +89,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope()));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newImplicitScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n@@ -95,1 +95,1 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n@@ -141,1 +141,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newSharedScope());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newConfinedScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n@@ -114,1 +114,1 @@\n-        try (ResourceScope scope = ResourceScope.newSharedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n@@ -120,2 +120,2 @@\n-    public MemorySegment confined_implicit() {\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n+    public MemorySegment implicit_close() {\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n@@ -125,12 +125,1 @@\n-    public MemorySegment shared_implicit() {\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newSharedScope());\n-    }\n-\n-    @Benchmark\n-    public MemorySegment confined_implicit_systemgc() {\n-        if (gcCount++ == 0) System.gc(); \/\/ GC when we overflow\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n-    }\n-\n-    @Benchmark\n-    public MemorySegment shared_implicit_systemgc() {\n+    public MemorySegment implicit_close_systemgc() {\n@@ -138,1 +127,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newSharedScope());\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ResourceScopeClose.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    ResourceScope scope = ResourceScope.newConfinedScope();\n+    ResourceScope scope = ResourceScope.newImplicitScope();\n@@ -63,1 +63,1 @@\n-    SegmentAllocator arenaAllocator = SegmentAllocator.arenaUnbounded(scope);\n+    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(scope);\n@@ -99,2 +99,3 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n-            MemorySegment segment = scope.allocateUtf8String(str);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, scope);\n+            segment.setUtf8String(0, str);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size, ResourceScope.newConfinedScope());\n+        srcSegmentImplicit = MemorySegment.allocateNative(size, ResourceScope.newImplicitScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope(null)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        this(MemorySegment.allocateNative(LAYOUT, ResourceScope.newConfinedScope(null)), x, y);\n+        this(MemorySegment.allocateNative(LAYOUT, ResourceScope.newConfinedScope()), x, y);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-    implicitScope = ResourceScope.newConfinedScope();\n+    implicitScope = ResourceScope.newImplicitScope();\n@@ -242,1 +242,1 @@\n-    try (final var scope = ResourceScope.newConfinedScope(null)) {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    implicitScope = ResourceScope.newConfinedScope();\n+    implicitScope = ResourceScope.newSharedScope();\n@@ -212,1 +212,1 @@\n-    try (final var scope = ResourceScope.newConfinedScope(null)) {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}