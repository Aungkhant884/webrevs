{"files":[{"patch":"@@ -367,0 +367,5 @@\n+bool frame::optimized_entry_frame_is_first() const {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -316,0 +316,5 @@\n+bool frame::optimized_entry_frame_is_first() const {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,0 +200,5 @@\n+bool frame::optimized_entry_frame_is_first() const {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -211,0 +211,5 @@\n+bool frame::optimized_entry_frame_is_first() const {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -361,0 +361,7 @@\n+bool frame::optimized_entry_frame_is_first() const {\n+  assert(is_optimized_entry_frame(), \"must be optimzed entry frame\");\n+  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  return jfa->last_Java_sp() == NULL;\n+}\n+\n@@ -367,0 +374,1 @@\n+  assert(!optimized_entry_frame_is_first(), \"must have a frame anchor to go back to\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,0 +64,5 @@\n+bool frame::optimized_entry_frame_is_first() const {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2309,0 +2309,1 @@\n+  ResourceMark rm; \/\/ for verify\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -345,0 +345,1 @@\n+  bool optimized_entry_frame_is_first() const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-  return is_entry_frame() && entry_frame_is_first();\n+  return (is_entry_frame() && entry_frame_is_first())\n+      || (is_optimized_entry_frame() && optimized_entry_frame_is_first());\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   TestAsyncStackWalk\n+ *\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:.\n+ *   -XX:+UnlockDiagnosticVMOptions\n+ *   -XX:+WhiteBoxAPI\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Xbatch\n+ *   TestAsyncStackWalk\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import sun.hotspot.WhiteBox;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestAsyncStackWalk {\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    static final CLinker linker = CLinker.getInstance();\n+\n+    static final MethodHandle MH_asyncStackWalk;\n+    static final MethodHandle MH_m;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"AsyncStackWalk\");\n+            SymbolLookup lookup = SymbolLookup.loaderLookup();\n+            MH_asyncStackWalk = linker.downcallHandle(\n+                    lookup.lookup(\"asyncStackWalk\").get(),\n+                    MethodType.methodType(void.class, MemoryAddress.class),\n+                    FunctionDescriptor.ofVoid(C_POINTER));\n+            MH_m = lookup().findStatic(TestAsyncStackWalk.class, \"m\", MethodType.methodType(void.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static int invocations;\n+    static boolean didStackWalk;\n+\n+    public static void main(String[] args) throws Throwable {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            MemoryAddress stubAddress = stub.address();\n+            invocations = 0;\n+            didStackWalk = false;\n+            payload(stubAddress);\n+            assertTrue(didStackWalk);\n+        }\n+    }\n+\n+    static void payload(MemoryAddress cb) throws Throwable {\n+        MH_asyncStackWalk.invokeExact(cb);\n+    }\n+\n+    static void m() {\n+        if (invocations++ >= 20000) { \/\/ warmup\n+            didStackWalk = true;\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/true);\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/false); \/\/ triggers different code paths\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#include <thread>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+static void start(void (*cb)(void)) {\n+    for (int i = 0; i < 25000; i++) {\n+        cb();\n+    }\n+}\n+\n+extern \"C\" {\n+EXPORT void asyncStackWalk(void (*cb)(void)) {\n+    std::thread thrd(start, cb);\n+    thrd.join();\n+}\n+}\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/libAsyncStackWalk.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}