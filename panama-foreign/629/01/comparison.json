{"files":[{"patch":"@@ -536,1 +536,1 @@\n-java\/foreign\/TestUpcall.java#stack 8275584 macosx-aarch64\n+java\/foreign\/TestUpcallStack.java 8275584 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Note: to run this test manually, you need to build the tests first to get native\n- * libraries compiled, and then execute it with plain jtreg, like:\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n@@ -5,11 +5,3 @@\n- *  $ bin\/jtreg -jdk:<path-to-tested-jdk> \\\n- *              -nativepath:<path-to-build-dir>\/support\/test\/jdk\/jtreg\/native\/lib\/ \\\n- *              -concurrency:auto \\\n- *              .\/test\/jdk\/java\/foreign\/TestMatrix.java\n- *\/\n-\n-\/*\n- * @test id=UpcallHighArity-FFTT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n@@ -17,13 +9,5 @@\n- * @run testng\/othervm\/native\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n- *\/\n-\n-\/* @test id=UpcallHighArity-TFTT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n@@ -31,13 +15,3 @@\n- * @run testng\/othervm\/native\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n- *\/\n-\n-\/* @test id=UpcallHighArity-FTTT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n@@ -45,7 +19,3 @@\n- * @run testng\/othervm\/native\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n@@ -54,4 +24,3 @@\n-\/* @test id=UpcallHighArity-TTTT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+\/*\n+ * Note: to run this test manually, you need to build the tests first to get native\n+ * libraries compiled, and then execute it with plain jtreg, like:\n@@ -59,7 +28,4 @@\n- * @run testng\/othervm\/native\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n+ *  $ bin\/jtreg -jdk:<path-to-tested-jdk> \\\n+ *              -nativepath:<path-to-build-dir>\/support\/test\/jdk\/jtreg\/native\/lib\/ \\\n+ *              -concurrency:auto \\\n+ *              .\/test\/jdk\/java\/foreign\/TestMatrix.java\n@@ -68,1 +34,1 @@\n-\/* @test id=UpcallHighArity-FFTF\n+\/* @test id=UpcallHighArity-FF\n@@ -73,1 +39,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -76,3 +42,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n@@ -82,1 +46,1 @@\n-\/* @test id=UpcallHighArity-TFTF\n+\/* @test id=UpcallHighArity-TF\n@@ -87,1 +51,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -90,3 +54,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n@@ -96,1 +58,1 @@\n-\/* @test id=UpcallHighArity-FTTF\n+\/* @test id=UpcallHighArity-FT\n@@ -101,1 +63,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -104,1 +66,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -106,1 +67,0 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n@@ -110,1 +70,1 @@\n-\/* @test id=UpcallHighArity-TTTF\n+\/* @test id=UpcallHighArity-TT\n@@ -115,1 +75,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -118,1 +78,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -120,1 +79,0 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n@@ -124,1 +82,1 @@\n-\/* @test id=UpcallHighArity-FFFT\n+\/* @test id=Downcall-F\n@@ -127,1 +85,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncall\n@@ -129,1 +87,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -132,4 +90,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n+ *   TestDowncall\n@@ -138,1 +93,1 @@\n-\/* @test id=UpcallHighArity-TFFT\n+\/* @test id=Downcall-T\n@@ -141,1 +96,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestDowncall\n@@ -143,1 +98,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -146,4 +101,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n+ *   TestDowncall\n@@ -152,1 +104,1 @@\n-\/* @test id=UpcallHighArity-FTFT\n+\/* @test id=UpcallScope-FF\n@@ -155,1 +107,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -157,1 +109,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -160,1 +112,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -162,2 +113,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n+ *   TestUpcallScope\n@@ -166,1 +116,1 @@\n-\/* @test id=UpcallHighArity-TTFT\n+\/* @test id=UpcallScope-TF\n@@ -169,1 +119,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -171,1 +121,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -174,1 +124,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -176,2 +125,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n+ *   TestUpcallScope\n@@ -180,1 +128,1 @@\n-\/* @test id=UpcallHighArity-FFFF\n+\/* @test id=UpcallScope-FT\n@@ -183,1 +131,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -185,1 +133,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -188,4 +136,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallScope\n@@ -194,1 +140,1 @@\n-\/* @test id=UpcallHighArity-TFFF\n+\/* @test id=UpcallScope-TT\n@@ -197,1 +143,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -199,1 +145,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -202,4 +148,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallScope\n@@ -208,1 +152,1 @@\n-\/* @test id=UpcallHighArity-FTFF\n+\/* @test id=UpcallAsync-FF\n@@ -211,1 +155,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -213,1 +157,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -216,1 +160,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -218,2 +161,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n+ *   TestUpcallAsync\n@@ -222,1 +164,1 @@\n-\/* @test id=UpcallHighArity-TTFF\n+\/* @test id=UpcallAsync-TF\n@@ -225,1 +167,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -227,1 +169,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -230,1 +172,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -232,2 +173,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n+ *   TestUpcallAsync\n@@ -236,1 +176,1 @@\n-\/* @test id=Downcall-FF\n+\/* @test id=UpcallAsync-FT\n@@ -239,1 +179,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestDowncall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -241,1 +181,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -244,49 +184,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- *\/\n-\n-\/* @test id=Downcall-TF\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestDowncall\n- *\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- *\/\n-\n-\/* @test id=Downcall-FT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestDowncall\n- *\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestDowncall\n- *\/\n-\n-\/* @test id=Downcall-TT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestDowncall\n- *\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestDowncall\n- *\/\n-\n-\/* @test id=Upcall-TFTT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n@@ -294,2 +185,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcall\n+ *   TestUpcallAsync\n@@ -298,1 +188,1 @@\n-\/* @test id=Upcall-FTTT\n+\/* @test id=UpcallAsync-TT\n@@ -301,1 +191,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -303,15 +193,1 @@\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcall\n- *\/\n-\n-\/* @test id=Upcall-TTTT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -320,1 +196,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n@@ -322,2 +197,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcall\n+ *   TestUpcallAsync\n@@ -326,1 +200,1 @@\n-\/* @test id=Upcall-TFTF\n+\/* @test id=UpcallStack-FF\n@@ -329,1 +203,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -331,15 +205,1 @@\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcall\n- *\/\n-\n-\/* @test id=Upcall-FTTF\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -348,29 +208,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcall\n- *\/\n-\n-\/* @test id=Upcall-TTTF\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcall\n- *\/\n-\n-\/* @test id=Upcall-TFFT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n@@ -378,2 +209,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcall\n+ *   TestUpcallStack\n@@ -382,1 +212,1 @@\n-\/* @test id=Upcall-FTFT\n+\/* @test id=UpcallStack-TF\n@@ -385,1 +215,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -387,29 +217,1 @@\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcall\n- *\/\n-\n-\/* @test id=Upcall-TTFT\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm\/manual\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n- *   TestUpcall\n- *\/\n-\n-\/* @test id=Upcall-TFFF\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -418,1 +220,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n@@ -420,2 +221,1 @@\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcall\n+ *   TestUpcallStack\n@@ -424,1 +224,1 @@\n-\/* @test id=Upcall-FTFF\n+\/* @test id=UpcallStack-FT\n@@ -427,1 +227,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -429,1 +229,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -432,4 +232,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcall\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallStack\n@@ -438,1 +236,1 @@\n-\/* @test id=Upcall-TTFF\n+\/* @test id=UpcallStack-TT\n@@ -441,1 +239,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -443,1 +241,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -446,4 +244,2 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n- *   TestUpcall\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   TestUpcallStack\n@@ -451,0 +247,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":94,"deletions":297,"binary":false,"changes":391,"status":"modified"},{"patch":"@@ -1,329 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=scope\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=SCOPE\n- *   TestUpcall\n- *\/\n-\n-\/*\n- * @test id=async\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=ASYNC\n- *   TestUpcall\n- *\/\n-\n-\/*\n- * @test id=stack\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=STACK\n- *   TestUpcall\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.SkipException;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.lang.invoke.MethodHandles.insertArguments;\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestUpcall extends CallGeneratorHelper {\n-\n-    private enum TestType {\n-        SCOPE,\n-        ASYNC,\n-        STACK\n-    }\n-\n-    private static final TestType UPCALL_TEST_TYPE = TestType.valueOf(System.getProperty(\"UPCALL_TEST_TYPE\"));\n-\n-    static {\n-        System.loadLibrary(\"TestUpcall\");\n-        System.loadLibrary(\"TestUpcallStack\");\n-        System.loadLibrary(\"AsyncInvokers\");\n-    }\n-    static CLinker abi = CLinker.systemCLinker();\n-\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n-    static MethodHandle DUMMY;\n-    static MethodHandle PASS_AND_SAVE;\n-\n-    static {\n-        try {\n-            DUMMY = MethodHandles.lookup().findStatic(TestUpcall.class, \"dummy\", MethodType.methodType(void.class));\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\",\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n-        } catch (Throwable ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    static NativeSymbol dummyStub;\n-\n-    @BeforeClass\n-    void setup() {\n-        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n-    }\n-\n-    private static void checkSelected(TestType type) {\n-        if (UPCALL_TEST_TYPE != type)\n-            throw new SkipException(\"Skipping tests that were not selected\");\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcalls(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        checkSelected(TestType.SCOPE);\n-\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n-            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n-            Object[] callArgs = args;\n-            Object res = mh.invokeWithArguments(callArgs);\n-            argChecks.forEach(c -> c.accept(args));\n-            if (ret == Ret.NON_VOID) {\n-                returnChecks.forEach(c -> c.accept(res));\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        checkSelected(TestType.ASYNC);\n-\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n-            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n-            MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n-            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n-\n-            mh = mh.asSpreader(Object[].class, args.length);\n-            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n-            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n-                    .map(FunctionDescriptor::of)\n-                    .orElse(FunctionDescriptor.ofVoid());\n-            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n-\n-            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n-\n-            Object res = invoker.type().returnType() == MemorySegment.class\n-                    ? invoker.invoke(allocator, callback)\n-                    : invoker.invoke(callback);\n-            argChecks.forEach(c -> c.accept(args));\n-            if (ret == Ret.NON_VOID) {\n-                returnChecks.forEach(c -> c.accept(res));\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        checkSelected(TestType.STACK);\n-\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n-            MethodHandle mh = downcallHandle(abi, addr, allocator, functionStack(ret, paramTypes, fields));\n-            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n-            Object[] callArgs = args;\n-            Object res = mh.invokeWithArguments(callArgs);\n-            argChecks.forEach(c -> c.accept(args));\n-            if (ret == Ret.NON_VOID) {\n-                returnChecks.forEach(c -> c.accept(res));\n-            }\n-        }\n-    }\n-\n-    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n-\n-    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n-        if (ret == Ret.VOID) {\n-            String name = \"call_async_V\";\n-            return INVOKERS.computeIfAbsent(name, symbol ->\n-                    abi.downcallHandle(\n-                            LOOKUP.lookup(symbol).orElseThrow(),\n-                            FunctionDescriptor.ofVoid(C_POINTER)));\n-        }\n-\n-        String name = \"call_async_\" + returnType.name().charAt(0)\n-                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n-\n-        return INVOKERS.computeIfAbsent(name, symbol -> {\n-            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n-            MemoryLayout returnLayout = returnType.layout(fields);\n-            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n-\n-            return abi.downcallHandle(invokerSymbol, desc);\n-        });\n-    }\n-\n-    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        return function(ret, params, fields, List.of());\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n-        List<MemoryLayout> paramLayouts = params.stream().map(p -> p.layout(fields)).collect(Collectors.toList());\n-        paramLayouts.add(C_POINTER); \/\/ the callback\n-        MemoryLayout[] layouts = Stream.concat(prefix.stream(), paramLayouts.stream()).toArray(MemoryLayout[]::new);\n-        return ret == Ret.VOID ?\n-                FunctionDescriptor.ofVoid(layouts) :\n-                FunctionDescriptor.of(layouts[prefix.size()], layouts);\n-    }\n-\n-    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n-    }\n-\n-    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n-    }\n-\n-    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n-        Object[] args = new Object[prefix.size() + params.size() + 1];\n-        int argNum = 0;\n-        for (MemoryLayout layout : prefix) {\n-            args[argNum++] = makeArg(layout, null, false);\n-        }\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n-        }\n-        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n-        return args;\n-    }\n-\n-    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n-        if (params.isEmpty()) {\n-            return dummyStub;\n-        }\n-\n-        AtomicReference<Object[]> box = new AtomicReference<>();\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n-        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n-\n-        for(int i = 0; i < prefix.size(); i++) {\n-            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n-        }\n-\n-        for (int i = 0; i < params.size(); i++) {\n-            ParamType pt = params.get(i);\n-            MemoryLayout layout = pt.layout(fields);\n-            Class<?> carrier = carrier(layout, false);\n-            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n-\n-            final int finalI = prefix.size() + i;\n-            if (carrier == MemorySegment.class) {\n-                argChecks.add(o -> assertStructEquals((MemorySegment) box.get()[finalI], (MemorySegment) o[finalI], layout));\n-            } else {\n-                argChecks.add(o -> assertEquals(box.get()[finalI], o[finalI]));\n-            }\n-        }\n-\n-        ParamType firstParam = params.get(0);\n-        MemoryLayout firstlayout = firstParam.layout(fields);\n-        Class<?> firstCarrier = carrier(firstlayout, true);\n-\n-        if (firstCarrier == MemorySegment.class) {\n-            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n-        } else {\n-            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n-        }\n-\n-        mh = mh.asType(mh.type().changeReturnType(ret == Ret.VOID ? void.class : firstCarrier));\n-\n-        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n-        FunctionDescriptor func = ret != Ret.VOID\n-                ? FunctionDescriptor.of(firstlayout, paramLayouts)\n-                : FunctionDescriptor.ofVoid(paramLayouts);\n-        return abi.upcallStub(mh, func, scope);\n-    }\n-\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n-        for (int i = 0; i < o.length; i++) {\n-            if (o[i] instanceof MemorySegment) {\n-                MemorySegment ms = (MemorySegment) o[i];\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n-                copy.copyFrom(ms);\n-                o[i] = copy;\n-            }\n-        }\n-        ref.set(o);\n-        return o[retArg];\n-    }\n-\n-    static void dummy() {\n-        \/\/do nothing\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":0,"deletions":329,"binary":false,"changes":329,"status":"deleted"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestUpcallAsync\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+public class TestUpcallAsync extends TestUpcallBase {\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(allocator, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n+\n+    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n+        if (ret == Ret.VOID) {\n+            String name = \"call_async_V\";\n+            return INVOKERS.computeIfAbsent(name, symbol ->\n+                    abi.downcallHandle(\n+                            LOOKUP.lookup(symbol).orElseThrow(),\n+                            FunctionDescriptor.ofVoid(C_POINTER)));\n+        }\n+\n+        String name = \"call_async_\" + returnType.name().charAt(0)\n+                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n+\n+        return INVOKERS.computeIfAbsent(name, symbol -> {\n+            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            MemoryLayout returnLayout = returnType.layout(fields);\n+            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n+\n+            return abi.downcallHandle(invokerSymbol, desc);\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.BeforeClass;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static org.testng.Assert.assertEquals;\n+\n+public abstract class TestUpcallBase extends CallGeneratorHelper {\n+\n+    static {\n+        System.loadLibrary(\"TestUpcall\");\n+        System.loadLibrary(\"TestUpcallStack\");\n+        System.loadLibrary(\"AsyncInvokers\");\n+    }\n+    static CLinker abi = CLinker.systemCLinker();\n+\n+    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n+\n+    static MethodHandle DUMMY;\n+    static MethodHandle PASS_AND_SAVE;\n+\n+    static {\n+        try {\n+            DUMMY = MethodHandles.lookup().findStatic(TestUpcallBase.class, \"dummy\", MethodType.methodType(void.class));\n+            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcallBase.class, \"passAndSave\",\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    static NativeSymbol dummyStub;\n+\n+    @BeforeClass\n+    void setup() {\n+        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n+        List<MemoryLayout> paramLayouts = params.stream().map(p -> p.layout(fields)).collect(Collectors.toList());\n+        paramLayouts.add(C_POINTER); \/\/ the callback\n+        MemoryLayout[] layouts = Stream.concat(prefix.stream(), paramLayouts.stream()).toArray(MemoryLayout[]::new);\n+        return ret == Ret.VOID ?\n+                FunctionDescriptor.ofVoid(layouts) :\n+                FunctionDescriptor.of(layouts[prefix.size()], layouts);\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size() + 1];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n+        for (int i = 0 ; i < params.size() ; i++) {\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+        }\n+        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n+        return args;\n+    }\n+\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+        if (params.isEmpty()) {\n+            return dummyStub;\n+        }\n+\n+        AtomicReference<Object[]> box = new AtomicReference<>();\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n+        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n+\n+        for(int i = 0; i < prefix.size(); i++) {\n+            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n+        }\n+\n+        for (int i = 0; i < params.size(); i++) {\n+            ParamType pt = params.get(i);\n+            MemoryLayout layout = pt.layout(fields);\n+            Class<?> carrier = carrier(layout, false);\n+            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n+\n+            final int finalI = prefix.size() + i;\n+            if (carrier == MemorySegment.class) {\n+                argChecks.add(o -> assertStructEquals((MemorySegment) box.get()[finalI], (MemorySegment) o[finalI], layout));\n+            } else {\n+                argChecks.add(o -> assertEquals(box.get()[finalI], o[finalI]));\n+            }\n+        }\n+\n+        ParamType firstParam = params.get(0);\n+        MemoryLayout firstlayout = firstParam.layout(fields);\n+        Class<?> firstCarrier = carrier(firstlayout, true);\n+\n+        if (firstCarrier == MemorySegment.class) {\n+            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n+        } else {\n+            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n+        }\n+\n+        mh = mh.asType(mh.type().changeReturnType(ret == Ret.VOID ? void.class : firstCarrier));\n+\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n+        FunctionDescriptor func = ret != Ret.VOID\n+                ? FunctionDescriptor.of(firstlayout, paramLayouts)\n+                : FunctionDescriptor.ofVoid(paramLayouts);\n+        return abi.upcallStub(mh, func, scope);\n+    }\n+\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+            }\n+        }\n+        ref.set(o);\n+        return o[retArg];\n+    }\n+\n+    static void dummy() {\n+        \/\/do nothing\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestUpcallScope\n+ *\/\n+\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public class TestUpcallScope extends TestUpcallBase {\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcalls(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestUpcallStack\n+ *\/\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public class TestUpcallStack extends TestUpcallBase {\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, functionStack(ret, paramTypes, fields));\n+            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n+    }\n+\n+    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -36,10 +36,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Xbatch\n- *   TestAsyncStackWalk\n- *\n- * @run main\/othervm\n- *   -Xbootclasspath\/a:.\n- *   -XX:+UnlockDiagnosticVMOptions\n- *   -XX:+WhiteBoxAPI\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n@@ -64,11 +54,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Xbatch\n- *   -XX:+UseZGC\n- *   TestAsyncStackWalk\n- *\n- * @run main\/othervm\n- *   -Xbootclasspath\/a:.\n- *   -XX:+UnlockDiagnosticVMOptions\n- *   -XX:+WhiteBoxAPI\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n@@ -93,11 +72,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Xbatch\n- *   -XX:+UseShenandoahGC\n- *   TestAsyncStackWalk\n- *\n- * @run main\/othervm\n- *   -Xbootclasspath\/a:.\n- *   -XX:+UnlockDiagnosticVMOptions\n- *   -XX:+WhiteBoxAPI\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -36,10 +36,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Xbatch\n- *   TestStackWalk\n- *\n- * @run main\/othervm\n- *   -Xbootclasspath\/a:.\n- *   -XX:+UnlockDiagnosticVMOptions\n- *   -XX:+WhiteBoxAPI\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n@@ -64,11 +54,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Xbatch\n- *   -XX:+UseZGC\n- *   TestStackWalk\n- *\n- * @run main\/othervm\n- *   -Xbootclasspath\/a:.\n- *   -XX:+UnlockDiagnosticVMOptions\n- *   -XX:+WhiteBoxAPI\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n@@ -93,11 +72,0 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   --enable-native-access=ALL-UNNAMED\n- *   -Xbatch\n- *   -XX:+UseShenandoahGC\n- *   TestStackWalk\n- *\n- * @run main\/othervm\n- *   -Xbootclasspath\/a:.\n- *   -XX:+UnlockDiagnosticVMOptions\n- *   -XX:+WhiteBoxAPI\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"}]}