{"files":[{"patch":"@@ -536,1 +536,1 @@\n-java\/foreign\/TestUpcall.java#stack 8275584 macosx-aarch64\n+java\/foreign\/TestUpcallStack.java 8275584 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *              -nativepath:<path-to-build-dir>\/support\/test\/jdk\/jtreg\/native\/manual\/lib\/ \\\n+ *              -nativepath:<path-to-build-dir>\/support\/test\/jdk\/jtreg\/native\/lib\/ \\\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -51,1 +51,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -63,1 +63,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -75,1 +75,1 @@\n- * @run testng\/othervm\/native\/manual\n+ * @run testng\/othervm\/native\n@@ -87,1 +87,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -98,1 +98,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -104,1 +104,1 @@\n-\/* @test id=Upcall-SCOPE-FF\n+\/* @test id=UpcallScope-FF\n@@ -107,1 +107,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -109,1 +109,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -111,1 +111,0 @@\n- *   -DUPCALL_TEST_TYPE=SCOPE\n@@ -114,1 +113,1 @@\n- *   TestUpcall\n+ *   TestUpcallScope\n@@ -117,1 +116,1 @@\n-\/* @test id=Upcall-SCOPE-TF\n+\/* @test id=UpcallScope-TF\n@@ -120,1 +119,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -122,1 +121,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -124,1 +123,0 @@\n- *   -DUPCALL_TEST_TYPE=SCOPE\n@@ -127,1 +125,1 @@\n- *   TestUpcall\n+ *   TestUpcallScope\n@@ -130,1 +128,1 @@\n-\/* @test id=Upcall-SCOPE-FT\n+\/* @test id=UpcallScope-FT\n@@ -133,1 +131,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -135,1 +133,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -137,1 +135,0 @@\n- *   -DUPCALL_TEST_TYPE=SCOPE\n@@ -140,1 +137,1 @@\n- *   TestUpcall\n+ *   TestUpcallScope\n@@ -143,1 +140,1 @@\n-\/* @test id=Upcall-SCOPE-TT\n+\/* @test id=UpcallScope-TT\n@@ -146,1 +143,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -148,1 +145,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -150,1 +147,0 @@\n- *   -DUPCALL_TEST_TYPE=SCOPE\n@@ -153,1 +149,1 @@\n- *   TestUpcall\n+ *   TestUpcallScope\n@@ -156,1 +152,1 @@\n-\/* @test id=Upcall-ASYNC-FF\n+\/* @test id=UpcallAsync-FF\n@@ -159,1 +155,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -161,1 +157,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -163,1 +159,0 @@\n- *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -166,1 +161,1 @@\n- *   TestUpcall\n+ *   TestUpcallAsync\n@@ -169,1 +164,1 @@\n-\/* @test id=Upcall-ASYNC-TF\n+\/* @test id=UpcallAsync-TF\n@@ -172,1 +167,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -174,1 +169,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -176,1 +171,0 @@\n- *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -179,1 +173,1 @@\n- *   TestUpcall\n+ *   TestUpcallAsync\n@@ -182,1 +176,1 @@\n-\/* @test id=Upcall-ASYNC-FT\n+\/* @test id=UpcallAsync-FT\n@@ -185,1 +179,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -187,1 +181,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -189,1 +183,0 @@\n- *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -192,1 +185,1 @@\n- *   TestUpcall\n+ *   TestUpcallAsync\n@@ -195,1 +188,1 @@\n-\/* @test id=Upcall-ASYNC-TT\n+\/* @test id=UpcallAsync-TT\n@@ -198,1 +191,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -200,1 +193,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\/timeout=960\n@@ -202,1 +195,0 @@\n- *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -205,1 +197,1 @@\n- *   TestUpcall\n+ *   TestUpcallAsync\n@@ -208,1 +200,1 @@\n-\/* @test id=Upcall-STACK-FF\n+\/* @test id=UpcallStack-FF\n@@ -211,1 +203,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -213,1 +205,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -215,1 +207,0 @@\n- *   -DUPCALL_TEST_TYPE=STACK\n@@ -218,1 +209,1 @@\n- *   TestUpcall\n+ *   TestUpcallStack\n@@ -221,1 +212,1 @@\n-\/* @test id=Upcall-STACK-TF\n+\/* @test id=UpcallStack-TF\n@@ -224,1 +215,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -226,1 +217,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -228,1 +219,0 @@\n- *   -DUPCALL_TEST_TYPE=STACK\n@@ -231,1 +221,1 @@\n- *   TestUpcall\n+ *   TestUpcallStack\n@@ -234,1 +224,1 @@\n-\/* @test id=Upcall-STACK-FT\n+\/* @test id=UpcallStack-FT\n@@ -237,1 +227,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -239,1 +229,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -241,1 +231,0 @@\n- *   -DUPCALL_TEST_TYPE=STACK\n@@ -244,1 +233,1 @@\n- *   TestUpcall\n+ *   TestUpcallStack\n@@ -247,1 +236,1 @@\n-\/* @test id=Upcall-STACK-TT\n+\/* @test id=UpcallStack-TT\n@@ -250,1 +239,1 @@\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n@@ -252,1 +241,1 @@\n- * @run testng\/othervm\/manual\n+ * @run testng\/othervm\/native\n@@ -254,1 +243,0 @@\n- *   -DUPCALL_TEST_TYPE=STACK\n@@ -257,1 +245,1 @@\n- *   TestUpcall\n+ *   TestUpcallStack\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":55,"deletions":67,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1,329 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=scope\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=SCOPE\n- *   TestUpcall\n- *\/\n-\n-\/*\n- * @test id=async\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=ASYNC\n- *   TestUpcall\n- *\/\n-\n-\/*\n- * @test id=stack\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @build NativeTestHelper CallGeneratorHelper TestUpcall\n- *\n- * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n- *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n- *   -DUPCALL_TEST_TYPE=STACK\n- *   TestUpcall\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.NativeSymbol;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.incubator.foreign.SymbolLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.SkipException;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import static java.lang.invoke.MethodHandles.insertArguments;\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestUpcall extends CallGeneratorHelper {\n-\n-    private enum TestType {\n-        SCOPE,\n-        ASYNC,\n-        STACK\n-    }\n-\n-    private static final TestType UPCALL_TEST_TYPE = TestType.valueOf(System.getProperty(\"UPCALL_TEST_TYPE\"));\n-\n-    static {\n-        System.loadLibrary(\"TestUpcall\");\n-        System.loadLibrary(\"TestUpcallStack\");\n-        System.loadLibrary(\"AsyncInvokers\");\n-    }\n-    static CLinker abi = CLinker.systemCLinker();\n-\n-    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n-\n-    static MethodHandle DUMMY;\n-    static MethodHandle PASS_AND_SAVE;\n-\n-    static {\n-        try {\n-            DUMMY = MethodHandles.lookup().findStatic(TestUpcall.class, \"dummy\", MethodType.methodType(void.class));\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\",\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n-        } catch (Throwable ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    static NativeSymbol dummyStub;\n-\n-    @BeforeClass\n-    void setup() {\n-        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n-    }\n-\n-    private static void checkSelected(TestType type) {\n-        if (UPCALL_TEST_TYPE != type)\n-            throw new SkipException(\"Skipping tests that were not selected\");\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcalls(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        checkSelected(TestType.SCOPE);\n-\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n-            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n-            Object[] callArgs = args;\n-            Object res = mh.invokeWithArguments(callArgs);\n-            argChecks.forEach(c -> c.accept(args));\n-            if (ret == Ret.NON_VOID) {\n-                returnChecks.forEach(c -> c.accept(res));\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        checkSelected(TestType.ASYNC);\n-\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(fName).get();\n-        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n-            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n-            MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n-            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n-\n-            mh = mh.asSpreader(Object[].class, args.length);\n-            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n-            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n-                    .map(FunctionDescriptor::of)\n-                    .orElse(FunctionDescriptor.ofVoid());\n-            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n-\n-            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n-\n-            Object res = invoker.type().returnType() == MemorySegment.class\n-                    ? invoker.invoke(allocator, callback)\n-                    : invoker.invoke(callback);\n-            argChecks.forEach(c -> c.accept(args));\n-            if (ret == Ret.NON_VOID) {\n-                returnChecks.forEach(c -> c.accept(res));\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        checkSelected(TestType.STACK);\n-\n-        List<Consumer<Object>> returnChecks = new ArrayList<>();\n-        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n-        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n-            MethodHandle mh = downcallHandle(abi, addr, allocator, functionStack(ret, paramTypes, fields));\n-            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n-            Object[] callArgs = args;\n-            Object res = mh.invokeWithArguments(callArgs);\n-            argChecks.forEach(c -> c.accept(args));\n-            if (ret == Ret.NON_VOID) {\n-                returnChecks.forEach(c -> c.accept(res));\n-            }\n-        }\n-    }\n-\n-    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n-\n-    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n-        if (ret == Ret.VOID) {\n-            String name = \"call_async_V\";\n-            return INVOKERS.computeIfAbsent(name, symbol ->\n-                    abi.downcallHandle(\n-                            LOOKUP.lookup(symbol).orElseThrow(),\n-                            FunctionDescriptor.ofVoid(C_POINTER)));\n-        }\n-\n-        String name = \"call_async_\" + returnType.name().charAt(0)\n-                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n-\n-        return INVOKERS.computeIfAbsent(name, symbol -> {\n-            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n-            MemoryLayout returnLayout = returnType.layout(fields);\n-            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n-\n-            return abi.downcallHandle(invokerSymbol, desc);\n-        });\n-    }\n-\n-    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        return function(ret, params, fields, List.of());\n-    }\n-\n-    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n-        List<MemoryLayout> paramLayouts = params.stream().map(p -> p.layout(fields)).collect(Collectors.toList());\n-        paramLayouts.add(C_POINTER); \/\/ the callback\n-        MemoryLayout[] layouts = Stream.concat(prefix.stream(), paramLayouts.stream()).toArray(MemoryLayout[]::new);\n-        return ret == Ret.VOID ?\n-                FunctionDescriptor.ofVoid(layouts) :\n-                FunctionDescriptor.of(layouts[prefix.size()], layouts);\n-    }\n-\n-    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n-    }\n-\n-    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n-        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n-    }\n-\n-    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n-        Object[] args = new Object[prefix.size() + params.size() + 1];\n-        int argNum = 0;\n-        for (MemoryLayout layout : prefix) {\n-            args[argNum++] = makeArg(layout, null, false);\n-        }\n-        for (int i = 0 ; i < params.size() ; i++) {\n-            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n-        }\n-        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n-        return args;\n-    }\n-\n-    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n-        if (params.isEmpty()) {\n-            return dummyStub;\n-        }\n-\n-        AtomicReference<Object[]> box = new AtomicReference<>();\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n-        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n-\n-        for(int i = 0; i < prefix.size(); i++) {\n-            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n-        }\n-\n-        for (int i = 0; i < params.size(); i++) {\n-            ParamType pt = params.get(i);\n-            MemoryLayout layout = pt.layout(fields);\n-            Class<?> carrier = carrier(layout, false);\n-            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n-\n-            final int finalI = prefix.size() + i;\n-            if (carrier == MemorySegment.class) {\n-                argChecks.add(o -> assertStructEquals((MemorySegment) box.get()[finalI], (MemorySegment) o[finalI], layout));\n-            } else {\n-                argChecks.add(o -> assertEquals(box.get()[finalI], o[finalI]));\n-            }\n-        }\n-\n-        ParamType firstParam = params.get(0);\n-        MemoryLayout firstlayout = firstParam.layout(fields);\n-        Class<?> firstCarrier = carrier(firstlayout, true);\n-\n-        if (firstCarrier == MemorySegment.class) {\n-            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n-        } else {\n-            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n-        }\n-\n-        mh = mh.asType(mh.type().changeReturnType(ret == Ret.VOID ? void.class : firstCarrier));\n-\n-        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n-        FunctionDescriptor func = ret != Ret.VOID\n-                ? FunctionDescriptor.of(firstlayout, paramLayouts)\n-                : FunctionDescriptor.ofVoid(paramLayouts);\n-        return abi.upcallStub(mh, func, scope);\n-    }\n-\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n-        for (int i = 0; i < o.length; i++) {\n-            if (o[i] instanceof MemorySegment) {\n-                MemorySegment ms = (MemorySegment) o[i];\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n-                copy.copyFrom(ms);\n-                o[i] = copy;\n-            }\n-        }\n-        ref.set(o);\n-        return o[retArg];\n-    }\n-\n-    static void dummy() {\n-        \/\/do nothing\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":0,"deletions":329,"binary":false,"changes":329,"status":"deleted"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestUpcallAsync\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+public class TestUpcallAsync extends TestUpcallBase {\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(allocator, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n+\n+    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n+        if (ret == Ret.VOID) {\n+            String name = \"call_async_V\";\n+            return INVOKERS.computeIfAbsent(name, symbol ->\n+                    abi.downcallHandle(\n+                            LOOKUP.lookup(symbol).orElseThrow(),\n+                            FunctionDescriptor.ofVoid(C_POINTER)));\n+        }\n+\n+        String name = \"call_async_\" + returnType.name().charAt(0)\n+                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n+\n+        return INVOKERS.computeIfAbsent(name, symbol -> {\n+            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            MemoryLayout returnLayout = returnType.layout(fields);\n+            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n+\n+            return abi.downcallHandle(invokerSymbol, desc);\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.BeforeClass;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static org.testng.Assert.assertEquals;\n+\n+public abstract class TestUpcallBase extends CallGeneratorHelper {\n+\n+    static {\n+        System.loadLibrary(\"TestUpcall\");\n+        System.loadLibrary(\"TestUpcallStack\");\n+        System.loadLibrary(\"AsyncInvokers\");\n+    }\n+    static CLinker abi = CLinker.systemCLinker();\n+\n+    static final SymbolLookup LOOKUP = SymbolLookup.loaderLookup();\n+\n+    static MethodHandle DUMMY;\n+    static MethodHandle PASS_AND_SAVE;\n+\n+    static {\n+        try {\n+            DUMMY = MethodHandles.lookup().findStatic(TestUpcallBase.class, \"dummy\", MethodType.methodType(void.class));\n+            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcallBase.class, \"passAndSave\",\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    static NativeSymbol dummyStub;\n+\n+    @BeforeClass\n+    void setup() {\n+        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n+        List<MemoryLayout> paramLayouts = params.stream().map(p -> p.layout(fields)).collect(Collectors.toList());\n+        paramLayouts.add(C_POINTER); \/\/ the callback\n+        MemoryLayout[] layouts = Stream.concat(prefix.stream(), paramLayouts.stream()).toArray(MemoryLayout[]::new);\n+        return ret == Ret.VOID ?\n+                FunctionDescriptor.ofVoid(layouts) :\n+                FunctionDescriptor.of(layouts[prefix.size()], layouts);\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size() + 1];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n+        for (int i = 0 ; i < params.size() ; i++) {\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+        }\n+        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n+        return args;\n+    }\n+\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+        if (params.isEmpty()) {\n+            return dummyStub;\n+        }\n+\n+        AtomicReference<Object[]> box = new AtomicReference<>();\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n+        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n+\n+        for(int i = 0; i < prefix.size(); i++) {\n+            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n+        }\n+\n+        for (int i = 0; i < params.size(); i++) {\n+            ParamType pt = params.get(i);\n+            MemoryLayout layout = pt.layout(fields);\n+            Class<?> carrier = carrier(layout, false);\n+            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n+\n+            final int finalI = prefix.size() + i;\n+            if (carrier == MemorySegment.class) {\n+                argChecks.add(o -> assertStructEquals((MemorySegment) box.get()[finalI], (MemorySegment) o[finalI], layout));\n+            } else {\n+                argChecks.add(o -> assertEquals(box.get()[finalI], o[finalI]));\n+            }\n+        }\n+\n+        ParamType firstParam = params.get(0);\n+        MemoryLayout firstlayout = firstParam.layout(fields);\n+        Class<?> firstCarrier = carrier(firstlayout, true);\n+\n+        if (firstCarrier == MemorySegment.class) {\n+            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n+        } else {\n+            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n+        }\n+\n+        mh = mh.asType(mh.type().changeReturnType(ret == Ret.VOID ? void.class : firstCarrier));\n+\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n+        FunctionDescriptor func = ret != Ret.VOID\n+                ? FunctionDescriptor.of(firstlayout, paramLayouts)\n+                : FunctionDescriptor.ofVoid(paramLayouts);\n+        return abi.upcallStub(mh, func, scope);\n+    }\n+\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+            }\n+        }\n+        ref.set(o);\n+        return o[retArg];\n+    }\n+\n+    static void dummy() {\n+        \/\/do nothing\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestUpcallScope\n+ *\/\n+\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public class TestUpcallScope extends TestUpcallBase {\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcalls(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallBase\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   TestUpcallStack\n+ *\/\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public class TestUpcallStack extends TestUpcallBase {\n+\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, functionStack(ret, paramTypes, fields));\n+            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n+    }\n+\n+    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}