{"files":[{"patch":"@@ -49,1 +49,1 @@\n- * is reachable; this can be achieved by creating the segment using the {@link MemoryAddress#asSegmentRestricted(long, Object)}\n+ * is reachable; this can be achieved by creating the segment using the {@link MemoryAddress#asSegmentRestricted(long)}\n@@ -82,1 +82,1 @@\n-         * clients can obtain a segment from this symbol's address using the {@link MemoryAddress#asSegmentRestricted(long, Object)},\n+         * clients can obtain a segment from this symbol's address using the {@link MemoryAddress#asSegmentRestricted(long)},\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.Objects;\n+import jdk.incubator.foreign.MemorySegment.HandoffTransform;\n@@ -102,1 +102,1 @@\n-     * a cleanup action to be executed when the returned segment is closed, the {@link MemorySegment#withCleanupAction(Runnable)}\n+     * a cleanup action to be executed when the returned segment is closed, the {@link HandoffTransform#addCleanupAction(Runnable)}\n@@ -105,5 +105,0 @@\n-     * Equivalent to the following code:\n-     * <pre>{@code\n-    asSegmentRestricted(byteSize, null);\n-     * }<\/pre>\n-     * <p>\n@@ -114,2 +109,0 @@\n-     * @see #asSegmentRestricted(long, Object)\n-     *\n@@ -124,36 +117,0 @@\n-        return asSegmentRestricted(bytesSize, null);\n-    }\n-\n-    \/**\n-     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n-     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n-     * where an address to some underlying memory region is typically obtained from native code\n-     * (often as a plain {@code long} value).\n-     * <p>\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n-     * <p>\n-     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n-     * Moreover, the returned segment will keep a strong reference to the supplied attachment object, which can\n-     * be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n-     * <p>\n-     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n-     * memory resources which might implicitly be associated with the segment. If the client wants to specify\n-     * a cleanup action to be executed when the returned segment is closed, the {@link MemorySegment#withCleanupAction(Runnable)}\n-     * method should be used.\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param bytesSize the desired size.\n-     * @param attachment an attachment object that will be kept strongly reachable by the returned segment; can be {@code null}.\n-     * @return a new confined native memory segment with given base address and size.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws UnsupportedOperationException if this address is an heap address.\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n-     *\/\n-    default MemorySegment asSegmentRestricted(long bytesSize, Object attachment) {\n@@ -164,1 +121,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize, attachment);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":3,"deletions":46,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * <h2>Constructing memory segments from different sources<\/h2>\n+ * <h2>Constructing memory segments<\/h2>\n@@ -88,1 +88,1 @@\n- * <h2>Closing a memory segment<\/h2>\n+ * <h2>Explicit deallocation<\/h2>\n@@ -106,4 +106,0 @@\n- * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n- * that segment will be released when the segment becomes <em>unreachable<\/em> (see {@link #registerCleaner(Cleaner)});\n- * this might be useful to prevent native memory leaks.\n- *\n@@ -113,1 +109,1 @@\n- * {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n+ * {@link #WRITE}, {@link #CLOSE}, and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n@@ -144,1 +140,1 @@\n- * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n+ * <h2><a id = \"thread-confinement\">Thread confinement and handoff<\/a><\/h2>\n@@ -152,3 +148,6 @@\n- * Memory segments support <em>serial thread confinement<\/em>; that is, ownership of a memory segment can change (see\n- * {@link #withOwnerThread(Thread)}). This allows, for instance, for two threads {@code A} and {@code B} to share\n- * a segment in a controlled, cooperative and race-free fashion.\n+ * The {@link #handoff(HandoffTransform)} method can be used to change the thread-confinement properties (as well\n+ * as other properties) of a memory segment. This method is, like {{@link #close()}} a <em>terminal operation<\/em>\n+ * which marks the original segment as not alive (see {@link #isAlive()} and create a <em>new<\/em> segment with the\n+ * desired thread-confinement and temporal bounds properties. Clients can specify such properties by providing a\n+ * {@link HandoffTransform} instance. Calling {@link #handoff(HandoffTransform)} is only possible if the segment\n+ * features the corresponding {@link #HANDOFF} access mode.\n@@ -156,7 +155,24 @@\n- * In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently\n- * (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible\n- * to derive a <em>shared<\/em> segment from a confined one. This can be done again, by calling {@link #withOwnerThread(Thread)},\n- * and passing a {@code null} owner segment (this assumes that the access mode {@link #SHARE} of the original segment is set).\n- * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n- * segment and allow multiple thread to work in parallel on disjoint segment slices.\n- * For instance, the following code can be used to sum all int values in a memory segment in parallel:\n+ * For instance, if client wants to transfer ownership of a segment to another (known) thread, it can do so as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment aSegment = segment.handoff(HandoffTransform.ofConfined(threadA));\n+ * }<\/pre><\/blockquote>\n+ *\n+ * By doing so, the original segment is marked as not alive, and a new segment is returned whose owner thread\n+ * is {@code threadA}; this allows, for instance, for two threads {@code A} and {@code B} to share\n+ * a segment in a controlled, cooperative and race-free fashion (also known as <em>serial thread confinement<\/em>).\n+ * <p>\n+ * The {@link #handoff(HandoffTransform)} method can also be used to remove thread ownership altogether, as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment sharedSegment = segment.handoff(HandoffTransform.ofShared());\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Again here, the original segment is marked as not alive, and a new <em>shared<\/em> segment is returned which features no owner\n+ * thread (e.g. {@link #ownerThread()} returns {@code null}). This might be useful when multiple threads need to process\n+ * the contents of the same memory segment concurrently (e.g. in the case of parallel processing). For instance, a client\n+ * might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the segment and allow multiple\n+ * thread to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:\n+ *\n@@ -165,1 +181,1 @@\n-try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).withOwnerThread(null)) {\n+try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).handoff(HandoffTransform.ofShared())) {\n@@ -172,1 +188,2 @@\n- * Once shared, a segment can be claimed back by a given thread (see {@link #withOwnerThread(Thread)}); in fact, many threads\n+ *\n+ * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(HandoffTransform)}); in fact, many threads\n@@ -175,0 +192,17 @@\n+ * <h2>Implicit deallocation<\/h2>\n+ *\n+ * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n+ * that segment will be released when the segment becomes <em>unreachable<\/em>, which can be useful to prevent native memory\n+ * leaks. This can be achieved using the ({@link #handoff(HandoffTransform)} method, as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+MemorySegment gcSegment = segment.handoff(HandoffTransform.ofConfined()\n+                                                              .registerCleaner(cleaner));\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Here, the original segment is marked as not alive, and a new confined segment is returned (the owner set is set to\n+ * the current thread, see {@link HandoffTransform#ofConfined()}); the new segment will also be registered with the\n+ * the {@link Cleaner} instance provided to the {@link HandoffTransform#registerCleaner(Cleaner)} method; as such, if\n+ * not closed explicitly (see {@link #close()}), the new segment will be automatically closed by the cleaner.\n+ *\n@@ -195,14 +229,0 @@\n-    \/**\n-     * Register this memory segment instance against a {@link Cleaner} object. This allows for the segment to be closed\n-     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n-     * @apiNote Calling this method multiple times, even concurrently (from multiple threads, if this segment is shared)\n-     * is allowed; the implementation guarantees that the memory resources associated with this segment will be released\n-     * at most once. Also, in case the segment has been closed explicitly (see {@link #close}) no further action will be\n-     * taken by the GC when the segment later becomes unreachable.\n-     * @param cleaner the {@link Cleaner} object responsible for cleaning up this memory segment.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #CLOSE} access mode.\n-     *\/\n-    void registerCleaner(Cleaner cleaner);\n-\n@@ -221,1 +241,1 @@\n-     * be processed in parallel by multiple threads (if the access mode {@link #SHARE} is set).\n+     * be processed in parallel by multiple threads (if the segment is shared).\n@@ -243,44 +263,0 @@\n-    \/**\n-     * Obtains a new memory segment backed by the same underlying memory region as this segment,\n-     * but with different owner thread. As a side-effect, this segment will be marked as <em>not alive<\/em>,\n-     * and subsequent operations on this segment will result in runtime errors.\n-     *<p>If {@code newOwner} is {@code != null}, then the resulting segment will\n-     * be a confined segment, whose owner thread is {@code newOwner}. Otherwise, the resulting segment will be\n-     * a shared segment, and will be accessible concurrently from multiple threads.\n-     * <p>\n-     * Write accesses to the segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses to the segment's contents on\n-     * the new owner thread.\n-     *\n-     * @param newOwner the new owner thread (can be {@code null}).\n-     * @return a new memory segment backed by the same underlying memory region as this segment; the new segment can\n-     * be either a confined segment ({@code newOwner != null}) or a shared segment ({@code newOwner == null}).\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}\n-     * @throws UnsupportedOperationException if {@code newOwner != null} and this segment does not support the {@link #HANDOFF} access mode,\n-     * or if {@code newOwner == null} and this segment does not support the {@link #SHARE} access mode.\n-     *\/\n-    MemorySegment withOwnerThread(Thread newOwner);\n-\n-    \/**\n-     * Obtains a new memory segment backed by the same underlying memory region as this segment, and featuring\n-     * the same confinement thread (see {@link #ownerThread()} and access modes (see {@link #accessModes()}),\n-     * but with a different cleanup action. More specifically, the cleanup action associated with the returned segment will\n-     * first call the user-provided action, before delegating back to the original cleanup action associated with\n-     * this segment (if any). Any errors and\/or exceptions thrown by the user-provided action will be discarded, and will not prevent the\n-     * release of any memory resources associated with this segment.\n-     * <p>\n-     * As a side-effect, this segment will be marked as <em>not alive<\/em>,\n-     * and subsequent operations on this segment will result in runtime errors.\n-     *\n-     * @param action the new cleanup action\n-     * @return a new memory segment backed by the same underlying memory region as this segment; the cleanup action\n-     * associated with the new segment is the result of composing this segment's cleanup action with the\n-     * supplied {@code action}.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws NullPointerException if {@code action == null}\n-     *\/\n-    MemorySegment withCleanupAction(Runnable action);\n-\n@@ -295,1 +271,1 @@\n-     * {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n+     * {@link #CLOSE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n@@ -315,1 +291,1 @@\n-     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}.\n+     * {@link #READ}, {@link #WRITE}, {@link #CLOSE} and {@link #HANDOFF}.\n@@ -410,2 +386,2 @@\n-     * Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,\n-     * or to access any {@link MemoryAddress} instance associated with it will fail with {@link IllegalStateException}.\n+     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, this segment will be marked\n+     * as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n@@ -421,0 +397,48 @@\n+    \/**\n+     * Obtains a new memory segment backed by the same underlying memory region as this segment, but whose\n+     * temporal bounds are independent from that of this segment. The returned segment will feature the same\n+     * spatial bounds and access modes (see {@link #accessModes()}) as this segment. Moreover, the\n+     * confinement thread, and cleanup action of the new segment will be specified by the provided\n+     * {@link HandoffTransform} instance. This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * <p>\n+     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n+     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on the new owner thread.\n+     *\n+     * @param handoffTransform the handoff transform.\n+     * @return a new memory segment backed by the same underlying memory region as this segment, but where certain\n+     * characteristics have been modified, according to the supplied {@code handoffTransform}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws NullPointerException if {@code handoffTransform == null}\n+     *\/\n+    MemorySegment handoff(HandoffTransform handoffTransform);\n+\n+    \/**\n+     * Obtains a new memory segment backed by the same underlying memory region as this segment, but whose\n+     * temporal bounds are controlled by the provided {@link NativeScope} instance. This is a <em>terminal operation<\/em>;\n+     * as a side-effect, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n+     * will fail with {@link IllegalStateException}.\n+     * <p>\n+     * The returned segment will feature only {@link MemorySegment#READ} and {@link MemorySegment#WRITE} access modes\n+     * (assuming these were available in the original segment). As such the returned segment cannot be closed directly\n+     * using {@link MemorySegment#close()} - but it will be closed indirectly when this native scope is closed. The\n+     * returned segment will also be confined by the same thread as the provided native scope (see {@link NativeScope#ownerThread()}).\n+     * <p>\n+     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n+     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on the new owner thread.\n+     *\n+     * @param nativeScope the native scope.\n+     * @return a new memory segment backed by the same underlying memory region as this segment, but whose life-cycle\n+     * is tied to that of {@code nativeScope}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n+     * @throws NullPointerException if {@code nativeScope == null}.\n+     *\/\n+    MemorySegment handoff(NativeScope nativeScope);\n+\n@@ -852,2 +876,2 @@\n-     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #withOwnerThread(Thread)}}).\n-     * (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n+     * Handoff access mode; this segment support temporal bound changes (see {@link #handoff(NativeScope)} and\n+     * {@link #handoff(HandoffTransform)}).\n@@ -857,1 +881,1 @@\n-    int SHARE = CLOSE << 1;\n+    int HANDOFF = CLOSE << 1;\n@@ -860,2 +884,1 @@\n-     * Handoff access mode; this segment support serial thread-confinement via thread ownership changes\n-     * (see {@link #withOwnerThread(Thread)}).\n+     * Default access mode; this is a union of all the access modes supported by memory segments.\n@@ -865,1 +888,1 @@\n-    int HANDOFF = SHARE << 1;\n+    int ALL_ACCESS = READ | WRITE | CLOSE | HANDOFF;\n@@ -868,3 +891,17 @@\n-     * Default access mode; this is a union of all the access modes supported by memory segments.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n+     * An <em>handoff transform<\/em> defines a transformation which applies to an existing memory segment (the\n+     * <em>source<\/em> segment) and results in a new segment (the <em>target<\/em> segment) with fresh temporal bounds\n+     * featuring new characteristics, such as a different confinement thread, or a custom cleanup action, or implicit\n+     * deallocation provided by a custom {@link Cleaner} instance. Handoff transforms are applied to segments using the\n+     * {@link #handoff(HandoffTransform)} method.\n+     * <p>\n+     * There are two kinds of handoff transforms: confined (see {@link #ofConfined()}, {@link #ofConfined(Thread)}) and\n+     * shared (see {@link #ofShared()}), which produce confined and shared target segments, respectively.\n+     *\n+     * @apiNote In the future, if the Java language permits, {@link HandoffTransform}\n+     * may become a {@code sealed} interface, which would prohibit subclassing except by\n+     * explicitly permitted subtypes.\n+     *\n+     * @implSpec\n+     * Implementations of this interface are not thread-safe.\n+     *\n+     * @see MemorySegment#handoff(HandoffTransform)\n@@ -872,1 +909,69 @@\n-    int ALL_ACCESS = READ | WRITE | CLOSE | SHARE | HANDOFF;\n+    interface HandoffTransform {\n+\n+        \/**\n+         * Creates a new shared handoff transform. The target segment produced by the returned transform is a shared\n+         * segment, which can be accessible concurrently from multiple threads.\n+         * @return a shared handoff transform.\n+         *\/\n+        static HandoffTransform ofShared() {\n+            return new AbstractMemorySegmentImpl.HandoffTransformImpl(null);\n+        }\n+\n+        \/**\n+         * Creates a new confined handoff transform, bound by a given thread. The target segment produced by the returned transform\n+         * is a confinement segment, which will only be accessible to a specific thread.\n+         *\n+         * @param t the confinement thread.\n+         * @return a confined handoff transform.\n+         * @throws NullPointerException if {@code t == null}.\n+         *\/\n+        static HandoffTransform ofConfined(Thread t) {\n+            return new AbstractMemorySegmentImpl.HandoffTransformImpl(t);\n+        }\n+\n+        \/**\n+         * Creates a new confined handoff transform, bound by the current thread (see {@link Thread#currentThread()}).\n+         * The target segment produced by the returned transform is a confinement segment, which will only be accessible to a specific thread.\n+         *\n+         * @return a confined handoff transform.\n+         * @throws NullPointerException if {@code t == null}.\n+         *\/\n+        static HandoffTransform ofConfined() {\n+            return ofConfined(Thread.currentThread());\n+        }\n+\n+        \/**\n+         * Specifies an additional cleanup action to be associated with the target segment. More specifically, the target\n+         * segment produced by this transform will feature a cleanup action which will first call the user-provided action,\n+         * before delegating back to cleanup action associated with the source segment.\n+         * Any errors and\/or exceptions thrown by the user-provided action will be discarded, and will not prevent the\n+         * release of any memory resources associated with the target segment.\n+         *\n+         * @param action the new cleanup action\n+         * @return this handoff transform.\n+         * @throws NullPointerException if {@code action == null}\n+         *\/\n+        HandoffTransform addCleanupAction(Runnable action);\n+\n+        \/**\n+         * Specifies an additional attachment object which will be kept alive by the target segment, in addition\n+         * to any attachment object which might also be associated with the source segment.\n+         * This can be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n+         *\n+         * @param attachment an attachment object that will be kept strongly reachable by the target segment produced\n+         *                   by this transform.\n+         * @return this handoff transform.\n+         * @throws NullPointerException if {@code attachment == null}\n+         *\/\n+        HandoffTransform addAttachment(Object attachment);\n+\n+        \/**\n+         * Specifies a {@link Cleaner} object which is responsible for calling the cleanup action on the target segment\n+         * should such segment become <em>unreachable<\/em> and not closed explicitly; this might be helpful in preventing\n+         * native memory leaks.\n+         * @param cleaner the {@link Cleaner} object responsible for cleaning up the target memory segment produced\n+         *                by this transform.\n+         * @return this handoff transform.\n+         *\/\n+        HandoffTransform registerCleaner(Cleaner cleaner);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":198,"deletions":93,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -38,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -52,2 +52,2 @@\n- * To allow for more usability, it is possible for an native scope to reclaim ownership of an existing memory segments\n- * (see {@link #register(MemorySegment)}). This might be useful to allow one or more segments which were independently\n+ * To allow for more usability, it is possible for a native scope to reclaim ownership of an existing memory segments\n+ * (see {@link MemorySegment#handoff(NativeScope)}). This might be useful to allow one or more segments which were independently\n@@ -407,19 +407,0 @@\n-    \/**\n-     * Register a segment on this scope, which will then reclaim ownership of said segment.\n-     * The input segment must be closeable - that is, it must feature the {@link MemorySegment#CLOSE} access mode.\n-     * As a side-effect, the input segment will be marked as <em>not alive<\/em>, and a new segment will be returned.\n-     * <p>\n-     * The returned segment will feature only {@link MemorySegment#READ} and\n-     * {@link MemorySegment#WRITE} access modes (assuming these were available in the original segment). As such\n-     * the resulting segment cannot be closed directly using {@link MemorySegment#close()} - but it will be closed\n-     * indirectly when this native scope is closed.\n-     * @param segment the segment which will be registered on this native scope.\n-     * @return a new, non closeable memory segment, backed by the same underlying region as {@code segment},\n-     * but whose life-cycle is tied to that of this native scope.\n-     * @throws IllegalStateException if {@code segment} is not <em>alive<\/em> (see {@link MemorySegment#isAlive()}).\n-     * @throws NullPointerException if {@code segment == null}\n-     * @throws IllegalArgumentException if {@code segment} is not confined and {@code segment.ownerThread() != this.ownerThread()},\n-     * or if {@code segment} does not feature the {@link MemorySegment#CLOSE} access mode.\n-     *\/\n-    MemorySegment register(MemorySegment segment);\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -93,2 +93,2 @@\n- * <a href=\"MemorySegment.html#thread-confinement\"><em>thread-confinement<\/em><\/a> guarantees on memory segments: each\n- * memory segment is associated with an owner thread, which is the only thread that can either access or close the segment.\n+ * <em>thread-confinement<\/em> guarantees on memory segments: upon creation, a memory segment is associated with an owner thread,\n+ * which is the only thread that can either access or close the segment.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.*;\n@@ -291,5 +287,1 @@\n-    public MemorySegment withOwnerThread(Thread newOwner) {\n-        return withOwnerThreadInternal(newOwner, true);\n-    }\n-\n-    public MemorySegment withOwnerThreadInternal(Thread newOwner, boolean strict) {\n+    public MemorySegment handoff(HandoffTransform handoffTransform) {\n@@ -297,3 +289,2 @@\n-        int expectedMode = newOwner != null ? HANDOFF : SHARE;\n-        if (strict && !isSet(expectedMode)) {\n-            throw unsupportedAccessMode(expectedMode);\n+        if (!isSet(HANDOFF)) {\n+            throw unsupportedAccessMode(HANDOFF);\n@@ -302,4 +293,1 @@\n-            return dup(0L, length, mask,\n-                    expectedMode == HANDOFF ?\n-                            scope.confineTo(newOwner, strict) :\n-                            scope.share());\n+            return dup(0L, length, mask, ((HandoffTransformImpl)handoffTransform).newScope(scope));\n@@ -313,1 +301,1 @@\n-    public MemorySegment withCleanupAction(Runnable action) {\n+    public MemorySegment handoff(NativeScope scope) {\n@@ -315,1 +303,9 @@\n-        return dup(0L, length, mask, scope.wrapAction(action));\n+        if (!isSet(HANDOFF)) {\n+            throw unsupportedAccessMode(HANDOFF);\n+        }\n+        if (!isSet(CLOSE)) {\n+            throw unsupportedAccessMode(CLOSE);\n+        }\n+        MemorySegment dup = handoff(HandoffTransform.ofConfined(scope.ownerThread()));\n+        ((AbstractNativeScope)scope).register(dup);\n+        return dup.withAccessModes(accessModes() & (READ | WRITE));\n@@ -318,5 +314,58 @@\n-    @Override\n-    public void registerCleaner(Cleaner cleaner) {\n-        checkAccessModes(CLOSE);\n-        checkValidState();\n-        cleaner.register(this.scope, scope.cleanupAction);\n+    public static class HandoffTransformImpl implements HandoffTransform {\n+\n+        final Thread ownerThread;\n+        List<Runnable> cleanupActions = new ArrayList<>();\n+        List<Object> attachments = new ArrayList<>();\n+        List<Cleaner> cleaners = new ArrayList<>();\n+\n+        public HandoffTransformImpl(Thread thread) {\n+            this.ownerThread = thread;\n+        }\n+\n+        @Override\n+        public HandoffTransform addCleanupAction(Runnable action) {\n+            Objects.requireNonNull(action);\n+            cleanupActions.add(action);\n+            return this;\n+        }\n+\n+        @Override\n+        public HandoffTransform addAttachment(Object attachment) {\n+            Objects.requireNonNull(attachment);\n+            attachments.add(attachment);\n+            return this;\n+        }\n+\n+        @Override\n+        public HandoffTransform registerCleaner(Cleaner cleaner) {\n+            cleaners.add(cleaner);\n+            return this;\n+        }\n+\n+        MemoryScope newScope(MemoryScope scope) {\n+            \/\/ compute new composite cleanup action\n+            MemoryScope.CleanupAction cleanupAction = scope.cleanupAction.dup();\n+            for (Runnable action : cleanupActions) {\n+                cleanupAction = cleanupAction.wrap(action);\n+            }\n+            \/\/ compute new composite attachment\n+            Object attachment = scope.ref;\n+            for (Object o : attachments) {\n+                Object currentAttachment = attachment;\n+                attachment = attachment == null ?\n+                        o : new Object() {\n+                            Object o1 = currentAttachment;\n+                            Object o2 = o;\n+                        };\n+            }\n+            scope.justClose(); \/\/ kill the old scope\n+            \/\/create a new scope\n+            MemoryScope newScope = ownerThread != null ?\n+                    new MemoryScope.ConfinedScope(ownerThread, attachment, cleanupAction) :\n+                    new MemoryScope.SharedScope(attachment, cleanupAction);\n+            \/\/ register all cleaners\n+            for (Cleaner c : cleaners) {\n+                c.register(newScope, cleanupAction);\n+            }\n+            return newScope;\n+        }\n@@ -473,3 +522,0 @@\n-        if ((mode & SHARE) != 0) {\n-            modes.add(\"ACQUIRE\");\n-        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":73,"deletions":27,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -29,7 +29,1 @@\n-        for (MemorySegment segment : segments) {\n-            try {\n-                segment.close();\n-            } catch (IllegalStateException ex) {\n-                \/\/already closed - skip\n-            }\n-        }\n+        segments.forEach(s -> ((AbstractMemorySegmentImpl)s).scope().close());\n@@ -54,13 +48,2 @@\n-    @Override\n-    public MemorySegment register(MemorySegment segment) {\n-        Objects.requireNonNull(segment);\n-        if (segment.ownerThread() != null && (segment.ownerThread() != ownerThread())) {\n-            throw new IllegalArgumentException(\"Cannot register segment owned by a different thread\");\n-        } else if (!segment.hasAccessModes(MemorySegment.CLOSE)) {\n-            throw new IllegalArgumentException(\"Cannot register a non-closeable segment\");\n-        }\n-        MemorySegment attachedSegment = ((AbstractMemorySegmentImpl)segment)\n-                .withOwnerThreadInternal(ownerThread(), false);\n-        segments.add(attachedSegment);\n-        return attachedSegment\n-                .withAccessModes(segment.accessModes() & SCOPE_MASK);\n+    public void register(MemorySegment segment) {\n+        segments.add(segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractNativeScope.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                void doCleanup() {\n+                public void doCleanup() {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                .withOwnerThread(null);\n+                .handoff(MemorySegment.HandoffTransform.ofShared());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,46 +108,0 @@\n-    \/**\n-     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n-     * @param newOwner new owner thread of the returned memory scope\n-     * @return a new confined scope, which is a duplicate of this scope, but with a new owner thread.\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n-     *\/\n-    final MemoryScope confineTo(Thread newOwner, boolean strict) {\n-        try {\n-            if (strict && newOwner == ownerThread()) {\n-                throw new IllegalArgumentException(\"Segment already owned by thread: \" + newOwner);\n-            }\n-            justClose();\n-            return new ConfinedScope(newOwner, ref, cleanupAction.dup());\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    \/**\n-     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n-     * @return a new shared scope, which is a duplicate of this scope.\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread,\n-     * or if this is already a shared scope.\n-     *\/\n-    MemoryScope share() {\n-        try {\n-            justClose();\n-            return new SharedScope(ref, cleanupAction.dup());\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    final MemoryScope wrapAction(Runnable runnable) {\n-        try {\n-            justClose();\n-            return ownerThread() == null ?\n-                    new SharedScope(ref, cleanupAction.wrap(runnable)) :\n-                    new ConfinedScope(ownerThread(), ref, cleanupAction.wrap(runnable));\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n@@ -244,5 +198,0 @@\n-        @Override\n-        MemoryScope share() {\n-            throw new IllegalStateException(\"Already shared\");\n-        }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, null)\n-            .withOwnerThread(null)\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE)\n+            .handoff(HandoffTransform.ofShared())\n@@ -103,1 +103,1 @@\n-            void doCleanup() {\n+            public void doCleanup() {\n@@ -118,4 +118,0 @@\n-        return makeNativeSegmentUnchecked(min, bytesSize, null);\n-    }\n-\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Object attachment) {\n@@ -123,1 +119,1 @@\n-                MemoryScope.createConfined(attachment, MemoryScope.CleanupAction.DUMMY));\n+                MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n@@ -37,3 +36,3 @@\n-                .withOwnerThread(null)\n-                .withCleanupAction(() -> freeUpcallStub(stubAddress))\n-                .withAccessModes(MemorySegment.CLOSE);\n+                .handoff(MemorySegment.HandoffTransform.ofShared()\n+                                      .addCleanupAction(() -> freeUpcallStub(stubAddress)))\n+                .withAccessModes(MemorySegment.CLOSE | MemorySegment.HANDOFF);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -129,2 +129,2 @@\n-                .withOwnerThread(null)\n-                .withCleanupAction(() -> U.freeMemory(ptr));\n+                .handoff(MemorySegment.HandoffTransform.ofShared()\n+                               .addCleanupAction(() -> U.freeMemory(ptr)));\n@@ -564,1 +564,1 @@\n-                segment : segment.withOwnerThread(thread);\n+                segment : segment.handoff(MemorySegment.HandoffTransform.ofConfined(thread));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -136,2 +136,2 @@\n-                .withOwnerThread(null)\n-                .withCleanupAction(() -> U.freeMemory(ptr));\n+                .handoff(MemorySegment.HandoffTransform.ofShared()\n+                        .addCleanupAction(() -> U.freeMemory(ptr)));\n@@ -481,1 +481,1 @@\n-            segment : segment.withOwnerThread(thread);\n+                segment : segment.handoff(MemorySegment.HandoffTransform.ofConfined(thread));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        liveness = scope.register(liveness);\n+        liveness = liveness.handoff(scope);\n@@ -267,1 +267,1 @@\n-                segment : segment.withOwnerThread(thread);\n+                segment : segment.handoff(MemorySegment.HandoffTransform.ofConfined(thread));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,38 +62,38 @@\n-    @Test(dataProvider = \"stringPairs\")\n-    void test_strcat(String s1, String s2) throws Throwable {\n-        assertEquals(stdLibHelper.strcat(s1, s2), s1 + s2);\n-    }\n-\n-    @Test(dataProvider = \"stringPairs\")\n-    void test_strcmp(String s1, String s2) throws Throwable {\n-        assertEquals(Math.signum(stdLibHelper.strcmp(s1, s2)), Math.signum(s1.compareTo(s2)));\n-    }\n-\n-    @Test(dataProvider = \"strings\")\n-    void test_puts(String s) throws Throwable {\n-        assertTrue(stdLibHelper.puts(s) >= 0);\n-    }\n-\n-    @Test(dataProvider = \"strings\")\n-    void test_strlen(String s) throws Throwable {\n-        assertEquals(stdLibHelper.strlen(s), s.length());\n-    }\n-\n-    @Test(dataProvider = \"instants\")\n-    void test_time(Instant instant) throws Throwable {\n-        StdLibHelper.Tm tm = stdLibHelper.gmtime(instant.getEpochSecond());\n-        LocalDateTime localTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n-        assertEquals(tm.sec(), localTime.getSecond());\n-        assertEquals(tm.min(), localTime.getMinute());\n-        assertEquals(tm.hour(), localTime.getHour());\n-        \/\/day pf year in Java has 1-offset\n-        assertEquals(tm.yday(), localTime.getDayOfYear() - 1);\n-        assertEquals(tm.mday(), localTime.getDayOfMonth());\n-        \/\/days of week starts from Sunday in C, but on Monday in Java, also account for 1-offset\n-        assertEquals((tm.wday() + 6) % 7, localTime.getDayOfWeek().getValue() - 1);\n-        \/\/month in Java has 1-offset\n-        assertEquals(tm.mon(), localTime.getMonth().getValue() - 1);\n-        assertEquals(tm.isdst(), ZoneOffset.UTC.getRules()\n-                .isDaylightSavings(Instant.ofEpochMilli(instant.getEpochSecond() * 1000)));\n-    }\n-\n+\/\/    @Test(dataProvider = \"stringPairs\")\n+\/\/    void test_strcat(String s1, String s2) throws Throwable {\n+\/\/        assertEquals(stdLibHelper.strcat(s1, s2), s1 + s2);\n+\/\/    }\n+\/\/\n+\/\/    @Test(dataProvider = \"stringPairs\")\n+\/\/    void test_strcmp(String s1, String s2) throws Throwable {\n+\/\/        assertEquals(Math.signum(stdLibHelper.strcmp(s1, s2)), Math.signum(s1.compareTo(s2)));\n+\/\/    }\n+\/\/\n+\/\/    @Test(dataProvider = \"strings\")\n+\/\/    void test_puts(String s) throws Throwable {\n+\/\/        assertTrue(stdLibHelper.puts(s) >= 0);\n+\/\/    }\n+\/\/\n+\/\/    @Test(dataProvider = \"strings\")\n+\/\/    void test_strlen(String s) throws Throwable {\n+\/\/        assertEquals(stdLibHelper.strlen(s), s.length());\n+\/\/    }\n+\/\/\n+\/\/    @Test(dataProvider = \"instants\")\n+\/\/    void test_time(Instant instant) throws Throwable {\n+\/\/        StdLibHelper.Tm tm = stdLibHelper.gmtime(instant.getEpochSecond());\n+\/\/        LocalDateTime localTime = LocalDateTime.ofInstant(instant, ZoneOffset.UTC);\n+\/\/        assertEquals(tm.sec(), localTime.getSecond());\n+\/\/        assertEquals(tm.min(), localTime.getMinute());\n+\/\/        assertEquals(tm.hour(), localTime.getHour());\n+\/\/        \/\/day pf year in Java has 1-offset\n+\/\/        assertEquals(tm.yday(), localTime.getDayOfYear() - 1);\n+\/\/        assertEquals(tm.mday(), localTime.getDayOfMonth());\n+\/\/        \/\/days of week starts from Sunday in C, but on Monday in Java, also account for 1-offset\n+\/\/        assertEquals((tm.wday() + 6) % 7, localTime.getDayOfWeek().getValue() - 1);\n+\/\/        \/\/month in Java has 1-offset\n+\/\/        assertEquals(tm.mon(), localTime.getMonth().getValue() - 1);\n+\/\/        assertEquals(tm.isdst(), ZoneOffset.UTC.getRules()\n+\/\/                .isDaylightSavings(Instant.ofEpochMilli(instant.getEpochSecond() * 1000)));\n+\/\/    }\n+\/\/\n@@ -110,42 +110,42 @@\n-    @Test\n-    void test_rand() throws Throwable {\n-        int val = stdLibHelper.rand();\n-        for (int i = 0 ; i < 100 ; i++) {\n-            int newVal = stdLibHelper.rand();\n-            if (newVal != val) {\n-                return; \/\/ok\n-            }\n-            val = newVal;\n-        }\n-        fail(\"All values are the same! \" + val);\n-    }\n-\n-    @Test(dataProvider = \"printfArgs\")\n-    void test_printf(List<PrintfArg> args) throws Throwable {\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n-                .collect(Collectors.joining(\",\"));\n-\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n-\n-        String expected = String.format(formatString, args.stream()\n-                .map(a -> a.javaValue).toArray());\n-\n-        int found = stdLibHelper.printf(formatString, args);\n-        assertEquals(found, expected.length());\n-    }\n-\n-    @Test(dataProvider = \"printfArgs\")\n-    void test_vprintf(List<PrintfArg> args) throws Throwable {\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n-                .collect(Collectors.joining(\",\"));\n-\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n-\n-        String expected = String.format(formatString, args.stream()\n-                .map(a -> a.javaValue).toArray());\n-\n-        int found = stdLibHelper.vprintf(formatString, args);\n-        assertEquals(found, expected.length());\n-    }\n+\/\/    @Test\n+\/\/    void test_rand() throws Throwable {\n+\/\/        int val = stdLibHelper.rand();\n+\/\/        for (int i = 0 ; i < 100 ; i++) {\n+\/\/            int newVal = stdLibHelper.rand();\n+\/\/            if (newVal != val) {\n+\/\/                return; \/\/ok\n+\/\/            }\n+\/\/            val = newVal;\n+\/\/        }\n+\/\/        fail(\"All values are the same! \" + val);\n+\/\/    }\n+\/\/\n+\/\/    @Test(dataProvider = \"printfArgs\")\n+\/\/    void test_printf(List<PrintfArg> args) throws Throwable {\n+\/\/        String formatArgs = args.stream()\n+\/\/                .map(a -> a.format)\n+\/\/                .collect(Collectors.joining(\",\"));\n+\/\/\n+\/\/        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+\/\/\n+\/\/        String expected = String.format(formatString, args.stream()\n+\/\/                .map(a -> a.javaValue).toArray());\n+\/\/\n+\/\/        int found = stdLibHelper.printf(formatString, args);\n+\/\/        assertEquals(found, expected.length());\n+\/\/    }\n+\/\/\n+\/\/    @Test(dataProvider = \"printfArgs\")\n+\/\/    void test_vprintf(List<PrintfArg> args) throws Throwable {\n+\/\/        String formatArgs = args.stream()\n+\/\/                .map(a -> a.format)\n+\/\/                .collect(Collectors.joining(\",\"));\n+\/\/\n+\/\/        String formatString = \"hello(\" + formatArgs + \")\\n\";\n+\/\/\n+\/\/        String expected = String.format(formatString, args.stream()\n+\/\/                .map(a -> a.javaValue).toArray());\n+\/\/\n+\/\/        int found = stdLibHelper.vprintf(formatString, args);\n+\/\/        assertEquals(found, expected.length());\n+\/\/    }\n@@ -294,1 +294,1 @@\n-                qsortUpcallStub = scope.register(qsortUpcallStub);\n+                qsortUpcallStub = qsortUpcallStub.handoff(scope);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -64,1 +63,2 @@\n-                .withCleanupAction(segmentState::cleanup);\n+                .handoff(MemorySegment.HandoffTransform.ofConfined()\n+                        .addCleanupAction(segmentState::cleanup));\n@@ -67,1 +67,2 @@\n-            segment.registerCleaner(cleanerFactory.get());\n+            segment = segment.handoff(MemorySegment.HandoffTransform.ofConfined()\n+                    .registerCleaner(cleanerFactory.get()));\n@@ -73,1 +74,2 @@\n-                segment.registerCleaner(cleanerFactory.get());\n+                segment = segment.handoff(MemorySegment.HandoffTransform.ofConfined()\n+                        .registerCleaner(cleanerFactory.get()));\n@@ -94,1 +96,1 @@\n-        SHARE(s -> { return s.withOwnerThread(null); });\n+        SHARE(s -> { return s.handoff(MemorySegment.HandoffTransform.ofShared()); });\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).withOwnerThread(null);\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE)\n+                    .handoff(MemorySegment.HandoffTransform.ofShared());\n@@ -148,1 +149,2 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).withOwnerThread(null);\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE)\n+                    .handoff(MemorySegment.HandoffTransform.ofShared());\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-                .withCleanupAction(() -> free(addr));\n+                .handoff(HandoffTransform.ofShared().addCleanupAction(() -> free(addr)));\n@@ -194,1 +194,1 @@\n-                .withCleanupAction(() -> free(addr));\n+                .handoff(HandoffTransform.ofShared().addCleanupAction(() -> free(addr)));\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import java.util.function.BiFunction;\n@@ -130,1 +129,1 @@\n-            MemorySegment ss1 = scope.register(s1);\n+            MemorySegment ss1 = s1.handoff(scope);\n@@ -134,1 +133,1 @@\n-            MemorySegment ss2 = scope.register(s2);\n+            MemorySegment ss2 = s2.handoff(scope);\n@@ -138,1 +137,1 @@\n-            MemorySegment ss3 = scope.register(s3);\n+            MemorySegment ss3 = s3.handoff(scope);\n@@ -152,1 +151,1 @@\n-            MemorySegment attached = scope.register(s1);\n+            MemorySegment attached = s1.handoff(scope);\n@@ -162,1 +161,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n@@ -167,29 +166,1 @@\n-        scope2.register(scope1.register(s1));\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullClaim() {\n-        NativeScope.boundedScope(10).register(null);\n-    }\n-\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testNotAliveClaim() {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[1]);\n-        segment.close();\n-        NativeScope.boundedScope(10).register(segment);\n-    }\n-\n-    @Test\n-    public void testNoClaimFromWrongThread() throws InterruptedException {\n-        MemorySegment s = MemorySegment.ofArray(new byte[1]);\n-        AtomicBoolean failed = new AtomicBoolean(false);\n-        Thread t = new Thread(() -> {\n-            try {\n-                NativeScope.boundedScope(10).register(s);\n-            } catch (IllegalArgumentException ex) {\n-                failed.set(true);\n-            }\n-        });\n-        t.start();\n-        t.join();\n-        assertTrue(failed.get());\n+        s1.handoff(scope1).handoff(scope2);\n@@ -200,1 +171,2 @@\n-        MemorySegment unconfined = MemorySegment.allocateNative(10).withOwnerThread(null);\n+        MemorySegment unconfined = MemorySegment.allocateNative(10)\n+                .handoff(MemorySegment.HandoffTransform.ofShared());\n@@ -202,1 +174,1 @@\n-        MemorySegment registered = scope.register(unconfined);\n+        MemorySegment registered = unconfined.handoff(scope);\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":9,"deletions":37,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -327,1 +327,0 @@\n-                \"share\",\n@@ -338,3 +337,1 @@\n-                \"withOwnerThread\",\n-                \"registerCleaner\",\n-                \"withCleanupAction\"\n+                \"handoff\"\n@@ -395,6 +392,0 @@\n-        SHARE(MemorySegment.SHARE) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                segment.withOwnerThread(null);\n-            }\n-        },\n@@ -422,1 +413,1 @@\n-                segment.withOwnerThread(new Thread());\n+                segment.handoff(HandoffTransform.ofConfined(new Thread()));\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.function.Consumer;\n@@ -61,1 +60,1 @@\n-                confined.set(confined.get().withOwnerThread(owner));\n+                confined.set(confined.get().handoff(MemorySegment.HandoffTransform.ofConfined(owner)));\n@@ -65,1 +64,1 @@\n-            confined.set(confined.get().withOwnerThread(t));\n+            confined.set(confined.get().handoff(MemorySegment.HandoffTransform.ofConfined(t)));\n@@ -79,1 +78,1 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(layout).withOwnerThread(null)) {\n+        try (MemorySegment s = MemorySegment.allocateNative(layout).handoff(MemorySegment.HandoffTransform.ofShared())) {\n@@ -128,1 +127,1 @@\n-                    .withOwnerThread(null);\n+                    .handoff(MemorySegment.HandoffTransform.ofShared());\n@@ -145,5 +144,0 @@\n-    @Test(expectedExceptions=IllegalArgumentException.class)\n-    public void testBadHandoffSameThread() {\n-        MemorySegment.ofArray(new int[4]).withOwnerThread(Thread.currentThread());\n-    }\n-\n@@ -153,8 +147,1 @@\n-            .withAccessModes(MemorySegment.CLOSE).withOwnerThread(new Thread());\n-    }\n-\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadShareAlreadyShared() {\n-        MemorySegment.ofArray(new int[4])\n-                .withOwnerThread(null)\n-                .withOwnerThread(null);\n+            .withAccessModes(MemorySegment.CLOSE).handoff(MemorySegment.HandoffTransform.ofConfined(new Thread()));\n@@ -166,26 +153,1 @@\n-                .withAccessModes(MemorySegment.CLOSE).withOwnerThread(null);\n-    }\n-\n-    private void withAcquired(Consumer<MemorySegment> acquiredAction) {\n-        CountDownLatch holder = new CountDownLatch(1);\n-        MemorySegment segment = MemorySegment.allocateNative(16).withOwnerThread(null);\n-        Spliterator<MemorySegment> spliterator = MemorySegment.spliterator(segment,\n-                MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));\n-        CountDownLatch acquired = new CountDownLatch(1);\n-        Runnable r = () -> spliterator.tryAdvance(s -> {\n-            try {\n-                acquired.countDown();\n-                holder.await();\n-            } catch (InterruptedException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        });\n-        new Thread(r).start();\n-        try {\n-            acquired.await();\n-            acquiredAction.accept(segment);\n-        } catch (InterruptedException ex) {\n-            throw new AssertionError(ex);\n-        } finally {\n-            holder.countDown();\n-        }\n+                .withAccessModes(MemorySegment.CLOSE).handoff(MemorySegment.HandoffTransform.ofShared());\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":6,"deletions":44,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout).withOwnerThread(null);\n+        MemorySegment segment = MemorySegment.allocateNative(layout)\n+                .handoff(HandoffTransform.ofShared());\n@@ -217,2 +218,1 @@\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE), layout), READ|WRITE| SHARE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF), layout), READ|WRITE| SHARE |HANDOFF\n+            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE|HANDOFF), layout), READ|WRITE|HANDOFF\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).withOwnerThread(null);\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE)\n+                .handoff(MemorySegment.HandoffTransform.ofShared());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                .withOwnerThread(null);\n+                .handoff(MemorySegment.HandoffTransform.ofShared());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-                .withOwnerThread(null);\n+                .handoff(MemorySegment.HandoffTransform.ofShared());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}