{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -33,2 +34,0 @@\n-import jdk.incubator.foreign.MemorySegment.HandoffTransform;\n-\n@@ -92,2 +91,3 @@\n-     * where an address to some underlying memory region is typically obtained from native code\n-     * (often as a plain {@code long} value). The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n@@ -101,4 +101,4 @@\n-     * memory resources which might implicitly be associated with the segment. If the client wants to specify\n-     * a cleanup action to be executed when the returned segment is closed, the {@link HandoffTransform#addCleanupAction(Runnable)}\n-     * method should be used.\n-     * <p>\n+     * memory resources which might implicitly be associated with the segment. This method is equivalent to the following code:\n+     * <pre>{@code\n+    asSegmentRestricted(byteSize, null, null);\n+     * }<\/pre>\n@@ -117,5 +117,1 @@\n-        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize);\n+        return asSegmentRestricted(bytesSize, null, null);\n@@ -124,0 +120,33 @@\n+    \/**\n+     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n+     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * <p>\n+     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * Moreover, the returned segment will keep a strong reference to the supplied attachment object (if any), which can\n+     * be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n+     * <p>\n+     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n+     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n+     * memory resources which might implicitly be associated with the segment, but will result in calling the\n+     * provided cleanup action (if any).\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param bytesSize the desired size.\n+     * @param cleanupAction the cleanup action; can be {@code null}.\n+     * @param attachment an attachment object that will be kept strongly reachable by the returned segment; can be {@code null}.\n+     * @return a new confined native memory segment with given base address and size.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     *\/\n+    MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n- * {@link #WRITE}, {@link #CLOSE}, and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n+ * {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n@@ -140,1 +140,1 @@\n- * <h2><a id = \"thread-confinement\">Thread confinement and handoff<\/a><\/h2>\n+ * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n@@ -148,6 +148,4 @@\n- * The {@link #handoff(HandoffTransform)} method can be used to change the thread-confinement properties (as well\n- * as other properties) of a memory segment. This method is, like {{@link #close()}} a <em>terminal operation<\/em>\n- * which marks the original segment as not alive (see {@link #isAlive()} and create a <em>new<\/em> segment with the\n- * desired thread-confinement and temporal bounds properties. Clients can specify such properties by providing a\n- * {@link HandoffTransform} instance. Calling {@link #handoff(HandoffTransform)} is only possible if the segment\n- * features the corresponding {@link #HANDOFF} access mode.\n+ * The {@link #handoff(Thread)} method can be used to change the thread-confinement properties of a memory segment.\n+ * This method is, like {@link #close()}, a <em>terminal operation<\/em> which marks the original segment as not alive\n+ * (see {@link #isAlive()}) and creates a <em>new<\/em> segment with the desired thread-confinement properties. Calling\n+ * {@link #handoff(Thread)} is only possible if the segment features the corresponding {@link #HANDOFF} access mode.\n@@ -159,1 +157,1 @@\n-MemorySegment aSegment = segment.handoff(HandoffTransform.ofConfined(threadA));\n+MemorySegment aSegment = segment.handoff(threadA);\n@@ -166,1 +164,3 @@\n- * The {@link #handoff(HandoffTransform)} method can also be used to remove thread ownership altogether, as follows:\n+ * Alternatively, the {@link #share()} method can be used to remove thread ownership altogether; this is only possible\n+ * if the segment features the corresponding {@link #SHARE} access mode. The following code shows how clients can\n+ * obtain a shared segment:\n@@ -170,1 +170,1 @@\n-MemorySegment sharedSegment = segment.handoff(HandoffTransform.ofShared());\n+MemorySegment sharedSegment = segment.share();\n@@ -181,1 +181,1 @@\n-try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).handoff(HandoffTransform.ofShared())) {\n+try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).share()) {\n@@ -189,1 +189,1 @@\n- * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(HandoffTransform)}); in fact, many threads\n+ * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(Thread)}); in fact, many threads\n@@ -196,1 +196,1 @@\n- * leaks. This can be achieved using the ({@link #handoff(HandoffTransform)} method, as follows:\n+ * leaks. This can be achieved using the {@link #registerCleaner(Cleaner)} method, as follows:\n@@ -200,2 +200,1 @@\n-MemorySegment gcSegment = segment.handoff(HandoffTransform.ofConfined()\n-                                                              .registerCleaner(cleaner));\n+MemorySegment gcSegment = segment.registerCleaner(cleaner);\n@@ -204,4 +203,4 @@\n- * Here, the original segment is marked as not alive, and a new confined segment is returned (the owner set is set to\n- * the current thread, see {@link HandoffTransform#ofConfined()}); the new segment will also be registered with the\n- * the {@link Cleaner} instance provided to the {@link HandoffTransform#registerCleaner(Cleaner)} method; as such, if\n- * not closed explicitly (see {@link #close()}), the new segment will be automatically closed by the cleaner.\n+ * Here, the original segment is marked as not alive, and a new segment is returned (the owner thread of the returned\n+ * segment set is set to that of the current thread, see {@link #ownerThread()}); the new segment\n+ * will also be registered with the the {@link Cleaner} instance provided to the {@link #registerCleaner(Cleaner)} method;\n+ * as such, if not closed explicitly (see {@link #close()}), the new segment will be automatically closed by the cleaner.\n@@ -271,1 +270,1 @@\n-     * {@link #CLOSE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n+     * {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n@@ -291,1 +290,1 @@\n-     * {@link #READ}, {@link #WRITE}, {@link #CLOSE} and {@link #HANDOFF}.\n+     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}.\n@@ -398,5 +397,5 @@\n-     * Obtains a new memory segment backed by the same underlying memory region as this segment, but whose\n-     * temporal bounds are independent from that of this segment. The returned segment will feature the same\n-     * spatial bounds and access modes (see {@link #accessModes()}) as this segment. Moreover, the\n-     * confinement thread, and cleanup action of the new segment will be specified by the provided\n-     * {@link HandoffTransform} instance. This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * Obtains a new confined memory segment backed by the same underlying memory region as this segment. The returned segment will\n+     * be confined on the specified thread, and will feature the same spatial bounds and access modes (see {@link #accessModes()})\n+     * as this segment.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n@@ -410,2 +409,2 @@\n-     * @param handoffTransform the handoff transform.\n-     * @return a new memory segment backed by the same underlying memory region as this segment, but where certain\n+     * @param thread the new owner thread\n+     * @return a new confined memory segment whose owner thread is set to {@code thread}.\n@@ -415,1 +414,2 @@\n-     * @throws NullPointerException if {@code handoffTransform == null}\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n+     * @throws NullPointerException if {@code thread == null}\n@@ -417,1 +417,1 @@\n-    MemorySegment handoff(HandoffTransform handoffTransform);\n+    MemorySegment handoff(Thread thread);\n@@ -420,2 +420,4 @@\n-     * Obtains a new memory segment backed by the same underlying memory region as this segment, but whose\n-     * temporal bounds are controlled by the provided {@link NativeScope} instance. This is a <em>terminal operation<\/em>;\n+     * Obtains a new confined memory segment backed by the same underlying memory region as this segment, but whose\n+     * temporal bounds are controlled by the provided {@link NativeScope} instance.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>;\n@@ -427,1 +429,1 @@\n-     * using {@link MemorySegment#close()} - but it will be closed indirectly when the native scope is closed. The\n+     * using {@link MemorySegment#close()} - but it will be closed indirectly when this native scope is closed. The\n@@ -430,1 +432,1 @@\n-     * In cases where the owner thread of the returned segment differs from that of this segment, write accesses to this\n+     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n@@ -436,1 +438,1 @@\n-     * @return a new memory segment backed by the same underlying memory region as this segment, but whose life-cycle\n+     * @return a new confined memory segment backed by the same underlying memory region as this segment, but whose life-cycle\n@@ -445,0 +447,40 @@\n+    \/**\n+     * Obtains a new shared memory segment backed by the same underlying memory region as this segment. The returned segment will\n+     * not be confined on any thread and can therefore be accessed concurrently from multiple threads; moreover, the\n+     * returned segment will feature the same spatial bounds and access modes (see {@link #accessModes()})\n+     * as this segment.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     * <p>\n+     * Write accesses to this segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n+     * to the returned segment's contents on a new thread.\n+     *\n+     * @return a new memory shared segment backed by the same underlying memory region as this segment.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws NullPointerException if {@code thread == null}\n+     *\/\n+    MemorySegment share();\n+\n+    \/**\n+     * Register this memory segment instance against a {@link Cleaner} object, by returning a new memory segment backed\n+     * by the same underlying memory region as this segment. The returned segment will feature the same confinement,\n+     * spatial bounds and access modes (see {@link #accessModes()}) as this segment. Moreover, the returned segment\n+     * will be associated with the specified {@link Cleaner} object; this allows for the segment to be closed\n+     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n+     * <p>\n+     * This is a <em>terminal operation<\/em>; as a side-effect, this segment will be\n+     * marked as <em>not alive<\/em>, and subsequent operations on this segment will fail with {@link IllegalStateException}.\n+     *\n+     * @param cleaner the cleaner object, responsible for implicit deallocation of the returned segment.\n+     * @return a new memory segment backed by the same underlying memory region as this segment, which features\n+     * implicit deallocation.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment, or if this segment is already associated with a cleaner.\n+     * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.\n+     * @throws NullPointerException if {@code thread == null}\n+     *\/\n+    MemorySegment registerCleaner(Cleaner cleaner);\n+\n@@ -876,2 +918,2 @@\n-     * Handoff access mode; this segment supports temporal bound changes (see {@link #handoff(NativeScope)} and\n-     * {@link #handoff(HandoffTransform)}).\n+     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #share()}).\n+     * (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n@@ -881,1 +923,1 @@\n-    int HANDOFF = CLOSE << 1;\n+    int SHARE = CLOSE << 1;\n@@ -884,1 +926,2 @@\n-     * Default access mode; this is a union of all the access modes supported by memory segments.\n+     * Handoff access mode; this segment support serial thread-confinement via thread ownership changes\n+     * (see {@link #handoff(NativeScope)} and {@link #handoff(Thread)}).\n@@ -888,1 +931,1 @@\n-    int ALL_ACCESS = READ | WRITE | CLOSE | HANDOFF;\n+    int HANDOFF = SHARE << 1;\n@@ -891,17 +934,3 @@\n-     * An <em>handoff transform<\/em> defines a transformation which applies to an existing memory segment (the\n-     * <em>source<\/em> segment) and results in a new segment (the <em>target<\/em> segment) with fresh temporal bounds\n-     * featuring new characteristics, such as a different confinement thread, or a custom cleanup action, or implicit\n-     * deallocation provided by a custom {@link Cleaner} instance. Handoff transforms are applied to segments using the\n-     * {@link #handoff(HandoffTransform)} method.\n-     * <p>\n-     * There are two kinds of handoff transforms: confined (see {@link #ofConfined()}, {@link #ofConfined(Thread)}) and\n-     * shared (see {@link #ofShared()}), which produce confined and shared target segments, respectively.\n-     *\n-     * @apiNote In the future, if the Java language permits, {@link HandoffTransform}\n-     * may become a {@code sealed} interface, which would prohibit subclassing except by\n-     * explicitly permitted subtypes.\n-     *\n-     * @implSpec\n-     * Implementations of this interface are not thread-safe.\n-     *\n-     * @see MemorySegment#handoff(HandoffTransform)\n+     * Default access mode; this is a union of all the access modes supported by memory segments.\n+     * @see MemorySegment#accessModes()\n+     * @see MemorySegment#withAccessModes(int)\n@@ -909,69 +938,1 @@\n-    interface HandoffTransform {\n-\n-        \/**\n-         * Creates a new shared handoff transform. The target segment produced by the returned transform is a shared\n-         * segment, which can be accessed concurrently from multiple threads.\n-         * @return a shared handoff transform.\n-         *\/\n-        static HandoffTransform ofShared() {\n-            return new AbstractMemorySegmentImpl.HandoffTransformImpl(null);\n-        }\n-\n-        \/**\n-         * Creates a new confined handoff transform, bound by a given thread. The target segment produced by the returned transform\n-         * is a confined segment, which will only be accessible by a specific thread.\n-         *\n-         * @param t the confinement thread.\n-         * @return a confined handoff transform.\n-         * @throws NullPointerException if {@code t == null}.\n-         *\/\n-        static HandoffTransform ofConfined(Thread t) {\n-            return new AbstractMemorySegmentImpl.HandoffTransformImpl(t);\n-        }\n-\n-        \/**\n-         * Creates a new confined handoff transform, bound by the current thread (see {@link Thread#currentThread()}).\n-         * The target segment produced by the returned transform is a confined segment, which will only be accessible by the current thread.\n-         *\n-         * @return a confined handoff transform.\n-         * @throws NullPointerException if {@code t == null}.\n-         *\/\n-        static HandoffTransform ofConfined() {\n-            return ofConfined(Thread.currentThread());\n-        }\n-\n-        \/**\n-         * Specifies an additional cleanup action to be associated with the target segment. More specifically, the target\n-         * segment produced by this transform will feature a cleanup action which will first call the user-provided action,\n-         * before delegating back to cleanup action associated with the source segment.\n-         * Any errors and\/or exceptions thrown by the user-provided action will be discarded, and will not prevent the\n-         * release of any memory resources associated with the target segment.\n-         *\n-         * @param action the new cleanup action\n-         * @return this handoff transform.\n-         * @throws NullPointerException if {@code action == null}\n-         *\/\n-        HandoffTransform addCleanupAction(Runnable action);\n-\n-        \/**\n-         * Specifies an additional attachment object which will be kept alive by the target segment, in addition\n-         * to any attachment object(s) which might also be associated with the source segment.\n-         * This can be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n-         *\n-         * @param attachment an attachment object that will be kept strongly reachable by the target segment produced\n-         *                   by this transform.\n-         * @return this handoff transform.\n-         * @throws NullPointerException if {@code attachment == null}\n-         *\/\n-        HandoffTransform addAttachment(Object attachment);\n-\n-        \/**\n-         * Specifies a {@link Cleaner} object which is responsible for calling the cleanup action on the target segment\n-         * should such segment become <em>unreachable<\/em> and not closed explicitly; this might be helpful in preventing\n-         * native memory leaks.\n-         * @param cleaner the {@link Cleaner} object responsible for cleaning up the target memory segment produced\n-         *                by this transform.\n-         * @return this handoff transform.\n-         *\/\n-        HandoffTransform registerCleaner(Cleaner cleaner);\n-    }\n+    int ALL_ACCESS = READ | WRITE | CLOSE | SHARE | HANDOFF;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":88,"deletions":127,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.function.Consumer;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -287,1 +287,2 @@\n-    public MemorySegment handoff(HandoffTransform handoffTransform) {\n+    public MemorySegment handoff(Thread thread) {\n+        Objects.requireNonNull(thread);\n@@ -293,1 +294,15 @@\n-            return dup(0L, length, mask, ((HandoffTransformImpl)handoffTransform).newScope(scope));\n+            return dup(0L, length, mask, scope.confineTo(thread));\n+        } finally {\n+            \/\/flush read\/writes to segment memory before returning the new segment\n+            VarHandle.fullFence();\n+        }\n+    }\n+\n+    @Override\n+    public MemorySegment share() {\n+        checkValidState();\n+        if (!isSet(SHARE)) {\n+            throw unsupportedAccessMode(SHARE);\n+        }\n+        try {\n+            return dup(0L, length, mask, scope.share());\n@@ -302,0 +317,1 @@\n+        Objects.requireNonNull(scope);\n@@ -309,1 +325,1 @@\n-        MemorySegment dup = handoff(HandoffTransform.ofConfined(scope.ownerThread()));\n+        MemorySegment dup = handoff(scope.ownerThread());\n@@ -314,57 +330,6 @@\n-    public static class HandoffTransformImpl implements HandoffTransform {\n-\n-        final Thread ownerThread;\n-        List<Runnable> cleanupActions = new ArrayList<>();\n-        List<Object> attachments = new ArrayList<>();\n-        List<Cleaner> cleaners = new ArrayList<>();\n-\n-        public HandoffTransformImpl(Thread thread) {\n-            this.ownerThread = thread;\n-        }\n-\n-        @Override\n-        public HandoffTransform addCleanupAction(Runnable action) {\n-            Objects.requireNonNull(action);\n-            cleanupActions.add(action);\n-            return this;\n-        }\n-\n-        @Override\n-        public HandoffTransform addAttachment(Object attachment) {\n-            Objects.requireNonNull(attachment);\n-            attachments.add(attachment);\n-            return this;\n-        }\n-\n-        @Override\n-        public HandoffTransform registerCleaner(Cleaner cleaner) {\n-            cleaners.add(cleaner);\n-            return this;\n-        }\n-\n-        MemoryScope newScope(MemoryScope scope) {\n-            \/\/ compute new composite cleanup action\n-            MemoryScope.CleanupAction cleanupAction = scope.cleanupAction.dup();\n-            for (Runnable action : cleanupActions) {\n-                cleanupAction = cleanupAction.wrap(action);\n-            }\n-            \/\/ compute new composite attachment\n-            Object attachment = scope.ref;\n-            for (Object o : attachments) {\n-                Object currentAttachment = attachment;\n-                attachment = attachment == null ?\n-                        o : new Object() {\n-                            Object o1 = currentAttachment;\n-                            Object o2 = o;\n-                        };\n-            }\n-            scope.justClose(); \/\/ kill the old scope\n-            \/\/create a new scope\n-            MemoryScope newScope = ownerThread != null ?\n-                    new MemoryScope.ConfinedScope(ownerThread, attachment, cleanupAction) :\n-                    new MemoryScope.SharedScope(attachment, cleanupAction);\n-            \/\/ register all cleaners\n-            for (Cleaner c : cleaners) {\n-                c.register(newScope, cleanupAction);\n-            }\n-            return newScope;\n+    @Override\n+    public MemorySegment registerCleaner(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        checkValidState();\n+        if (!isSet(CLOSE)) {\n+            throw unsupportedAccessMode(CLOSE);\n@@ -372,0 +337,1 @@\n+        return dup(0L, length, mask, scope.cleanable(cleaner));\n@@ -522,0 +488,3 @@\n+        if ((mode & SHARE) != 0) {\n+            modes.add(\"SHARE\");\n+        }\n@@ -644,1 +613,1 @@\n-            bufferScope = MemoryScope.createConfined(bb, MemoryScope.CleanupAction.DUMMY);\n+            bufferScope = MemoryScope.createConfined(bb, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n@@ -658,24 +627,0 @@\n-\n-    public static final AbstractMemorySegmentImpl NOTHING = new AbstractMemorySegmentImpl(\n-        0, 0, MemoryScope.createShared(null, MemoryScope.CleanupAction.DUMMY)\n-    ) {\n-        @Override\n-        ByteBuffer makeByteBuffer() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        @Override\n-        long min() {\n-            return 0;\n-        }\n-\n-        @Override\n-        Object base() {\n-            return null;\n-        }\n-\n-        @Override\n-        AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {\n-            throw new UnsupportedOperationException();\n-        }\n-    };\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":30,"deletions":85,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY);\n+        MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,6 +104,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n-                @Override\n-                public void doCleanup() {\n-                    unmapperProxy.unmap();\n-                }\n-            });\n+            MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap, null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,0 +95,9 @@\n+    @Override\n+    public MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment) {\n+        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize, cleanupAction, attachment);\n+    }\n+\n@@ -100,2 +109,1 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize)\n-                .handoff(MemorySegment.HandoffTransform.ofShared());\n+        return MemoryAddress.ofLong(value).asSegmentRestricted(byteSize, null, null).share();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.ref.PhantomCleanable;\n@@ -34,0 +35,1 @@\n+import java.lang.ref.Cleaner;\n@@ -52,1 +54,3 @@\n-    private MemoryScope(Object ref, CleanupAction cleanupAction) {\n+    static final Runnable DUMMY_CLEANUP_ACTION = () -> { };\n+\n+    private MemoryScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n@@ -56,0 +60,3 @@\n+        this.scopeCleanable = cleaner != null ?\n+                new ScopeCleanable(this, cleaner, cleanupAction) :\n+                null;\n@@ -65,2 +72,2 @@\n-    static MemoryScope createConfined(Object ref, CleanupAction cleanupAction) {\n-        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction);\n+    static MemoryScope createConfined(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction, cleaner);\n@@ -75,2 +82,2 @@\n-    static MemoryScope createShared(Object ref, CleanupAction cleanupAction) {\n-        return new SharedScope(ref, cleanupAction);\n+    static MemoryScope createShared(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+        return new SharedScope(ref, cleanupAction, cleaner);\n@@ -80,1 +87,2 @@\n-    protected final CleanupAction cleanupAction;\n+    protected final ScopeCleanable scopeCleanable;\n+    protected final Runnable cleanupAction;\n@@ -100,1 +108,4 @@\n-            cleanupAction.cleanup();\n+            cleanupAction.run();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n@@ -108,0 +119,57 @@\n+    \/**\n+     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n+     * @param newOwner new owner thread of the returned memory scope\n+     * @return a new confined scope, which is a duplicate of this scope, but with a new owner thread.\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n+     *\/\n+    MemoryScope confineTo(Thread newOwner) {\n+        try {\n+            justClose();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+            return new ConfinedScope(newOwner, ref, cleanupAction, scopeCleanable != null ?\n+                    scopeCleanable.cleaner : null);\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+    \/**\n+     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n+     * @return a new shared scope, which is a duplicate of this scope.\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread,\n+     * or if this is already a shared scope.\n+     *\/\n+    MemoryScope share() {\n+        try {\n+            justClose();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+            return new SharedScope(ref, cleanupAction, scopeCleanable != null ?\n+                    scopeCleanable.cleaner : null);\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+    MemoryScope cleanable(Cleaner cleaner) {\n+        if (scopeCleanable != null) {\n+            throw new IllegalStateException(\"Already registered with a cleaner\");\n+        }\n+        try {\n+            justClose();\n+            if (scopeCleanable != null) {\n+                scopeCleanable.clear();\n+            }\n+            return ownerThread() == null ?\n+                    new SharedScope(ref, cleanupAction, cleaner) :\n+                    new ConfinedScope(ownerThread(), ref, cleanupAction, cleaner);\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n@@ -156,2 +224,2 @@\n-        public ConfinedScope(Thread owner, Object ref, CleanupAction cleanupAction) {\n-            super(ref, cleanupAction);\n+        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+            super(ref, cleanupAction, cleaner);\n@@ -194,2 +262,2 @@\n-        SharedScope(Object ref, CleanupAction cleanupAction) {\n-            super(ref, cleanupAction);\n+        SharedScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n+            super(ref, cleanupAction, cleaner);\n@@ -216,7 +284,3 @@\n-    \/**\n-     * A functional interface modelling the cleanup action associated with a scope.\n-     *\/\n-    interface CleanupAction extends Runnable {\n-        void cleanup();\n-        CleanupAction dup();\n-        CleanupAction wrap(Runnable runnable);\n+    static class ScopeCleanable extends PhantomCleanable<MemoryScope> {\n+        final Cleaner cleaner;\n+        Runnable cleanupAction;\n@@ -224,3 +288,4 @@\n-        @Override\n-        default void run() {\n-            cleanup();\n+        public ScopeCleanable(MemoryScope referent, Cleaner cleaner, Runnable cleanupAction) {\n+            super(referent, cleaner);\n+            this.cleaner = cleaner;\n+            this.cleanupAction = cleanupAction;\n@@ -229,107 +294,3 @@\n-        \/** Dummy cleanup action *\/\n-        CleanupAction DUMMY = new CleanupAction() {\n-            @Override\n-            public void cleanup() {\n-                \/\/ do nothing\n-            }\n-\n-            @Override\n-            public CleanupAction dup() {\n-                return this;\n-            }\n-\n-            @Override\n-            public CleanupAction wrap(Runnable runnable) {\n-                return AtMostOnceOnly.of(runnable);\n-            }\n-        };\n-\n-        \/**\n-         * A stateful cleanup action; this action can only be called at most once. The implementation\n-         * guarantees this invariant even when multiple threads race to call the {@link #cleanup()} method.\n-         *\/\n-        abstract class AtMostOnceOnly implements CleanupAction {\n-\n-            static final VarHandle CALLED;\n-\n-            static {\n-                try {\n-                    CALLED = MethodHandles.lookup().findVarHandle(AtMostOnceOnly.class, \"called\", boolean.class);\n-                } catch (Throwable ex) {\n-                    throw new ExceptionInInitializerError(ex);\n-                }\n-            }\n-\n-            private boolean called = false;\n-\n-            abstract void doCleanup();\n-\n-            public final void cleanup() {\n-                if (disable()) {\n-                    doCleanup();\n-                }\n-            };\n-\n-            @Override\n-            public CleanupAction dup() {\n-                disable();\n-                return new DupAction(this);\n-            }\n-\n-            @Override\n-            public CleanupAction wrap(Runnable runnable) {\n-                disable();\n-                return AtMostOnceOnly.of(() -> {\n-                    try {\n-                        runnable.run();\n-                    } catch (Throwable t) {\n-                        \/\/ ignore\n-                    } finally {\n-                        doCleanup();\n-                    }\n-                });\n-            }\n-\n-            \/\/where\n-            static class DupAction extends AtMostOnceOnly {\n-                final AtMostOnceOnly root;\n-\n-                DupAction(AtMostOnceOnly root) {\n-                    this.root = root;\n-                }\n-\n-                @Override\n-                void doCleanup() {\n-                    root.doCleanup();\n-                }\n-\n-                @Override\n-                public CleanupAction dup() {\n-                    disable();\n-                    return new DupAction(root);\n-                }\n-            }\n-\n-            final boolean disable() {\n-                \/\/ This can fail under normal circumstances. The only case where a failure can happen is when\n-                \/\/ when two cleaners race to cleanup the same scope. It is never possible to have a race\n-                \/\/ between explicit\/implicit close because all the scope terminal operations have\n-                \/\/ reachability fences which prevent a scope to be deemed unreachable before we are done\n-                \/\/ marking the original cleanup action as \"dead\".\n-                return CALLED.compareAndSet(this, false, true);\n-            }\n-\n-            \/**\n-             * Returns a custom {@code BasicCleanupAction} based on given {@link Runnable} instance.\n-             * @param runnable the runnable to be executed when {@link #cleanup()} is called on the returned cleanup action.\n-             * @return the new cleanup action.\n-             *\/\n-            static AtMostOnceOnly of(Runnable runnable) {\n-                Objects.requireNonNull(runnable);\n-                return new AtMostOnceOnly() {\n-                    @Override\n-                    void doCleanup() {\n-                        runnable.run();\n-                    }\n-                };\n-            }\n+        @Override\n+        protected void performCleanup() {\n+            cleanupAction.run();\n@@ -338,1 +299,0 @@\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":89,"deletions":129,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -44,2 +44,2 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE)\n-            .handoff(HandoffTransform.ofShared())\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, MemoryScope.DUMMY_CLEANUP_ACTION, null)\n+            .share()\n@@ -101,3 +101,1 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, new MemoryScope.CleanupAction.AtMostOnceOnly() {\n-            @Override\n-            public void doCleanup() {\n+        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n@@ -106,2 +104,1 @@\n-            }\n-        });\n+            }, null);\n@@ -117,1 +114,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize) {\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, Object ref) {\n@@ -119,1 +116,1 @@\n-                MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY));\n+                MemoryScope.createConfined(ref, cleanupAction == null ? MemoryScope.DUMMY_CLEANUP_ACTION : cleanupAction, null));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.MemoryAddressImpl;\n@@ -35,4 +36,4 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0)\n-                .handoff(MemorySegment.HandoffTransform.ofShared()\n-                                      .addCleanupAction(() -> freeUpcallStub(stubAddress)))\n-                .withAccessModes(MemorySegment.CLOSE | MemorySegment.HANDOFF);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(\n+                MemoryAddress.ofLong(stubAddress), 0, () -> freeUpcallStub(stubAddress), null)\n+                .share()\n+                .withAccessModes(MemorySegment.CLOSE | MemorySegment.HANDOFF | MemorySegment.SHARE);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -127,4 +127,3 @@\n-        MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(\n-                MemoryAddress.ofLong(ptr), LAYOUT.byteSize())\n-                .handoff(MemorySegment.HandoffTransform.ofShared()\n-                               .addCleanupAction(() -> U.freeMemory(ptr)));\n+        MemorySegment ms = MemoryAddress.ofLong(ptr)\n+                .asSegmentRestricted(LAYOUT.byteSize(), () -> U.freeMemory(ptr), null)\n+                .share();\n@@ -564,1 +563,1 @@\n-                segment : segment.handoff(MemorySegment.HandoffTransform.ofConfined(thread));\n+                segment : segment.handoff(thread);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -134,4 +134,3 @@\n-        MemorySegment base = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(\n-                MemoryAddress.ofLong(ptr), LAYOUT.byteSize())\n-                .handoff(MemorySegment.HandoffTransform.ofShared()\n-                        .addCleanupAction(() -> U.freeMemory(ptr)));\n+        MemorySegment base = MemoryAddress.ofLong(ptr)\n+                .asSegmentRestricted(LAYOUT.byteSize(), () -> U.freeMemory(ptr), null)\n+                .share();\n@@ -481,1 +480,1 @@\n-                segment : segment.handoff(MemorySegment.HandoffTransform.ofConfined(thread));\n+            segment : segment.handoff(thread);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-                segment : segment.handoff(MemorySegment.HandoffTransform.ofConfined(thread));\n+                segment : segment.handoff(thread);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng TestCleaner\n+ * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n@@ -44,0 +44,1 @@\n+import java.util.stream.Stream;\n@@ -60,1 +61,1 @@\n-    public void test(int n, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n+    public void testAtMostOnce(RegisterKind registerKind, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n@@ -62,7 +63,9 @@\n-        MemorySegment segment = MemorySegment.allocateNative(10)\n-                .handoff(MemorySegment.HandoffTransform.ofConfined()\n-                        .addCleanupAction(segmentState::cleanup));\n-        \/\/ register cleaners before\n-        for (int i = 0 ; i < n ; i++) {\n-            segment = segment.handoff(MemorySegment.HandoffTransform.ofConfined()\n-                    .registerCleaner(cleanerFactory.get()));\n+        MemorySegment root = MemorySegment.allocateNative(10).share();\n+        MemorySegment segment = root.address().asSegmentRestricted(10, () -> {\n+            root.close();\n+            segmentState.cleanup();\n+        }, null);\n+\n+        if (registerKind == RegisterKind.BEFORE) {\n+            \/\/ register cleaners before\n+            segment = segment.registerCleaner(cleanerFactory.get());\n@@ -70,0 +73,3 @@\n+\n+        kickGCAndCheck(segmentState, segment);\n+\n@@ -71,6 +77,6 @@\n-        if (segment.isAlive()) {\n-            \/\/ also register cleaners after\n-            for (int i = 0; i < n; i++) {\n-                segment = segment.handoff(MemorySegment.HandoffTransform.ofConfined()\n-                        .registerCleaner(cleanerFactory.get()));\n-            }\n+\n+        kickGCAndCheck(segmentState, segment);\n+\n+        if (segment.isAlive() && registerKind == RegisterKind.AFTER) {\n+            \/\/ register cleaners after\n+            segment = segment.registerCleaner(cleanerFactory.get());\n@@ -78,2 +84,2 @@\n-        \/\/check that cleanup has not been called by any cleaner yet!\n-        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n+\n+        kickGCAndCheck(segmentState, segment);\n@@ -93,0 +99,27 @@\n+    private void kickGCAndCheck(SegmentState segmentState, MemorySegment segment) {\n+        for (int i = 0 ; i < 100 ; i++) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            Thread.onSpinWait();\n+        }\n+        \/\/check that cleanup has not been called by any cleaner yet!\n+        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n+    }\n+\n+    @Test(dataProvider = \"segmentFunctions\")\n+    public void testBadDoubleRegister(Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n+        MemorySegment segment = MemorySegment.allocateNative(10);\n+        segment = segment.registerCleaner(cleanerFactory.get());\n+        segment = segmentFunction.apply(segment);\n+        try {\n+            segment.registerCleaner(cleanerFactory.get()); \/\/ error here!\n+            fail();\n+        } catch (IllegalStateException ex) {\n+            if (!segment.isAlive()) {\n+                assertTrue(ex.getMessage().contains(\"This segment is already closed\"));\n+            } else {\n+                assertTrue(ex.getMessage().contains(\"Already registered with a cleaner\"));\n+            }\n+        }\n+    }\n+\n@@ -96,1 +129,1 @@\n-        SHARE(s -> { return s.handoff(MemorySegment.HandoffTransform.ofShared()); });\n+        SHARE(s -> { return s.share(); });\n@@ -110,0 +143,25 @@\n+    @DataProvider\n+    static Object[][] segmentFunctions() {\n+        Supplier<?>[] cleaners = {\n+                (Supplier<Cleaner>)Cleaner::create,\n+                (Supplier<Cleaner>)CleanerFactory::cleaner\n+        };\n+\n+        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n+        Object[][] data = new Object[cleaners.length * segmentFunctions.length][3];\n+\n+        for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n+            for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n+                data[cleaner + (cleaners.length * segmentFunction)] =\n+                        new Object[] { cleaners[cleaner], segmentFunctions[segmentFunction] };\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    enum RegisterKind {\n+        BEFORE,\n+        AFTER;\n+    }\n+\n@@ -117,1 +175,1 @@\n-        int[] ncleaners = { 1, 2, 4, 8, 16 };\n+        RegisterKind[] kinds = RegisterKind.values();\n@@ -120,1 +178,1 @@\n-        Object[][] data = new Object[cleaners.length * ncleaners.length * segmentFunctions.length][3];\n+        Object[][] data = new Object[cleaners.length * kinds.length * segmentFunctions.length][3];\n@@ -122,1 +180,1 @@\n-        for (int ncleaner = 0 ; ncleaner < ncleaners.length ; ncleaner++) {\n+        for (int kind = 0 ; kind < kinds.length ; kind++) {\n@@ -125,2 +183,2 @@\n-                    data[ncleaner + ncleaners.length * cleaner + (cleaners.length * ncleaners.length * segmentFunction)] =\n-                            new Object[] { ncleaners[ncleaner], cleaners[cleaner], segmentFunctions[segmentFunction] };\n+                    data[kind + kinds.length * cleaner + (cleaners.length * kinds.length * segmentFunction)] =\n+                            new Object[] { kinds[kind], cleaners[cleaner], segmentFunctions[segmentFunction] };\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":81,"deletions":23,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE)\n-                    .handoff(MemorySegment.HandoffTransform.ofShared());\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n@@ -149,2 +148,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE)\n-                    .handoff(MemorySegment.HandoffTransform.ofShared());\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,2 +175,1 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n-                .handoff(HandoffTransform.ofShared().addCleanupAction(() -> free(addr)));\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), null);\n@@ -193,2 +192,1 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n-                .handoff(HandoffTransform.ofShared().addCleanupAction(() -> free(addr)));\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), null);\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -171,2 +170,1 @@\n-        MemorySegment unconfined = MemorySegment.allocateNative(10)\n-                .handoff(MemorySegment.HandoffTransform.ofShared());\n+        MemorySegment unconfined = MemorySegment.allocateNative(10).share();\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -327,0 +327,3 @@\n+                \"share\",\n+                \"handoff\",\n+                \"registerCleaner\",\n@@ -336,2 +339,1 @@\n-                \"toDoubleArray\",\n-                \"handoff\"\n+                \"toDoubleArray\"\n@@ -392,0 +394,6 @@\n+        SHARE(MemorySegment.SHARE) {\n+            @Override\n+            void run(MemorySegment segment) {\n+                segment.share();\n+            }\n+        },\n@@ -413,1 +421,1 @@\n-                segment.handoff(HandoffTransform.ofConfined(new Thread()));\n+                segment.handoff(new Thread());\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                confined.set(confined.get().handoff(MemorySegment.HandoffTransform.ofConfined(owner)));\n+                confined.set(confined.get().handoff(owner));\n@@ -64,1 +64,1 @@\n-            confined.set(confined.get().handoff(MemorySegment.HandoffTransform.ofConfined(t)));\n+            confined.set(confined.get().handoff(t));\n@@ -78,1 +78,1 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(layout).handoff(MemorySegment.HandoffTransform.ofShared())) {\n+        try (MemorySegment s = MemorySegment.allocateNative(layout).share()) {\n@@ -126,2 +126,1 @@\n-            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize())\n-                    .handoff(MemorySegment.HandoffTransform.ofShared());\n+            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize()).share();\n@@ -147,1 +146,1 @@\n-            .withAccessModes(MemorySegment.CLOSE).handoff(MemorySegment.HandoffTransform.ofConfined(new Thread()));\n+            .withAccessModes(MemorySegment.CLOSE).handoff(new Thread());\n@@ -153,1 +152,1 @@\n-                .withAccessModes(MemorySegment.CLOSE).handoff(MemorySegment.HandoffTransform.ofShared());\n+                .withAccessModes(MemorySegment.CLOSE).share();\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout)\n-                .handoff(HandoffTransform.ofShared());\n+        MemorySegment segment = MemorySegment.allocateNative(layout).share();\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE)\n-                .handoff(MemorySegment.HandoffTransform.ofShared());\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE)\n-                .handoff(MemorySegment.HandoffTransform.ofShared());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,2 +88,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE)\n-                .handoff(MemorySegment.HandoffTransform.ofShared());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}