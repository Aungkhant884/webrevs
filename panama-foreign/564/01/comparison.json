{"files":[{"patch":"@@ -239,0 +239,4 @@\n+    \/**\n+     * The layout for the {@code bool} C type\n+     *\/\n+    ValueLayout C_BOOL = pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);\n@@ -714,0 +718,4 @@\n+        \/**\n+         * A kind corresponding to the <em>integral<\/em> C {@code bool} type\n+         *\/\n+        BOOL(true),\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    private static final VarHandle bool_handle = MemoryHandles.varHandle(boolean.class, ByteOrder.nativeOrder());\n@@ -126,0 +127,26 @@\n+    \/**\n+     * Reads a boolean from given segment and offset.\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @return a boolean value read from {@code segment}.\n+     *\/\n+    @ForceInline\n+    public static boolean getBooleanAtOffset(MemorySegment segment, long offset) {\n+        Objects.requireNonNull(segment);\n+        return (boolean)bool_handle.get(segment, offset);\n+    }\n+\n+    \/**\n+     * Writes a boolean at given segment and offset.\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n+     * @param value the boolean value to be written.\n+     *\/\n+    @ForceInline\n+    public static void setBooleanAtOffset(MemorySegment segment, long offset, boolean value) {\n+        Objects.requireNonNull(segment);\n+        bool_handle.set(segment, offset, value);\n+    }\n+\n@@ -626,0 +653,31 @@\n+    \/**\n+     * Reads a boolean from given segment.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    boolean value = getBooleanAtOffset(segment, 0L);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param segment the segment to be dereferenced.\n+     * @return a boolean value read from {@code segment}.\n+     *\/\n+    @ForceInline\n+    public static boolean getBoolean(MemorySegment segment) {\n+        return getBooleanAtOffset(segment, 0L);\n+    }\n+\n+    \/**\n+     * Writes a boolean at given segment.\n+     * <p>\n+     * This is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    setBooleanAtOffset(segment, 0L, value);\n+     * }<\/pre><\/blockquote>\n+     * @param segment the segment to be dereferenced.\n+     * @param value the boolean value to be written.\n+     *\/\n+    @ForceInline\n+    public static void setBoolean(MemorySegment segment, boolean value) {\n+        setBooleanAtOffset(segment, 0L, value);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the\n+ * (all primitive types but {@code void}, as well as {@link MemoryAddress} are supported), as well as the alignment constraint and the\n@@ -80,1 +80,1 @@\n- *     {@code float} or {@code double}.\n+ *     {@code float}, {@code double} or {@link MemoryAddress}.\n@@ -83,1 +83,1 @@\n- * <li>numeric atomic update access modes for {@code int} and {@code long}.\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n@@ -86,1 +86,1 @@\n- * <li>bitwise atomic update access modes for {@code int} and {@code long}.\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n@@ -91,1 +91,1 @@\n- * If {@code T} is {@code float} or {@code double} then atomic\n+ * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n@@ -93,2 +93,2 @@\n- * (see {@link Float#floatToRawIntBits} and\n- * {@link Double#doubleToRawLongBits}, respectively).\n+ * (see {@link Float#floatToRawIntBits},\n+ * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n@@ -169,2 +169,2 @@\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, and {@code double}.\n+     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code boolean}, {@code short}, {@code char}, {@code int},\n+     * {@code float}, {@code long}, {@code double} and {@link MemoryAddress}.\n@@ -195,2 +195,2 @@\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, and {@code double}.\n+     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code boolean}, {@code short}, {@code char}, {@code int},\n+     * {@code float}, {@code long}, {@code double} and {@link MemoryAddress}.\n@@ -212,1 +212,1 @@\n-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder));\n+        return Utils.makeMemoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder);\n@@ -525,1 +525,1 @@\n-        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {\n+        if ((!carrier.isPrimitive() && carrier != MemoryAddress.class) || carrier == void.class) {\n@@ -531,2 +531,6 @@\n-        long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());\n-        return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);\n+        if (carrier == MemoryAddress.class) {\n+            return MemoryLayouts.ADDRESS.byteSize();\n+        } else {\n+            long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());\n+            return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -485,2 +485,2 @@\n-     * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},\n-     * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),\n+     * @throws IllegalArgumentException if the carrier is {@code void}, or a non-primitive type other than {@link MemoryAddress},\n+     * or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,0 +116,5 @@\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code boolean}, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     *\/\n+    public static final ValueLayout JAVA_BOOLEAN = MemoryLayout.valueLayout(8, ByteOrder.nativeOrder());\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -60,2 +58,0 @@\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n-\n@@ -168,2 +164,2 @@\n-        VarHandle handle = Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,\n-                ((ValueLayout)layout).order()));\n+        VarHandle handle = Utils.makeMemoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,\n+                ((ValueLayout)layout).order());\n@@ -229,2 +225,1 @@\n-        } else if (enclosing.layout instanceof SequenceLayout) {\n-            SequenceLayout seq = (SequenceLayout)enclosing.layout;\n+        } else if (enclosing.layout instanceof SequenceLayout seq) {\n@@ -236,2 +231,1 @@\n-        } else if (enclosing.layout instanceof GroupLayout) {\n-            GroupLayout g = (GroupLayout)enclosing.layout;\n+        } else if (enclosing.layout instanceof GroupLayout g) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,0 +53,5 @@\n+    private static ValueLayout ofBool(ByteOrder order, long bitSize) {\n+        return MemoryLayout.valueLayout(bitSize, order)\n+                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.BOOL);\n+    }\n+\n@@ -106,0 +111,5 @@\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout C_BOOL = ofBool(LITTLE_ENDIAN, 8);\n+\n@@ -167,0 +177,5 @@\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout C_BOOL = ofBool(LITTLE_ENDIAN, 8);\n+\n@@ -231,0 +246,5 @@\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout C_BOOL = ofBool(LITTLE_ENDIAN, 8);\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -38,0 +39,1 @@\n+import java.nio.ByteOrder;\n@@ -52,0 +54,2 @@\n+    private static final MethodHandle BYTE_TO_BOOL;\n+    private static final MethodHandle BOOL_TO_BYTE;\n@@ -62,0 +66,4 @@\n+            BYTE_TO_BOOL = lookup.findStatic(Utils.class, \"byteToBoolean\",\n+                    MethodType.methodType(boolean.class, byte.class));\n+            BOOL_TO_BYTE = lookup.findStatic(Utils.class, \"booleanToByte\",\n+                    MethodType.methodType(byte.class, boolean.class));\n@@ -94,1 +102,14 @@\n-    public static VarHandle fixUpVarHandle(VarHandle handle) {\n+    public static VarHandle makeMemoryAccessVarHandle(Class<?> carrier, boolean skipAlignmentCheck, long alignmentMask, ByteOrder order) {\n+        Class<?> baseCarrier = carrier;\n+        if (carrier == MemoryAddress.class) {\n+            baseCarrier = switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+                case 8 -> long.class;\n+                case 4 -> int.class;\n+                default -> throw new UnsupportedOperationException(\"Unsupported address layout\");\n+            };\n+        } else if (carrier == boolean.class) {\n+            baseCarrier = byte.class;\n+        }\n+\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck, alignmentMask, order);\n+\n@@ -97,1 +118,1 @@\n-        return SHOULD_ADAPT_HANDLES\n+        handle = SHOULD_ADAPT_HANDLES\n@@ -100,0 +121,7 @@\n+        if (carrier == boolean.class) {\n+            return MemoryHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n+        } else if (carrier == MemoryAddress.class) {\n+            return MemoryHandles.asAddressVarHandle(handle);\n+        } else {\n+            return handle;\n+        }\n@@ -108,1 +136,1 @@\n-        if (!isValidPrimitiveCarrier(carrier))\n+        if (!isValidPrimitiveCarrier(carrier) && carrier != MemoryAddress.class)\n@@ -110,1 +138,5 @@\n-        if (Wrapper.forPrimitiveType(carrier).bitWidth() != layout.bitSize())\n+        if (carrier == MemoryAddress.class && layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()) {\n+            throw new IllegalArgumentException(\"Address size mismatch: \" + MemoryLayouts.ADDRESS.byteSize() + \" != \" + layout.bitSize());\n+        }\n+        if (carrier.isPrimitive() && Wrapper.forPrimitiveType(carrier).bitWidth() != layout.bitSize() &&\n+                carrier != boolean.class && layout.byteSize() != 1) {\n@@ -112,0 +144,1 @@\n+        }\n@@ -115,1 +148,2 @@\n-        return carrier == byte.class\n+        return carrier == boolean.class\n+            || carrier == byte.class\n@@ -128,0 +162,8 @@\n+\n+    private static boolean byteToBoolean(byte b) {\n+        return b != 0;\n+    }\n+\n+    private static byte booleanToByte(boolean b) {\n+        return b ? (byte)1 : (byte)0;\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-        if (!type.isPrimitive() || type == void.class || type == boolean.class)\n+        if (!type.isPrimitive() || type == void.class)\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,6 +501,0 @@\n-    public static VarHandle vhPrimitiveOrAddress(Class<?> carrier, MemoryLayout layout) {\n-        return carrier == MemoryAddress.class\n-            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n-            : layout.varHandle(carrier);\n-    }\n-\n@@ -578,3 +572,1 @@\n-            return carrier == MemoryAddress.class\n-                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n-                : layout.varHandle(carrier);\n+            return layout.varHandle(carrier);\n@@ -663,0 +655,2 @@\n+        } else if (type == boolean.class) {\n+            MemoryAccess.setBoolean(ptr, (boolean) o);\n@@ -683,0 +677,2 @@\n+        } else if (type == boolean.class) {\n+            MemoryAccess.setBoolean(ptr, (boolean) o);\n@@ -703,0 +699,2 @@\n+        } else if (type == boolean.class) {\n+            return MemoryAccess.getBoolean(ptr);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n+            case BOOL, CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;\n@@ -268,1 +267,1 @@\n-                    VarHandle reader = vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle(carrier);\n@@ -308,2 +307,1 @@\n-                    VarHandle ptrReader\n-                        = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class, AArch64.C_POINTER);\n+                    VarHandle ptrReader = AArch64.C_POINTER.varHandle(MemoryAddress.class);\n@@ -320,1 +318,1 @@\n-                    VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle(carrier);\n@@ -485,3 +483,1 @@\n-                        VarHandle writer\n-                            = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class,\n-                                                               AArch64.C_POINTER);\n+                        VarHandle writer = AArch64.C_POINTER.varHandle(MemoryAddress.class);\n@@ -493,1 +489,1 @@\n-                        VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                        VarHandle writer = layout.varHandle(carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            VarHandle reader = layout.varHandle(carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;\n@@ -241,1 +240,1 @@\n-                    VarHandle reader = vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle(carrier);\n@@ -272,1 +271,1 @@\n-                    VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle(carrier);\n@@ -410,1 +409,1 @@\n-                        VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                        VarHandle writer = layout.varHandle(carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> ArgumentClassImpl.INTEGER;\n+            case BOOL, CHAR, SHORT, INT, LONG, LONG_LONG -> ArgumentClassImpl.INTEGER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n+            case BOOL, CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            VarHandle reader = layout.varHandle(carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,5 +79,0 @@\n-            {\n-                MethodType.methodType(void.class, boolean.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_8_LE),\n-                \"Unsupported carrier\"\n-            },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,6 +108,7 @@\n-        addIdentity.add(\"identity_char\",   byte.class,   C_CHAR,   (byte) 10);\n-        addIdentity.add(\"identity_short\",  short.class,  C_SHORT, (short) 10);\n-        addIdentity.add(\"identity_int\",    int.class,    C_INT,           10);\n-        addIdentity.add(\"identity_long\",   long.class,   C_LONG_LONG,     10L);\n-        addIdentity.add(\"identity_float\",  float.class,  C_FLOAT,         10F);\n-        addIdentity.add(\"identity_double\", double.class, C_DOUBLE,        10D);\n+        addIdentity.add(\"identity_bool\",   boolean.class, C_BOOL,   true);\n+        addIdentity.add(\"identity_char\",   byte.class,    C_CHAR,   (byte) 10);\n+        addIdentity.add(\"identity_short\",  short.class,   C_SHORT, (short) 10);\n+        addIdentity.add(\"identity_int\",    int.class,     C_INT,           10);\n+        addIdentity.add(\"identity_long\",   long.class,    C_LONG_LONG,     10L);\n+        addIdentity.add(\"identity_float\",  float.class,   C_FLOAT,         10F);\n+        addIdentity.add(\"identity_double\", double.class,  C_DOUBLE,        10D);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -385,0 +386,1 @@\n+                { ID, MemoryLayouts.BITS_8_BE, boolean.class, MatrixChecker.BOOLEAN },\n@@ -389,0 +391,1 @@\n+                { ID, MemoryLayouts.BITS_64_BE, MemoryAddress.class, MatrixChecker.ADDR },\n@@ -393,0 +396,1 @@\n+                { IMMUTABLE, MemoryLayouts.BITS_8_BE, boolean.class, MatrixChecker.BOOLEAN },\n@@ -397,0 +401,1 @@\n+                { IMMUTABLE, MemoryLayouts.BITS_64_BE, MemoryAddress.class, MatrixChecker.ADDR },\n@@ -401,0 +406,1 @@\n+                { ID, MemoryLayouts.BITS_8_LE, boolean.class, MatrixChecker.BOOLEAN },\n@@ -405,0 +411,1 @@\n+                { ID, MemoryLayouts.BITS_64_LE, MemoryAddress.class, MatrixChecker.ADDR },\n@@ -409,0 +416,1 @@\n+                { IMMUTABLE, MemoryLayouts.BITS_8_LE, boolean.class, MatrixChecker.BOOLEAN },\n@@ -413,0 +421,1 @@\n+                { IMMUTABLE, MemoryLayouts.BITS_64_LE, MemoryAddress.class, MatrixChecker.ADDR },\n@@ -426,0 +435,5 @@\n+        MatrixChecker BOOLEAN = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+        };\n+\n@@ -446,0 +460,5 @@\n+        MatrixChecker ADDR = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, MemoryAddress.ofLong(r + c));\n+            assertEquals(MemoryAddress.ofLong(r + c), (MemoryAddress)handle.get(segment, r, c));\n+        };\n+\n@@ -461,1 +480,0 @@\n-                { boolean.class },\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -112,0 +112,4 @@\n+                {\"bool\", new Accessor<>(false,\n+                        MemoryAccess::getBoolean, MemoryAccess::setBoolean,\n+                        (bb) -> bb.get(0) != 0, (bb, v) -> bb.put(0, v ? (byte)1 : (byte)0))\n+                },\n@@ -181,0 +185,5 @@\n+                \/\/ bool, offset\n+                {\"bool\", new Accessor<>(false,\n+                        s -> MemoryAccess.getBooleanAtOffset(s, 4), (s, x) -> MemoryAccess.setBooleanAtOffset(s, 4, x),\n+                        (bb) -> bb.get(4) != 0, (bb, v) -> bb.put(4, v ? (byte)1 : (byte)0))\n+                },\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-                { boolean.class },\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include <stdbool.h>\n+\n@@ -34,0 +36,4 @@\n+EXPORT bool identity_bool(bool x) {\n+    return x;\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/libIntrinsics.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}