{"files":[{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Superclass for .java source generator classes.\n+ *\/\n+abstract class ClassSourceBuilder extends JavaSourceBuilder {\n+\n+    enum Kind {\n+        CLASS(\"class\"),\n+        INTERFACE(\"interface\");\n+\n+        final String kindName;\n+\n+        Kind(String kindName) {\n+            this.kindName = kindName;\n+        }\n+    }\n+\n+    final Kind kind;\n+    final ClassDesc desc;\n+    protected final JavaSourceBuilder enclosing;\n+\n+    \/\/ code buffer\n+    private StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    ClassSourceBuilder(JavaSourceBuilder enclosing, Kind kind, String name) {\n+        this.enclosing = enclosing;\n+        this.align = (enclosing instanceof ClassSourceBuilder) ?\n+            ((ClassSourceBuilder) enclosing).align : 0;\n+        this.kind = kind;\n+        this.desc = ClassDesc.of(enclosing.packageName(), enclosing.uniqueNestedClassName(name));\n+    }\n+\n+    boolean isNested() {\n+        return enclosing instanceof ClassSourceBuilder;\n+    }\n+\n+    String className() {\n+        return desc.displayName();\n+    }\n+\n+    String fullName() {\n+        return isNested() ?\n+                ((ClassSourceBuilder)enclosing).className() + \".\" + className() :\n+                className();\n+    }\n+\n+    @Override\n+    public final String packageName() {\n+        return desc.packageName();\n+    }\n+\n+    String superClass() {\n+        return null;\n+    }\n+\n+    String mods() {\n+        return (!isNested() || kind == Kind.INTERFACE) ?\n+                    \"public \" : \"public static \";\n+    }\n+\n+    void classBegin() {\n+        if (isNested()) {\n+            incrAlign();\n+        }\n+        emitPackagePrefix();\n+        emitImportSection();\n+\n+        indent();\n+        append(mods());\n+        append(kind.kindName + \" \" + className());\n+        if (superClass() != null) {\n+            append(\" extends \");\n+            append(superClass());\n+        }\n+        append(\" {\\n\\n\");\n+    }\n+\n+    JavaSourceBuilder classEnd() {\n+        indent();\n+        append(\"}\\n\\n\");\n+        if (isNested()) {\n+            decrAlign();\n+            ((ClassSourceBuilder)enclosing).append(build());\n+            sb = null;\n+        }\n+        return enclosing;\n+    }\n+\n+    @Override\n+    public List<JavaFileObject> toFiles() {\n+        if (isNested()) {\n+            throw new UnsupportedOperationException(\"Nested builder!\");\n+        }\n+        String res = build();\n+        sb = null;\n+        return List.of(Utils.fileFromString(packageName(), className(), res));\n+    }\n+\n+    \/\/ Internal generation helpers (used by other builders)\n+\n+    void append(String s) {\n+        sb.append(s);\n+    }\n+\n+    void append(char c) {\n+        sb.append(c);\n+    }\n+\n+    void append(boolean b) {\n+        sb.append(b);\n+    }\n+\n+    void append(long l) {\n+        sb.append(l);\n+    }\n+\n+    void indent() {\n+        for (int i = 0; i < align; i++) {\n+            append(\"    \");\n+        }\n+    }\n+\n+    void incrAlign() {\n+        align++;\n+    }\n+\n+    void decrAlign() {\n+        align--;\n+    }\n+\n+    String build() {\n+        String s = sb.toString();\n+        return s;\n+    }\n+\n+    \/\/ is the name enclosed enclosed by a class of the same name?\n+    boolean isEnclosedBySameName(String name) {\n+        return className().equals(name) ||\n+                (isNested() && enclosing.isEnclosedBySameName(name));\n+    }\n+\n+    protected void emitPackagePrefix() {\n+        if (!isNested()) {\n+            assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n+            append(\"\/\/ Generated by jextract\\n\\n\");\n+            if (!packageName().isEmpty()) {\n+                append(\"package \");\n+                append(packageName());\n+                append(\";\\n\\n\");\n+            }\n+        }\n+    }\n+\n+    protected void emitImportSection() {\n+        if (!isNested()) {\n+            append(\"import java.lang.invoke.MethodHandle;\\n\");\n+            append(\"import java.lang.invoke.VarHandle;\\n\");\n+            append(\"import java.nio.ByteOrder;\\n\");\n+            append(\"import jdk.incubator.foreign.*;\\n\");\n+            append(\"import static \");\n+            append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n+            append(\".*;\\n\");\n+        }\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access, boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \" + type.getSimpleName() + \" \" +name + \"() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \");\n+        if (nullCheck) {\n+            append(\"RuntimeHelper.requireNonNull(\");\n+        }\n+        append(access);\n+        if (nullCheck) {\n+            append(\",\\\"\");\n+            append(symbolName);\n+            append(\"\\\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access) {\n+        emitGetter(mods, type, name, access, false, null);\n+    }\n+\n+    ToplevelBuilder toplevel() {\n+        JavaSourceBuilder encl = enclosing;\n+        while (encl instanceof ClassSourceBuilder) {\n+            encl = ((ClassSourceBuilder) encl).enclosing;\n+        }\n+        return (ToplevelBuilder)encl;\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        enclosing.emitWithConstantClass(constantConsumer);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClassSourceBuilder.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.invoke.MethodType;\n@@ -44,0 +43,1 @@\n+import java.util.function.Consumer;\n@@ -48,1 +48,1 @@\n-public class ConstantBuilder extends NestedClassBuilder {\n+public class ConstantBuilder extends ClassSourceBuilder {\n@@ -53,2 +53,2 @@\n-    public ConstantBuilder(JavaSourceBuilder enclosing, Kind kind, String className) {\n-        super(enclosing, kind, className);\n+    public ConstantBuilder(JavaSourceBuilder enclosing, String className) {\n+        super(enclosing, Kind.CLASS, className);\n@@ -58,1 +58,1 @@\n-        return kind == JavaSourceBuilder.Kind.CLASS ?\n+        return kind == ClassSourceBuilder.Kind.CLASS ?\n@@ -152,1 +152,1 @@\n-        Constant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n@@ -157,1 +157,1 @@\n-        Constant emitGetter(JavaSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n@@ -198,1 +198,1 @@\n-            append(\"LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+            append(toplevel().headerClassName() + \".LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n@@ -395,1 +395,1 @@\n-        append(\"LIBRARIES, \\\"\");\n+        append(toplevel().headerClassName() + \".LIBRARIES, \\\"\");\n@@ -403,0 +403,5 @@\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        constantConsumer.accept(this);\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Consumer;\n@@ -36,1 +37,1 @@\n-public class FunctionalInterfaceBuilder extends NestedClassBuilder {\n+public class FunctionalInterfaceBuilder extends ClassSourceBuilder {\n@@ -43,2 +44,2 @@\n-    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, String className, MethodType fiType,\n-                               FunctionDescriptor fiDesc) {\n+    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, String className,\n+                               MethodType fiType, FunctionDescriptor fiDesc) {\n@@ -74,1 +75,1 @@\n-        emitWithConstantClass(className(), constantBuilder -> {\n+        emitWithConstantClass(constantBuilder -> {\n@@ -99,1 +100,1 @@\n-        emitWithConstantClass(className(), constantBuilder -> {\n+        emitWithConstantClass(constantBuilder -> {\n@@ -153,0 +154,5 @@\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        enclosing.emitWithConstantClass(constantConsumer);\n+    }\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -30,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -36,2 +34,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.invoke.MethodType;\n@@ -46,1 +42,1 @@\n-abstract class HeaderFileBuilder extends JavaSourceBuilder {\n+abstract class HeaderFileBuilder extends ClassSourceBuilder {\n@@ -52,2 +48,2 @@\n-    HeaderFileBuilder(ClassDesc desc, String superclass) {\n-        super(Kind.CLASS, desc);\n+    HeaderFileBuilder(ToplevelBuilder enclosing, String name, String superclass) {\n+        super(enclosing, Kind.CLASS, name);\n@@ -65,1 +61,1 @@\n-            emitWithConstantClass(javaName, constantBuilder -> {\n+            emitWithConstantClass(constantBuilder -> {\n@@ -70,1 +66,1 @@\n-            emitWithConstantClass(javaName, constantBuilder -> {\n+            emitWithConstantClass(constantBuilder -> {\n@@ -88,1 +84,1 @@\n-        emitWithConstantClass(javaName, constantBuilder -> {\n+        emitWithConstantClass(constantBuilder -> {\n@@ -98,1 +94,1 @@\n-            emitWithConstantClass(javaName, constantBuilder -> {\n+            emitWithConstantClass(constantBuilder -> {\n@@ -107,12 +103,0 @@\n-    @Override\n-    public void addTypedef(String name, String superClass, Type type) {\n-        if (type instanceof Type.Primitive) {\n-            \/\/ primitive\n-            emitPrimitiveTypedef((Type.Primitive)type, name);\n-        } else {\n-            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n-            builder.classBegin();\n-            builder.classEnd();\n-        }\n-    }\n-\n@@ -200,1 +184,1 @@\n-    private void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n+    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -34,1 +35,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -36,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -41,0 +42,1 @@\n+import java.util.stream.Collectors;\n@@ -42,79 +44,1 @@\n-\/**\n- * Superclass for .java source generator classes.\n- *\/\n-abstract class JavaSourceBuilder {\n-\n-    enum Kind {\n-        CLASS(\"class\"),\n-        INTERFACE(\"interface\");\n-\n-        final String kindName;\n-\n-        Kind(String kindName) {\n-            this.kindName = kindName;\n-        }\n-    }\n-\n-    final Kind kind;\n-    final ClassDesc desc;\n-\n-    Set<String> nestedClassNames = new HashSet<>();\n-    int nestedClassNameCount = 0;\n-\n-    \/\/ code buffer\n-    private StringBuilder sb = new StringBuilder();\n-    \/\/ current line alignment (number of 4-spaces)\n-    private int align;\n-\n-    JavaSourceBuilder(int align, Kind kind, ClassDesc desc) {\n-        this.align = align;\n-        this.kind = kind;\n-        this.desc = desc;\n-    }\n-\n-    JavaSourceBuilder(Kind kind, ClassDesc desc) {\n-        this(0, kind, desc);\n-    }\n-\n-    String className() {\n-        return desc.displayName();\n-    }\n-\n-    String fullName() {\n-        return className();\n-    }\n-\n-    final String packageName() {\n-        return desc.packageName();\n-    }\n-\n-    String superClass() {\n-        return null;\n-    }\n-\n-    String mods() {\n-        return \"public \";\n-    }\n-\n-    void classBegin() {\n-        emitPackagePrefix();\n-        emitImportSection();\n-\n-        indent();\n-        append(mods());\n-        append(kind.kindName + \" \" + className());\n-        if (superClass() != null) {\n-            append(\" extends \");\n-            append(superClass());\n-        }\n-        append(\" {\\n\\n\");\n-    }\n-\n-    JavaSourceBuilder classEnd() {\n-        if (constantBuilder != null) {\n-            constantBuilder.classEnd();\n-        }\n-        indent();\n-        append(\"}\\n\\n\");\n-        return this;\n-    }\n+public abstract class JavaSourceBuilder {\n@@ -153,1 +77,1 @@\n-    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+    public void addVar(String javaName, String nativeName, ClassSourceBuilder.VarInfo varInfo) {\n@@ -157,1 +81,1 @@\n-    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+    public void addFunction(String javaName, String nativeName, ClassSourceBuilder.FunctionInfo functionInfo) {\n@@ -170,37 +94,1 @@\n-        return new StructBuilder(this, name.isEmpty() ? parent.name() : name, layout, type);\n-    }\n-\n-    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n-        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name,\n-                functionInfo.methodType(), functionInfo.descriptor());\n-        builder.classBegin();\n-        builder.classEnd();\n-        return builder.fullName();\n-    }\n-\n-    public List<JavaFileObject> toFiles() {\n-        classEnd();\n-        String res = build();\n-        return List.of(Utils.fileFromString(packageName(), className(), res));\n-    }\n-\n-    \/\/ Internal generation helpers (used by other builders)\n-\n-    int align() {\n-        return align;\n-    }\n-\n-    void append(String s) {\n-        sb.append(s);\n-    }\n-\n-    void append(char c) {\n-        sb.append(c);\n-    }\n-\n-    void append(boolean b) {\n-        sb.append(b);\n-    }\n-\n-    void append(long l) {\n-        sb.append(l);\n+        throw new UnsupportedOperationException();\n@@ -209,4 +97,2 @@\n-    void indent() {\n-        for (int i = 0; i < align; i++) {\n-            append(\"    \");\n-        }\n+    public String addFunctionalInterface(String name, ClassSourceBuilder.FunctionInfo fInfo) {\n+        throw new UnsupportedOperationException();\n@@ -215,3 +101,1 @@\n-    void incrAlign() {\n-        align++;\n-    }\n+    abstract public List<JavaFileObject> toFiles();\n@@ -219,3 +103,1 @@\n-    void decrAlign() {\n-        align--;\n-    }\n+    public abstract String packageName();\n@@ -223,5 +105,2 @@\n-    String build() {\n-        String s = sb.toString();\n-        sb = null;\n-        return s;\n-    }\n+    Set<String> nestedClassNames = new HashSet<>();\n+    int nestedClassNameCount = 0;\n@@ -245,51 +124,1 @@\n-    \/\/ is the name enclosed enclosed by a class of the same name?\n-    boolean isEnclosedBySameName(String name) {\n-        return className().equals(name);\n-    }\n-\n-    protected void emitPackagePrefix() {\n-        assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n-        append(\"\/\/ Generated by jextract\\n\\n\");\n-        if (!packageName().isEmpty()) {\n-            append(\"package \");\n-            append(packageName());\n-            append(\";\\n\\n\");\n-        }\n-    }\n-\n-    protected void emitImportSection() {\n-        append(\"import java.lang.invoke.MethodHandle;\\n\");\n-        append(\"import java.lang.invoke.VarHandle;\\n\");\n-        append(\"import java.nio.ByteOrder;\\n\");\n-        append(\"import jdk.incubator.foreign.*;\\n\");\n-        append(\"import static \");\n-        append(OutputFactory.C_LANG_CONSTANTS_HOLDER);\n-        append(\".*;\\n\");\n-    }\n-\n-    protected void emitGetter(String mods, Class<?> type, String name, String access, boolean nullCheck, String symbolName) {\n-        incrAlign();\n-        indent();\n-        append(mods + \" \" + type.getSimpleName() + \" \" +name + \"() {\\n\");\n-        incrAlign();\n-        indent();\n-        append(\"return \");\n-        if (nullCheck) {\n-            append(\"RuntimeHelper.requireNonNull(\");\n-        }\n-        append(access);\n-        if (nullCheck) {\n-            append(\",\\\"\");\n-            append(symbolName);\n-            append(\"\\\")\");\n-        }\n-        append(\";\\n\");\n-        decrAlign();\n-        indent();\n-        append(\"}\\n\");\n-        decrAlign();\n-    }\n-\n-    protected void emitGetter(String mods, Class<?> type, String name, String access) {\n-        emitGetter(mods, type, name, access, false, null);\n-    }\n+    abstract boolean isEnclosedBySameName(String name);\n@@ -297,18 +126,1 @@\n-    int constant_counter = 0;\n-    int constant_class_index = 0;\n-\n-    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n-    ConstantBuilder constantBuilder;\n-\n-    protected void emitWithConstantClass(String javaName, Consumer<ConstantBuilder> constantConsumer) {\n-        if (constant_counter > CONSTANTS_PER_CLASS || constantBuilder == null) {\n-            if (constantBuilder != null) {\n-                constantBuilder.classEnd();\n-            }\n-            constant_counter = 0;\n-            constantBuilder = new ConstantBuilder(this, Kind.CLASS, \"constants$\" + constant_class_index++);\n-            constantBuilder.classBegin();\n-        }\n-        constantConsumer.accept(constantBuilder);\n-        constant_counter++;\n-    }\n+    abstract protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":16,"deletions":204,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.jextract.impl;\n-\n-import javax.tools.JavaFileObject;\n-import java.lang.constant.ClassDesc;\n-import java.util.List;\n-import java.util.function.Consumer;\n-\n-public class NestedClassBuilder extends JavaSourceBuilder {\n-\n-    protected final JavaSourceBuilder enclosing;\n-\n-    public NestedClassBuilder(JavaSourceBuilder enclosing, Kind kind, String className) {\n-        super(enclosing.align(), kind, ClassDesc.of(enclosing.packageName(), enclosing.uniqueNestedClassName(className)));\n-        this.enclosing = enclosing;\n-    }\n-\n-    @Override\n-    protected String mods() {\n-        return kind == Kind.INTERFACE ?\n-                \"public \" : \"public static \";\n-    }\n-\n-    @Override\n-    boolean isEnclosedBySameName(String name) {\n-        return super.isEnclosedBySameName(name) || enclosing.isEnclosedBySameName(name);\n-    }\n-\n-    @Override\n-    String fullName() {\n-        return enclosing.className() + \".\" + className();\n-    }\n-\n-    @Override\n-    void classBegin() {\n-        incrAlign();\n-        super.classBegin();\n-    }\n-\n-    @Override\n-    JavaSourceBuilder classEnd() {\n-        super.classEnd();\n-        decrAlign();\n-        enclosing.append(build());\n-        return enclosing;\n-    }\n-\n-    @Override\n-    protected void emitPackagePrefix() {\n-        \/\/ nested class. containing class has necessary package declaration\n-    }\n-\n-    @Override\n-    protected void emitImportSection() {\n-        \/\/ nested class. containing class has necessary imports\n-    }\n-\n-    @Override\n-    public List<JavaFileObject> toFiles() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    @Override\n-    protected void emitWithConstantClass(String javaName, Consumer<ConstantBuilder> constantConsumer) {\n-        if (this instanceof ConstantBuilder cb) {\n-            \/\/ use this class to emit constants\n-            constantConsumer.accept(cb);\n-        } else {\n-            enclosing.emitWithConstantClass(javaName, constantConsumer);\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/NestedClassBuilder.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -113,1 +113,1 @@\n-        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(ClassDesc.of(pkgName, clsName), libraryNames.toArray(new String[0]));\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName, libraryNames.toArray(new String[0]));\n@@ -193,0 +193,1 @@\n+        StructBuilder structBuilder = null;\n@@ -196,2 +197,2 @@\n-            currentBuilder = currentBuilder.addStruct(className, parent, layout, Type.declared(d));\n-            currentBuilder.classBegin();\n+            currentBuilder = structBuilder = currentBuilder.addStruct(className, parent, layout, Type.declared(d));\n+            structBuilder.classBegin();\n@@ -199,1 +200,1 @@\n-                addStructDefinition(d, currentBuilder.fullName());\n+                addStructDefinition(d, structBuilder.fullName());\n@@ -205,2 +206,2 @@\n-            if (isStructKind) {\n-                currentBuilder = currentBuilder.classEnd();\n+            if (structBuilder != null) {\n+                currentBuilder = structBuilder.classEnd();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -30,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -36,1 +33,0 @@\n-import java.lang.invoke.MethodType;\n@@ -56,2 +52,2 @@\n-    StructBuilder(JavaSourceBuilder enclosing, String className, GroupLayout structLayout, Type structType) {\n-        super(enclosing, Kind.CLASS, className);\n+    StructBuilder(JavaSourceBuilder enclosing, String name, GroupLayout structLayout, Type structType) {\n+        super(enclosing, name);\n@@ -122,1 +118,1 @@\n-            return super.addStruct(name, parent, layout, type);\n+            return new StructBuilder(this, name.isEmpty() ? parent.name() : name, layout, type);\n@@ -126,0 +122,8 @@\n+    @Override\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo.methodType(), functionInfo.descriptor());\n+        builder.classBegin();\n+        builder.classEnd();\n+        return builder.className();\n+    }\n+\n@@ -376,4 +380,3 @@\n-    private String qualifiedName(JavaSourceBuilder builder) {\n-        if (builder instanceof NestedClassBuilder) {\n-            NestedClassBuilder nestedClassBuilder = (NestedClassBuilder)builder;\n-            String prefix = qualifiedName(nestedClassBuilder.enclosing);\n+    private String qualifiedName(ClassSourceBuilder builder) {\n+        if (builder.isNested()) {\n+            String prefix = qualifiedName((ClassSourceBuilder)builder.enclosing);\n@@ -381,2 +384,2 @@\n-                    nestedClassBuilder.className() :\n-                    prefix + \"$\" + nestedClassBuilder.className();\n+                    builder.className() :\n+                    prefix + \"$\" + builder.className();\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -29,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -35,1 +33,0 @@\n-import java.lang.invoke.MethodType;\n@@ -48,0 +45,4 @@\n+    private final List<JavaSourceBuilder> builders = new ArrayList<>();\n+    private SplitHeader lastHeader;\n+    private int headersCount;\n+    private final ClassDesc headerDesc;\n@@ -49,1 +50,0 @@\n-    private final List<SplitHeader> headers = new ArrayList<>();\n@@ -53,2 +53,1 @@\n-    ToplevelBuilder(ClassDesc desc, String[] libraryNames) {\n-        super(Kind.CLASS, desc);\n+    ToplevelBuilder(String packageName, String headerClassName, String[] libraryNames) {\n@@ -56,1 +55,2 @@\n-        SplitHeader first = new FirstHeader(ClassDesc.of(packageName(), className()));\n+        this.headerDesc = ClassDesc.of(packageName, headerClassName);\n+        SplitHeader first = lastHeader = new FirstHeader(headerClassName);\n@@ -58,1 +58,1 @@\n-        headers.add(first);\n+        builders.add(first);\n@@ -61,3 +61,15 @@\n-    @Override\n-    void classBegin() {\n-        throw new UnsupportedOperationException();\n+    public List<JavaFileObject> toFiles() {\n+        if (constantBuilder != null) {\n+            constantBuilder.classEnd();\n+        }\n+        lastHeader.classEnd();\n+        builders.addAll(constantBuilders);\n+        List<JavaFileObject> files = new ArrayList<>();\n+        files.addAll(builders.stream()\n+                .flatMap(b -> b.toFiles().stream())\n+                .collect(Collectors.toList()));\n+        return files;\n+    }\n+\n+    public String headerClassName() {\n+        return headerDesc.displayName();\n@@ -67,2 +79,2 @@\n-    JavaSourceBuilder classEnd() {\n-        throw new UnsupportedOperationException();\n+    boolean isEnclosedBySameName(String name) {\n+        return false;\n@@ -71,8 +83,3 @@\n-    public List<JavaFileObject> toFiles() {\n-        headers.stream().skip(1).findFirst()\n-                .orElse(lastHeader()).emitLibraries(libraryNames);\n-        List<JavaFileObject> files = new ArrayList<>();\n-        files.addAll(headers.stream()\n-                .flatMap(hf -> hf.toFiles().stream())\n-                .collect(Collectors.toList()));\n-        return files;\n+    @Override\n+    public String packageName() {\n+        return headerDesc.packageName();\n@@ -98,1 +105,9 @@\n-        nextHeader().addTypedef(name, superClass, type);\n+        if (type instanceof Type.Primitive) {\n+            \/\/ primitive\n+            nextHeader().emitPrimitiveTypedef((Type.Primitive)type, name);\n+        } else {\n+            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n+            builders.add(builder);\n+            builder.classBegin();\n+            builder.classEnd();\n+        }\n@@ -103,1 +118,4 @@\n-        return nextHeader().addStruct(name, parent, layout, type);\n+        String structName = name.isEmpty() ? parent.name() : name;\n+        StructBuilder structBuilder = new StructBuilder(this, structName, layout, type);\n+        builders.add(structBuilder);\n+        return structBuilder;\n@@ -108,5 +126,6 @@\n-        return nextHeader().addFunctionalInterface(name, functionInfo);\n-    }\n-\n-    private SplitHeader lastHeader() {\n-        return headers.get(headers.size() - 1);\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this,\n+                name, functionInfo.methodType(), functionInfo.descriptor());\n+        builders.add(builder);\n+        builder.classBegin();\n+        builder.classEnd();\n+        return builder.className();\n@@ -117,3 +136,4 @@\n-            boolean hasSuper = !(lastHeader() instanceof FirstHeader);\n-            SplitHeader headerFileBuilder = new SplitHeader(ClassDesc.of(packageName(), className() + \"_\" + headers.size()),\n-                    hasSuper ? lastHeader().className() : null);\n+            boolean hasSuper = !(lastHeader instanceof FirstHeader);\n+            SplitHeader headerFileBuilder = new SplitHeader(headerDesc.displayName() + \"_\" + ++headersCount,\n+                    hasSuper ? lastHeader.className() : null);\n+            lastHeader.classEnd();\n@@ -121,1 +141,2 @@\n-            headers.add(headerFileBuilder);\n+            builders.add(headerFileBuilder);\n+            lastHeader = headerFileBuilder;\n@@ -126,1 +147,1 @@\n-            return lastHeader();\n+            return lastHeader;\n@@ -130,3 +151,3 @@\n-    static class SplitHeader extends HeaderFileBuilder {\n-        SplitHeader(ClassDesc desc, String superclass) {\n-            super(desc, superclass);\n+    class SplitHeader extends HeaderFileBuilder {\n+        SplitHeader(String name, String superclass) {\n+            super(ToplevelBuilder.this, name, superclass);\n@@ -139,22 +160,0 @@\n-\n-        private void emitLibraries(String[] libraryNames) {\n-            incrAlign();\n-            indent();\n-            append(\"static final \");\n-            append(\"LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\\n\");\n-            incrAlign();\n-            for (String lib : libraryNames) {\n-                indent();\n-                append('\\\"');\n-                append(quoteLibraryName(lib));\n-                append(\"\\\",\\n\");\n-            }\n-            decrAlign();\n-            indent();\n-            append(\"});\\n\\n\");\n-            decrAlign();\n-        }\n-\n-        private static String quoteLibraryName(String lib) {\n-            return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n-        }\n@@ -165,2 +164,2 @@\n-        FirstHeader(ClassDesc desc) {\n-            super(desc, \"#{SUPER}\");\n+        FirstHeader(String name) {\n+            super(name, \"#{SUPER}\");\n@@ -177,0 +176,1 @@\n+            emitLibraries(libraryNames);\n@@ -192,1 +192,1 @@\n-            HeaderFileBuilder last = lastHeader();\n+            HeaderFileBuilder last = lastHeader;\n@@ -196,0 +196,50 @@\n+\n+        private void emitLibraries(String[] libraryNames) {\n+            incrAlign();\n+            indent();\n+            append(\"static final \");\n+            append(\"LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {\\n\");\n+            incrAlign();\n+            for (String lib : libraryNames) {\n+                indent();\n+                append('\\\"');\n+                append(quoteLibraryName(lib));\n+                append(\"\\\",\\n\");\n+            }\n+            decrAlign();\n+            indent();\n+            append(\"});\\n\\n\");\n+            decrAlign();\n+        }\n+\n+        private String quoteLibraryName(String lib) {\n+            return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+        }\n+    }\n+\n+    \/\/ constant support\n+\n+    int constant_counter = 0;\n+    int constant_class_index = 0;\n+    List<ConstantBuilder> constantBuilders = new ArrayList<>();\n+\n+    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n+    ConstantBuilder constantBuilder;\n+\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        if (constant_counter > CONSTANTS_PER_CLASS || constantBuilder == null) {\n+            if (constantBuilder != null) {\n+                constantBuilder.classEnd();\n+            }\n+            constant_counter = 0;\n+            constantBuilder = new ConstantBuilder(this, \"constants$\" + constant_class_index++) {\n+                @Override\n+                String mods() {\n+                    return \"\"; \/\/ constants package-private!\n+                }\n+            };\n+            constantBuilders.add(constantBuilder);\n+            constantBuilder.classBegin();\n+        }\n+        constantConsumer.accept(constantBuilder);\n+        constant_counter++;\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":111,"deletions":61,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-public class TypedefBuilder extends NestedClassBuilder {\n+public class TypedefBuilder extends ClassSourceBuilder {\n@@ -34,2 +34,2 @@\n-    public TypedefBuilder(JavaSourceBuilder prev, String className, String superClass) {\n-        super(prev, Kind.CLASS, className);\n+    public TypedefBuilder(JavaSourceBuilder enclosing, String name, String superClass) {\n+        super(enclosing, Kind.CLASS, name);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-            Class<?> pointCls = loader.loadClass(\"repeatedDecls_h$Point\");\n+            Class<?> pointCls = loader.loadClass(\"Point\");\n@@ -87,1 +87,1 @@\n-            Class<?> point_tCls = loader.loadClass(\"repeatedDecls_h$Point_t\");\n+            Class<?> point_tCls = loader.loadClass(\"Point_t\");\n@@ -90,1 +90,1 @@\n-            Class<?> point$0Cls = loader.loadClass(\"repeatedDecls_h$POINT$0\");\n+            Class<?> point$0Cls = loader.loadClass(\"POINT$0\");\n@@ -95,1 +95,1 @@\n-            Class<?> point3DCls = loader.loadClass(\"repeatedDecls_h$Point3D\");\n+            Class<?> point3DCls = loader.loadClass(\"Point3D\");\n@@ -97,1 +97,1 @@\n-            Class<?> point3D_tCls = loader.loadClass(\"repeatedDecls_h$Point3D_t\");\n+            Class<?> point3D_tCls = loader.loadClass(\"Point3D_t\");\n","filename":"test\/jdk\/tools\/jextract\/RepeatedDeclsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            Class<?> fooCls = loader.loadClass(\"name_collision_h$foo\");\n+            Class<?> fooCls = loader.loadClass(\"foo\");\n@@ -65,1 +65,1 @@\n-            Class<?> foo2Cls = loader.loadClass(\"name_collision_h$foo2\");\n+            Class<?> foo2Cls = loader.loadClass(\"foo2\");\n@@ -79,1 +79,1 @@\n-            Class<?> barCls = loader.loadClass(\"name_collision_h$bar\");\n+            Class<?> barCls = loader.loadClass(\"bar\");\n@@ -90,1 +90,1 @@\n-            Class<?> bar2Cls = loader.loadClass(\"name_collision_h$bar2\");\n+            Class<?> bar2Cls = loader.loadClass(\"bar2\");\n","filename":"test\/jdk\/tools\/jextract\/Test8240811.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            Class<?> fooCls = loader.loadClass(\"test8245767_h$Foo\");\n+            Class<?> fooCls = loader.loadClass(\"Foo\");\n@@ -60,1 +60,1 @@\n-            Class<?> point_tCls = loader.loadClass(\"test8245767_h$Point_t\");\n+            Class<?> point_tCls = loader.loadClass(\"Point_t\");\n@@ -64,1 +64,1 @@\n-            Class<?> pointCls = loader.loadClass(\"test8245767_h$Point\");\n+            Class<?> pointCls = loader.loadClass(\"Point\");\n","filename":"test\/jdk\/tools\/jextract\/Test8245767.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-            Class<?> nodeClass = loader.loadClass(\"test8248415_h$Node\");\n+            Class<?> nodeClass = loader.loadClass(\"Node\");\n","filename":"test\/jdk\/tools\/jextract\/Test8248415.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-            Class<?> fiClass = loader.loadClass(\"test8249290_h$func$f\");\n+            Class<?> fiClass = loader.loadClass(\"func$f\");\n","filename":"test\/jdk\/tools\/jextract\/Test8249290.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-            Class<?> fiClass = loader.loadClass(\"test8249300_h$func$f\");\n+            Class<?> fiClass = loader.loadClass(\"func$f\");\n","filename":"test\/jdk\/tools\/jextract\/Test8249300.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-            Class<?> fooClass = loader.loadClass(\"test8251943_h$Foo\");\n+            Class<?> fooClass = loader.loadClass(\"Foo\");\n","filename":"test\/jdk\/tools\/jextract\/Test8251943.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-            cls = loader.loadClass(\"test8258405_h$func\");\n+            cls = loader.loadClass(\"func\");\n@@ -51,1 +51,1 @@\n-            cls = loader.loadClass(\"test8258405_h$Foo$bar\");\n+            cls = loader.loadClass(\"Foo$bar\");\n","filename":"test\/jdk\/tools\/jextract\/Test8258405.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            Class<?> FooClass = loader.loadClass(\"test8260705_h$Foo\");\n+            Class<?> FooClass = loader.loadClass(\"Foo\");\n@@ -54,1 +54,1 @@\n-            Class<?> Foo2Class = loader.loadClass(\"test8260705_h$Foo2\");\n+            Class<?> Foo2Class = loader.loadClass(\"Foo2\");\n@@ -64,1 +64,1 @@\n-            assertNotNull(loader.loadClass(\"test8260705_h$Foo3\"));\n+            assertNotNull(loader.loadClass(\"Foo3\"));\n@@ -66,1 +66,1 @@\n-            Class<?> Foo4Class = loader.loadClass(\"test8260705_h$Foo4\");\n+            Class<?> Foo4Class = loader.loadClass(\"Foo4\");\n@@ -69,1 +69,1 @@\n-            Class<?> Foo5Class = loader.loadClass(\"test8260705_h$Foo5\");\n+            Class<?> Foo5Class = loader.loadClass(\"Foo5\");\n","filename":"test\/jdk\/tools\/jextract\/Test8260705.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            Class<?> FooClass = loader.loadClass(\"test8260717_h$foo_t\");\n+            Class<?> FooClass = loader.loadClass(\"foo_t\");\n","filename":"test\/jdk\/tools\/jextract\/Test8260717.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-            assertNotNull(loader.loadClass(\"test8260929_h$rab\"));\n-            Class<?> rab2Class = loader.loadClass(\"test8260929_h$rab2\");\n+            assertNotNull(loader.loadClass(\"rab\"));\n+            Class<?> rab2Class = loader.loadClass(\"rab2\");\n","filename":"test\/jdk\/tools\/jextract\/Test8260929.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,5 +44,5 @@\n-            assertNotNull(loader.loadClass(\"test8261893_h$permits_\"));\n-            assertNotNull(loader.loadClass(\"test8261893_h$record_\"));\n-            assertNotNull(loader.loadClass(\"test8261893_h$sealed_\"));\n-            assertNotNull(loader.loadClass(\"test8261893_h$var_\"));\n-            assertNotNull(loader.loadClass(\"test8261893_h$yield_\"));\n+            assertNotNull(loader.loadClass(\"permits_\"));\n+            assertNotNull(loader.loadClass(\"record_\"));\n+            assertNotNull(loader.loadClass(\"sealed_\"));\n+            assertNotNull(loader.loadClass(\"var_\"));\n+            assertNotNull(loader.loadClass(\"yield_\"));\n","filename":"test\/jdk\/tools\/jextract\/Test8261893.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,4 +51,4 @@\n-            assertNotNull(loader.loadClass(\"test8262117_h$u\"));\n-            assertNotNull(loader.loadClass(\"test8262117_h$u$outer$u$0\"));\n-            assertNotNull(loader.loadClass(\"test8262117_h$v\"));\n-            assertNotNull(loader.loadClass(\"test8262117_h$v$v$0\"));\n+            assertNotNull(loader.loadClass(\"u\"));\n+            assertNotNull(loader.loadClass(\"u$outer$u$0\"));\n+            assertNotNull(loader.loadClass(\"v\"));\n+            assertNotNull(loader.loadClass(\"v$v$0\"));\n","filename":"test\/jdk\/tools\/jextract\/Test8262117.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,4 +50,4 @@\n-            assertNotNull(loader.loadClass(\"test8262825_h$RuntimeHelper_\"));\n-            assertNotNull(loader.loadClass(\"test8262825_h$String_\"));\n-            assertNotNull(loader.loadClass(\"test8262825_h$MemoryAddress_\"));\n-            assertNotNull(loader.loadClass(\"test8262825_h$MemorySegment_\"));\n+            assertNotNull(loader.loadClass(\"RuntimeHelper_\"));\n+            assertNotNull(loader.loadClass(\"String_\"));\n+            assertNotNull(loader.loadClass(\"MemoryAddress_\"));\n+            assertNotNull(loader.loadClass(\"MemorySegment_\"));\n","filename":"test\/jdk\/tools\/jextract\/Test8262825.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,3 +45,3 @@\n-            assertNotNull(loader.loadClass(\"test8262851_h$Odd\"));\n-            assertNotNull(loader.loadClass(\"test8262851_h$Odd$before\"));\n-            assertNotNull(loader.loadClass(\"test8262851_h$Odd$after\"));\n+            assertNotNull(loader.loadClass(\"Odd\"));\n+            assertNotNull(loader.loadClass(\"Odd$before\"));\n+            assertNotNull(loader.loadClass(\"Odd$after\"));\n","filename":"test\/jdk\/tools\/jextract\/Test8262851.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-        Class<?> cls = loader.loadClass(\"nested_h$\" + name);\n+        Class<?> cls = loader.loadClass(name);\n","filename":"test\/jdk\/tools\/jextract\/TestNested.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            Class<?> intOrFloatCls = loader.loadClass(\"uniondecl_h$IntOrFloat\");\n+            Class<?> intOrFloatCls = loader.loadClass(\"IntOrFloat\");\n","filename":"test\/jdk\/tools\/jextract\/UniondeclTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import test.jextract.funcpointers.*;\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            Class<?> cls = loader.loadClass(\"org.jextract.incompleteArray_h$Foo\");\n+            Class<?> cls = loader.loadClass(\"org.jextract.Foo\");\n","filename":"test\/jdk\/tools\/jextract\/incompleteArray\/IncompleteArrayTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import test.jextract.test8244938.*;\n","filename":"test\/jdk\/tools\/jextract\/test8244938\/Test8244938.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import test.jextract.test8252465.*;\n","filename":"test\/jdk\/tools\/jextract\/test8252465\/LibTest8252465Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import test.jextract.test8253102.*;\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/LibTest8253102Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import test.jextract.test8254983.*;\n","filename":"test\/jdk\/tools\/jextract\/test8254983\/LibTest8254983Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import test.jextract.unsupported.*;\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/LibUnsupportedTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            Class<?> ndpi_class = loader.loadClass(\"test8261578_1_h$ndpi_flow_tcp_struct\");\n+            Class<?> ndpi_class = loader.loadClass(\"ndpi_flow_tcp_struct\");\n@@ -60,1 +60,1 @@\n-            Class<?> foo_class = loader.loadClass(\"test8261578_2_h$foo\");\n+            Class<?> foo_class = loader.loadClass(\"foo\");\n@@ -79,1 +79,1 @@\n-            Class<?> plugin_class = loader.loadClass(\"test8261578_3_h$PluginCodec_H323AudioG7231AnnexC\");\n+            Class<?> plugin_class = loader.loadClass(\"PluginCodec_H323AudioG7231AnnexC\");\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/Test8261578.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-        Class<?> structCls = loader.loadClass(\"com.acme.examples_h$\" + structName);\n+        Class<?> structCls = loader.loadClass(\"com.acme.\" + structName);\n@@ -215,1 +215,1 @@\n-        Class<?> fiClass = findNestedClass(cls, name);\n+        Class<?> fiClass = loader.loadClass(\"com.acme.\" + name);\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/TestClassGeneration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import test.jextract.fp.*;\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/LibFuncPtrTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import test.jextract.struct.*;\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/LibStructTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}