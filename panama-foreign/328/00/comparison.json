{"files":[{"patch":"@@ -30,0 +30,4 @@\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n+import jdk.internal.foreign.Utils;\n+\n+import java.util.Objects;\n@@ -86,3 +90,29 @@\n-     * Returns the raw long value associated to this memory address.\n-     * @return The raw long value associated to this memory address.\n-     * @throws UnsupportedOperationException if this memory address is associated with an heap segment.\n+     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n+     * bounds, and can therefore be closed. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators),\n+     * where an address to some underlying memory region is typically obtained from native code\n+     * (often as a plain {@code long} value). The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * <p>\n+     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param bytesSize the desired size.\n+     * @return a new confined native memory segment with given base address and size.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws UnsupportedOperationException if this address is an heap address.\n+     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n+     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     *\/\n+    default MemorySegment asSegmentRestricted(long bytesSize) {\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        Utils.checkRestrictedAccess(\"MemoryAddress.ofSegmentRestricted\");\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize);\n+    }\n+\n+    \/**\n+     * Returns the raw long value associated with this memory address.\n+     * @return The raw long value associated with this memory address.\n+     * @throws UnsupportedOperationException if this memory address is an heap address.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -260,1 +260,0 @@\n-     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).\n@@ -267,0 +266,21 @@\n+    \/**\n+     * Obtains a new memory segment backed by the same underlying memory region as this segment, and featuring\n+     * the same confinement thread (see {@link #ownerThread()} and access modes (see {@link #accessModes()}),\n+     * but with a different cleanup action. More specifically, the cleanup action associated with the returned segment will\n+     * first call the user-provided action, before delegating back to the original cleanup action associated with\n+     * this segment. Any exception thrown by the user-provided action will be discarded, and will not prevent the\n+     * release of any memory resources associated with this segment.\n+     * <p>\n+     * As a side-effect, this segment will be marked as <em>not alive<\/em>,\n+     * and subsequent operations on this segment will result in runtime errors.\n+     *\n+     * @param action the new cleanup action\n+     * @return a new memory segment backed by the same underlying memory region as this segment; the cleanup action\n+     * associated with the new segment is the result of composing this segment's cleanup action with the\n+     * supplied {@code action}.\n+     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n+     * thread owning this segment.\n+     * @throws NullPointerException if {@code action == null}\n+     *\/\n+    MemorySegment withCleanupAction(Runnable action);\n+\n@@ -524,1 +544,1 @@\n-     * Creates a new buffer memory segment that models the memory associated with the given byte\n+     * Creates a new confined buffer memory segment that models the memory associated with the given byte\n@@ -530,1 +550,1 @@\n-     * not feature the {@link #WRITE} access mode.\n+     * not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -536,1 +556,1 @@\n-     * @return a new buffer memory segment.\n+     * @return a new confined buffer memory segment.\n@@ -543,1 +563,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n@@ -547,1 +567,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -550,1 +570,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -557,1 +577,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n@@ -561,1 +581,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -564,1 +584,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -571,1 +591,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n@@ -575,1 +595,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -578,1 +598,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -585,1 +605,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n@@ -588,1 +608,2 @@\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>.\n+     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -591,1 +612,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -598,1 +619,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n@@ -602,1 +623,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -605,1 +626,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -612,1 +633,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n@@ -616,1 +637,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -619,1 +640,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -626,1 +647,1 @@\n-     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.\n+     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n@@ -633,1 +654,1 @@\n-     * @return a new array memory segment.\n+     * @return a new confined array memory segment.\n@@ -640,1 +661,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout.\n@@ -660,1 +681,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n@@ -672,1 +693,1 @@\n-     * @return a new native memory segment.\n+     * @return a new confined native memory segment.\n@@ -680,1 +701,1 @@\n-     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * Creates a new confined mapped memory segment that models a memory-mapped region of a file from a given path.\n@@ -684,1 +705,1 @@\n-     * the segment will not feature the {@link #WRITE} access mode.\n+     * the segment will not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -694,1 +715,1 @@\n-     * @return a new mapped memory segment.\n+     * @return a new confined mapped memory segment.\n@@ -705,1 +726,1 @@\n-     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size and\n@@ -707,1 +728,1 @@\n-     * (see {@link #ALL_ACCESS}).\n+     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n@@ -715,1 +736,1 @@\n-     * @return a new native memory segment.\n+     * @return a new confined native memory segment.\n@@ -733,1 +754,1 @@\n-     * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n+     * Returns a shared native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n@@ -738,1 +759,2 @@\n-    MemorySegment.ofNativeRestricted(MemoryAddress.NULL, Long.MAX_VALUE, null, null, null)\n+    MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE)\n+                 .withOwnerThread(null)\n@@ -755,36 +777,0 @@\n-    \/**\n-     * Returns a new native memory segment with given base address and size; the returned segment has its own temporal\n-     * bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup\n-     * action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,\n-     * GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code\n-     * (often as a plain {@code long} value). The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}).\n-     * <p>\n-     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr the desired base address\n-     * @param bytesSize the desired size.\n-     * @param owner the desired owner thread. If {@code owner == null}, the returned segment is <em>not<\/em> confined.\n-     * @param cleanup a cleanup action to be executed when the {@link MemorySegment#close()} method is called on the\n-     *                returned segment. If {@code cleanup == null}, no cleanup action is executed.\n-     * @param attachment an object that must be kept alive by the returned segment; this can be useful when\n-     *                   the returned segment depends on memory which could be released if a certain object\n-     *                   is determined to be unreacheable. In most cases this will be set to {@code null}.\n-     * @return a new native memory segment with given base address, size, owner, cleanup action and object attachment.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws UnsupportedOperationException if {@code addr} is associated with an heap segment.\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n-     * @throws NullPointerException if {@code addr == null}.\n-     *\/\n-    static MemorySegment ofNativeRestricted(MemoryAddress addr, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {\n-        Objects.requireNonNull(addr);\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n-        Utils.checkRestrictedAccess(\"MemorySegment.ofNativeRestricted\");\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, bytesSize, owner, cleanup, attachment);\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":57,"deletions":71,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -298,0 +298,6 @@\n+    @Override\n+    public MemorySegment withCleanupAction(Runnable action) {\n+        checkValidState();\n+        return dup(0L, length, mask, scope.wrapAction(action));\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,11 +66,1 @@\n-        return createConfined(Thread.currentThread(), ref, cleanupAction);\n-    }\n-\n-    \/**\n-     * Creates a confined memory scope with given attachment, cleanup action and owner thread.\n-     * @param ref           an optional reference to an instance that needs to be kept reachable\n-     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n-     * @return a confined memory scope\n-     *\/\n-    static MemoryScope createConfined(Thread owner, Object ref, CleanupAction cleanupAction) {\n-        return new ConfinedScope(owner, ref, cleanupAction);\n+        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction);\n@@ -150,0 +140,11 @@\n+    final MemoryScope wrapAction(Runnable runnable) {\n+        try {\n+            justClose();\n+            return ownerThread() == null ?\n+                    new SharedScope(ref, cleanupAction.wrap(runnable)) :\n+                    new ConfinedScope(ownerThread(), ref, cleanupAction.wrap(runnable));\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n@@ -277,0 +278,1 @@\n+        CleanupAction wrap(Runnable runnable);\n@@ -294,0 +296,5 @@\n+\n+            @Override\n+            public CleanupAction wrap(Runnable runnable) {\n+                return AtMostOnceOnly.of(runnable);\n+            }\n@@ -328,0 +335,14 @@\n+            @Override\n+            public CleanupAction wrap(Runnable runnable) {\n+                disable();\n+                return AtMostOnceOnly.of(() -> {\n+                    try {\n+                        runnable.run();\n+                    } catch (Throwable t) {\n+                        \/\/ ignore\n+                    } finally {\n+                        doCleanup();\n+                    }\n+                });\n+            }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -44,2 +44,3 @@\n-    public static final MemorySegment EVERYTHING = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.NULL,\n-            Long.MAX_VALUE, null, null, null).withAccessModes(READ | WRITE);\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE)\n+            .withOwnerThread(null)\n+            .withAccessModes(READ | WRITE);\n@@ -116,7 +117,3 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Thread owner, Runnable cleanup, Object attachment) {\n-        MemoryScope.CleanupAction cleanupAction = cleanup != null ?\n-                MemoryScope.CleanupAction.AtMostOnceOnly.of(cleanup) : MemoryScope.CleanupAction.DUMMY;\n-        MemoryScope scope = owner == null ?\n-                MemoryScope.createShared(attachment, cleanupAction) :\n-                MemoryScope.createConfined(owner, attachment, cleanupAction);\n-        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), scope);\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize) {\n+        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize),\n+                MemoryScope.createConfined(null, MemoryScope.CleanupAction.DUMMY));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.function.ToIntFunction;\n@@ -116,1 +115,1 @@\n-        try (MemorySegment segment = MemorySegment.ofNativeRestricted(MemoryAddress.NULL, seq.byteSize(), null, null, null)) {\n+        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize())) {\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n+ * @run testng TestCleaner\n@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -64,1 +63,2 @@\n-        MemorySegment segment = makeSegment(segmentState);\n+        MemorySegment segment = MemorySegment.allocateNative(10)\n+                .withCleanupAction(segmentState::cleanup);\n@@ -91,4 +91,0 @@\n-    MemorySegment makeSegment(SegmentState segmentState) {\n-        return MemorySegment.ofNativeRestricted(MemoryAddress.NULL, 10, Thread.currentThread(), segmentState::cleanup, null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,\n-                () -> free(addr.toRawLongValue()), null);\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n+                .withCleanupAction(() -> free(addr.toRawLongValue()));\n@@ -188,2 +188,2 @@\n-        MemorySegment mallocSegment = MemorySegment.ofNativeRestricted(addr, 12, null,\n-                () -> free(addr.toRawLongValue()), null);\n+        MemorySegment mallocSegment = addr.asSegmentRestricted(12)\n+                .withCleanupAction(() -> free(addr.toRawLongValue()));\n@@ -207,1 +207,1 @@\n-            MemorySegment.ofNativeRestricted(segment.address(), 0, null, null, null);\n+            segment.address().asSegmentRestricted(0);\n@@ -211,5 +211,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullUnsafeSegment() {\n-        MemorySegment.ofNativeRestricted(null, 10, null, null, null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -43,1 +43,1 @@\n-        MemorySegment.ofNativeRestricted(MemoryAddress.ofLong(42), 10, null, null, null);\n+        MemorySegment.ofNativeRestricted();\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -339,1 +339,2 @@\n-                \"registerCleaner\"\n+                \"registerCleaner\",\n+                \"withCleanupAction\"\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.*;\n@@ -130,2 +127,2 @@\n-            MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(\n-                    s.address(), s.byteSize(), null, null, null);\n+            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize())\n+                    .withOwnerThread(null);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}