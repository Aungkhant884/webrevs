{"files":[{"patch":"@@ -2251,1 +2251,1 @@\n-    sealed interface Scope permits MemorySessionImpl, AbstractMemorySegmentImpl.ScopeImpl {\n+    sealed interface Scope permits MemorySessionImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-    final AbstractMemorySegmentImpl parent;\n@@ -83,1 +82,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySessionImpl scope, AbstractMemorySegmentImpl parent) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySessionImpl scope) {\n@@ -87,1 +86,0 @@\n-        this.parent = parent;\n@@ -385,37 +383,1 @@\n-        return scope == MemorySessionImpl.EXTERNAL ?\n-                new ScopeImpl(this) : scope;\n-    }\n-\n-    \/**\n-     * Some segments are backed by an 'external' memory session. This is the case for (a) heap memory segments,\n-     * and (b) native segments created unsafely from raw native addresses and (c) segments created from\n-     * heap buffers. In these cases, we return a fresh scope instance which wraps a segment.\n-     * Equality on these scopes is defined in terms of equality of the \"roots\" of their associated segments.\n-     * This means that externally managed memory segments have a scope that is a \"singleton\":\n-     * a segment and all the slices derived from it have scopes that are equals.\n-     *\/\n-    public static final class ScopeImpl implements Scope {\n-        final MemorySegment root;\n-\n-        @Override\n-        public boolean isAlive() {\n-            return true;\n-        }\n-\n-        public ScopeImpl(AbstractMemorySegmentImpl segment) {\n-            while (segment.parent != null) {\n-                segment = segment.parent;\n-            }\n-            this.root = segment;\n-        }\n-\n-        @Override\n-        public boolean equals(Object that) {\n-            return that instanceof ScopeImpl scopeImpl &&\n-                    root == scopeImpl.root; \/\/ do not use segment equality (which is too loose)\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return root.hashCode();\n-        }\n+        return scope;\n@@ -558,1 +520,1 @@\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -560,1 +522,1 @@\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -562,1 +524,1 @@\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -564,1 +526,1 @@\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -566,1 +528,1 @@\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -568,1 +530,1 @@\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -570,1 +532,1 @@\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -575,1 +537,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferScope, bufferSegment);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferScope);\n@@ -578,1 +540,1 @@\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferScope, bufferSegment);\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferScope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":11,"deletions":49,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-        super(length, readOnly, MemorySessionImpl.EXTERNAL, parent);\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+        super(length, readOnly, session);\n@@ -96,2 +96,2 @@\n-        OfByte(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-            super(offset, base, length, readOnly, parent);\n+        OfByte(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -102,1 +102,1 @@\n-            return new OfByte(this.offset + offset, base, size, readOnly, this);\n+            return new OfByte(this.offset + offset, base, size, readOnly, scope);\n@@ -113,1 +113,2 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false, null);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -129,2 +130,2 @@\n-        OfChar(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-            super(offset, base, length, readOnly, parent);\n+        OfChar(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -135,1 +136,1 @@\n-            return new OfChar(this.offset + offset, base, size, readOnly, this);\n+            return new OfChar(this.offset + offset, base, size, readOnly, scope);\n@@ -146,1 +147,2 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false, null);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -162,2 +164,2 @@\n-        OfShort(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-            super(offset, base, length, readOnly, parent);\n+        OfShort(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -168,1 +170,1 @@\n-            return new OfShort(this.offset + offset, base, size, readOnly, this);\n+            return new OfShort(this.offset + offset, base, size, readOnly, scope);\n@@ -179,1 +181,2 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false, null);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -195,2 +198,2 @@\n-        OfInt(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-            super(offset, base, length, readOnly, parent);\n+        OfInt(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -201,1 +204,1 @@\n-            return new OfInt(this.offset + offset, base, size, readOnly, this);\n+            return new OfInt(this.offset + offset, base, size, readOnly, scope);\n@@ -212,1 +215,2 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false, null);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -228,2 +232,2 @@\n-        OfLong(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-            super(offset, base, length, readOnly, parent);\n+        OfLong(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -234,1 +238,1 @@\n-            return new OfLong(this.offset + offset, base, size, readOnly, this);\n+            return new OfLong(this.offset + offset, base, size, readOnly, scope);\n@@ -245,1 +249,2 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false, null);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -261,2 +266,2 @@\n-        OfFloat(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-            super(offset, base, length, readOnly, parent);\n+        OfFloat(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -267,1 +272,1 @@\n-            return new OfFloat(this.offset + offset, base, size, readOnly, this);\n+            return new OfFloat(this.offset + offset, base, size, readOnly, scope);\n@@ -278,1 +283,2 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false, null);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -294,2 +300,2 @@\n-        OfDouble(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n-            super(offset, base, length, readOnly, parent);\n+        OfDouble(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -300,1 +306,1 @@\n-            return new OfDouble(this.offset + offset, base, size, readOnly, this);\n+            return new OfDouble(this.offset + offset, base, size, readOnly, scope);\n@@ -311,1 +317,2 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false, null);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":37,"deletions":30,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySessionImpl scope, AbstractMemorySegmentImpl parent) {\n-        super(min, length, readOnly, scope, parent);\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySessionImpl scope) {\n+        super(min, length, readOnly, scope);\n@@ -58,1 +58,1 @@\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, scope, this);\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, scope);\n@@ -98,1 +98,1 @@\n-            super(0, null, 0, readOnly, session, null);\n+            super(0, null, 0, readOnly, session);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    public static final MemorySessionImpl EXTERNAL = new GlobalSession(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySessionImpl scope, AbstractMemorySegmentImpl parent) {\n-        super(length, readOnly, scope, parent);\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySessionImpl scope) {\n+        super(length, readOnly, scope);\n@@ -70,1 +70,1 @@\n-        super(0L, false, MemorySessionImpl.GLOBAL, null);\n+        super(0L, false, new GlobalSession(null));\n@@ -87,1 +87,1 @@\n-        return new NativeMemorySegmentImpl(min + offset, size, readOnly, scope, this);\n+        return new NativeMemorySegmentImpl(min + offset, size, readOnly, scope);\n@@ -135,1 +135,1 @@\n-                false, sessionImpl, null);\n+                false, sessionImpl);\n@@ -160,1 +160,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl, null);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n@@ -166,1 +166,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl, null);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n@@ -171,1 +171,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.EXTERNAL, null);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1233,1 +1233,1 @@\n-                                            readOnly, sessionImpl, null);\n+                                            readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}