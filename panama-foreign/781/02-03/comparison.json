{"files":[{"patch":"@@ -118,1 +118,1 @@\n- * a scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n+ * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n@@ -131,1 +131,1 @@\n- * is a native segment associated with a scope that is always alive.\n+ * is a native segment associated with a fresh scope that is always alive.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n- * a scope that is always alive. This is because the Java runtime, in addition to having no insight\n+ * a fresh scope that is always alive. This is because the Java runtime, in addition to having no insight\n@@ -371,4 +371,4 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0) *\n- * foreign = foreign.asUnbounded() \/\/ size = Long.MAX_VALUE\n- *                  .asSlice(0, JAVA_INT); \/\/ size = 4\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n+ * foreign = foreign.asUnbounded()                                  \/\/ size = Long.MAX_VALUE\n+ *                  .asSlice(0, JAVA_INT);                          \/\/ size = 4\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ok\n@@ -394,2 +394,2 @@\n- * foreign = MemorySegment.ofAddress(foreign.address(), 4, arena); \/\/ create new segment (size = 4)\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * foreign = MemorySegment.ofAddress(foreign.address(), 4, arena);  \/\/ create new segment (size = 4)\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n@@ -1016,1 +1016,1 @@\n-     * same scope {@code S}.\n+     * same scope {@code S}. Otherwise, the scope of the returned segment is a fresh scope that is always alive.\n@@ -1035,1 +1035,1 @@\n-     * The scope of the returned segment is always alive, and keeps the given byte array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n@@ -1047,1 +1047,1 @@\n-     * The scope of the returned segment is always alive, and keeps the given char array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n@@ -1059,1 +1059,1 @@\n-     * The scope of the returned segment is always alive, and keeps the given short array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n@@ -1071,1 +1071,1 @@\n-     * The scope of the returned segment is always alive, and keeps the given int array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n@@ -1083,1 +1083,1 @@\n-     * The scope of the returned segment is always alive, and keeps the given float array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n@@ -1095,1 +1095,1 @@\n-     * The scope of the returned segment is always alive, and keeps the given long array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n@@ -1107,1 +1107,1 @@\n-     * The scope of the returned segment is always alive, and keeps the given double array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n@@ -1144,1 +1144,6 @@\n-     * The returned segment is always accessible, from any thread.\n+     * The returned segment is not {@linkplain MemorySegment#isReadOnly()} read-only), and is associated\n+     * with a fresh scope that is always alive.\n+     * <p>\n+     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid address from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n@@ -1146,4 +1151,0 @@\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, byteSize, Arena.global());\n-     *}\n@@ -1699,1 +1700,1 @@\n-     * a native segment, associated with a scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n@@ -2041,1 +2042,1 @@\n-     * a native segment, associated with a scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n@@ -2250,1 +2251,1 @@\n-    sealed interface Scope permits MemorySessionImpl {\n+    sealed interface Scope permits MemorySessionImpl, AbstractMemorySegmentImpl.ScopeImpl {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-     * returned by this method is associated with a {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+\n@@ -78,0 +79,1 @@\n+    final AbstractMemorySegmentImpl parent;\n@@ -81,1 +83,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySessionImpl scope) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySessionImpl scope, AbstractMemorySegmentImpl parent) {\n@@ -85,0 +87,1 @@\n+        this.parent = parent;\n@@ -382,1 +385,37 @@\n-        return scope;\n+        return scope == MemorySessionImpl.EXTERNAL ?\n+                new ScopeImpl(this) : scope;\n+    }\n+\n+    \/**\n+     * Some segments are backed by an 'external' memory session. This is the case for (a) heap memory segments,\n+     * and (b) native segments created unsafely from raw native addresses and (c) segments created from\n+     * heap buffers. In these cases, we return a fresh scope instance which wraps a segment.\n+     * Equality on these scopes is defined in terms of equality of the \"roots\" of their associated segments.\n+     * This means that externally managed memory segments have a scope that is a \"singleton\":\n+     * a segment and all the slices derived from it have scopes that are equals.\n+     *\/\n+    public static final class ScopeImpl implements Scope {\n+        final MemorySegment root;\n+\n+        @Override\n+        public boolean isAlive() {\n+            return true;\n+        }\n+\n+        public ScopeImpl(AbstractMemorySegmentImpl segment) {\n+            while (segment.parent != null) {\n+                segment = segment.parent;\n+            }\n+            this.root = segment;\n+        }\n+\n+        @Override\n+        public boolean equals(Object that) {\n+            return that instanceof ScopeImpl scopeImpl &&\n+                    root == scopeImpl.root; \/\/ do not use segment equality (which is too loose)\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return root.hashCode();\n+        }\n@@ -509,0 +548,2 @@\n+        boolean readOnly = bb.isReadOnly();\n+        int scaleFactor = getScaleFactor(bb);\n@@ -515,2 +556,0 @@\n-        boolean readOnly = bb.isReadOnly();\n-        int scaleFactor = getScaleFactor(bb);\n@@ -519,1 +558,1 @@\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n@@ -521,1 +560,1 @@\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n@@ -523,1 +562,1 @@\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n@@ -525,1 +564,1 @@\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n@@ -527,1 +566,1 @@\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n@@ -529,1 +568,1 @@\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n@@ -531,1 +570,1 @@\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferSegment);\n@@ -536,1 +575,1 @@\n-            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferScope);\n+            return new NativeMemorySegmentImpl(bbAddress + (pos << scaleFactor), size << scaleFactor, readOnly, bufferScope, bufferSegment);\n@@ -539,1 +578,1 @@\n-            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferScope);\n+            return new MappedMemorySegmentImpl(bbAddress + pos, unmapper, size, readOnly, bufferScope, bufferSegment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":52,"deletions":13,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-        super(length, readOnly, session);\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+        super(length, readOnly, MemorySessionImpl.EXTERNAL, parent);\n@@ -96,2 +96,2 @@\n-        OfByte(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-            super(offset, base, length, readOnly, session);\n+        OfByte(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+            super(offset, base, length, readOnly, parent);\n@@ -102,1 +102,1 @@\n-            return new OfByte(this.offset + offset, base, size, readOnly, scope);\n+            return new OfByte(this.offset + offset, base, size, readOnly, this);\n@@ -113,2 +113,1 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false, null);\n@@ -130,2 +129,2 @@\n-        OfChar(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-            super(offset, base, length, readOnly, session);\n+        OfChar(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+            super(offset, base, length, readOnly, parent);\n@@ -136,1 +135,1 @@\n-            return new OfChar(this.offset + offset, base, size, readOnly, scope);\n+            return new OfChar(this.offset + offset, base, size, readOnly, this);\n@@ -147,2 +146,1 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false, null);\n@@ -164,2 +162,2 @@\n-        OfShort(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-            super(offset, base, length, readOnly, session);\n+        OfShort(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+            super(offset, base, length, readOnly, parent);\n@@ -170,1 +168,1 @@\n-            return new OfShort(this.offset + offset, base, size, readOnly, scope);\n+            return new OfShort(this.offset + offset, base, size, readOnly, this);\n@@ -181,2 +179,1 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false, null);\n@@ -198,2 +195,2 @@\n-        OfInt(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-            super(offset, base, length, readOnly, session);\n+        OfInt(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+            super(offset, base, length, readOnly, parent);\n@@ -204,1 +201,1 @@\n-            return new OfInt(this.offset + offset, base, size, readOnly, scope);\n+            return new OfInt(this.offset + offset, base, size, readOnly, this);\n@@ -215,2 +212,1 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false, null);\n@@ -232,2 +228,2 @@\n-        OfLong(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-            super(offset, base, length, readOnly, session);\n+        OfLong(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+            super(offset, base, length, readOnly, parent);\n@@ -238,1 +234,1 @@\n-            return new OfLong(this.offset + offset, base, size, readOnly, scope);\n+            return new OfLong(this.offset + offset, base, size, readOnly, this);\n@@ -249,2 +245,1 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false, null);\n@@ -266,2 +261,2 @@\n-        OfFloat(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-            super(offset, base, length, readOnly, session);\n+        OfFloat(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+            super(offset, base, length, readOnly, parent);\n@@ -272,1 +267,1 @@\n-            return new OfFloat(this.offset + offset, base, size, readOnly, scope);\n+            return new OfFloat(this.offset + offset, base, size, readOnly, this);\n@@ -283,2 +278,1 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false, null);\n@@ -300,2 +294,2 @@\n-        OfDouble(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n-            super(offset, base, length, readOnly, session);\n+        OfDouble(long offset, Object base, long length, boolean readOnly, AbstractMemorySegmentImpl parent) {\n+            super(offset, base, length, readOnly, parent);\n@@ -306,1 +300,1 @@\n-            return new OfDouble(this.offset + offset, base, size, readOnly, scope);\n+            return new OfDouble(this.offset + offset, base, size, readOnly, this);\n@@ -317,2 +311,1 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n-                    MemorySessionImpl.heapSession(arr));\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":30,"deletions":37,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.Arena;\n@@ -46,2 +45,2 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySessionImpl scope) {\n-        super(min, length, readOnly, scope);\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySessionImpl scope, AbstractMemorySegmentImpl parent) {\n+        super(min, length, readOnly, scope, parent);\n@@ -59,1 +58,1 @@\n-        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, scope);\n+        return new MappedMemorySegmentImpl(min + offset, unmapper, size, readOnly, scope, this);\n@@ -99,1 +98,1 @@\n-            super(0, null, 0, readOnly, session);\n+            super(0, null, 0, readOnly, session, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    public static final MemorySessionImpl NATIVE = new GlobalSession(null);\n+    public static final MemorySessionImpl EXTERNAL = new GlobalSession(null);\n@@ -80,18 +80,0 @@\n-    class SessionArena implements Arena {\n-        private final MemorySessionImpl sessionImpl;\n-\n-        SessionArena(MemorySessionImpl sessionImpl) {\n-            this.sessionImpl = sessionImpl;\n-        }\n-\n-        @Override\n-        public Scope scope() {\n-            return sessionImpl;\n-        }\n-\n-        @Override\n-        public void close() {\n-            sessionImpl.close();\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.Arena;\n@@ -55,2 +54,2 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySessionImpl scope) {\n-        super(length, readOnly, scope);\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySessionImpl scope, AbstractMemorySegmentImpl parent) {\n+        super(length, readOnly, scope, parent);\n@@ -71,1 +70,1 @@\n-        super(0L, false, MemorySessionImpl.GLOBAL);\n+        super(0L, false, MemorySessionImpl.GLOBAL, null);\n@@ -88,1 +87,1 @@\n-        return new NativeMemorySegmentImpl(min + offset, size, readOnly, scope);\n+        return new NativeMemorySegmentImpl(min + offset, size, readOnly, scope, this);\n@@ -136,1 +135,1 @@\n-                false, sessionImpl);\n+                false, sessionImpl, null);\n@@ -161,1 +160,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl, null);\n@@ -167,1 +166,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl, null);\n@@ -172,1 +171,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.NATIVE);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.EXTERNAL, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1233,1 +1233,1 @@\n-                                            readOnly, sessionImpl);\n+                                            readOnly, sessionImpl, null);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -671,0 +671,1 @@\n+            assertEquals(msRoundTrip.scope(), ms.scope());\n@@ -675,0 +676,10 @@\n+    @Test(dataProvider = \"bufferFactories\")\n+    public void testDerivedBufferScopes(Supplier<Buffer> bufferFactory) {\n+        MemorySegment segment = MemorySegment.ofBuffer(bufferFactory.get());\n+        assertEquals(segment.scope(), segment.scope());\n+        assertEquals(segment.asSlice(0).scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().scope(), segment.scope());\n+        MemorySegment another = MemorySegment.ofBuffer(bufferFactory.get());\n+        assertNotEquals(segment.scope(), another.scope());\n+    }\n+\n@@ -984,0 +995,22 @@\n+\n+    @DataProvider(name = \"bufferFactories\")\n+    public static Object[][] bufferFactories() {\n+        List<Supplier<Buffer>> l = List.of(\n+                () -> ByteBuffer.allocate(10),\n+                () -> CharBuffer.allocate(10),\n+                () -> ShortBuffer.allocate(10),\n+                () -> IntBuffer.allocate(10),\n+                () -> FloatBuffer.allocate(10),\n+                () -> LongBuffer.allocate(10),\n+                () -> DoubleBuffer.allocate(10),\n+                () -> ByteBuffer.allocateDirect(10),\n+                () -> ByteBuffer.allocateDirect(10).asCharBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asShortBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asIntBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asFloatBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asLongBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asDoubleBuffer()\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -116,0 +116,10 @@\n+    @Test(dataProvider = \"segmentFactories\")\n+    public void testDerivedScopes(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment segment = segmentSupplier.get();\n+        assertEquals(segment.scope(), segment.scope());\n+        assertEquals(segment.asSlice(0).scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().scope(), segment.scope());\n+        MemorySegment another = segmentSupplier.get();\n+        assertNotEquals(segment.scope(), another.scope());\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}