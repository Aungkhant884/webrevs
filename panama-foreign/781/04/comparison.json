{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import jdk.internal.ref.CleanerFactory;\n+\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -32,1 +35,1 @@\n- * An arena controls the lifecycle of memory segments, providing both flexible allocation and timely deallocation.\n+ * An arena controls the lifecycle of native memory segments, providing both flexible allocation and timely deallocation.\n@@ -34,5 +37,13 @@\n- * An arena has a {@linkplain #scope() scope}, called the arena scope. When the arena is {@linkplain #close() closed},\n- * the arena scope is no longer {@linkplain SegmentScope#isAlive() alive}. As a result, all the\n- * segments associated with the arena scope are invalidated, safely and atomically, their backing memory regions are\n- * deallocated (where applicable) and can no longer be accessed after the arena is closed:\n- *\n+ * An arena has a {@linkplain MemorySegment.Scope scope} - the <em>arena scope<\/em>. All the segments allocated\n+ * by the arena are associated with the arena scope. As such, the arena determines the temporal bounds\n+ * of all the memory segments allocated by it.\n+ * <p>\n+ * Moreover, an arena also determines whether access to memory segments allocated by it should be\n+ * {@linkplain MemorySegment#isAccessibleBy(Thread) restricted} to specific threads.\n+ * An arena is a {@link SegmentAllocator} and features several allocation methods that can be used by clients\n+ * to obtain native segments.\n+ * <p>\n+ * The simplest arena is the {@linkplain Arena#global() global arena}. The global arena\n+ * features an <em>unbounded lifetime<\/em>. As such, native segments allocated with the global arena are always\n+ * accessible and their backing regions of memory are never deallocated. Moreover, memory segments allocated with the\n+ * global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n@@ -40,4 +51,3 @@\n- * try (Arena arena = Arena.openConfined()) {\n- *     MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n- *     ...\n- * } \/\/ memory released here\n+ * MemorySegment segment = Arena.global().allocate(100, 1);\n+ * ...\n+ * \/\/ segment is never deallocated!\n@@ -45,0 +55,6 @@\n+ * <p>\n+ * Alternatively, clients can obtain an {@linkplain Arena#ofAuto() automatic arena}, that is an arena\n+ * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. As such, the regions\n+ * of memory backing memory segments allocated with the automatic arena are deallocated at some unspecified time\n+ * <em>after<\/em> the automatic allocator (and all the segments allocated by it) become\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n@@ -46,2 +62,15 @@\n- * Furthermore, an arena is a {@link SegmentAllocator}. All the segments {@linkplain #allocate(long, long) allocated} by the\n- * arena are associated with the arena scope. This makes arenas extremely useful when interacting with foreign code, as shown below:\n+ * {@snippet lang = java:\n+ * MemorySegment segment = Arena.ofAuto().allocate(100, 1);\n+ * ...\n+ * segment = null; \/\/ the segment region becomes available for deallocation after this point\n+ *}\n+ * Memory segments allocated with an automatic arena can also be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n+ * <p>\n+ * Rather than leaving deallocation in the hands of the Java runtime, clients will often wish to exercise control over\n+ * the timing of deallocation for regions of memory that back memory segments. Two kinds of arenas support this,\n+ * namely {@linkplain #ofConfined() confined} and {@linkplain #ofShared() shared} arenas. They both feature\n+ * bounded lifetimes that are managed manually. For instance, the lifetime of a confined arena starts when the confined\n+ * arena is created, and ends when the confined arena is {@linkplain #close() closed}. As a result, the regions of memory\n+ * backing memory segments allocated with a confined arena are deallocated when the confined arena is closed.\n+ * When this happens, all the segments allocated with the confined arena are invalidated, and subsequent access\n+ * operations on these segments will fail {@link IllegalStateException}:\n@@ -50,4 +79,3 @@\n- * try (Arena arena = Arena.openConfined()) {\n- *     MemorySegment nativeArray = arena.allocateArray(ValueLayout.JAVA_INT, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n- *     MemorySegment nativeString = arena.allocateUtf8String(\"Hello!\");\n- *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.scope());\n+ * MemorySegment segment = null;\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     segment = arena.allocate(100);\n@@ -55,1 +83,2 @@\n- * } \/\/ memory released here\n+ * } \/\/ segment region deallocated here\n+ * segment.get(ValueLayout.JAVA_BYTE, 0); \/\/ throws IllegalStateException\n@@ -58,0 +87,36 @@\n+ * Memory segments allocated with a {@linkplain #ofConfined() confined arena} can only be accessed (and closed) by the\n+ * thread that created the arena. If access to a memory segment from multiple threads is required, clients can allocate\n+ * segment in a {@linkplain #ofShared() shared arena} instead.\n+ * <p>\n+ * The characteristics of the various arenas are summarized in the following table:\n+ *\n+ * <blockquote><table class=\"plain\">\n+ * <caption style=\"display:none\">Arenas characteristics<\/caption>\n+ * <thead>\n+ * <tr>\n+ *     <th scope=\"col\">Kind<\/th>\n+ *     <th scope=\"col\">Bounded lifetime<\/th>\n+ *     <th scope=\"col\">Explicitly closeable<\/th>\n+ *     <th scope=\"col\">Accessible from multiple threads<\/th>\n+ * <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Global<\/th>\n+ *     <td style=\"text-align:center;\">No<\/td>\n+ *     <td style=\"text-align:center;\">No<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Automatic<\/th>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">No<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Confined<\/th>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">No<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Shared<\/th>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td><\/tr>\n+ * <\/tbody>\n+ * <\/table><\/blockquote>\n+ *\n@@ -63,1 +128,1 @@\n- * is always created and closed by one thread, and the memory segments associated with the arena's scope are always\n+ * is always created and closed by one thread, and the memory segments allocated by the arena are always\n@@ -73,2 +138,2 @@\n- * {@linkplain #isCloseableBy(Thread) owner thread}, typically the thread which initiated the creation operation.\n- * The segments created by a confined arena can only be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed}\n+ * <em>owner thread<\/em>, typically the thread which initiated the creation operation.\n+ * The segments created by a confined arena can only be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed}\n@@ -79,1 +144,1 @@\n- * can be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread. This might be useful when\n+ * can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread. This might be useful when\n@@ -81,1 +146,7 @@\n- * Moreover, a shared arena {@linkplain #isCloseableBy(Thread) can be closed} by any thread.\n+ * Moreover, a shared arena can be closed by any thread.\n+ *\n+ *\n+ * @implSpec\n+ * Implementations of this interface are thread-safe.\n+ *\n+ * @see MemorySegment\n@@ -88,0 +159,40 @@\n+    \/**\n+     * Creates a new arena that is managed, automatically, by the garbage collector.\n+     * Segments obtained with the returned arena can be\n+     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n+     * Calling {@link #close()} on the returned arena will result in an {@link UnsupportedOperationException}.\n+     *\n+     * @return a new arena that is managed, automatically, by the garbage collector.\n+     *\/\n+    static Arena ofAuto() {\n+        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner()).asArena();\n+    }\n+\n+    \/**\n+     * Obtains the global arena. Segments obtained with the global arena can be\n+     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n+     * Calling {@link #close()} on the returned arena will result in an {@link UnsupportedOperationException}.\n+     *\n+     * @return the global arena.\n+     *\/\n+    static Arena global() {\n+        class Holder {\n+            final static Arena GLOBAL = MemorySessionImpl.GLOBAL.asArena();\n+        }\n+        return Holder.GLOBAL;\n+    }\n+\n+    \/**\n+     * {@return a new confined arena, owned by the current thread}\n+     *\/\n+    static Arena ofConfined() {\n+        return MemorySessionImpl.createConfined(Thread.currentThread()).asArena();\n+    }\n+\n+    \/**\n+     * {@return a new shared arena}\n+     *\/\n+    static Arena ofShared() {\n+        return MemorySessionImpl.createShared().asArena();\n+    }\n+\n@@ -90,1 +201,1 @@\n-     * The returned segment is associated with the arena scope.\n+     * The returned segment is associated with this {@linkplain #scope() arena scope}.\n@@ -96,5 +207,1 @@\n-     * The default implementation of this method is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * MemorySegment.allocateNative(bytesSize, byteAlignment, scope());\n-     *}\n-     * More generally implementations of this method must return a native segment featuring the requested size,\n+     * Implementations of this method must return a native segment featuring the requested size,\n@@ -113,4 +220,3 @@\n-     * @throws IllegalStateException if the arena has already been {@linkplain #close() closed}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n-     * @see MemorySegment#allocateNative(long, long, SegmentScope)\n+     * @throws IllegalStateException if this arena has already been {@linkplain #close() closed}.\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n+     * other than the arena owner thread.\n@@ -120,1 +226,1 @@\n-        return MemorySegment.allocateNative(byteSize, byteAlignment, scope());\n+        return ((MemorySessionImpl)scope()).allocate(byteSize, byteAlignment);\n@@ -126,1 +232,1 @@\n-    SegmentScope scope();\n+    Scope scope();\n@@ -129,1 +235,1 @@\n-     * Closes this arena. If this method completes normally, the arena scope is no longer {@linkplain SegmentScope#isAlive() alive},\n+     * Closes this arena. If this method completes normally, the arena scope is no longer {@linkplain Scope#isAlive() alive},\n@@ -131,1 +237,1 @@\n-     * segments associated with that scope are also released.\n+     * segments obtained from this arena are also released.\n@@ -137,1 +243,5 @@\n-     * @see SegmentScope#isAlive()\n+     * @implSpec If this method completes normally, then {@code this.scope().isAlive() == false}.\n+     * Implementations are allowed to throw {@link UnsupportedOperationException} if an explicit close operation is\n+     * not supported.\n+     *\n+     * @see Scope#isAlive()\n@@ -140,3 +250,5 @@\n-     * @throws IllegalStateException if the arena scope is {@linkplain SegmentScope#whileAlive(Runnable) kept alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code isCloseableBy(T) == false}.\n+     * @throws IllegalStateException if a segment associated with this arena is being accessed concurrently, e.g.\n+     * by a {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle}.\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n+     * other than the arena owner thread.\n+     * @throws UnsupportedOperationException if this arena does not support explicit closure.\n@@ -147,19 +259,0 @@\n-    \/**\n-     * {@return {@code true} if the provided thread can close this arena}\n-     * @param thread the thread to be tested.\n-     *\/\n-    boolean isCloseableBy(Thread thread);\n-\n-    \/**\n-     * {@return a new confined arena, owned by the current thread}\n-     *\/\n-    static Arena openConfined() {\n-        return MemorySessionImpl.createConfined(Thread.currentThread()).asArena();\n-    }\n-\n-    \/**\n-     * {@return a new shared arena}\n-     *\/\n-    static Arena openShared() {\n-        return MemorySessionImpl.createShared().asArena();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":153,"deletions":60,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Linker.Option...) upcall stubs}.\n+ * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Linker.Option...) upcall stubs}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Option...) upcall stubs}.<\/li>\n+ * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stubs}.<\/li>\n@@ -88,1 +88,1 @@\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Option...) Creating an upcall stub} requires a method\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) Creating an upcall stub} requires a method\n@@ -96,1 +96,2 @@\n- * downcall method handles and, they are released via their associated {@linkplain SegmentScope scope}.\n+ * downcall method handles. An upcall stub can be released by {@linkplain Arena#close() closing} the arena which was used\n+ * to create it.\n@@ -108,3 +109,2 @@\n- *     <li>The scope of {@code A} is {@linkplain SegmentScope#isAlive() alive}. Otherwise, the invocation throws\n- *     {@link IllegalStateException};<\/li>\n- *     <li>The invocation occurs in a thread {@code T} such that {@code A.scope().isAccessibleBy(T) == true}.\n+ *     <li>{@code A.scope().isAlive() == true}. Otherwise, the invocation throws {@link IllegalStateException};<\/li>\n+ *     <li>The invocation occurs in a thread {@code T} such that {@code A.isAccessibleBy(T) == true}.\n@@ -112,1 +112,3 @@\n- *     <li>The scope of {@code A} is {@linkplain SegmentScope#whileAlive(Runnable) kept alive} during the invocation.<\/li>\n+ *     <li>{@code A} is kept alive during the invocation. For instance, if {@code A} has been obtained using a\n+ *     {@linkplain Arena#ofConfined() confined arena}, any attempt to {@linkplain Arena#close() close}\n+ *     the confined arena while the downcall method handle is executing will result in a {@link IllegalStateException}.<\/li>\n@@ -116,1 +118,1 @@\n- * the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned segment is {@code 0}.\n+ * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n@@ -129,1 +131,1 @@\n- * is a native segment associated with the {@linkplain SegmentScope#global() global scope}.\n+ * is a native segment associated with a fresh scope that is always alive.\n@@ -162,1 +164,1 @@\n-     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope, Option...) upcall stub}.\n+     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}.\n@@ -239,1 +241,1 @@\n-     * scope. Calling such a function pointer from foreign code will result in the execution of the provided\n+     * arena. Calling such a function pointer from foreign code will result in the execution of the provided\n@@ -243,2 +245,3 @@\n-     * the provided scope. As such, the corresponding upcall stub will be deallocated\n-     * when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n+     * the provided arena. As such, the lifetime of the returned upcall stub segment is controlled by the\n+     * provided arena. For instance, if the provided arena is a confined arena, the returned\n+     * upcall stub segment will be deallocated when the provided confined arena is {@linkplain Arena#close() closed}.\n@@ -254,1 +257,1 @@\n-     * @param scope the scope associated with the returned upcall stub segment.\n+     * @param arena the arena associated with the returned upcall stub segment.\n@@ -260,3 +263,3 @@\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -264,1 +267,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope, Linker.Option... options);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena, Linker.Option... options);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -67,1 +68,1 @@\n- * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, SegmentScope)}\n+ * Native segments can be obtained by calling one of the {@link Arena#allocate(long, long)}\n@@ -70,1 +71,1 @@\n- * {@link FileChannel#map(MapMode, long, long, SegmentScope) mapping} a file into a new off-heap region\n+ * {@link FileChannel#map(MapMode, long, long, Arena) mapping} a file into a new off-heap region\n@@ -95,2 +96,2 @@\n- * (as in {@link MemorySegment#allocateNative(long, SegmentScope)}) or derived from a {@link MemoryLayout}\n- * (as in {@link MemorySegment#allocateNative(MemoryLayout, SegmentScope)}). The size of a memory segment is typically\n+ * (as in {@link Arena#allocate(long, long)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link Arena#allocate(MemoryLayout)}). The size of a memory segment is typically\n@@ -103,1 +104,1 @@\n- * Every memory segment is associated with a {@linkplain SegmentScope scope}. This ensures that access operations\n+ * Every memory segment is associated with a {@linkplain Scope scope}. This ensures that access operations\n@@ -105,1 +106,1 @@\n- * (e.g., after the scope associated with the accessed memory segment is no longer {@linkplain SegmentScope#isAlive() alive}).\n+ * (e.g., after the scope associated with the accessed memory segment is no longer {@linkplain Scope#isAlive() alive}).\n@@ -108,4 +109,3 @@\n- * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated\n- * scope; that is, if the segment is associated with the {@linkplain SegmentScope#global() global scope} or an {@linkplain SegmentScope#auto() automatic scope},\n- * it can be accessed by multiple threads. If the segment is associated with an arena scope, then it can only be\n- * accessed compatibly with the <a href=\"Arena.html#thread-confinement\">arena confinement characteristics<\/a>.\n+ * Finally, access operations on a memory segment can be subject to additional thread-confinement checks.\n+ * Heap segments can be accessed from any thread. Conversely, native segments can only be accessed compatibly with the\n+ * <a href=\"ScopedArena.html#thread-confinement\">confinement characteristics<\/a> of the arena used to obtain them.\n@@ -165,1 +165,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -172,1 +172,1 @@\n- * }\n+ *}\n@@ -176,2 +176,2 @@\n- * {@code slice} segment will result in an exception. The {@linkplain SegmentScope temporal bounds} of the original segment\n- * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@linkplain SegmentScope#isAlive() alive},\n+ * {@code slice} segment will result in an exception. The {@linkplain Arena temporal bounds} of the original segment\n+ * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@linkplain Scope#isAlive() alive},\n@@ -182,1 +182,1 @@\n- * (to do this, the segment has to be associated with a scope that allows {@linkplain SegmentScope#isAccessibleBy(Thread) access}\n+ * (to do this, the segment has to be {@linkplain MemorySegment#isAccessibleBy(Thread) accessible}\n@@ -186,1 +186,1 @@\n- * try (Arena arena = Arena.openShared()) {\n+ * try (Arena arena = Arena.ofShared()) {\n@@ -245,2 +245,2 @@\n- * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, SegmentScope)}\n- * or {@link #allocateNative(MemoryLayout, SegmentScope)}. These factories ensure that the off-heap region of memory backing\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link Arena#allocate(long, long)}\n+ * or {@link Arena#allocate(MemoryLayout)}. These factories ensure that the off-heap region of memory backing\n@@ -358,2 +358,2 @@\n- * Zero-length memory segments obtained when interacting with foreign functions are associated with the\n- * {@link SegmentScope#global() global scope}. This is because the Java runtime, in addition to having no insight\n+ * Zero-length memory segments obtained when interacting with foreign functions are associated with\n+ * a fresh scope that is always alive. This is because the Java runtime, in addition to having no insight\n@@ -361,2 +361,2 @@\n- * into the lifetime intended for said region of memory by the foreign function that allocated it. The global scope\n- * ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it. Thus, zero-length\n+ * memory segments cannot be accessed directly, but can be passed, opaquely, to other pointer-accepting foreign functions.\n@@ -371,4 +371,4 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0) *\n- * foreign = foreign.asUnbounded() \/\/ size = Long.MAX_VALUE\n- *                  .asSlice(0, JAVA_INT); \/\/ size = 4\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n+ * foreign = foreign.asUnbounded()                                  \/\/ size = Long.MAX_VALUE\n+ *                  .asSlice(0, JAVA_INT);                          \/\/ size = 4\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ok\n@@ -388,1 +388,1 @@\n- * Finally, clients can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope) obtain}\n+ * Finally, clients can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, Arena) obtain}\n@@ -392,1 +392,1 @@\n- * SegmentScope scope = ... \/\/ obtains a scope\n+ * Arena arena = ... \/\/ obtains an arena\n@@ -394,2 +394,2 @@\n- * foreign = MemorySegment.ofAddress(foreign.address(), 4, scope); \/\/ create new segment (size = 4)\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * foreign = MemorySegment.ofAddress(foreign.address(), 4, arena);  \/\/ create new segment (size = 4)\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n@@ -399,1 +399,1 @@\n- * and {@link #ofAddress(long, long, SegmentScope)} are\n+ * and {@link #ofAddress(long, long, Arena)} are\n@@ -437,1 +437,1 @@\n-     * are associated with the same scope as that associated with this segment.\n+     * have the same lifetime as that of this segment.\n@@ -470,1 +470,7 @@\n-    SegmentScope scope();\n+    Scope scope();\n+\n+    \/**\n+     * {@return {@code true} if this segment can be accessed from the provided thread}\n+     * @param thread the thread to be tested.\n+     *\/\n+    boolean isAccessibleBy(Thread thread);\n@@ -590,1 +596,1 @@\n-     * created e.g. using the {@link #allocateNative(long, SegmentScope)} (and related) factory, or by\n+     * created e.g. using the {@link Arena#allocate(long, long)} (and related) factory, or by\n@@ -598,1 +604,1 @@\n-     * {@link FileChannel#map(FileChannel.MapMode, long, long, SegmentScope)} factory, or by\n+     * {@link FileChannel#map(FileChannel.MapMode, long, long, Arena)} factory, or by\n@@ -665,1 +671,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -667,1 +673,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -684,1 +690,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -686,1 +692,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -688,1 +694,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -690,1 +696,1 @@\n-     * such that {@code src.scope().isAccessibleBy(T) == false}.\n+     * such that {@code src.isAccessibleBy(T) == false}.\n@@ -718,1 +724,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -720,1 +726,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -722,1 +728,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -724,1 +730,1 @@\n-     * such that {@code other.scope().isAccessibleBy(T) == false}.\n+     * such that {@code other.isAccessibleBy(T) == false}.\n@@ -750,1 +756,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -752,1 +758,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -767,1 +773,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -769,1 +775,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -784,1 +790,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -786,1 +792,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -813,1 +819,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -815,1 +821,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -835,1 +841,1 @@\n-     * after the scope associated with this segment is no longer {@linkplain SegmentScope#isAlive() alive}, will\n+     * after the scope associated with this segment is no longer {@linkplain Scope#isAlive() alive}, will\n@@ -837,1 +843,1 @@\n-     * such that {@code scope().isAccessible(T) == false} will throw a {@link WrongThreadException}.\n+     * such that {@code isAccessible(T) == false} will throw a {@link WrongThreadException}.\n@@ -839,1 +845,1 @@\n-     * If this segment is associated with a scope that can only be accessed from a single thread, calling read\/write I\/O\n+     * If this segment is accessible from a single thread, calling read\/write I\/O\n@@ -860,1 +866,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -862,1 +868,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -874,1 +880,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -876,1 +882,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -888,1 +894,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -890,1 +896,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -902,1 +908,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -904,1 +910,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -916,1 +922,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -918,1 +924,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -930,1 +936,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -932,1 +938,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -944,1 +950,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -946,1 +952,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -966,1 +972,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -968,1 +974,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -991,1 +997,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -993,1 +999,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1008,9 +1014,7 @@\n-     * The scope {@code S} associated with the returned segment is computed as follows:\n-     * <ul>\n-     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose scope\n-     *     is {@code S'}, then {@code S = S'}; or<\/li>\n-     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain SegmentScope#global() global scope}; or\n-     *     <li>if the buffer is a direct buffer, then {@code S} is a scope that is always alive and which keeps the buffer reachable.\n-     *     Therefore, the off-heap region of memory backing the buffer instance will remain available as long as the\n-     *     returned segment is reachable.<\/li>\n-     * <\/ul>\n+     * If the provided buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose\n+     * {@linkplain Scope scope} is {@code S}, the returned segment will be associated with the\n+     * same scope {@code S}. Otherwise, the scope of the returned segment is a fresh scope that is always alive.\n+     * <p>\n+     * The scope associated with the returned segment keeps the provided buffer reachable. As such, if\n+     * the provided buffer is a direct buffer, its backing memory region will not be deallocated as long as the\n+     * returned segment (or any of its slices) are kept reachable.\n@@ -1031,2 +1035,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1043,2 +1047,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1055,2 +1059,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1067,2 +1071,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1079,2 +1083,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1091,2 +1095,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1103,2 +1107,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1120,1 +1124,1 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n+     * The returned segment is always accessible, from any thread.\n@@ -1140,1 +1144,6 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n+     * The returned segment is not {@linkplain MemorySegment#isReadOnly()} read-only), and is associated\n+     * with a fresh scope that is always alive.\n+     * <p>\n+     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid address from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n@@ -1142,4 +1151,0 @@\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, byteSize, SegmentScope.global());\n-     *}\n@@ -1164,1 +1169,1 @@\n-        return MemorySegment.ofAddress(address, byteSize, SegmentScope.global());\n+        return MemorySegment.ofAddress(address, byteSize, Arena.global());\n@@ -1168,7 +1173,2 @@\n-     * Creates a native segment with the given size, address, and scope.\n-     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n-     * where an address to some underlying region of memory is typically obtained from foreign code\n-     * (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided scope.\n+     * Creates a native segment with the given size, {@linkplain #address() address value} and arena.\n+     * The returned segment is always accessible, from any thread.\n@@ -1178,1 +1178,1 @@\n-     * ofAddress(address, byteSize, scope, null);\n+     * ofAddress(address, byteSize, arena, null);\n@@ -1191,2 +1191,2 @@\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a native segment with the given address, size and scope.\n+     * @param arena the arena associated with the returned native segment.\n+     * @return a native segment with the given address, size and arena.\n@@ -1194,3 +1194,3 @@\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -1201,1 +1201,1 @@\n-    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope) {\n+    static MemorySegment ofAddress(long address, long byteSize, Arena arena) {\n@@ -1203,1 +1203,1 @@\n-        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(arena);\n@@ -1205,1 +1205,2 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, null);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize,\n+                MemorySessionImpl.toMemorySession(arena), null);\n@@ -1209,1 +1210,1 @@\n-     * Creates a native segment with the given size, address, and scope.\n+     * Creates a native segment with the given size, {@linkplain #address() address value}, and arena.\n@@ -1214,4 +1215,4 @@\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided scope.\n-     * <p>\n-     * The provided cleanup action (if any) will be invoked when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n+     * The returned segment is not {@linkplain MemorySegment#isReadOnly()} read-only), and its lifetime is controlled\n+     * by the provided arena. For instance, if the provided arena is a confined arena, the returned\n+     * native segment will be invalidated - and the provided cleanup action invoked - when the provided confined arena\n+     * is {@linkplain Arena#close() closed}.\n@@ -1234,1 +1235,1 @@\n-     * @param scope the scope associated with the returned native segment.\n+     * @param arena the arena associated with the returned native segment.\n@@ -1236,1 +1237,1 @@\n-     * @return a native segment with the given address, size and scope.\n+     * @return a native segment with the given address, size and arena.\n@@ -1238,3 +1239,3 @@\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -1244,1 +1245,1 @@\n-    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope, Runnable cleanupAction) {\n+    static MemorySegment ofAddress(long address, long byteSize, Arena arena, Runnable cleanupAction) {\n@@ -1246,1 +1247,1 @@\n-        Objects.requireNonNull(scope);\n+        Objects.requireNonNull(arena);\n@@ -1248,103 +1249,2 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, cleanupAction);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given layout and scope.\n-     * <p>\n-     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n-     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n-     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n-     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the scope is no longer referenced.\n-     * <p>\n-     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n-     * of the returned segment will be aligned according to the alignment constraint of the provided layout.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);\n-     * }\n-     * <p>\n-     * The region of off-heap region backing the returned native segment is initialized to zero.\n-     *\n-     * @param layout the layout of the off-heap memory region backing the native segment.\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a new native segment.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static MemorySegment allocateNative(MemoryLayout layout, SegmentScope scope) {\n-        Objects.requireNonNull(layout);\n-        Objects.requireNonNull(scope);\n-        return allocateNative(layout.byteSize(), layout.byteAlignment(), scope);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size (in bytes) and scope.\n-     * <p>\n-     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n-     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n-     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n-     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the scope is no longer referenced.\n-     * <p>\n-     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n-     * of the returned segment is guaranteed to be at least 1-byte aligned.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * allocateNative(bytesSize, 1, scope);\n-     * }\n-     * <p>\n-     * The region of off-heap region backing the returned native segment is initialized to zero.\n-     *\n-     * @param byteSize the size (in bytes) of the off-heap memory region of memory backing the native memory segment.\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static MemorySegment allocateNative(long byteSize, SegmentScope scope) {\n-        return allocateNative(byteSize, 1, scope);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size (in bytes), alignment (in bytes) and scope.\n-     * <p>\n-     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n-     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n-     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n-     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the scope is no longer referenced.\n-     * <p>\n-     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n-     * of the returned segment will be aligned according to the provided alignment constraint.\n-     * <p>\n-     * The region of off-heap region backing the returned native segment is initialized to zero.\n-     *\n-     * @param byteSize the size (in bytes) of the off-heap region of memory backing the native memory segment.\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code byteAlignment <= 0}, or if {@code byteAlignment}\n-     *                                  is not a power of 2.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static MemorySegment allocateNative(long byteSize, long byteAlignment, SegmentScope scope) {\n-        Objects.requireNonNull(scope);\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, scope);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize,\n+                MemorySessionImpl.toMemorySession(arena), cleanupAction);\n@@ -1377,1 +1277,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1379,1 +1279,1 @@\n-     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -1381,1 +1281,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1383,1 +1283,1 @@\n-     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -1424,1 +1324,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1426,1 +1326,1 @@\n-     * such that {@code srcSegment().scope().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n@@ -1428,1 +1328,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1430,1 +1330,1 @@\n-     * such that {@code dstSegment().scope().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n@@ -1477,1 +1377,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1479,1 +1379,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1497,1 +1397,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1499,1 +1399,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1518,1 +1418,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1520,1 +1420,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1538,1 +1438,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1540,1 +1440,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1559,1 +1459,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1561,1 +1461,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1579,1 +1479,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1581,1 +1481,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1600,1 +1500,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1602,1 +1502,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1620,1 +1520,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1622,1 +1522,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1641,1 +1541,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1643,1 +1543,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1661,1 +1561,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1663,1 +1563,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1682,1 +1582,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1684,1 +1584,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1702,1 +1602,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1704,1 +1604,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1723,1 +1623,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1725,1 +1625,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1743,1 +1643,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1745,1 +1645,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1764,1 +1664,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1766,1 +1666,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1784,1 +1684,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1786,1 +1686,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1800,1 +1700,1 @@\n-     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n+     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n@@ -1808,1 +1708,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1810,1 +1710,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1831,1 +1731,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1833,1 +1733,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1854,1 +1754,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1856,1 +1756,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1878,1 +1778,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1880,1 +1780,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1903,1 +1803,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1905,1 +1805,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1927,1 +1827,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1929,1 +1829,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1952,1 +1852,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1954,1 +1854,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1976,1 +1876,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1978,1 +1878,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2001,1 +1901,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2003,1 +1903,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2025,1 +1925,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2027,1 +1927,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2050,1 +1950,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2052,1 +1952,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2074,1 +1974,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2076,1 +1976,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2099,1 +1999,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2101,1 +2001,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2123,1 +2023,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2125,1 +2025,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2142,1 +2042,1 @@\n-     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n+     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n@@ -2146,1 +2046,0 @@\n-     *\n@@ -2152,1 +2051,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2154,1 +2053,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2179,1 +2078,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2181,1 +2080,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2241,1 +2140,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2275,1 +2174,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2317,1 +2216,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2319,1 +2218,1 @@\n-     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -2321,1 +2220,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2323,1 +2222,1 @@\n-     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -2338,0 +2237,41 @@\n+    \/**\n+     * A scope controls access to one or more memory segments. That is, a memory segment cannot be accessed if its\n+     * associated scope is not {@linkplain #isAlive() alive}. In other words, a scope models the <em>lifetime<\/em>\n+     * of all the memory segments associated with it.\n+     * <p>\n+     * A new scope can be created, indirectly, by creating a new {@linkplain Arena arena}. For instance, when a new\n+     * {@linkplain Arena#ofConfined() confined} arena is created, a new scope is also created. This scope - the arena scope - is\n+     * starts as {@link #isAlive() alive}. When the confined arena is {@linkplain Arena#close() closed},\n+     * the arena scope becomes no longer alive.\n+     * <p>\n+     * Scope instances can be compared for equality. That is, two scopes\n+     * are considered {@linkplain #equals(Object)} if they denote the same lifetime.\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    sealed interface Scope permits MemorySessionImpl {\n+        \/**\n+         * {@return {@code true}, if the regions of memory backing the memory segments associated with this scope are\n+         * still valid}\n+         *\/\n+        boolean isAlive();\n+\n+        \/**\n+         * Returns {@code true}, if the provided object is also a scope, and the lifetime associated with this scope\n+         * and that scope are the same. In that case, it is always the case that\n+         * {@code this.isAlive() == ((Scope)that).isAlive()}.\n+         * @param that the object to be tested.\n+         * @return {@code true}, if the provided object is also a scope, and the lifetime associated with this scope\n+         * and that scope are the same.\n+         *\/\n+        @Override\n+        boolean equals(Object that);\n+\n+        \/**\n+         * Returns the hash code of this scope object.\n+         * @implSpec Implementations of this method obey the general contract of {@link Object#hashCode}.\n+         * @return the hash code of this scope object.\n+         * @see #equals(Object)\n+         *\/\n+        @Override\n+        int hashCode();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":256,"deletions":316,"binary":false,"changes":572,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n- *     <li>{@link #nativeAllocator(SegmentScope)} obtains a simple allocator which can\n- *     be used to allocate native segments;<\/li>\n@@ -387,27 +385,0 @@\n-\n-    \/**\n-     * Simple allocator used to allocate native segments. The returned allocator responds to an allocation request by\n-     * returning a native segment backed by a fresh off-heap region of memory, with given byte size and alignment constraint.\n-     * <p>\n-     * Each native segment obtained by the returned allocator is associated with the provided scope. As such,\n-     * the off-heap region which backs the returned segment is freed when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * <p>\n-     * The {@link MemorySegment#address()} of the native segments obtained by the returned allocator is the starting address of\n-     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n-     * of the native segment will be aligned according the provided alignment constraint.\n-     * <p>\n-     * The off-heap region of memory backing a native segment obtained by the returned allocator is initialized to zero.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * SegmentAllocator nativeAllocator = (byteSize, byteAlignment) ->\n-     *     MemorySegment.allocateNative(byteSize, byteAlignment, scope);\n-     * }\n-     * @param scope the scope associated with the segments returned by the native allocator.\n-     * @return a simple allocator used to allocate native segments.\n-     *\/\n-    static SegmentAllocator nativeAllocator(SegmentScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySessionImpl)scope;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.ref.CleanerFactory;\n-\n-\/**\n- * A segment scope controls access to memory segments.\n- * <p>\n- * A memory segment can only be accessed while its scope is {@linkplain #isAlive() alive}. Moreover,\n- * depending on how the segment scope has been obtained, access might additionally be\n- * <a href=\"Arena.html#thread-confinement\">restricted to specific threads<\/a>.\n- * <p>\n- * The simplest segment scope is the {@linkplain SegmentScope#global() global scope}. The global scope\n- * is always alive. As a result, segments associated with the global scope are always accessible and their backing\n- * regions of memory are never deallocated. Moreover, memory segments associated with the global scope\n- * can be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n- * {@snippet lang = java:\n- * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.global());\n- * ...\n- * \/\/ segment is never deallocated!\n- *}\n- * <p>\n- * Alternatively, clients can obtain an {@linkplain SegmentScope#auto() automatic scope}, that is a segment\n- * scope that is managed, automatically, by the garbage collector. The regions of memory backing memory segments associated\n- * with an automatic scope are deallocated at some unspecified time <em>after<\/em> they become\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n- *\n- * {@snippet lang = java:\n- * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.auto());\n- * ...\n- * segment = null; \/\/ the segment region becomes available for deallocation after this point\n- *}\n- * Memory segments associated with an automatic scope can also be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n- * <p>\n- * Finally, clients can obtain a segment scope from an existing {@linkplain Arena arena}, the arena scope. The regions of memory\n- * backing memory segments associated with an arena scope are deallocated when the arena is {@linkplain Arena#close() closed}.\n- * When this happens, the arena scope becomes not {@linkplain #isAlive() alive} and subsequent access operations on segments\n- * associated with the arena scope will fail {@link IllegalStateException}.\n- *\n- * {@snippet lang = java:\n- * MemorySegment segment = null;\n- * try (Arena arena = Arena.openConfined()) {\n- *     segment = MemorySegment.allocateNative(100, arena.scope());\n- *     ...\n- * } \/\/ segment region deallocated here\n- * segment.get(ValueLayout.JAVA_BYTE, 0); \/\/ throws IllegalStateException\n- * }\n- *\n- * Which threads can {@link #isAccessibleBy(Thread) access} memory segments associated with an arena scope depends\n- * on the arena kind. For instance, segments associated with the scope of a {@linkplain Arena#openConfined() confined arena}\n- * can only be accessed by the thread that created the arena. Conversely, segments associated with the scope of\n- * {@linkplain Arena#openConfined() shared arena} can be accessed by any thread.\n- *\n- * @implSpec\n- * Implementations of this interface are thread-safe.\n- *\n- * @see Arena\n- * @see MemorySegment\n- *\n- * @since 20\n- *\/\n-@PreviewFeature(feature =PreviewFeature.Feature.FOREIGN)\n-sealed public interface SegmentScope permits MemorySessionImpl {\n-\n-    \/**\n-     * Creates a new scope that is managed, automatically, by the garbage collector.\n-     * Segments associated with the returned scope can be\n-     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread.\n-     *\n-     * @return a new scope that is managed, automatically, by the garbage collector.\n-     *\/\n-    static SegmentScope auto() {\n-        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n-    }\n-\n-    \/**\n-     * Obtains the global scope. Segments associated with the global scope can be\n-     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread.\n-     *\n-     * @return the global scope.\n-     *\/\n-    static SegmentScope global() {\n-        return MemorySessionImpl.GLOBAL;\n-    }\n-\n-    \/**\n-     * {@return {@code true}, if this scope is alive}\n-     *\/\n-    boolean isAlive();\n-\n-    \/**\n-     * {@return {@code true} if the provided thread can access and\/or associate segments with this scope}\n-     * @param thread the thread to be tested.\n-     *\/\n-    boolean isAccessibleBy(Thread thread);\n-\n-    \/**\n-     * Runs a critical action while this scope is kept alive.\n-     * @param action the action to be run.\n-     * @throws IllegalStateException if this scope is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code isAccessibleBy(T) == false}.\n-     *\/\n-    void whileAlive(Runnable action);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentScope.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -57,1 +57,1 @@\n- *     {@link MemorySegment#ofAddress(long, long, SegmentScope) resizing} the segment first).<\/li>\n+ *     {@link MemorySegment#ofAddress(long, long, Arena) resizing} the segment first).<\/li>\n@@ -62,1 +62,1 @@\n- * The factory methods {@link #libraryLookup(String, SegmentScope)} and {@link #libraryLookup(Path, SegmentScope)}\n+ * The factory methods {@link #libraryLookup(String, Arena)} and {@link #libraryLookup(Path, Arena)}\n@@ -64,2 +64,4 @@\n- * The library is loaded if not already loaded. The symbol lookup, which is known as a <em>library lookup<\/em>, is associated\n- * with a {@linkplain  SegmentScope scope}; when the scope becomes not {@link SegmentScope#isAlive()}, the library is unloaded:\n+ * The library is loaded if not already loaded. The symbol lookup, which is known as a <em>library lookup<\/em>, and its\n+ * lifetime is controlled by an {@linkplain Arena arena}. For instance, if the provided arena is a\n+ * confined arena, the library associated with the symbol lookup is unloaded when the confined arena\n+ * is {@linkplain Arena#close()}:\n@@ -68,2 +70,2 @@\n- * try (Arena arena = Arena.openConfined()) {\n- *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.scope()); \/\/ libGL.so loaded here\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena); \/\/ libGL.so loaded here\n@@ -95,1 +97,1 @@\n- * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", arena).find(\"glGetString\").isPresent(); \/\/ true\n@@ -104,1 +106,1 @@\n- * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", arena).find(\"glGetString\").isPresent(); \/\/ true\n@@ -142,3 +144,4 @@\n-     * returned by this method is backed by a scope that is always alive and which keeps the caller's\n-     * class loader reachable. Therefore, libraries associated with the caller's class\n-     * loader are kept loaded (and their symbols available) as long as a loader lookup for that class loader is reachable.\n+     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * class loader reachable. Therefore, libraries associated with the caller's class loader are kept loaded\n+     * (and their symbols available) as long as a loader lookup for that class loader, or any of the segments\n+     * obtained by it, is reachable.\n@@ -161,3 +164,7 @@\n-        SegmentScope loaderScope = (loader == null || loader instanceof BuiltinClassLoader) ?\n-                SegmentScope.global() : \/\/ builtin loaders never go away\n-                MemorySessionImpl.heapSession(loader);\n+        Arena loaderScope;\/\/ builtin loaders never go away\n+        if ((loader == null || loader instanceof BuiltinClassLoader)) {\n+            loaderScope = Arena.global();\n+        } else {\n+            MemorySessionImpl session = MemorySessionImpl.heapSession(loader);\n+            loaderScope = session.asArena();\n+        }\n@@ -177,2 +184,4 @@\n-     * The library will be unloaded when the provided scope becomes\n-     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n+     * The lifetime of the returned library lookup is controlled by the provided arena.\n+     * For instance, if the provided arena is a confined arena, the library\n+     * associated with the returned lookup will be unloaded when the provided confined arena is\n+     * {@linkplain Arena#close() closed}.\n@@ -189,1 +198,1 @@\n-     * @param scope the scope associated with symbols obtained from the returned lookup.\n+     * @param arena the arena associated with symbols obtained from the returned lookup.\n@@ -191,0 +200,3 @@\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -195,1 +207,1 @@\n-    static SymbolLookup libraryLookup(String name, SegmentScope scope) {\n+    static SymbolLookup libraryLookup(String name, Arena arena) {\n@@ -197,1 +209,1 @@\n-        return libraryLookup(name, RawNativeLibraries::load, scope);\n+        return libraryLookup(name, RawNativeLibraries::load, arena);\n@@ -202,2 +214,4 @@\n-     * in that library. The library will be unloaded when the provided scope becomes\n-     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n+     * in that library. The lifetime of the returned library lookup is controlled by the provided arena.\n+     * For instance, if the provided arena is a confined arena, the library\n+     * associated with the returned lookup will be unloaded when the provided confined arena is\n+     * {@linkplain Arena#close() closed}.\n@@ -213,1 +227,1 @@\n-     * @param scope the scope associated with symbols obtained from the returned lookup.\n+     * @param arena the arena associated with symbols obtained from the returned lookup.\n@@ -215,0 +229,3 @@\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -219,1 +236,1 @@\n-    static SymbolLookup libraryLookup(Path path, SegmentScope scope) {\n+    static SymbolLookup libraryLookup(Path path, Arena arena) {\n@@ -221,1 +238,1 @@\n-        return libraryLookup(path, RawNativeLibraries::load, scope);\n+        return libraryLookup(path, RawNativeLibraries::load, arena);\n@@ -224,1 +241,1 @@\n-    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, SegmentScope libScope) {\n+    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, Arena libScope) {\n@@ -234,1 +251,1 @@\n-        ((MemorySessionImpl) libScope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        MemorySessionImpl.toMemorySession(libScope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":43,"deletions":26,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * MemorySegment segment = MemorySegment.allocateNative(10 * 4, SegmentScope.auto());\n+ * MemorySegment segment = Arena.ofAuto().allocate(10 * 4, 1);\n@@ -53,1 +53,2 @@\n- * The segment is associated with an {@linkplain java.lang.foreign.SegmentScope#auto() automatic scope}. This\n+ * Native segments are allocated using an {@link Arena}. An arena controls the lifetime of all the segments allocated\n+ * from it. In this case, as the segment is allocated using an {@linkplain java.lang.foreign.Arena#ofAuto() automatic arena}. This\n@@ -75,1 +76,1 @@\n- * This can be done, using the {@link java.lang.foreign.Arena} abstraction, as shown below:\n+ * This can be done, using a <em>confined arena<\/em>, as shown below:\n@@ -78,1 +79,1 @@\n- * try (Arena arena = Arena.openConfined()) {\n+ * try (Arena arena = Arena.ofConfined()) {\n@@ -86,6 +87,5 @@\n- * This example is almost identical to the prior one; this time we first create an arena\n- * which is used to allocate multiple native segments which share the same life-cycle. That is, all the segments\n- * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.SegmentScope scope}.\n- * Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures that the off-heap region of memory backing the\n- * native segment will be released at the end of the block, according to the semantics described in Section {@jls 14.20.3}\n- * of <cite>The Java Language Specification<\/cite>.\n+ * A confined arena can be {@linkplain java.lang.foreign.Arena#close() closed}. When a confined\n+ * arena is closed, all the segments allocated by it are invalidated, and become inaccessible.\n+ * Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures\n+ * that the off-heap region of memory backing the native segment will be released at the end of the block, according to\n+ * the semantics described in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n@@ -102,1 +102,1 @@\n- * the scope associated with the segment being accessed is still alive.\n+ * the arena from which the segment has been obtained has not been closed.\n@@ -125,1 +125,1 @@\n- * try (Arena arena = Arena.openConfined()) {\n+ * try (Arena arena = Arena.ofConfined()) {\n@@ -182,1 +182,1 @@\n- * SegmentScope scope = ...\n+ * Arena arena = ...\n@@ -184,1 +184,1 @@\n- *     intCompareHandle, intCompareDescriptor, scope);\n+ *     intCompareHandle, intCompareDescriptor, arena);\n@@ -189,1 +189,1 @@\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, SegmentScope, Linker.Option...) create}\n+ * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, Arena, Linker.Option...) create}\n@@ -193,3 +193,3 @@\n- * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.SegmentScope scope}\n- * provided when the upcall stub is created. This same scope is made available by the {@link java.lang.foreign.MemorySegment}\n- * instance returned by that method.\n+ * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.Arena arena}\n+ * provided when the upcall stub is created. If the provided arena is a confined arena,\n+ * the upcall stub will be deallocated when the confined arena is {@linkplain java.lang.foreign.Arena#close() closed}.\n@@ -200,1 +200,1 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}\n+ * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, Arena)}\n@@ -205,1 +205,1 @@\n- * {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}, if the provided spatial bounds are\n+ * {@link java.lang.foreign.MemorySegment#ofAddress(long, long, Arena)}, if the provided spatial bounds are\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -30,1 +31,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -1003,1 +1003,1 @@\n-     * with the given offset, size and memory session.\n+     * with the given offset, size and arena.\n@@ -1007,1 +1007,5 @@\n-     *\n+     * <p>\n+     * The lifetime of the returned segment is controlled by the provided arena.\n+     * For instance, if the provided arena is a closeable arena,\n+     * the returned segment will be unmapped when the provided closeable arena\n+     * is {@linkplain Arena#close() closed}.\n@@ -1048,2 +1052,2 @@\n-     * @param   session\n-     *          The segment memory session.\n+     * @param   arena\n+     *          The segment arena.\n@@ -1058,2 +1062,1 @@\n-     *          If the {@code session} is not\n-     *          {@linkplain SegmentScope#isAlive() alive}.\n+     *          If {@code arena.isAlive() == false}.\n@@ -1062,3 +1065,2 @@\n-     *          If this method is called from a thread other than the thread\n-     *          {@linkplain SegmentScope#isAccessibleBy(Thread) owning} the\n-     *          {@code session}.\n+     *          If {@code arena} is a confined scoped arena, and this method is called from a\n+     *          thread {@code T}, other than the scoped arena's owner thread.\n@@ -1086,1 +1088,1 @@\n-    public MemorySegment map(MapMode mode, long offset, long size, SegmentScope session)\n+    public MemorySegment map(MapMode mode, long offset, long size, Arena arena)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -50,0 +46,1 @@\n+\n@@ -82,1 +79,1 @@\n-    final SegmentScope scope;\n+    final MemorySessionImpl scope;\n@@ -85,1 +82,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, SegmentScope scope) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySessionImpl scope) {\n@@ -91,1 +88,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope);\n@@ -385,1 +382,1 @@\n-    public SegmentScope scope() {\n+    public Scope scope() {\n@@ -389,0 +386,5 @@\n+    @Override\n+    public boolean isAccessibleBy(Thread thread) {\n+        return sessionImpl().isAccessibleBy(thread);\n+    }\n+\n@@ -391,1 +393,1 @@\n-        return (MemorySessionImpl)scope;\n+        return scope;\n@@ -508,1 +510,3 @@\n-        final SegmentScope bufferScope;\n+        boolean readOnly = bb.isReadOnly();\n+        int scaleFactor = getScaleFactor(bb);\n+        final MemorySessionImpl bufferScope;\n@@ -514,2 +518,0 @@\n-        boolean readOnly = bb.isReadOnly();\n-        int scaleFactor = getScaleFactor(bb);\n@@ -518,1 +520,1 @@\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -520,1 +522,1 @@\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -522,1 +524,1 @@\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -524,1 +526,1 @@\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -526,1 +528,1 @@\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -528,1 +530,1 @@\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -530,1 +532,1 @@\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -49,1 +48,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, SegmentScope)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySessionImpl)}.\n@@ -70,2 +69,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly) {\n-        super(length, readOnly, SegmentScope.global());\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+        super(length, readOnly, session);\n@@ -82,1 +81,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope);\n@@ -97,2 +96,2 @@\n-        OfByte(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfByte(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -102,2 +101,2 @@\n-        OfByte dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfByte(this.offset + offset, base, size, readOnly);\n+        OfByte dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfByte(this.offset + offset, base, size, readOnly, scope);\n@@ -114,1 +113,2 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -130,2 +130,2 @@\n-        OfChar(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfChar(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -135,2 +135,2 @@\n-        OfChar dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfChar(this.offset + offset, base, size, readOnly);\n+        OfChar dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfChar(this.offset + offset, base, size, readOnly, scope);\n@@ -147,1 +147,2 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -163,2 +164,2 @@\n-        OfShort(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfShort(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -168,2 +169,2 @@\n-        OfShort dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfShort(this.offset + offset, base, size, readOnly);\n+        OfShort dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfShort(this.offset + offset, base, size, readOnly, scope);\n@@ -180,1 +181,2 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -196,2 +198,2 @@\n-        OfInt(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfInt(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -201,2 +203,2 @@\n-        OfInt dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfInt(this.offset + offset, base, size, readOnly);\n+        OfInt dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfInt(this.offset + offset, base, size, readOnly, scope);\n@@ -213,1 +215,2 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -229,2 +232,2 @@\n-        OfLong(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfLong(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -234,2 +237,2 @@\n-        OfLong dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfLong(this.offset + offset, base, size, readOnly);\n+        OfLong dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfLong(this.offset + offset, base, size, readOnly, scope);\n@@ -246,1 +249,2 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -262,2 +266,2 @@\n-        OfFloat(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfFloat(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -267,2 +271,2 @@\n-        OfFloat dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfFloat(this.offset + offset, base, size, readOnly);\n+        OfFloat dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfFloat(this.offset + offset, base, size, readOnly, scope);\n@@ -279,1 +283,2 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -295,2 +300,2 @@\n-        OfDouble(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfDouble(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -300,2 +305,2 @@\n-        OfDouble dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfDouble(this.offset + offset, base, size, readOnly);\n+        OfDouble dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfDouble(this.offset + offset, base, size, readOnly, scope);\n@@ -312,1 +317,2 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":46,"deletions":40,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -46,1 +45,1 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, SegmentScope scope) {\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySessionImpl scope) {\n@@ -58,1 +57,1 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.Arena;\n@@ -31,2 +30,2 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -54,1 +53,1 @@\n-        implements SegmentScope, SegmentAllocator\n+        implements Scope\n@@ -83,1 +82,1 @@\n-            public SegmentScope scope() {\n+            public Scope scope() {\n@@ -91,7 +90,0 @@\n-\n-            @Override\n-            public boolean isCloseableBy(Thread thread) {\n-                Objects.requireNonNull(thread);\n-                return ownerThread() == null || \/\/ shared\n-                        ownerThread() == thread;\n-            }\n@@ -101,0 +93,11 @@\n+    @ForceInline\n+    public static final MemorySessionImpl toMemorySession(Arena arena) {\n+        return (MemorySessionImpl) arena.scope();\n+    }\n+\n+    public final boolean isCloseableBy(Thread thread) {\n+        Objects.requireNonNull(thread);\n+        return isCloseable() &&\n+                (owner == null || owner == thread);\n+    }\n+\n@@ -153,1 +156,0 @@\n-    @Override\n@@ -163,1 +165,0 @@\n-    @Override\n@@ -178,6 +179,0 @@\n-    public static boolean sameOwnerThread(SegmentScope scope1, SegmentScope scope2) {\n-        return ((MemorySessionImpl) scope1).ownerThread() ==\n-                ((MemorySessionImpl) scope2).ownerThread();\n-    }\n-\n-    @Override\n@@ -228,0 +223,4 @@\n+    public static final void checkValidState(MemorySegment segment) {\n+        ((AbstractMemorySegmentImpl)segment).sessionImpl().checkValidState();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -55,1 +54,1 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, SegmentScope scope) {\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySessionImpl scope) {\n@@ -57,1 +56,1 @@\n-        this.min = (UNSAFE.addressSize() == 4)\n+        this.min = (Unsafe.getUnsafe().addressSize() == 4)\n@@ -71,1 +70,1 @@\n-        super(0L, false, MemorySessionImpl.GLOBAL);\n+        super(0L, false, new GlobalSession(null));\n@@ -87,1 +86,1 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n@@ -119,2 +118,1 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, SegmentScope scope) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) scope;\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl) {\n@@ -137,1 +135,1 @@\n-                false, scope);\n+                false, sessionImpl);\n@@ -156,2 +154,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope scope, Runnable action) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) scope;\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n@@ -163,1 +160,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, scope);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n@@ -167,2 +164,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope scope) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) scope;\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n@@ -170,1 +166,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, scope);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n@@ -175,1 +171,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, SegmentScope.global());\n+        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -29,1 +30,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -91,1 +91,1 @@\n-                ADDRESS.byteSize() * numSymbols, SegmentScope.global());\n+                ADDRESS.byteSize() * numSymbols, Arena.global());\n@@ -94,1 +94,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, SegmentScope.global()));\n+                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, Arena.global()));\n@@ -111,1 +111,1 @@\n-                        Optional.of(MemorySegment.ofAddress(addr, 0, SegmentScope.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr, 0, Arena.global()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -157,1 +157,1 @@\n-    public static MemorySegment longToAddress(long addr, long size, long align, SegmentScope scope) {\n+    public static MemorySegment longToAddress(long addr, long size, long align, MemorySessionImpl scope) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -75,2 +75,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope, Linker.Option... options) {\n-        Objects.requireNonNull(scope);\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena, Linker.Option... options) {\n+        Objects.requireNonNull(arena);\n@@ -87,1 +87,1 @@\n-        return arrangeUpcall(target, target.type(), function, scope, optionSet);\n+        return arrangeUpcall(target, target.type(), function, arena, optionSet);\n@@ -91,1 +91,1 @@\n-                                                   FunctionDescriptor function, SegmentScope scope,\n+                                                   FunctionDescriptor function, Arena arena,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -30,5 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -200,1 +197,1 @@\n-     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link SegmentScope} that\n+     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link Arena} that\n@@ -205,1 +202,1 @@\n-        private final SegmentScope scope;\n+        private final MemorySessionImpl scope;\n@@ -207,1 +204,1 @@\n-        private Context(SegmentAllocator allocator, SegmentScope scope) {\n+        private Context(SegmentAllocator allocator, MemorySessionImpl scope) {\n@@ -216,1 +213,1 @@\n-        public SegmentScope scope() {\n+        public MemorySessionImpl scope() {\n@@ -229,2 +226,3 @@\n-            Arena arena = Arena.openConfined();\n-            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.scope())), arena.scope()) {\n+            Arena arena = Arena.ofConfined();\n+            return new Context(SegmentAllocator.slicingAllocator(arena.allocate(size, 1)),\n+                    (MemorySessionImpl)arena.scope()) {\n@@ -245,1 +243,1 @@\n-                public SegmentScope scope() {\n+                public MemorySessionImpl scope() {\n@@ -256,2 +254,2 @@\n-            Arena arena = Arena.openConfined();\n-            return new Context(null, arena.scope()) {\n+            Arena arena = Arena.ofConfined();\n+            return new Context(null, (MemorySessionImpl)arena.scope()) {\n@@ -279,1 +277,1 @@\n-            public SegmentScope scope() {\n+            public MemorySessionImpl scope() {\n@@ -702,1 +700,1 @@\n-                stack.push(Utils.longToAddress((long) stack.pop(), size, align, context.scope));\n+                stack.push(Utils.longToAddress((long) stack.pop(), size, align, context.scope()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -47,6 +46,1 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -85,1 +79,1 @@\n-    private static final String SCOPE_DESC = methodType(SegmentScope.class).descriptorString();\n+    private static final String SCOPE_DESC = methodType(MemorySessionImpl.class).descriptorString();\n@@ -91,1 +85,1 @@\n-    private static final String LONG_TO_ADDRESS_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class, SegmentScope.class).descriptorString();\n+    private static final String LONG_TO_ADDRESS_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class, MemorySessionImpl.class).descriptorString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -64,1 +64,1 @@\n-    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, SegmentScope scope) {\n+    public static MemorySegment make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, Arena scope) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -53,2 +53,2 @@\n-    static MemorySegment makeUpcall(long entry, SegmentScope scope) {\n-        ((MemorySessionImpl) scope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+    static MemorySegment makeUpcall(long entry, Arena scope) {\n+        MemorySessionImpl.toMemorySession(scope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.Arena;\n@@ -47,1 +48,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -193,1 +193,1 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session, LinkerOptions options) {\n+    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena session, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -63,1 +63,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -34,1 +35,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -63,1 +63,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.foreign.Arena;\n@@ -35,1 +36,0 @@\n-import java.lang.foreign.SegmentScope ;\n@@ -60,1 +60,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n@@ -64,1 +64,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -75,2 +74,2 @@\n-    private static MemorySegment make(List<MemoryLayout> elements, FFIABI abi, SegmentScope scope) {\n-        MemorySegment elementsSeg = MemorySegment.allocateNative((elements.size() + 1) * ADDRESS.byteSize(), scope);\n+    private static MemorySegment make(List<MemoryLayout> elements, FFIABI abi, Arena scope) {\n+        MemorySegment elementsSeg = scope.allocate((elements.size() + 1) * ADDRESS.byteSize());\n@@ -86,1 +85,1 @@\n-        MemorySegment ffiType = MemorySegment.allocateNative(LAYOUT, scope);\n+        MemorySegment ffiType = scope.allocate(LAYOUT);\n@@ -105,1 +104,1 @@\n-    static MemorySegment toFFIType(MemoryLayout layout, FFIABI abi, SegmentScope scope) {\n+    static MemorySegment toFFIType(MemoryLayout layout, FFIABI abi, Arena scope) {\n@@ -128,1 +127,1 @@\n-        try (Arena verifyArena = Arena.openConfined()) {\n+        try (Arena verifyArena = Arena.ofConfined()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -84,1 +83,1 @@\n-        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, SegmentScope.auto());\n+        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, Arena.ofAuto());\n@@ -110,1 +109,1 @@\n-                                          SegmentScope scope, LinkerOptions options) {\n+                                          Arena scope, LinkerOptions options) {\n@@ -120,2 +119,2 @@\n-    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, SegmentScope scope) {\n-        MemorySegment argTypes = MemorySegment.allocateNative(function.argumentLayouts().size() * ADDRESS.byteSize(), scope);\n+    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, Arena scope) {\n+        MemorySegment argTypes = scope.allocate(function.argumentLayouts().size() * ADDRESS.byteSize());\n@@ -139,1 +138,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -192,2 +191,2 @@\n-        try (Arena upcallArena = Arena.openConfined()) {\n-            MemorySegment argsSeg = MemorySegment.ofAddress(argPtrs.address(), numArgs * ADDRESS.byteSize(), upcallArena.scope());\n+        try (Arena upcallArena = Arena.ofConfined()) {\n+            MemorySegment argsSeg = MemorySegment.ofAddress(argPtrs.address(), numArgs * ADDRESS.byteSize(), upcallArena);\n@@ -195,1 +194,1 @@\n-                ? MemorySegment.ofAddress(retPtr.address(), retLayout.byteSize(), upcallArena.scope())\n+                ? MemorySegment.ofAddress(retPtr.address(), retLayout.byteSize(), upcallArena)\n@@ -201,1 +200,1 @@\n-                MemorySegment argPtr = MemorySegment.ofAddress(argsSeg.getAtIndex(JAVA_LONG, i), argLayout.byteSize(), upcallArena.scope());\n+                MemorySegment argPtr = MemorySegment.ofAddress(argsSeg.getAtIndex(JAVA_LONG, i), argLayout.byteSize(), upcallArena);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -30,1 +31,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -101,2 +101,2 @@\n-                                         SegmentScope scope) throws IllegalStateException {\n-        MemorySegment cif = MemorySegment.allocateNative(SIZEOF_CIF, scope);\n+                                         Arena scope) throws IllegalStateException {\n+        MemorySegment cif = scope.allocate(SIZEOF_CIF);\n@@ -126,1 +126,1 @@\n-                                       Thread.UncaughtExceptionHandler handler, SegmentScope scope)\n+                                       Thread.UncaughtExceptionHandler handler, Arena scope)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -44,1 +45,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -123,1 +123,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope, LinkerOptions options) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -34,1 +35,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -58,1 +58,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -135,1 +135,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope, LinkerOptions options) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -61,1 +61,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -134,1 +134,1 @@\n-    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope scope, LinkerOptions options) {\n+    public static MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -60,1 +60,1 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope, LinkerOptions options) {\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, Arena scope, LinkerOptions options) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -1211,1 +1211,1 @@\n-                             SegmentScope session)\n+                             Arena arena)\n@@ -1215,2 +1215,2 @@\n-        Objects.requireNonNull(session, \"Session is null\");\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n+        Objects.requireNonNull(arena, \"Arena is null\");\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toMemorySession(arena);\n@@ -1233,1 +1233,1 @@\n-                                            readOnly, session);\n+                                            readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -382,1 +382,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+            Arena scope = Arena.ofAuto();\n+            MemorySegment segment = scope.allocate(layout);\n@@ -386,1 +387,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1L, SegmentScope.auto());\n+            Arena scope = Arena.ofAuto();\n+            MemorySegment segment = scope.allocate(1L, 1);\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.*;\n@@ -27,5 +28,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SymbolLookup;\n@@ -54,6 +50,6 @@\n-        try (Arena arena0 = Arena.openConfined()) {\n-            callFunc(loadLibrary(arena0.scope()));\n-            try (Arena arena1 = Arena.openConfined()) {\n-                callFunc(loadLibrary(arena1.scope()));\n-                try (Arena arena2 = Arena.openConfined()) {\n-                    callFunc(loadLibrary(arena2.scope()));\n+        try (Arena arena0 = Arena.ofConfined()) {\n+            callFunc(loadLibrary(arena0));\n+            try (Arena arena1 = Arena.ofConfined()) {\n+                callFunc(loadLibrary(arena1));\n+                try (Arena arena2 = Arena.ofConfined()) {\n+                    callFunc(loadLibrary(arena2));\n@@ -68,2 +64,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            addr = loadLibrary(arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            addr = loadLibrary(arena);\n@@ -74,1 +70,1 @@\n-    private static MemorySegment loadLibrary(SegmentScope session) {\n+    private static MemorySegment loadLibrary(Arena session) {\n@@ -77,1 +73,1 @@\n-        assertEquals(addr.scope(), session);\n+        assertEquals(addr.scope(), session.scope());\n@@ -97,1 +93,1 @@\n-        SymbolLookup.libraryLookup(\"nonExistent\", SegmentScope.global());\n+        SymbolLookup.libraryLookup(\"nonExistent\", Arena.global());\n@@ -102,1 +98,1 @@\n-        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), SegmentScope.global());\n+        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), Arena.global());\n@@ -119,2 +115,2 @@\n-                try (Arena arena = Arena.openConfined()) {\n-                    callFunc(loadLibrary(arena.scope()));\n+                try (Arena arena = Arena.ofConfined()) {\n+                    callFunc(loadLibrary(arena));\n@@ -128,2 +124,2 @@\n-        Arena arena = Arena.openShared();\n-        MemorySegment addr = loadLibrary(arena.scope());\n+        Arena arena = Arena.ofShared();\n+        MemorySegment addr = loadLibrary(arena);\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -154,1 +153,1 @@\n-            return LINKER.upcallStub(target, descriptor, SegmentScope.auto());\n+            return LINKER.upcallStub(target, descriptor, Arena.ofAuto());\n@@ -267,1 +266,1 @@\n-        return LINKER.upcallStub(target, fd, arena.scope());\n+        return LINKER.upcallStub(target, fd, arena);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -60,1 +59,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -78,1 +77,1 @@\n-                Arena arena = Arena.openShared();\n+                Arena arena = Arena.ofShared();\n@@ -117,1 +116,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -119,1 +118,1 @@\n-            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n+            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena);\n@@ -137,1 +136,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -149,1 +148,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -151,1 +150,1 @@\n-            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n+            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena);\n@@ -161,1 +160,1 @@\n-            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n+            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), Arena.ofAuto());\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -192,1 +192,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -200,1 +200,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -207,1 +207,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -214,1 +214,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -274,1 +274,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -278,1 +278,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.scope());\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena);\n@@ -297,1 +297,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,4 +34,2 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n+\n@@ -97,1 +95,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -116,1 +115,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -137,1 +137,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -194,2 +195,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = arena.allocate(ValueLayout.JAVA_INT);\n@@ -205,2 +206,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = arena.allocate(ValueLayout.JAVA_INT);\n@@ -214,1 +215,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -257,1 +259,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -295,1 +298,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -334,1 +338,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -377,1 +382,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -86,1 +86,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -117,1 +117,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -120,1 +120,1 @@\n-            MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena.scope());\n+            MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena);\n@@ -138,1 +138,1 @@\n-            try (Arena arena = Arena.openConfined()) {\n+            try (Arena arena = Arena.ofConfined()) {\n@@ -141,1 +141,1 @@\n-                MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena.scope());\n+                MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena);\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -34,3 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n@@ -111,1 +107,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -122,1 +119,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), SegmentScope.global());\n+        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), Arena.global());\n@@ -130,2 +127,4 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            long byteSize = layout.byteSize() + 1;\n+            long byteAlignment = layout.byteSize();\n+            MemorySegment segment = arena.allocate(byteSize, byteAlignment);\n@@ -139,2 +138,2 @@\n-        Arena arena = Arena.openConfined();\n-        MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,3 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -35,2 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n@@ -40,1 +36,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -188,2 +183,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(tuples);;\n@@ -233,1 +228,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -235,1 +230,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena);\n@@ -239,1 +234,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -241,1 +236,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena);\n@@ -252,1 +247,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -255,1 +250,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena);\n@@ -260,1 +255,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -263,1 +258,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena);\n@@ -274,1 +269,1 @@\n-        Arena arena = Arena.openConfined();\n+        Arena arena = Arena.ofConfined();\n@@ -276,1 +271,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena);\n@@ -293,1 +288,1 @@\n-            try (Arena arena = Arena.openConfined();\n+            try (Arena arena = Arena.ofConfined();\n@@ -296,1 +291,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.scope());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena);\n@@ -304,1 +299,1 @@\n-            try (Arena arena = Arena.openConfined();\n+            try (Arena arena = Arena.ofConfined();\n@@ -307,1 +302,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena);\n@@ -325,1 +320,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -327,1 +322,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena);\n@@ -363,2 +358,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(bytes);;\n@@ -389,2 +384,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(bytes);;\n@@ -423,2 +418,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(bytes);;\n@@ -436,2 +431,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n@@ -474,2 +469,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n@@ -485,2 +480,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            leaked = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            leaked = arena.allocate(bytes);;\n@@ -494,1 +489,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, SegmentScope.auto());\n+        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, Arena.ofAuto());\n@@ -504,1 +499,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, SegmentScope.auto());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, Arena.ofAuto());\n@@ -514,1 +509,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, SegmentScope.auto());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, Arena.ofAuto());\n@@ -526,1 +521,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -528,1 +523,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena);\n@@ -536,1 +531,1 @@\n-            try (Arena arena = Arena.openConfined();\n+            try (Arena arena = Arena.ofConfined();\n@@ -538,1 +533,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.scope());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena);\n@@ -550,1 +545,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -552,1 +547,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena);\n@@ -562,1 +557,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -564,1 +559,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena);\n@@ -579,1 +574,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, SegmentScope.auto());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, Arena.ofAuto());\n@@ -587,2 +582,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment nativeArray = arena.allocate(bytes, 1);;\n@@ -600,2 +595,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment nativeArray = arena.allocate(seq);;\n@@ -672,2 +667,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment ms = arena.allocate(4, 1);;\n@@ -676,0 +671,1 @@\n+            assertEquals(msRoundTrip.scope(), ms.scope());\n@@ -680,0 +676,10 @@\n+    @Test(dataProvider = \"bufferFactories\")\n+    public void testDerivedBufferScopes(Supplier<Buffer> bufferFactory) {\n+        MemorySegment segment = MemorySegment.ofBuffer(bufferFactory.get());\n+        assertEquals(segment.scope(), segment.scope());\n+        assertEquals(segment.asSlice(0).scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().scope(), segment.scope());\n+        MemorySegment another = MemorySegment.ofBuffer(bufferFactory.get());\n+        assertNotEquals(segment.scope(), another.scope());\n+    }\n+\n@@ -682,2 +688,2 @@\n-        Arena arena = Arena.openConfined();\n-        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment s1 = arena.allocate(JAVA_INT);\n@@ -698,1 +704,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());;\n+            MemorySegment segment = arena.allocate(10, 1);;\n@@ -719,1 +725,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, arena.scope());\n+            MemorySegment segment = arena.allocate(10, 1);\n@@ -736,2 +742,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(16, 1);;\n@@ -754,2 +760,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(16, 1);;\n@@ -765,2 +771,2 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, SegmentScope.auto()) },\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().scope()) },\n+                { (Supplier<MemorySegment>) () -> Arena.ofAuto().allocate(16, 1)},\n+                { (Supplier<MemorySegment>) () -> Arena.ofConfined().allocate(16, 1)},\n@@ -774,2 +780,2 @@\n-                { (Supplier<Arena>) Arena::openConfined },\n-                { (Supplier<Arena>) Arena::openShared },\n+                { (Supplier<Arena>) Arena::ofConfined},\n+                { (Supplier<Arena>) Arena::ofShared},\n@@ -989,0 +995,22 @@\n+\n+    @DataProvider(name = \"bufferFactories\")\n+    public static Object[][] bufferFactories() {\n+        List<Supplier<Buffer>> l = List.of(\n+                () -> ByteBuffer.allocate(10),\n+                () -> CharBuffer.allocate(10),\n+                () -> ShortBuffer.allocate(10),\n+                () -> IntBuffer.allocate(10),\n+                () -> FloatBuffer.allocate(10),\n+                () -> LongBuffer.allocate(10),\n+                () -> DoubleBuffer.allocate(10),\n+                () -> ByteBuffer.allocateDirect(10),\n+                () -> ByteBuffer.allocateDirect(10).asCharBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asShortBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asIntBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asFloatBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asLongBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asDoubleBuffer()\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":94,"deletions":66,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -65,1 +65,1 @@\n-                SegmentScope.global());\n+                Arena.global());\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -98,1 +98,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,5 +41,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -66,1 +62,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -69,1 +65,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.scope()) :\n+                    arena :\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,5 +37,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -62,1 +58,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -65,1 +61,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.scope()) :\n+                    arena :\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-            Arena arena = Arena.openShared();\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.scope());\n+            Arena arena = Arena.ofShared();\n+            MemorySegment segment = arena.allocate(SEGMENT_SIZE, 1);\n@@ -77,1 +77,1 @@\n-                accessExecutor.execute(accessorFactory.make(i, segment));\n+                accessExecutor.execute(accessorFactory.make(i, segment, arena));\n@@ -139,1 +139,1 @@\n-        AbstractBufferAccessor(int id, MemorySegment segment) {\n+        AbstractBufferAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -147,1 +147,1 @@\n-        SegmentAccessor(int id, MemorySegment segment) {\n+        SegmentAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -165,1 +165,1 @@\n-        SegmentCopyAccessor(int id, MemorySegment segment) {\n+        SegmentCopyAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -180,1 +180,1 @@\n-        SegmentFillAccessor(int id, MemorySegment segment) {\n+        SegmentFillAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -194,1 +194,1 @@\n-        SegmentMismatchAccessor(int id, MemorySegment segment) {\n+        SegmentMismatchAccessor(int id, MemorySegment segment, Arena arena) {\n@@ -196,1 +196,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.scope());\n+            this.copy = arena.allocate(SEGMENT_SIZE, 1);\n@@ -209,2 +209,2 @@\n-        BufferAccessor(int id, MemorySegment segment) {\n-            super(id, segment);\n+        BufferAccessor(int id, MemorySegment segment, Arena _unused) {\n+            super(id, segment, null);\n@@ -226,2 +226,2 @@\n-        public BufferHandleAccessor(int id, MemorySegment segment) {\n-            super(id, segment);\n+        public BufferHandleAccessor(int id, MemorySegment segment, Arena _unused) {\n+            super(id, segment, null);\n@@ -264,1 +264,1 @@\n-        AbstractSegmentAccessor make(int id, MemorySegment segment);\n+        AbstractSegmentAccessor make(int id, MemorySegment segment, Arena arena);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -103,1 +103,1 @@\n-        NATIVE(MemorySegment.allocateNative(8, SegmentScope.auto()), -1);\n+        NATIVE(Arena.ofAuto().allocate(8, 1), -1);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -36,1 +37,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -76,1 +76,1 @@\n-        ABI.upcallStub(DUMMY_TARGET_MH, FunctionDescriptor.ofVoid(), SegmentScope.auto(), downcallOnlyOption);\n+        ABI.upcallStub(DUMMY_TARGET_MH, FunctionDescriptor.ofVoid(), Arena.ofAuto(), downcallOnlyOption);\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-        try (var arena = Arena.openConfined()) {\n-            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.scope());\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate((long) longArrayLength * Long.BYTES, Long.SIZE);\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,3 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -35,2 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n@@ -38,1 +34,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -438,2 +433,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -37,3 +35,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -94,2 +89,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.scope()));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(arena.allocate(layout));\n@@ -126,2 +121,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(arena.allocate(seq));\n@@ -195,2 +190,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(arena.allocate(seq));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.Arena;\n@@ -32,1 +31,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -83,2 +82,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment segment = MemorySegment.allocateNative(128, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment segment = arena.allocate(128, 1);\n@@ -96,2 +95,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment segment = MemorySegment.allocateNative(64, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment segment = arena.allocate(64, 1);\n@@ -139,1 +138,3 @@\n-        MemorySegment targetSegment = MemorySegment.allocateNative(ValueLayout.ADDRESS.byteSize(), SegmentScope.auto());\n+        long byteSize = ValueLayout.ADDRESS.byteSize();\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment targetSegment = scope.allocate(byteSize, 1);\n@@ -147,1 +148,3 @@\n-        MemorySegment targetSegment = MemorySegment.allocateNative(ValueLayout.ADDRESS.byteSize(), SegmentScope.auto());\n+        long byteSize = ValueLayout.ADDRESS.byteSize();\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment targetSegment = scope.allocate(byteSize, 1);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -34,3 +32,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -55,2 +50,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(aligned);;\n@@ -73,2 +68,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(alignedGroup);;\n@@ -100,2 +95,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment segment = arena.allocate(layout);;\n@@ -124,2 +119,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(g, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(g);;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -296,2 +296,2 @@\n-        try (final Arena arena = Arena.openConfined()) {\n-            var segment = MemorySegment.allocateNative(size, arena.scope());\n+        try (final Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryInspection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n-\n@@ -54,1 +52,1 @@\n-        Arena arena = Arena.openConfined();\n+        Arena arena = Arena.ofConfined();\n@@ -57,1 +55,1 @@\n-            addCloseAction(arena.scope(), () -> acc.addAndGet(delta));\n+            addCloseAction(arena, () -> acc.addAndGet(delta));\n@@ -68,1 +66,1 @@\n-        SegmentScope session = sessionSupplier.get();\n+        Arena session = sessionSupplier.get();\n@@ -91,2 +89,2 @@\n-        SegmentScope session = sessionSupplier.get();\n-        AtomicReference<SegmentScope> sessionRef = new AtomicReference<>(session);\n+        Arena session = sessionSupplier.get();\n+        AtomicReference<Arena> sessionRef = new AtomicReference<>(session);\n@@ -145,1 +143,1 @@\n-        Arena arena = Arena.openConfined();\n+        Arena arena = Arena.ofConfined();\n@@ -148,2 +146,2 @@\n-            Arena handle = Arena.openConfined();\n-            keepAlive(handle.scope(), arena.scope());\n+            Arena handle = Arena.ofConfined();\n+            keepAlive(handle, arena);\n@@ -168,1 +166,1 @@\n-        Arena arena = Arena.openShared();\n+        Arena arena = Arena.ofShared();\n@@ -172,2 +170,2 @@\n-                try (Arena handle = Arena.openConfined()) {\n-                    keepAlive(handle.scope(), arena.scope());\n+                try (Arena handle = Arena.ofConfined()) {\n+                    keepAlive(handle, arena);\n@@ -196,1 +194,1 @@\n-        Arena.openConfined().close();\n+        Arena.ofConfined().close();\n@@ -201,1 +199,1 @@\n-        Arena.openShared().close();\n+        Arena.ofShared().close();\n@@ -206,3 +204,3 @@\n-        Arena arena = Arena.openConfined();\n-        Arena handle = Arena.openConfined();\n-        keepAlive(handle.scope(), arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        Arena handle = Arena.ofConfined();\n+        keepAlive(handle, arena);\n@@ -229,1 +227,1 @@\n-        SegmentScope session = sessionSupplier.get();\n+        Arena session = sessionSupplier.get();\n@@ -235,3 +233,3 @@\n-    private void acquireRecursive(SegmentScope session, int acquireCount) {\n-        try (Arena arena = Arena.openConfined()) {\n-            keepAlive(arena.scope(), session);\n+    private void acquireRecursive(Arena session, int acquireCount) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            keepAlive(arena, session);\n@@ -250,1 +248,1 @@\n-        Arena root = Arena.openConfined();\n+        Arena root = Arena.ofConfined();\n@@ -253,1 +251,1 @@\n-            keepAlive(SegmentScope.auto(), root.scope());\n+            keepAlive(Arena.ofAuto(), root);\n@@ -265,2 +263,2 @@\n-                    try (Arena arena = Arena.openConfined()) {\n-                        keepAlive(arena.scope(), root.scope());\n+                    try (Arena arena = Arena.ofConfined()) {\n+                        keepAlive(arena, root);\n@@ -277,1 +275,1 @@\n-        Arena root = Arena.openConfined();\n+        Arena root = Arena.ofConfined();\n@@ -281,2 +279,2 @@\n-            Arena arena = Arena.openShared(); \/\/ create session inside same thread!\n-            keepAlive(arena.scope(), root.scope());\n+            Arena arena = Arena.ofShared(); \/\/ create session inside same thread!\n+            keepAlive(arena, root);\n@@ -288,2 +286,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                keepAlive(arena.scope(), root.scope());\n+            try (Arena arena = Arena.ofConfined()) {\n+                keepAlive(arena, root);\n@@ -324,2 +322,2 @@\n-                { (Supplier<Arena>) Arena::openConfined},\n-                { (Supplier<Arena>) Arena::openShared},\n+                { (Supplier<Arena>) Arena::ofConfined},\n+                { (Supplier<Arena>) Arena::ofShared},\n@@ -329,2 +327,2 @@\n-    private void keepAlive(SegmentScope child, SegmentScope parent) {\n-        MemorySessionImpl parentImpl = (MemorySessionImpl) parent;\n+    private void keepAlive(Arena child, Arena parent) {\n+        MemorySessionImpl parentImpl = MemorySessionImpl.toMemorySession(parent);\n@@ -335,2 +333,2 @@\n-    private void addCloseAction(SegmentScope session, Runnable action) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n+    private void addCloseAction(Arena session, Runnable action) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toMemorySession(session);\n@@ -340,1 +338,1 @@\n-    interface SessionSupplier extends Supplier<SegmentScope> {\n+    interface SessionSupplier extends Supplier<Arena> {\n@@ -342,2 +340,2 @@\n-        static void close(SegmentScope session) {\n-            ((MemorySessionImpl)session).close();\n+        static void close(Arena session) {\n+            MemorySessionImpl.toMemorySession(session).close();\n@@ -346,2 +344,2 @@\n-        static boolean isImplicit(SegmentScope session) {\n-            return !((MemorySessionImpl)session).isCloseable();\n+        static boolean isImplicit(Arena session) {\n+            return !MemorySessionImpl.toMemorySession(session).isCloseable();\n@@ -351,1 +349,1 @@\n-            return SegmentScope::auto;\n+            return Arena::ofAuto;\n@@ -355,1 +353,1 @@\n-            return () -> arenaSupplier.get().scope();\n+            return () -> arenaSupplier.get();\n@@ -362,1 +360,1 @@\n-                { SessionSupplier.ofArena(Arena::openShared) },\n+                { SessionSupplier.ofArena(Arena::ofShared) },\n@@ -370,2 +368,2 @@\n-                { SessionSupplier.ofArena(Arena::openConfined) },\n-                { SessionSupplier.ofArena(Arena::openShared) },\n+                { SessionSupplier.ofArena(Arena::ofConfined) },\n+                { SessionSupplier.ofArena(Arena::ofShared) },\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":45,"deletions":47,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -175,2 +174,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            var nativeSegment = arena.allocate(4, 4);;\n@@ -187,3 +186,3 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n-                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                var s1 = arena.allocate((long) Integer.MAX_VALUE + 10L, 8);;\n+                var s2 = arena.allocate((long) Integer.MAX_VALUE + 10L, 8);;\n@@ -231,3 +230,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            s1 = MemorySegment.allocateNative(4, 1, arena.scope());;\n-            s2 = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            s1 = arena.allocate(4, 1);\n+            s2 = arena.allocate(4, 1);;\n@@ -242,2 +241,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            var segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(4, 1);;\n@@ -284,1 +283,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n+        NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,3 +32,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -36,3 +34,1 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n+\n@@ -148,2 +144,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n@@ -158,2 +154,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(doubles);;\n@@ -171,1 +167,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -173,1 +169,1 @@\n-                    arena.scope(), () -> freeMemory(addr));\n+                    arena, () -> freeMemory(addr));\n@@ -182,1 +178,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -184,1 +180,1 @@\n-                    arena.scope(), () -> freeMemory(addr));\n+                    arena, () -> freeMemory(addr));\n@@ -201,3 +197,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n-            MemorySegment.ofAddress(segment.address(), -1, SegmentScope.global());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(4, 1);;\n+            MemorySegment.ofAddress(segment.address(), -1, Arena.global());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -102,1 +102,1 @@\n-            SegmentScope.class,\n+            MemorySegment.Scope.class,\n@@ -107,17 +107,1 @@\n-            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.SegmentScope,java.lang.Runnable)\/3\/0\",\n-            \"java.lang.foreign.MemorySegment.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.MemorySegment.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.MemoryLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.SequenceLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfAddress\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfBoolean\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfByte\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfChar\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfShort\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfInt\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfFloat\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfLong\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfDouble\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.GroupLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.Arena,java.lang.Runnable)\/3\/0\"\n@@ -181,2 +165,2 @@\n-        addDefaultMapping(Arena.class, Arena.openConfined());\n-        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n+        addDefaultMapping(Arena.class, Arena.ofConfined());\n+        addDefaultMapping(MemorySegment.Scope.class, Arena.ofAuto().scope());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n@@ -75,2 +73,2 @@\n-        Arena arena = Arena.openConfined();\n-        Z obj = scopedOperation.apply(arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        Z obj = scopedOperation.apply(arena);\n@@ -88,2 +86,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            Z obj = scopedOperation.apply(arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            Z obj = scopedOperation.apply(arena);\n@@ -112,1 +110,1 @@\n-        ScopedOperation.ofScope(session -> MemorySegment.allocateNative(100, session), \"MemorySession::allocate\");;\n+        ScopedOperation.ofScope(session -> session.allocate(100, 1), \"MemorySession::allocate\");\n@@ -126,18 +124,18 @@\n-        ScopedOperation.ofAllocator(a -> a.allocate(1), \"NativeAllocator::allocate\/size\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(1, 1), \"NativeAllocator::allocate\/size\/align\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+        ScopedOperation.ofScope(a -> a.allocate(1), \"Arena::allocate\/size\");\n+        ScopedOperation.ofScope(a -> a.allocate(1, 1), \"Arena::allocate\/size\/align\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE), \"Arena::allocate\/layout\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, 1L), \"Arena::allocateArray\/size\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"Arena::allocateArray\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateArray\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateArray\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateArray\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateArray\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateArray\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateArray\/double\");\n@@ -151,1 +149,1 @@\n-    static class ScopedOperation<X> implements Consumer<X>, Function<SegmentScope, X> {\n+    static class ScopedOperation<X> implements Consumer<X>, Function<Arena, X> {\n@@ -153,1 +151,1 @@\n-        final Function<SegmentScope, X> factory;\n+        final Function<Arena, X> factory;\n@@ -157,1 +155,1 @@\n-        private ScopedOperation(Function<SegmentScope, X> factory, Consumer<X> operation, String name) {\n+        private ScopedOperation(Function<Arena, X> factory, Consumer<X> operation, String name) {\n@@ -169,1 +167,1 @@\n-        public X apply(SegmentScope session) {\n+        public X apply(Arena session) {\n@@ -173,1 +171,1 @@\n-        static <Z> void of(Function<SegmentScope, Z> factory, Consumer<Z> consumer, String name) {\n+        static <Z> void of(Function<Arena, Z> factory, Consumer<Z> consumer, String name) {\n@@ -177,1 +175,1 @@\n-        static void ofScope(Consumer<SegmentScope> scopeConsumer, String name) {\n+        static void ofScope(Consumer<Arena> scopeConsumer, String name) {\n@@ -190,9 +188,0 @@\n-        static void ofAllocator(Consumer<SegmentAllocator> allocatorConsumer, String name) {\n-            for (AllocatorFactory allocatorFactory : AllocatorFactory.values()) {\n-                scopedOperations.add(new ScopedOperation<>(\n-                        allocatorFactory.allocatorFactory,\n-                        allocatorConsumer,\n-                        allocatorFactory.name() + \"\/\" + name));\n-            }\n-        }\n-\n@@ -201,1 +190,1 @@\n-            NATIVE(session -> MemorySegment.allocateNative(10, session)),\n+            NATIVE(session -> session.allocate(10, 1)),\n@@ -221,1 +210,1 @@\n-            final Function<SegmentScope, MemorySegment> segmentFactory;\n+            final Function<Arena, MemorySegment> segmentFactory;\n@@ -223,1 +212,1 @@\n-            SegmentFactory(Function<SegmentScope, MemorySegment> segmentFactory) {\n+            SegmentFactory(Function<Arena, MemorySegment> segmentFactory) {\n@@ -227,10 +216,0 @@\n-\n-        enum AllocatorFactory {\n-            NATIVE_ALLOCATOR(SegmentAllocator::nativeAllocator);\n-\n-            final Function<SegmentScope, SegmentAllocator> allocatorFactory;\n-\n-            AllocatorFactory(Function<SegmentScope, SegmentAllocator> allocatorFactory) {\n-                this.allocatorFactory = allocatorFactory;\n-            }\n-        }\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":32,"deletions":53,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -72,2 +72,2 @@\n-                    Arena.openConfined(),\n-                    Arena.openShared()\n+                    Arena.ofConfined(),\n+                    Arena.ofShared()\n@@ -106,1 +106,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -120,1 +120,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -154,1 +154,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -191,1 +191,1 @@\n-                return MemorySegment.allocateNative(byteSize, byteAlignment, SegmentScope.auto());\n+                return Arena.ofAuto().allocate(byteSize, byteAlignment);\n@@ -209,2 +209,2 @@\n-                Arena.openConfined(),\n-                Arena.openShared()\n+                Arena.ofConfined(),\n+                Arena.ofShared()\n@@ -351,2 +351,3 @@\n-        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.scope()))),\n-        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.scope()));\n+        SLICING(true, (size, arena) -> {\n+            return SegmentAllocator.slicingAllocator(arena.allocate(size, 1));\n+        });\n@@ -484,2 +485,1 @@\n-                { SegmentAllocator.nativeAllocator(SegmentScope.global()) },\n-                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, SegmentScope.global())) },\n+                { SegmentAllocator.prefixAllocator(Arena.global().allocate(10, 1)) },\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -147,1 +147,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n+            NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -35,1 +36,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -84,1 +84,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n+            NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -65,1 +65,1 @@\n-                () -> MemorySegment.allocateNative(16, SegmentScope.auto()),\n+                () -> Arena.ofAuto().allocate(16, 1),\n@@ -68,1 +68,1 @@\n-                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, SegmentScope.auto());\n+                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, Arena.ofAuto());\n@@ -135,1 +135,1 @@\n-        NATIVE(() -> MemorySegment.allocateNative(16, SegmentScope.auto())),\n+        NATIVE(() -> Arena.ofAuto().allocate(16, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,5 +31,2 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n+\n@@ -53,1 +50,1 @@\n-        MemorySegment.allocateNative(size, align, SegmentScope.auto());\n+        Arena.ofAuto().allocate(size, align);\n@@ -58,3 +55,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            SegmentScope session = arena.scope();\n-            var segment = MemorySegment.allocateNative(0, session);\n+        try (Arena arena = Arena.ofConfined()) {\n+            Arena session = arena;\n+            var segment = session.allocate(0, 1);\n@@ -63,1 +60,1 @@\n-            segment = MemorySegment.allocateNative(seq, session);\n+            segment = session.allocate(seq);\n@@ -66,1 +63,1 @@\n-            segment = MemorySegment.allocateNative(0, 4, session);\n+            segment = session.allocate(0, 4);\n@@ -78,1 +75,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE, SegmentScope.auto());\n+        Arena.ofAuto().allocate(Long.MAX_VALUE, 1);\n@@ -83,1 +80,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, SegmentScope.auto()); \/\/ 2M\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(1024L * 1024 * 8 * 2, 1); \/\/ 2M\n@@ -89,2 +87,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(1000, 1);\n@@ -100,2 +98,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(10, 1);\n@@ -118,0 +116,10 @@\n+    @Test(dataProvider = \"segmentFactories\")\n+    public void testDerivedScopes(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment segment = segmentSupplier.get();\n+        assertEquals(segment.scope(), segment.scope());\n+        assertEquals(segment.asSlice(0).scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().scope(), segment.scope());\n+        MemorySegment another = segmentSupplier.get();\n+        assertNotEquals(segment.scope(), another.scope());\n+    }\n+\n@@ -120,2 +128,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            Arena scope1 = arena;\n+            MemorySegment segment = scope1.allocate(100, 1);\n@@ -126,2 +135,2 @@\n-            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()));\n-            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.scope());\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, Arena.global()));\n+            MemorySegment segment2 = arena.allocate(100, 1);\n@@ -145,2 +154,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(100, 1);\n@@ -150,1 +159,1 @@\n-            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()).hashCode());\n+            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, Arena.global()).hashCode());\n@@ -165,1 +174,2 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment memorySegment = scope.allocate(10, 1);\n@@ -172,1 +182,2 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10L, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment memorySegment = scope.allocate(10L, 1);\n@@ -179,1 +190,1 @@\n-            var segment = MemorySegment.allocateNative(10, SegmentScope.global());\n+            var segment = Arena.global().allocate(10, 1);\n@@ -197,4 +208,4 @@\n-                { SegmentScope.auto(), false },\n-                { SegmentScope.global(), false },\n-                { Arena.openConfined().scope(), true },\n-                { Arena.openShared().scope(), false }\n+                { Arena.ofAuto(), false },\n+                { Arena.global(), false },\n+                { Arena.ofConfined(), true },\n+                { Arena.ofShared(), false }\n@@ -205,3 +216,1 @@\n-    public void testIsAccessibleBy(SegmentScope scope, boolean isConfined) {\n-        assertTrue(scope.isAccessibleBy(Thread.currentThread()));\n-        assertTrue(scope.isAccessibleBy(new Thread()) != isConfined);\n+    public void testIsAccessibleBy(Arena scope, boolean isConfined) {\n@@ -209,2 +218,2 @@\n-        assertTrue(segment.scope().isAccessibleBy(Thread.currentThread()));\n-        assertTrue(segment.scope().isAccessibleBy(new Thread()) != isConfined);\n+        assertTrue(segment.isAccessibleBy(Thread.currentThread()));\n+        assertTrue(segment.isAccessibleBy(new Thread()) != isConfined);\n@@ -223,6 +232,6 @@\n-                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto())\n+                () -> Arena.ofAuto().allocate(4L, 1),\n+                () -> Arena.ofAuto().allocate(4L, 8),\n+                () -> Arena.ofAuto().allocate(JAVA_INT),\n+                () -> Arena.ofAuto().allocate(4L, 1),\n+                () -> Arena.ofAuto().allocate(4L, 8),\n+                () -> Arena.ofAuto().allocate(JAVA_INT)\n@@ -265,0 +274,30 @@\n+    @Test\n+    public void testScopeConfinedArena() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(100);\n+            assertEquals(segment.scope(), arena.scope());\n+        }\n+    }\n+\n+    @Test\n+    public void testScopeSharedArena() {\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(100);\n+            assertEquals(segment.scope(), arena.scope());\n+        }\n+    }\n+\n+    @Test\n+    public void testScopeAutoArena() {\n+        Arena arena = Arena.ofAuto();\n+        MemorySegment segment = arena.allocate(100);\n+        assertEquals(segment.scope(), arena.scope());\n+    }\n+\n+    @Test\n+    public void testScopeGlobalArena() {\n+        Arena arena = Arena.global();\n+        MemorySegment segment = arena.allocate(100);\n+        assertEquals(segment.scope(), arena.scope());\n+    }\n+\n@@ -286,1 +325,1 @@\n-        if (!segment.scope().isAccessibleBy(Thread.currentThread())) {\n+        if (!segment.isAccessibleBy(Thread.currentThread())) {\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":82,"deletions":43,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment s = MemorySegment.allocateNative(layout, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment s = arena.allocate(layout);;\n@@ -97,2 +97,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment s = arena.allocate(4, 1);;\n@@ -102,1 +102,1 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.scope());\n+            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena);\n@@ -124,2 +124,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemoryLayout layout = MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT);\n+            MemorySegment s1 = arena.allocate(layout);;\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -52,2 +51,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(LAYOUT);;\n@@ -67,2 +66,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(LAYOUT);;\n@@ -128,1 +127,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -187,1 +186,1 @@\n-        NATIVE(MemorySegment.allocateNative(100, SegmentScope.auto()), 8),\n+        NATIVE(Arena.ofAuto().allocate(100), 8),\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,5 +30,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.*;\n@@ -45,2 +41,0 @@\n-import java.lang.foreign.ValueLayout;\n-\n@@ -62,2 +56,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(layout);;\n@@ -89,1 +83,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -104,1 +99,2 @@\n-        MemorySegment.allocateNative(2, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(2, 1)\n@@ -110,1 +106,2 @@\n-        MemorySegment.allocateNative(2, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(2, 1)\n@@ -116,1 +113,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -122,1 +120,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -128,1 +127,2 @@\n-        MemorySegment.allocateNative(12, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(12, 1)\n@@ -134,1 +134,2 @@\n-        MemorySegment.allocateNative(12, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(12, 1)\n@@ -140,1 +141,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -146,1 +148,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -152,1 +155,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(8, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(8, 1);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n@@ -64,2 +64,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n@@ -72,2 +72,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n@@ -80,2 +80,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,5 +36,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -44,1 +40,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -65,1 +60,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -68,1 +63,1 @@\n-            Object[] args = makeArgs(SegmentScope.auto(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(Arena.ofAuto(), ret, paramTypes, fields, returnChecks, argChecks);\n@@ -75,1 +70,1 @@\n-            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena.scope());\n+            MemorySegment callback = ABI.upcallStub(mh, callbackDesc, arena);\n@@ -81,1 +76,1 @@\n-                    ? invoker.invoke(arena.scope(), callback)\n+                    ? invoker.invoke(arena, callback)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,6 +25,2 @@\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n+import java.lang.foreign.Arena;\n@@ -68,1 +64,1 @@\n-        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n+        DUMMY_STUB = ABI.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), Arena.ofAuto());\n@@ -84,1 +80,1 @@\n-    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+    static Object[] makeArgs(Arena session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n@@ -88,1 +84,1 @@\n-    static Object[] makeArgs(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+    static Object[] makeArgs(Arena session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n@@ -101,1 +97,1 @@\n-    static MemorySegment makeCallback(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n+    static MemorySegment makeCallback(Arena session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -155,1 +151,3 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n+                long byteSize = ms.byteSize();\n+                Arena scope = Arena.ofAuto();\n+                MemorySegment copy = scope.allocate(byteSize, 1);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallBase.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena.scope());\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena);\n@@ -77,2 +77,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment stub = Linker.nativeLinker().upcallStub(INT_TARGET, FunctionDescriptor.of(C_INT, C_INT), arena.scope());\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(INT_TARGET, FunctionDescriptor.of(C_INT, C_INT), arena);\n@@ -102,1 +102,1 @@\n-            try (Arena arena = Arena.openConfined()) {\n+            try (Arena arena = Arena.ofConfined()) {\n@@ -104,1 +104,1 @@\n-                        arena.scope(), Linker.Option.uncaughtExceptionHandler(UNCAUGHT_EXCEPTION_HANDLER));\n+                        arena, Linker.Option.uncaughtExceptionHandler(UNCAUGHT_EXCEPTION_HANDLER));\n@@ -113,2 +113,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena.scope());\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -46,1 +41,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -90,1 +84,3 @@\n-                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), SegmentScope.auto());\n+                long byteSize = ms.byteSize();\n+                Arena scope = Arena.ofAuto();\n+                MemorySegment copy = scope.allocate(byteSize, 1);\n@@ -105,2 +101,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor, arena);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -58,1 +58,1 @@\n-            Object[] args = makeArgs(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgs(arena, ret, paramTypes, fields, returnChecks, argChecks);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -58,1 +57,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -60,1 +59,1 @@\n-            Object[] args = makeArgsStack(arena.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] args = makeArgsStack(arena, ret, paramTypes, fields, returnChecks, argChecks);\n@@ -74,1 +73,1 @@\n-    static Object[] makeArgsStack(SegmentScope session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+    static Object[] makeArgsStack(Arena session, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,5 +40,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -92,3 +88,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.scope());\n-            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena);\n+            MemorySegment argSegment = arena.allocate(S_PDI_LAYOUT);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -80,3 +80,5 @@\n-            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.scope());\n-            MemorySegment callInfo = MemorySegment.allocateNative(CallInfo.LAYOUT, arena.scope());;\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), arena.scope());;\n+            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena);\n+            Arena scope1 = arena;\n+            MemorySegment callInfo = scope1.allocate(CallInfo.LAYOUT);;\n+            MemoryLayout layout = MemoryLayout.sequenceLayout(args.size(), C_INT);\n+            MemorySegment argIDs = arena.allocate(layout);;\n@@ -185,2 +187,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -69,1 +68,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1L, 2, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(1L, 2);\n@@ -105,2 +105,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(inner_size * outer_size * 8, 4);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -132,0 +132,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -71,2 +70,2 @@\n-    static ByteBuffer segmentBufferOfSize(SegmentScope session, int size) {\n-        var segment = MemorySegment.allocateNative(size, 1, session);\n+    static ByteBuffer segmentBufferOfSize(Arena session, int size) {\n+        var segment = session.allocate(size, 1);\n@@ -79,1 +78,1 @@\n-    static ByteBuffer[] segmentBuffersOfSize(int len, SegmentScope session, int size) {\n+    static ByteBuffer[] segmentBuffersOfSize(int len, Arena session, int size) {\n@@ -91,1 +90,1 @@\n-    static ByteBuffer[] mixedBuffersOfSize(int len, SegmentScope session, int size) {\n+    static ByteBuffer[] mixedBuffersOfSize(int len, Arena session, int size) {\n@@ -156,1 +155,1 @@\n-                new ArenaSupplier(Arena::openConfined, \"confined arena\");\n+                new ArenaSupplier(Arena::ofConfined, \"confined arena\");\n@@ -158,1 +157,1 @@\n-                new ArenaSupplier(Arena::openShared, \"shared arena\");\n+                new ArenaSupplier(Arena::ofShared, \"shared arena\");\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -78,1 +78,2 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope = drop;\n+            var segment = scope.allocate(10, 1);\n@@ -111,2 +112,2 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 64);\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 32);\n+            ByteBuffer bb = segmentBufferOfSize(drop, 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop, 32);\n@@ -163,2 +164,4 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope1 = drop;\n+            MemorySegment segment1 = scope1.allocate(10, 1);\n+            Arena scope = drop;\n+            MemorySegment segment2 = scope.allocate(10, 1);\n@@ -187,2 +190,2 @@\n-                var writeBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n-                var readBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n+                var writeBuffers = mixedBuffersOfSize(16, drop, 32);\n+                var readBuffers = mixedBuffersOfSize(16, drop, 32);\n@@ -210,1 +213,2 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope = drop;\n+            var segment = scope.allocate(10, 1);\n@@ -255,1 +259,1 @@\n-            var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n+            var bba = segmentBuffersOfSize(32, drop, 128);\n@@ -264,1 +268,1 @@\n-                                var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n+                                var bba = segmentBuffersOfSize(32, drop, 128);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 16);\n+            ByteBuffer bb = segmentBufferOfSize(drop, 16);\n@@ -87,1 +87,1 @@\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 16);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop, 16);\n@@ -105,2 +105,4 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope1 = drop;\n+            MemorySegment segment1 = scope1.allocate(10, 1);\n+            Arena scope = drop;\n+            MemorySegment segment2 = scope.allocate(10, 1);\n@@ -144,1 +146,2 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope = drop;\n+            var segment = scope.allocate(10, 1);\n@@ -174,2 +177,2 @@\n-            var writeBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n-            var readBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n+            var writeBuffers = mixedBuffersOfSize(32, drop, 64);\n+            var readBuffers = mixedBuffersOfSize(32, drop, 64);\n@@ -192,1 +195,1 @@\n-            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1, 64), mixedBuffersOfSize(16, drop2, 64))\n@@ -195,1 +198,1 @@\n-            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1, 64), mixedBuffersOfSize(16, drop2, 64))\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.ref java.base\/jdk.internal.foreign\n@@ -32,0 +33,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -52,1 +54,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -54,1 +56,1 @@\n-            arena.scope().whileAlive(() -> {\n+            ((MemorySessionImpl)arena.scope()).whileAlive(() -> {\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -43,1 +43,1 @@\n-        MemorySegment.ofAddress(0, 4000, SegmentScope.global());\n+        MemorySegment.ofAddress(0, 4000, Arena.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -47,2 +47,2 @@\n-                MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class));\n-        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, SegmentScope.global());\n+                MethodType.methodType(MemorySegment.class, long.class, long.class, Arena.class));\n+        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, Arena.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -45,2 +45,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, SegmentScope.class);\n-        method.invoke(null, 0L, 4000L, SegmentScope.global());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, Arena.class);\n+        method.invoke(null, 0L, 4000L, Arena.global());\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -75,1 +75,1 @@\n-        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n+        addDefaultMapping(Arena.class, Arena.ofAuto());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -57,1 +57,1 @@\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class)),\n+                            MethodType.methodType(MemorySegment.class, long.class, long.class, Arena.class)),\n@@ -60,1 +60,1 @@\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class, Runnable.class)),\n+                            MethodType.methodType(MemorySegment.class, long.class, long.class, Arena.class, Runnable.class)),\n@@ -63,1 +63,1 @@\n-                            MethodType.methodType(SymbolLookup.class, String.class, SegmentScope.class)),\n+                            MethodType.methodType(SymbolLookup.class, String.class, Arena.class)),\n@@ -66,1 +66,1 @@\n-                            MethodType.methodType(SymbolLookup.class, Path.class, SegmentScope.class)),\n+                            MethodType.methodType(SymbolLookup.class, Path.class, Arena.class)),\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,5 +39,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -118,1 +114,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -121,1 +117,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.scope());\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena);\n@@ -188,2 +184,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena);\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,2 +117,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        try (Arena arena  = Arena.openConfined()) {\n+        try (Arena arena  = Arena.ofConfined()) {\n@@ -89,1 +89,1 @@\n-        try (Arena arena  = Arena.openConfined()) {\n+        try (Arena arena  = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena);\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.Supplier;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n-public class BulkMismatchAcquire {\n-\n-    public enum SessionKind {\n-        CONFINED(Arena::openConfined),\n-        SHARED(Arena::openShared);\n-\n-        final Supplier<Arena> arenaFactory;\n-\n-        SessionKind(Supplier<Arena> arenaFactory) {\n-            this.arenaFactory = arenaFactory;\n-        }\n-\n-        Arena makeArena() {\n-            return arenaFactory.get();\n-        }\n-    }\n-\n-    @Param({\"CONFINED\", \"SHARED\"})\n-    public BulkMismatchAcquire.SessionKind sessionKind;\n-\n-    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n-    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n-\n-    Arena arena;\n-    MemorySegment mismatchSegmentLarge1;\n-    MemorySegment mismatchSegmentLarge2;\n-    ByteBuffer mismatchBufferLarge1;\n-    ByteBuffer mismatchBufferLarge2;\n-    MemorySegment mismatchSegmentSmall1;\n-    MemorySegment mismatchSegmentSmall2;\n-    ByteBuffer mismatchBufferSmall1;\n-    ByteBuffer mismatchBufferSmall2;\n-\n-    @Setup\n-    public void setup() {\n-        arena = sessionKind.makeArena();\n-        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL);\n-        mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL);\n-        mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-        mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-\n-        \/\/ mismatch at first byte\n-        mismatchSegmentSmall1 = arena.allocate(7);\n-        mismatchSegmentSmall2 = arena.allocate(7);\n-        mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-        mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-        {\n-            mismatchSegmentSmall1.fill((byte) 0xFF);\n-            mismatchBufferSmall1.put((byte) 0xFF).clear();\n-            \/\/ verify expected mismatch indices\n-            long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-            if (si != -1)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-            int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-            if (bi != -1)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-            si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-            if (si != 0)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-            bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-            if (bi != 0)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-        }\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_large_segment() {\n-        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_large_segment_acquire() {\n-        long[] arr = new long[1];\n-        mismatchSegmentLarge1.scope().whileAlive(() -> {\n-            arr[0] = mismatchSegmentLarge1.mismatch(mismatchSegmentSmall2);\n-        });\n-        return arr[0];\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_large_bytebuffer() {\n-        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_small_segment() {\n-        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_small_segment_acquire() {\n-        long[] arr = new long[1];\n-        mismatchSegmentLarge1.scope().whileAlive(() -> {\n-            arr[0] = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-        });\n-        return arr[0];\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_small_bytebuffer() {\n-        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -46,1 +46,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -64,1 +63,1 @@\n-    final Arena arena = Arena.openShared();\n+    final Arena arena = Arena.ofShared();\n@@ -67,1 +66,2 @@\n-    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+    final MemorySegment segment = arena.allocate(ALLOC_SIZE, 1);\n+\n@@ -76,2 +76,13 @@\n-    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());\n-    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());;\n+    final MemorySegment mismatchSegmentLarge1;\n+\n+    {\n+        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL, 1);\n+    }\n+\n+    final MemorySegment mismatchSegmentLarge2;\n+\n+    {\n+        mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL, 1);\n+    }\n+\n+    ;\n@@ -82,2 +93,14 @@\n-    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.scope());;\n-    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.scope());;\n+    final MemorySegment mismatchSegmentSmall1;\n+\n+    {\n+        mismatchSegmentSmall1 = arena.allocate(7, 1);\n+    }\n+\n+    ;\n+    final MemorySegment mismatchSegmentSmall2;\n+\n+    {\n+        mismatchSegmentSmall2 = arena.allocate(7, 1);\n+    }\n+\n+    ;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,9 +25,2 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.*;\n+\n@@ -88,2 +81,8 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().scope());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().scope());\n+    static final MemorySegment sharedPoint;\n+\n+    static {\n+        Arena scope = Arena.ofShared();\n+        sharedPoint = scope.allocate(POINT_LAYOUT);\n+    }\n+\n+    static final MemorySegment confinedPoint;\n@@ -91,1 +90,11 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto());\n+    static {\n+        Arena scope = Arena.ofConfined();\n+        confinedPoint = scope.allocate(POINT_LAYOUT);\n+    }\n+\n+    static final MemorySegment point;\n+\n+    static {\n+        Arena scope = Arena.ofAuto();\n+        point = scope.allocate(POINT_LAYOUT);\n+    }\n@@ -93,1 +102,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto()));\n+    static final SegmentAllocator recycling_allocator;\n@@ -96,0 +105,2 @@\n+        Arena scope = Arena.ofAuto();\n+        recycling_allocator = SegmentAllocator.prefixAllocator(scope.allocate(POINT_LAYOUT));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,1 +39,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -67,1 +67,1 @@\n-        return LINKER.upcallStub(BLANK, BLANK_DESC, SegmentScope.auto());\n+        return LINKER.upcallStub(BLANK, BLANK_DESC, Arena.ofAuto());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -72,1 +72,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, SegmentScope.auto());\n+    static final MemorySegment segment;\n@@ -75,0 +75,2 @@\n+        Arena scope = Arena.ofAuto();\n+        segment = scope.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,5 +25,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -63,2 +59,2 @@\n-    final Arena arena = Arena.openConfined();\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.scope()));\n+    final Arena arena = Arena.ofConfined();\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(arena.allocate(ALLOC_LAYOUT));\n@@ -82,1 +78,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -92,1 +88,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -138,1 +134,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-        arena = Arena.openConfined();\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segment = arena.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,3 +75,3 @@\n-        arena = Arena.openConfined();\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segmentIn = arena.allocate(ALLOC_SIZE, 1);\n+        segmentOut = arena.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -40,1 +41,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -79,1 +79,2 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, SegmentScope.auto());\n+            Arena scope = Arena.ofAuto();\n+            MemorySegment s = scope.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -98,2 +98,2 @@\n-        arena = Arena.openConfined();\n-        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-        arena = Arena.openConfined();\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segment = arena.allocate(ALLOC_SIZE, CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,1 +39,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -73,1 +73,1 @@\n-            res += MemorySegment.ofAddress(i, i % 100, SegmentScope.global()).address();\n+            res += MemorySegment.ofAddress(i, i % 100, Arena.global()).address();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,4 +71,6 @@\n-        confinedArena = Arena.openConfined();\n-        sharedArena = Arena.openShared();\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.scope());\n-        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.scope());\n+        confinedArena = Arena.ofConfined();\n+        sharedArena = Arena.ofShared();\n+        Arena scope1 = confinedArena;\n+        nativeSegment = scope1.allocate(ALLOC_SIZE, 4);\n+        Arena scope = sharedArena;\n+        nativeSharedSegment = scope.allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-        arena = Arena.openConfined();\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        nativeSegment = arena.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    Arena arena = Arena.openConfined();\n+    Arena arena = Arena.ofConfined();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentVsBits.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Arena;\n@@ -40,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -107,1 +106,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -114,1 +113,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -121,1 +120,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n+        return Arena.ofAuto().allocate(ALLOC_SIZE, 4);\n@@ -127,1 +126,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n+        return Arena.ofAuto().allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -43,1 +40,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -82,2 +78,2 @@\n-        arena = Arena.openShared();\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n+        arena = Arena.ofShared();\n+        segment = arena.allocate(ALLOC_SIZE, CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -43,1 +40,0 @@\n-import java.lang.foreign.SymbolLookup;\n@@ -55,2 +51,2 @@\n-    Arena arena = Arena.openConfined();\n-    MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment segment = arena.allocate(100, 1);\n@@ -90,1 +86,1 @@\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.scope());\n+        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,4 +25,1 @@\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -39,2 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.Arena;\n@@ -68,1 +64,2 @@\n-        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), SegmentScope.global());\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT);\n+        INPUT_SEGMENT = Arena.global().allocate(layout);\n@@ -86,1 +83,1 @@\n-                    SegmentScope.global()\n+                    Arena.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -47,0 +42,1 @@\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -60,1 +56,1 @@\n-    Arena arena = Arena.openConfined();\n+    Arena arena = Arena.ofConfined();\n@@ -63,1 +59,2 @@\n-    SegmentAllocator arenaAllocator = new RingAllocator(arena.scope());\n+    SegmentAllocator arenaAllocator = new RingAllocator(arena);\n+    SlicingPool pool = new SlicingPool();\n@@ -84,1 +81,1 @@\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.scope()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(arena.allocate(size + 1, 1));\n@@ -99,1 +96,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -110,0 +107,8 @@\n+    @Benchmark\n+    public int panama_strlen_pool() throws Throwable {\n+        Arena arena = pool.acquire();\n+        int l = (int) STRLEN.invokeExact(arena.allocateUtf8String(str));\n+        arena.close();\n+        return l;\n+    }\n+\n@@ -151,2 +156,2 @@\n-        public RingAllocator(SegmentScope session) {\n-            this.segment = MemorySegment.allocateNative(1024, session);\n+        public RingAllocator(Arena session) {\n+            this.segment = session.allocate(1024, 1);\n@@ -172,0 +177,34 @@\n+\n+    static class SlicingPool {\n+        final MemorySegment pool = Arena.ofAuto().allocate(1024);\n+        boolean isAcquired = false;\n+\n+        public Arena acquire() {\n+            if (isAcquired) {\n+                throw new IllegalStateException(\"An allocator is already in use\");\n+            }\n+            isAcquired = true;\n+            return new SlicingPoolAllocator();\n+        }\n+\n+        class SlicingPoolAllocator implements Arena {\n+\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicing = SegmentAllocator.slicingAllocator(pool);\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                MemorySegment segment = slicing.allocate(byteSize, byteAlignment);\n+                return MemorySegment.ofAddress(segment.address(), byteSize, arena);\n+            }\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                isAcquired = false;\n+                arena.close();\n+            }\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -71,1 +71,2 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        srcSegmentImplicit = scope.allocate(size, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -70,2 +70,2 @@\n-            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, SegmentScope.global());\n-            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, SegmentScope.global());\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, Arena.global());\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, Arena.global());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.*;\n@@ -38,2 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.Arena;\n@@ -134,1 +131,1 @@\n-            fd, SegmentScope.global()\n+            fd, Arena.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-        arena = Arena.openConfined();\n-        data = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n+        arena = Arena.ofConfined();\n+        data = arena.allocate(JAVA_INT);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    final Arena arena = Arena.openConfined();\n+    final Arena arena = Arena.ofConfined();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,5 +25,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -33,1 +29,0 @@\n-import java.lang.foreign.SymbolLookup;\n@@ -69,2 +64,2 @@\n-        this.arena = Arena.openConfined();\n-        this.segment = MemorySegment.allocateNative(LAYOUT, arena.scope());\n+        this.arena = Arena.ofConfined();\n+        this.segment = arena.allocate(LAYOUT);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -72,2 +72,4 @@\n-    nativeIn = MemorySegment.allocateNative(size, SegmentScope.auto());\n-    nativeOut = MemorySegment.allocateNative(size, SegmentScope.auto());\n+      Arena scope1 = Arena.ofAuto();\n+      nativeIn = scope1.allocate(size, 1);\n+      Arena scope = Arena.ofAuto();\n+      nativeOut = scope.allocate(size, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -88,2 +87,6 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+      long byteAlignment1 = SPECIES.vectorByteSize();\n+      Arena scope1 = Arena.ofAuto();\n+      srcSegment = scope1.allocate(size, byteAlignment1);\n+      long byteAlignment = SPECIES.vectorByteSize();\n+      Arena scope = Arena.ofAuto();\n+      dstSegment = scope.allocate(size, byteAlignment);\n@@ -166,3 +169,3 @@\n-    try (final var arena = Arena.openConfined()) {\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n+    try (final var arena = Arena.ofConfined()) {\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -93,2 +92,6 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+      long byteAlignment1 = SPECIES.vectorByteSize();\n+      Arena scope1 = Arena.ofAuto();\n+      srcSegment = scope1.allocate(size, byteAlignment1);\n+      long byteAlignment = SPECIES.vectorByteSize();\n+      Arena scope = Arena.ofAuto();\n+      dstSegment = scope.allocate(size, byteAlignment);\n@@ -164,3 +167,3 @@\n-    try (final var arena = Arena.openConfined()) {\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n+    try (final var arena = Arena.ofConfined()) {\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"}]}