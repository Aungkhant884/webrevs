{"files":[{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_foreign_abi_VMFunctions_initVMFunctions(JNIEnv *env,\n+                                        jclass cls,\n+                                        jlong address)\n+{\n+   size_t* addresses = (size_t*)(void*)address;\n+   \/\/ The order in which the function pointers are stored has to match the order of constants\n+   \/\/ in the VMFunctions.FunctionName enum.\n+   addresses[0] = (size_t)&malloc;\n+   addresses[1] = (size_t)&free;\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/VMFunctions.c","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -53,1 +53,0 @@\n-import java.nio.file.Path;\n@@ -415,22 +414,0 @@\n-    \/\/ lazy init MH_ALLOC and MH_FREE handles\n-    private static class AllocHolder {\n-\n-        private static final CLinker linker = getSystemLinker();\n-\n-        static {\n-             \/\/ FIXME: This should go away. This is temporary hack to get testing on Windows going.\n-             \/\/ After fix for 8266627, this whole section will be removed.\n-             if (linker instanceof Windowsx64Linker) {\n-                 System.load(Path.of(System.getenv(\"SystemRoot\"), \"System32\", \"msvcrt.dll\").toAbsolutePath().toString());\n-             }\n-        }\n-\n-        static final MethodHandle MH_MALLOC = linker.downcallHandle(CLinker.findNative(\"malloc\").get(),\n-                        MethodType.methodType(MemoryAddress.class, long.class),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n-\n-        static final MethodHandle MH_FREE = linker.downcallHandle(CLinker.findNative(\"free\").get(),\n-                        MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER));\n-    }\n-\n@@ -439,1 +416,1 @@\n-            return (MemoryAddress) AllocHolder.MH_MALLOC.invokeExact(size);\n+            return (MemoryAddress) VMFunctions.MH_MALLOC.invokeExact(size);\n@@ -447,1 +424,1 @@\n-            AllocHolder.MH_FREE.invokeExact(addr);\n+            VMFunctions.MH_FREE.invokeExact(addr);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign.abi;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+\/**\n+ * This class is used to setup downcall method handles which refer to commonly used functions within the JVM.\n+ * A memory segment is allocated, with enough room to contain as many pointers as the number of constants\n+ * defined in {@link FunctionName}. This segment is then filled by the JVM with function pointers which target\n+ * the desired functions.\n+ *\/\n+class VMFunctions {\n+\n+    \/**\n+     * The order of these constants has to match that in which the VM will fill the {@code vmFunctions} pointer array.\n+     *\/\n+    enum FunctionName {\n+        MALLOC,\n+        FREE;\n+\n+        MemoryAddress get() {\n+            return MemoryAccess.getAddressAtIndex(vmFunctions, ordinal());\n+        }\n+    }\n+\n+    private static final CLinker linker = SharedUtils.getSystemLinker();\n+    private static final MemorySegment vmFunctions;\n+\n+    static {\n+        vmFunctions = MemorySegment.allocateNative(\n+                MemoryLayouts.ADDRESS.byteSize() * FunctionName.values().length,\n+                ResourceScope.newImplicitScope());\n+        initVMFunctions(vmFunctions.address().toRawLongValue());\n+    }\n+\n+    static final MethodHandle MH_MALLOC = linker.downcallHandle(FunctionName.MALLOC.get(),\n+            MethodType.methodType(MemoryAddress.class, long.class),\n+            FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+\n+    static final MethodHandle MH_FREE = linker.downcallHandle(FunctionName.FREE.get(),\n+            MethodType.methodType(void.class, MemoryAddress.class),\n+            FunctionDescriptor.ofVoid(C_POINTER));\n+\n+    static native void initVMFunctions(long address);\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/VMFunctions.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}