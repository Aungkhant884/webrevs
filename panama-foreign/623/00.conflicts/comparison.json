{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"prims\/foreign_globals.inline.hpp\"\n@@ -41,314 +42,0 @@\n-\/\/ 1. Create buffer according to layout\n-\/\/ 2. Load registers & stack args into buffer\n-\/\/ 3. Call upcall helper with upcall handler instance & buffer pointer (C++ ABI)\n-\/\/ 4. Load return value from buffer into foreign ABI registers\n-\/\/ 5. Return\n-address ProgrammableUpcallHandler::generate_upcall_stub(jobject rec, jobject jabi, jobject jlayout) {\n-  ResourceMark rm;\n-  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n-  const BufferLayout layout = ForeignGlobals::parse_buffer_layout(jlayout);\n-\n-  CodeBuffer buffer(\"upcall_stub\", 1024, upcall_stub_size);\n-\n-  MacroAssembler* _masm = new MacroAssembler(&buffer);\n-  int stack_alignment_C = 16; \/\/ bytes\n-  int register_size = sizeof(uintptr_t);\n-  int buffer_alignment = xmm_reg_size;\n-\n-  \/\/ stub code\n-  __ enter();\n-\n-  \/\/ save pointer to JNI receiver handle into constant segment\n-  Address rec_adr = __ as_Address(InternalAddress(__ address_constant((address)rec)));\n-\n-  __ subptr(rsp, (int) align_up(layout.buffer_size, buffer_alignment));\n-\n-  Register used[] = { c_rarg0, c_rarg1, rax, rbx, rdi, rsi, r12, r13, r14, r15 };\n-  GrowableArray<Register> preserved;\n-  \/\/ TODO need to preserve anything killed by the upcall that is non-volatile, needs XMM regs as well, probably\n-  for (size_t i = 0; i < sizeof(used)\/sizeof(Register); i++) {\n-    Register reg = used[i];\n-    if (!abi.is_volatile_reg(reg)) {\n-      preserved.push(reg);\n-    }\n-  }\n-\n-  int preserved_size = align_up(preserved.length() * register_size, stack_alignment_C); \/\/ includes register alignment\n-  int buffer_offset = preserved_size; \/\/ offset from rsp\n-\n-  __ subptr(rsp, preserved_size);\n-  for (int i = 0; i < preserved.length(); i++) {\n-    __ movptr(Address(rsp, i * register_size), preserved.at(i));\n-  }\n-\n-  for (int i = 0; i < abi._integer_argument_registers.length(); i++) {\n-    size_t offs = buffer_offset + layout.arguments_integer + i * sizeof(uintptr_t);\n-    __ movptr(Address(rsp, (int)offs), abi._integer_argument_registers.at(i));\n-  }\n-\n-  for (int i = 0; i < abi._vector_argument_registers.length(); i++) {\n-    XMMRegister reg = abi._vector_argument_registers.at(i);\n-    size_t offs = buffer_offset + layout.arguments_vector + i * xmm_reg_size;\n-    __ movdqu(Address(rsp, (int)offs), reg);\n-  }\n-\n-  \/\/ Capture prev stack pointer (stack arguments base)\n-#ifndef _WIN64\n-  __ lea(rax, Address(rbp, 16)); \/\/ skip frame+return address\n-#else\n-  __ lea(rax, Address(rbp, 16 + 32)); \/\/ also skip shadow space\n-#endif\n-  __ movptr(Address(rsp, buffer_offset + (int) layout.stack_args), rax);\n-#ifndef PRODUCT\n-  __ movptr(Address(rsp, buffer_offset + (int) layout.stack_args_bytes), -1); \/\/ unknown\n-#endif\n-\n-  \/\/ Call upcall helper\n-\n-  __ movptr(c_rarg0, rec_adr);\n-  __ lea(c_rarg1, Address(rsp, buffer_offset));\n-\n-#ifdef _WIN64\n-  __ block_comment(\"allocate shadow space for argument register spill\");\n-  __ subptr(rsp, 32);\n-#endif\n-\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::attach_thread_and_do_upcall)));\n-\n-#ifdef _WIN64\n-  __ block_comment(\"pop shadow space\");\n-  __ addptr(rsp, 32);\n-#endif\n-\n-  for (int i = 0; i < abi._integer_return_registers.length(); i++) {\n-    size_t offs = buffer_offset + layout.returns_integer + i * sizeof(uintptr_t);\n-    __ movptr(abi._integer_return_registers.at(i), Address(rsp, (int)offs));\n-  }\n-\n-  for (int i = 0; i < abi._vector_return_registers.length(); i++) {\n-    XMMRegister reg = abi._vector_return_registers.at(i);\n-    size_t offs = buffer_offset + layout.returns_vector + i * xmm_reg_size;\n-    __ movdqu(reg, Address(rsp, (int)offs));\n-  }\n-\n-  for (size_t i = abi._X87_return_registers_noof; i > 0 ; i--) {\n-      ssize_t offs = buffer_offset + layout.returns_x87 + (i - 1) * (sizeof(long double));\n-      __ fld_x (Address(rsp, (int)offs));\n-  }\n-\n-  \/\/ Restore preserved registers\n-  for (int i = 0; i < preserved.length(); i++) {\n-    __ movptr(preserved.at(i), Address(rsp, i * register_size));\n-  }\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  _masm->flush();\n-\n-  BufferBlob* blob = BufferBlob::create(\"upcall_stub\", &buffer);\n-\n-  return blob->code_begin();\n-}\n-\n-struct ArgMove {\n-  BasicType bt;\n-  VMRegPair from;\n-  VMRegPair to;\n-\n-  bool is_identity() const {\n-      return from.first() == to.first() && from.second() == to.second();\n-  }\n-};\n-\n-static GrowableArray<ArgMove> compute_argument_shuffle(Method* entry, int& out_arg_size_bytes, const CallRegs& conv, BasicType& ret_type) {\n-  assert(entry->is_static(), \"\");\n-\n-  \/\/ Fill in the signature array, for the calling-convention call.\n-  const int total_out_args = entry->size_of_parameters();\n-  assert(total_out_args > 0, \"receiver arg \");\n-\n-  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n-  VMRegPair* out_regs = NEW_RESOURCE_ARRAY(VMRegPair, total_out_args);\n-\n-  {\n-    int i = 0;\n-    SignatureStream ss(entry->signature());\n-    for (; !ss.at_return_type(); ss.next()) {\n-      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n-      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n-        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n-    }\n-    assert(i == total_out_args, \"\");\n-    ret_type = ss.type();\n-  }\n-\n-  int out_arg_slots = SharedRuntime::java_calling_convention(out_sig_bt, out_regs, total_out_args);\n-\n-  const int total_in_args = total_out_args - 1; \/\/ skip receiver\n-  BasicType* in_sig_bt  = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n-  VMRegPair* in_regs    = NEW_RESOURCE_ARRAY(VMRegPair, total_in_args);\n-\n-  for (int i = 0; i < total_in_args ; i++ ) {\n-    in_sig_bt[i] = out_sig_bt[i+1]; \/\/ skip receiver\n-  }\n-\n-  \/\/ Now figure out where the args must be stored and how much stack space they require.\n-  conv.calling_convention(in_sig_bt, in_regs, total_in_args);\n-\n-  GrowableArray<int> arg_order(2 * total_in_args);\n-\n-  VMRegPair tmp_vmreg;\n-  tmp_vmreg.set2(rbx->as_VMReg());\n-\n-  \/\/ Compute a valid move order, using tmp_vmreg to break any cycles\n-  SharedRuntime::compute_move_order(in_sig_bt,\n-                                    total_in_args, in_regs,\n-                                    total_out_args, out_regs,\n-                                    arg_order,\n-                                    tmp_vmreg);\n-\n-  GrowableArray<ArgMove> arg_order_vmreg(total_in_args); \/\/ conservative\n-\n-#ifdef ASSERT\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n-  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n-    reg_destroyed[r] = false;\n-  }\n-  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n-    freg_destroyed[f] = false;\n-  }\n-#endif \/\/ ASSERT\n-\n-  for (int i = 0; i < arg_order.length(); i += 2) {\n-    int in_arg  = arg_order.at(i);\n-    int out_arg = arg_order.at(i + 1);\n-\n-    assert(in_arg != -1 || out_arg != -1, \"\");\n-    BasicType arg_bt = (in_arg != -1 ? in_sig_bt[in_arg] : out_sig_bt[out_arg]);\n-    switch (arg_bt) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-      case T_FLOAT:\n-        break; \/\/ process\n-\n-      case T_LONG:\n-      case T_DOUBLE:\n-        assert(in_arg  == -1 || (in_arg  + 1 < total_in_args  &&  in_sig_bt[in_arg  + 1] == T_VOID), \"bad arg list: %d\", in_arg);\n-        assert(out_arg == -1 || (out_arg + 1 < total_out_args && out_sig_bt[out_arg + 1] == T_VOID), \"bad arg list: %d\", out_arg);\n-        break; \/\/ process\n-\n-      case T_VOID:\n-        continue; \/\/ skip\n-\n-      default:\n-        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n-    }\n-\n-    ArgMove move;\n-    move.bt   = arg_bt;\n-    move.from = (in_arg != -1 ? in_regs[in_arg] : tmp_vmreg);\n-    move.to   = (out_arg != -1 ? out_regs[out_arg] : tmp_vmreg);\n-\n-    if(move.is_identity()) {\n-      continue; \/\/ useless move\n-    }\n-\n-#ifdef ASSERT\n-    if (in_arg != -1) {\n-      if (in_regs[in_arg].first()->is_Register()) {\n-        assert(!reg_destroyed[in_regs[in_arg].first()->as_Register()->encoding()], \"destroyed reg!\");\n-      } else if (in_regs[in_arg].first()->is_XMMRegister()) {\n-        assert(!freg_destroyed[in_regs[in_arg].first()->as_XMMRegister()->encoding()], \"destroyed reg!\");\n-      }\n-    }\n-    if (out_arg != -1) {\n-      if (out_regs[out_arg].first()->is_Register()) {\n-        reg_destroyed[out_regs[out_arg].first()->as_Register()->encoding()] = true;\n-      } else if (out_regs[out_arg].first()->is_XMMRegister()) {\n-        freg_destroyed[out_regs[out_arg].first()->as_XMMRegister()->encoding()] = true;\n-      }\n-    }\n-#endif \/* ASSERT *\/\n-\n-    arg_order_vmreg.push(move);\n-  }\n-\n-  int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;\n-  out_arg_size_bytes = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n-\n-  return arg_order_vmreg;\n-}\n-\n-static const char* null_safe_string(const char* str) {\n-  return str == nullptr ? \"NULL\" : str;\n-}\n-\n-#ifdef ASSERT\n-static void print_arg_moves(const GrowableArray<ArgMove>& arg_moves, Method* entry) {\n-  LogTarget(Trace, foreign) lt;\n-  if (lt.is_enabled()) {\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    ls.print_cr(\"Argument shuffle for %s {\", entry->name_and_sig_as_C_string());\n-    for (int i = 0; i < arg_moves.length(); i++) {\n-      ArgMove arg_mv = arg_moves.at(i);\n-      BasicType arg_bt     = arg_mv.bt;\n-      VMRegPair from_vmreg = arg_mv.from;\n-      VMRegPair to_vmreg   = arg_mv.to;\n-\n-      ls.print(\"Move a %s from (\", null_safe_string(type2name(arg_bt)));\n-      from_vmreg.first()->print_on(&ls);\n-      ls.print(\",\");\n-      from_vmreg.second()->print_on(&ls);\n-      ls.print(\") to \");\n-      to_vmreg.first()->print_on(&ls);\n-      ls.print(\",\");\n-      to_vmreg.second()->print_on(&ls);\n-      ls.print_cr(\")\");\n-    }\n-    ls.print_cr(\"}\");\n-  }\n-}\n-#endif\n-\n-static void save_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n-  __ block_comment(\"{ save_native_args \");\n-  int store_offset = arg_save_area_offset;\n-  for (int i = 0; i < conv._args_length; i++) {\n-    VMReg reg = conv._arg_regs[i];\n-    if (reg->is_Register()) {\n-      __ movptr(Address(rsp, store_offset), reg->as_Register());\n-      store_offset += 8;\n-    } else if (reg->is_XMMRegister()) {\n-      \/\/ Java API doesn't support vector args\n-      __ movdqu(Address(rsp, store_offset), reg->as_XMMRegister());\n-      store_offset += 16;\n-    }\n-    \/\/ do nothing for stack\n-  }\n-  __ block_comment(\"} save_native_args \");\n-}\n-\n-static void restore_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n-  __ block_comment(\"{ restore_native_args \");\n-  int load_offset = arg_save_area_offset;\n-  for (int i = 0; i < conv._args_length; i++) {\n-    VMReg reg = conv._arg_regs[i];\n-    if (reg->is_Register()) {\n-      __ movptr(reg->as_Register(), Address(rsp, load_offset));\n-      load_offset += 8;\n-    } else if (reg->is_XMMRegister()) {\n-      \/\/ Java API doesn't support vector args\n-      __ movdqu(reg->as_XMMRegister(), Address(rsp, load_offset));\n-      load_offset += 16;\n-    }\n-    \/\/ do nothing for stack\n-  }\n-  __ block_comment(\"} restore_native_args \");\n-}\n-\n@@ -389,69 +76,0 @@\n-static int compute_arg_save_area_size(const CallRegs& conv) {\n-  int result_size = 0;\n-  for (int i = 0; i < conv._args_length; i++) {\n-    VMReg reg = conv._arg_regs[i];\n-    if (reg->is_Register()) {\n-      result_size += 8;\n-    } else if (reg->is_XMMRegister()) {\n-      \/\/ Java API doesn't support vector args\n-      result_size += 16;\n-    }\n-    \/\/ do nothing for stack\n-  }\n-  return result_size;\n-}\n-\n-static int compute_res_save_area_size(const CallRegs& conv) {\n-  int result_size = 0;\n-  for (int i = 0; i < conv._rets_length; i++) {\n-    VMReg reg = conv._ret_regs[i];\n-    if (reg->is_Register()) {\n-      result_size += 8;\n-    } else if (reg->is_XMMRegister()) {\n-      \/\/ Java API doesn't support vector args\n-      result_size += 16;\n-    } else {\n-      ShouldNotReachHere(); \/\/ unhandled type\n-    }\n-  }\n-  return result_size;\n-}\n-\n-static void save_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n-  int offset = res_save_area_offset;\n-  __ block_comment(\"{ save java result \");\n-  for (int i = 0; i < conv._rets_length; i++) {\n-    VMReg reg = conv._ret_regs[i];\n-    if (reg->is_Register()) {\n-      __ movptr(Address(rsp, offset), reg->as_Register());\n-      offset += 8;\n-    } else if (reg->is_XMMRegister()) {\n-      \/\/ Java API doesn't support vector args\n-      __ movdqu(Address(rsp, offset), reg->as_XMMRegister());\n-      offset += 16;\n-    } else {\n-      ShouldNotReachHere(); \/\/ unhandled type\n-    }\n-  }\n-  __ block_comment(\"} save java result \");\n-}\n-\n-static void restore_java_result(MacroAssembler* _masm, const CallRegs& conv, int res_save_area_offset) {\n-  int offset = res_save_area_offset;\n-  __ block_comment(\"{ restore java result \");\n-  for (int i = 0; i < conv._rets_length; i++) {\n-    VMReg reg = conv._ret_regs[i];\n-    if (reg->is_Register()) {\n-      __ movptr(reg->as_Register(), Address(rsp, offset));\n-      offset += 8;\n-    } else if (reg->is_XMMRegister()) {\n-      \/\/ Java API doesn't support vector args\n-      __ movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n-      offset += 16;\n-    } else {\n-      ShouldNotReachHere(); \/\/ unhandled type\n-    }\n-  }\n-  __ block_comment(\"} restore java result \");\n-}\n-\n@@ -549,41 +167,0 @@\n-\n-static void shuffle_arguments(MacroAssembler* _masm, const GrowableArray<ArgMove>& arg_moves) {\n-  for (int i = 0; i < arg_moves.length(); i++) {\n-    ArgMove arg_mv = arg_moves.at(i);\n-    BasicType arg_bt     = arg_mv.bt;\n-    VMRegPair from_vmreg = arg_mv.from;\n-    VMRegPair to_vmreg   = arg_mv.to;\n-\n-    assert(\n-      !((from_vmreg.first()->is_Register() && to_vmreg.first()->is_XMMRegister())\n-      || (from_vmreg.first()->is_XMMRegister() && to_vmreg.first()->is_Register())),\n-       \"move between gp and fp reg not supported\");\n-\n-    __ block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n-    switch (arg_bt) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-       __ move32_64(from_vmreg, to_vmreg);\n-       break;\n-\n-      case T_FLOAT:\n-        __ float_move(from_vmreg, to_vmreg);\n-        break;\n-\n-      case T_DOUBLE:\n-        __ double_move(from_vmreg, to_vmreg);\n-        break;\n-\n-      case T_LONG :\n-        __ long_move(from_vmreg, to_vmreg);\n-        break;\n-\n-      default:\n-        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n-    }\n-  }\n-}\n-\n@@ -594,2 +171,6 @@\n-address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry, jobject jabi, jobject jconv) {\n-  ResourceMark rm;\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry,\n+                                                                  BasicType* in_sig_bt, int total_in_args,\n+                                                                  BasicType* out_sig_bt, int total_out_args,\n+                                                                  BasicType ret_type,\n+                                                                  jobject jabi, jobject jconv,\n+                                                                  bool needs_return_buffer, int ret_buf_size) {\n@@ -597,2 +178,1 @@\n-  const CallRegs conv = ForeignGlobals::parse_call_regs(jconv);\n-  assert(conv._rets_length <= 1, \"no multi reg returns\");\n+  const CallRegs call_regs = ForeignGlobals::parse_call_regs(jconv);\n@@ -601,2 +181,6 @@\n-  int register_size = sizeof(uintptr_t);\n-  int buffer_alignment = xmm_reg_size;\n+  Register shuffle_reg = rbx;\n+  JavaCallConv out_conv;\n+  NativeCallConv in_conv(call_regs._arg_regs, call_regs._args_length);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n+  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n+  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n@@ -604,5 +188,8 @@\n-  int out_arg_area = -1;\n-  BasicType ret_type;\n-  GrowableArray<ArgMove> arg_moves = compute_argument_shuffle(entry, out_arg_area, conv, ret_type);\n-  assert(out_arg_area != -1, \"Should have been set\");\n-  DEBUG_ONLY(print_arg_moves(arg_moves, entry);)\n+#ifdef ASSERT\n+  LogTarget(Trace, panama) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    arg_shuffle.print_on(&ls);\n+  }\n+#endif\n@@ -617,0 +204,1 @@\n+<<<<<<< HEAD\n@@ -624,0 +212,12 @@\n+=======\n+  RegSpiller arg_spilller(call_regs._arg_regs, call_regs._args_length);\n+  RegSpiller result_spiller(call_regs._ret_regs, call_regs._rets_length);\n+  \/\/ To spill receiver during deopt\n+  int deopt_spill_size = 1 * BytesPerWord;\n+\n+  int shuffle_area_offset    = 0;\n+  int deopt_spill_offset     = shuffle_area_offset    + out_arg_area;\n+  int res_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int arg_save_area_offset   = res_save_area_offset   + result_spiller.spill_size_bytes();\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_spilller.spill_size_bytes();\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -627,0 +227,6 @@\n+  int ret_buf_offset = -1;\n+  if (needs_return_buffer) {\n+    ret_buf_offset = frame_bottom_offset;\n+    frame_bottom_offset += ret_buf_size;\n+  }\n+\n@@ -635,0 +241,3 @@\n+  \/\/      | (optional)          |\n+  \/\/      | ret_buf             |\n+  \/\/      |---------------------| = ret_buf_offset\n@@ -666,1 +275,1 @@\n-  save_native_arguments(_masm, conv, arg_save_area_offset);\n+  arg_spilller.generate_spill(_masm, arg_save_area_offset);\n@@ -680,3 +289,6 @@\n-  \/\/ TODO merge these somehow\n-  restore_native_arguments(_masm, conv, arg_save_area_offset);\n-  shuffle_arguments(_masm, arg_moves);\n+  arg_spilller.generate_fill(_masm, arg_save_area_offset);\n+  if (needs_return_buffer) {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(abi._ret_buf_addr_reg, Address(rsp, ret_buf_offset));\n+  }\n+  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n@@ -696,1 +308,46 @@\n-  save_java_result(_masm, conv, res_save_area_offset);\n+  \/\/ return value shuffle\n+  if (!needs_return_buffer) {\n+#ifdef ASSERT\n+    if (call_regs._rets_length == 1) { \/\/ 0 or 1\n+      VMReg j_expected_result_reg;\n+      switch (ret_type) {\n+        case T_BOOLEAN:\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_CHAR:\n+        case T_INT:\n+        case T_LONG:\n+        j_expected_result_reg = rax->as_VMReg();\n+        break;\n+        case T_FLOAT:\n+        case T_DOUBLE:\n+          j_expected_result_reg = xmm0->as_VMReg();\n+          break;\n+        default:\n+          fatal(\"unexpected return type: %s\", type2name(ret_type));\n+      }\n+      \/\/ No need to move for now, since CallArranger can pick a return type\n+      \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+      assert(call_regs._ret_regs[0] == j_expected_result_reg,\n+      \"unexpected result register: %s != %s\", call_regs._ret_regs[0]->name(), j_expected_result_reg->name());\n+    }\n+#endif\n+  } else {\n+    assert(ret_buf_offset != -1, \"no return buffer allocated\");\n+    __ lea(rscratch1, Address(rsp, ret_buf_offset));\n+    int offset = 0;\n+    for (int i = 0; i < call_regs._rets_length; i++) {\n+      VMReg reg = call_regs._ret_regs[i];\n+      if (reg->is_Register()) {\n+        __ movptr(reg->as_Register(), Address(rscratch1, offset));\n+        offset += 8;\n+      } else if (reg->is_XMMRegister()) {\n+        __ movdqu(reg->as_XMMRegister(), Address(rscratch1, offset));\n+        offset += 16;\n+      } else {\n+        ShouldNotReachHere();\n+      }\n+    }\n+  }\n+\n+  result_spiller.generate_spill(_masm, res_save_area_offset);\n@@ -708,28 +365,1 @@\n-  restore_java_result(_masm, conv, res_save_area_offset);\n-\n-  \/\/ return value shuffle\n-#ifdef ASSERT\n-  if (conv._rets_length == 1) { \/\/ 0 or 1\n-    VMReg j_expected_result_reg;\n-    switch (ret_type) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-      case T_LONG:\n-       j_expected_result_reg = rax->as_VMReg();\n-       break;\n-      case T_FLOAT:\n-      case T_DOUBLE:\n-        j_expected_result_reg = xmm0->as_VMReg();\n-        break;\n-      default:\n-        fatal(\"unexpected return type: %s\", type2name(ret_type));\n-    }\n-    \/\/ No need to move for now, since CallArranger can pick a return type\n-    \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n-    assert(conv._ret_regs[0] == j_expected_result_reg,\n-     \"unexpected result register: %s != %s\", conv._ret_regs[0]->name(), j_expected_result_reg->name());\n-  }\n-#endif\n+  result_spiller.generate_fill(_masm, res_save_area_offset);\n@@ -771,1 +401,6 @@\n-  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, in_ByteSize(frame_data_offset));\n+  OptimizedEntryBlob* blob\n+    = OptimizedEntryBlob::create(name,\n+                                 &buffer,\n+                                 exception_handler_offset,\n+                                 receiver,\n+                                 in_ByteSize(frame_data_offset));\n@@ -775,1 +410,0 @@\n-    Disassembler::decode(blob, tty);\n@@ -781,4 +415,0 @@\n-\n-bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n-  return true;\n-}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":104,"deletions":474,"binary":false,"changes":578,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+<<<<<<< HEAD\n@@ -135,0 +136,3 @@\n+=======\n+     * @param addedLayouts the argument layouts to append.\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -139,0 +143,1 @@\n+<<<<<<< HEAD\n@@ -145,0 +150,9 @@\n+=======\n+        Objects.requireNonNull(addedLayouts);\n+        Arrays.stream(addedLayouts).forEach(Objects::requireNonNull);\n+        if (index < 0 || index > argLayouts.size())\n+            throw new IllegalArgumentException(\"Index out of bounds: \" + index);\n+        List<MemoryLayout> newLayouts = new ArrayList<>(argLayouts.size() + addedLayouts.length);\n+        newLayouts.addAll(argLayouts.subList(0, index));\n+        newLayouts.addAll(List.of(addedLayouts));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.foreign.Utils;\n@@ -45,0 +49,2 @@\n+    private final ABIDescriptor abi;\n+\n@@ -53,1 +59,2 @@\n-    public CallingSequenceBuilder(boolean forUpcall) {\n+    public CallingSequenceBuilder(ABIDescriptor abi, boolean forUpcall) {\n+        this.abi = abi;\n@@ -59,0 +66,1 @@\n+<<<<<<< HEAD\n@@ -63,0 +71,3 @@\n+=======\n+        addArgumentBinding(inputBindings.size(), carrier, layout, bindings);\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -66,0 +77,7 @@\n+    private void addArgumentBinding(int index, Class<?> carrier, MemoryLayout layout, List<Binding> bindings) {\n+        verifyBindings(true, carrier, bindings);\n+        inputBindings.add(index, bindings);\n+        mt = mt.insertParameterTypes(index, carrier);\n+        desc = desc.insertArgumentLayouts(index, layout);\n+    }\n+\n@@ -80,0 +98,6 @@\n+    private boolean needsReturnBuffer() {\n+        return outputBindings.stream()\n+            .filter(Binding.Move.class::isInstance)\n+            .count() > 1;\n+    }\n+\n@@ -81,1 +105,47 @@\n-        return new CallingSequence(mt, desc, isTrivial, inputBindings, outputBindings);\n+        boolean needsReturnBuffer = needsReturnBuffer();\n+        long returnBufferSize = needsReturnBuffer ? computeReturnBuferSize() : 0;\n+        long allocationSize = computeAllocationSize() + returnBufferSize;\n+        if (!forUpcall) {\n+            addArgumentBinding(0, NativeSymbol.class, ValueLayout.ADDRESS, List.of(\n+                Binding.unboxAddress(NativeSymbol.class),\n+                Binding.vmStore(abi.targetAddrStorage(), long.class)));\n+            if (needsReturnBuffer) {\n+                addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                    Binding.unboxAddress(MemorySegment.class),\n+                    Binding.vmStore(abi.retBufAddrStorage(), long.class)));\n+            }\n+        } else if (needsReturnBuffer) { \/\/ forUpcall == true\n+            addArgumentBinding(0, MemorySegment.class, ValueLayout.ADDRESS, List.of(\n+                Binding.vmLoad(abi.retBufAddrStorage(), long.class),\n+                Binding.boxAddress(),\n+                Binding.toSegment(returnBufferSize)));\n+        }\n+        return new CallingSequence(mt, desc, isTrivial, needsReturnBuffer, returnBufferSize, allocationSize, inputBindings, outputBindings);\n+    }\n+\n+    private long computeAllocationSize() {\n+        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n+        \/\/ starting address of the allocator might be un-aligned.\n+        long size = 0;\n+        for (List<Binding> bindings : inputBindings) {\n+            for (Binding b : bindings) {\n+                if (b instanceof Binding.Copy copy) {\n+                    size = Utils.alignUp(size, copy.alignment());\n+                    size += copy.size();\n+                } else if (b instanceof Binding.Allocate allocate) {\n+                    size = Utils.alignUp(size, allocate.alignment());\n+                    size += allocate.size();\n+                }\n+            }\n+        }\n+        return size;\n+    }\n+\n+    private long computeReturnBuferSize() {\n+        return outputBindings.stream()\n+                .filter(Binding.Move.class::isInstance)\n+                .map(Binding.Move.class::cast)\n+                .map(Binding.Move::storage)\n+                .map(VMStorage::type)\n+                .mapToLong(abi.arch::typeSize)\n+                .sum();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":72,"deletions":2,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+<<<<<<< HEAD\n@@ -50,0 +51,2 @@\n+=======\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -61,0 +64,15 @@\n+<<<<<<< HEAD\n+=======\n+\/*\n+ * @test id=stack\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcall\n+ *\n+ * @run testng\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ *   --enable-native-access=ALL-UNNAMED -Dgenerator.sample.factor=17\n+ *   -DUPCALL_TEST_TYPE=STACK\n+ *   TestUpcall\n+ *\/\n+\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -84,0 +102,1 @@\n+import java.util.stream.Stream;\n@@ -88,1 +107,0 @@\n-\n@@ -93,2 +111,2 @@\n-        NO_SCOPE,\n-        ASYNC\n+        ASYNC,\n+        STACK\n@@ -101,0 +119,1 @@\n+        System.loadLibrary(\"TestUpcallStack\");\n@@ -114,1 +133,1 @@\n-                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class, int.class));\n@@ -155,0 +174,1 @@\n+\n@@ -183,0 +203,20 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcallsStack(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.STACK);\n+\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        NativeSymbol addr = LOOKUP.lookup(\"s\" + fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, functionStack(ret, paramTypes, fields));\n+            Object[] args = makeArgsStack(scope, ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n+    }\n+\n@@ -189,3 +229,3 @@\n-                abi.downcallHandle(\n-                    LOOKUP.lookup(symbol).orElseThrow(),\n-                        FunctionDescriptor.ofVoid(C_POINTER)));\n+                    abi.downcallHandle(\n+                            LOOKUP.lookup(symbol).orElseThrow(),\n+                            FunctionDescriptor.ofVoid(C_POINTER)));\n@@ -206,0 +246,4 @@\n+    static FunctionDescriptor functionStack(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n+        return function(ret, params, fields, STACK_PREFIX_LAYOUTS);\n+    }\n+\n@@ -207,0 +251,4 @@\n+        return function(ret, params, fields, List.of());\n+    }\n+\n+    static FunctionDescriptor function(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<MemoryLayout> prefix) {\n@@ -209,1 +257,1 @@\n-        MemoryLayout[] layouts = paramLayouts.toArray(new MemoryLayout[0]);\n+        MemoryLayout[] layouts = Stream.concat(prefix.stream(), paramLayouts.stream()).toArray(MemoryLayout[]::new);\n@@ -212,1 +260,5 @@\n-                FunctionDescriptor.of(layouts[0], layouts);\n+                FunctionDescriptor.of(layouts[prefix.size()], layouts);\n+    }\n+\n+    static Object[] makeArgsStack(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, STACK_PREFIX_LAYOUTS);\n@@ -216,1 +268,9 @@\n-        Object[] args = new Object[params.size() + 1];\n+        return makeArgs(scope, ret, params, fields, checks, argChecks, List.of());\n+    }\n+\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) throws ReflectiveOperationException {\n+        Object[] args = new Object[prefix.size() + params.size() + 1];\n+        int argNum = 0;\n+        for (MemoryLayout layout : prefix) {\n+            args[argNum++] = makeArg(layout, null, false);\n+        }\n@@ -218,1 +278,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n+            args[argNum++] = makeArg(params.get(i).layout(fields), checks, i == 0);\n@@ -220,1 +280,1 @@\n-        args[params.size()] = makeCallback(scope, ret, params, fields, checks, argChecks);\n+        args[argNum] = makeCallback(scope, ret, params, fields, checks, argChecks, prefix);\n@@ -224,2 +284,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemoryLayout> prefix) {\n@@ -231,2 +290,6 @@\n-        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box);\n-        mh = mh.asCollector(Object[].class, params.size());\n+        MethodHandle mh = insertArguments(PASS_AND_SAVE, 1, box, prefix.size());\n+        mh = mh.asCollector(Object[].class, prefix.size() + params.size());\n+\n+        for(int i = 0; i < prefix.size(); i++) {\n+            mh = mh.asType(mh.type().changeParameterType(i, carrier(prefix.get(i), false)));\n+        }\n@@ -238,1 +301,1 @@\n-            mh = mh.asType(mh.type().changeParameterType(i, carrier));\n+            mh = mh.asType(mh.type().changeParameterType(prefix.size() + i, carrier));\n@@ -240,1 +303,1 @@\n-            final int finalI = i;\n+            final int finalI = prefix.size() + i;\n@@ -253,1 +316,1 @@\n-            checks.add(o -> assertStructEquals((MemorySegment) box.get()[0], (MemorySegment) o, firstlayout));\n+            checks.add(o -> assertStructEquals((MemorySegment) box.get()[prefix.size()], (MemorySegment) o, firstlayout));\n@@ -255,1 +318,1 @@\n-            checks.add(o -> assertEquals(o, box.get()[0]));\n+            checks.add(o -> assertEquals(o, box.get()[prefix.size()]));\n@@ -260,1 +323,1 @@\n-        MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);\n+        MemoryLayout[] paramLayouts = Stream.concat(prefix.stream(), params.stream().map(p -> p.layout(fields))).toArray(MemoryLayout[]::new);\n@@ -267,1 +330,1 @@\n-    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref) {\n+    static Object passAndSave(Object[] o, AtomicReference<Object[]> ref, int retArg) {\n@@ -277,1 +340,1 @@\n-        return o[0];\n+        return o[retArg];\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":86,"deletions":23,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -47,0 +48,1 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -64,0 +66,1 @@\n+<<<<<<< HEAD\n@@ -66,0 +69,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -68,0 +75,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -91,0 +99,1 @@\n+<<<<<<< HEAD\n@@ -93,0 +102,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -95,3 +108,4 @@\n-                { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n-                  bufferLoad(8, int.class), vmStore(rsi, int.class)},\n-                { vmStore(rax, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n+              bufferLoad(8, int.class), vmStore(rsi, int.class)},\n+            { vmStore(rax, long.class) },\n@@ -121,0 +135,1 @@\n+<<<<<<< HEAD\n@@ -123,0 +138,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -125,3 +144,4 @@\n-                { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n-                        bufferLoad(8, long.class), vmStore(rsi, long.class)},\n-                { vmStore(rax, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(rdi, long.class),\n+                    bufferLoad(8, long.class), vmStore(rsi, long.class)},\n+            { vmStore(rax, long.class) },\n@@ -150,0 +170,1 @@\n+<<<<<<< HEAD\n@@ -152,0 +173,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -154,3 +179,4 @@\n-                { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                        bufferLoad(8, long.class), vmStore(stackStorage(1), long.class)},\n-                { vmStore(rax, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class)},\n+            { vmStore(rax, long.class) },\n@@ -179,0 +205,1 @@\n+<<<<<<< HEAD\n@@ -181,0 +208,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -183,3 +214,4 @@\n-                { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                        bufferLoad(8, int.class), vmStore(stackStorage(1), int.class)},\n-                { vmStore(rax, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(8, int.class), vmStore(stackStorage(1), int.class)},\n+            { vmStore(rax, long.class) },\n@@ -203,0 +235,1 @@\n+<<<<<<< HEAD\n@@ -205,0 +238,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -207,0 +244,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -233,0 +271,1 @@\n+<<<<<<< HEAD\n@@ -235,0 +274,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -237,0 +280,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -267,0 +311,1 @@\n+<<<<<<< HEAD\n@@ -269,0 +314,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -271,0 +320,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -323,0 +373,1 @@\n+<<<<<<< HEAD\n@@ -325,0 +376,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -327,0 +382,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -365,0 +421,1 @@\n+<<<<<<< HEAD\n@@ -367,0 +424,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -369,0 +430,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -386,0 +448,1 @@\n+<<<<<<< HEAD\n@@ -388,0 +451,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -390,0 +457,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -444,0 +512,1 @@\n+<<<<<<< HEAD\n@@ -446,0 +515,4 @@\n+=======\n+        assertEquals(callingSequence.methodType(), mt.appendParameterTypes(long.class).insertParameterTypes(0, MemorySegment.class, NativeSymbol.class));\n+        assertEquals(callingSequence.functionDesc(), fd.appendArgumentLayouts(C_LONG).insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+>>>>>>> 43478b9bdbeb2c827b89ae4ac369805bb0641fd6\n@@ -448,0 +521,2 @@\n+            { unboxAddress(MemorySegment.class), vmStore(r11, long.class) },\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n@@ -474,2 +549,2 @@\n-        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, MemoryAddress.class, long.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(C_POINTER, C_LONG));\n+        assertEquals(callingSequence.methodType(), MethodType.methodType(void.class, NativeSymbol.class, MemoryAddress.class, long.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER, C_LONG));\n@@ -478,0 +553,1 @@\n+            { unboxAddress(NativeSymbol.class), vmStore(r10, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":90,"deletions":14,"binary":false,"changes":104,"status":"modified"}]}