{"files":[{"patch":"@@ -82,0 +82,1 @@\n+class RuntimeStub; \/\/ for as_runtime_stub()\n@@ -151,1 +152,1 @@\n-  virtual bool is_optimized_entry_blob() const                  { return false; }\n+  virtual bool is_optimized_entry_blob() const        { return false; }\n@@ -160,6 +161,7 @@\n-  nmethod* as_nmethod_or_null()                { return is_nmethod() ? (nmethod*) this : NULL; }\n-  nmethod* as_nmethod()                        { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n-  CompiledMethod* as_compiled_method_or_null() { return is_compiled() ? (CompiledMethod*) this : NULL; }\n-  CompiledMethod* as_compiled_method()         { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n-  CodeBlob* as_codeblob_or_null() const        { return (CodeBlob*) this; }\n-  OptimizedEntryBlob* as_optimized_entry_blob() const             { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n+  nmethod* as_nmethod_or_null()                       { return is_nmethod() ? (nmethod*) this : NULL; }\n+  nmethod* as_nmethod()                               { assert(is_nmethod(), \"must be nmethod\"); return (nmethod*) this; }\n+  CompiledMethod* as_compiled_method_or_null()        { return is_compiled() ? (CompiledMethod*) this : NULL; }\n+  CompiledMethod* as_compiled_method()                { assert(is_compiled(), \"must be compiled\"); return (CompiledMethod*) this; }\n+  CodeBlob* as_codeblob_or_null() const               { return (CodeBlob*) this; }\n+  OptimizedEntryBlob* as_optimized_entry_blob() const { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n+  RuntimeStub* as_runtime_stub() const                { assert(is_runtime_stub(), \"must be runtime blob\"); return (RuntimeStub*) this; }\n@@ -515,0 +517,2 @@\n+  static void free(RuntimeStub* stub) { RuntimeBlob::free(stub); }\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -108,0 +108,10 @@\n+JNI_ENTRY(jboolean, NEP_freeInvoker(JNIEnv* env, jclass _unused, jlong invoker))\n+  \/\/ safe to call without code cache lock, because stub is always alive\n+  CodeBlob* cb = CodeCache::find_blob((char*) invoker);\n+  if (cb == nullptr) {\n+    return false;\n+  }\n+  RuntimeStub::free(cb->as_runtime_stub());\n+  return true;\n+JNI_END\n+\n@@ -116,0 +126,1 @@\n+  {CC \"freeInvoker0\", CC \"(J)Z\", FN_PTR(NEP_freeInvoker)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import java.lang.ref.SoftReference;\n-import java.util.Map;\n@@ -42,2 +40,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Function;\n@@ -81,29 +77,0 @@\n-    private static class SoftReferenceCache<K, V> {\n-        private final Map<K, Node> cache = new ConcurrentHashMap<>();\n-\n-        public V get(K key, Function<K, V> valueFactory) {\n-            return cache\n-                    .computeIfAbsent(key, k -> new Node()) \/\/ short lock (has to be according to ConcurrentHashMap)\n-                    .get(key, valueFactory); \/\/ long lock, but just for the particular key\n-        }\n-\n-        private class Node {\n-            private SoftReference<V> ref;\n-\n-            public Node() {\n-            }\n-\n-            public V get(K key, Function<K, V> valueFactory) {\n-                V result;\n-                if (ref == null || (result = ref.get()) == null) {\n-                    synchronized (this) { \/\/ don't let threads race on the valueFactory::apply call\n-                        if (ref == null || (result = ref.get()) == null) {\n-                            result = valueFactory.apply(key); \/\/ keep alive\n-                            ref = new SoftReference<>(result);\n-                        }\n-                    }\n-                }\n-                return result;\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.ref.CleanerFactory;\n+\n@@ -29,0 +31,1 @@\n+import java.lang.ref.Cleaner;\n@@ -31,2 +34,0 @@\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -45,1 +46,2 @@\n-    private static final Map<CacheKey, Long> INVOKER_CACHE = new ConcurrentHashMap<>();\n+    private static final Cleaner CLEANER = CleanerFactory.cleaner();\n+    private static final SoftReferenceCache<CacheKey, NativeEntryPoint> INVOKER_CACHE = new SoftReferenceCache<>();\n@@ -66,4 +68,6 @@\n-        long invoker = INVOKER_CACHE.computeIfAbsent(key, k ->\n-            makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer));\n-\n-        return new NativeEntryPoint(methodType, invoker);\n+        return INVOKER_CACHE.get(key, k -> {\n+            long invoker = makeInvoker(methodType, abi, argMoves, returnMoves, needsReturnBuffer);\n+            NativeEntryPoint nep = new NativeEntryPoint(methodType, invoker);\n+            CLEANER.register(nep, () -> freeInvoker(invoker));\n+            return nep;\n+        });\n@@ -76,0 +80,7 @@\n+    private static native boolean freeInvoker0(long invoker);\n+    private static void freeInvoker(long invoker) {\n+        if (!freeInvoker0(invoker)) {\n+            throw new InternalError(\"Could not free invoker\");\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+import java.lang.ref.SoftReference;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+class SoftReferenceCache<K, V> {\n+    private final Map<K, Node> cache = new ConcurrentHashMap<>();\n+\n+    public V get(K key, Function<K, V> valueFactory) {\n+        return cache\n+                .computeIfAbsent(key, k -> new Node()) \/\/ short lock (has to be according to ConcurrentHashMap)\n+                .get(key, valueFactory); \/\/ long lock, but just for the particular key\n+    }\n+\n+    private class Node {\n+        private SoftReference<V> ref;\n+\n+        public Node() {\n+        }\n+\n+        public V get(K key, Function<K, V> valueFactory) {\n+            V result;\n+            if (ref == null || (result = ref.get()) == null) {\n+                synchronized (this) { \/\/ don't let threads race on the valueFactory::apply call\n+                    if (ref == null || (result = ref.get()) == null) {\n+                        result = valueFactory.apply(key); \/\/ keep alive\n+                        ref = new SoftReference<>(result);\n+                    }\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SoftReferenceCache.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}