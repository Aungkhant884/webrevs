{"files":[{"patch":"@@ -43,1 +43,1 @@\n- * A foreign linker specializing for C Application Binary Interface (ABI) calling conventions.\n+ * A C linker implements the C Application Binary Interface (ABI) calling conventions.\n@@ -47,1 +47,1 @@\n- * There are two components that go into linking a foreign function: a method type, and\n+ * Linking a foreign function is a process which requires two components: a method type, and\n@@ -52,2 +52,0 @@\n- * Memory layout attributes are used in the function descriptor to attach ABI classification meta-data to memory layouts,\n- * which are required for linking.\n@@ -68,2 +66,2 @@\n- * The function descriptor used in linking contains a memory layout to match each carrier type.\n- * There are some restrictions on the carrier type and memory layout combinations that are allowed:\n+ * For the linking process to be successful, some requirements must be satisfied; if {@code M} and {@code F} are\n+ * the method type and the function descriptor, respectively, used during the linking process, then it must be that:\n@@ -71,13 +69,15 @@\n- *   <li>If a primitve type is used as a carrier type, the corresponding\n- *   memory layout must be a {@code ValueLayout}, and the bit size of the layout must match that of the carrier type\n- *   (see {@link Integer#SIZE} and similar fields in other primitive wrapper classes).<\/li>\n- *\n- *   <li>If the carrier type is {@code MemoryAddress}, then the corresponding memory layout must be a\n- *   {@code ValueLayout}, and its bit size must match the platform's address size (see {@link MemoryLayouts#ADDRESS}).\n- *   For this purpose, {@link CLinker#C_POINTER} can  be used<\/li>\n- *\n- *   <li>If the carrier type is {@code MemorySegment}, then the corresponding memory layout must be a\n- *   {@code GroupLayout}<\/li>\n- *\n- *   <li>If the carrier type is {@code VaList}, then the corresponding memory layout must be\n- *   {@link CLinker#C_VA_LIST}<\/li>\n+ *     <li>The arity of {@code M} is the same as that of {@code F};<\/li>\n+ *     <li>If the return type of {@code M} is {@code void}, then {@code F} should have no return layout\n+ *     (see {@link FunctionDescriptor#ofVoid(MemoryLayout...)});<\/li>\n+ *     <li>for each pair of carrier type {@code C} and layout {@code L} in {@code M} and {@code F}, respectively,\n+ *     where {@code C} and {@code L} refer to the same argument, or to the return value, the following conditions must hold:\n+ *     <ul>\n+ *       <li>If {@code C} is a primitve type, then {@code L} must be a {@code ValueLayout}, and the size of the layout must match\n+ *       that of the carrier type (see {@link Integer#SIZE} and similar fields in other primitive wrapper classes);<\/li>\n+ *       <li>If {@code C} is {@code MemoryAddress.class}, then {@code L} must be a {@code ValueLayout}, and its size must match\n+ *       the platform's address size (see {@link MemoryLayouts#ADDRESS}). For this purpose, the {@link CLinker#C_POINTER} layout\n+ *       constant can  be used;<\/li>\n+ *       <li>If {@code C} is {@code MemorySegment.class}, then {@code L} must be a {@code GroupLayout}<\/li>\n+ *       <li>If {@code C} is {@code VaList.class}, then {@code L} must be {@link CLinker#C_VA_LIST}<\/li>\n+ *     <\/ul>\n+ *     <\/li>\n@@ -91,2 +91,2 @@\n- * passed as a variadic argument, an explicit carrier type and memory layout must be present in the method type and\n- * function descriptor when linking the function. Furthermore, as memory layouts corresponding to variadic arguments in\n+ * passed as a variadic argument, an explicit, additional, carrier type and memory layout must be present in the method type and\n+ * function descriptor objects passed to the linker. Furthermore, as memory layouts corresponding to variadic arguments in\n@@ -95,1 +95,1 @@\n- * argument in a specialized function descriptor\n+ * argument in a specialized function descriptor.\n@@ -97,1 +97,1 @@\n- * @apiNote In the future, if the Java language permits, {@link MemoryLayout}\n+ * @apiNote In the future, if the Java language permits, {@link CLinker}\n@@ -648,1 +648,1 @@\n-         * @apiNote In the future, if the Java language permits, {@link MemoryLayout}\n+         * @apiNote In the future, if the Java language permits, {@link Builder}\n@@ -762,1 +762,1 @@\n-        public boolean isIntergral() {\n+        public boolean isIntegral() {\n@@ -772,1 +772,1 @@\n-            return !isIntergral() && !isPointer();\n+            return !isIntegral() && !isPointer();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * This class provides a scope of given size, within which several allocations can be performed. An native scope is backed\n+ * This class provides a scope, within which several allocations can be performed. An native scope is backed\n@@ -43,2 +43,2 @@\n- * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate the values it needs,\n- * using a <em>bounded<\/em> native scope will typically provide better performances than independently allocating the memory\n+ * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate,\n+ * then using a <em>bounded<\/em> native scope will typically provide better performances than independently allocating the memory\n@@ -49,1 +49,2 @@\n- * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope.\n+ * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope's\n+ * owner thread.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n- * provides linking capabilities which allow to model foreign functions as {@link jdk.incubator.foreign.MemoryHandles} instance,\n+ * provides linking capabilities which allow to model foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -121,1 +121,1 @@\n- * Here, we lookup the {@code strlen} symbol in the <em>default<\/em> library lookup (see {@link jdk.incubator.foreign.LibraryLookup#ofDefault()}.\n+ * Here, we lookup the {@code strlen} symbol in the <em>default<\/em> library lookup (see {@link jdk.incubator.foreign.LibraryLookup#ofDefault()}).\n@@ -177,1 +177,1 @@\n- * The {@link jdk.incubator.foreign.CLinker} class also allows to turn an existing method handle (which might point\n+ * The {@link jdk.incubator.foreign.CLinker} interface also allows to turn an existing method handle (which might point\n@@ -201,1 +201,1 @@\n- * Now that we have a method handle instance, we can link it into a fresh native memory segment, using the {@link jdk.incubator.foreign.CLinker} class, as follows:\n+ * Now that we have a method handle instance, we can link it into a fresh native memory segment, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n@@ -212,1 +212,1 @@\n- * sequence of steps which will allow foreign code to call the {@code intCompareHandle} according to the rules specified\n+ * sequence of steps which will allow foreign code to call {@code intCompareHandle} according to the rules specified\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}