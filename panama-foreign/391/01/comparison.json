{"files":[{"patch":"@@ -180,0 +180,7 @@\n+  \/\/ No need in interpreter entry for linkToNative for now.\n+  \/\/ Interpreter calls compiled entry through i2c.\n+  if (iid == vmIntrinsics::_linkToNative) {\n+    __ hlt(0);\n+    return NULL;\n+  }\n+\n@@ -274,1 +281,4 @@\n-  if (iid == vmIntrinsics::_invokeBasic) {\n+  if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {\n+    if (iid == vmIntrinsics::_linkToNative) {\n+      assert(for_compiler_entry, \"only compiler entry is supported\");\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1197,1 +1197,1 @@\n-  } else if (iid == vmIntrinsics::_invokeBasic) {\n+  } else if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2632,1 +2632,4 @@\n-    if (call_addr == NULL) return NULL;\n+    if (call_addr == NULL) {\n+      C->record_failure(\"native invoker not implemented on this platform\");\n+      return NULL;\n+    }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1684,1 +1684,1 @@\n-      assert(!is_mcall || (call_returns[block->_pre_order] == (uint) current_offset), \"ret_addr_offset() did not match size of emitted code\");\n+      assert(!is_mcall || (call_returns[block->_pre_order] <= (uint) current_offset), \"ret_addr_offset() not within emitted code\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @requires os.arch==\"amd64\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}